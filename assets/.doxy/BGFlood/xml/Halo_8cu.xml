<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="Halo_8cu" kind="file" language="C++">
    <compoundname>Halo.cu</compoundname>
    <includes refid="Halo_8h" local="yes">Halo.h</includes>
    <incdepgraph>
      <node id="27">
        <label>Arrays.h</label>
        <link refid="Arrays_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
      </node>
      <node id="45">
        <label>Boundary.h</label>
        <link refid="Boundary_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
      </node>
      <node id="46">
        <label>ConserveElevation.h</label>
        <link refid="ConserveElevation_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
      </node>
      <node id="29">
        <label>Forcing.h</label>
        <link refid="Forcing_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
      </node>
      <node id="3">
        <label>General.h</label>
        <link refid="General_8h_source"/>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
        <childnode refid="16" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
        <childnode refid="19" relation="include">
        </childnode>
        <childnode refid="20" relation="include">
        </childnode>
        <childnode refid="21" relation="include">
        </childnode>
        <childnode refid="22" relation="include">
        </childnode>
      </node>
      <node id="42">
        <label>Gradients.h</label>
        <link refid="Gradients_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
      <node id="33">
        <label>GridManip.h</label>
        <link refid="GridManip_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>src/Halo.cu</label>
        <link refid="Halo_8cu"/>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>Halo.h</label>
        <link refid="Halo_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="28" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="45" relation="include">
        </childnode>
        <childnode refid="46" relation="include">
        </childnode>
      </node>
      <node id="34">
        <label>InitEvolv.h</label>
        <link refid="InitEvolv_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="35" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
      </node>
      <node id="32">
        <label>InitialConditions.h</label>
        <link refid="InitialConditions_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="34" relation="include">
        </childnode>
        <childnode refid="42" relation="include">
        </childnode>
        <childnode refid="43" relation="include">
        </childnode>
      </node>
      <node id="24">
        <label>Input.h</label>
        <link refid="Input_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="44">
        <label>Kurganov.h</label>
        <link refid="Kurganov_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="43" relation="include">
        </childnode>
      </node>
      <node id="30">
        <label>MemManagement.h</label>
        <link refid="MemManagement_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
      </node>
      <node id="28">
        <label>Mesh.h</label>
        <link refid="Mesh_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="39" relation="include">
        </childnode>
      </node>
      <node id="23">
        <label>Param.h</label>
        <link refid="Param_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
      </node>
      <node id="39">
        <label>Poly.h</label>
        <link refid="Poly_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
      </node>
      <node id="38">
        <label>ReadForcing.h</label>
        <link refid="ReadForcing_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="35" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="39" relation="include">
        </childnode>
      </node>
      <node id="36">
        <label>ReadInput.h</label>
        <link refid="ReadInput_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
      </node>
      <node id="35">
        <label>Read_netcdf.h</label>
        <link refid="Read__netcdf_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="36" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="40" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
      </node>
      <node id="31">
        <label>Setup_GPU.h</label>
        <link refid="Setup__GPU_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="32" relation="include">
        </childnode>
      </node>
      <node id="43">
        <label>Spherical.h</label>
        <link refid="Spherical_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="44" relation="include">
        </childnode>
      </node>
      <node id="41">
        <label>Updateforcing.h</label>
        <link refid="Updateforcing_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="32" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
      </node>
      <node id="26">
        <label>Util_CPU.h</label>
        <link refid="Util__CPU_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
      </node>
      <node id="40">
        <label>Write_netcdf.h</label>
        <link refid="Write__netcdf_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="36" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
      </node>
      <node id="25">
        <label>Write_txtlog.h</label>
        <link refid="Write__txtlog_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
      </node>
      <node id="37">
        <label>utctime.h</label>
        <link refid="utctime_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="36" relation="include">
        </childnode>
      </node>
      <node id="16">
        <label>algorithm</label>
      </node>
      <node id="10">
        <label>chrono</label>
      </node>
      <node id="9">
        <label>cmath</label>
      </node>
      <node id="11">
        <label>ctime</label>
      </node>
      <node id="4">
        <label>cuda_runtime.h</label>
      </node>
      <node id="5">
        <label>device_launch_parameters.h</label>
      </node>
      <node id="19">
        <label>fstream</label>
      </node>
      <node id="18">
        <label>iomanip</label>
      </node>
      <node id="17">
        <label>iostream</label>
      </node>
      <node id="21">
        <label>limits</label>
      </node>
      <node id="14">
        <label>map</label>
      </node>
      <node id="8">
        <label>math.h</label>
      </node>
      <node id="15">
        <label>netcdf.h</label>
      </node>
      <node id="20">
        <label>sstream</label>
      </node>
      <node id="6">
        <label>stdio.h</label>
      </node>
      <node id="7">
        <label>stdlib.h</label>
      </node>
      <node id="12">
        <label>string</label>
      </node>
      <node id="22">
        <label>thread</label>
      </node>
      <node id="13">
        <label>vector</label>
      </node>
    </incdepgraph>
    <sectiondef kind="func">
      <memberdef kind="function" id="Halo_8cu_1a33d2233b52ae274a668055c9075a3901" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void void fillHaloD</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>fillHaloD</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating halos on CPU on every side of a block of a single variable. </para>
        </briefdescription>
        <detaileddescription>
<para>! </para>
<sect2 id="Halo_8cu_1autotoc_md0">
<title>Description</title>
<para>This fuction is a wraping fuction of the halo functions for CPU. It is called from another wraping function to keep things clean. In a sense this is the third (and last) layer of wrapping</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>The block index to work on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to work on </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="16" column="18" bodyfile="src/Halo.cu" bodystart="16" bodyend="28"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a6e2403c1c105317070a7ac8516c5621f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloD&lt; double &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; double &gt; XBlock, double *z)</argsstring>
        <name>fillHaloD&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="29" column="10" declfile="src/Halo.cu" declline="29" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a8c6debda6b888b35798dcaaf5ec95d3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloD&lt; float &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; float &gt; XBlock, float *z)</argsstring>
        <name>fillHaloD&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="30" column="10" declfile="src/Halo.cu" declline="30" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ab0197d939bcfd09fdc7c5807453d9dfc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloC</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>fillHaloC</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating halos for each block of a single variable on CPU. </para>
        </briefdescription>
        <detaileddescription>
<para>! </para>
<sect2 id="Halo_8h_1autotoc_md1">
<title>Description</title>
<para>This function is a wraping fuction of the halo functions on CPU. It is called from the main Halo CPU function. This is layer 2 of 3 wrap so the candy doesn&apos;t stick too much. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to work on </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="43" column="18" bodyfile="src/Halo.cu" bodystart="43" bodyend="51"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a62c3c8912f171794c2aedd471025e4c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloC&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z)</argsstring>
        <name>fillHaloC&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="52" column="10" declfile="src/Halo.cu" declline="52" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a8940bc0632378da915f25ee31de2ed0b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloC&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z)</argsstring>
        <name>fillHaloC&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="53" column="10" declfile="src/Halo.cu" declline="53" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af0f36c2211a044c4891c7fafc9d1b02f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void RecalculateZs</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T *zb)</argsstring>
        <name>RecalculateZs</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>Recalculate water surface after recalculating the values on the halo on the CPU. </para>
        </briefdescription>
        <detaileddescription>
<para>Recalculate water surface after recalculating the values on the halo on the GPU.</para>
<para>! </para>
<sect2 id="Halo_8h_1autotoc_md2">
<title>Description</title>
<para>Recalculate water surface after recalculating the values on the halo on the CPU. zb (bottom elevation) on each halo is calculated at the start of the loop or as part of the initial condition. When conserve-elevation is not required, only h is recalculated on the halo at ever 1/2 steps. <linebreak/>
 zs then needs to be recalculated to obtain a mass-conservative solution (if zs is conserved then mass conservation is not garanteed)</para>
<para><simplesect kind="warning"><para>This function calculate zs everywhere in the block... this is a bit unecessary. Instead it should recalculate only where there is a prolongation or a restiction</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Xev</parametername>
</parameternamelist>
<parameterdescription>
<para>The evolving structure containing the evolving variables </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>The bottom elevation variable </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
! </para>
</sect2>
<sect2 id="Halo_8h_1autotoc_md4">
<title>Description</title>
<para>Recalculate water surface after recalculating the values on the halo on the CPU. zb (bottom elevation) on each halo is calculated at the start of the loop or as part of the initial condition. When conserve-elevation is not required, only h is recalculated on the halo at ever 1/2 steps. zs then needs to be recalculated to obtain a mass-conservative solution (if zs is conserved then mass conservation is not garanteed)</para>
<para><simplesect kind="warning"><para>This function calculate zs everywhere in the block... this is a bit unecessary. Instead it should recalculate only where there is a prolongation or a restiction </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Xev</parametername>
</parameternamelist>
<parameterdescription>
<para>The evolving structure containing the evolving variables </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>The bottom elevation variable </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="72" column="18" bodyfile="src/Halo.cu" bodystart="72" bodyend="107"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a4a179168b1b6ca6d431895fa50ddbc5e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void RecalculateZs&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float *zb)</argsstring>
        <name>RecalculateZs&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="108" column="10" declfile="src/Halo.cu" declline="108" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a4346cbc367125486b54412319cca8521" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void RecalculateZs&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double *zb)</argsstring>
        <name>RecalculateZs&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="109" column="10" declfile="src/Halo.cu" declline="109" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9fd24940e7422244beb1290eee7e01d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void Recalculatehh</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T *zb)</argsstring>
        <name>Recalculatehh</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>Recalculate water depth after recalculating the values on the halo on the CPU. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8h_1autotoc_md3">
<title>Description</title>
<para>Recalculate water depth after recalculating the values on the halo on the CPU. zb (bottom elevation) on each halo is calculated at the start of the loop or as part of the initial condition. When conserve-elevation is not required, only h is recalculated on the halo at ever 1/2 steps. zs then needs to be recalculated to obtain a mass-conservative solution (if zs is conserved then mass conservation is not garanteed) <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Xev</parametername>
</parameternamelist>
<parameterdescription>
<para>The evolving structure containing the evolving variables </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>The bottom elevation variable </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="123" column="18" bodyfile="src/Halo.cu" bodystart="123" bodyend="159"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a86f7fbcf268c15b06de92d94a86676d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void Recalculatehh&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float *zb)</argsstring>
        <name>Recalculatehh&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="160" column="10" declfile="src/Halo.cu" declline="160" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a57466ad6cd9816401644ed33654265f7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void Recalculatehh&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double *zb)</argsstring>
        <name>Recalculatehh&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="161" column="10" declfile="src/Halo.cu" declline="161" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a5ffb16dded1af0f0b9243601ee29db92" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void RecalculateZsGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T *zb)</argsstring>
        <name>RecalculateZsGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="180" column="29" bodyfile="src/Halo.cu" bodystart="180" bodyend="202"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a1375cf89754b41163abe692f5a52f1aa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void RecalculateZsGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float *zb)</argsstring>
        <name>RecalculateZsGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="203" column="21" declfile="src/Halo.cu" declline="203" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a2530753f4e0a860edcdde8a4600d575e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void RecalculateZsGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double *zb)</argsstring>
        <name>RecalculateZsGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="204" column="21" declfile="src/Halo.cu" declline="204" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a96005943eb8cc55515edf93a438bdc15" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloF</definition>
        <argsstring>(Param XParam, bool doProlongation, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>fillHaloF</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating flux in the halos for a block and a single variable on CPU. </para>
        </briefdescription>
        <detaileddescription>
<para>! <xrefsect id="deprecated_1_deprecated000001"><xreftitle>Deprecated</xreftitle><xrefdescription><para>This function is was never sucessful and will never be used. It is fundamentally flawed because is doesn&apos;t preserve the balance of fluxes on the restiction interface. It should be deleted soon.</para>
</xrefdescription></xrefsect></para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="211" column="18" bodyfile="src/Halo.cu" bodystart="211" bodyend="223"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af14f6761d43141eba363350b5f7ad48d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloF&lt; float &gt;</definition>
        <argsstring>(Param XParam, bool doProlongation, BlockP&lt; float &gt; XBlock, float *z)</argsstring>
        <name>fillHaloF&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="224" column="10" declfile="src/Halo.cu" declline="224" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae033bec7214b1e041fbde2fc784da5ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloF&lt; double &gt;</definition>
        <argsstring>(Param XParam, bool doProlongation, BlockP&lt; double &gt; XBlock, double *z)</argsstring>
        <name>fillHaloF&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="225" column="10" declfile="src/Halo.cu" declline="225" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a2ee84ac3de37b97bf6c4a3919f8a355b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T *z)</argsstring>
        <name>fillHaloGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating halos for each block of a single variable on GPU. </para>
        </briefdescription>
        <detaileddescription>
<para>! </para>
<sect2 id="Halo_8h_1autotoc_md5">
<title>Description</title>
<para>This function is a wraping fuction of the halo functions on GPU. It is called from the main Halo GPU function. The present imnplementation is naive and slow one that calls the rather complex fillLeft type functions <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>The cuda stream to use </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to work on </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="239" column="18" bodyfile="src/Halo.cu" bodystart="239" bodyend="260"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a805c1dabf839953debffe2799c61cae0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double *z)</argsstring>
        <name>fillHaloGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="261" column="10" declfile="src/Halo.cu" declline="261" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a20176600a52e8881aa78213c15e1ac4b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float *z)</argsstring>
        <name>fillHaloGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="262" column="10" declfile="src/Halo.cu" declline="262" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9685d8f9a22683d2a5a8ab96abb1f735" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>fillHaloGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating halos for each block of a single variable on GPU. </para>
        </briefdescription>
        <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000002"><xreftitle>Deprecated</xreftitle><xrefdescription></xrefdescription></xrefsect><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>The cuda stream to use </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to work on </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="272" column="18" bodyfile="src/Halo.cu" bodystart="272" bodyend="293"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a34e004e3fbebc9bb46bb634a202ae6d0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z)</argsstring>
        <name>fillHaloGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="294" column="10" declfile="src/Halo.cu" declline="294" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ac2832633400d205ffe4346bbe730d260" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z)</argsstring>
        <name>fillHaloGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="295" column="10" declfile="src/Halo.cu" declline="295" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a29a79939f743cb813160e5cd771480b9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloGPUnew</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T *z)</argsstring>
        <name>fillHaloGPUnew</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating halos for each block of a single variable on GPU. New version. </para>
        </briefdescription>
        <detaileddescription>
<para>! <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>The cuda stream to use </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to work on </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="306" column="18" bodyfile="src/Halo.cu" bodystart="306" bodyend="330"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a824b0c7405c55a3c7add16fb2dbddd7b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPUnew&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double *z)</argsstring>
        <name>fillHaloGPUnew&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="331" column="10" declfile="src/Halo.cu" declline="331" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ad8b7fdfb110e1c442c9c46434ea55a8c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPUnew&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float *z)</argsstring>
        <name>fillHaloGPUnew&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="332" column="10" declfile="src/Halo.cu" declline="332" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae3adb7ce2fbe32053675857784affbe1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloTopRightC</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>fillHaloTopRightC</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating flux for halos for each block of a single variable on GPU. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8h_1autotoc_md6">
<title>Description</title>
<para>This function is a wraping function of the halo flux functions on GPU. It is called from the main Halo GPU function. The present imnplementation is naive and slow one that calls the rather complex fillLeft type functions <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to work on </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>For flux term and actually most terms, only top and right neighbours are needed! </para>
</simplesect>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="346" column="18" bodyfile="src/Halo.cu" bodystart="346" bodyend="365"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a3c209f200fa3e85dfdf772a4e2904049" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloTopRightC&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z)</argsstring>
        <name>fillHaloTopRightC&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="366" column="10" declfile="src/Halo.cu" declline="366" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ac87d50a1edb09efac22b75440d8a67ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloTopRightC&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z)</argsstring>
        <name>fillHaloTopRightC&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="367" column="10" declfile="src/Halo.cu" declline="367" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae5c54a05d63827832b83be828802753f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloLRFluxC</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>fillHaloLRFluxC</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating flux for halos for each block of a single variable on GPU. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to work on </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>For flux term and actually most terms, only top and right neighbours are needed! </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="376" column="18" bodyfile="src/Halo.cu" bodystart="376" bodyend="395"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ad2c3611f0b1922bbf5f31517f9f6e491" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloLRFluxC&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z)</argsstring>
        <name>fillHaloLRFluxC&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="396" column="10" declfile="src/Halo.cu" declline="396" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ab72d57c0f58a2aba8386523e4c311279" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloLRFluxC&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z)</argsstring>
        <name>fillHaloLRFluxC&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="397" column="10" declfile="src/Halo.cu" declline="397" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a0170ca89e35d08a9bd76139bfdd6ff37" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloBTFluxC</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>fillHaloBTFluxC</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating flux for halos for each block of a single variable on GPU. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to work on </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>For flux term and actually most terms, only top and right neighbours are needed! </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="406" column="18" bodyfile="src/Halo.cu" bodystart="406" bodyend="425"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a5b5769495221a888c7c842adb908b5b9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloBTFluxC&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z)</argsstring>
        <name>fillHaloBTFluxC&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="426" column="10" declfile="src/Halo.cu" declline="426" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1accd66463b0299c74894d64c1bb1b202a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloBTFluxC&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z)</argsstring>
        <name>fillHaloBTFluxC&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="427" column="10" declfile="src/Halo.cu" declline="427" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a1933020a5783e090d0c44fffb283e563" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloTopRightGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T *z)</argsstring>
        <name>fillHaloTopRightGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating flux for halos for each block of a single variable on GPU. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information <linebreak/>
 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>The cuda stream to use </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to work on </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>For flux term and actually most terms, only top and right neighbours are needed! </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="438" column="18" bodyfile="src/Halo.cu" bodystart="438" bodyend="455"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a84c9dcd8f96a68563a6ed9f41fddeb9b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloTopRightGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double *z)</argsstring>
        <name>fillHaloTopRightGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="456" column="10" declfile="src/Halo.cu" declline="456" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ac7dd171c00746b296b85d607c2630b32" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloTopRightGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float *z)</argsstring>
        <name>fillHaloTopRightGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="457" column="10" declfile="src/Halo.cu" declline="457" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af347bef69b66f3cc31cfc0e1e61ea971" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloLeftRightGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T *z)</argsstring>
        <name>fillHaloLeftRightGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating for halos for each block of a single variable on GPU. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>The cuda stream to use </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to work on </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>For flux term and actually most terms, only top and right neighbours are needed! </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="468" column="18" bodyfile="src/Halo.cu" bodystart="468" bodyend="485"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af618df69f5fab841b5c52471a217b3ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloLeftRightGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double *z)</argsstring>
        <name>fillHaloLeftRightGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="486" column="10" declfile="src/Halo.cu" declline="486" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ace2d807ee7ac57add88bb337cebaada3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloLeftRightGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float *z)</argsstring>
        <name>fillHaloLeftRightGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="487" column="10" declfile="src/Halo.cu" declline="487" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a6da328def689854bc8f7f54af1d40dcb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloLeftRightGPUnew</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T *z)</argsstring>
        <name>fillHaloLeftRightGPUnew</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating for halos for each block of a single variable on GPU. New version. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>The cuda stream to use </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to work on </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="497" column="18" bodyfile="src/Halo.cu" bodystart="497" bodyend="508"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9c68f2c332f01be941bbc9e6dd04e5e5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloLeftRightGPUnew&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double *z)</argsstring>
        <name>fillHaloLeftRightGPUnew&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="509" column="10" declfile="src/Halo.cu" declline="509" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ab1b44678d54793b59734f97b88c2a623" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloLeftRightGPUnew&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float *z)</argsstring>
        <name>fillHaloLeftRightGPUnew&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="510" column="10" declfile="src/Halo.cu" declline="510" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a645550ebdc0b4a03a0d47e31e0814d31" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloBotTopGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T *z)</argsstring>
        <name>fillHaloBotTopGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating flux for halos for each block of a single variable on GPU. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8cu_1autotoc_md7">
<title>Description</title>
<para>This function is a wraping function of the halo flux functions on GPU. It is called from the main Halo GPU function. The present imnplementation is naive and slow one that calls the rather complex fillLeft type functions <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>The cuda stream to use </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to work on </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="524" column="18" bodyfile="src/Halo.cu" bodystart="524" bodyend="541"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ad922091a4b843c143f4897d9446fe846" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloBotTopGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double *z)</argsstring>
        <name>fillHaloBotTopGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="542" column="10" declfile="src/Halo.cu" declline="542" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a718dfed8a35b43d0e476d15fa60cf99e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloBotTopGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float *z)</argsstring>
        <name>fillHaloBotTopGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="543" column="10" declfile="src/Halo.cu" declline="543" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a243e3434cdc9990c9911ee1c00052348" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloBotTopGPUnew</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T *z)</argsstring>
        <name>fillHaloBotTopGPUnew</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating flux for halos for each block of a single variable on GPU. New version. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8cu_1autotoc_md8">
<title>Description</title>
<para>This function is a wraping function of the halo flux functions on GPU. It is called from the main Halo GPU function. The present imnplementation is naive and slow one that calls the rather complex fillLeft type functions <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>The cuda stream to use </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to work on </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="557" column="18" bodyfile="src/Halo.cu" bodystart="557" bodyend="568"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9ed5180f00aa1fc13391a3618e6caba9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloBotTopGPUnew&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double *z)</argsstring>
        <name>fillHaloBotTopGPUnew&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="569" column="10" declfile="src/Halo.cu" declline="569" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a7a80e2f0e348af6c37f5550554eb1fec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloBotTopGPUnew&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float *z)</argsstring>
        <name>fillHaloBotTopGPUnew&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="570" column="10" declfile="src/Halo.cu" declline="570" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a4a31e12451e1336defc379f47d6aab9e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHalo</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T *zb)</argsstring>
        <name>fillHalo</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating halos for each block and each variable on CPU. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8h_1autotoc_md9">
<title>Description</title>
<para>This function is a wraping fuction of the halo functions on CPU. It is called from the main Halo function. It uses multithreading to calculate the halos of the 4 variables in parallel. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Xev</parametername>
</parameternamelist>
<parameterdescription>
<para>The evolving structure containing the evolving variables </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>The bottom elevation variable </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="586" column="18" bodyfile="src/Halo.cu" bodystart="586" bodyend="616"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1afa4cf32960744be7d6afbd861b4af55e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHalo&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float *zb)</argsstring>
        <name>fillHalo&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="617" column="10" declfile="src/Halo.cu" declline="617" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a3631ffea6e7d5766b04de6082182813e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHalo&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double *zb)</argsstring>
        <name>fillHalo&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="618" column="10" declfile="src/Halo.cu" declline="618" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a571ac7ff2cf8b31f5d026b7e909e5271" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHalo</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev)</argsstring>
        <name>fillHalo</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating halos for each block and each variable on CPU. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8h_1autotoc_md10">
<title>Description</title>
<para>This function is a wraping fuction of the halo functions on CPU. It is called from the main Halo function. It uses multithreading to calculate the halos of the 4 variables in parallel. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Xev</parametername>
</parameternamelist>
<parameterdescription>
<para>The evolving structure containing the evolving variables </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="632" column="18" bodyfile="src/Halo.cu" bodystart="632" bodyend="648"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aa8f68738d43b4ea348c964349d07fd21" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHalo&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev)</argsstring>
        <name>fillHalo&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="649" column="10" declfile="src/Halo.cu" declline="649" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a22fa619b12cb821e01c0611bf0774f70" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHalo&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev)</argsstring>
        <name>fillHalo&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="650" column="10" declfile="src/Halo.cu" declline="650" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a2a355feb696605ad555fe018395bcac2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev)</argsstring>
        <name>fillHaloGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating halos for each block and each variable on GPU. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Xev</parametername>
</parameternamelist>
<parameterdescription>
<para>The evolving structure containing the evolving variables </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="659" column="18" bodyfile="src/Halo.cu" bodystart="659" bodyend="680"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9b8d1661f255b3e8e41a8ec6a2a98260" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev)</argsstring>
        <name>fillHaloGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="681" column="10" declfile="src/Halo.cu" declline="681" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a87f6da23bb80f5c2a138bad34e576e5b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev)</argsstring>
        <name>fillHaloGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="682" column="10" declfile="src/Halo.cu" declline="682" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a8bcac8c7fda9dd6edcfb34f40543ceef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T *zb)</argsstring>
        <name>fillHaloGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating halos for each block and each variable on GPU. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8h_1autotoc_md11">
<title>Description</title>
<para>This function is a wraping fuction of the halo functions on GPU. It is called from the main Halo GPU function. It uses multiple cuda streams to calculate the halos of the 4 variables in parallel. After filling the halos, it applies either the elevation conservation or wet-dry fix if enabled in parameters. Finally, it recalculates the surface elevation zs based on the updated water depth h and bottom elevation zb. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Xev</parametername>
</parameternamelist>
<parameterdescription>
<para>The evolving structure containing the evolving variables </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>The bottom elevation variable </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="699" column="18" bodyfile="src/Halo.cu" bodystart="699" bodyend="750"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae9d035a7e3954d9b2801a74cf2ba87f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float *zb)</argsstring>
        <name>fillHaloGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="751" column="10" declfile="src/Halo.cu" declline="751" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ac253f2bf76324a678d0f34a9a9b1c631" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double *zb)</argsstring>
        <name>fillHaloGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="752" column="10" declfile="src/Halo.cu" declline="752" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a335ca91325da154b12cc3f3ee6dabba3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHalo</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, GradientsP&lt; T &gt; Grad)</argsstring>
        <name>fillHalo</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structGradientsP" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>Grad</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating halos for each block and each variable on CPU. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8h_1autotoc_md12">
<title>Description</title>
<para>This function is a wrapping function of the halo functions on CPU. It is called from the main Halo function. It uses multithreading to calculate the halos of the 4 variables in parallel. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Grad</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradients structure containing the gradients </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="765" column="18" bodyfile="src/Halo.cu" bodystart="765" bodyend="800"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a1537aa80051775c77097a9bb3b82725c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHalo&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, GradientsP&lt; float &gt; Grad)</argsstring>
        <name>fillHalo&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structGradientsP" kindref="compound">GradientsP</ref>&lt; float &gt;</type>
          <declname>Grad</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="801" column="10" declfile="src/Halo.cu" declline="801" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a0884370506c63c157bcca090e1dc9034" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHalo&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, GradientsP&lt; double &gt; Grad)</argsstring>
        <name>fillHalo&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structGradientsP" kindref="compound">GradientsP</ref>&lt; double &gt;</type>
          <declname>Grad</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="802" column="10" declfile="src/Halo.cu" declline="802" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a8d8f335f2691b865597b01f0e6c2e210" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, GradientsP&lt; T &gt; Grad)</argsstring>
        <name>fillHaloGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structGradientsP" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>Grad</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating halos for each block and each variable on GPU. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Grad</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradients structure containing the gradients </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="811" column="18" bodyfile="src/Halo.cu" bodystart="811" bodyend="837"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a18a815a1959a39e7ab80e94b759a15f7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, GradientsP&lt; float &gt; Grad)</argsstring>
        <name>fillHaloGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structGradientsP" kindref="compound">GradientsP</ref>&lt; float &gt;</type>
          <declname>Grad</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="838" column="10" declfile="src/Halo.cu" declline="838" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a0c4feec6db1f401b3409302c41843524" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, GradientsP&lt; double &gt; Grad)</argsstring>
        <name>fillHaloGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structGradientsP" kindref="compound">GradientsP</ref>&lt; double &gt;</type>
          <declname>Grad</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="839" column="10" declfile="src/Halo.cu" declline="839" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a657a661d3469befc6894213c9512fb3d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHalo</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux)</argsstring>
        <name>fillHalo</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; T &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating flux halos for each block and each variable on CPU. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Flux</parametername>
</parameternamelist>
<parameterdescription>
<para>The flux structure containing the flux variables </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="849" column="18" bodyfile="src/Halo.cu" bodystart="849" bodyend="884"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aa43f5a8602659f6210dd902089ccf013" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHalo&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, FluxP&lt; float &gt; Flux)</argsstring>
        <name>fillHalo&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; float &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="885" column="10" declfile="src/Halo.cu" declline="885" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a950a805927a040a251910383f8a0917c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHalo&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, FluxP&lt; double &gt; Flux)</argsstring>
        <name>fillHalo&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; double &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="886" column="10" declfile="src/Halo.cu" declline="886" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a3f01819995937c8bbce5ac05c18f71b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux)</argsstring>
        <name>fillHaloGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; T &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating flux halos for each block and each variable on GPU. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Flux</parametername>
</parameternamelist>
<parameterdescription>
<para>The flux structure containing the flux variables </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="895" column="18" bodyfile="src/Halo.cu" bodystart="895" bodyend="945"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1acac7f5cbebdc9598fe00696f6708068f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, FluxP&lt; float &gt; Flux)</argsstring>
        <name>fillHaloGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; float &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="946" column="10" declfile="src/Halo.cu" declline="946" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae4dfd3f7c7752f689ea4aa1cd17b378c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, FluxP&lt; double &gt; Flux)</argsstring>
        <name>fillHaloGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; double &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="947" column="10" declfile="src/Halo.cu" declline="947" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ad8656ca08616abdeb043f622de7243fd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void bndmaskGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, FluxP&lt; T &gt; Flux)</argsstring>
        <name>bndmaskGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; T &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
<para>Wrapping function for applying boundary masks to flux variables on GPU. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Xev</parametername>
</parameternamelist>
<parameterdescription>
<para>The evolving structure containing the evolving variables </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Flux</parametername>
</parameternamelist>
<parameterdescription>
<para>The flux structure containing the flux variables </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="957" column="18" bodyfile="src/Halo.cu" bodystart="957" bodyend="986"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a1a2c2fe28c070ea593b6f0fb06cda5eb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void bndmaskGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, FluxP&lt; float &gt; Flux)</argsstring>
        <name>bndmaskGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; float &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="987" column="10" declfile="src/Halo.cu" declline="987" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a8effb78a3ef81c8e53f925af0e1beeec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void bndmaskGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, FluxP&lt; double &gt; Flux)</argsstring>
        <name>bndmaskGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; double &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="988" column="10" declfile="src/Halo.cu" declline="988" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a660ab474d664c8622e1f0768eef59342" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void refine_linear_Left</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear_Left</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
<para>Refine a block on the left side using linear reconstruction. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8h_1autotoc_md13">
<title>Description</title>
<para>This function refines a block on the left side using linear reconstruction. It checks if the neighboring block on the left is at a coarser level. If so, it calculates the new values for the left boundary of the current block using the gradients in the x and y directions. The new values are computed based on the distance to the neighboring block and the gradients, ensuring a smooth transition between different resolution levels. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the current block </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdx</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the x direction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdy</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the y direction </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1044" column="18" bodyfile="src/Halo.cu" bodystart="1044" bodyend="1066"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a4e7dbd71c089a0e3dc219c1eb5d9d13e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear_Left&lt; float &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear_Left&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1067" column="10" declfile="src/Halo.cu" declline="1067" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aaa405d4b273e7eba82cccef28661a4cf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear_Left&lt; double &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear_Left&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1068" column="10" declfile="src/Halo.cu" declline="1068" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a0dfd1652d58d54f5d3fd66d6d30ed2dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void refine_linear_LeftGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear_LeftGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
<para>GPU kernel to refine a block on the left side using linear reconstruction. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8cu_1autotoc_md14">
<title>Description</title>
<para>This GPU kernel refines a block on the left side using linear reconstruction. It checks if the neighboring block on the left is at a coarser level. If so, it calculates the new values for the left boundary of the current block using the gradients in the x and y directions. The new values are computed based on the distance to the neighboring block and the gradients, ensuring a smooth transition between different resolution levels. Each thread processes a specific row of the block, allowing for parallel computation across multiple blocks. <linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdx</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the x direction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdy</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the y direction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1086" column="29" bodyfile="src/Halo.cu" bodystart="1086" bodyend="1118"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae21004698b731ba1e88d8199e1bf5839" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void refine_linear_LeftGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear_LeftGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1119" column="21" declfile="src/Halo.cu" declline="1119" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a387ff243908f0957e13f8f5eb4e6c4ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void refine_linear_LeftGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear_LeftGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1120" column="21" declfile="src/Halo.cu" declline="1120" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a41de2d4fe883bf1e375fd44877584b14" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void refine_linear_Right</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear_Right</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
<para>Refine a block on the right side using linear reconstruction. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8cu_1autotoc_md15">
<title>Description</title>
<para>This function refines a block on the right side using linear reconstruction. It checks if the neighboring block on the right is at a coarser level. If so, it calculates the new values for the right boundary of the current block using the gradients in the x and y directions. The new values are computed based on the distance to the neighboring block and the gradients, ensuring a smooth transition between different resolution levels. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the current block </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdx</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the x direction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdy</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the y direction </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1138" column="18" bodyfile="src/Halo.cu" bodystart="1138" bodyend="1160"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a1fa1834cc4aa84cb7738a0adc45a4dc2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear_Right&lt; float &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear_Right&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1161" column="10" declfile="src/Halo.cu" declline="1161" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a80b97b76fe856b41292e4700327b4829" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear_Right&lt; double &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear_Right&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1162" column="10" declfile="src/Halo.cu" declline="1162" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a66adad329d72cd96c0a4fc0fefd62cfe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void refine_linear_RightGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear_RightGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
<para>GPU kernel to refine a block on the right side using linear reconstruction. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8cu_1autotoc_md16">
<title>Description</title>
<para>This GPU kernel refines a block on the right side using linear reconstruction. It checks if the neighboring block on the right is at a coarser level. If so, it calculates the new values for the right boundary of the current block using the gradients in the x and y directions. The new values are computed based on the distance to the neighboring block and the gradients, ensuring a smooth transition between different resolution levels. Each thread processes a specific row of the block, allowing for parallel computation across multiple blocks. <linebreak/>
 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdx</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the x direction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdy</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the y direction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1179" column="29" bodyfile="src/Halo.cu" bodystart="1179" bodyend="1210"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1abf05d4e326bc8001570eb7c0e2078780" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void refine_linear_RightGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear_RightGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1211" column="21" declfile="src/Halo.cu" declline="1211" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a7ba5681c7d996dca7b951aba4dd80aa9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void refine_linear_RightGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear_RightGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1212" column="21" declfile="src/Halo.cu" declline="1212" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a86539114f4682e0cfd5ae397978c569a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void refine_linear_Bot</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear_Bot</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
<para>Refine a block on the bottom side using linear reconstruction. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8cu_1autotoc_md17">
<title>Description</title>
<para>This function refines a block on the bottom side using linear reconstruction. It checks if the neighboring block on the bottom is at a coarser level. If so, it calculates the new values for the bottom boundary of the current block using the gradients in the x and y directions. The new values are computed based on the distance to the neighboring block and the gradients, ensuring a smooth transition between different resolution levels. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the current block </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdx</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the x direction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdy</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the y direction <linebreak/>
 </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1227" column="18" bodyfile="src/Halo.cu" bodystart="1227" bodyend="1250"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a7a09d610716c25c2c4cb45dde7ffdd53" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear_Bot&lt; float &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear_Bot&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1251" column="10" declfile="src/Halo.cu" declline="1251" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a5895d32dd2bfb9aa26fb9653a767882a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear_Bot&lt; double &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear_Bot&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1252" column="10" declfile="src/Halo.cu" declline="1252" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a5748f4fb9632d8308fa235004d5f6b12" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void refine_linear_BotGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear_BotGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
<para>GPU kernel to refine a block on the bottom side using linear reconstruction. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8cu_1autotoc_md18">
<title>Description</title>
<para>This GPU kernel refines a block on the bottom side using linear reconstruction. It checks if the neighboring block on the bottom is at a coarser level. If so, it calculates the new values for the bottom boundary of the current block using the gradients in the x and y directions. The new values are computed based on the distance to the neighboring block and the gradients, ensuring a smooth transition between different resolution levels. Each thread processes a specific column of the block, allowing for parallel computation across multiple blocks. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdx</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the x direction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdy</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the y direction </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1267" column="29" bodyfile="src/Halo.cu" bodystart="1267" bodyend="1296"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ace3bee45c02ffdf7c1848ee910bf97be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void refine_linear_BotGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear_BotGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1297" column="21" declfile="src/Halo.cu" declline="1297" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a179fecb6df5a3276383654db31c3b213" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void refine_linear_BotGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear_BotGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1298" column="21" declfile="src/Halo.cu" declline="1298" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a7b4fb01de4f8fdd9daafc221db1a959f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void refine_linear_Top</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear_Top</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
<para>Refine a block on the top side using linear reconstruction. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8cu_1autotoc_md19">
<title>Description</title>
<para>This function refines a block on the top side using linear reconstruction. It checks if the neighboring block on the top is at a coarser level. If so, it calculates the new values for the top boundary of the current block using the gradients in the x and y directions. The new values are computed based on the distance to the neighboring block and the gradients, ensuring a smooth transition between different resolution levels. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the current block </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdx</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the x direction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdy</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the y direction <linebreak/>
 </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1313" column="18" bodyfile="src/Halo.cu" bodystart="1313" bodyend="1336"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1afc2a5bb2abceee1a853c771cefbf5a2b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear_Top&lt; float &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear_Top&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1337" column="10" declfile="src/Halo.cu" declline="1337" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ab1f2fb4f0d584a9b42bcfbd80c018cf8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear_Top&lt; double &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear_Top&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1338" column="10" declfile="src/Halo.cu" declline="1338" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a525a7162ec9037c8b16cf7417f3926b2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void refine_linear_TopGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear_TopGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
<para>GPU kernel to refine a block on the top side using linear reconstruction. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8cu_1autotoc_md20">
<title>Description</title>
<para>This GPU kernel refines a block on the top side using linear reconstruction. It checks if the neighboring block on the top is at a coarser level. If so, it calculates the new values for the top boundary of the current block using the gradients in the x and y directions. The new values are computed based on the distance to the neighboring block and the gradients, ensuring a smooth transition between different resolution levels. Each thread processes a specific column of the block, allowing for parallel computation across multiple blocks. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdx</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the x direction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdy</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the y direction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1354" column="29" bodyfile="src/Halo.cu" bodystart="1354" bodyend="1382"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9ad60860791cc1d9816671a7daf3f9ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void refine_linear_TopGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear_TopGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1383" column="21" declfile="src/Halo.cu" declline="1383" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae915fa866b3f0fe4136aadc5dbd58135" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void refine_linear_TopGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear_TopGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1384" column="21" declfile="src/Halo.cu" declline="1384" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aa3159218d597d5dec3caa8686a223081" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void refine_linear</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
<para>Wrapping function for refining all sides of active blocks using linear reconstruction. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdx</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the x direction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdy</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the y direction </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1395" column="18" bodyfile="src/Halo.cu" bodystart="1395" bodyend="1405"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a535cb1b12608ac724cc113d84302cc7e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1406" column="10" declfile="src/Halo.cu" declline="1406" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aff8eecab036938a6f0516958e7a6666e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1407" column="10" declfile="src/Halo.cu" declline="1407" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a090d7ddeba077e9ef3b06ec9e4f8851a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void refine_linearGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linearGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
<para>Wrapping function for refining all sides of active blocks using linear reconstruction on GPU. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdx</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the x direction </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dzdy</parametername>
</parameternamelist>
<parameterdescription>
<para>The gradient of z in the y direction </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1418" column="18" bodyfile="src/Halo.cu" bodystart="1418" bodyend="1430"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aba3b8bc4676eb67b3ba5af23fd082a03" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linearGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linearGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1431" column="10" declfile="src/Halo.cu" declline="1431" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a2dbaeb9cbd6aba5e1a875ff4f81befb0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linearGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linearGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1432" column="10" declfile="src/Halo.cu" declline="1432" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9127f7d09d9a110da1cb7fae1786c389" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void HaloFluxCPULR</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>HaloFluxCPULR</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>CPU function for applying halo flux correction on the left and right boundaries. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the block </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1441" column="18" bodyfile="src/Halo.cu" bodystart="1441" bodyend="1529"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a82e672706036bc5b4e87cd2b739f9609" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void HaloFluxGPULR</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>HaloFluxGPULR</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for applying halo flux correction on the left and right boundaries of all active blocks. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1539" column="30" bodyfile="src/Halo.cu" bodystart="1539" bodyend="1641"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9178199ff5e46ef9a5fee4241b8e235e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void HaloFluxGPULRnew</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>HaloFluxGPULRnew</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>GPU kernel for applying halo flux correction on the left and right boundaries of all active blocks. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1651" column="30" bodyfile="src/Halo.cu" bodystart="1651" bodyend="1757"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a5497979187df8771242d5c3d66922615" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void HaloFluxCPUBT</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>HaloFluxCPUBT</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for applying halo flux correction on the left and right boundaries of all active blocks on GPU. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters <linebreak/>
 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1766" column="18" bodyfile="src/Halo.cu" bodystart="1766" bodyend="1854"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a0c0b81d1c956a11c4025491946f90010" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void HaloFluxGPUBT</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>HaloFluxGPUBT</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>GPU kernel for applying halo flux correction on the top and bottom boundaries of all active blocks. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1863" column="29" bodyfile="src/Halo.cu" bodystart="1863" bodyend="1960"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a5ddd71e988ae7200bfd409d5d9d81921" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void HaloFluxGPUBTnew</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>HaloFluxGPUBTnew</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>GPU kernel for applying halo flux correction on the top and bottom boundaries of all active blocks. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1969" column="29" bodyfile="src/Halo.cu" bodystart="1969" bodyend="2072"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ad7bdbf10e6e7309983c7143644f18268" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillLeft</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillLeft</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Applying halo flux correction on the left boundaries of all active blocks on GPU. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The model parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>The block index </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing the block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2083" column="18" bodyfile="src/Halo.cu" bodystart="2083" bodyend="2286"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af1855d1f517b150637f7ebba2b7c98d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillLeft</definition>
        <argsstring>(int halowidth, int *active, int *level, int *leftbot, int *lefttop, int *rightbot, int *botright, int *topright, T *a)</argsstring>
        <name>fillLeft</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>GPU kernel for applying halo flux correction on the left boundaries of all active blocks. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>halowidth</parametername>
</parameternamelist>
<parameterdescription>
<para>The width of the halo region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>active</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of active block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of block levels </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>leftbot</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of left bottom neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lefttop</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of left top neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rightbot</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right bottom neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>botright</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of bottom right neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>topright</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of top right neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2302" column="29" bodyfile="src/Halo.cu" bodystart="2302" bodyend="2470"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a3b14beb454331728755e5f8a6f251e13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillLeft&lt; float &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, int *leftbot, int *lefttop, int *rightbot, int *botright, int *topright, float *a)</argsstring>
        <name>fillLeft&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2471" column="21" declfile="src/Halo.cu" declline="2471" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aedd2d63dd1706ae7d29be62692da6f38" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillLeft&lt; double &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, int *leftbot, int *lefttop, int *rightbot, int *botright, int *topright, double *a)</argsstring>
        <name>fillLeft&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2472" column="21" declfile="src/Halo.cu" declline="2472" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aeca99a935bccb5897113cf8f57dcc877" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillLeftnew</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *leftbot, int *lefttop, int *rightbot, int *botright, int *topright, T *a)</argsstring>
        <name>fillLeftnew</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>New way of filling the left halo 2 blocks at a time to maximize GPU occupancy. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8h_1autotoc_md21">
<title>Description</title>
<para>This fuction is a wraping fuction of the halo functions for CPU. It is called from another wraping function to keep things clean. In a sense this is the third (and last) layer of wrapping</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>halowidth</parametername>
</parameternamelist>
<parameterdescription>
<para>The width of the halo region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nblk</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of active blocks </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>active</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of active block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of block levels </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>leftbot</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of left bottom neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lefttop</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of left top neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rightbot</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right bottom neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>botright</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of bottom right neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>topright</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of top right neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2492" column="29" bodyfile="src/Halo.cu" bodystart="2492" bodyend="2666"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a98fac6187460306e6a2d90611cf5f7b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillLeftnew&lt; float &gt;</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *leftbot, int *lefttop, int *rightbot, int *botright, int *topright, float *a)</argsstring>
        <name>fillLeftnew&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2667" column="21" declfile="src/Halo.cu" declline="2667" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae6479ede9a0c3e1cfacc2e53355ebccb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillLeftnew&lt; double &gt;</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *leftbot, int *lefttop, int *rightbot, int *botright, int *topright, double *a)</argsstring>
        <name>fillLeftnew&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2668" column="21" declfile="src/Halo.cu" declline="2668" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a5d9d65fbd4acba2dc766568a77bfaffd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillLeftFlux</definition>
        <argsstring>(Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillLeftFlux</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>CPU function for applying halo flux correction on the left boundaries of a specific block. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>doProlongation</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating whether to perform prolongation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the block to process </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing neighbor information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2678" column="18" bodyfile="src/Halo.cu" bodystart="2678" bodyend="2808"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a2345005d54233720f2cae1e1b443a36f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillRight</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillRight</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Fills the right halo region of a block. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the block to process </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing neighbor information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2818" column="18" bodyfile="src/Halo.cu" bodystart="2818" bodyend="3020"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af71504ac800a61627ac5cef75d003bfd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillRight</definition>
        <argsstring>(int halowidth, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, T *a)</argsstring>
        <name>fillRight</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>CUDA kernel to fill the right halo region of blocks in parallel. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>halowidth</parametername>
</parameternamelist>
<parameterdescription>
<para>The width of the halo region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>active</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of active block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of block levels </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rightbot</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right bottom neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>righttop</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right top neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>leftbot</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of left bottom neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>botleft</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of bottom left neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>topleft</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of top left neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type of the variable (e.g., float, double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3037" column="29" bodyfile="src/Halo.cu" bodystart="3037" bodyend="3207"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a72e57bc7f4ba67769042bff28273c9e7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillRight&lt; float &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, float *a)</argsstring>
        <name>fillRight&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3209" column="21" declfile="src/Halo.cu" declline="3209" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a1ded4426a80fbcf290981dc537f320d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillRight&lt; double &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, double *a)</argsstring>
        <name>fillRight&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3210" column="21" declfile="src/Halo.cu" declline="3210" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ab2b0d44b1bb0c826f764f7b84b8bed23" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillRightnew</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, T *a)</argsstring>
        <name>fillRightnew</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>CUDA kernel to fill the right halo region of blocks in parallel (new version). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>halowidth</parametername>
</parameternamelist>
<parameterdescription>
<para>The width of the halo region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nblk</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of active blocks </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>active</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of active block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of block levels </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rightbot</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right bottom neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>righttop</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right top neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>leftbot</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of left bottom neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>botleft</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of bottom left neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>topleft</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of top left neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type of the variable (e.g., float, double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3227" column="29" bodyfile="src/Halo.cu" bodystart="3227" bodyend="3400"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a81fe82b12b6eecfaab656454daa1c2d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillRightnew&lt; float &gt;</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, float *a)</argsstring>
        <name>fillRightnew&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3402" column="21" declfile="src/Halo.cu" declline="3402" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ab5a4a9f0e151d12e559ac3581e855908" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillRightnew&lt; double &gt;</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, double *a)</argsstring>
        <name>fillRightnew&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3403" column="21" declfile="src/Halo.cu" declline="3403" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a2f03036ffa47f139c5eba848de62ce1a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillRightFlux</definition>
        <argsstring>(Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillRightFlux</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Function to fill the right halo region of a block, handling various neighbor configurations. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The parameters of the grid and blocks </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>doProlongation</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating whether to perform prolongation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the current block </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing neighbor information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type of the variable (e.g., float, double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3415" column="18" bodyfile="src/Halo.cu" bodystart="3415" bodyend="3540"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a1f1c910e13ec59b239e54f5b9974785b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillRightFlux&lt; float &gt;</definition>
        <argsstring>(Param XParam, bool doProlongation, int ib, BlockP&lt; float &gt; XBlock, float *&amp;z)</argsstring>
        <name>fillRightFlux&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3542" column="10" declfile="src/Halo.cu" declline="3542" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a04f5e436751e34f565037dc24a22a155" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillRightFlux&lt; double &gt;</definition>
        <argsstring>(Param XParam, bool doProlongation, int ib, BlockP&lt; double &gt; XBlock, double *&amp;z)</argsstring>
        <name>fillRightFlux&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3543" column="10" declfile="src/Halo.cu" declline="3543" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1afaa07f3e06bd6f302d97aa9954188afb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillRightFlux</definition>
        <argsstring>(int halowidth, bool doProlongation, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, T *a)</argsstring>
        <name>fillRightFlux</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>CUDA kernel to fill the right halo region of blocks in parallel for flux variables, handling various neighbor configurations. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>halowidth</parametername>
</parameternamelist>
<parameterdescription>
<para>The width of the halo region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>doProlongation</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating whether to perform prolongation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>active</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of active block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of block levels </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rightbot</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right bottom neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>righttop</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right top neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>leftbot</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of left bottom neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>botleft</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of bottom left neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>topleft</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of top left neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type of the variable (e.g., float, double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3560" column="29" bodyfile="src/Halo.cu" bodystart="3560" bodyend="3671"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a56941d739afb1ee3215e82cd06678e96" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillRightFlux&lt; float &gt;</definition>
        <argsstring>(int halowidth, bool doProlongation, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, float *a)</argsstring>
        <name>fillRightFlux&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3672" column="21" declfile="src/Halo.cu" declline="3672" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a87e192a85f48bf6a5706ac9fde71b3e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillRightFlux&lt; double &gt;</definition>
        <argsstring>(int halowidth, bool doProlongation, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, double *a)</argsstring>
        <name>fillRightFlux&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3673" column="21" declfile="src/Halo.cu" declline="3673" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a671352fcb2eaaa2d4207ff07c9e8f852" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillBot</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillBot</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Function to fill the bottom halo region of a block, handling various neighbor configurations. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The parameters of the grid and blocks </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the current block </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing neighbor information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type of the variable (e.g., float, double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3685" column="18" bodyfile="src/Halo.cu" bodystart="3685" bodyend="3885"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af9678ea06bf2f69ed3152b64f8deffca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillBot</definition>
        <argsstring>(int halowidth, int *active, int *level, int *botleft, int *botright, int *topleft, int *lefttop, int *righttop, T *a)</argsstring>
        <name>fillBot</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>CUDA kernel to fill the bottom halo region of blocks in parallel, handling various neighbor configurations. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>halowidth</parametername>
</parameternamelist>
<parameterdescription>
<para>The width of the halo region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>active</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of active block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of block levels </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>botleft</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of bottom left neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>botright</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of bottom right neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>topleft</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of top left neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lefttop</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of left top neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>righttop</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right top neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type of the variable (e.g., float, double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3901" column="29" bodyfile="src/Halo.cu" bodystart="3901" bodyend="4062"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a7020b0ebbbedc2f4dcb4f34e1007273f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillBot&lt; float &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, int *botleft, int *botright, int *topleft, int *lefttop, int *righttop, float *a)</argsstring>
        <name>fillBot&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4063" column="21" declfile="src/Halo.cu" declline="4063" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a55031de0d78e78dfc24cef8c29bc7017" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillBot&lt; double &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, int *botleft, int *botright, int *topleft, int *lefttop, int *righttop, double *a)</argsstring>
        <name>fillBot&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4064" column="21" declfile="src/Halo.cu" declline="4064" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a2fc4bb8d813f6515dea868a5d2d36f68" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillBotnew</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *botleft, int *botright, int *topleft, int *lefttop, int *righttop, T *a)</argsstring>
        <name>fillBotnew</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>CUDA kernel to fill the bottom halo region of blocks in parallel for new refinement, handling various neighbor configurations, new version. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>halowidth</parametername>
</parameternamelist>
<parameterdescription>
<para>The width of the halo region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nblk</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of active blocks </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>active</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of active block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of block levels </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>botleft</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of bottom left neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>botright</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of bottom right neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>topleft</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of top left neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lefttop</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of left top neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>righttop</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right top neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type of the variable (e.g., float, double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4080" column="29" bodyfile="src/Halo.cu" bodystart="4080" bodyend="4243"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1acb3d52e6ce9ff6c556e2d0743ea6844f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillBotnew&lt; float &gt;</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *botleft, int *botright, int *topleft, int *lefttop, int *righttop, float *a)</argsstring>
        <name>fillBotnew&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4244" column="21" declfile="src/Halo.cu" declline="4244" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a701b145ee386048b5066d978de26a8a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillBotnew&lt; double &gt;</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *botleft, int *botright, int *topleft, int *lefttop, int *righttop, double *a)</argsstring>
        <name>fillBotnew&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4245" column="21" declfile="src/Halo.cu" declline="4245" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ada9520990635cb340db8cf913cc6e356" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillBotFlux</definition>
        <argsstring>(Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillBotFlux</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Fills the bottom halo region of a block, handling various neighbor configurations. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The parameters of the grid/block structure </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>doProlongation</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating whether to perform prolongation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the current block </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing neighbor information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type of the variable (e.g., float, double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4256" column="18" bodyfile="src/Halo.cu" bodystart="4256" bodyend="4384"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aefe78bd2478a704e63205de5fee4f5ac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillTop</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillTop</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Fills the top halo region of a block, handling various neighbor configurations. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The parameters of the grid/block structure </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the current block </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block structure containing neighbor information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type of the variable (e.g., float, double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4394" column="18" bodyfile="src/Halo.cu" bodystart="4394" bodyend="4594"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a77acf80e6591f424cb6b99331eb3764a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillTop</definition>
        <argsstring>(int halowidth, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, T *a)</argsstring>
        <name>fillTop</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>CUDA kernel to fill the top halo region of blocks in parallel for new refinement, handling various neighbor configurations, new version. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>halowidth</parametername>
</parameternamelist>
<parameterdescription>
<para>The width of the halo region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>active</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of active block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of block levels </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>topleft</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of top left neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>topright</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of top right neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>botleft</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of bottom left neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>leftbot</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of left bottom neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rightbot</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right bottom neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type of the variable (e.g., float, double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4610" column="29" bodyfile="src/Halo.cu" bodystart="4610" bodyend="4772"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ab3744247f8d4622ba1f0e52a738148f7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillTop&lt; float &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, float *a)</argsstring>
        <name>fillTop&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4774" column="21" declfile="src/Halo.cu" declline="4774" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a89b6a37e2b440932b8c4beea68e0a13a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillTop&lt; double &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, double *a)</argsstring>
        <name>fillTop&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4775" column="21" declfile="src/Halo.cu" declline="4775" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a67e1c95744d12c9baf5767e34767d4d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillTopnew</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, T *a)</argsstring>
        <name>fillTopnew</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4791" column="29" bodyfile="src/Halo.cu" bodystart="4791" bodyend="4956"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a65828cacc2417f824d4e96d696749531" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillTopnew&lt; float &gt;</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, float *a)</argsstring>
        <name>fillTopnew&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4958" column="21" declfile="src/Halo.cu" declline="4958" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a5fa720fa5a16910d38c34480f2f1b72b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillTopnew&lt; double &gt;</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, double *a)</argsstring>
        <name>fillTopnew&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4959" column="21" declfile="src/Halo.cu" declline="4959" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9af9c1a41440ff037441b0cea28bcbaf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillTopFlux</definition>
        <argsstring>(Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillTopFlux</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Function to fill the top halo region of a block for new refinement, handling various neighbor configurations. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The parameters of the grid and blocks </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>doProlongation</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating whether to perform prolongation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the block to be processed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The structure containing block neighbor information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type of the variable (e.g., float, double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4970" column="18" bodyfile="src/Halo.cu" bodystart="4970" bodyend="5094"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af00c6ce01842ac1e06289207021a7793" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillTopFlux&lt; float &gt;</definition>
        <argsstring>(Param XParam, bool doProlongation, int ib, BlockP&lt; float &gt; XBlock, float *&amp;z)</argsstring>
        <name>fillTopFlux&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="5095" column="10" declfile="src/Halo.cu" declline="5095" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a7d2e054c42e7de0e660d4eb7d42171ad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillTopFlux&lt; double &gt;</definition>
        <argsstring>(Param XParam, bool doProlongation, int ib, BlockP&lt; double &gt; XBlock, double *&amp;z)</argsstring>
        <name>fillTopFlux&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="5096" column="10" declfile="src/Halo.cu" declline="5096" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aaeae9c3ca26a884c76d4d429c60dead6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillTopFlux</definition>
        <argsstring>(int halowidth, bool doProlongation, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, T *a)</argsstring>
        <name>fillTopFlux</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>CUDA kernel to fill the top halo region of blocks in parallel for new refinement, handling various neighbor configurations, new version. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>halowidth</parametername>
</parameternamelist>
<parameterdescription>
<para>The width of the halo region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>doProlongation</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating whether to perform prolongation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>active</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of active block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of block levels </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>topleft</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of top left neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>topright</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of top right neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>botleft</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of bottom left neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>leftbot</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of left bottom neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rightbot</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of right bottom neighbor block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be refined </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type of the variable (e.g., float, double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="5113" column="29" bodyfile="src/Halo.cu" bodystart="5113" bodyend="5214"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a266e09515f6b6f7f560ccc120e806957" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillTopFlux&lt; float &gt;</definition>
        <argsstring>(int halowidth, bool doProlongation, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, float *a)</argsstring>
        <name>fillTopFlux&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="5216" column="21" declfile="src/Halo.cu" declline="5216" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a6f91cf2e90ac2d1db440820c5ba5518c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillTopFlux&lt; double &gt;</definition>
        <argsstring>(int halowidth, bool doProlongation, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, double *a)</argsstring>
        <name>fillTopFlux&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="5217" column="21" declfile="src/Halo.cu" declline="5217" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a1797b1932cfb1952397c7618a84da179" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillCorners</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillCorners</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Function to fill the corner halo regions for all active blocks. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The parameters of the grid and blocks </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The structure containing block neighbor information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be processed </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type of the variable (e.g., float, double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="5227" column="18" bodyfile="src/Halo.cu" bodystart="5227" bodyend="5238"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a0da557498682b82b0ffcc76249624dca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillCorners&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *&amp;z)</argsstring>
        <name>fillCorners&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="5239" column="10" declfile="src/Halo.cu" declline="5239" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a66442f2a4308a4f7973c13eadfd0ccd4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillCorners&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *&amp;z)</argsstring>
        <name>fillCorners&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="5240" column="10" declfile="src/Halo.cu" declline="5240" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae6a37fef4c306b5218742df8872f03dc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillCorners</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; &amp;Xev)</argsstring>
        <name>fillCorners</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt; &amp;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
<para>Function to fill the corner halo regions for all active blocks and all evolving variables. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The parameters of the grid and blocks </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The structure containing block neighbor information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Xev</parametername>
</parameternamelist>
<parameterdescription>
<para>The structure containing evolving variables </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type of the variables (e.g., float, double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="5251" column="18" bodyfile="src/Halo.cu" bodystart="5251" bodyend="5264"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1acf6d62f01f062c58a9c0133a3e931b28" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillCorners&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; &amp;Xev)</argsstring>
        <name>fillCorners&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt; &amp;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="5265" column="10" declfile="src/Halo.cu" declline="5265" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aa2d6ea0e98dca434a8fe613239142688" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillCorners&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; &amp;Xev)</argsstring>
        <name>fillCorners&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt; &amp;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="5266" column="10" declfile="src/Halo.cu" declline="5266" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aad3c5276e55ffe7f76f312de463a6353" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillCorners</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillCorners</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Function to fill the corner halo regions for a specific block, handling various neighbor configurations. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The parameters of the grid and blocks </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the block to be processed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The structure containing block neighbor information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be processed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type of the variable (e.g., float, double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="5277" column="18" bodyfile="src/Halo.cu" bodystart="5277" bodyend="5408"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af52340141ab4f4e3f665ec44134720b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillCorners&lt; float &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; float &gt; XBlock, float *&amp;z)</argsstring>
        <name>fillCorners&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="5409" column="10" declfile="src/Halo.cu" declline="5409" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a3b201dc5498462f5fc345114b3633541" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillCorners&lt; double &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; double &gt; XBlock, double *&amp;z)</argsstring>
        <name>fillCorners&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="5410" column="10" declfile="src/Halo.cu" declline="5410" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9ba5024f1ba2013889f0dd2eee8e9f94" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillCornersGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>fillCornersGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>CUDA kernel to fill the corner halo regions for all active blocks in parallel, handling various neighbor configurations. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>The parameters of the grid and blocks </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The structure containing block neighbor information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be processed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type of the variable (e.g., float, double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="5420" column="29" bodyfile="src/Halo.cu" bodystart="5420" bodyend="5542"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a43113d49e13054ec5dc2b528e4d8f5b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillCornersGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z)</argsstring>
        <name>fillCornersGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="5543" column="21" declfile="src/Halo.cu" declline="5543" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a75017ac658d5b68f331f20d00d591023" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillCornersGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z)</argsstring>
        <name>fillCornersGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="5544" column="21" declfile="src/Halo.cu" declline="5544" declcolumn="21"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="preprocessor">#include<sp/>&quot;Halo.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloD(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="17"><highlight class="normal">{</highlight></codeline>
<codeline lineno="18"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"><sp/><sp/><sp/><sp/>fillLeft(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="21"><highlight class="normal"><sp/><sp/><sp/><sp/>fillRight(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="22"><highlight class="normal"><sp/><sp/><sp/><sp/>fillTop(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="23"><highlight class="normal"><sp/><sp/><sp/><sp/>fillBot(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="24"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fill<sp/>bot</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fill<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="26"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="27"><highlight class="normal"></highlight></codeline>
<codeline lineno="28"><highlight class="normal">}</highlight></codeline>
<codeline lineno="29"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloD&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="30"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloD&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="31"><highlight class="normal"></highlight></codeline>
<codeline lineno="43"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloC(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="44"><highlight class="normal">{</highlight></codeline>
<codeline lineno="45"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib;</highlight></codeline>
<codeline lineno="46"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="48"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="49"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillHaloD(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="50"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="51"><highlight class="normal">}</highlight></codeline>
<codeline lineno="52"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloC&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="53"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloC&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="54"><highlight class="normal"></highlight></codeline>
<codeline lineno="72"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RecalculateZs(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>Xev,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="73"><highlight class="normal">{</highlight></codeline>
<codeline lineno="74"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/>n;</highlight></codeline>
<codeline lineno="75"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="76"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="77"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="79"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//We<sp/>only<sp/>need<sp/>to<sp/>recalculate<sp/>zs<sp/>on<sp/>the<sp/>halo<sp/>side<sp/></highlight></codeline>
<codeline lineno="80"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>n<sp/>=<sp/>-1;<sp/>n<sp/>&lt;=<sp/>(XParam.blkwidth);<sp/>n++)</highlight></codeline>
<codeline lineno="81"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="82"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>left<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>-1,<sp/>n,<sp/>ib);</highlight></codeline>
<codeline lineno="83"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>right<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>XParam.blkwidth,<sp/>n,<sp/>ib);</highlight></codeline>
<codeline lineno="84"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>top<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>n,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="85"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bot<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>n,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="86"><highlight class="comment"></highlight></codeline>
<codeline lineno="87"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.zs[left]<sp/>=<sp/>zb[left]<sp/>+<sp/>Xev.h[left];</highlight></codeline>
<codeline lineno="88"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.zs[right]<sp/>=<sp/>zb[right]<sp/>+<sp/>Xev.h[right];</highlight></codeline>
<codeline lineno="89"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.zs[top]<sp/>=<sp/>zb[top]<sp/>+<sp/>Xev.h[top];</highlight></codeline>
<codeline lineno="90"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.zs[bot]<sp/>=<sp/>zb[bot]<sp/>+<sp/>Xev.h[bot];</highlight></codeline>
<codeline lineno="91"><highlight class="comment"></highlight></codeline>
<codeline lineno="92"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//printf(&quot;n=%d;<sp/>zsold=%f;<sp/>zsnew=%f<sp/>(zb=%f<sp/>+<sp/>h=%f)\n&quot;,n,<sp/>Xev.zs[n],<sp/>zb[n]<sp/>+<sp/>Xev.h[n],<sp/>zb[n]<sp/>,<sp/>Xev.h[n]);</highlight></codeline>
<codeline lineno="93"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="94"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="95"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Recalculate<sp/>zs<sp/>everywhere<sp/>maybe<sp/>we<sp/>only<sp/>need<sp/>to<sp/>do<sp/>that<sp/>on<sp/>the<sp/>halo<sp/>?</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>-1;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth+1);<sp/>j++)</highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>-1;<sp/>i<sp/>&lt;<sp/>(XParam.blkwidth+1);<sp/>i++)</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>memloc(XParam.halowidth,XParam.blkmemwidth,<sp/>i,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.<ref refid="structEvolvingP_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[n]<sp/>=<sp/>zb[n]<sp/>+<sp/>Xev.<ref refid="structEvolvingP_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[n];</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="107"><highlight class="normal">}</highlight></codeline>
<codeline lineno="108"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RecalculateZs&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>Xev,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>zb);</highlight></codeline>
<codeline lineno="109"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RecalculateZs&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>Xev,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>zb);</highlight></codeline>
<codeline lineno="110"><highlight class="normal"></highlight></codeline>
<codeline lineno="123"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Recalculatehh(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>Xev,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="124"><highlight class="normal">{</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/>n;</highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="130"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//We<sp/>only<sp/>need<sp/>to<sp/>recalculate<sp/>zs<sp/>on<sp/>the<sp/>halo<sp/>side</highlight></codeline>
<codeline lineno="131"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>n<sp/>=<sp/>-1;<sp/>n<sp/>&lt;=<sp/>(XParam.blkwidth);<sp/>n++)</highlight></codeline>
<codeline lineno="132"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="133"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>left<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>-1,<sp/>n,<sp/>ib);</highlight></codeline>
<codeline lineno="134"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>right<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>XParam.blkwidth,<sp/>n,<sp/>ib);</highlight></codeline>
<codeline lineno="135"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>top<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>n,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="136"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bot<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>n,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="137"><highlight class="comment"></highlight></codeline>
<codeline lineno="138"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.zs[left]<sp/>=<sp/>zb[left]<sp/>+<sp/>Xev.h[left];</highlight></codeline>
<codeline lineno="139"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.zs[right]<sp/>=<sp/>zb[right]<sp/>+<sp/>Xev.h[right];</highlight></codeline>
<codeline lineno="140"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.zs[top]<sp/>=<sp/>zb[top]<sp/>+<sp/>Xev.h[top];</highlight></codeline>
<codeline lineno="141"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.zs[bot]<sp/>=<sp/>zb[bot]<sp/>+<sp/>Xev.h[bot];</highlight></codeline>
<codeline lineno="142"><highlight class="comment"></highlight></codeline>
<codeline lineno="143"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//printf(&quot;n=%d;<sp/>zsold=%f;<sp/>zsnew=%f<sp/>(zb=%f<sp/>+<sp/>h=%f)\n&quot;,n,<sp/>Xev.zs[n],<sp/>zb[n]<sp/>+<sp/>Xev.h[n],<sp/>zb[n]<sp/>,<sp/>Xev.h[n]);</highlight></codeline>
<codeline lineno="144"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="145"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="146"><highlight class="normal"></highlight></codeline>
<codeline lineno="147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Recalculate<sp/>zs<sp/>everywhere<sp/>maybe<sp/>we<sp/>only<sp/>need<sp/>to<sp/>do<sp/>that<sp/>on<sp/>the<sp/>halo<sp/>?</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>-1;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>+<sp/>1);<sp/>j++)</highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>-1;<sp/>i<sp/>&lt;<sp/>(XParam.blkwidth<sp/>+<sp/>1);<sp/>i++)</highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>i,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.<ref refid="structEvolvingP_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[n]<sp/>=<sp/>max(Xev.<ref refid="structEvolvingP_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[n]-<sp/>zb[n],(T)0.0)<sp/>;</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="157"><highlight class="normal"></highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="159"><highlight class="normal">}</highlight></codeline>
<codeline lineno="160"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Recalculatehh&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>Xev,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>zb);</highlight></codeline>
<codeline lineno="161"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Recalculatehh&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>Xev,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>zb);</highlight></codeline>
<codeline lineno="162"><highlight class="normal"></highlight></codeline>
<codeline lineno="163"><highlight class="normal"></highlight></codeline>
<codeline lineno="180"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RecalculateZsGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>Xev,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="181"><highlight class="normal">{</highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkmemwidth;</highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x<sp/>-1;</highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y<sp/>-1;</highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/>n;</highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ib<sp/>=<sp/>XBlock.active[ibl];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/>n<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/>Xev.<ref refid="structEvolvingP_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[n]<sp/>=<sp/>zb[n]<sp/>+<sp/>Xev.<ref refid="structEvolvingP_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[n];</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="196"><highlight class="comment"><sp/><sp/><sp/><sp/>if(zb[n]<sp/>&lt;<sp/>XParam.eps)</highlight></codeline>
<codeline lineno="197"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="198"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;ix=%d,<sp/>iy=%d,<sp/>ib=%d,<sp/>n=%d;<sp/>zsold=%f;<sp/>zsnew=%f<sp/>(zb=%f<sp/>+<sp/>h=%f)\n&quot;,ix,iy,ib,<sp/>n,<sp/>Xev.zs[n],<sp/>zb[n]<sp/>+<sp/>Xev.h[n],<sp/>zb[n],<sp/>Xev.h[n]);</highlight></codeline>
<codeline lineno="199"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="200"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="202"><highlight class="normal">}</highlight></codeline>
<codeline lineno="203"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RecalculateZsGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>Xev,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>zb);</highlight></codeline>
<codeline lineno="204"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RecalculateZsGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>Xev,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>zb);</highlight></codeline>
<codeline lineno="205"><highlight class="normal"></highlight></codeline>
<codeline lineno="211"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloF(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="212"><highlight class="normal">{</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib;</highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillLeftFlux(XParam,<sp/>doProlongation,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillBotFlux(XParam,<sp/>doProlongation,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillRightFlux(XParam,<sp/>doProlongation,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillTopFlux(XParam,<sp/>doProlongation,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="223"><highlight class="normal">}</highlight></codeline>
<codeline lineno="224"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloF&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="225"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloF&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="226"><highlight class="normal"></highlight></codeline>
<codeline lineno="239"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="240"><highlight class="normal">{</highlight></codeline>
<codeline lineno="241"><highlight class="normal"></highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloLR(1,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloBT(XParam.blkwidth,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="244"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="245"><highlight class="normal"></highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/>fillLeft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>z);</highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/>fillRight<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRight<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="252"><highlight class="normal"><sp/><sp/><sp/><sp/>fillBot<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>z);</highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillBot<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/><sp/><sp/>fillTop<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTop<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaStreamSynchronize(stream));</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="259"><highlight class="normal"></highlight></codeline>
<codeline lineno="260"><highlight class="normal">}</highlight></codeline>
<codeline lineno="261"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="262"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="263"><highlight class="normal"></highlight></codeline>
<codeline lineno="272"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="273"><highlight class="normal">{</highlight></codeline>
<codeline lineno="274"><highlight class="normal"></highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloLR(1,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloBT(XParam.blkwidth,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="278"><highlight class="normal"></highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/>fillLeft<sp/>&lt;&lt;<sp/>&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;<sp/>&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>z);</highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeft<sp/>&lt;&lt;<sp/>&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;<sp/>&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/><sp/><sp/>fillRight<sp/>&lt;&lt;<sp/>&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;<sp/>&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight></codeline>
<codeline lineno="283"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRight<sp/>&lt;&lt;<sp/>&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;<sp/>&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="284"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/>fillBot<sp/>&lt;&lt;<sp/>&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;<sp/>&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>z);</highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillBot<sp/>&lt;&lt;<sp/>&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0&gt;&gt;<sp/>&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="287"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/>fillTop<sp/>&lt;&lt;<sp/>&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;<sp/>&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight></codeline>
<codeline lineno="289"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTop<sp/>&lt;&lt;<sp/>&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0&gt;&gt;<sp/>&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaStreamSynchronize(stream));</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="292"><highlight class="normal"></highlight></codeline>
<codeline lineno="293"><highlight class="normal">}</highlight></codeline>
<codeline lineno="294"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="295"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="296"><highlight class="normal"></highlight></codeline>
<codeline lineno="297"><highlight class="normal"></highlight></codeline>
<codeline lineno="306"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPUnew(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="307"><highlight class="normal">{</highlight></codeline>
<codeline lineno="308"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloLR(1,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="309"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloBT(XParam.blkwidth,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="311"><highlight class="normal"></highlight></codeline>
<codeline lineno="312"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloLRx2(2,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloBTx2(XParam.blkwidth,<sp/>2,<sp/>1);</highlight></codeline>
<codeline lineno="314"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDimx2(ceil(XParam.nblk/2),<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="315"><highlight class="normal"></highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeftnew<sp/>&lt;&lt;&lt;gridDimx2,<sp/>blockDimHaloLRx2,<sp/>0&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.nblk,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/><sp/><sp/>fillLeft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>z);</highlight></codeline>
<codeline lineno="318"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="319"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRightnew<sp/>&lt;&lt;&lt;gridDimx2,<sp/>blockDimHaloLRx2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.nblk,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/><sp/><sp/>fillRight<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight></codeline>
<codeline lineno="321"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="322"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillBotnew<sp/>&lt;&lt;&lt;gridDimx2,<sp/>blockDimHaloBTx2,<sp/>0&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.nblk,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="323"><highlight class="normal"><sp/><sp/><sp/><sp/>fillBot<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>z);</highlight></codeline>
<codeline lineno="324"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTopnew<sp/>&lt;&lt;&lt;gridDimx2,<sp/>blockDimHaloBTx2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.nblk,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/><sp/><sp/>fillTop<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="328"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaStreamSynchronize(stream));</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="329"><highlight class="normal"></highlight></codeline>
<codeline lineno="330"><highlight class="normal">}</highlight></codeline>
<codeline lineno="331"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPUnew&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="332"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPUnew&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="333"><highlight class="normal"></highlight></codeline>
<codeline lineno="334"><highlight class="normal"></highlight></codeline>
<codeline lineno="346"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloTopRightC(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="347"><highlight class="normal">{</highlight></codeline>
<codeline lineno="348"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>for<sp/>flux<sp/>term<sp/>and<sp/>actually<sp/>most<sp/>terms,<sp/>only<sp/>top<sp/>and<sp/>right<sp/>neighbours<sp/>are<sp/>needed!</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="349"><highlight class="normal"></highlight></codeline>
<codeline lineno="350"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeft(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib;</highlight></codeline>
<codeline lineno="352"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="353"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HaloFluxCPULR(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HaloFluxCPUBT(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="357"><highlight class="normal"></highlight></codeline>
<codeline lineno="358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRightFlux(XParam,true,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTopFlux(XParam,true,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="360"><highlight class="normal"></highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="362"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="363"><highlight class="normal"></highlight></codeline>
<codeline lineno="364"><highlight class="normal"></highlight></codeline>
<codeline lineno="365"><highlight class="normal">}</highlight></codeline>
<codeline lineno="366"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloTopRightC&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="367"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloTopRightC&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="368"><highlight class="normal"></highlight></codeline>
<codeline lineno="376"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLRFluxC(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="377"><highlight class="normal">{</highlight></codeline>
<codeline lineno="378"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>for<sp/>flux<sp/>term<sp/>and<sp/>actually<sp/>most<sp/>terms,<sp/>only<sp/>top<sp/>and<sp/>right<sp/>neighbours<sp/>are<sp/>needed!</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="379"><highlight class="normal"></highlight></codeline>
<codeline lineno="380"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeft(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib;</highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="383"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HaloFluxCPULR(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//HaloFluxCPUBT(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="387"><highlight class="normal"></highlight></codeline>
<codeline lineno="388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRightFlux(XParam,true,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTopFlux(XParam,true,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="390"><highlight class="normal"></highlight></codeline>
<codeline lineno="391"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="392"><highlight class="normal"></highlight></codeline>
<codeline lineno="393"><highlight class="normal"></highlight></codeline>
<codeline lineno="394"><highlight class="normal"></highlight></codeline>
<codeline lineno="395"><highlight class="normal">}</highlight></codeline>
<codeline lineno="396"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLRFluxC&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="397"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLRFluxC&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="398"><highlight class="normal"></highlight></codeline>
<codeline lineno="406"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBTFluxC(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="407"><highlight class="normal">{</highlight></codeline>
<codeline lineno="408"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>for<sp/>flux<sp/>term<sp/>and<sp/>actually<sp/>most<sp/>terms,<sp/>only<sp/>top<sp/>and<sp/>right<sp/>neighbours<sp/>are<sp/>needed!</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="409"><highlight class="normal"></highlight></codeline>
<codeline lineno="410"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeft(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="411"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib;</highlight></codeline>
<codeline lineno="412"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="413"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="414"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//HaloFluxCPULR(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="416"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HaloFluxCPUBT(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="417"><highlight class="normal"></highlight></codeline>
<codeline lineno="418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRightFlux(XParam,true,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTopFlux(XParam,true,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="420"><highlight class="normal"></highlight></codeline>
<codeline lineno="421"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="422"><highlight class="normal"></highlight></codeline>
<codeline lineno="423"><highlight class="normal"></highlight></codeline>
<codeline lineno="424"><highlight class="normal"></highlight></codeline>
<codeline lineno="425"><highlight class="normal">}</highlight></codeline>
<codeline lineno="426"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBTFluxC&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="427"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBTFluxC&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="428"><highlight class="normal"></highlight></codeline>
<codeline lineno="429"><highlight class="normal"></highlight></codeline>
<codeline lineno="438"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloTopRightGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="439"><highlight class="normal">{</highlight></codeline>
<codeline lineno="440"><highlight class="normal"></highlight></codeline>
<codeline lineno="441"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloLR(1,<sp/>16,<sp/>1);</highlight></codeline>
<codeline lineno="442"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloBT(16,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="443"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="444"><highlight class="normal"></highlight></codeline>
<codeline lineno="445"><highlight class="normal"></highlight></codeline>
<codeline lineno="446"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>a);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="447"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRightFlux<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,false,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="448"><highlight class="normal"><sp/><sp/><sp/><sp/>HaloFluxGPULR<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="449"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="450"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillBot<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>a);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="451"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTopFlux<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,false,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="452"><highlight class="normal"><sp/><sp/><sp/><sp/>HaloFluxGPUBT<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="453"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaStreamSynchronize(stream));</highlight></codeline>
<codeline lineno="454"><highlight class="normal"></highlight></codeline>
<codeline lineno="455"><highlight class="normal">}</highlight></codeline>
<codeline lineno="456"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloTopRightGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="457"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloTopRightGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="458"><highlight class="normal"></highlight></codeline>
<codeline lineno="459"><highlight class="normal"></highlight></codeline>
<codeline lineno="468"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLeftRightGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="469"><highlight class="normal">{</highlight></codeline>
<codeline lineno="470"><highlight class="normal"></highlight></codeline>
<codeline lineno="471"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloLR(1,<sp/>16,<sp/>1);</highlight></codeline>
<codeline lineno="472"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dim3<sp/>blockDimHaloBT(16,<sp/>1,<sp/>1);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="473"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="474"><highlight class="normal"></highlight></codeline>
<codeline lineno="475"><highlight class="normal"></highlight></codeline>
<codeline lineno="476"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>a);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="477"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRightFlux<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,false,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="478"><highlight class="normal"><sp/><sp/><sp/><sp/>HaloFluxGPULR<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="479"><highlight class="normal"></highlight></codeline>
<codeline lineno="480"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillBot<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>a);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="481"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTopFlux<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,false,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="482"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//HaloFluxGPUBT<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="483"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaStreamSynchronize(stream));</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="484"><highlight class="normal"></highlight></codeline>
<codeline lineno="485"><highlight class="normal">}</highlight></codeline>
<codeline lineno="486"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLeftRightGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="487"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLeftRightGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="488"><highlight class="normal"></highlight></codeline>
<codeline lineno="489"><highlight class="normal"></highlight></codeline>
<codeline lineno="497"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLeftRightGPUnew(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="498"><highlight class="normal">{</highlight></codeline>
<codeline lineno="499"><highlight class="normal"></highlight></codeline>
<codeline lineno="500"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloLR(2,<sp/>16,<sp/>1);</highlight></codeline>
<codeline lineno="501"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dim3<sp/>blockDimHaloBT(16,<sp/>1,<sp/>1);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="502"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(ceil(XParam.nblk/2),<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="503"><highlight class="normal"></highlight></codeline>
<codeline lineno="504"><highlight class="normal"><sp/><sp/><sp/><sp/>HaloFluxGPULRnew<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="505"><highlight class="normal"></highlight></codeline>
<codeline lineno="506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="507"><highlight class="normal"></highlight></codeline>
<codeline lineno="508"><highlight class="normal">}</highlight></codeline>
<codeline lineno="509"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLeftRightGPUnew&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="510"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLeftRightGPUnew&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="511"><highlight class="normal"></highlight></codeline>
<codeline lineno="524"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBotTopGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="525"><highlight class="normal">{</highlight></codeline>
<codeline lineno="526"><highlight class="normal"></highlight></codeline>
<codeline lineno="527"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dim3<sp/>blockDimHaloLR(1,<sp/>16,<sp/>1);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="528"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloBT(16,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="529"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="530"><highlight class="normal"></highlight></codeline>
<codeline lineno="531"><highlight class="normal"></highlight></codeline>
<codeline lineno="532"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>a);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="533"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRightFlux<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,false,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="534"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//HaloFluxGPULR<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="535"><highlight class="normal"></highlight></codeline>
<codeline lineno="536"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillBot<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>a);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="537"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTopFlux<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,false,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="538"><highlight class="normal"><sp/><sp/><sp/><sp/>HaloFluxGPUBT<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="539"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaStreamSynchronize(stream));</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="540"><highlight class="normal"></highlight></codeline>
<codeline lineno="541"><highlight class="normal">}</highlight></codeline>
<codeline lineno="542"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBotTopGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="543"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBotTopGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="544"><highlight class="normal"></highlight></codeline>
<codeline lineno="557"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBotTopGPUnew(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="558"><highlight class="normal">{</highlight></codeline>
<codeline lineno="559"><highlight class="normal"></highlight></codeline>
<codeline lineno="560"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dim3<sp/>blockDimHaloLR(1,<sp/>16,<sp/>1);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="561"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloBT(16,<sp/>2,<sp/>1);</highlight></codeline>
<codeline lineno="562"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(ceil(XParam.nblk/2),<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="563"><highlight class="normal"></highlight></codeline>
<codeline lineno="564"><highlight class="normal"></highlight></codeline>
<codeline lineno="565"><highlight class="normal"><sp/><sp/><sp/><sp/>HaloFluxGPUBTnew<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="566"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="567"><highlight class="normal"></highlight></codeline>
<codeline lineno="568"><highlight class="normal">}</highlight></codeline>
<codeline lineno="569"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBotTopGPUnew&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="570"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBotTopGPUnew&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="571"><highlight class="normal"></highlight></codeline>
<codeline lineno="572"><highlight class="normal"></highlight></codeline>
<codeline lineno="586"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>Xev,<sp/>T*zb)</highlight></codeline>
<codeline lineno="587"><highlight class="normal">{</highlight></codeline>
<codeline lineno="588"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="589"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="590"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::thread<sp/>t0(fillHaloC&lt;T&gt;,XParam,<sp/>XBlock,<sp/>Xev.<ref refid="structEvolvingP_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>);</highlight></codeline>
<codeline lineno="591"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::thread<sp/>t1(fillHaloC&lt;T&gt;,XParam,<sp/>XBlock,<sp/>Xev.<ref refid="structEvolvingP_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>);</highlight></codeline>
<codeline lineno="592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t2(fillHaloF&lt;T&gt;,XParam,true,<sp/>XBlock,<sp/>Xev.u);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t3(fillHaloF&lt;T&gt;,XParam,true,<sp/>XBlock,<sp/>Xev.v);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="594"><highlight class="normal"></highlight></codeline>
<codeline lineno="595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::thread<sp/>t2(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Xev.<ref refid="structEvolvingP_1addf0f1e2e0672ff7d32890c1867d1586" kindref="member">u</ref>);</highlight></codeline>
<codeline lineno="596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::thread<sp/>t3(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Xev.<ref refid="structEvolvingP_1a5f61fdbd33ae88a62d35dd5235d8f375" kindref="member">v</ref>);</highlight></codeline>
<codeline lineno="597"><highlight class="normal"></highlight></codeline>
<codeline lineno="598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>t0.join();</highlight></codeline>
<codeline lineno="599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>t1.join();</highlight></codeline>
<codeline lineno="600"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>t2.join();</highlight></codeline>
<codeline lineno="601"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>t3.join();</highlight></codeline>
<codeline lineno="602"><highlight class="normal"></highlight></codeline>
<codeline lineno="603"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.conserveElevation)</highlight></codeline>
<codeline lineno="604"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="605"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>conserveElevation(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight></codeline>
<codeline lineno="606"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.wetdryfix)</highlight></codeline>
<codeline lineno="608"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="609"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetDryRestriction(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight></codeline>
<codeline lineno="610"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="611"><highlight class="normal"></highlight></codeline>
<codeline lineno="612"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RecalculateZs(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight></codeline>
<codeline lineno="613"><highlight class="normal"></highlight></codeline>
<codeline lineno="614"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maskbnd(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight></codeline>
<codeline lineno="615"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="616"><highlight class="normal">}</highlight></codeline>
<codeline lineno="617"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>Xev,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*zb);</highlight></codeline>
<codeline lineno="618"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>Xev,</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*<sp/>zb);</highlight></codeline>
<codeline lineno="619"><highlight class="normal"></highlight></codeline>
<codeline lineno="632"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>Xev)</highlight></codeline>
<codeline lineno="633"><highlight class="normal">{</highlight></codeline>
<codeline lineno="634"><highlight class="normal"></highlight></codeline>
<codeline lineno="635"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t0(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Xev.<ref refid="structEvolvingP_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>);</highlight></codeline>
<codeline lineno="636"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t1(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Xev.<ref refid="structEvolvingP_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>);</highlight></codeline>
<codeline lineno="637"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t2(fillHaloF&lt;T&gt;,<sp/>XParam,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>XBlock,<sp/>Xev.<ref refid="structEvolvingP_1addf0f1e2e0672ff7d32890c1867d1586" kindref="member">u</ref>);</highlight></codeline>
<codeline lineno="638"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t3(fillHaloF&lt;T&gt;,<sp/>XParam,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>XBlock,<sp/>Xev.<ref refid="structEvolvingP_1a5f61fdbd33ae88a62d35dd5235d8f375" kindref="member">v</ref>);</highlight></codeline>
<codeline lineno="639"><highlight class="normal"></highlight></codeline>
<codeline lineno="640"><highlight class="normal"><sp/><sp/><sp/><sp/>t0.join();</highlight></codeline>
<codeline lineno="641"><highlight class="normal"><sp/><sp/><sp/><sp/>t1.join();</highlight></codeline>
<codeline lineno="642"><highlight class="normal"><sp/><sp/><sp/><sp/>t2.join();</highlight></codeline>
<codeline lineno="643"><highlight class="normal"><sp/><sp/><sp/><sp/>t3.join();</highlight></codeline>
<codeline lineno="644"><highlight class="normal"></highlight></codeline>
<codeline lineno="645"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="646"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//maskbnd(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="647"><highlight class="normal"></highlight></codeline>
<codeline lineno="648"><highlight class="normal">}</highlight></codeline>
<codeline lineno="649"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>Xev);</highlight></codeline>
<codeline lineno="650"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>Xev);</highlight></codeline>
<codeline lineno="651"><highlight class="normal"></highlight></codeline>
<codeline lineno="659"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>Xev)</highlight></codeline>
<codeline lineno="660"><highlight class="normal">{</highlight></codeline>
<codeline lineno="661"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_streams<sp/>=<sp/>4;</highlight></codeline>
<codeline lineno="662"><highlight class="normal"></highlight></codeline>
<codeline lineno="663"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaStream_t<sp/>streams[num_streams];</highlight></codeline>
<codeline lineno="664"><highlight class="normal"></highlight></codeline>
<codeline lineno="665"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="666"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));</highlight></codeline>
<codeline lineno="668"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="669"><highlight class="normal"></highlight></codeline>
<codeline lineno="670"><highlight class="normal"></highlight></codeline>
<codeline lineno="671"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[0],<sp/>Xev.<ref refid="structEvolvingP_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>);</highlight></codeline>
<codeline lineno="672"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[1],<sp/>Xev.<ref refid="structEvolvingP_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>);</highlight></codeline>
<codeline lineno="673"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[2],<sp/>Xev.<ref refid="structEvolvingP_1addf0f1e2e0672ff7d32890c1867d1586" kindref="member">u</ref>);</highlight></codeline>
<codeline lineno="674"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[3],<sp/>Xev.<ref refid="structEvolvingP_1a5f61fdbd33ae88a62d35dd5235d8f375" kindref="member">v</ref>);</highlight></codeline>
<codeline lineno="675"><highlight class="normal"></highlight></codeline>
<codeline lineno="676"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="677"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="678"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStreamDestroy(streams[i]);</highlight></codeline>
<codeline lineno="679"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="680"><highlight class="normal">}</highlight></codeline>
<codeline lineno="681"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>Xev);</highlight></codeline>
<codeline lineno="682"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>Xev);</highlight></codeline>
<codeline lineno="683"><highlight class="normal"></highlight></codeline>
<codeline lineno="699"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>Xev,T<sp/>*<sp/>zb)</highlight></codeline>
<codeline lineno="700"><highlight class="normal">{</highlight></codeline>
<codeline lineno="701"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_streams<sp/>=<sp/>4;</highlight></codeline>
<codeline lineno="702"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHalo(XParam.blkwidth,1,<sp/>1);</highlight></codeline>
<codeline lineno="703"><highlight class="normal"></highlight></codeline>
<codeline lineno="704"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XBlock.mask.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="705"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="706"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimfull(XParam.blkmemwidth,<sp/>XParam.blkmemwidth,<sp/>1);</highlight></codeline>
<codeline lineno="707"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDimfull(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="708"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="709"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaStream_t<sp/>streams[num_streams];</highlight></codeline>
<codeline lineno="710"><highlight class="normal"></highlight></codeline>
<codeline lineno="711"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="712"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));</highlight></codeline>
<codeline lineno="714"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="715"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="716"><highlight class="normal"></highlight></codeline>
<codeline lineno="717"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[0],<sp/>Xev.<ref refid="structEvolvingP_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>);</highlight></codeline>
<codeline lineno="718"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[1],<sp/>Xev.<ref refid="structEvolvingP_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>);</highlight></codeline>
<codeline lineno="719"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[2],<sp/>Xev.<ref refid="structEvolvingP_1addf0f1e2e0672ff7d32890c1867d1586" kindref="member">u</ref>);</highlight></codeline>
<codeline lineno="720"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[3],<sp/>Xev.<ref refid="structEvolvingP_1a5f61fdbd33ae88a62d35dd5235d8f375" kindref="member">v</ref>);</highlight></codeline>
<codeline lineno="721"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="722"><highlight class="normal"></highlight></codeline>
<codeline lineno="723"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.conserveElevation)</highlight></codeline>
<codeline lineno="724"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>conserveElevationGPU(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight></codeline>
<codeline lineno="726"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="727"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.wetdryfix)</highlight></codeline>
<codeline lineno="728"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetDryRestrictionGPU(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight></codeline>
<codeline lineno="730"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="731"><highlight class="normal"></highlight></codeline>
<codeline lineno="732"><highlight class="normal"><sp/><sp/><sp/><sp/>RecalculateZsGPU<sp/>&lt;&lt;&lt;<sp/>gridDimfull,<sp/>blockDimfull,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight></codeline>
<codeline lineno="733"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="734"><highlight class="normal"></highlight></codeline>
<codeline lineno="735"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//if<sp/>(XBlock.mask.nblk<sp/>&gt;<sp/>0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="736"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="737"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>maskbndGPUleft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[0]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="738"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>maskbndGPUtop<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[1]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="739"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>maskbndGPUright<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[2]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="740"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>maskbndGPUtop<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[3]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="741"><highlight class="normal"></highlight></codeline>
<codeline lineno="742"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="743"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="744"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="745"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStreamDestroy(streams[i]);</highlight></codeline>
<codeline lineno="747"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="748"><highlight class="normal"></highlight></codeline>
<codeline lineno="749"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="750"><highlight class="normal">}</highlight></codeline>
<codeline lineno="751"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>Xev,</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*zb);</highlight></codeline>
<codeline lineno="752"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>Xev,</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>zb);</highlight></codeline>
<codeline lineno="753"><highlight class="normal"></highlight></codeline>
<codeline lineno="765"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structGradientsP" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>Grad)</highlight></codeline>
<codeline lineno="766"><highlight class="normal">{</highlight></codeline>
<codeline lineno="767"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="768"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="769"><highlight class="comment"><sp/><sp/><sp/><sp/>std::thread<sp/>t0(fillHaloF&lt;T&gt;,XParam,<sp/>true,<sp/>XBlock,<sp/>Grad.dhdx);</highlight></codeline>
<codeline lineno="770"><highlight class="comment"><sp/><sp/><sp/><sp/>std::thread<sp/>t1(fillHaloF&lt;T&gt;,XParam,<sp/>true,<sp/>XBlock,<sp/>Grad.dudx);</highlight></codeline>
<codeline lineno="771"><highlight class="comment"><sp/><sp/><sp/><sp/>std::thread<sp/>t2(fillHaloF&lt;T&gt;,XParam,<sp/>true,<sp/>XBlock,<sp/>Grad.dvdx);</highlight></codeline>
<codeline lineno="772"><highlight class="comment"><sp/><sp/><sp/><sp/>std::thread<sp/>t3(fillHaloF&lt;T&gt;,XParam,<sp/>true,<sp/>XBlock,<sp/>Grad.dzsdx);</highlight></codeline>
<codeline lineno="773"><highlight class="comment"></highlight></codeline>
<codeline lineno="774"><highlight class="comment"><sp/><sp/><sp/><sp/>std::thread<sp/>t4(fillHaloF&lt;T&gt;,XParam,<sp/>true,<sp/>XBlock,<sp/>Grad.dhdy);</highlight></codeline>
<codeline lineno="775"><highlight class="comment"><sp/><sp/><sp/><sp/>std::thread<sp/>t5(fillHaloF&lt;T&gt;,XParam,<sp/>true,<sp/>XBlock,<sp/>Grad.dudy);</highlight></codeline>
<codeline lineno="776"><highlight class="comment"><sp/><sp/><sp/><sp/>std::thread<sp/>t6(fillHaloF&lt;T&gt;,XParam,<sp/>true,<sp/>XBlock,<sp/>Grad.dvdy);</highlight></codeline>
<codeline lineno="777"><highlight class="comment"><sp/><sp/><sp/><sp/>std::thread<sp/>t7(fillHaloF&lt;T&gt;,XParam,<sp/>true,<sp/>XBlock,<sp/>Grad.dzsdy);</highlight></codeline>
<codeline lineno="778"><highlight class="comment"></highlight></codeline>
<codeline lineno="779"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="780"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t0(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Grad.<ref refid="structGradientsP_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>);</highlight></codeline>
<codeline lineno="781"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t1(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Grad.<ref refid="structGradientsP_1a031883fc1cf8682f6eb513f6dd46f47e" kindref="member">dudx</ref>);</highlight></codeline>
<codeline lineno="782"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t2(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Grad.<ref refid="structGradientsP_1aa5192b823cd1b71e7622d3e3c90ff163" kindref="member">dvdx</ref>);</highlight></codeline>
<codeline lineno="783"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t3(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Grad.<ref refid="structGradientsP_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>);</highlight></codeline>
<codeline lineno="784"><highlight class="normal"></highlight></codeline>
<codeline lineno="785"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t4(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Grad.<ref refid="structGradientsP_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>);</highlight></codeline>
<codeline lineno="786"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t5(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Grad.<ref refid="structGradientsP_1ac700564ea6800deeed698502ab8a15eb" kindref="member">dudy</ref>);</highlight></codeline>
<codeline lineno="787"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t6(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Grad.<ref refid="structGradientsP_1aebefd731d1813ab1af3f7c282a5ba2e5" kindref="member">dvdy</ref>);</highlight></codeline>
<codeline lineno="788"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t7(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Grad.<ref refid="structGradientsP_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="789"><highlight class="normal"></highlight></codeline>
<codeline lineno="790"><highlight class="normal"><sp/><sp/><sp/><sp/>t0.join();</highlight></codeline>
<codeline lineno="791"><highlight class="normal"><sp/><sp/><sp/><sp/>t1.join();</highlight></codeline>
<codeline lineno="792"><highlight class="normal"><sp/><sp/><sp/><sp/>t2.join();</highlight></codeline>
<codeline lineno="793"><highlight class="normal"><sp/><sp/><sp/><sp/>t3.join();</highlight></codeline>
<codeline lineno="794"><highlight class="normal"><sp/><sp/><sp/><sp/>t4.join();</highlight></codeline>
<codeline lineno="795"><highlight class="normal"><sp/><sp/><sp/><sp/>t5.join();</highlight></codeline>
<codeline lineno="796"><highlight class="normal"><sp/><sp/><sp/><sp/>t6.join();</highlight></codeline>
<codeline lineno="797"><highlight class="normal"><sp/><sp/><sp/><sp/>t7.join();</highlight></codeline>
<codeline lineno="798"><highlight class="normal"></highlight></codeline>
<codeline lineno="799"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="800"><highlight class="normal">}</highlight></codeline>
<codeline lineno="801"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structGradientsP" kindref="compound">GradientsP&lt;float&gt;</ref><sp/>Grad);</highlight></codeline>
<codeline lineno="802"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structGradientsP" kindref="compound">GradientsP&lt;double&gt;</ref><sp/>Grad);</highlight></codeline>
<codeline lineno="803"><highlight class="normal"></highlight></codeline>
<codeline lineno="811"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structGradientsP" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>Grad)</highlight></codeline>
<codeline lineno="812"><highlight class="normal">{</highlight></codeline>
<codeline lineno="813"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_streams<sp/>=<sp/>8;</highlight></codeline>
<codeline lineno="814"><highlight class="normal"></highlight></codeline>
<codeline lineno="815"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaStream_t<sp/>streams[num_streams];</highlight></codeline>
<codeline lineno="816"><highlight class="normal"></highlight></codeline>
<codeline lineno="817"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="818"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="819"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));</highlight></codeline>
<codeline lineno="820"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="821"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="822"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[0],<sp/>Grad.<ref refid="structGradientsP_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>);</highlight></codeline>
<codeline lineno="823"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[2],<sp/>Grad.<ref refid="structGradientsP_1a031883fc1cf8682f6eb513f6dd46f47e" kindref="member">dudx</ref>);</highlight></codeline>
<codeline lineno="824"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[3],<sp/>Grad.<ref refid="structGradientsP_1aa5192b823cd1b71e7622d3e3c90ff163" kindref="member">dvdx</ref>);</highlight></codeline>
<codeline lineno="825"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[4],<sp/>Grad.<ref refid="structGradientsP_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>);</highlight></codeline>
<codeline lineno="826"><highlight class="normal"></highlight></codeline>
<codeline lineno="827"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[5],<sp/>Grad.<ref refid="structGradientsP_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>);</highlight></codeline>
<codeline lineno="828"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[6],<sp/>Grad.<ref refid="structGradientsP_1ac700564ea6800deeed698502ab8a15eb" kindref="member">dudy</ref>);</highlight></codeline>
<codeline lineno="829"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[7],<sp/>Grad.<ref refid="structGradientsP_1aebefd731d1813ab1af3f7c282a5ba2e5" kindref="member">dvdy</ref>);</highlight></codeline>
<codeline lineno="830"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[1],<sp/>Grad.<ref refid="structGradientsP_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="831"><highlight class="normal"></highlight></codeline>
<codeline lineno="832"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="833"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStreamDestroy(streams[i]);</highlight></codeline>
<codeline lineno="835"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="836"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="837"><highlight class="normal">}</highlight></codeline>
<codeline lineno="838"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structGradientsP" kindref="compound">GradientsP&lt;float&gt;</ref><sp/>Grad);</highlight></codeline>
<codeline lineno="839"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structGradientsP" kindref="compound">GradientsP&lt;double&gt;</ref><sp/>Grad);</highlight></codeline>
<codeline lineno="840"><highlight class="normal"></highlight></codeline>
<codeline lineno="841"><highlight class="normal"></highlight></codeline>
<codeline lineno="849"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;T&gt;</ref><sp/>Flux)</highlight></codeline>
<codeline lineno="850"><highlight class="normal">{</highlight></codeline>
<codeline lineno="851"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="853"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t0(fillHaloTopRightC&lt;T&gt;,XParam,<sp/>XBlock,<sp/>Flux.Fhu);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="854"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t1(fillHaloTopRightC&lt;T&gt;,XParam,<sp/>XBlock,<sp/>Flux.Fhv);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="855"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t2(fillHaloTopRightC&lt;T&gt;,XParam,<sp/>XBlock,<sp/>Flux.Fqux);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="856"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t3(fillHaloTopRightC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Fquy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="857"><highlight class="normal"></highlight></codeline>
<codeline lineno="858"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t4(fillHaloTopRightC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Fqvx);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="859"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t5(fillHaloTopRightC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Fqvy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="860"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t6(fillHaloTopRightC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Su);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="861"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t7(fillHaloTopRightC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Sv);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="862"><highlight class="normal"></highlight></codeline>
<codeline lineno="863"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t0(fillHaloLRFluxC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.<ref refid="structFluxP_1a17e14a93800ccca171a596871947c9aa" kindref="member">Fhu</ref>);</highlight></codeline>
<codeline lineno="864"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t1(fillHaloLRFluxC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.<ref refid="structFluxP_1ac3a599f0ed00e32352dd20edf2dd568a" kindref="member">Fqux</ref>);</highlight></codeline>
<codeline lineno="865"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t2(fillHaloLRFluxC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.<ref refid="structFluxP_1a84d46ac49567a37b6003659653e7c61c" kindref="member">Su</ref>);</highlight></codeline>
<codeline lineno="866"><highlight class="normal"></highlight></codeline>
<codeline lineno="867"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t6(fillHaloLRFluxC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.<ref refid="structFluxP_1ad61f95624bb8f5f41944124e94977242" kindref="member">Fqvx</ref>);</highlight></codeline>
<codeline lineno="868"><highlight class="normal"></highlight></codeline>
<codeline lineno="869"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t3(fillHaloBTFluxC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.<ref refid="structFluxP_1aeb4d674a60d5436fa152886412c4107c" kindref="member">Fhv</ref>);</highlight></codeline>
<codeline lineno="870"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t4(fillHaloBTFluxC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.<ref refid="structFluxP_1ad441ac258b404df19af2189862bd4a6b" kindref="member">Fqvy</ref>);</highlight></codeline>
<codeline lineno="871"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t5(fillHaloBTFluxC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.<ref refid="structFluxP_1ac8a06855719d653e239263c10b602772" kindref="member">Sv</ref>);</highlight></codeline>
<codeline lineno="872"><highlight class="normal"></highlight></codeline>
<codeline lineno="873"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t7(fillHaloBTFluxC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.<ref refid="structFluxP_1ad532ddfa554b8e9985152e482fe2d44b" kindref="member">Fquy</ref>);</highlight></codeline>
<codeline lineno="874"><highlight class="normal"></highlight></codeline>
<codeline lineno="875"><highlight class="normal"><sp/><sp/><sp/><sp/>t0.join();</highlight></codeline>
<codeline lineno="876"><highlight class="normal"><sp/><sp/><sp/><sp/>t1.join();</highlight></codeline>
<codeline lineno="877"><highlight class="normal"><sp/><sp/><sp/><sp/>t2.join();</highlight></codeline>
<codeline lineno="878"><highlight class="normal"><sp/><sp/><sp/><sp/>t3.join();</highlight></codeline>
<codeline lineno="879"><highlight class="normal"><sp/><sp/><sp/><sp/>t4.join();</highlight></codeline>
<codeline lineno="880"><highlight class="normal"><sp/><sp/><sp/><sp/>t5.join();</highlight></codeline>
<codeline lineno="881"><highlight class="normal"><sp/><sp/><sp/><sp/>t6.join();</highlight></codeline>
<codeline lineno="882"><highlight class="normal"><sp/><sp/><sp/><sp/>t7.join();</highlight></codeline>
<codeline lineno="883"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="884"><highlight class="normal">}</highlight></codeline>
<codeline lineno="885"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;float&gt;</ref><sp/>Flux);</highlight></codeline>
<codeline lineno="886"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;double&gt;</ref><sp/>Flux);</highlight></codeline>
<codeline lineno="887"><highlight class="normal"></highlight></codeline>
<codeline lineno="895"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;T&gt;</ref><sp/>Flux)</highlight></codeline>
<codeline lineno="896"><highlight class="normal">{</highlight></codeline>
<codeline lineno="897"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_streams<sp/>=<sp/>8;</highlight></codeline>
<codeline lineno="898"><highlight class="normal"></highlight></codeline>
<codeline lineno="899"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaStream_t<sp/>streams[num_streams];</highlight></codeline>
<codeline lineno="900"><highlight class="normal"></highlight></codeline>
<codeline lineno="901"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="902"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="903"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));</highlight></codeline>
<codeline lineno="904"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="905"><highlight class="normal"></highlight></codeline>
<codeline lineno="906"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHalo(XParam.blkwidth,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="907"><highlight class="normal"></highlight></codeline>
<codeline lineno="908"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XBlock.mask.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="909"><highlight class="normal"></highlight></codeline>
<codeline lineno="910"><highlight class="normal"></highlight></codeline>
<codeline lineno="911"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloLeftRightGPUnew(XParam,<sp/>XBlock,<sp/>streams[0],<sp/>Flux.<ref refid="structFluxP_1a17e14a93800ccca171a596871947c9aa" kindref="member">Fhu</ref>);</highlight></codeline>
<codeline lineno="912"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloLeftRightGPUnew(XParam,<sp/>XBlock,<sp/>streams[1],<sp/>Flux.<ref refid="structFluxP_1a84d46ac49567a37b6003659653e7c61c" kindref="member">Su</ref>);</highlight></codeline>
<codeline lineno="913"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloLeftRightGPUnew(XParam,<sp/>XBlock,<sp/>streams[2],<sp/>Flux.<ref refid="structFluxP_1ac3a599f0ed00e32352dd20edf2dd568a" kindref="member">Fqux</ref>);</highlight></codeline>
<codeline lineno="914"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloLeftRightGPUnew(XParam,<sp/>XBlock,<sp/>streams[3],<sp/>Flux.<ref refid="structFluxP_1ad61f95624bb8f5f41944124e94977242" kindref="member">Fqvx</ref>);</highlight></codeline>
<codeline lineno="915"><highlight class="normal"></highlight></codeline>
<codeline lineno="916"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="917"><highlight class="normal"></highlight></codeline>
<codeline lineno="918"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloBotTopGPUnew(XParam,<sp/>XBlock,<sp/>streams[4],<sp/>Flux.<ref refid="structFluxP_1ad532ddfa554b8e9985152e482fe2d44b" kindref="member">Fquy</ref>);</highlight></codeline>
<codeline lineno="919"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloBotTopGPUnew(XParam,<sp/>XBlock,<sp/>streams[5],<sp/>Flux.<ref refid="structFluxP_1ad441ac258b404df19af2189862bd4a6b" kindref="member">Fqvy</ref>);</highlight></codeline>
<codeline lineno="920"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloBotTopGPUnew(XParam,<sp/>XBlock,<sp/>streams[6],<sp/>Flux.<ref refid="structFluxP_1aeb4d674a60d5436fa152886412c4107c" kindref="member">Fhv</ref>);</highlight></codeline>
<codeline lineno="921"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloBotTopGPUnew(XParam,<sp/>XBlock,<sp/>streams[7],<sp/>Flux.<ref refid="structFluxP_1ac8a06855719d653e239263c10b602772" kindref="member">Sv</ref>);</highlight></codeline>
<codeline lineno="922"><highlight class="normal"></highlight></codeline>
<codeline lineno="923"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="924"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="925"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="926"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStreamSynchronize(streams[i]);</highlight></codeline>
<codeline lineno="927"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="928"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Below<sp/>has<sp/>now<sp/>moved<sp/>to<sp/>its<sp/>own<sp/>function</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="929"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//if<sp/>(XBlock.mask.nblk<sp/>&gt;<sp/>0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="930"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="931"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>maskbndGPUFluxleft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[0]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Flux);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="932"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>maskbndGPUFluxtop<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[1]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Flux);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="933"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>maskbndGPUFluxright<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[2]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Flux);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="934"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>maskbndGPUFluxbot<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[3]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Flux);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="935"><highlight class="normal"></highlight></codeline>
<codeline lineno="936"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="937"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="938"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="939"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="940"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStreamDestroy(streams[i]);</highlight></codeline>
<codeline lineno="942"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="943"><highlight class="normal"></highlight></codeline>
<codeline lineno="944"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="945"><highlight class="normal">}</highlight></codeline>
<codeline lineno="946"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;float&gt;</ref><sp/>Flux);</highlight></codeline>
<codeline lineno="947"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;double&gt;</ref><sp/>Flux);</highlight></codeline>
<codeline lineno="948"><highlight class="normal"></highlight></codeline>
<codeline lineno="957"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>bndmaskGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>Xev,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;T&gt;</ref><sp/>Flux)</highlight></codeline>
<codeline lineno="958"><highlight class="normal">{</highlight></codeline>
<codeline lineno="959"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_streams<sp/>=<sp/>8;</highlight></codeline>
<codeline lineno="960"><highlight class="normal"></highlight></codeline>
<codeline lineno="961"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaStream_t<sp/>streams[num_streams];</highlight></codeline>
<codeline lineno="962"><highlight class="normal"></highlight></codeline>
<codeline lineno="963"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="964"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="965"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));</highlight></codeline>
<codeline lineno="966"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="967"><highlight class="normal"></highlight></codeline>
<codeline lineno="968"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHalo(XParam.blkwidth,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="969"><highlight class="normal"></highlight></codeline>
<codeline lineno="970"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XBlock.mask.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="971"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.mask.nblk<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="972"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maskbndGPUFluxleft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[0]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Xev,<sp/>Flux);</highlight></codeline>
<codeline lineno="974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maskbndGPUFluxtop<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[1]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/><sp/>Flux);</highlight></codeline>
<codeline lineno="975"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maskbndGPUFluxright<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[2]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/><sp/>Flux);</highlight></codeline>
<codeline lineno="976"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maskbndGPUFluxbot<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[3]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Flux);</highlight></codeline>
<codeline lineno="977"><highlight class="normal"></highlight></codeline>
<codeline lineno="978"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="979"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="980"><highlight class="normal"></highlight></codeline>
<codeline lineno="981"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="982"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="983"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStreamDestroy(streams[i]);</highlight></codeline>
<codeline lineno="984"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="985"><highlight class="normal"></highlight></codeline>
<codeline lineno="986"><highlight class="normal">}</highlight></codeline>
<codeline lineno="987"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>bndmaskGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>Xev,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;float&gt;</ref><sp/>Flux);</highlight></codeline>
<codeline lineno="988"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>bndmaskGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>Xev,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;double&gt;</ref><sp/>Flux);</highlight></codeline>
<codeline lineno="989"><highlight class="normal"></highlight></codeline>
<codeline lineno="990"><highlight class="normal"></highlight><highlight class="comment">//template<sp/>&lt;class<sp/>T&gt;<sp/>void<sp/>refine_linearCPU(Param<sp/>XParam,<sp/>int<sp/>ib,<sp/>bool<sp/>isLR,<sp/>bool<sp/>isoposit,<sp/>BlockP&lt;T&gt;<sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="991"><highlight class="normal"></highlight><highlight class="comment">//{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="992"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>int<sp/>Neighblock,<sp/>Mirrorblock;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="993"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="994"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>int<sp/>ir<sp/>=<sp/>isoposit<sp/>?<sp/>0<sp/>:<sp/>XParam.blkwidth<sp/>-<sp/>1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="995"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>int<sp/>iw<sp/>=<sp/>isoposit<sp/>?<sp/>XParam.blkwidth<sp/>:<sp/>-1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="996"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>if<sp/>(isLR)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="997"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="998"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/>Neighblock<sp/>=<sp/>isoposit<sp/>?<sp/>XBlock.RightBot[ib]<sp/>:<sp/>XBlock.LeftBot[ib];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="999"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/>Mirrorblock<sp/>=<sp/>isoposit<sp/>?<sp/>XBlock.LeftBot[Neighblock]<sp/>:<sp/>XBlock.RightBot[Neighblock]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1000"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1001"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1002"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1003"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/>Neighblock<sp/>=<sp/>isoposit<sp/>?<sp/>XBlock.TopLeft[ib]<sp/>:<sp/>XBlock.BotLeft[ib];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1004"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/>Mirrorblock<sp/>=<sp/>isoposit<sp/>?<sp/>XBlock.BotLeft[Neighblock]<sp/>:<sp/>XBlock.TopLeft[Neighblock]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1005"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1006"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1007"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>if<sp/>(XBlock.level[Neighblock]<sp/>&lt;<sp/>XBlock.level[ib])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1008"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1009"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>ilevdx<sp/>=<sp/>calcres(XParam.dx,<sp/>XBlock.level[ib])<sp/>*<sp/>T(0.25);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1010"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>ix<sp/>=<sp/>0;<sp/>ix<sp/>&lt;<sp/>XParam.blkwidth;<sp/>ix++)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1011"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/>{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1012"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>jj<sp/>=<sp/>Mirrorblock<sp/>==<sp/>ib<sp/>?<sp/>floor(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>floor(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1013"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>il<sp/>=<sp/>isLR<sp/>?<sp/>memloc(XParam,<sp/>ir,<sp/>jj,<sp/>Neighblock)<sp/>:<sp/>memloc(XParam,<sp/>jj,<sp/>ir,<sp/>Neighblock);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1014"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>write<sp/>=<sp/>isLR<sp/>?<sp/>memloc(XParam,<sp/>iw,<sp/>j,<sp/>ib)<sp/>:<sp/>memloc(XParam,<sp/>j,<sp/>iw,<sp/>ib);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1015"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>T(-1.0);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1016"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&gt;<sp/>j<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1017"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1018"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[il]<sp/>+<sp/>(faclr<sp/>*<sp/>dzdx[il]<sp/>+<sp/>facbt<sp/>*<sp/>dzdy[il])<sp/>*<sp/>ilevdx;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1019"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1020"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1021"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1022"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1023"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/>}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1024"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1025"><highlight class="normal"></highlight><highlight class="comment">//}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1026"><highlight class="normal"></highlight><highlight class="comment">//template<sp/>void<sp/>refine_linearCPU&lt;float&gt;(Param<sp/>XParam,<sp/>int<sp/>ib,<sp/>BlockP&lt;float&gt;<sp/>XBlock,<sp/>float*<sp/>z,<sp/>float*<sp/>dzdx,<sp/>float*<sp/>dzdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1027"><highlight class="normal"></highlight><highlight class="comment">//template<sp/>void<sp/>refine_linearCPU&lt;double&gt;(Param<sp/>XParam,<sp/>int<sp/>ib,<sp/>BlockP&lt;double&gt;<sp/>XBlock,<sp/>double*<sp/>z,<sp/>double*<sp/>dzdx,<sp/>double*<sp/>dzdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1028"><highlight class="normal"></highlight></codeline>
<codeline lineno="1044"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Left(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T<sp/>*<sp/>dzdx,<sp/>T<sp/>*<sp/>dzdy)</highlight></codeline>
<codeline lineno="1045"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1046"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="1047"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1048"><highlight class="normal"></highlight></codeline>
<codeline lineno="1049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ilevdx<sp/>=<sp/>calcres(XParam.delta,<sp/>XBlock.level[ib])*T(0.5);</highlight></codeline>
<codeline lineno="1050"><highlight class="normal"></highlight></codeline>
<codeline lineno="1051"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="1052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1053"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.RightBot[XBlock.LeftBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(floor(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(floor(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="1054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>jj<sp/>,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>T(1.0);</highlight></codeline>
<codeline lineno="1057"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&lt;<sp/>(j-T(0.01))<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight></codeline>
<codeline lineno="1058"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1059"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[il]<sp/>+<sp/>(faclr*dzdx[il]+facbt*dzdy[il])<sp/>*<sp/>ilevdx;</highlight></codeline>
<codeline lineno="1060"><highlight class="normal"></highlight></codeline>
<codeline lineno="1061"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight></codeline>
<codeline lineno="1062"><highlight class="normal"></highlight></codeline>
<codeline lineno="1063"><highlight class="normal"></highlight></codeline>
<codeline lineno="1064"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1065"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1066"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1067"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Left&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1068"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Left&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1069"><highlight class="normal"></highlight></codeline>
<codeline lineno="1070"><highlight class="normal"></highlight></codeline>
<codeline lineno="1086"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_LeftGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,T*dzdy)</highlight></codeline>
<codeline lineno="1087"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1088"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1089"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1090"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>ix<sp/>=<sp/>0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1091"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="1092"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="1093"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1094"><highlight class="normal"></highlight></codeline>
<codeline lineno="1095"><highlight class="normal"></highlight></codeline>
<codeline lineno="1096"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1097"><highlight class="normal"></highlight></codeline>
<codeline lineno="1098"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="1099"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>iy;</highlight></codeline>
<codeline lineno="1101"><highlight class="normal"></highlight></codeline>
<codeline lineno="1102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ilevdx<sp/>=<sp/>calcres(XParam.delta,<sp/>XBlock.level[ib])<sp/>*<sp/>T(0.5);</highlight></codeline>
<codeline lineno="1103"><highlight class="normal"></highlight></codeline>
<codeline lineno="1104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.RightBot[XBlock.LeftBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>:<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="1106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>T(1.0);</highlight></codeline>
<codeline lineno="1109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&lt;<sp/>(j<sp/>-<sp/>T(0.01))<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight></codeline>
<codeline lineno="1110"><highlight class="normal"></highlight></codeline>
<codeline lineno="1111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[il]<sp/>+<sp/>(faclr<sp/>*<sp/>dzdx[il]<sp/>+<sp/>facbt<sp/>*<sp/>dzdy[il])<sp/>*<sp/>ilevdx;</highlight></codeline>
<codeline lineno="1112"><highlight class="normal"></highlight></codeline>
<codeline lineno="1113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight></codeline>
<codeline lineno="1114"><highlight class="normal"></highlight></codeline>
<codeline lineno="1115"><highlight class="normal"></highlight></codeline>
<codeline lineno="1116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1117"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1118"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1119"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_LeftGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1120"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_LeftGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1121"><highlight class="normal"></highlight></codeline>
<codeline lineno="1122"><highlight class="normal"></highlight></codeline>
<codeline lineno="1138"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Right(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight></codeline>
<codeline lineno="1139"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1140"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="1141"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1142"><highlight class="normal"></highlight></codeline>
<codeline lineno="1143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>ilevdx<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib]<sp/>)<sp/>*<sp/>T(0.5);</highlight></codeline>
<codeline lineno="1144"><highlight class="normal"></highlight></codeline>
<codeline lineno="1145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="1146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.LeftBot[XBlock.RightBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(floor(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(floor(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="1148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>T(-1.0);</highlight></codeline>
<codeline lineno="1151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&lt;<sp/>(j<sp/>-<sp/>T(0.01))<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight></codeline>
<codeline lineno="1152"><highlight class="normal"></highlight></codeline>
<codeline lineno="1153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[il]<sp/>+<sp/>(faclr<sp/>*<sp/>dzdx[il]<sp/>+<sp/>facbt<sp/>*<sp/>dzdy[il])<sp/>*<sp/>ilevdx;</highlight></codeline>
<codeline lineno="1154"><highlight class="normal"></highlight></codeline>
<codeline lineno="1155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight></codeline>
<codeline lineno="1156"><highlight class="normal"></highlight></codeline>
<codeline lineno="1157"><highlight class="normal"></highlight></codeline>
<codeline lineno="1158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1159"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1160"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1161"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Right&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1162"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Right&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1163"><highlight class="normal"></highlight></codeline>
<codeline lineno="1179"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_RightGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight></codeline>
<codeline lineno="1180"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1181"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1182"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1183"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1184"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="1185"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="1186"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1187"><highlight class="normal"></highlight></codeline>
<codeline lineno="1188"><highlight class="normal"></highlight></codeline>
<codeline lineno="1189"><highlight class="normal"></highlight></codeline>
<codeline lineno="1190"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="1191"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1192"><highlight class="normal"></highlight></codeline>
<codeline lineno="1193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ilevdx<sp/>=<sp/>calcres(XParam.delta,<sp/>XBlock.level[ib])<sp/>*<sp/>T(0.5);</highlight></codeline>
<codeline lineno="1194"><highlight class="normal"></highlight></codeline>
<codeline lineno="1195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>iy;</highlight></codeline>
<codeline lineno="1196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.LeftBot[XBlock.RightBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>:<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="1197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1199"><highlight class="normal"></highlight></codeline>
<codeline lineno="1200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>T(-1.0);</highlight></codeline>
<codeline lineno="1201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&lt;<sp/>(j<sp/>-<sp/>T(0.01))<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight></codeline>
<codeline lineno="1202"><highlight class="normal"></highlight></codeline>
<codeline lineno="1203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[il]<sp/>+<sp/>(faclr<sp/>*<sp/>dzdx[il]<sp/>+<sp/>facbt<sp/>*<sp/>dzdy[il])<sp/>*<sp/>ilevdx;</highlight></codeline>
<codeline lineno="1204"><highlight class="normal"></highlight></codeline>
<codeline lineno="1205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight></codeline>
<codeline lineno="1206"><highlight class="normal"></highlight></codeline>
<codeline lineno="1207"><highlight class="normal"></highlight></codeline>
<codeline lineno="1208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1209"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1210"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1211"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_RightGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1212"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_RightGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1213"><highlight class="normal"></highlight></codeline>
<codeline lineno="1227"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Bot(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight></codeline>
<codeline lineno="1228"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1229"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="1230"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1231"><highlight class="normal"></highlight></codeline>
<codeline lineno="1232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>ilevdx<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib])<sp/>*<sp/>T(0.5);</highlight></codeline>
<codeline lineno="1233"><highlight class="normal"></highlight></codeline>
<codeline lineno="1234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>XParam.blkwidth;<sp/>i++)</highlight></codeline>
<codeline lineno="1235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii<sp/>=<sp/>XBlock.TopLeft[XBlock.BotLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(floor(i<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(floor(i<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="1237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jl<sp/>=<sp/>memloc(XParam,<sp/><sp/>ii,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="1238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>i,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="1239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>T(1.0);</highlight></codeline>
<codeline lineno="1241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>floor(i<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&lt;<sp/>(i<sp/>-<sp/>T(0.01))<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight></codeline>
<codeline lineno="1242"><highlight class="normal"></highlight></codeline>
<codeline lineno="1243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[jl]<sp/>+<sp/>(faclr<sp/>*<sp/>dzdx[jl]<sp/>+<sp/>facbt<sp/>*<sp/>dzdy[jl])<sp/>*<sp/>ilevdx;</highlight></codeline>
<codeline lineno="1244"><highlight class="normal"></highlight></codeline>
<codeline lineno="1245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight></codeline>
<codeline lineno="1246"><highlight class="normal"></highlight></codeline>
<codeline lineno="1247"><highlight class="normal"></highlight></codeline>
<codeline lineno="1248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1249"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1250"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1251"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Bot&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1252"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Bot&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1253"><highlight class="normal"></highlight></codeline>
<codeline lineno="1267"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_BotGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight></codeline>
<codeline lineno="1268"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1269"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1270"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1271"><highlight class="normal"></highlight></codeline>
<codeline lineno="1272"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="1273"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="1274"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1275"><highlight class="normal"></highlight></codeline>
<codeline lineno="1276"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="1277"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1278"><highlight class="normal"></highlight></codeline>
<codeline lineno="1279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ilevdx<sp/>=<sp/>calcres(XParam.delta,<sp/>XBlock.level[ib])<sp/>*<sp/>T(0.5);</highlight></codeline>
<codeline lineno="1280"><highlight class="normal"></highlight></codeline>
<codeline lineno="1281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>ix;</highlight></codeline>
<codeline lineno="1282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii<sp/>=<sp/>XBlock.TopLeft[XBlock.BotLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>floor(i<sp/>*<sp/>(T)0.5)<sp/>:<sp/>floor(i<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="1283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ii,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="1284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>i,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="1285"><highlight class="normal"></highlight></codeline>
<codeline lineno="1286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>T(1.0);</highlight></codeline>
<codeline lineno="1287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>floor(i<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&lt;<sp/>(i<sp/>-<sp/>T(0.01))<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight></codeline>
<codeline lineno="1288"><highlight class="normal"></highlight></codeline>
<codeline lineno="1289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[jl]<sp/>+<sp/>(faclr<sp/>*<sp/>dzdx[jl]<sp/>+<sp/>facbt<sp/>*<sp/>dzdy[jl])<sp/>*<sp/>ilevdx;</highlight></codeline>
<codeline lineno="1290"><highlight class="normal"></highlight></codeline>
<codeline lineno="1291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight></codeline>
<codeline lineno="1292"><highlight class="normal"></highlight></codeline>
<codeline lineno="1293"><highlight class="normal"></highlight></codeline>
<codeline lineno="1294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1295"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1296"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1297"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_BotGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1298"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_BotGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1299"><highlight class="normal"></highlight></codeline>
<codeline lineno="1313"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Top(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight></codeline>
<codeline lineno="1314"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1315"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="1316"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1317"><highlight class="normal"></highlight></codeline>
<codeline lineno="1318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ilevdx<sp/>=<sp/>calcres(XParam.delta,<sp/>XBlock.level[ib])<sp/>*<sp/>T(0.5);</highlight></codeline>
<codeline lineno="1319"><highlight class="normal"></highlight></codeline>
<codeline lineno="1320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>XParam.blkwidth;<sp/>i++)</highlight></codeline>
<codeline lineno="1321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii<sp/>=<sp/>XBlock.BotLeft[XBlock.TopLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(floor(i<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(floor(i<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="1323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jl<sp/>=<sp/>memloc(XParam,<sp/>ii<sp/>,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="1324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>i,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="1325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>T(-1.0);</highlight></codeline>
<codeline lineno="1327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>floor(i<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&lt;<sp/>(i<sp/>-<sp/>T(0.01))<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight></codeline>
<codeline lineno="1328"><highlight class="normal"></highlight></codeline>
<codeline lineno="1329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[jl]<sp/>+<sp/>(faclr<sp/>*<sp/>dzdx[jl]<sp/>+<sp/>facbt<sp/>*<sp/>dzdy[jl])<sp/>*<sp/>ilevdx;</highlight></codeline>
<codeline lineno="1330"><highlight class="normal"></highlight></codeline>
<codeline lineno="1331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight></codeline>
<codeline lineno="1332"><highlight class="normal"></highlight></codeline>
<codeline lineno="1333"><highlight class="normal"></highlight></codeline>
<codeline lineno="1334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1335"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1336"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1337"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Top&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1338"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Top&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1339"><highlight class="normal"></highlight></codeline>
<codeline lineno="1354"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_TopGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight></codeline>
<codeline lineno="1355"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1356"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1357"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1358"><highlight class="normal"></highlight></codeline>
<codeline lineno="1359"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="1360"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="1361"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1362"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="1363"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1364"><highlight class="normal"></highlight></codeline>
<codeline lineno="1365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ilevdx<sp/>=<sp/>calcres(XParam.delta,<sp/>XBlock.level[ib])<sp/>*<sp/>T(0.5);</highlight></codeline>
<codeline lineno="1366"><highlight class="normal"></highlight></codeline>
<codeline lineno="1367"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>ix;</highlight></codeline>
<codeline lineno="1368"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii<sp/>=<sp/>XBlock.BotLeft[XBlock.TopLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>floor(i<sp/>*<sp/>(T)0.5)<sp/>:<sp/>floor(i<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="1369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ii<sp/>,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="1370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>i,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="1371"><highlight class="normal"></highlight></codeline>
<codeline lineno="1372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>T(-1.0);</highlight></codeline>
<codeline lineno="1373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>floor(i<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&lt;<sp/>(i<sp/>-<sp/>T(0.01))<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight></codeline>
<codeline lineno="1374"><highlight class="normal"></highlight></codeline>
<codeline lineno="1375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[jl]<sp/>+<sp/>(faclr<sp/>*<sp/>dzdx[jl]<sp/>+<sp/>facbt<sp/>*<sp/>dzdy[jl])<sp/>*<sp/>ilevdx;</highlight></codeline>
<codeline lineno="1376"><highlight class="normal"></highlight></codeline>
<codeline lineno="1377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight></codeline>
<codeline lineno="1378"><highlight class="normal"></highlight></codeline>
<codeline lineno="1379"><highlight class="normal"></highlight></codeline>
<codeline lineno="1380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1381"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1382"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1383"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_TopGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1384"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_TopGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1385"><highlight class="normal"></highlight></codeline>
<codeline lineno="1395"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight></codeline>
<codeline lineno="1396"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1397"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="1398"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refine_linear_Left(XParam,<sp/>ib,<sp/>XBlock,<sp/>z,<sp/>dzdx,<sp/>dzdy);</highlight></codeline>
<codeline lineno="1401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refine_linear_Right(XParam,<sp/>ib,<sp/>XBlock,<sp/>z,<sp/>dzdx,<sp/>dzdy);</highlight></codeline>
<codeline lineno="1402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refine_linear_Top(XParam,<sp/>ib,<sp/>XBlock,<sp/>z,<sp/>dzdx,<sp/>dzdy);</highlight></codeline>
<codeline lineno="1403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refine_linear_Bot(XParam,<sp/>ib,<sp/>XBlock,<sp/>z,<sp/>dzdx,<sp/>dzdy);</highlight></codeline>
<codeline lineno="1404"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1405"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1406"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1407"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1408"><highlight class="normal"></highlight></codeline>
<codeline lineno="1418"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linearGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight></codeline>
<codeline lineno="1419"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1420"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloLR(1,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="1421"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloBT(XParam.blkwidth,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="1422"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="1423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1424"><highlight class="normal"><sp/><sp/><sp/><sp/>refine_linear_LeftGPU&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0&gt;&gt;&gt;(XParam,<sp/>XBlock,<sp/>z,<sp/>dzdx,<sp/>dzdy);</highlight></codeline>
<codeline lineno="1425"><highlight class="normal"><sp/><sp/><sp/><sp/>refine_linear_RightGPU<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z,<sp/>dzdx,<sp/>dzdy);</highlight></codeline>
<codeline lineno="1426"><highlight class="normal"><sp/><sp/><sp/><sp/>refine_linear_TopGPU<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z,<sp/>dzdx,<sp/>dzdy);</highlight></codeline>
<codeline lineno="1427"><highlight class="normal"><sp/><sp/><sp/><sp/>refine_linear_BotGPU<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z,<sp/>dzdx,<sp/>dzdy);</highlight></codeline>
<codeline lineno="1428"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="1429"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1430"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1431"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linearGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1432"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linearGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1433"><highlight class="normal"></highlight></codeline>
<codeline lineno="1441"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>HaloFluxCPULR(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T<sp/>*z)</highlight></codeline>
<codeline lineno="1442"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1443"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>i,il,itl;</highlight></codeline>
<codeline lineno="1444"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1445"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="1447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1450"><highlight class="normal"></highlight></codeline>
<codeline lineno="1451"><highlight class="normal"></highlight></codeline>
<codeline lineno="1452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j*2;</highlight></codeline>
<codeline lineno="1453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>jj+1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1455"><highlight class="normal"></highlight></codeline>
<codeline lineno="1456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1458"><highlight class="normal"></highlight></codeline>
<codeline lineno="1459"><highlight class="normal"></highlight></codeline>
<codeline lineno="1460"><highlight class="normal"></highlight></codeline>
<codeline lineno="1461"><highlight class="normal"></highlight></codeline>
<codeline lineno="1462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1464"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1465"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1466"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="1468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1471"><highlight class="normal"></highlight></codeline>
<codeline lineno="1472"><highlight class="normal"></highlight></codeline>
<codeline lineno="1473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1476"><highlight class="normal"></highlight></codeline>
<codeline lineno="1477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1478"><highlight class="normal"></highlight></codeline>
<codeline lineno="1479"><highlight class="normal"></highlight></codeline>
<codeline lineno="1480"><highlight class="normal"></highlight></codeline>
<codeline lineno="1481"><highlight class="normal"></highlight></codeline>
<codeline lineno="1482"><highlight class="normal"></highlight></codeline>
<codeline lineno="1483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1485"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1486"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1487"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="1489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1492"><highlight class="normal"></highlight></codeline>
<codeline lineno="1493"><highlight class="normal"></highlight></codeline>
<codeline lineno="1494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1496"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1497"><highlight class="normal"></highlight></codeline>
<codeline lineno="1498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1499"><highlight class="normal"></highlight></codeline>
<codeline lineno="1500"><highlight class="normal"></highlight></codeline>
<codeline lineno="1501"><highlight class="normal"></highlight></codeline>
<codeline lineno="1502"><highlight class="normal"></highlight></codeline>
<codeline lineno="1503"><highlight class="normal"></highlight></codeline>
<codeline lineno="1504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1506"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1507"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightTop[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1508"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="1510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1513"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1519"><highlight class="normal"></highlight></codeline>
<codeline lineno="1520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1521"><highlight class="normal"></highlight></codeline>
<codeline lineno="1522"><highlight class="normal"></highlight></codeline>
<codeline lineno="1523"><highlight class="normal"></highlight></codeline>
<codeline lineno="1524"><highlight class="normal"></highlight></codeline>
<codeline lineno="1525"><highlight class="normal"></highlight></codeline>
<codeline lineno="1526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1528"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1529"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1530"><highlight class="normal"></highlight></codeline>
<codeline lineno="1539"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>HaloFluxGPULR(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="1540"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1541"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>i,<sp/>il,<sp/>itl;</highlight></codeline>
<codeline lineno="1542"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1543"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1544"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>ix<sp/>=<sp/>0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1545"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="1546"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="1547"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1548"><highlight class="normal"></highlight></codeline>
<codeline lineno="1549"><highlight class="normal"></highlight></codeline>
<codeline lineno="1550"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>iy;</highlight></codeline>
<codeline lineno="1551"><highlight class="normal"></highlight></codeline>
<codeline lineno="1552"><highlight class="normal"></highlight></codeline>
<codeline lineno="1553"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1554"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1555"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1556"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1557"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1558"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1560"><highlight class="normal"></highlight></codeline>
<codeline lineno="1561"><highlight class="normal"></highlight></codeline>
<codeline lineno="1562"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1563"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1564"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1565"><highlight class="normal"></highlight></codeline>
<codeline lineno="1566"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1567"><highlight class="normal"></highlight></codeline>
<codeline lineno="1568"><highlight class="normal"></highlight></codeline>
<codeline lineno="1569"><highlight class="normal"></highlight></codeline>
<codeline lineno="1570"><highlight class="normal"></highlight></codeline>
<codeline lineno="1571"><highlight class="normal"></highlight></codeline>
<codeline lineno="1572"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1573"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1574"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1575"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1576"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1578"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1579"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1580"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1581"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1582"><highlight class="normal"></highlight></codeline>
<codeline lineno="1583"><highlight class="normal"></highlight></codeline>
<codeline lineno="1584"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1586"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1587"><highlight class="normal"></highlight></codeline>
<codeline lineno="1588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1589"><highlight class="normal"></highlight></codeline>
<codeline lineno="1590"><highlight class="normal"></highlight></codeline>
<codeline lineno="1591"><highlight class="normal"></highlight></codeline>
<codeline lineno="1592"><highlight class="normal"></highlight></codeline>
<codeline lineno="1593"><highlight class="normal"></highlight></codeline>
<codeline lineno="1594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1596"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1597"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1598"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1600"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1601"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1602"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1603"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1604"><highlight class="normal"></highlight></codeline>
<codeline lineno="1605"><highlight class="normal"></highlight></codeline>
<codeline lineno="1606"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1608"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1609"><highlight class="normal"></highlight></codeline>
<codeline lineno="1610"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1611"><highlight class="normal"></highlight></codeline>
<codeline lineno="1612"><highlight class="normal"></highlight></codeline>
<codeline lineno="1613"><highlight class="normal"></highlight></codeline>
<codeline lineno="1614"><highlight class="normal"></highlight></codeline>
<codeline lineno="1615"><highlight class="normal"></highlight></codeline>
<codeline lineno="1616"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1617"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1618"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1619"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightTop[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1620"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1623"><highlight class="normal"></highlight></codeline>
<codeline lineno="1624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1625"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1626"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1627"><highlight class="normal"></highlight></codeline>
<codeline lineno="1628"><highlight class="normal"></highlight></codeline>
<codeline lineno="1629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1631"><highlight class="normal"></highlight></codeline>
<codeline lineno="1632"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1633"><highlight class="normal"></highlight></codeline>
<codeline lineno="1634"><highlight class="normal"></highlight></codeline>
<codeline lineno="1635"><highlight class="normal"></highlight></codeline>
<codeline lineno="1636"><highlight class="normal"></highlight></codeline>
<codeline lineno="1637"><highlight class="normal"></highlight></codeline>
<codeline lineno="1638"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1639"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1640"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1641"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1642"><highlight class="normal"></highlight></codeline>
<codeline lineno="1651"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>HaloFluxGPULRnew(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="1652"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1653"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>i,<sp/>il,<sp/>itl;</highlight></codeline>
<codeline lineno="1654"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1655"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1656"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>ix<sp/>=<sp/>0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1657"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="1658"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;</highlight></codeline>
<codeline lineno="1659"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ibl<sp/>&lt;<sp/>XParam.nblk)</highlight></codeline>
<codeline lineno="1660"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1661"><highlight class="normal"></highlight></codeline>
<codeline lineno="1662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1663"><highlight class="normal"></highlight></codeline>
<codeline lineno="1664"><highlight class="normal"></highlight></codeline>
<codeline lineno="1665"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>iy;</highlight></codeline>
<codeline lineno="1666"><highlight class="normal"></highlight></codeline>
<codeline lineno="1667"><highlight class="normal"></highlight></codeline>
<codeline lineno="1668"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1670"><highlight class="normal"></highlight></codeline>
<codeline lineno="1671"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1672"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1674"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1675"><highlight class="normal"></highlight></codeline>
<codeline lineno="1676"><highlight class="normal"></highlight></codeline>
<codeline lineno="1677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1678"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1679"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1680"><highlight class="normal"></highlight></codeline>
<codeline lineno="1681"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1682"><highlight class="normal"></highlight></codeline>
<codeline lineno="1683"><highlight class="normal"></highlight></codeline>
<codeline lineno="1684"><highlight class="normal"></highlight></codeline>
<codeline lineno="1685"><highlight class="normal"></highlight></codeline>
<codeline lineno="1686"><highlight class="normal"></highlight></codeline>
<codeline lineno="1687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1690"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1692"><highlight class="normal"></highlight></codeline>
<codeline lineno="1693"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1696"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1697"><highlight class="normal"></highlight></codeline>
<codeline lineno="1698"><highlight class="normal"></highlight></codeline>
<codeline lineno="1699"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1700"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1701"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1702"><highlight class="normal"></highlight></codeline>
<codeline lineno="1703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1704"><highlight class="normal"></highlight></codeline>
<codeline lineno="1705"><highlight class="normal"></highlight></codeline>
<codeline lineno="1706"><highlight class="normal"></highlight></codeline>
<codeline lineno="1707"><highlight class="normal"></highlight></codeline>
<codeline lineno="1708"><highlight class="normal"></highlight></codeline>
<codeline lineno="1709"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1710"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1711"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1714"><highlight class="normal"></highlight></codeline>
<codeline lineno="1715"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1716"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1719"><highlight class="normal"></highlight></codeline>
<codeline lineno="1720"><highlight class="normal"></highlight></codeline>
<codeline lineno="1721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1724"><highlight class="normal"></highlight></codeline>
<codeline lineno="1725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1726"><highlight class="normal"></highlight></codeline>
<codeline lineno="1727"><highlight class="normal"></highlight></codeline>
<codeline lineno="1728"><highlight class="normal"></highlight></codeline>
<codeline lineno="1729"><highlight class="normal"></highlight></codeline>
<codeline lineno="1730"><highlight class="normal"></highlight></codeline>
<codeline lineno="1731"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightTop[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1738"><highlight class="normal"></highlight></codeline>
<codeline lineno="1739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1742"><highlight class="normal"></highlight></codeline>
<codeline lineno="1743"><highlight class="normal"></highlight></codeline>
<codeline lineno="1744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1746"><highlight class="normal"></highlight></codeline>
<codeline lineno="1747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1748"><highlight class="normal"></highlight></codeline>
<codeline lineno="1749"><highlight class="normal"></highlight></codeline>
<codeline lineno="1750"><highlight class="normal"></highlight></codeline>
<codeline lineno="1751"><highlight class="normal"></highlight></codeline>
<codeline lineno="1752"><highlight class="normal"></highlight></codeline>
<codeline lineno="1753"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1756"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1757"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1758"><highlight class="normal"></highlight></codeline>
<codeline lineno="1766"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>HaloFluxCPUBT(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="1767"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1768"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>i,<sp/>il,<sp/>itl;</highlight></codeline>
<codeline lineno="1769"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1770"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1771"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="1772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1773"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="1775"><highlight class="normal"></highlight></codeline>
<codeline lineno="1776"><highlight class="normal"></highlight></codeline>
<codeline lineno="1777"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>XParam.blkwidth,<sp/><sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="1779"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam,<sp/>jj+1,<sp/>XParam.blkwidth,<sp/><sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="1780"><highlight class="normal"></highlight></codeline>
<codeline lineno="1781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1782"><highlight class="normal"></highlight></codeline>
<codeline lineno="1783"><highlight class="normal"></highlight></codeline>
<codeline lineno="1784"><highlight class="normal"></highlight></codeline>
<codeline lineno="1785"><highlight class="normal"></highlight></codeline>
<codeline lineno="1786"><highlight class="normal"></highlight></codeline>
<codeline lineno="1787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1788"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1789"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1790"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotRight[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1791"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1792"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="1793"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1794"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="1796"><highlight class="normal"></highlight></codeline>
<codeline lineno="1797"><highlight class="normal"></highlight></codeline>
<codeline lineno="1798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam,<sp/><sp/>jj,<sp/>XParam.blkwidth,<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="1800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam,<sp/><sp/>jj<sp/>+<sp/>1,<sp/>XParam.blkwidth,<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="1801"><highlight class="normal"></highlight></codeline>
<codeline lineno="1802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1803"><highlight class="normal"></highlight></codeline>
<codeline lineno="1804"><highlight class="normal"></highlight></codeline>
<codeline lineno="1805"><highlight class="normal"></highlight></codeline>
<codeline lineno="1806"><highlight class="normal"></highlight></codeline>
<codeline lineno="1807"><highlight class="normal"></highlight></codeline>
<codeline lineno="1808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1809"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1810"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1811"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1812"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="1814"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1815"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1816"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="1817"><highlight class="normal"></highlight></codeline>
<codeline lineno="1818"><highlight class="normal"></highlight></codeline>
<codeline lineno="1819"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1820"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>0,<sp/><sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="1821"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="1822"><highlight class="normal"></highlight></codeline>
<codeline lineno="1823"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1824"><highlight class="normal"></highlight></codeline>
<codeline lineno="1825"><highlight class="normal"></highlight></codeline>
<codeline lineno="1826"><highlight class="normal"></highlight></codeline>
<codeline lineno="1827"><highlight class="normal"></highlight></codeline>
<codeline lineno="1828"><highlight class="normal"></highlight></codeline>
<codeline lineno="1829"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1831"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1832"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopRight[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1833"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="1835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1836"><highlight class="normal"></highlight></codeline>
<codeline lineno="1837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1838"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="1840"><highlight class="normal"></highlight></codeline>
<codeline lineno="1841"><highlight class="normal"></highlight></codeline>
<codeline lineno="1842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="1843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="1844"><highlight class="normal"></highlight></codeline>
<codeline lineno="1845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1846"><highlight class="normal"></highlight></codeline>
<codeline lineno="1847"><highlight class="normal"></highlight></codeline>
<codeline lineno="1848"><highlight class="normal"></highlight></codeline>
<codeline lineno="1849"><highlight class="normal"></highlight></codeline>
<codeline lineno="1850"><highlight class="normal"></highlight></codeline>
<codeline lineno="1851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1853"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1854"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1855"><highlight class="normal"></highlight></codeline>
<codeline lineno="1863"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>HaloFluxGPUBT(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="1864"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1865"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>i,<sp/>il,<sp/>itl;</highlight></codeline>
<codeline lineno="1866"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1867"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1868"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="1869"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>iy<sp/>=<sp/>threadIdx.x;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1870"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="1871"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1872"><highlight class="normal"></highlight></codeline>
<codeline lineno="1873"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>ix;</highlight></codeline>
<codeline lineno="1874"><highlight class="normal"></highlight></codeline>
<codeline lineno="1875"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1876"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1877"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>j,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="1881"><highlight class="normal"></highlight></codeline>
<codeline lineno="1882"><highlight class="normal"></highlight></codeline>
<codeline lineno="1883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1884"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>XParam.blkwidth,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="1885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XParam.blkwidth,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="1886"><highlight class="normal"></highlight></codeline>
<codeline lineno="1887"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1888"><highlight class="normal"></highlight></codeline>
<codeline lineno="1889"><highlight class="normal"></highlight></codeline>
<codeline lineno="1890"><highlight class="normal"></highlight></codeline>
<codeline lineno="1891"><highlight class="normal"></highlight></codeline>
<codeline lineno="1892"><highlight class="normal"></highlight></codeline>
<codeline lineno="1893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1894"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1895"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1896"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotRight[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1897"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1898"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1899"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1900"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1901"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>j,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="1902"><highlight class="normal"></highlight></codeline>
<codeline lineno="1903"><highlight class="normal"></highlight></codeline>
<codeline lineno="1904"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1905"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>XParam.blkwidth,<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="1906"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XParam.blkwidth,<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="1907"><highlight class="normal"></highlight></codeline>
<codeline lineno="1908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1909"><highlight class="normal"></highlight></codeline>
<codeline lineno="1910"><highlight class="normal"></highlight></codeline>
<codeline lineno="1911"><highlight class="normal"></highlight></codeline>
<codeline lineno="1912"><highlight class="normal"></highlight></codeline>
<codeline lineno="1913"><highlight class="normal"></highlight></codeline>
<codeline lineno="1914"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1915"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1916"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1917"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1918"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1919"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1920"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1921"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1922"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="1923"><highlight class="normal"></highlight></codeline>
<codeline lineno="1924"><highlight class="normal"></highlight></codeline>
<codeline lineno="1925"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1926"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="1927"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="1928"><highlight class="normal"></highlight></codeline>
<codeline lineno="1929"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1930"><highlight class="normal"></highlight></codeline>
<codeline lineno="1931"><highlight class="normal"></highlight></codeline>
<codeline lineno="1932"><highlight class="normal"></highlight></codeline>
<codeline lineno="1933"><highlight class="normal"></highlight></codeline>
<codeline lineno="1934"><highlight class="normal"></highlight></codeline>
<codeline lineno="1935"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1937"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1938"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopRight[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1939"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1942"><highlight class="normal"></highlight></codeline>
<codeline lineno="1943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1944"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="1946"><highlight class="normal"></highlight></codeline>
<codeline lineno="1947"><highlight class="normal"></highlight></codeline>
<codeline lineno="1948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="1949"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="1950"><highlight class="normal"></highlight></codeline>
<codeline lineno="1951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1952"><highlight class="normal"></highlight></codeline>
<codeline lineno="1953"><highlight class="normal"></highlight></codeline>
<codeline lineno="1954"><highlight class="normal"></highlight></codeline>
<codeline lineno="1955"><highlight class="normal"></highlight></codeline>
<codeline lineno="1956"><highlight class="normal"></highlight></codeline>
<codeline lineno="1957"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1958"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1959"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1960"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1961"><highlight class="normal"></highlight></codeline>
<codeline lineno="1969"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>HaloFluxGPUBTnew(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="1970"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1971"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>i,<sp/>il,<sp/>itl;</highlight></codeline>
<codeline lineno="1972"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1973"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1974"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="1975"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>iy<sp/>=<sp/>threadIdx.x;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1976"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>threadIdx.y<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.y;</highlight></codeline>
<codeline lineno="1977"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ibl<sp/>&lt;<sp/>XParam.nblk)</highlight></codeline>
<codeline lineno="1978"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1979"><highlight class="normal"></highlight></codeline>
<codeline lineno="1980"><highlight class="normal"></highlight></codeline>
<codeline lineno="1981"><highlight class="normal"></highlight></codeline>
<codeline lineno="1982"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1983"><highlight class="normal"></highlight></codeline>
<codeline lineno="1984"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>ix;</highlight></codeline>
<codeline lineno="1985"><highlight class="normal"></highlight></codeline>
<codeline lineno="1986"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1987"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1988"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1989"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1990"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>j,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="1992"><highlight class="normal"></highlight></codeline>
<codeline lineno="1993"><highlight class="normal"></highlight></codeline>
<codeline lineno="1994"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>XParam.blkwidth,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="1996"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XParam.blkwidth,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="1997"><highlight class="normal"></highlight></codeline>
<codeline lineno="1998"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1999"><highlight class="normal"></highlight></codeline>
<codeline lineno="2000"><highlight class="normal"></highlight></codeline>
<codeline lineno="2001"><highlight class="normal"></highlight></codeline>
<codeline lineno="2002"><highlight class="normal"></highlight></codeline>
<codeline lineno="2003"><highlight class="normal"></highlight></codeline>
<codeline lineno="2004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotRight[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2010"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2011"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2012"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>j,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="2013"><highlight class="normal"></highlight></codeline>
<codeline lineno="2014"><highlight class="normal"></highlight></codeline>
<codeline lineno="2015"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2016"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>XParam.blkwidth,<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="2017"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XParam.blkwidth,<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="2018"><highlight class="normal"></highlight></codeline>
<codeline lineno="2019"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="2020"><highlight class="normal"></highlight></codeline>
<codeline lineno="2021"><highlight class="normal"></highlight></codeline>
<codeline lineno="2022"><highlight class="normal"></highlight></codeline>
<codeline lineno="2023"><highlight class="normal"></highlight></codeline>
<codeline lineno="2024"><highlight class="normal"></highlight></codeline>
<codeline lineno="2025"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2026"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2027"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2028"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2030"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2033"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="2034"><highlight class="normal"></highlight></codeline>
<codeline lineno="2035"><highlight class="normal"></highlight></codeline>
<codeline lineno="2036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="2038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="2039"><highlight class="normal"></highlight></codeline>
<codeline lineno="2040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="2041"><highlight class="normal"></highlight></codeline>
<codeline lineno="2042"><highlight class="normal"></highlight></codeline>
<codeline lineno="2043"><highlight class="normal"></highlight></codeline>
<codeline lineno="2044"><highlight class="normal"></highlight></codeline>
<codeline lineno="2045"><highlight class="normal"></highlight></codeline>
<codeline lineno="2046"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2048"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopRight[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2050"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2051"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2053"><highlight class="normal"></highlight></codeline>
<codeline lineno="2054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="2057"><highlight class="normal"></highlight></codeline>
<codeline lineno="2058"><highlight class="normal"></highlight></codeline>
<codeline lineno="2059"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2060"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2061"><highlight class="normal"></highlight></codeline>
<codeline lineno="2062"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="2063"><highlight class="normal"></highlight></codeline>
<codeline lineno="2064"><highlight class="normal"></highlight></codeline>
<codeline lineno="2065"><highlight class="normal"></highlight></codeline>
<codeline lineno="2066"><highlight class="normal"></highlight></codeline>
<codeline lineno="2067"><highlight class="normal"></highlight></codeline>
<codeline lineno="2068"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2069"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2070"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2071"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2072"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2073"><highlight class="normal"></highlight></codeline>
<codeline lineno="2074"><highlight class="normal"></highlight></codeline>
<codeline lineno="2083"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillLeft(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>&amp;z)</highlight></codeline>
<codeline lineno="2084"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2085"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,bb;</highlight></codeline>
<codeline lineno="2086"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>write;</highlight></codeline>
<codeline lineno="2087"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="2088"><highlight class="normal"></highlight></codeline>
<codeline lineno="2089"><highlight class="normal"></highlight></codeline>
<codeline lineno="2090"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2091"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2092"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="2093"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2094"><highlight class="normal"></highlight></codeline>
<codeline lineno="2095"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2096"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2097"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2098"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2099"><highlight class="normal"></highlight></codeline>
<codeline lineno="2100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2105"><highlight class="normal"></highlight></codeline>
<codeline lineno="2106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2113"><highlight class="normal"></highlight></codeline>
<codeline lineno="2114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="2119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="2120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="2121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="2122"><highlight class="normal"></highlight></codeline>
<codeline lineno="2123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="2124"><highlight class="normal"></highlight></codeline>
<codeline lineno="2125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2127"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2128"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[<sp/>XBlock.LeftBot[ib]<sp/>])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2129"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="2131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2133"><highlight class="normal"></highlight></codeline>
<codeline lineno="2134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>j,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="2136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2138"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2139"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]<sp/>]&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="2140"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2141"><highlight class="normal"></highlight></codeline>
<codeline lineno="2142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth<sp/>/<sp/>2;<sp/>j++)</highlight></codeline>
<codeline lineno="2143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2144"><highlight class="normal"></highlight></codeline>
<codeline lineno="2145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2146"><highlight class="normal"></highlight></codeline>
<codeline lineno="2147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.LeftBot[ib];</highlight></codeline>
<codeline lineno="2149"><highlight class="normal"></highlight></codeline>
<codeline lineno="2150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2154"><highlight class="normal"></highlight></codeline>
<codeline lineno="2155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="2156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2163"><highlight class="normal"></highlight></codeline>
<codeline lineno="2164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>(XParam.blkwidth<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.LeftTop[ib];</highlight></codeline>
<codeline lineno="2176"><highlight class="normal"></highlight></codeline>
<codeline lineno="2177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>z[read];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2184"><highlight class="normal"></highlight></codeline>
<codeline lineno="2185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="2186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2188"><highlight class="normal"></highlight></codeline>
<codeline lineno="2189"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2190"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2191"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="2193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2195"><highlight class="normal"></highlight></codeline>
<codeline lineno="2196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="2197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2198"><highlight class="normal"></highlight></codeline>
<codeline lineno="2199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.RightBot[XBlock.LeftBot[ib]]<sp/>==<sp/>ib?<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5)):<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5)+<sp/>XParam.blkwidth/2);</highlight></codeline>
<codeline lineno="2200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>3.0);</highlight></codeline>
<codeline lineno="2201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>j<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="2202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>j<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="2203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir=<sp/>memloc(XParam,<sp/>XParam.blkwidth-1,<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="2206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth-1,<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="2207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//2<sp/>scenarios<sp/>here<sp/>ib<sp/>is<sp/>the<sp/>rightbot<sp/>neighbour<sp/>of<sp/>the<sp/>leftbot<sp/>block<sp/>or<sp/>ib<sp/>is<sp/>the<sp/>righttop<sp/>neighbour</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightBot[XBlock.LeftBot[ib]]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="2211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[XBlock.LeftBot[ib]]<sp/>==<sp/>XBlock.LeftBot[ib])<sp/></highlight><highlight class="comment">//<sp/>no<sp/>botom<sp/>of<sp/>leftbot<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(0.5)<sp/>*<sp/>(T(1.0)<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="2215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="2217"><highlight class="normal"></highlight></codeline>
<codeline lineno="2218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotRight[XBlock.LeftBot[ib]]]<sp/>&lt;<sp/>XBlock.level[XBlock.LeftBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>but<sp/>is<sp/>coarser</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth-1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotRight[XBlock.LeftBot[ib]]);</highlight></codeline>
<codeline lineno="2225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotRight[XBlock.LeftBot[ib]]]<sp/>==<sp/>XBlock.level[XBlock.LeftBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>same<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotRight[XBlock.LeftBot[ib]]);</highlight></codeline>
<codeline lineno="2229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotRight[XBlock.LeftBot[ib]]]<sp/>&gt;<sp/>XBlock.level[XBlock.LeftBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>higher<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="2233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="2234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="2235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotRight[XBlock.LeftBot[ib]]);</highlight></codeline>
<codeline lineno="2236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="comment">//righttopleftif<sp/>==<sp/>ib</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>(XParam.blkwidth<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="2246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[XBlock.LeftTop[ib]]<sp/>==<sp/>XBlock.LeftTop[ib])<sp/></highlight><highlight class="comment">//<sp/>no<sp/>botom<sp/>of<sp/>leftbot<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(0.5*(1.0-w1));</highlight></codeline>
<codeline lineno="2250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="2252"><highlight class="normal"></highlight></codeline>
<codeline lineno="2253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopRight[XBlock.LeftTop[ib]]]<sp/>&lt;<sp/>XBlock.level[XBlock.LeftTop[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>but<sp/>is<sp/>coarser</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,0,<sp/>XBlock.TopRight[XBlock.LeftTop[ib]]);</highlight></codeline>
<codeline lineno="2260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopRight[XBlock.LeftTop[ib]]]<sp/>==<sp/>XBlock.level[XBlock.LeftTop[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>same<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>0,<sp/>XBlock.TopRight[XBlock.LeftTop[ib]]);</highlight></codeline>
<codeline lineno="2264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopRight[XBlock.LeftTop[ib]]]<sp/>&gt;<sp/>XBlock.level[XBlock.LeftTop[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>higher<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="2268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="2269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="2270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>0,<sp/>XBlock.TopRight[XBlock.LeftTop[ib]]);</highlight></codeline>
<codeline lineno="2271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2275"><highlight class="normal"></highlight></codeline>
<codeline lineno="2276"><highlight class="normal"></highlight></codeline>
<codeline lineno="2277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>w1<sp/>*<sp/>z[ii]<sp/>+<sp/>w2<sp/>*<sp/>z[ir]<sp/>+<sp/>w3<sp/>*<sp/>z[it];</highlight></codeline>
<codeline lineno="2278"><highlight class="normal"></highlight></codeline>
<codeline lineno="2279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2280"><highlight class="normal"></highlight></codeline>
<codeline lineno="2281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2282"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2283"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2284"><highlight class="normal"></highlight></codeline>
<codeline lineno="2285"><highlight class="normal"></highlight></codeline>
<codeline lineno="2286"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2287"><highlight class="normal"></highlight></codeline>
<codeline lineno="2288"><highlight class="normal"></highlight></codeline>
<codeline lineno="2302"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillLeft(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>topright,<sp/>T<sp/>*<sp/>a)</highlight></codeline>
<codeline lineno="2303"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2304"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2305"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2306"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>ix<sp/>=<sp/>0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2307"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="2308"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="2309"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="2310"><highlight class="normal"></highlight></codeline>
<codeline lineno="2311"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="2312"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LB<sp/>=<sp/>leftbot[ib];</highlight></codeline>
<codeline lineno="2313"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LT<sp/>=<sp/>lefttop[ib];</highlight></codeline>
<codeline lineno="2314"><highlight class="normal"></highlight></codeline>
<codeline lineno="2315"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RBLB<sp/>=<sp/>rightbot[LB];</highlight></codeline>
<codeline lineno="2316"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BRLB<sp/>=<sp/>botright[LB];</highlight></codeline>
<codeline lineno="2317"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TRLT<sp/>=<sp/>topright[LT];</highlight></codeline>
<codeline lineno="2318"><highlight class="normal"></highlight></codeline>
<codeline lineno="2319"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levBRLB<sp/>=<sp/>level[BRLB];</highlight></codeline>
<codeline lineno="2320"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTRLT<sp/>=<sp/>level[TRLT];</highlight></codeline>
<codeline lineno="2321"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levLB<sp/>=<sp/>level[LB];</highlight></codeline>
<codeline lineno="2322"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levLT<sp/>=<sp/>level[LT];</highlight></codeline>
<codeline lineno="2323"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>-1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2324"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="2325"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="2326"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="2327"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="2328"><highlight class="normal"></highlight></codeline>
<codeline lineno="2329"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2330"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2342"><highlight class="normal"></highlight></codeline>
<codeline lineno="2343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2347"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj,<sp/>LT);</highlight></codeline>
<codeline lineno="2349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj,<sp/>LT);</highlight></codeline>
<codeline lineno="2350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="2351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="2352"><highlight class="normal"></highlight></codeline>
<codeline lineno="2353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2357"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2358"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLB<sp/>==<sp/>lev<sp/>)</highlight></codeline>
<codeline lineno="2359"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>iy,<sp/>LB);</highlight></codeline>
<codeline lineno="2361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2362"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2363"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLB<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="2364"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2368"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj,<sp/>LB);</highlight></codeline>
<codeline lineno="2369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj,<sp/>LB);</highlight></codeline>
<codeline lineno="2370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>LB);</highlight></codeline>
<codeline lineno="2371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>LB);</highlight></codeline>
<codeline lineno="2372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj,<sp/>LT);</highlight></codeline>
<codeline lineno="2386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj,<sp/>LT);</highlight></codeline>
<codeline lineno="2387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="2388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="2389"><highlight class="normal"></highlight></codeline>
<codeline lineno="2390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2393"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2394"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLB<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="2395"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>RBLB==ib?<sp/>ceil(iy<sp/>*<sp/>(T)0.5):<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.y<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="2397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>(T)1.0<sp/>/<sp/>(T)3.0;</highlight></codeline>
<codeline lineno="2398"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="2399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="2400"><highlight class="normal"></highlight></codeline>
<codeline lineno="2401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>jj,<sp/>LB);</highlight></codeline>
<codeline lineno="2403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>jj<sp/>-<sp/>1,<sp/>LB);</highlight></codeline>
<codeline lineno="2404"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RBLB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2405"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="2407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2408"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BRLB<sp/>==<sp/>LB)</highlight></codeline>
<codeline lineno="2409"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2410"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>(T)0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="2411"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="2413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2414"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBRLB<sp/>&lt;<sp/>levLB)</highlight></codeline>
<codeline lineno="2415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2416"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BRLB);</highlight></codeline>
<codeline lineno="2420"><highlight class="normal"></highlight></codeline>
<codeline lineno="2421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2422"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBRLB<sp/>==<sp/>levLB)</highlight></codeline>
<codeline lineno="2423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BRLB);</highlight></codeline>
<codeline lineno="2425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBRLB<sp/>&gt;<sp/>levLB)</highlight></codeline>
<codeline lineno="2427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2428"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="2429"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="2430"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="2431"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BRLB);</highlight></codeline>
<codeline lineno="2432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2434"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2435"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2436"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2437"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>==<sp/>(blockDim.y<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="2438"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2439"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TRLT<sp/>==<sp/>LT)</highlight></codeline>
<codeline lineno="2440"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2441"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="2442"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2443"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="2444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2445"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTRLT<sp/>&lt;<sp/>levLT)</highlight></codeline>
<codeline lineno="2446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>0,<sp/>TRLT);</highlight></codeline>
<codeline lineno="2451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTRLT<sp/>==<sp/>levLT)</highlight></codeline>
<codeline lineno="2453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>0,<sp/>TRLT);</highlight></codeline>
<codeline lineno="2455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTRLT<sp/>&gt;<sp/>levLT)</highlight></codeline>
<codeline lineno="2457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="2460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>0,<sp/>TRLT);</highlight></codeline>
<codeline lineno="2462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>w1<sp/>*<sp/>a[ii]<sp/>+<sp/>w2<sp/>*<sp/>a[ir]<sp/>+<sp/>w3<sp/>*<sp/>a[it];</highlight></codeline>
<codeline lineno="2467"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2468"><highlight class="normal"></highlight></codeline>
<codeline lineno="2469"><highlight class="normal"><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="2470"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2471"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillLeft&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="2472"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillLeft&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="2473"><highlight class="normal"></highlight></codeline>
<codeline lineno="2492"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillLeftnew(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="2493"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2494"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2495"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2496"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>ix<sp/>=<sp/>0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2497"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="2498"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//need<sp/>to<sp/>take<sp/>min<sp/>of<sp/>ibl<sp/>or<sp/>total<sp/>number<sp/>of<sp/>blks<sp/>in<sp/>case<sp/>nblk<sp/>is<sp/>not<sp/>dividable<sp/>by<sp/>2</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2499"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;;</highlight></codeline>
<codeline lineno="2500"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ibl<sp/>&lt;<sp/>nblk)</highlight></codeline>
<codeline lineno="2501"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2502"><highlight class="normal"></highlight></codeline>
<codeline lineno="2503"><highlight class="normal"></highlight></codeline>
<codeline lineno="2504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="2505"><highlight class="normal"></highlight></codeline>
<codeline lineno="2506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="2507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LB<sp/>=<sp/>leftbot[ib];</highlight></codeline>
<codeline lineno="2508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LT<sp/>=<sp/>lefttop[ib];</highlight></codeline>
<codeline lineno="2509"><highlight class="normal"></highlight></codeline>
<codeline lineno="2510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RBLB<sp/>=<sp/>rightbot[LB];</highlight></codeline>
<codeline lineno="2511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BRLB<sp/>=<sp/>botright[LB];</highlight></codeline>
<codeline lineno="2512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TRLT<sp/>=<sp/>topright[LT];</highlight></codeline>
<codeline lineno="2513"><highlight class="normal"></highlight></codeline>
<codeline lineno="2514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levBRLB<sp/>=<sp/>level[BRLB];</highlight></codeline>
<codeline lineno="2515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTRLT<sp/>=<sp/>level[TRLT];</highlight></codeline>
<codeline lineno="2516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levLB<sp/>=<sp/>level[LB];</highlight></codeline>
<codeline lineno="2517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levLT<sp/>=<sp/>level[LT];</highlight></codeline>
<codeline lineno="2518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>-1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="2520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="2521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="2522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="2523"><highlight class="normal"></highlight></codeline>
<codeline lineno="2524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2530"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2537"><highlight class="normal"></highlight></codeline>
<codeline lineno="2538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2541"><highlight class="normal"></highlight></codeline>
<codeline lineno="2542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj,<sp/>LT);</highlight></codeline>
<codeline lineno="2544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj,<sp/>LT);</highlight></codeline>
<codeline lineno="2545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="2546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="2547"><highlight class="normal"></highlight></codeline>
<codeline lineno="2548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2549"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2551"><highlight class="normal"></highlight></codeline>
<codeline lineno="2552"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLB<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="2554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2555"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>iy,<sp/>LB);</highlight></codeline>
<codeline lineno="2556"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2557"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2558"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLB<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="2559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2560"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2561"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2562"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2563"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj,<sp/>LB);</highlight></codeline>
<codeline lineno="2564"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj,<sp/>LB);</highlight></codeline>
<codeline lineno="2565"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>LB);</highlight></codeline>
<codeline lineno="2566"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>LB);</highlight></codeline>
<codeline lineno="2567"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2568"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2569"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2570"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2571"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2572"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2573"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2574"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2575"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2576"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2578"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2579"><highlight class="normal"></highlight></codeline>
<codeline lineno="2580"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj,<sp/>LT);</highlight></codeline>
<codeline lineno="2581"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj,<sp/>LT);</highlight></codeline>
<codeline lineno="2582"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="2583"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="2584"><highlight class="normal"></highlight></codeline>
<codeline lineno="2585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2586"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2589"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLB<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="2590"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2591"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>RBLB<sp/>==<sp/>ib<sp/>?<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.y<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="2592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>(T)1.0<sp/>/<sp/>(T)3.0;</highlight></codeline>
<codeline lineno="2593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="2594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="2595"><highlight class="normal"></highlight></codeline>
<codeline lineno="2596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>jj,<sp/>LB);</highlight></codeline>
<codeline lineno="2598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>jj<sp/>-<sp/>1,<sp/>LB);</highlight></codeline>
<codeline lineno="2599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RBLB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2600"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2601"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="2602"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2603"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BRLB<sp/>==<sp/>LB)</highlight></codeline>
<codeline lineno="2604"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2605"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>(T)0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="2606"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="2608"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2609"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBRLB<sp/>&lt;<sp/>levLB)</highlight></codeline>
<codeline lineno="2610"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2611"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2612"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2613"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2614"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BRLB);</highlight></codeline>
<codeline lineno="2615"><highlight class="normal"></highlight></codeline>
<codeline lineno="2616"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2617"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBRLB<sp/>==<sp/>levLB)</highlight></codeline>
<codeline lineno="2618"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2619"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BRLB);</highlight></codeline>
<codeline lineno="2620"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBRLB<sp/>&gt;<sp/>levLB)</highlight></codeline>
<codeline lineno="2622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2623"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="2624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="2625"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="2626"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BRLB);</highlight></codeline>
<codeline lineno="2627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2632"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>==<sp/>(blockDim.y<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="2633"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2634"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TRLT<sp/>==<sp/>LT)</highlight></codeline>
<codeline lineno="2635"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2636"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="2637"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2638"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="2639"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTRLT<sp/>&lt;<sp/>levLT)</highlight></codeline>
<codeline lineno="2641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>0,<sp/>TRLT);</highlight></codeline>
<codeline lineno="2646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTRLT<sp/>==<sp/>levLT)</highlight></codeline>
<codeline lineno="2648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>0,<sp/>TRLT);</highlight></codeline>
<codeline lineno="2650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTRLT<sp/>&gt;<sp/>levLT)</highlight></codeline>
<codeline lineno="2652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="2655"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>0,<sp/>TRLT);</highlight></codeline>
<codeline lineno="2657"><highlight class="normal"></highlight></codeline>
<codeline lineno="2658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>w1<sp/>*<sp/>a[ii]<sp/>+<sp/>w2<sp/>*<sp/>a[ir]<sp/>+<sp/>w3<sp/>*<sp/>a[it];</highlight></codeline>
<codeline lineno="2662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2663"><highlight class="normal"></highlight></codeline>
<codeline lineno="2664"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="2665"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2666"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2667"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillLeftnew&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="2668"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillLeftnew&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="2669"><highlight class="normal"></highlight></codeline>
<codeline lineno="2678"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillLeftFlux(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="2679"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2680"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>bb;</highlight></codeline>
<codeline lineno="2681"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>write;</highlight></codeline>
<codeline lineno="2682"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/><sp/>it;</highlight></codeline>
<codeline lineno="2683"><highlight class="normal"></highlight></codeline>
<codeline lineno="2684"><highlight class="normal"></highlight></codeline>
<codeline lineno="2685"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2686"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="2688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2689"><highlight class="normal"></highlight></codeline>
<codeline lineno="2690"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2693"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2694"><highlight class="normal"></highlight></codeline>
<codeline lineno="2695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2696"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2697"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2699"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2700"><highlight class="normal"></highlight></codeline>
<codeline lineno="2701"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2705"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2706"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2707"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2708"><highlight class="normal"></highlight></codeline>
<codeline lineno="2709"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2710"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2711"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="2714"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2715"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="2716"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2717"><highlight class="normal"></highlight></codeline>
<codeline lineno="2718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/><sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="2719"><highlight class="normal"></highlight></codeline>
<codeline lineno="2720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2722"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2723"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.LeftBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2724"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="2726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2728"><highlight class="normal"></highlight></codeline>
<codeline lineno="2729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2730"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>j,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="2731"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2733"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2734"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="2735"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2736"><highlight class="normal"></highlight></codeline>
<codeline lineno="2737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth<sp/>/<sp/>2;<sp/>j++)</highlight></codeline>
<codeline lineno="2738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2739"><highlight class="normal"></highlight></codeline>
<codeline lineno="2740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2741"><highlight class="normal"></highlight></codeline>
<codeline lineno="2742"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.LeftBot[ib];</highlight></codeline>
<codeline lineno="2744"><highlight class="normal"></highlight></codeline>
<codeline lineno="2745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2748"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2749"><highlight class="normal"></highlight></codeline>
<codeline lineno="2750"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="2751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2753"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2756"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2757"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2758"><highlight class="normal"></highlight></codeline>
<codeline lineno="2759"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2762"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2763"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2764"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2765"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2766"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2767"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2768"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2769"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>8)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2770"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.LeftTop[ib];</highlight></codeline>
<codeline lineno="2771"><highlight class="normal"></highlight></codeline>
<codeline lineno="2772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2773"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>z[read];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2775"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2777"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2779"><highlight class="normal"></highlight></codeline>
<codeline lineno="2780"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="2781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2783"><highlight class="normal"></highlight></codeline>
<codeline lineno="2784"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2785"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2786"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="2788"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2790"><highlight class="normal"></highlight></codeline>
<codeline lineno="2791"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//T<sp/>w1,<sp/>w2,<sp/>w3;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2792"><highlight class="normal"></highlight></codeline>
<codeline lineno="2793"><highlight class="normal"></highlight></codeline>
<codeline lineno="2794"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.RightBot[XBlock.LeftBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="2795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2796"><highlight class="normal"></highlight></codeline>
<codeline lineno="2797"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="2798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(doProlongation)</highlight></codeline>
<codeline lineno="2799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[ii];</highlight></codeline>
<codeline lineno="2800"><highlight class="normal"></highlight></codeline>
<codeline lineno="2801"><highlight class="normal"></highlight></codeline>
<codeline lineno="2802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2803"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2804"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2805"><highlight class="normal"></highlight></codeline>
<codeline lineno="2806"><highlight class="normal"></highlight></codeline>
<codeline lineno="2807"><highlight class="normal"></highlight></codeline>
<codeline lineno="2808"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2809"><highlight class="normal"></highlight></codeline>
<codeline lineno="2810"><highlight class="normal"></highlight></codeline>
<codeline lineno="2818"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRight(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="2819"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2820"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>bb;</highlight></codeline>
<codeline lineno="2821"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>write;</highlight></codeline>
<codeline lineno="2822"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="2823"><highlight class="normal"></highlight></codeline>
<codeline lineno="2824"><highlight class="normal"></highlight></codeline>
<codeline lineno="2825"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2826"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="2828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2829"><highlight class="normal"></highlight></codeline>
<codeline lineno="2830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth-1,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2833"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2834"><highlight class="normal"></highlight></codeline>
<codeline lineno="2835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2838"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2840"><highlight class="normal"></highlight></codeline>
<codeline lineno="2841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2844"><highlight class="normal"></highlight></codeline>
<codeline lineno="2845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2850"><highlight class="normal"></highlight></codeline>
<codeline lineno="2851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2853"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2854"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>(XParam.blkwidth<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="2856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="2857"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="2858"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="2859"><highlight class="normal"></highlight></codeline>
<codeline lineno="2860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="2861"><highlight class="normal"></highlight></codeline>
<codeline lineno="2862"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2864"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2865"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.RightBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2866"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="2868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2870"><highlight class="normal"></highlight></codeline>
<codeline lineno="2871"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2872"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="2873"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2875"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2876"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="2877"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2878"><highlight class="normal"></highlight></codeline>
<codeline lineno="2879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth<sp/>/<sp/>2;<sp/>j++)</highlight></codeline>
<codeline lineno="2880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2881"><highlight class="normal"></highlight></codeline>
<codeline lineno="2882"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2883"><highlight class="normal"></highlight></codeline>
<codeline lineno="2884"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.RightBot[ib];</highlight></codeline>
<codeline lineno="2886"><highlight class="normal"></highlight></codeline>
<codeline lineno="2887"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2888"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2889"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2890"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2891"><highlight class="normal"></highlight></codeline>
<codeline lineno="2892"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="2893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2894"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2897"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2898"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2899"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2900"><highlight class="normal"></highlight></codeline>
<codeline lineno="2901"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth-1,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2902"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2903"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2904"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2905"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2906"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2907"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2910"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2911"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>(XParam.blkwidth<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2912"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.RightTop[ib];</highlight></codeline>
<codeline lineno="2913"><highlight class="normal"></highlight></codeline>
<codeline lineno="2914"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2915"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2916"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>z[read];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2917"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2918"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2919"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2920"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2921"><highlight class="normal"></highlight></codeline>
<codeline lineno="2922"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="2923"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2924"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2925"><highlight class="normal"></highlight></codeline>
<codeline lineno="2926"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2927"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2928"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2929"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="2930"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2931"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2932"><highlight class="normal"></highlight></codeline>
<codeline lineno="2933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="2934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2935"><highlight class="normal"></highlight></codeline>
<codeline lineno="2936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.LeftBot[XBlock.RightBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="2937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>3.0);</highlight></codeline>
<codeline lineno="2938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>j<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="2939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>j<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="2940"><highlight class="normal"></highlight></codeline>
<codeline lineno="2941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="2943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="2944"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//2<sp/>scenarios<sp/>here<sp/>ib<sp/>is<sp/>the<sp/>leftbot<sp/>neighbour<sp/>of<sp/>the<sp/>rightbot<sp/>block<sp/>or<sp/>ib<sp/>is<sp/>the<sp/>lefttop<sp/>neighbour</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftBot[XBlock.RightBot[ib]]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2946"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2947"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="2948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2949"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotLeft[XBlock.RightBot[ib]]<sp/>==<sp/>XBlock.RightBot[ib])<sp/></highlight><highlight class="comment">//<sp/>no<sp/>botom<sp/>of<sp/>leftbot<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1));</highlight></codeline>
<codeline lineno="2952"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2953"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="2954"><highlight class="normal"></highlight></codeline>
<codeline lineno="2955"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2956"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[XBlock.RightBot[ib]]]<sp/>&lt;<sp/>XBlock.level[XBlock.RightBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>but<sp/>is<sp/>coarser</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2957"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2958"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2959"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2960"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2961"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotLeft[XBlock.RightBot[ib]]);</highlight></codeline>
<codeline lineno="2962"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2963"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[XBlock.RightBot[ib]]]<sp/>==<sp/>XBlock.level[XBlock.RightBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>same<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2965"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotLeft[XBlock.RightBot[ib]]);</highlight></codeline>
<codeline lineno="2966"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2967"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[XBlock.RightBot[ib]]]<sp/>&gt;<sp/>XBlock.level[XBlock.RightBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>higher<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2968"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2969"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="2970"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="2971"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="2972"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotLeft[XBlock.RightBot[ib]]);</highlight></codeline>
<codeline lineno="2973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2974"><highlight class="normal"></highlight></codeline>
<codeline lineno="2975"><highlight class="normal"></highlight></codeline>
<codeline lineno="2976"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2977"><highlight class="normal"></highlight></codeline>
<codeline lineno="2978"><highlight class="normal"></highlight></codeline>
<codeline lineno="2979"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2980"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2981"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2982"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>(XParam.blkwidth<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="2983"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2984"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopLeft[XBlock.RightTop[ib]]<sp/>==<sp/>XBlock.RightTop[ib])<sp/></highlight><highlight class="comment">//<sp/>no<sp/>botom<sp/>of<sp/>leftbot<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2985"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2986"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1));</highlight></codeline>
<codeline lineno="2987"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2988"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="2989"><highlight class="normal"></highlight></codeline>
<codeline lineno="2990"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[XBlock.RightTop[ib]]]<sp/>&lt;<sp/>XBlock.level[XBlock.RightTop[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>but<sp/>is<sp/>coarser</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2992"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2993"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2994"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2996"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>0,<sp/>XBlock.TopLeft[XBlock.RightTop[ib]]);</highlight></codeline>
<codeline lineno="2997"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2998"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[XBlock.RightTop[ib]]]<sp/>==<sp/>XBlock.level[XBlock.RightTop[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>same<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2999"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3000"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>0,<sp/>XBlock.TopLeft[XBlock.RightTop[ib]]);</highlight></codeline>
<codeline lineno="3001"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3002"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[XBlock.RightTop[ib]]]<sp/>&gt;<sp/>XBlock.level[XBlock.RightTop[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>higher<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="3006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>0,<sp/>XBlock.TopLeft[XBlock.RightTop[ib]]);</highlight></codeline>
<codeline lineno="3008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3010"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3011"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3012"><highlight class="normal"></highlight></codeline>
<codeline lineno="3013"><highlight class="normal"></highlight></codeline>
<codeline lineno="3014"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>w1<sp/>*<sp/>z[ii]<sp/>+<sp/>w2<sp/>*<sp/>z[ir]<sp/>+<sp/>w3<sp/>*<sp/>z[it];</highlight></codeline>
<codeline lineno="3015"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3016"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3017"><highlight class="normal"></highlight></codeline>
<codeline lineno="3018"><highlight class="normal"></highlight></codeline>
<codeline lineno="3019"><highlight class="normal"></highlight></codeline>
<codeline lineno="3020"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3021"><highlight class="normal"></highlight></codeline>
<codeline lineno="3022"><highlight class="normal"></highlight></codeline>
<codeline lineno="3037"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRight(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>rightbot,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>leftbot,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*botleft,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="3038"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3039"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3040"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3041"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>ix<sp/>=<sp/>blockDim.y<sp/>-<sp/>1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3042"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="3043"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="3044"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="3045"><highlight class="normal"></highlight></codeline>
<codeline lineno="3046"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RB<sp/>=<sp/>rightbot[ib];</highlight></codeline>
<codeline lineno="3047"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RT<sp/>=<sp/>righttop[ib];</highlight></codeline>
<codeline lineno="3048"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>LB<sp/>=<sp/>leftbot[ib];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3049"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>BL<sp/>=<sp/>botleft[ib];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3050"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LBRB<sp/>=<sp/>leftbot[RB];</highlight></codeline>
<codeline lineno="3051"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TLRT<sp/>=<sp/>topleft[RT];</highlight></codeline>
<codeline lineno="3052"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BLRB<sp/>=<sp/>botleft[RB];</highlight></codeline>
<codeline lineno="3053"><highlight class="normal"></highlight></codeline>
<codeline lineno="3054"><highlight class="normal"></highlight></codeline>
<codeline lineno="3055"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="3056"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRB<sp/>=<sp/>level[RB];</highlight></codeline>
<codeline lineno="3057"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRT<sp/>=<sp/>level[RT];</highlight></codeline>
<codeline lineno="3058"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levBLRB<sp/>=<sp/>level[BLRB];</highlight></codeline>
<codeline lineno="3059"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTLRT<sp/>=<sp/>level[TLRT];</highlight></codeline>
<codeline lineno="3060"><highlight class="normal"></highlight></codeline>
<codeline lineno="3061"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3062"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="3063"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="3064"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="3065"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="3066"><highlight class="normal"></highlight></codeline>
<codeline lineno="3067"><highlight class="normal"></highlight></codeline>
<codeline lineno="3068"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3069"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3070"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3071"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3072"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3073"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3074"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3075"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3076"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3077"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3078"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3079"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3080"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3081"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3082"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3083"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3084"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3085"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="3086"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="3087"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="3088"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="3089"><highlight class="normal"></highlight></codeline>
<codeline lineno="3090"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3091"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3092"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3093"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3094"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="3095"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3096"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>RB);</highlight></codeline>
<codeline lineno="3097"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3098"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3099"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="3100"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3104"><highlight class="normal"></highlight></codeline>
<codeline lineno="3105"><highlight class="normal"></highlight></codeline>
<codeline lineno="3106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RB);</highlight></codeline>
<codeline lineno="3107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RB);</highlight></codeline>
<codeline lineno="3108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RB);</highlight></codeline>
<codeline lineno="3109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RB);</highlight></codeline>
<codeline lineno="3110"><highlight class="normal"></highlight></codeline>
<codeline lineno="3111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="3125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="3126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="3127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="3128"><highlight class="normal"></highlight></codeline>
<codeline lineno="3129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3132"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3133"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="3134"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>LBRB<sp/>==<sp/>ib<sp/>?<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.y<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="3137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>3.0;</highlight></codeline>
<codeline lineno="3138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="3139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="3140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RB);</highlight></codeline>
<codeline lineno="3142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>-<sp/>1,<sp/>RB);</highlight></codeline>
<codeline lineno="3143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LBRB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="3146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BLRB<sp/>==<sp/>RB)</highlight></codeline>
<codeline lineno="3148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="3150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="3151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="3152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBLRB<sp/>&lt;<sp/>levRB)</highlight></codeline>
<codeline lineno="3154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BLRB);</highlight></codeline>
<codeline lineno="3159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBLRB<sp/>==<sp/>levRB)</highlight></codeline>
<codeline lineno="3161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BLRB);</highlight></codeline>
<codeline lineno="3163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBLRB<sp/>&gt;<sp/>levRB)</highlight></codeline>
<codeline lineno="3165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="3168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BLRB);</highlight></codeline>
<codeline lineno="3170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>==<sp/>(blockDim.y<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="3176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TLRT<sp/>==<sp/>RT)</highlight></codeline>
<codeline lineno="3178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="3180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="3181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="3182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTLRT<sp/>&lt;<sp/>levRT)</highlight></codeline>
<codeline lineno="3184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>TLRT);</highlight></codeline>
<codeline lineno="3189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTLRT<sp/>==<sp/>levRT)</highlight></codeline>
<codeline lineno="3191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>TLRT);</highlight></codeline>
<codeline lineno="3193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTLRT<sp/>&gt;<sp/>levRT)</highlight></codeline>
<codeline lineno="3195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="3198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>TLRT);</highlight></codeline>
<codeline lineno="3200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3203"><highlight class="normal"></highlight></codeline>
<codeline lineno="3204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read=<sp/>w1<sp/>*<sp/>a[ii]<sp/>+<sp/>w2<sp/>*<sp/>a[ir]<sp/>+<sp/>w3<sp/>*<sp/>a[it];</highlight></codeline>
<codeline lineno="3205"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3206"><highlight class="normal"><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="3207"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3208"><highlight class="normal"></highlight></codeline>
<codeline lineno="3209"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRight&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="3210"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRight&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="3211"><highlight class="normal"></highlight></codeline>
<codeline lineno="3227"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightnew(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="3228"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3229"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3230"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3231"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>ix<sp/>=<sp/>blockDim.y<sp/>-<sp/>1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3232"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="3233"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;</highlight></codeline>
<codeline lineno="3234"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ibl<sp/>&lt;<sp/>nblk)</highlight></codeline>
<codeline lineno="3235"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="3237"><highlight class="normal"></highlight></codeline>
<codeline lineno="3238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RB<sp/>=<sp/>rightbot[ib];</highlight></codeline>
<codeline lineno="3239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RT<sp/>=<sp/>righttop[ib];</highlight></codeline>
<codeline lineno="3240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>LB<sp/>=<sp/>leftbot[ib];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>BL<sp/>=<sp/>botleft[ib];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LBRB<sp/>=<sp/>leftbot[RB];</highlight></codeline>
<codeline lineno="3243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TLRT<sp/>=<sp/>topleft[RT];</highlight></codeline>
<codeline lineno="3244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BLRB<sp/>=<sp/>botleft[RB];</highlight></codeline>
<codeline lineno="3245"><highlight class="normal"></highlight></codeline>
<codeline lineno="3246"><highlight class="normal"></highlight></codeline>
<codeline lineno="3247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="3248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRB<sp/>=<sp/>level[RB];</highlight></codeline>
<codeline lineno="3249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRT<sp/>=<sp/>level[RT];</highlight></codeline>
<codeline lineno="3250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levBLRB<sp/>=<sp/>level[BLRB];</highlight></codeline>
<codeline lineno="3251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTLRT<sp/>=<sp/>level[TLRT];</highlight></codeline>
<codeline lineno="3252"><highlight class="normal"></highlight></codeline>
<codeline lineno="3253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="3255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="3256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="3257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="3258"><highlight class="normal"></highlight></codeline>
<codeline lineno="3259"><highlight class="normal"></highlight></codeline>
<codeline lineno="3260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="3278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="3279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="3280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="3281"><highlight class="normal"></highlight></codeline>
<codeline lineno="3282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="3287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>RB);</highlight></codeline>
<codeline lineno="3289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="3292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3296"><highlight class="normal"></highlight></codeline>
<codeline lineno="3297"><highlight class="normal"></highlight></codeline>
<codeline lineno="3298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RB);</highlight></codeline>
<codeline lineno="3299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RB);</highlight></codeline>
<codeline lineno="3300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RB);</highlight></codeline>
<codeline lineno="3301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RB);</highlight></codeline>
<codeline lineno="3302"><highlight class="normal"></highlight></codeline>
<codeline lineno="3303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3315"><highlight class="normal"></highlight></codeline>
<codeline lineno="3316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="3317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="3318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="3319"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="3320"><highlight class="normal"></highlight></codeline>
<codeline lineno="3321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="3326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>LBRB<sp/>==<sp/>ib<sp/>?<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.y<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="3329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>3.0;</highlight></codeline>
<codeline lineno="3330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="3331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="3332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RB);</highlight></codeline>
<codeline lineno="3334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>-<sp/>1,<sp/>RB);</highlight></codeline>
<codeline lineno="3335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LBRB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="3338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BLRB<sp/>==<sp/>RB)</highlight></codeline>
<codeline lineno="3340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="3342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="3343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="3344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBLRB<sp/>&lt;<sp/>levRB)</highlight></codeline>
<codeline lineno="3346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3347"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BLRB);</highlight></codeline>
<codeline lineno="3351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBLRB<sp/>==<sp/>levRB)</highlight></codeline>
<codeline lineno="3353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BLRB);</highlight></codeline>
<codeline lineno="3355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBLRB<sp/>&gt;<sp/>levRB)</highlight></codeline>
<codeline lineno="3357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="3360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BLRB);</highlight></codeline>
<codeline lineno="3362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>==<sp/>(blockDim.y<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="3368"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TLRT<sp/>==<sp/>RT)</highlight></codeline>
<codeline lineno="3370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="3372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="3373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="3374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTLRT<sp/>&lt;<sp/>levRT)</highlight></codeline>
<codeline lineno="3376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>TLRT);</highlight></codeline>
<codeline lineno="3381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTLRT<sp/>==<sp/>levRT)</highlight></codeline>
<codeline lineno="3383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>TLRT);</highlight></codeline>
<codeline lineno="3385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTLRT<sp/>&gt;<sp/>levRT)</highlight></codeline>
<codeline lineno="3387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="3390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>TLRT);</highlight></codeline>
<codeline lineno="3392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3394"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3395"><highlight class="normal"></highlight></codeline>
<codeline lineno="3396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>w1<sp/>*<sp/>a[ii]<sp/>+<sp/>w2<sp/>*<sp/>a[ir]<sp/>+<sp/>w3<sp/>*<sp/>a[it];</highlight></codeline>
<codeline lineno="3397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3398"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="3399"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3400"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3401"><highlight class="normal"></highlight></codeline>
<codeline lineno="3402"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightnew&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="3403"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightnew&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="3404"><highlight class="normal"></highlight></codeline>
<codeline lineno="3405"><highlight class="normal"></highlight></codeline>
<codeline lineno="3415"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightFlux(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="3416"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3417"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>bb;</highlight></codeline>
<codeline lineno="3418"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>write;</highlight></codeline>
<codeline lineno="3419"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/>it;</highlight></codeline>
<codeline lineno="3420"><highlight class="normal"></highlight></codeline>
<codeline lineno="3421"><highlight class="normal"></highlight></codeline>
<codeline lineno="3422"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3423"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="3425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3426"><highlight class="normal"></highlight></codeline>
<codeline lineno="3427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3428"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3429"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3430"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3431"><highlight class="normal"></highlight></codeline>
<codeline lineno="3432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3434"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3435"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3436"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3437"><highlight class="normal"></highlight></codeline>
<codeline lineno="3438"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3439"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3440"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3441"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3442"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3443"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3445"><highlight class="normal"></highlight></codeline>
<codeline lineno="3446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="3449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>8)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3454"><highlight class="normal"></highlight></codeline>
<codeline lineno="3455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="3456"><highlight class="normal"></highlight></codeline>
<codeline lineno="3457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3459"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3460"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.RightBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3461"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="3463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3465"><highlight class="normal"></highlight></codeline>
<codeline lineno="3466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="3467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="3468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3470"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3471"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="3472"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3473"><highlight class="normal"></highlight></codeline>
<codeline lineno="3474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth<sp/>/<sp/>2;<sp/>j++)</highlight></codeline>
<codeline lineno="3475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3476"><highlight class="normal"></highlight></codeline>
<codeline lineno="3477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="3478"><highlight class="normal"></highlight></codeline>
<codeline lineno="3479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.RightBot[ib];</highlight></codeline>
<codeline lineno="3481"><highlight class="normal"></highlight></codeline>
<codeline lineno="3482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="3483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="3485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3486"><highlight class="normal"></highlight></codeline>
<codeline lineno="3487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="3489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3496"><highlight class="normal"></highlight></codeline>
<codeline lineno="3497"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>8)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.RightTop[ib];</highlight></codeline>
<codeline lineno="3509"><highlight class="normal"></highlight></codeline>
<codeline lineno="3510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>z[read];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3513"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="3514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="3516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="3518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3521"><highlight class="normal"></highlight></codeline>
<codeline lineno="3522"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3523"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3524"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="3526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="3528"><highlight class="normal"></highlight></codeline>
<codeline lineno="3529"><highlight class="normal"></highlight></codeline>
<codeline lineno="3530"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.LeftBot[XBlock.RightBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(floor(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(floor(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="3531"><highlight class="normal"></highlight></codeline>
<codeline lineno="3532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="3533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(doProlongation)</highlight></codeline>
<codeline lineno="3534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[ii];</highlight></codeline>
<codeline lineno="3535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3536"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3537"><highlight class="normal"></highlight></codeline>
<codeline lineno="3538"><highlight class="normal"></highlight></codeline>
<codeline lineno="3539"><highlight class="normal"></highlight></codeline>
<codeline lineno="3540"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3541"><highlight class="normal"></highlight></codeline>
<codeline lineno="3542"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightFlux&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*&amp;<sp/>z);</highlight></codeline>
<codeline lineno="3543"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightFlux&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*&amp;<sp/>z);</highlight></codeline>
<codeline lineno="3544"><highlight class="normal"></highlight></codeline>
<codeline lineno="3545"><highlight class="normal"></highlight></codeline>
<codeline lineno="3560"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightFlux(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="3561"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3562"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3563"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3564"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>ix<sp/>=<sp/>blockDim.y<sp/>-<sp/>1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3565"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="3566"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="3567"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="3568"><highlight class="normal"></highlight></codeline>
<codeline lineno="3569"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RB<sp/>=<sp/>rightbot[ib];</highlight></codeline>
<codeline lineno="3570"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RT<sp/>=<sp/>righttop[ib];</highlight></codeline>
<codeline lineno="3571"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>LB<sp/>=<sp/>leftbot[ib];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3572"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>BL<sp/>=<sp/>botleft[ib];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3573"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LBRB<sp/>=<sp/>leftbot[RB];</highlight></codeline>
<codeline lineno="3574"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>TLRT<sp/>=<sp/>topleft[RT];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3575"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>BLRB<sp/>=<sp/>botleft[RB];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3576"><highlight class="normal"></highlight></codeline>
<codeline lineno="3577"><highlight class="normal"></highlight></codeline>
<codeline lineno="3578"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="3579"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRB<sp/>=<sp/>level[RB];</highlight></codeline>
<codeline lineno="3580"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>levRT<sp/>=<sp/>level[RT];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3581"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>levBLRB<sp/>=<sp/>level[BLRB];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3582"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>levTLRT<sp/>=<sp/>level[TLRT];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3583"><highlight class="normal"></highlight></codeline>
<codeline lineno="3584"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3585"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="3586"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it;</highlight></codeline>
<codeline lineno="3587"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="3588"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//T<sp/>w1,<sp/>w2;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3589"><highlight class="normal"></highlight></codeline>
<codeline lineno="3590"><highlight class="normal"></highlight></codeline>
<codeline lineno="3591"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3592"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3600"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3601"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3602"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3603"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3604"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3605"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3606"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3608"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="3609"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RT);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3610"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="3611"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3612"><highlight class="normal"></highlight></codeline>
<codeline lineno="3613"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.5)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[it]);</highlight></codeline>
<codeline lineno="3614"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3615"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3616"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3617"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="3618"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3619"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>RB);</highlight></codeline>
<codeline lineno="3620"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3621"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3622"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="3623"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3625"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3626"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3627"><highlight class="normal"></highlight></codeline>
<codeline lineno="3628"><highlight class="normal"></highlight></codeline>
<codeline lineno="3629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RB);</highlight></codeline>
<codeline lineno="3630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RB);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RB);</highlight></codeline>
<codeline lineno="3632"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RB);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3633"><highlight class="normal"></highlight></codeline>
<codeline lineno="3634"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.5)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[it]);</highlight></codeline>
<codeline lineno="3635"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3636"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3637"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3638"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3639"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3646"><highlight class="normal"></highlight></codeline>
<codeline lineno="3647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="3648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RT);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="3650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3651"><highlight class="normal"></highlight></codeline>
<codeline lineno="3652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.5)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[it]<sp/>);</highlight></codeline>
<codeline lineno="3653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3655"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3656"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="3657"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>LBRB<sp/>==<sp/>ib<sp/>?<sp/>floor(iy<sp/>*<sp/>(T)0.5)<sp/>:<sp/>floor(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.y<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="3660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RB);</highlight></codeline>
<codeline lineno="3663"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3664"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(doProlongation)</highlight></codeline>
<codeline lineno="3665"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[ir];</highlight></codeline>
<codeline lineno="3666"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3668"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[write];</highlight></codeline>
<codeline lineno="3669"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3670"><highlight class="normal"><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="3671"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3672"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightFlux&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="3673"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightFlux&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="3674"><highlight class="normal"></highlight></codeline>
<codeline lineno="3675"><highlight class="normal"></highlight></codeline>
<codeline lineno="3685"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillBot(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="3686"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3687"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>bb;</highlight></codeline>
<codeline lineno="3688"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>write;</highlight></codeline>
<codeline lineno="3689"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="3690"><highlight class="normal"></highlight></codeline>
<codeline lineno="3691"><highlight class="normal"></highlight></codeline>
<codeline lineno="3692"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3693"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="3695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3696"><highlight class="normal"></highlight></codeline>
<codeline lineno="3697"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3699"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3700"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3701"><highlight class="normal"></highlight></codeline>
<codeline lineno="3702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3705"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3706"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3707"><highlight class="normal"></highlight></codeline>
<codeline lineno="3708"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3709"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3710"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3711"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3714"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3715"><highlight class="normal"></highlight></codeline>
<codeline lineno="3716"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,j,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="3719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>8)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,jj,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,jj,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,jj+1,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,jj+1,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3724"><highlight class="normal"></highlight></codeline>
<codeline lineno="3725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="3726"><highlight class="normal"></highlight></codeline>
<codeline lineno="3727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3729"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3730"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.BotLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3731"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="3733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3735"><highlight class="normal"></highlight></codeline>
<codeline lineno="3736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,j,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="3737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="3738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3740"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3741"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="3742"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3743"><highlight class="normal"></highlight></codeline>
<codeline lineno="3744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth<sp/>/<sp/>2;<sp/>j++)</highlight></codeline>
<codeline lineno="3745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3746"><highlight class="normal"></highlight></codeline>
<codeline lineno="3747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="3748"><highlight class="normal"></highlight></codeline>
<codeline lineno="3749"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3750"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.BotLeft[ib];</highlight></codeline>
<codeline lineno="3751"><highlight class="normal"></highlight></codeline>
<codeline lineno="3752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>bb);</highlight></codeline>
<codeline lineno="3753"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>bb);</highlight></codeline>
<codeline lineno="3754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>bb);</highlight></codeline>
<codeline lineno="3755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>bb);</highlight></codeline>
<codeline lineno="3756"><highlight class="normal"></highlight></codeline>
<codeline lineno="3757"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="3758"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3759"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>botright<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3762"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3763"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3764"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3765"><highlight class="normal"></highlight></codeline>
<codeline lineno="3766"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3767"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3768"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3769"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3770"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3771"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3773"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3775"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>8)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3777"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.BotRight[ib];</highlight></codeline>
<codeline lineno="3778"><highlight class="normal"></highlight></codeline>
<codeline lineno="3779"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3780"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>z[read];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>bb);</highlight></codeline>
<codeline lineno="3783"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>bb);</highlight></codeline>
<codeline lineno="3784"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>bb);</highlight></codeline>
<codeline lineno="3785"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>bb);</highlight></codeline>
<codeline lineno="3786"><highlight class="normal"></highlight></codeline>
<codeline lineno="3787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="3788"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3790"><highlight class="normal"></highlight></codeline>
<codeline lineno="3791"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3792"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3793"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3794"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="3795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="3797"><highlight class="normal"></highlight></codeline>
<codeline lineno="3798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="3799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3800"><highlight class="normal"></highlight></codeline>
<codeline lineno="3801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.TopLeft[XBlock.BotLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="3802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>3.0);</highlight></codeline>
<codeline lineno="3803"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>j<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="3804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>j<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="3805"><highlight class="normal"></highlight></codeline>
<codeline lineno="3806"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3807"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="3808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>-1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="3809"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//2<sp/>scenarios<sp/>here<sp/>ib<sp/>is<sp/>the<sp/>rightbot<sp/>neighbour<sp/>of<sp/>the<sp/>leftbot<sp/>block<sp/>or<sp/>ib<sp/>is<sp/>the<sp/>righttop<sp/>neighbour</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3810"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopLeft[XBlock.BotLeft[ib]]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3811"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3812"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="3813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3814"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[XBlock.BotLeft[ib]]<sp/>==<sp/>XBlock.BotLeft[ib])<sp/></highlight><highlight class="comment">//<sp/>no<sp/>botom<sp/>of<sp/>leftbot<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3815"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3816"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1));</highlight></codeline>
<codeline lineno="3817"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="3818"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="3819"><highlight class="normal"></highlight></codeline>
<codeline lineno="3820"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3821"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]]<sp/>&lt;<sp/>XBlock.level[XBlock.BotLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>but<sp/>is<sp/>coarser</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3822"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3823"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="3824"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="3825"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="3826"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]]);</highlight></codeline>
<codeline lineno="3827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]]<sp/>==<sp/>XBlock.level[XBlock.BotLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>same<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3829"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]]);</highlight></codeline>
<codeline lineno="3831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]]<sp/>&gt;<sp/>XBlock.level[XBlock.BotLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>higher<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3833"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="3835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="3836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="3837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]]);</highlight></codeline>
<codeline lineno="3838"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3839"><highlight class="normal"></highlight></codeline>
<codeline lineno="3840"><highlight class="normal"></highlight></codeline>
<codeline lineno="3841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3842"><highlight class="normal"></highlight></codeline>
<codeline lineno="3843"><highlight class="normal"></highlight></codeline>
<codeline lineno="3844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="comment">//righttopleftif<sp/>==<sp/>ib</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>(XParam.blkwidth<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="3848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[XBlock.BotRight[ib]]<sp/>==<sp/>XBlock.BotRight[ib])<sp/></highlight><highlight class="comment">//<sp/>no<sp/>botom<sp/>of<sp/>leftbot<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1));</highlight></codeline>
<codeline lineno="3852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="3853"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="3854"><highlight class="normal"></highlight></codeline>
<codeline lineno="3855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightTop[XBlock.BotRight[ib]]]<sp/>&lt;<sp/>XBlock.level[XBlock.BotRight[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>but<sp/>is<sp/>coarser</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3857"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3858"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="3859"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="3860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="3861"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.RightTop[XBlock.BotRight[ib]]);</highlight></codeline>
<codeline lineno="3862"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightTop[XBlock.BotRight[ib]]]<sp/>==<sp/>XBlock.level[XBlock.BotRight[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>same<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3864"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3865"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,0,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.RightTop[XBlock.BotRight[ib]]);</highlight></codeline>
<codeline lineno="3866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightTop[XBlock.BotRight[ib]]]<sp/>&gt;<sp/>XBlock.level[XBlock.BotRight[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>higher<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="3870"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="3871"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="3872"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,0,XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.RightTop[XBlock.BotRight[ib]]);</highlight></codeline>
<codeline lineno="3873"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3877"><highlight class="normal"></highlight></codeline>
<codeline lineno="3878"><highlight class="normal"></highlight></codeline>
<codeline lineno="3879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>w1<sp/>*<sp/>z[ii]<sp/>+<sp/>w2<sp/>*<sp/>z[ir]<sp/>+<sp/>w3<sp/>*<sp/>z[it];</highlight></codeline>
<codeline lineno="3880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3881"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3882"><highlight class="normal"></highlight></codeline>
<codeline lineno="3883"><highlight class="normal"></highlight></codeline>
<codeline lineno="3884"><highlight class="normal"></highlight></codeline>
<codeline lineno="3885"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3886"><highlight class="normal"></highlight></codeline>
<codeline lineno="3901"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillBot(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="3902"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3903"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3904"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3905"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="3906"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>iy<sp/>=<sp/>0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3907"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="3908"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3909"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="3910"><highlight class="normal"></highlight></codeline>
<codeline lineno="3911"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BL<sp/>=<sp/>botleft[ib];</highlight></codeline>
<codeline lineno="3912"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BR<sp/>=<sp/>botright[ib];</highlight></codeline>
<codeline lineno="3913"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TLBL<sp/>=<sp/>topleft[BL];</highlight></codeline>
<codeline lineno="3914"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LTBL<sp/>=<sp/>lefttop[BL];</highlight></codeline>
<codeline lineno="3915"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RTBR<sp/>=<sp/>righttop[BR];</highlight></codeline>
<codeline lineno="3916"><highlight class="normal"></highlight></codeline>
<codeline lineno="3917"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="3918"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levBL<sp/>=<sp/>level[BL];</highlight></codeline>
<codeline lineno="3919"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levBR<sp/>=<sp/>level[BR];</highlight></codeline>
<codeline lineno="3920"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levLTBL<sp/>=<sp/>level[LTBL];</highlight></codeline>
<codeline lineno="3921"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRTBR<sp/>=<sp/>level[RTBR];</highlight></codeline>
<codeline lineno="3922"><highlight class="normal"></highlight></codeline>
<codeline lineno="3923"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="3924"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="3925"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="3926"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="3927"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="3928"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3929"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3930"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3931"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3932"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3935"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3944"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x/2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BR);</highlight></codeline>
<codeline lineno="3946"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BR);</highlight></codeline>
<codeline lineno="3947"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BR);</highlight></codeline>
<codeline lineno="3948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BR);</highlight></codeline>
<codeline lineno="3949"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3952"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3953"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBL<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="3954"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3955"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BL);</highlight></codeline>
<codeline lineno="3956"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3957"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3958"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBL<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="3959"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3960"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3961"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3962"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3963"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BL);</highlight></codeline>
<codeline lineno="3964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BL);</highlight></codeline>
<codeline lineno="3965"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BL);</highlight></codeline>
<codeline lineno="3966"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BL);</highlight></codeline>
<codeline lineno="3967"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3968"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3969"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3970"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3971"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3972"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3975"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3976"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3977"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3978"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x/2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3979"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BR);</highlight></codeline>
<codeline lineno="3980"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BR);</highlight></codeline>
<codeline lineno="3981"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BR);</highlight></codeline>
<codeline lineno="3982"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BR);</highlight></codeline>
<codeline lineno="3983"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3984"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3985"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3986"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3987"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBL<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="3988"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3989"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>TLBL<sp/>==<sp/>ib<sp/>?<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.x<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="3990"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>3.0;</highlight></codeline>
<codeline lineno="3991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="3992"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="3993"><highlight class="normal"></highlight></codeline>
<codeline lineno="3994"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>BL);</highlight></codeline>
<codeline lineno="3996"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>BL);</highlight></codeline>
<codeline lineno="3997"><highlight class="normal"></highlight></codeline>
<codeline lineno="3998"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TLBL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3999"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4000"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="4001"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4002"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LTBL<sp/>==<sp/>BL)</highlight></codeline>
<codeline lineno="4003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="4005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="4006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="4007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLTBL<sp/>&lt;<sp/>levBL)</highlight></codeline>
<codeline lineno="4009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4010"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4011"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4012"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4013"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>LTBL);</highlight></codeline>
<codeline lineno="4014"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4015"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLTBL<sp/>==<sp/>levBL)</highlight></codeline>
<codeline lineno="4016"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4017"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>LTBL);</highlight></codeline>
<codeline lineno="4018"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4019"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLTBL<sp/>&gt;<sp/>levBL)</highlight></codeline>
<codeline lineno="4020"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4021"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="4023"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4024"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>LTBL);</highlight></codeline>
<codeline lineno="4025"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4026"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4027"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4028"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4030"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>(blockDim.x<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="4031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RTBR<sp/>==<sp/>BR)</highlight></codeline>
<codeline lineno="4033"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4034"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="4035"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="4036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="4037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRTBR<sp/>&lt;<sp/>levBR)</highlight></codeline>
<codeline lineno="4039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4041"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4042"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4043"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,0,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>RTBR);</highlight></codeline>
<codeline lineno="4044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRTBR<sp/>==<sp/>levBR)</highlight></codeline>
<codeline lineno="4046"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,0,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>RTBR);</highlight></codeline>
<codeline lineno="4048"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRTBR<sp/>&gt;<sp/>levBR)</highlight></codeline>
<codeline lineno="4050"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4051"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="4053"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>RTBR);</highlight></codeline>
<codeline lineno="4055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4057"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4058"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>w1<sp/>*<sp/>a[ii]<sp/>+<sp/>w2<sp/>*<sp/>a[ir]<sp/>+<sp/>w3<sp/>*<sp/>a[it];</highlight></codeline>
<codeline lineno="4059"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4060"><highlight class="normal"><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="4061"><highlight class="normal"></highlight></codeline>
<codeline lineno="4062"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4063"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillBot&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="4064"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillBot&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="4065"><highlight class="normal"></highlight></codeline>
<codeline lineno="4080"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillBotnew(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="4081"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4082"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4083"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4084"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="4085"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>iy<sp/>=<sp/>0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4086"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>threadIdx.y<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.y;</highlight></codeline>
<codeline lineno="4087"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ibl<sp/>&lt;<sp/>nblk)</highlight></codeline>
<codeline lineno="4088"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4089"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="4090"><highlight class="normal"></highlight></codeline>
<codeline lineno="4091"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BL<sp/>=<sp/>botleft[ib];</highlight></codeline>
<codeline lineno="4092"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BR<sp/>=<sp/>botright[ib];</highlight></codeline>
<codeline lineno="4093"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TLBL<sp/>=<sp/>topleft[BL];</highlight></codeline>
<codeline lineno="4094"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LTBL<sp/>=<sp/>lefttop[BL];</highlight></codeline>
<codeline lineno="4095"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RTBR<sp/>=<sp/>righttop[BR];</highlight></codeline>
<codeline lineno="4096"><highlight class="normal"></highlight></codeline>
<codeline lineno="4097"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="4098"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levBL<sp/>=<sp/>level[BL];</highlight></codeline>
<codeline lineno="4099"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levBR<sp/>=<sp/>level[BR];</highlight></codeline>
<codeline lineno="4100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levLTBL<sp/>=<sp/>level[LTBL];</highlight></codeline>
<codeline lineno="4101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRTBR<sp/>=<sp/>level[RTBR];</highlight></codeline>
<codeline lineno="4102"><highlight class="normal"></highlight></codeline>
<codeline lineno="4103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="4104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="4105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="4106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="4107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="4108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="4113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="4120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BR);</highlight></codeline>
<codeline lineno="4126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BR);</highlight></codeline>
<codeline lineno="4127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BR);</highlight></codeline>
<codeline lineno="4128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BR);</highlight></codeline>
<codeline lineno="4129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBL<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="4134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BL);</highlight></codeline>
<codeline lineno="4136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBL<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="4139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BL);</highlight></codeline>
<codeline lineno="4144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BL);</highlight></codeline>
<codeline lineno="4145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BL);</highlight></codeline>
<codeline lineno="4146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BL);</highlight></codeline>
<codeline lineno="4147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="4154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BR);</highlight></codeline>
<codeline lineno="4160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BR);</highlight></codeline>
<codeline lineno="4161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BR);</highlight></codeline>
<codeline lineno="4162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BR);</highlight></codeline>
<codeline lineno="4163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBL<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="4168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>TLBL<sp/>==<sp/>ib<sp/>?<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.x<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="4170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>3.0;</highlight></codeline>
<codeline lineno="4171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="4172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="4173"><highlight class="normal"></highlight></codeline>
<codeline lineno="4174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="4175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>BL);</highlight></codeline>
<codeline lineno="4176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>BL);</highlight></codeline>
<codeline lineno="4177"><highlight class="normal"></highlight></codeline>
<codeline lineno="4178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TLBL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="4181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LTBL<sp/>==<sp/>BL)</highlight></codeline>
<codeline lineno="4183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="4185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="4186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="4187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLTBL<sp/>&lt;<sp/>levBL)</highlight></codeline>
<codeline lineno="4189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>LTBL);</highlight></codeline>
<codeline lineno="4194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLTBL<sp/>==<sp/>levBL)</highlight></codeline>
<codeline lineno="4196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>LTBL);</highlight></codeline>
<codeline lineno="4198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLTBL<sp/>&gt;<sp/>levBL)</highlight></codeline>
<codeline lineno="4200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="4203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>LTBL);</highlight></codeline>
<codeline lineno="4205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>(blockDim.x<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="4211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RTBR<sp/>==<sp/>BR)</highlight></codeline>
<codeline lineno="4213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="4215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="4216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="4217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRTBR<sp/>&lt;<sp/>levBR)</highlight></codeline>
<codeline lineno="4219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>RTBR);</highlight></codeline>
<codeline lineno="4224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRTBR<sp/>==<sp/>levBR)</highlight></codeline>
<codeline lineno="4226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>RTBR);</highlight></codeline>
<codeline lineno="4228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRTBR<sp/>&gt;<sp/>levBR)</highlight></codeline>
<codeline lineno="4230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="4233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>RTBR);</highlight></codeline>
<codeline lineno="4235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>w1<sp/>*<sp/>a[ii]<sp/>+<sp/>w2<sp/>*<sp/>a[ir]<sp/>+<sp/>w3<sp/>*<sp/>a[it];</highlight></codeline>
<codeline lineno="4239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="4241"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4242"><highlight class="normal"></highlight></codeline>
<codeline lineno="4243"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4244"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillBotnew&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="4245"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillBotnew&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="4246"><highlight class="normal"></highlight></codeline>
<codeline lineno="4256"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillBotFlux(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="4257"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4258"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>bb;</highlight></codeline>
<codeline lineno="4259"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>write;</highlight></codeline>
<codeline lineno="4260"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/>ir,<sp/>it;</highlight></codeline>
<codeline lineno="4261"><highlight class="normal"></highlight></codeline>
<codeline lineno="4262"><highlight class="normal"></highlight></codeline>
<codeline lineno="4263"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4264"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="4266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4267"><highlight class="normal"></highlight></codeline>
<codeline lineno="4268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="4271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4272"><highlight class="normal"></highlight></codeline>
<codeline lineno="4273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="4276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4278"><highlight class="normal"></highlight></codeline>
<codeline lineno="4279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="4282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4286"><highlight class="normal"></highlight></codeline>
<codeline lineno="4287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="4288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="4290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>8)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="4292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotRight[ib]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="4294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotRight[ib]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4295"><highlight class="normal"></highlight></codeline>
<codeline lineno="4296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[it]<sp/>);</highlight></codeline>
<codeline lineno="4297"><highlight class="normal"></highlight></codeline>
<codeline lineno="4298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4300"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4301"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.BotLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4302"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="4304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4306"><highlight class="normal"></highlight></codeline>
<codeline lineno="4307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="4308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="4309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="4310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4311"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4312"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4313"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4314"><highlight class="normal"></highlight></codeline>
<codeline lineno="4315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth<sp/>/<sp/>2;<sp/>j++)</highlight></codeline>
<codeline lineno="4316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4317"><highlight class="normal"></highlight></codeline>
<codeline lineno="4318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="4319"><highlight class="normal"></highlight></codeline>
<codeline lineno="4320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.BotLeft[ib];</highlight></codeline>
<codeline lineno="4322"><highlight class="normal"></highlight></codeline>
<codeline lineno="4323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>bb);</highlight></codeline>
<codeline lineno="4324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>bb);</highlight></codeline>
<codeline lineno="4326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4327"><highlight class="normal"></highlight></codeline>
<codeline lineno="4328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="4329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>botright<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="4334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4336"><highlight class="normal"></highlight></codeline>
<codeline lineno="4337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="4340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="4345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4347"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>8)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.BotRight[ib];</highlight></codeline>
<codeline lineno="4349"><highlight class="normal"></highlight></codeline>
<codeline lineno="4350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>z[read];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>bb);</highlight></codeline>
<codeline lineno="4354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>bb);</highlight></codeline>
<codeline lineno="4356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4357"><highlight class="normal"></highlight></codeline>
<codeline lineno="4358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/><sp/>+<sp/>z[it]<sp/>);</highlight></codeline>
<codeline lineno="4359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4361"><highlight class="normal"></highlight></codeline>
<codeline lineno="4362"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4363"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4364"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="4366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="4368"><highlight class="normal"></highlight></codeline>
<codeline lineno="4369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//T<sp/>w1,<sp/>w2,<sp/>w3;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4370"><highlight class="normal"></highlight></codeline>
<codeline lineno="4371"><highlight class="normal"></highlight></codeline>
<codeline lineno="4372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.TopLeft[XBlock.BotLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="4373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="4374"><highlight class="normal"></highlight></codeline>
<codeline lineno="4375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ii<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="4377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(doProlongation)</highlight></codeline>
<codeline lineno="4378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[ir];</highlight></codeline>
<codeline lineno="4379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4380"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4381"><highlight class="normal"></highlight></codeline>
<codeline lineno="4382"><highlight class="normal"></highlight></codeline>
<codeline lineno="4383"><highlight class="normal"></highlight></codeline>
<codeline lineno="4384"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4385"><highlight class="normal"></highlight></codeline>
<codeline lineno="4394"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTop(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="4395"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4396"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>bb;</highlight></codeline>
<codeline lineno="4397"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>write;</highlight></codeline>
<codeline lineno="4398"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="4399"><highlight class="normal"></highlight></codeline>
<codeline lineno="4400"><highlight class="normal"></highlight></codeline>
<codeline lineno="4401"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4402"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="4404"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4405"><highlight class="normal"></highlight></codeline>
<codeline lineno="4406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,j,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,j,<sp/>XParam.blkwidth,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4408"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="4409"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4410"><highlight class="normal"></highlight></codeline>
<codeline lineno="4411"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="4414"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4416"><highlight class="normal"></highlight></codeline>
<codeline lineno="4417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="4420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4422"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4424"><highlight class="normal"></highlight></codeline>
<codeline lineno="4425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="4426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="4428"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>(XParam.blkwidth<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4429"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4430"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>1,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4431"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4433"><highlight class="normal"></highlight></codeline>
<codeline lineno="4434"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="4435"><highlight class="normal"></highlight></codeline>
<codeline lineno="4436"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4437"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4438"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4439"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.TopLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4440"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4441"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="4442"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4443"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4444"><highlight class="normal"></highlight></codeline>
<codeline lineno="4445"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="4446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="4447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="4448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4449"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4450"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4451"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4452"><highlight class="normal"></highlight></codeline>
<codeline lineno="4453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth<sp/>/<sp/>2;<sp/>j++)</highlight></codeline>
<codeline lineno="4454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4455"><highlight class="normal"></highlight></codeline>
<codeline lineno="4456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="4457"><highlight class="normal"></highlight></codeline>
<codeline lineno="4458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.TopLeft[ib];</highlight></codeline>
<codeline lineno="4460"><highlight class="normal"></highlight></codeline>
<codeline lineno="4461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,jj,<sp/>0,<sp/>bb);</highlight></codeline>
<codeline lineno="4462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,jj,<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="4463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,jj<sp/>+<sp/>1,<sp/>0,<sp/>bb);</highlight></codeline>
<codeline lineno="4464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,jj<sp/>+<sp/>1,<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="4465"><highlight class="normal"></highlight></codeline>
<codeline lineno="4466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="4467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="4472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4474"><highlight class="normal"></highlight></codeline>
<codeline lineno="4475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,j,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="4478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="4483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>(XParam.blkwidth<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.TopRight[ib];</highlight></codeline>
<codeline lineno="4487"><highlight class="normal"></highlight></codeline>
<codeline lineno="4488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j<sp/>,<sp/>XParam.blkwidth,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>z[read];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,jj,<sp/>0,<sp/>bb);</highlight></codeline>
<codeline lineno="4492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,jj,<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="4493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,jj<sp/>+<sp/>1,<sp/>0,<sp/>bb);</highlight></codeline>
<codeline lineno="4494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,jj<sp/>+<sp/>1,<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="4495"><highlight class="normal"></highlight></codeline>
<codeline lineno="4496"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="4497"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4499"><highlight class="normal"></highlight></codeline>
<codeline lineno="4500"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4501"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4502"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="4504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="4506"><highlight class="normal"></highlight></codeline>
<codeline lineno="4507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="4508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="4509"><highlight class="normal"></highlight></codeline>
<codeline lineno="4510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.BotLeft[XBlock.TopLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="4511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>3.0);</highlight></codeline>
<codeline lineno="4512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>j<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="4513"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>j<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="4514"><highlight class="normal"></highlight></codeline>
<codeline lineno="4515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,j,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,jj,<sp/>0,<sp/><sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="4517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,jj-1,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="4518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//2<sp/>scenarios<sp/>here<sp/>ib<sp/>is<sp/>the<sp/>leftbot<sp/>neighbour<sp/>of<sp/>the<sp/>rightbot<sp/>block<sp/>or<sp/>ib<sp/>is<sp/>the<sp/>lefttop<sp/>neighbour</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotLeft[XBlock.TopLeft[ib]]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="4522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftBot[XBlock.TopLeft[ib]]<sp/>==<sp/>XBlock.TopLeft[ib])<sp/></highlight><highlight class="comment">//<sp/>no<sp/>botom<sp/>of<sp/>leftbot<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1));</highlight></codeline>
<codeline lineno="4526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="4527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="4528"><highlight class="normal"></highlight></codeline>
<codeline lineno="4529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4530"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]]<sp/>&lt;<sp/>XBlock.level[XBlock.TopLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>but<sp/>is<sp/>coarser</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="4533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="4534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="4535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,0,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="4536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]]<sp/>==<sp/>XBlock.level[XBlock.TopLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>same<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/><sp/>XParam.blkwidth<sp/>-<sp/>1,0,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="4540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]]<sp/>&gt;<sp/>XBlock.level[XBlock.TopLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>higher<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="4544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="4545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="4546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>0,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="4547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4548"><highlight class="normal"></highlight></codeline>
<codeline lineno="4549"><highlight class="normal"></highlight></codeline>
<codeline lineno="4550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4551"><highlight class="normal"></highlight></codeline>
<codeline lineno="4552"><highlight class="normal"></highlight></codeline>
<codeline lineno="4553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4555"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4556"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>(XParam.blkwidth<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="4557"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4558"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightBot[XBlock.TopRight[ib]]<sp/>==<sp/>XBlock.TopRight[ib])<sp/></highlight><highlight class="comment">//<sp/>no<sp/>botom<sp/>of<sp/>leftbot<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4560"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1));</highlight></codeline>
<codeline lineno="4561"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="4562"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="4563"><highlight class="normal"></highlight></codeline>
<codeline lineno="4564"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4565"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]]<sp/>&lt;<sp/>XBlock.level[XBlock.TopRight[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>but<sp/>is<sp/>coarser</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4566"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4567"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="4568"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="4569"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="4570"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>0,<sp/>XBlock.RightBot[XBlock.TopRight[ib]]);</highlight></codeline>
<codeline lineno="4571"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4572"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]]<sp/>==<sp/>XBlock.level[XBlock.TopRight[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>same<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4573"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4574"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>0,<sp/>XBlock.RightBot[XBlock.TopRight[ib]]);</highlight></codeline>
<codeline lineno="4575"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4576"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]]<sp/>&gt;<sp/>XBlock.level[XBlock.TopRight[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>higher<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4578"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="4579"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="4580"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="4581"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,0,<sp/>XBlock.RightBot[XBlock.TopRight[ib]]);</highlight></codeline>
<codeline lineno="4582"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4583"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4584"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4586"><highlight class="normal"></highlight></codeline>
<codeline lineno="4587"><highlight class="normal"></highlight></codeline>
<codeline lineno="4588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>w1<sp/>*<sp/>z[ii]<sp/>+<sp/>w2<sp/>*<sp/>z[ir]<sp/>+<sp/>w3<sp/>*<sp/>z[it];</highlight></codeline>
<codeline lineno="4589"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4590"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4591"><highlight class="normal"></highlight></codeline>
<codeline lineno="4592"><highlight class="normal"></highlight></codeline>
<codeline lineno="4593"><highlight class="normal"></highlight></codeline>
<codeline lineno="4594"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4595"><highlight class="normal"></highlight></codeline>
<codeline lineno="4610"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTop(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>topright,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/><sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="4611"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4612"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4613"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4614"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="4615"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>iy<sp/>=<sp/>blockDim.x-1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4616"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="4617"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="4618"><highlight class="normal"></highlight></codeline>
<codeline lineno="4619"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TL<sp/>=<sp/>topleft[ib];</highlight></codeline>
<codeline lineno="4620"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TR<sp/>=<sp/>topright[ib];</highlight></codeline>
<codeline lineno="4621"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LBTL<sp/>=<sp/>leftbot[TL];</highlight></codeline>
<codeline lineno="4622"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BLTL<sp/>=<sp/>botleft[TL];</highlight></codeline>
<codeline lineno="4623"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RBTR<sp/>=<sp/>rightbot[TR];</highlight></codeline>
<codeline lineno="4624"><highlight class="normal"></highlight></codeline>
<codeline lineno="4625"><highlight class="normal"></highlight></codeline>
<codeline lineno="4626"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="4627"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTL<sp/>=<sp/>level[TL];</highlight></codeline>
<codeline lineno="4628"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTR<sp/>=<sp/>level[TR];</highlight></codeline>
<codeline lineno="4629"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levLBTL<sp/>=<sp/>level[LBTL];</highlight></codeline>
<codeline lineno="4630"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRBTR<sp/>=<sp/>level[RBTR];</highlight></codeline>
<codeline lineno="4631"><highlight class="normal"></highlight></codeline>
<codeline lineno="4632"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x,<sp/>ib);</highlight></codeline>
<codeline lineno="4633"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="4634"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="4635"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="4636"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="4637"><highlight class="normal"></highlight></codeline>
<codeline lineno="4638"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4639"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4655"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TR);</highlight></codeline>
<codeline lineno="4657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TR);</highlight></codeline>
<codeline lineno="4659"><highlight class="normal"></highlight></codeline>
<codeline lineno="4660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4663"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4664"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="4665"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4666"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4668"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4669"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="4670"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4671"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4672"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4674"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="4675"><highlight class="normal"></highlight></codeline>
<codeline lineno="4676"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TL);</highlight></codeline>
<codeline lineno="4678"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4679"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TL);</highlight></codeline>
<codeline lineno="4680"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4681"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4682"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4683"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4684"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4685"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4686"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x-1,<sp/>ib);</highlight></codeline>
<codeline lineno="4687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4690"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4693"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TR);</highlight></codeline>
<codeline lineno="4694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TR);</highlight></codeline>
<codeline lineno="4696"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4697"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4699"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4700"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="4701"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>BLTL<sp/>==<sp/>ib<sp/>?<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.x<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="4703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>3.0;</highlight></codeline>
<codeline lineno="4704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="4705"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="4706"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4707"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4708"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4709"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BLTL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4710"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4711"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="4712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LBTL<sp/>==<sp/>TL)</highlight></codeline>
<codeline lineno="4714"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4715"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="4716"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="4717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="4718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLBTL<sp/>&lt;<sp/>levTL)</highlight></codeline>
<codeline lineno="4720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>0,<sp/>LBTL);</highlight></codeline>
<codeline lineno="4725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLBTL<sp/>==<sp/>levTL)</highlight></codeline>
<codeline lineno="4727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>0,<sp/>LBTL);</highlight></codeline>
<codeline lineno="4729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4730"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLBTL<sp/>&gt;<sp/>levTL)</highlight></codeline>
<codeline lineno="4731"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="4734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>0,<sp/>LBTL);</highlight></codeline>
<codeline lineno="4736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>blockDim.x<sp/>-<sp/>1)</highlight></codeline>
<codeline lineno="4742"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RBTR<sp/>==<sp/>TR)</highlight></codeline>
<codeline lineno="4744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="4746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="4747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="4748"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4749"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRBTR<sp/>&lt;<sp/>levTR)</highlight></codeline>
<codeline lineno="4750"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4753"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>RBTR);</highlight></codeline>
<codeline lineno="4755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4756"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRBTR<sp/>==<sp/>levTR)</highlight></codeline>
<codeline lineno="4757"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4758"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>RBTR);</highlight></codeline>
<codeline lineno="4759"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRBTR<sp/>&gt;<sp/>levTR)</highlight></codeline>
<codeline lineno="4761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4762"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4763"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="4764"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4765"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,0,<sp/>0,<sp/>RBTR);</highlight></codeline>
<codeline lineno="4766"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4767"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4768"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4769"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read=<sp/>w1<sp/>*<sp/>a[ii]<sp/>+<sp/>w2<sp/>*<sp/>a[ir]<sp/>+<sp/>w3<sp/>*<sp/>a[it];</highlight></codeline>
<codeline lineno="4770"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4771"><highlight class="normal"><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="4772"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4773"><highlight class="normal"></highlight></codeline>
<codeline lineno="4774"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTop&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="4775"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTop&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="4776"><highlight class="normal"></highlight></codeline>
<codeline lineno="4777"><highlight class="normal"></highlight><highlight class="comment">/***</highlight></codeline>
<codeline lineno="4778"><highlight class="comment"><sp/>*<sp/>@brief<sp/>CUDA<sp/>kernel<sp/>to<sp/>fill<sp/>the<sp/>top<sp/>halo<sp/>region<sp/>of<sp/>blocks<sp/>in<sp/>parallel<sp/>for<sp/>new<sp/>refinement,<sp/>handling<sp/>various<sp/>neighbor<sp/>configurations,<sp/>new<sp/>version</highlight></codeline>
<codeline lineno="4779"><highlight class="comment"><sp/>*<sp/>@param<sp/>halowidth<sp/>The<sp/>width<sp/>of<sp/>the<sp/>halo<sp/>region</highlight></codeline>
<codeline lineno="4780"><highlight class="comment"><sp/>*<sp/>@param<sp/>nblk<sp/>The<sp/>number<sp/>of<sp/>active<sp/>blocks</highlight></codeline>
<codeline lineno="4781"><highlight class="comment"><sp/>*<sp/>@param<sp/>active<sp/>The<sp/>array<sp/>of<sp/>active<sp/>block<sp/>indices</highlight></codeline>
<codeline lineno="4782"><highlight class="comment"><sp/>*<sp/>@param<sp/>level<sp/>The<sp/>array<sp/>of<sp/>block<sp/>levels</highlight></codeline>
<codeline lineno="4783"><highlight class="comment"><sp/>*<sp/>@param<sp/>topleft<sp/>The<sp/>array<sp/>of<sp/>top<sp/>left<sp/>neighbor<sp/>block<sp/>indices</highlight></codeline>
<codeline lineno="4784"><highlight class="comment"><sp/>*<sp/>@param<sp/>topright<sp/>The<sp/>array<sp/>of<sp/>top<sp/>right<sp/>neighbor<sp/>block<sp/>indices</highlight></codeline>
<codeline lineno="4785"><highlight class="comment"><sp/>*<sp/>@param<sp/>botleft<sp/>The<sp/>array<sp/>of<sp/>bottom<sp/>left<sp/>neighbor<sp/>block<sp/>indices</highlight></codeline>
<codeline lineno="4786"><highlight class="comment"><sp/>*<sp/>@param<sp/>leftbot<sp/>The<sp/>array<sp/>of<sp/>left<sp/>bottom<sp/>neighbor<sp/>block<sp/>indices</highlight></codeline>
<codeline lineno="4787"><highlight class="comment"><sp/>*<sp/>@param<sp/>rightbot<sp/>The<sp/>array<sp/>of<sp/>right<sp/>bottom<sp/>neighbor<sp/>block<sp/>indices</highlight></codeline>
<codeline lineno="4788"><highlight class="comment"><sp/>*<sp/>@param<sp/>a<sp/>The<sp/>variable<sp/>to<sp/>be<sp/>refined</highlight></codeline>
<codeline lineno="4789"><highlight class="comment"><sp/>*<sp/></highlight></codeline>
<codeline lineno="4790"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4791"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopnew(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="4792"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4793"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4794"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4795"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="4796"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>iy<sp/>=<sp/>blockDim.x-1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4797"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>threadIdx.y<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.y;</highlight></codeline>
<codeline lineno="4798"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ibl<sp/>&lt;<sp/>nblk)</highlight></codeline>
<codeline lineno="4799"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="4801"><highlight class="normal"></highlight></codeline>
<codeline lineno="4802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TL<sp/>=<sp/>topleft[ib];</highlight></codeline>
<codeline lineno="4803"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TR<sp/>=<sp/>topright[ib];</highlight></codeline>
<codeline lineno="4804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LBTL<sp/>=<sp/>leftbot[TL];</highlight></codeline>
<codeline lineno="4805"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BLTL<sp/>=<sp/>botleft[TL];</highlight></codeline>
<codeline lineno="4806"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RBTR<sp/>=<sp/>rightbot[TR];</highlight></codeline>
<codeline lineno="4807"><highlight class="normal"></highlight></codeline>
<codeline lineno="4808"><highlight class="normal"></highlight></codeline>
<codeline lineno="4809"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="4810"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTL<sp/>=<sp/>level[TL];</highlight></codeline>
<codeline lineno="4811"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTR<sp/>=<sp/>level[TR];</highlight></codeline>
<codeline lineno="4812"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levLBTL<sp/>=<sp/>level[LBTL];</highlight></codeline>
<codeline lineno="4813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRBTR<sp/>=<sp/>level[RBTR];</highlight></codeline>
<codeline lineno="4814"><highlight class="normal"></highlight></codeline>
<codeline lineno="4815"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x,<sp/>ib);</highlight></codeline>
<codeline lineno="4816"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="4817"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="4818"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="4819"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="4820"><highlight class="normal"></highlight></codeline>
<codeline lineno="4821"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4822"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4823"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4824"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4825"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4826"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4829"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4833"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4838"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TR);</highlight></codeline>
<codeline lineno="4840"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TR);</highlight></codeline>
<codeline lineno="4842"><highlight class="normal"></highlight></codeline>
<codeline lineno="4843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="4848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="4853"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4854"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4857"><highlight class="normal"></highlight></codeline>
<codeline lineno="4858"><highlight class="normal"></highlight></codeline>
<codeline lineno="4859"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TL);</highlight></codeline>
<codeline lineno="4861"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4862"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TL);</highlight></codeline>
<codeline lineno="4863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4864"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4865"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4870"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4871"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4872"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4873"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TR);</highlight></codeline>
<codeline lineno="4877"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TR);</highlight></codeline>
<codeline lineno="4879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4881"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4882"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="4884"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>BLTL<sp/>==<sp/>ib<sp/>?<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.x<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="4886"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>3.0;</highlight></codeline>
<codeline lineno="4887"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="4888"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="4889"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4890"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4891"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4892"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BLTL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4894"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="4895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LBTL<sp/>==<sp/>TL)</highlight></codeline>
<codeline lineno="4897"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4898"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="4899"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="4900"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="4901"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4902"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLBTL<sp/>&lt;<sp/>levTL)</highlight></codeline>
<codeline lineno="4903"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4904"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4905"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4906"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4907"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>0,<sp/>LBTL);</highlight></codeline>
<codeline lineno="4908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLBTL<sp/>==<sp/>levTL)</highlight></codeline>
<codeline lineno="4910"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4911"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>0,<sp/>LBTL);</highlight></codeline>
<codeline lineno="4912"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4913"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLBTL<sp/>&gt;<sp/>levTL)</highlight></codeline>
<codeline lineno="4914"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4915"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4916"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="4917"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4918"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>0,<sp/>LBTL);</highlight></codeline>
<codeline lineno="4919"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4920"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4921"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4922"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4923"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4924"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>blockDim.x<sp/>-<sp/>1)</highlight></codeline>
<codeline lineno="4925"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4926"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RBTR<sp/>==<sp/>TR)</highlight></codeline>
<codeline lineno="4927"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4928"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="4929"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="4930"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="4931"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4932"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRBTR<sp/>&lt;<sp/>levTR)</highlight></codeline>
<codeline lineno="4933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4935"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>RBTR);</highlight></codeline>
<codeline lineno="4938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRBTR<sp/>==<sp/>levTR)</highlight></codeline>
<codeline lineno="4940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>RBTR);</highlight></codeline>
<codeline lineno="4942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRBTR<sp/>&gt;<sp/>levTR)</highlight></codeline>
<codeline lineno="4944"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4946"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="4947"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>RBTR);</highlight></codeline>
<codeline lineno="4949"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4952"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>w1<sp/>*<sp/>a[ii]<sp/>+<sp/>w2<sp/>*<sp/>a[ir]<sp/>+<sp/>w3<sp/>*<sp/>a[it];</highlight></codeline>
<codeline lineno="4953"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4954"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="4955"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4956"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4957"><highlight class="normal"></highlight></codeline>
<codeline lineno="4958"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopnew&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="4959"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopnew&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="4960"><highlight class="normal"></highlight></codeline>
<codeline lineno="4970"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopFlux(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="4971"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4972"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>bb;</highlight></codeline>
<codeline lineno="4973"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>write;</highlight></codeline>
<codeline lineno="4974"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/>ir,<sp/>it;</highlight></codeline>
<codeline lineno="4975"><highlight class="normal"></highlight></codeline>
<codeline lineno="4976"><highlight class="normal"></highlight></codeline>
<codeline lineno="4977"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4978"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4979"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="4980"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4981"><highlight class="normal"></highlight></codeline>
<codeline lineno="4982"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4983"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4984"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="4985"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4986"><highlight class="normal"></highlight></codeline>
<codeline lineno="4987"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4988"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4989"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="4990"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4992"><highlight class="normal"></highlight></codeline>
<codeline lineno="4993"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4994"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="4996"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4997"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4998"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4999"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5000"><highlight class="normal"></highlight></codeline>
<codeline lineno="5001"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="5002"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="5004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>(XParam.blkwidth<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="5005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="5006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>1,<sp/>XBlock.TopRight[ib]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="5008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>XBlock.TopRight[ib]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5009"><highlight class="normal"></highlight></codeline>
<codeline lineno="5010"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[it]<sp/>);</highlight></codeline>
<codeline lineno="5011"><highlight class="normal"></highlight></codeline>
<codeline lineno="5012"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5013"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5014"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5015"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.TopLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5016"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5017"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="5018"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5019"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5020"><highlight class="normal"></highlight></codeline>
<codeline lineno="5021"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="5022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="5023"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="5024"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5025"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5026"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="5027"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5028"><highlight class="normal"></highlight></codeline>
<codeline lineno="5029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth<sp/>/<sp/>2;<sp/>j++)</highlight></codeline>
<codeline lineno="5030"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5031"><highlight class="normal"></highlight></codeline>
<codeline lineno="5032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="5033"><highlight class="normal"></highlight></codeline>
<codeline lineno="5034"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="5035"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.TopLeft[ib];</highlight></codeline>
<codeline lineno="5036"><highlight class="normal"></highlight></codeline>
<codeline lineno="5037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>0,<sp/>bb);</highlight></codeline>
<codeline lineno="5038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>1,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>bb);</highlight></codeline>
<codeline lineno="5040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5041"><highlight class="normal"></highlight></codeline>
<codeline lineno="5042"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/><sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="5043"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="5046"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="5048"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5050"><highlight class="normal"></highlight></codeline>
<codeline lineno="5051"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5053"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="5054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5057"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5058"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="5059"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5060"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5061"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>(XParam.blkwidth<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="5062"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.TopRight[ib];</highlight></codeline>
<codeline lineno="5063"><highlight class="normal"></highlight></codeline>
<codeline lineno="5064"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5065"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5066"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>z[read];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5067"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>0,<sp/>bb);</highlight></codeline>
<codeline lineno="5068"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>1,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5069"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>bb);</highlight></codeline>
<codeline lineno="5070"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5071"><highlight class="normal"></highlight></codeline>
<codeline lineno="5072"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/><sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="5073"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5074"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5075"><highlight class="normal"></highlight></codeline>
<codeline lineno="5076"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5077"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5078"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5079"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="5080"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5081"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="5082"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.BotLeft[XBlock.TopLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(floor(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(floor(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="5083"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="5084"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="5085"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="5086"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(doProlongation)</highlight></codeline>
<codeline lineno="5087"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[ir];</highlight></codeline>
<codeline lineno="5088"><highlight class="normal"></highlight></codeline>
<codeline lineno="5089"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5090"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5091"><highlight class="normal"></highlight></codeline>
<codeline lineno="5092"><highlight class="normal"></highlight></codeline>
<codeline lineno="5093"><highlight class="normal"></highlight></codeline>
<codeline lineno="5094"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5095"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopFlux&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*&amp;<sp/>z);</highlight></codeline>
<codeline lineno="5096"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopFlux&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*&amp;<sp/>z);</highlight></codeline>
<codeline lineno="5097"><highlight class="normal"></highlight></codeline>
<codeline lineno="5113"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopFlux(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="5114"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5115"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="5116"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5117"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="5118"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>iy<sp/>=<sp/>blockDim.x<sp/>-<sp/>1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5119"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="5120"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="5121"><highlight class="normal"></highlight></codeline>
<codeline lineno="5122"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TL<sp/>=<sp/>topleft[ib];</highlight></codeline>
<codeline lineno="5123"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TR<sp/>=<sp/>topright[ib];</highlight></codeline>
<codeline lineno="5124"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>LBTL<sp/>=<sp/>leftbot[TL];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5125"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BLTL<sp/>=<sp/>botleft[TL];</highlight></codeline>
<codeline lineno="5126"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>RBTR<sp/>=<sp/>rightbot[TR];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5127"><highlight class="normal"></highlight></codeline>
<codeline lineno="5128"><highlight class="normal"></highlight></codeline>
<codeline lineno="5129"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="5130"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTL<sp/>=<sp/>level[TL];</highlight></codeline>
<codeline lineno="5131"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>levTR<sp/>=<sp/>level[TR];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5132"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>levLBTL<sp/>=<sp/>level[LBTL];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5133"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>levRBTR<sp/>=<sp/>level[RBTR];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5134"><highlight class="normal"></highlight></codeline>
<codeline lineno="5135"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x,<sp/>ib);</highlight></codeline>
<codeline lineno="5136"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="5137"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it;</highlight></codeline>
<codeline lineno="5138"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="5139"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//T<sp/>w1,<sp/>w2,<sp/>w3;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5140"><highlight class="normal"></highlight></codeline>
<codeline lineno="5141"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="5142"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="5144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="5146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="5147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="5151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="5153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="5154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="5158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="5159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TR);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="5161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TR);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5162"><highlight class="normal"></highlight></codeline>
<codeline lineno="5163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.5)<sp/>*<sp/>(a[ii]<sp/><sp/>+<sp/>a[it]<sp/>);</highlight></codeline>
<codeline lineno="5164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5166"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5167"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="5168"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="5170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="5171"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5172"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="5173"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="5175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="5177"><highlight class="normal"></highlight></codeline>
<codeline lineno="5178"><highlight class="normal"></highlight></codeline>
<codeline lineno="5179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="5180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TL);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="5182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TL);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.5)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[it]);</highlight></codeline>
<codeline lineno="5184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="5188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="5190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="5191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="5195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="5196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TR);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="5198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TR);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.5)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[it]);</highlight></codeline>
<codeline lineno="5200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5202"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5203"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="5204"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>BLTL<sp/>==<sp/>ib<sp/>?<sp/>floor(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>floor(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.x<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="5206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="5207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="5208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(doProlongation)</highlight></codeline>
<codeline lineno="5209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[ir];</highlight></codeline>
<codeline lineno="5210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/><sp/>a[write];</highlight></codeline>
<codeline lineno="5212"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5213"><highlight class="normal"><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="5214"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5215"><highlight class="normal"></highlight></codeline>
<codeline lineno="5216"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopFlux&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="5217"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopFlux&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="5218"><highlight class="normal"></highlight></codeline>
<codeline lineno="5219"><highlight class="normal"></highlight></codeline>
<codeline lineno="5227"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="5228"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5229"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib;</highlight></codeline>
<codeline lineno="5230"><highlight class="normal"></highlight></codeline>
<codeline lineno="5231"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="5232"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="5234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillCorners(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="5235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="5236"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5237"><highlight class="normal"></highlight></codeline>
<codeline lineno="5238"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5239"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*&amp;<sp/>z);</highlight></codeline>
<codeline lineno="5240"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*&amp;<sp/>z);</highlight></codeline>
<codeline lineno="5241"><highlight class="normal"></highlight></codeline>
<codeline lineno="5242"><highlight class="normal"></highlight></codeline>
<codeline lineno="5251"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref>&amp;<sp/>Xev)</highlight></codeline>
<codeline lineno="5252"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5253"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib;</highlight></codeline>
<codeline lineno="5254"><highlight class="normal"></highlight></codeline>
<codeline lineno="5255"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="5256"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="5258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillCorners(XParam,<sp/>ib,<sp/>XBlock,<sp/>Xev.<ref refid="structEvolvingP_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>);</highlight></codeline>
<codeline lineno="5259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillCorners(XParam,<sp/>ib,<sp/>XBlock,<sp/>Xev.<ref refid="structEvolvingP_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>);</highlight></codeline>
<codeline lineno="5260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillCorners(XParam,<sp/>ib,<sp/>XBlock,<sp/>Xev.<ref refid="structEvolvingP_1addf0f1e2e0672ff7d32890c1867d1586" kindref="member">u</ref>);</highlight></codeline>
<codeline lineno="5261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillCorners(XParam,<sp/>ib,<sp/>XBlock,<sp/>Xev.<ref refid="structEvolvingP_1a5f61fdbd33ae88a62d35dd5235d8f375" kindref="member">v</ref>);</highlight></codeline>
<codeline lineno="5262"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5263"><highlight class="normal"></highlight></codeline>
<codeline lineno="5264"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5265"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref>&amp;<sp/>Xev);</highlight></codeline>
<codeline lineno="5266"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref>&amp;<sp/>Xev);</highlight></codeline>
<codeline lineno="5267"><highlight class="normal"></highlight></codeline>
<codeline lineno="5268"><highlight class="normal"></highlight></codeline>
<codeline lineno="5277"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="5278"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5279"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Run<sp/>only<sp/>this<sp/>function<sp/>after<sp/>the<sp/>filling<sp/>the<sp/>other<sp/>bit<sp/>of<sp/>halo<sp/>(i.e.<sp/>fctn<sp/>fillleft...)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5280"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Most<sp/>of<sp/>the<sp/>time<sp/>the<sp/>cormers<sp/>are<sp/>not<sp/>needed.<sp/>they<sp/>are<sp/>when<sp/>refining<sp/>a<sp/>cell!<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5281"><highlight class="normal"></highlight></codeline>
<codeline lineno="5282"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="5283"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>zz;</highlight></codeline>
<codeline lineno="5284"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write;</highlight></codeline>
<codeline lineno="5285"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="5286"><highlight class="normal"></highlight></codeline>
<codeline lineno="5287"><highlight class="normal"></highlight></codeline>
<codeline lineno="5288"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Bottom<sp/>left<sp/>corner</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5289"><highlight class="normal"><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="5290"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//check<sp/>that<sp/>there<sp/>is<sp/>a<sp/>block<sp/>there<sp/>and<sp/>if<sp/>there<sp/>is<sp/>calculate<sp/>the<sp/>value<sp/>depending<sp/>on<sp/>the<sp/>level<sp/>of<sp/>that<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5291"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[XBlock.BotLeft[ib]]<sp/>==<sp/>XBlock.BotLeft[ib])<sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>no<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5292"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[memloc(XParam,<sp/>-1,<sp/>0,<sp/>ib)]<sp/>+<sp/>z[memloc(XParam,<sp/>0,<sp/>-1,<sp/>ib)]);</highlight></codeline>
<codeline lineno="5294"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5295"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]]<sp/>==<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="5296"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>z[memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]])];</highlight></codeline>
<codeline lineno="5298"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5299"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="5300"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]]);</highlight></codeline>
<codeline lineno="5302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>2,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]]);</highlight></codeline>
<codeline lineno="5303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>2,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]]);</highlight></codeline>
<codeline lineno="5304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>2,<sp/>XParam.blkwidth<sp/>-<sp/>2,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]]);</highlight></codeline>
<codeline lineno="5305"><highlight class="normal"></highlight></codeline>
<codeline lineno="5306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="5307"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5308"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="5309"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]]);</highlight></codeline>
<codeline lineno="5311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>-<sp/>1,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="5312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,0,<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="5313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.5)<sp/>*<sp/>z[ii]<sp/>+<sp/>T(0.25)<sp/>*<sp/>(z[ir]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="5314"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5315"><highlight class="normal"></highlight></codeline>
<codeline lineno="5316"><highlight class="normal"><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>zz;</highlight></codeline>
<codeline lineno="5317"><highlight class="normal"></highlight></codeline>
<codeline lineno="5318"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Top<sp/>Left<sp/>corner</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5319"><highlight class="normal"><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="5320"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//check<sp/>that<sp/>there<sp/>is<sp/>a<sp/>block<sp/>there<sp/>and<sp/>if<sp/>there<sp/>is<sp/>calculate<sp/>the<sp/>value<sp/>depending<sp/>on<sp/>the<sp/>level<sp/>of<sp/>that<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5321"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftBot[XBlock.TopLeft[ib]]<sp/>==<sp/>XBlock.TopLeft[ib])<sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>no<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5322"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[memloc(XParam,<sp/>-1,<sp/>XParam.blkwidth-1,<sp/>ib)]<sp/>+<sp/>z[memloc(XParam,<sp/>0,<sp/>XParam.blkwidth,<sp/>ib)]);</highlight></codeline>
<codeline lineno="5324"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5325"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]]<sp/>==<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="5326"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>z[memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>0,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]])];</highlight></codeline>
<codeline lineno="5328"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5329"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="5330"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>0,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="5332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>1,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="5333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>2,<sp/>0,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="5334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>2,<sp/>1,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="5335"><highlight class="normal"></highlight></codeline>
<codeline lineno="5336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="5337"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5338"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="5339"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>0,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="5341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="5342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="5343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.5)<sp/>*<sp/>z[ii]<sp/>+<sp/>T(0.25)<sp/>*<sp/>(z[ir]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="5344"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5345"><highlight class="normal"></highlight></codeline>
<codeline lineno="5346"><highlight class="normal"><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>zz;</highlight></codeline>
<codeline lineno="5347"><highlight class="normal"></highlight></codeline>
<codeline lineno="5348"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Top<sp/>Right<sp/>corner</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5349"><highlight class="normal"><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="5350"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//check<sp/>that<sp/>there<sp/>is<sp/>a<sp/>block<sp/>there<sp/>and<sp/>if<sp/>there<sp/>is<sp/>calculate<sp/>the<sp/>value<sp/>depending<sp/>on<sp/>the<sp/>level<sp/>of<sp/>that<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5351"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightBot[XBlock.TopRight[ib]]<sp/>==<sp/>XBlock.TopRight[ib])<sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>no<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5352"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[memloc(XParam,<sp/>XParam.blkwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib)]<sp/>+<sp/>z[memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth,<sp/>ib)]);</highlight></codeline>
<codeline lineno="5354"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5355"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]]<sp/>==<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="5356"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>z[memloc(XParam,<sp/>0,<sp/>0,<sp/>XBlock.RightBot[XBlock.TopRight[ib]])];</highlight></codeline>
<codeline lineno="5358"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5359"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="5360"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>0,<sp/>XBlock.RightBot[XBlock.TopRight[ib]]);</highlight></codeline>
<codeline lineno="5362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>1,<sp/>XBlock.RightBot[XBlock.TopRight[ib]]);</highlight></codeline>
<codeline lineno="5363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>0,<sp/>XBlock.RightBot[XBlock.TopRight[ib]]);</highlight></codeline>
<codeline lineno="5364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>1,<sp/>XBlock.RightBot[XBlock.TopRight[ib]]);</highlight></codeline>
<codeline lineno="5365"><highlight class="normal"></highlight></codeline>
<codeline lineno="5366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="5367"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5368"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="5369"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>0,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="5371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="5372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth-1,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="5373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.5)<sp/>*<sp/>z[ii]<sp/>+<sp/>T(0.25)<sp/>*<sp/>(<sp/>z[ir]<sp/>+<sp/><sp/>z[it]);</highlight></codeline>
<codeline lineno="5374"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5375"><highlight class="normal"></highlight></codeline>
<codeline lineno="5376"><highlight class="normal"><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>zz;</highlight></codeline>
<codeline lineno="5377"><highlight class="normal"></highlight></codeline>
<codeline lineno="5378"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Bot<sp/>Right<sp/>corner</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5379"><highlight class="normal"><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="5380"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//check<sp/>that<sp/>there<sp/>is<sp/>a<sp/>block<sp/>there<sp/>and<sp/>if<sp/>there<sp/>is<sp/>calculate<sp/>the<sp/>value<sp/>depending<sp/>on<sp/>the<sp/>level<sp/>of<sp/>that<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5381"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightBot[XBlock.BotRight[ib]]<sp/>==<sp/>XBlock.BotRight[ib])<sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>no<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5382"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[memloc(XParam,<sp/>XParam.blkwidth-1,<sp/>-<sp/>1,<sp/>ib)]<sp/>+<sp/>z[memloc(XParam,<sp/>XParam.blkwidth<sp/>,<sp/>0,<sp/>ib)]);</highlight></codeline>
<codeline lineno="5384"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5385"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[XBlock.BotRight[ib]]]<sp/>==<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="5386"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>z[memloc(XParam,<sp/>0,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.RightBot[XBlock.BotRight[ib]])];</highlight></codeline>
<codeline lineno="5388"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5389"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[XBlock.BotRight[ib]]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="5390"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.RightBot[XBlock.BotRight[ib]]);</highlight></codeline>
<codeline lineno="5392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>XParam.blkwidth<sp/>-<sp/>2,<sp/>XBlock.RightBot[XBlock.BotRight[ib]]);</highlight></codeline>
<codeline lineno="5393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.RightBot[XBlock.BotRight[ib]]);</highlight></codeline>
<codeline lineno="5394"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>2,<sp/>XBlock.RightBot[XBlock.BotRight[ib]]);</highlight></codeline>
<codeline lineno="5395"><highlight class="normal"></highlight></codeline>
<codeline lineno="5396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="5397"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5398"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[XBlock.BotRight[ib]]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="5399"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="5401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="5402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="5403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.5)<sp/>*<sp/>z[ii]<sp/>+<sp/>T(0.25)<sp/>*<sp/>(z[ir]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="5404"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5405"><highlight class="normal"></highlight></codeline>
<codeline lineno="5406"><highlight class="normal"><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>zz;</highlight></codeline>
<codeline lineno="5407"><highlight class="normal"></highlight></codeline>
<codeline lineno="5408"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5409"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*&amp;<sp/>z);</highlight></codeline>
<codeline lineno="5410"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*&amp;<sp/>z);</highlight></codeline>
<codeline lineno="5411"><highlight class="normal"></highlight></codeline>
<codeline lineno="5420"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCornersGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="5421"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5422"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="5423"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth<sp/>=<sp/>XParam.halowidth;</highlight></codeline>
<codeline lineno="5424"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5425"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="5426"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>iy<sp/>=<sp/>threadIdx.y;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5427"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>iy<sp/>=<sp/>blockDim.x-1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5428"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="5429"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="5430"><highlight class="normal"></highlight></codeline>
<codeline lineno="5431"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TL<sp/>=<sp/>XBlock.TopLeft[ib];</highlight></codeline>
<codeline lineno="5432"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TR<sp/>=<sp/>XBlock.TopRight[ib];</highlight></codeline>
<codeline lineno="5433"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LB<sp/>=<sp/>XBlock.LeftBot[ib];</highlight></codeline>
<codeline lineno="5434"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LT<sp/>=<sp/>XBlock.LeftTop[ib];</highlight></codeline>
<codeline lineno="5435"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BL<sp/>=<sp/>XBlock.BotLeft[ib];</highlight></codeline>
<codeline lineno="5436"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BR<sp/>=<sp/>XBlock.BotRight[ib];</highlight></codeline>
<codeline lineno="5437"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RB<sp/>=<sp/>XBlock.RightBot[ib];</highlight></codeline>
<codeline lineno="5438"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RT<sp/>=<sp/>XBlock.RightTop[ib];</highlight></codeline>
<codeline lineno="5439"><highlight class="normal"></highlight></codeline>
<codeline lineno="5440"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>LBTL<sp/>=<sp/>XBlock.leftbot[TL];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5441"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>BLTL<sp/>=<sp/>XBlock.botleft[TL];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5442"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>RBTR<sp/>=<sp/>XBlock.rightbot[TR];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5443"><highlight class="normal"></highlight></codeline>
<codeline lineno="5444"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iout,<sp/>ii;</highlight></codeline>
<codeline lineno="5445"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="5446"><highlight class="normal"></highlight></codeline>
<codeline lineno="5447"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="5448"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Bot<sp/>left<sp/>corner</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5450"><highlight class="normal"></highlight></codeline>
<codeline lineno="5451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iout<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>-1,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="5452"><highlight class="normal"></highlight></codeline>
<codeline lineno="5453"><highlight class="normal"></highlight></codeline>
<codeline lineno="5454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BL<sp/>==<sp/>ib<sp/>&amp;&amp;<sp/>LB<sp/>==<sp/>ib)</highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="5457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BL<sp/>!=<sp/>ib)</highlight></codeline>
<codeline lineno="5461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>-1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>BL);</highlight></codeline>
<codeline lineno="5463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>-1,<sp/>LB);</highlight></codeline>
<codeline lineno="5467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5468"><highlight class="normal"></highlight></codeline>
<codeline lineno="5469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[iout]<sp/>=<sp/>z[ii];</highlight></codeline>
<codeline lineno="5471"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5472"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>1)</highlight></codeline>
<codeline lineno="5473"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5474"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="5475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Top<sp/>left<sp/>corner</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iout<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>-1,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="5477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TL<sp/>==<sp/>ib<sp/>&amp;&amp;<sp/>LT<sp/>==<sp/>ib)</highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="5480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TL<sp/>!=<sp/>ib)</highlight></codeline>
<codeline lineno="5484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>-1,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="5486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="5490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5491"><highlight class="normal"></highlight></codeline>
<codeline lineno="5492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[iout]<sp/>=<sp/>z[ii];</highlight></codeline>
<codeline lineno="5494"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="5495"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5496"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>2)</highlight></codeline>
<codeline lineno="5497"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Top<sp/>right<sp/>corner</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iout<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="5500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TR<sp/>==<sp/>ib<sp/>&amp;&amp;<sp/>RT<sp/>==<sp/>ib)</highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="5503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TR<sp/>!=<sp/>ib)</highlight></codeline>
<codeline lineno="5507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="5509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>XParam.blkwidth,<sp/>RT);</highlight></codeline>
<codeline lineno="5513"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5514"><highlight class="normal"></highlight></codeline>
<codeline lineno="5515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[iout]<sp/>=<sp/>z[ii];</highlight></codeline>
<codeline lineno="5517"><highlight class="normal"></highlight></codeline>
<codeline lineno="5518"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5519"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>3)</highlight></codeline>
<codeline lineno="5520"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Bot<sp/>right<sp/>corner</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iout<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="5523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BR<sp/>==<sp/>ib<sp/>&amp;&amp;<sp/>RB<sp/>==<sp/>ib)</highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="5526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BR<sp/>!=<sp/>ib)</highlight></codeline>
<codeline lineno="5530"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>BR);</highlight></codeline>
<codeline lineno="5532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>-1,<sp/>RB);</highlight></codeline>
<codeline lineno="5536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5537"><highlight class="normal"></highlight></codeline>
<codeline lineno="5538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[iout]<sp/>=<sp/>z[ii];</highlight></codeline>
<codeline lineno="5540"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5541"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="5542"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5543"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCornersGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="5544"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCornersGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
    </programlisting>
    <location file="src/Halo.cu"/>
  </compounddef>
</doxygen>
