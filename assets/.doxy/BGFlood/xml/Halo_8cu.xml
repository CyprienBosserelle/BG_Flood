<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="Halo_8cu" kind="file" language="C++">
    <compoundname>Halo.cu</compoundname>
    <includes refid="Halo_8h" local="yes">Halo.h</includes>
    <incdepgraph>
      <node id="27">
        <label>Arrays.h</label>
        <link refid="Arrays_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
      </node>
      <node id="45">
        <label>Boundary.h</label>
        <link refid="Boundary_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
      </node>
      <node id="46">
        <label>ConserveElevation.h</label>
        <link refid="ConserveElevation_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
      </node>
      <node id="29">
        <label>Forcing.h</label>
        <link refid="Forcing_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
      </node>
      <node id="3">
        <label>General.h</label>
        <link refid="General_8h_source"/>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
        <childnode refid="16" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
        <childnode refid="19" relation="include">
        </childnode>
        <childnode refid="20" relation="include">
        </childnode>
        <childnode refid="21" relation="include">
        </childnode>
        <childnode refid="22" relation="include">
        </childnode>
      </node>
      <node id="42">
        <label>Gradients.h</label>
        <link refid="Gradients_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
      <node id="33">
        <label>GridManip.h</label>
        <link refid="GridManip_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>src/Halo.cu</label>
        <link refid="Halo_8cu"/>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>Halo.h</label>
        <link refid="Halo_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="28" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="45" relation="include">
        </childnode>
        <childnode refid="46" relation="include">
        </childnode>
      </node>
      <node id="34">
        <label>InitEvolv.h</label>
        <link refid="InitEvolv_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="35" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
      </node>
      <node id="32">
        <label>InitialConditions.h</label>
        <link refid="InitialConditions_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="34" relation="include">
        </childnode>
        <childnode refid="42" relation="include">
        </childnode>
        <childnode refid="43" relation="include">
        </childnode>
      </node>
      <node id="24">
        <label>Input.h</label>
        <link refid="Input_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="44">
        <label>Kurganov.h</label>
        <link refid="Kurganov_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="43" relation="include">
        </childnode>
      </node>
      <node id="30">
        <label>MemManagement.h</label>
        <link refid="MemManagement_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
      </node>
      <node id="28">
        <label>Mesh.h</label>
        <link refid="Mesh_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="39" relation="include">
        </childnode>
      </node>
      <node id="23">
        <label>Param.h</label>
        <link refid="Param_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
      </node>
      <node id="39">
        <label>Poly.h</label>
        <link refid="Poly_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
      </node>
      <node id="38">
        <label>ReadForcing.h</label>
        <link refid="ReadForcing_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="35" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="39" relation="include">
        </childnode>
      </node>
      <node id="36">
        <label>ReadInput.h</label>
        <link refid="ReadInput_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
      </node>
      <node id="35">
        <label>Read_netcdf.h</label>
        <link refid="Read__netcdf_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="36" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="40" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
      </node>
      <node id="31">
        <label>Setup_GPU.h</label>
        <link refid="Setup__GPU_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="32" relation="include">
        </childnode>
      </node>
      <node id="43">
        <label>Spherical.h</label>
        <link refid="Spherical_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="44" relation="include">
        </childnode>
      </node>
      <node id="41">
        <label>Updateforcing.h</label>
        <link refid="Updateforcing_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="32" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
      </node>
      <node id="26">
        <label>Util_CPU.h</label>
        <link refid="Util__CPU_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
      </node>
      <node id="40">
        <label>Write_netcdf.h</label>
        <link refid="Write__netcdf_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="36" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
      </node>
      <node id="25">
        <label>Write_txtlog.h</label>
        <link refid="Write__txtlog_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
      </node>
      <node id="37">
        <label>utctime.h</label>
        <link refid="utctime_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="36" relation="include">
        </childnode>
      </node>
      <node id="16">
        <label>algorithm</label>
      </node>
      <node id="10">
        <label>chrono</label>
      </node>
      <node id="9">
        <label>cmath</label>
      </node>
      <node id="11">
        <label>ctime</label>
      </node>
      <node id="4">
        <label>cuda_runtime.h</label>
      </node>
      <node id="5">
        <label>device_launch_parameters.h</label>
      </node>
      <node id="19">
        <label>fstream</label>
      </node>
      <node id="18">
        <label>iomanip</label>
      </node>
      <node id="17">
        <label>iostream</label>
      </node>
      <node id="21">
        <label>limits</label>
      </node>
      <node id="14">
        <label>map</label>
      </node>
      <node id="8">
        <label>math.h</label>
      </node>
      <node id="15">
        <label>netcdf.h</label>
      </node>
      <node id="20">
        <label>sstream</label>
      </node>
      <node id="6">
        <label>stdio.h</label>
      </node>
      <node id="7">
        <label>stdlib.h</label>
      </node>
      <node id="12">
        <label>string</label>
      </node>
      <node id="22">
        <label>thread</label>
      </node>
      <node id="13">
        <label>vector</label>
      </node>
    </incdepgraph>
    <sectiondef kind="func">
      <memberdef kind="function" id="Halo_8cu_1a33d2233b52ae274a668055c9075a3901" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void void fillHaloD</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>fillHaloD</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating halos on CPU on every side of a block of a single variable. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8cu_1autotoc_md0">
<title>Description</title>
<para>This fuction is a wraping fuction of the halo functions for CPU. It is called from another wraping function to keep things clean. In a sense this is the third (and last) layer of wrapping </para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="12" column="18" bodyfile="src/Halo.cu" bodystart="12" bodyend="24"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a6e2403c1c105317070a7ac8516c5621f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloD&lt; double &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; double &gt; XBlock, double *z)</argsstring>
        <name>fillHaloD&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="25" column="10" declfile="src/Halo.cu" declline="25" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a8c6debda6b888b35798dcaaf5ec95d3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloD&lt; float &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; float &gt; XBlock, float *z)</argsstring>
        <name>fillHaloD&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="26" column="10" declfile="src/Halo.cu" declline="26" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ab0197d939bcfd09fdc7c5807453d9dfc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloC</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>fillHaloC</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating halos for each block of a single variable on CPU. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8h_1autotoc_md1">
<title>Description</title>
<para>This function is a wraping fuction of the halo functions on CPU. It is called from the main Halo CPU function. This is layer 2 of 3 wrap so the candy doesn&apos;t stick too much. </para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="36" column="18" bodyfile="src/Halo.cu" bodystart="36" bodyend="44"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a62c3c8912f171794c2aedd471025e4c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloC&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z)</argsstring>
        <name>fillHaloC&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="45" column="10" declfile="src/Halo.cu" declline="45" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a8940bc0632378da915f25ee31de2ed0b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloC&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z)</argsstring>
        <name>fillHaloC&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="46" column="10" declfile="src/Halo.cu" declline="46" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af0f36c2211a044c4891c7fafc9d1b02f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void RecalculateZs</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T *zb)</argsstring>
        <name>RecalculateZs</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>Recalculate water surface after recalculating the values on the halo on the CPU. </para>
        </briefdescription>
        <detaileddescription>
<para>Recalculate water surface after recalculating the values on the halo on the GPU.</para>
<sect2 id="Halo_8h_1autotoc_md2">
<title>Description</title>
<para>Recalculate water surface after recalculating the values on the halo on the CPU. zb (bottom elevation) on each halo is calculated at the start of the loop or as part of the initial condition. When conserve-elevation is not required, only h is recalculated on the halo at ever 1/2 steps. <linebreak/>
 zs then needs to be recalculated to obtain a mass-conservative solution (if zs is conserved then mass conservation is not garanteed)</para>
</sect2>
<sect2 id="Halo_8h_1autotoc_md3">
<title>Warning</title>
<para>This function calculate zs everywhere in the block... this is a bit unecessary. Instead it should recalculate only where there is a prolongation or a restiction</para>
</sect2>
<sect2 id="Halo_8h_1autotoc_md4">
<title>Description</title>
<para>Recalculate water surface after recalculating the values on the halo on the CPU. zb (bottom elevation) on each halo is calculated at the start of the loop or as part of the initial condition. When conserve-elevation is not required, only h is recalculated on the halo at ever 1/2 steps. zs then needs to be recalculated to obtain a mass-conservative solution (if zs is conserved then mass conservation is not garanteed)</para>
</sect2>
<sect2 id="Halo_8h_1autotoc_md5">
<title>Warning</title>
<para>This function calculate zs everywhere in the block... this is a bit unecessary. Instead it should recalculate only where there is a prolongation or a restiction </para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="59" column="18" bodyfile="src/Halo.cu" bodystart="59" bodyend="94"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a4a179168b1b6ca6d431895fa50ddbc5e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void RecalculateZs&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float *zb)</argsstring>
        <name>RecalculateZs&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="95" column="10" declfile="src/Halo.cu" declline="95" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a4346cbc367125486b54412319cca8521" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void RecalculateZs&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double *zb)</argsstring>
        <name>RecalculateZs&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="96" column="10" declfile="src/Halo.cu" declline="96" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9fd24940e7422244beb1290eee7e01d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void Recalculatehh</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T *zb)</argsstring>
        <name>Recalculatehh</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="98" column="18" bodyfile="src/Halo.cu" bodystart="98" bodyend="134"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a86f7fbcf268c15b06de92d94a86676d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void Recalculatehh&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float *zb)</argsstring>
        <name>Recalculatehh&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="135" column="10" declfile="src/Halo.cu" declline="135" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a57466ad6cd9816401644ed33654265f7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void Recalculatehh&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double *zb)</argsstring>
        <name>Recalculatehh&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="136" column="10" declfile="src/Halo.cu" declline="136" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a5ffb16dded1af0f0b9243601ee29db92" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void RecalculateZsGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T *zb)</argsstring>
        <name>RecalculateZsGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="150" column="29" bodyfile="src/Halo.cu" bodystart="150" bodyend="172"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a1375cf89754b41163abe692f5a52f1aa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void RecalculateZsGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float *zb)</argsstring>
        <name>RecalculateZsGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="173" column="21" declfile="src/Halo.cu" declline="173" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a2530753f4e0a860edcdde8a4600d575e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void RecalculateZsGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double *zb)</argsstring>
        <name>RecalculateZsGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="174" column="21" declfile="src/Halo.cu" declline="174" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a96005943eb8cc55515edf93a438bdc15" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloF</definition>
        <argsstring>(Param XParam, bool doProlongation, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>fillHaloF</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating flux in the halos for a block and a single variable on CPU. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8h_1autotoc_md6">
<title>Depreciated</title>
<para>This function is was never sucessful and will never be used. It is fundamentally flawed because is doesn&apos;t preserve the balance of fluxes on the restiction interface It should be deleted soon </para>
</sect2>
<sect2 id="Halo_8h_1autotoc_md7">
<title>Description</title>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="186" column="18" bodyfile="src/Halo.cu" bodystart="186" bodyend="198"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af14f6761d43141eba363350b5f7ad48d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloF&lt; float &gt;</definition>
        <argsstring>(Param XParam, bool doProlongation, BlockP&lt; float &gt; XBlock, float *z)</argsstring>
        <name>fillHaloF&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="199" column="10" declfile="src/Halo.cu" declline="199" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae033bec7214b1e041fbde2fc784da5ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloF&lt; double &gt;</definition>
        <argsstring>(Param XParam, bool doProlongation, BlockP&lt; double &gt; XBlock, double *z)</argsstring>
        <name>fillHaloF&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="200" column="10" declfile="src/Halo.cu" declline="200" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a2ee84ac3de37b97bf6c4a3919f8a355b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T *z)</argsstring>
        <name>fillHaloGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating halos for each block of a single variable on GPU. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8h_1autotoc_md8">
<title>Description</title>
<para>This function is a wraping fuction of the halo functions on GPU. It is called from the main Halo GPU function. The present imnplementation is naive and slow one that calls the rather complex fillLeft type functions </para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="210" column="18" bodyfile="src/Halo.cu" bodystart="210" bodyend="231"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a805c1dabf839953debffe2799c61cae0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double *z)</argsstring>
        <name>fillHaloGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="232" column="10" declfile="src/Halo.cu" declline="232" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a20176600a52e8881aa78213c15e1ac4b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float *z)</argsstring>
        <name>fillHaloGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="233" column="10" declfile="src/Halo.cu" declline="233" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9685d8f9a22683d2a5a8ab96abb1f735" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>fillHaloGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="235" column="18" bodyfile="src/Halo.cu" bodystart="235" bodyend="256"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a34e004e3fbebc9bb46bb634a202ae6d0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z)</argsstring>
        <name>fillHaloGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="257" column="10" declfile="src/Halo.cu" declline="257" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ac2832633400d205ffe4346bbe730d260" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z)</argsstring>
        <name>fillHaloGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="258" column="10" declfile="src/Halo.cu" declline="258" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a29a79939f743cb813160e5cd771480b9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloGPUnew</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T *z)</argsstring>
        <name>fillHaloGPUnew</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="263" column="18" bodyfile="src/Halo.cu" bodystart="263" bodyend="287"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a824b0c7405c55a3c7add16fb2dbddd7b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPUnew&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double *z)</argsstring>
        <name>fillHaloGPUnew&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="288" column="10" declfile="src/Halo.cu" declline="288" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ad8b7fdfb110e1c442c9c46434ea55a8c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPUnew&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float *z)</argsstring>
        <name>fillHaloGPUnew&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="289" column="10" declfile="src/Halo.cu" declline="289" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae3adb7ce2fbe32053675857784affbe1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloTopRightC</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>fillHaloTopRightC</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Wrapping function for calculating flux for halos for each block of a single variable on GPU. </para>
        </briefdescription>
        <detaileddescription>
<sect2 id="Halo_8h_1autotoc_md9">
<title>Description</title>
<para>This function is a wraping function of the halo flux functions on GPU. It is called from the main Halo GPU function. The present imnplementation is naive and slow one that calls the rather complex fillLeft type functions </para>
</sect2>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="300" column="18" bodyfile="src/Halo.cu" bodystart="300" bodyend="319"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a3c209f200fa3e85dfdf772a4e2904049" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloTopRightC&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z)</argsstring>
        <name>fillHaloTopRightC&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="320" column="10" declfile="src/Halo.cu" declline="320" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ac87d50a1edb09efac22b75440d8a67ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloTopRightC&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z)</argsstring>
        <name>fillHaloTopRightC&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="321" column="10" declfile="src/Halo.cu" declline="321" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae5c54a05d63827832b83be828802753f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloLRFluxC</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>fillHaloLRFluxC</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="323" column="18" bodyfile="src/Halo.cu" bodystart="323" bodyend="342"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ad2c3611f0b1922bbf5f31517f9f6e491" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloLRFluxC&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z)</argsstring>
        <name>fillHaloLRFluxC&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="343" column="10" declfile="src/Halo.cu" declline="343" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ab72d57c0f58a2aba8386523e4c311279" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloLRFluxC&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z)</argsstring>
        <name>fillHaloLRFluxC&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="344" column="10" declfile="src/Halo.cu" declline="344" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a0170ca89e35d08a9bd76139bfdd6ff37" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloBTFluxC</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>fillHaloBTFluxC</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="346" column="18" bodyfile="src/Halo.cu" bodystart="346" bodyend="365"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a5b5769495221a888c7c842adb908b5b9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloBTFluxC&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z)</argsstring>
        <name>fillHaloBTFluxC&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="366" column="10" declfile="src/Halo.cu" declline="366" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1accd66463b0299c74894d64c1bb1b202a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloBTFluxC&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z)</argsstring>
        <name>fillHaloBTFluxC&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="367" column="10" declfile="src/Halo.cu" declline="367" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a1933020a5783e090d0c44fffb283e563" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloTopRightGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T *z)</argsstring>
        <name>fillHaloTopRightGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="371" column="18" bodyfile="src/Halo.cu" bodystart="371" bodyend="388"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a84c9dcd8f96a68563a6ed9f41fddeb9b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloTopRightGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double *z)</argsstring>
        <name>fillHaloTopRightGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="389" column="10" declfile="src/Halo.cu" declline="389" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ac7dd171c00746b296b85d607c2630b32" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloTopRightGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float *z)</argsstring>
        <name>fillHaloTopRightGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="390" column="10" declfile="src/Halo.cu" declline="390" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af347bef69b66f3cc31cfc0e1e61ea971" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloLeftRightGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T *z)</argsstring>
        <name>fillHaloLeftRightGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="392" column="18" bodyfile="src/Halo.cu" bodystart="392" bodyend="409"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af618df69f5fab841b5c52471a217b3ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloLeftRightGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double *z)</argsstring>
        <name>fillHaloLeftRightGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="410" column="10" declfile="src/Halo.cu" declline="410" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ace2d807ee7ac57add88bb337cebaada3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloLeftRightGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float *z)</argsstring>
        <name>fillHaloLeftRightGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="411" column="10" declfile="src/Halo.cu" declline="411" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a6da328def689854bc8f7f54af1d40dcb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloLeftRightGPUnew</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T *z)</argsstring>
        <name>fillHaloLeftRightGPUnew</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="413" column="18" bodyfile="src/Halo.cu" bodystart="413" bodyend="424"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9c68f2c332f01be941bbc9e6dd04e5e5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloLeftRightGPUnew&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double *z)</argsstring>
        <name>fillHaloLeftRightGPUnew&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="425" column="10" declfile="src/Halo.cu" declline="425" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ab1b44678d54793b59734f97b88c2a623" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloLeftRightGPUnew&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float *z)</argsstring>
        <name>fillHaloLeftRightGPUnew&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="426" column="10" declfile="src/Halo.cu" declline="426" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a645550ebdc0b4a03a0d47e31e0814d31" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloBotTopGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T *z)</argsstring>
        <name>fillHaloBotTopGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="428" column="18" bodyfile="src/Halo.cu" bodystart="428" bodyend="445"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ad922091a4b843c143f4897d9446fe846" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloBotTopGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double *z)</argsstring>
        <name>fillHaloBotTopGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="446" column="10" declfile="src/Halo.cu" declline="446" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a718dfed8a35b43d0e476d15fa60cf99e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloBotTopGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float *z)</argsstring>
        <name>fillHaloBotTopGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="447" column="10" declfile="src/Halo.cu" declline="447" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a243e3434cdc9990c9911ee1c00052348" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloBotTopGPUnew</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T *z)</argsstring>
        <name>fillHaloBotTopGPUnew</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="449" column="18" bodyfile="src/Halo.cu" bodystart="449" bodyend="460"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9ed5180f00aa1fc13391a3618e6caba9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloBotTopGPUnew&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double *z)</argsstring>
        <name>fillHaloBotTopGPUnew&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="461" column="10" declfile="src/Halo.cu" declline="461" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a7a80e2f0e348af6c37f5550554eb1fec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloBotTopGPUnew&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float *z)</argsstring>
        <name>fillHaloBotTopGPUnew&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="462" column="10" declfile="src/Halo.cu" declline="462" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a4a31e12451e1336defc379f47d6aab9e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHalo</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T *zb)</argsstring>
        <name>fillHalo</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="465" column="18" bodyfile="src/Halo.cu" bodystart="465" bodyend="495"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1afa4cf32960744be7d6afbd861b4af55e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHalo&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float *zb)</argsstring>
        <name>fillHalo&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="496" column="10" declfile="src/Halo.cu" declline="496" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a3631ffea6e7d5766b04de6082182813e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHalo&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double *zb)</argsstring>
        <name>fillHalo&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="497" column="10" declfile="src/Halo.cu" declline="497" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a571ac7ff2cf8b31f5d026b7e909e5271" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHalo</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev)</argsstring>
        <name>fillHalo</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="499" column="18" bodyfile="src/Halo.cu" bodystart="499" bodyend="515"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aa8f68738d43b4ea348c964349d07fd21" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHalo&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev)</argsstring>
        <name>fillHalo&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="516" column="10" declfile="src/Halo.cu" declline="516" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a22fa619b12cb821e01c0611bf0774f70" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHalo&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev)</argsstring>
        <name>fillHalo&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="517" column="10" declfile="src/Halo.cu" declline="517" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a2a355feb696605ad555fe018395bcac2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev)</argsstring>
        <name>fillHaloGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="520" column="18" bodyfile="src/Halo.cu" bodystart="520" bodyend="541"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9b8d1661f255b3e8e41a8ec6a2a98260" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev)</argsstring>
        <name>fillHaloGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="542" column="10" declfile="src/Halo.cu" declline="542" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a87f6da23bb80f5c2a138bad34e576e5b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev)</argsstring>
        <name>fillHaloGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="543" column="10" declfile="src/Halo.cu" declline="543" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a8bcac8c7fda9dd6edcfb34f40543ceef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T *zb)</argsstring>
        <name>fillHaloGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="545" column="18" bodyfile="src/Halo.cu" bodystart="545" bodyend="596"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae9d035a7e3954d9b2801a74cf2ba87f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float *zb)</argsstring>
        <name>fillHaloGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="597" column="10" declfile="src/Halo.cu" declline="597" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ac253f2bf76324a678d0f34a9a9b1c631" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double *zb)</argsstring>
        <name>fillHaloGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="598" column="10" declfile="src/Halo.cu" declline="598" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a335ca91325da154b12cc3f3ee6dabba3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHalo</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, GradientsP&lt; T &gt; Grad)</argsstring>
        <name>fillHalo</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structGradientsP" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>Grad</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="600" column="18" bodyfile="src/Halo.cu" bodystart="600" bodyend="635"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a1537aa80051775c77097a9bb3b82725c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHalo&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, GradientsP&lt; float &gt; Grad)</argsstring>
        <name>fillHalo&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structGradientsP" kindref="compound">GradientsP</ref>&lt; float &gt;</type>
          <declname>Grad</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="636" column="10" declfile="src/Halo.cu" declline="636" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a0884370506c63c157bcca090e1dc9034" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHalo&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, GradientsP&lt; double &gt; Grad)</argsstring>
        <name>fillHalo&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structGradientsP" kindref="compound">GradientsP</ref>&lt; double &gt;</type>
          <declname>Grad</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="637" column="10" declfile="src/Halo.cu" declline="637" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a8d8f335f2691b865597b01f0e6c2e210" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, GradientsP&lt; T &gt; Grad)</argsstring>
        <name>fillHaloGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structGradientsP" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>Grad</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="639" column="18" bodyfile="src/Halo.cu" bodystart="639" bodyend="665"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a18a815a1959a39e7ab80e94b759a15f7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, GradientsP&lt; float &gt; Grad)</argsstring>
        <name>fillHaloGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structGradientsP" kindref="compound">GradientsP</ref>&lt; float &gt;</type>
          <declname>Grad</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="666" column="10" declfile="src/Halo.cu" declline="666" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a0c4feec6db1f401b3409302c41843524" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, GradientsP&lt; double &gt; Grad)</argsstring>
        <name>fillHaloGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structGradientsP" kindref="compound">GradientsP</ref>&lt; double &gt;</type>
          <declname>Grad</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="667" column="10" declfile="src/Halo.cu" declline="667" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a657a661d3469befc6894213c9512fb3d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHalo</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux)</argsstring>
        <name>fillHalo</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; T &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="670" column="18" bodyfile="src/Halo.cu" bodystart="670" bodyend="705"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aa43f5a8602659f6210dd902089ccf013" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHalo&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, FluxP&lt; float &gt; Flux)</argsstring>
        <name>fillHalo&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; float &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="706" column="10" declfile="src/Halo.cu" declline="706" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a950a805927a040a251910383f8a0917c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHalo&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, FluxP&lt; double &gt; Flux)</argsstring>
        <name>fillHalo&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; double &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="707" column="10" declfile="src/Halo.cu" declline="707" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a3f01819995937c8bbce5ac05c18f71b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillHaloGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux)</argsstring>
        <name>fillHaloGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; T &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="709" column="18" bodyfile="src/Halo.cu" bodystart="709" bodyend="759"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1acac7f5cbebdc9598fe00696f6708068f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, FluxP&lt; float &gt; Flux)</argsstring>
        <name>fillHaloGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; float &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="760" column="10" declfile="src/Halo.cu" declline="760" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae4dfd3f7c7752f689ea4aa1cd17b378c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillHaloGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, FluxP&lt; double &gt; Flux)</argsstring>
        <name>fillHaloGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; double &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="761" column="10" declfile="src/Halo.cu" declline="761" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ad8656ca08616abdeb043f622de7243fd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void bndmaskGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, FluxP&lt; T &gt; Flux)</argsstring>
        <name>bndmaskGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; T &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="763" column="18" bodyfile="src/Halo.cu" bodystart="763" bodyend="792"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a1a2c2fe28c070ea593b6f0fb06cda5eb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void bndmaskGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, FluxP&lt; float &gt; Flux)</argsstring>
        <name>bndmaskGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; float &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="793" column="10" declfile="src/Halo.cu" declline="793" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a8effb78a3ef81c8e53f925af0e1beeec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void bndmaskGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, FluxP&lt; double &gt; Flux)</argsstring>
        <name>bndmaskGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>Xev</declname>
        </param>
        <param>
          <type><ref refid="structFluxP" kindref="compound">FluxP</ref>&lt; double &gt;</type>
          <declname>Flux</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="794" column="10" declfile="src/Halo.cu" declline="794" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a660ab474d664c8622e1f0768eef59342" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void refine_linear_Left</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear_Left</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="835" column="18" bodyfile="src/Halo.cu" bodystart="835" bodyend="857"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a4e7dbd71c089a0e3dc219c1eb5d9d13e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear_Left&lt; float &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear_Left&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="858" column="10" declfile="src/Halo.cu" declline="858" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aaa405d4b273e7eba82cccef28661a4cf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear_Left&lt; double &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear_Left&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="859" column="10" declfile="src/Halo.cu" declline="859" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a0dfd1652d58d54f5d3fd66d6d30ed2dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void refine_linear_LeftGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear_LeftGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="861" column="29" bodyfile="src/Halo.cu" bodystart="861" bodyend="893"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae21004698b731ba1e88d8199e1bf5839" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void refine_linear_LeftGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear_LeftGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="894" column="21" declfile="src/Halo.cu" declline="894" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a387ff243908f0957e13f8f5eb4e6c4ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void refine_linear_LeftGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear_LeftGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="895" column="21" declfile="src/Halo.cu" declline="895" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a41de2d4fe883bf1e375fd44877584b14" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void refine_linear_Right</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear_Right</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="898" column="18" bodyfile="src/Halo.cu" bodystart="898" bodyend="920"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a1fa1834cc4aa84cb7738a0adc45a4dc2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear_Right&lt; float &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear_Right&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="921" column="10" declfile="src/Halo.cu" declline="921" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a80b97b76fe856b41292e4700327b4829" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear_Right&lt; double &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear_Right&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="922" column="10" declfile="src/Halo.cu" declline="922" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a66adad329d72cd96c0a4fc0fefd62cfe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void refine_linear_RightGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear_RightGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="924" column="29" bodyfile="src/Halo.cu" bodystart="924" bodyend="955"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1abf05d4e326bc8001570eb7c0e2078780" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void refine_linear_RightGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear_RightGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="956" column="21" declfile="src/Halo.cu" declline="956" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a7ba5681c7d996dca7b951aba4dd80aa9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void refine_linear_RightGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear_RightGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="957" column="21" declfile="src/Halo.cu" declline="957" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a86539114f4682e0cfd5ae397978c569a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void refine_linear_Bot</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear_Bot</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="959" column="18" bodyfile="src/Halo.cu" bodystart="959" bodyend="982"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a7a09d610716c25c2c4cb45dde7ffdd53" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear_Bot&lt; float &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear_Bot&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="983" column="10" declfile="src/Halo.cu" declline="983" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a5895d32dd2bfb9aa26fb9653a767882a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear_Bot&lt; double &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear_Bot&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="984" column="10" declfile="src/Halo.cu" declline="984" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a5748f4fb9632d8308fa235004d5f6b12" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void refine_linear_BotGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear_BotGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="987" column="29" bodyfile="src/Halo.cu" bodystart="987" bodyend="1016"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ace3bee45c02ffdf7c1848ee910bf97be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void refine_linear_BotGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear_BotGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1017" column="21" declfile="src/Halo.cu" declline="1017" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a179fecb6df5a3276383654db31c3b213" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void refine_linear_BotGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear_BotGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1018" column="21" declfile="src/Halo.cu" declline="1018" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a7b4fb01de4f8fdd9daafc221db1a959f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void refine_linear_Top</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear_Top</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1020" column="18" bodyfile="src/Halo.cu" bodystart="1020" bodyend="1043"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1afc2a5bb2abceee1a853c771cefbf5a2b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear_Top&lt; float &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear_Top&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1044" column="10" declfile="src/Halo.cu" declline="1044" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ab1f2fb4f0d584a9b42bcfbd80c018cf8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear_Top&lt; double &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear_Top&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1045" column="10" declfile="src/Halo.cu" declline="1045" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a525a7162ec9037c8b16cf7417f3926b2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void refine_linear_TopGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear_TopGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1047" column="29" bodyfile="src/Halo.cu" bodystart="1047" bodyend="1075"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9ad60860791cc1d9816671a7daf3f9ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void refine_linear_TopGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear_TopGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1076" column="21" declfile="src/Halo.cu" declline="1076" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae915fa866b3f0fe4136aadc5dbd58135" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void refine_linear_TopGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear_TopGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1077" column="21" declfile="src/Halo.cu" declline="1077" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aa3159218d597d5dec3caa8686a223081" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void refine_linear</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linear</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1079" column="18" bodyfile="src/Halo.cu" bodystart="1079" bodyend="1089"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a535cb1b12608ac724cc113d84302cc7e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linear&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1090" column="10" declfile="src/Halo.cu" declline="1090" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aff8eecab036938a6f0516958e7a6666e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linear&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linear&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1091" column="10" declfile="src/Halo.cu" declline="1091" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a090d7ddeba077e9ef3b06ec9e4f8851a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void refine_linearGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z, T *dzdx, T *dzdy)</argsstring>
        <name>refine_linearGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1093" column="18" bodyfile="src/Halo.cu" bodystart="1093" bodyend="1105"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aba3b8bc4676eb67b3ba5af23fd082a03" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linearGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z, float *dzdx, float *dzdy)</argsstring>
        <name>refine_linearGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1106" column="10" declfile="src/Halo.cu" declline="1106" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a2dbaeb9cbd6aba5e1a875ff4f81befb0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void refine_linearGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z, double *dzdx, double *dzdy)</argsstring>
        <name>refine_linearGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dzdy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1107" column="10" declfile="src/Halo.cu" declline="1107" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9127f7d09d9a110da1cb7fae1786c389" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void HaloFluxCPULR</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>HaloFluxCPULR</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1110" column="18" bodyfile="src/Halo.cu" bodystart="1110" bodyend="1198"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a82e672706036bc5b4e87cd2b739f9609" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void HaloFluxGPULR</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>HaloFluxGPULR</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1200" column="30" bodyfile="src/Halo.cu" bodystart="1200" bodyend="1302"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9178199ff5e46ef9a5fee4241b8e235e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void HaloFluxGPULRnew</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>HaloFluxGPULRnew</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1304" column="30" bodyfile="src/Halo.cu" bodystart="1304" bodyend="1410"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a5497979187df8771242d5c3d66922615" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void HaloFluxCPUBT</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>HaloFluxCPUBT</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1412" column="18" bodyfile="src/Halo.cu" bodystart="1412" bodyend="1500"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a0c0b81d1c956a11c4025491946f90010" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void HaloFluxGPUBT</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>HaloFluxGPUBT</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1502" column="29" bodyfile="src/Halo.cu" bodystart="1502" bodyend="1599"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a5ddd71e988ae7200bfd409d5d9d81921" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void HaloFluxGPUBTnew</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>HaloFluxGPUBTnew</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1601" column="29" bodyfile="src/Halo.cu" bodystart="1601" bodyend="1704"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ad7bdbf10e6e7309983c7143644f18268" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillLeft</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillLeft</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1708" column="18" bodyfile="src/Halo.cu" bodystart="1708" bodyend="1911"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af1855d1f517b150637f7ebba2b7c98d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillLeft</definition>
        <argsstring>(int halowidth, int *active, int *level, int *leftbot, int *lefttop, int *rightbot, int *botright, int *topright, T *a)</argsstring>
        <name>fillLeft</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="1915" column="29" bodyfile="src/Halo.cu" bodystart="1915" bodyend="2083"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a3b14beb454331728755e5f8a6f251e13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillLeft&lt; float &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, int *leftbot, int *lefttop, int *rightbot, int *botright, int *topright, float *a)</argsstring>
        <name>fillLeft&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2084" column="21" declfile="src/Halo.cu" declline="2084" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aedd2d63dd1706ae7d29be62692da6f38" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillLeft&lt; double &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, int *leftbot, int *lefttop, int *rightbot, int *botright, int *topright, double *a)</argsstring>
        <name>fillLeft&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2085" column="21" declfile="src/Halo.cu" declline="2085" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aeca99a935bccb5897113cf8f57dcc877" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillLeftnew</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *leftbot, int *lefttop, int *rightbot, int *botright, int *topright, T *a)</argsstring>
        <name>fillLeftnew</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2095" column="29" bodyfile="src/Halo.cu" bodystart="2095" bodyend="2269"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a98fac6187460306e6a2d90611cf5f7b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillLeftnew&lt; float &gt;</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *leftbot, int *lefttop, int *rightbot, int *botright, int *topright, float *a)</argsstring>
        <name>fillLeftnew&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2270" column="21" declfile="src/Halo.cu" declline="2270" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae6479ede9a0c3e1cfacc2e53355ebccb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillLeftnew&lt; double &gt;</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *leftbot, int *lefttop, int *rightbot, int *botright, int *topright, double *a)</argsstring>
        <name>fillLeftnew&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2271" column="21" declfile="src/Halo.cu" declline="2271" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a5d9d65fbd4acba2dc766568a77bfaffd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillLeftFlux</definition>
        <argsstring>(Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillLeftFlux</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2274" column="18" bodyfile="src/Halo.cu" bodystart="2274" bodyend="2404"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a2345005d54233720f2cae1e1b443a36f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillRight</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillRight</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2408" column="18" bodyfile="src/Halo.cu" bodystart="2408" bodyend="2610"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af71504ac800a61627ac5cef75d003bfd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillRight</definition>
        <argsstring>(int halowidth, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, T *a)</argsstring>
        <name>fillRight</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2614" column="29" bodyfile="src/Halo.cu" bodystart="2614" bodyend="2784"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a72e57bc7f4ba67769042bff28273c9e7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillRight&lt; float &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, float *a)</argsstring>
        <name>fillRight&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2786" column="21" declfile="src/Halo.cu" declline="2786" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a1ded4426a80fbcf290981dc537f320d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillRight&lt; double &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, double *a)</argsstring>
        <name>fillRight&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2787" column="21" declfile="src/Halo.cu" declline="2787" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ab2b0d44b1bb0c826f764f7b84b8bed23" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillRightnew</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, T *a)</argsstring>
        <name>fillRightnew</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2789" column="29" bodyfile="src/Halo.cu" bodystart="2789" bodyend="2962"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a81fe82b12b6eecfaab656454daa1c2d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillRightnew&lt; float &gt;</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, float *a)</argsstring>
        <name>fillRightnew&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2964" column="21" declfile="src/Halo.cu" declline="2964" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ab5a4a9f0e151d12e559ac3581e855908" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillRightnew&lt; double &gt;</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, double *a)</argsstring>
        <name>fillRightnew&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2965" column="21" declfile="src/Halo.cu" declline="2965" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a2f03036ffa47f139c5eba848de62ce1a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillRightFlux</definition>
        <argsstring>(Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillRightFlux</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="2969" column="18" bodyfile="src/Halo.cu" bodystart="2969" bodyend="3094"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a1f1c910e13ec59b239e54f5b9974785b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillRightFlux&lt; float &gt;</definition>
        <argsstring>(Param XParam, bool doProlongation, int ib, BlockP&lt; float &gt; XBlock, float *&amp;z)</argsstring>
        <name>fillRightFlux&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3096" column="10" declfile="src/Halo.cu" declline="3096" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a04f5e436751e34f565037dc24a22a155" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillRightFlux&lt; double &gt;</definition>
        <argsstring>(Param XParam, bool doProlongation, int ib, BlockP&lt; double &gt; XBlock, double *&amp;z)</argsstring>
        <name>fillRightFlux&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3097" column="10" declfile="src/Halo.cu" declline="3097" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1afaa07f3e06bd6f302d97aa9954188afb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillRightFlux</definition>
        <argsstring>(int halowidth, bool doProlongation, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, T *a)</argsstring>
        <name>fillRightFlux</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3101" column="29" bodyfile="src/Halo.cu" bodystart="3101" bodyend="3212"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a56941d739afb1ee3215e82cd06678e96" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillRightFlux&lt; float &gt;</definition>
        <argsstring>(int halowidth, bool doProlongation, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, float *a)</argsstring>
        <name>fillRightFlux&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3213" column="21" declfile="src/Halo.cu" declline="3213" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a87e192a85f48bf6a5706ac9fde71b3e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillRightFlux&lt; double &gt;</definition>
        <argsstring>(int halowidth, bool doProlongation, int *active, int *level, int *rightbot, int *righttop, int *leftbot, int *botleft, int *topleft, double *a)</argsstring>
        <name>fillRightFlux&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3214" column="21" declfile="src/Halo.cu" declline="3214" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a671352fcb2eaaa2d4207ff07c9e8f852" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillBot</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillBot</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3218" column="18" bodyfile="src/Halo.cu" bodystart="3218" bodyend="3418"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af9678ea06bf2f69ed3152b64f8deffca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillBot</definition>
        <argsstring>(int halowidth, int *active, int *level, int *botleft, int *botright, int *topleft, int *lefttop, int *righttop, T *a)</argsstring>
        <name>fillBot</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3421" column="29" bodyfile="src/Halo.cu" bodystart="3421" bodyend="3582"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a7020b0ebbbedc2f4dcb4f34e1007273f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillBot&lt; float &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, int *botleft, int *botright, int *topleft, int *lefttop, int *righttop, float *a)</argsstring>
        <name>fillBot&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3583" column="21" declfile="src/Halo.cu" declline="3583" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a55031de0d78e78dfc24cef8c29bc7017" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillBot&lt; double &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, int *botleft, int *botright, int *topleft, int *lefttop, int *righttop, double *a)</argsstring>
        <name>fillBot&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3584" column="21" declfile="src/Halo.cu" declline="3584" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a2fc4bb8d813f6515dea868a5d2d36f68" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillBotnew</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *botleft, int *botright, int *topleft, int *lefttop, int *righttop, T *a)</argsstring>
        <name>fillBotnew</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3586" column="29" bodyfile="src/Halo.cu" bodystart="3586" bodyend="3749"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1acb3d52e6ce9ff6c556e2d0743ea6844f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillBotnew&lt; float &gt;</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *botleft, int *botright, int *topleft, int *lefttop, int *righttop, float *a)</argsstring>
        <name>fillBotnew&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3750" column="21" declfile="src/Halo.cu" declline="3750" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a701b145ee386048b5066d978de26a8a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillBotnew&lt; double &gt;</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *botleft, int *botright, int *topleft, int *lefttop, int *righttop, double *a)</argsstring>
        <name>fillBotnew&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>lefttop</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>righttop</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3751" column="21" declfile="src/Halo.cu" declline="3751" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ada9520990635cb340db8cf913cc6e356" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillBotFlux</definition>
        <argsstring>(Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillBotFlux</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3753" column="18" bodyfile="src/Halo.cu" bodystart="3753" bodyend="3881"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aefe78bd2478a704e63205de5fee4f5ac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillTop</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillTop</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="3883" column="18" bodyfile="src/Halo.cu" bodystart="3883" bodyend="4083"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a77acf80e6591f424cb6b99331eb3764a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillTop</definition>
        <argsstring>(int halowidth, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, T *a)</argsstring>
        <name>fillTop</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4085" column="29" bodyfile="src/Halo.cu" bodystart="4085" bodyend="4247"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ab3744247f8d4622ba1f0e52a738148f7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillTop&lt; float &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, float *a)</argsstring>
        <name>fillTop&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4249" column="21" declfile="src/Halo.cu" declline="4249" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a89b6a37e2b440932b8c4beea68e0a13a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillTop&lt; double &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, double *a)</argsstring>
        <name>fillTop&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4250" column="21" declfile="src/Halo.cu" declline="4250" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a67e1c95744d12c9baf5767e34767d4d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillTopnew</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, T *a)</argsstring>
        <name>fillTopnew</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4252" column="29" bodyfile="src/Halo.cu" bodystart="4252" bodyend="4417"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a65828cacc2417f824d4e96d696749531" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillTopnew&lt; float &gt;</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, float *a)</argsstring>
        <name>fillTopnew&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4419" column="21" declfile="src/Halo.cu" declline="4419" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a5fa720fa5a16910d38c34480f2f1b72b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillTopnew&lt; double &gt;</definition>
        <argsstring>(int halowidth, int nblk, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, double *a)</argsstring>
        <name>fillTopnew&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nblk</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4420" column="21" declfile="src/Halo.cu" declline="4420" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9af9c1a41440ff037441b0cea28bcbaf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillTopFlux</definition>
        <argsstring>(Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillTopFlux</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4423" column="18" bodyfile="src/Halo.cu" bodystart="4423" bodyend="4547"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af00c6ce01842ac1e06289207021a7793" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillTopFlux&lt; float &gt;</definition>
        <argsstring>(Param XParam, bool doProlongation, int ib, BlockP&lt; float &gt; XBlock, float *&amp;z)</argsstring>
        <name>fillTopFlux&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4548" column="10" declfile="src/Halo.cu" declline="4548" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a7d2e054c42e7de0e660d4eb7d42171ad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillTopFlux&lt; double &gt;</definition>
        <argsstring>(Param XParam, bool doProlongation, int ib, BlockP&lt; double &gt; XBlock, double *&amp;z)</argsstring>
        <name>fillTopFlux&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4549" column="10" declfile="src/Halo.cu" declline="4549" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aaeae9c3ca26a884c76d4d429c60dead6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillTopFlux</definition>
        <argsstring>(int halowidth, bool doProlongation, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, T *a)</argsstring>
        <name>fillTopFlux</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4551" column="29" bodyfile="src/Halo.cu" bodystart="4551" bodyend="4652"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a266e09515f6b6f7f560ccc120e806957" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillTopFlux&lt; float &gt;</definition>
        <argsstring>(int halowidth, bool doProlongation, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, float *a)</argsstring>
        <name>fillTopFlux&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4654" column="21" declfile="src/Halo.cu" declline="4654" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a6f91cf2e90ac2d1db440820c5ba5518c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillTopFlux&lt; double &gt;</definition>
        <argsstring>(int halowidth, bool doProlongation, int *active, int *level, int *topleft, int *topright, int *botleft, int *leftbot, int *rightbot, double *a)</argsstring>
        <name>fillTopFlux&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>doProlongation</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>topright</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>botleft</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>leftbot</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>rightbot</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4655" column="21" declfile="src/Halo.cu" declline="4655" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a1797b1932cfb1952397c7618a84da179" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillCorners</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillCorners</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4659" column="18" bodyfile="src/Halo.cu" bodystart="4659" bodyend="4670"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a0da557498682b82b0ffcc76249624dca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillCorners&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *&amp;z)</argsstring>
        <name>fillCorners&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4671" column="10" declfile="src/Halo.cu" declline="4671" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a66442f2a4308a4f7973c13eadfd0ccd4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillCorners&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *&amp;z)</argsstring>
        <name>fillCorners&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4672" column="10" declfile="src/Halo.cu" declline="4672" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1ae6a37fef4c306b5218742df8872f03dc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillCorners</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; &amp;Xev)</argsstring>
        <name>fillCorners</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; T &gt; &amp;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4675" column="18" bodyfile="src/Halo.cu" bodystart="4675" bodyend="4688"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1acf6d62f01f062c58a9c0133a3e931b28" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillCorners&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; &amp;Xev)</argsstring>
        <name>fillCorners&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; float &gt; &amp;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4689" column="10" declfile="src/Halo.cu" declline="4689" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aa2d6ea0e98dca434a8fe613239142688" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillCorners&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; &amp;Xev)</argsstring>
        <name>fillCorners&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="structEvolvingP" kindref="compound">EvolvingP</ref>&lt; double &gt; &amp;</type>
          <declname>Xev</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4690" column="10" declfile="src/Halo.cu" declline="4690" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1aad3c5276e55ffe7f76f312de463a6353" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void fillCorners</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp;z)</argsstring>
        <name>fillCorners</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4694" column="18" bodyfile="src/Halo.cu" bodystart="4694" bodyend="4825"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1af52340141ab4f4e3f665ec44134720b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillCorners&lt; float &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; float &gt; XBlock, float *&amp;z)</argsstring>
        <name>fillCorners&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4826" column="10" declfile="src/Halo.cu" declline="4826" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a3b201dc5498462f5fc345114b3633541" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void fillCorners&lt; double &gt;</definition>
        <argsstring>(Param XParam, int ib, BlockP&lt; double &gt; XBlock, double *&amp;z)</argsstring>
        <name>fillCorners&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *&amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4827" column="10" declfile="src/Halo.cu" declline="4827" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a9ba5024f1ba2013889f0dd2eee8e9f94" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void fillCornersGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *z)</argsstring>
        <name>fillCornersGPU</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4830" column="29" bodyfile="src/Halo.cu" bodystart="4830" bodyend="4952"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a43113d49e13054ec5dc2b528e4d8f5b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillCornersGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *z)</argsstring>
        <name>fillCornersGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4953" column="21" declfile="src/Halo.cu" declline="4953" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="Halo_8cu_1a75017ac658d5b68f331f20d00d591023" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void fillCornersGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *z)</argsstring>
        <name>fillCornersGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="classParam" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="structBlockP" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Halo.cu" line="4954" column="21" declfile="src/Halo.cu" declline="4954" declcolumn="21"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="preprocessor">#include<sp/>&quot;Halo.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloD(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="13"><highlight class="normal">{</highlight></codeline>
<codeline lineno="14"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"><sp/><sp/><sp/><sp/>fillLeft(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="17"><highlight class="normal"><sp/><sp/><sp/><sp/>fillRight(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="18"><highlight class="normal"><sp/><sp/><sp/><sp/>fillTop(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="19"><highlight class="normal"><sp/><sp/><sp/><sp/>fillBot(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="20"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fill<sp/>bot</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fill<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="23"><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal">}</highlight></codeline>
<codeline lineno="25"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloD&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="26"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloD&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="27"><highlight class="normal"></highlight></codeline>
<codeline lineno="36"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloC(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="37"><highlight class="normal">{</highlight></codeline>
<codeline lineno="38"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib;</highlight></codeline>
<codeline lineno="39"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="40"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="41"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="42"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillHaloD(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="43"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="44"><highlight class="normal">}</highlight></codeline>
<codeline lineno="45"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloC&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="46"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloC&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="47"><highlight class="normal"></highlight></codeline>
<codeline lineno="59"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RecalculateZs(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>Xev,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="60"><highlight class="normal">{</highlight></codeline>
<codeline lineno="61"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/>n;</highlight></codeline>
<codeline lineno="62"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="66"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//We<sp/>only<sp/>need<sp/>to<sp/>recalculate<sp/>zs<sp/>on<sp/>the<sp/>halo<sp/>side<sp/></highlight></codeline>
<codeline lineno="67"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>n<sp/>=<sp/>-1;<sp/>n<sp/>&lt;=<sp/>(XParam.blkwidth);<sp/>n++)</highlight></codeline>
<codeline lineno="68"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="69"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>left<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>-1,<sp/>n,<sp/>ib);</highlight></codeline>
<codeline lineno="70"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>right<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>XParam.blkwidth,<sp/>n,<sp/>ib);</highlight></codeline>
<codeline lineno="71"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>top<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>n,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="72"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bot<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>n,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="73"><highlight class="comment"></highlight></codeline>
<codeline lineno="74"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.zs[left]<sp/>=<sp/>zb[left]<sp/>+<sp/>Xev.h[left];</highlight></codeline>
<codeline lineno="75"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.zs[right]<sp/>=<sp/>zb[right]<sp/>+<sp/>Xev.h[right];</highlight></codeline>
<codeline lineno="76"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.zs[top]<sp/>=<sp/>zb[top]<sp/>+<sp/>Xev.h[top];</highlight></codeline>
<codeline lineno="77"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.zs[bot]<sp/>=<sp/>zb[bot]<sp/>+<sp/>Xev.h[bot];</highlight></codeline>
<codeline lineno="78"><highlight class="comment"></highlight></codeline>
<codeline lineno="79"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//printf(&quot;n=%d;<sp/>zsold=%f;<sp/>zsnew=%f<sp/>(zb=%f<sp/>+<sp/>h=%f)\n&quot;,n,<sp/>Xev.zs[n],<sp/>zb[n]<sp/>+<sp/>Xev.h[n],<sp/>zb[n]<sp/>,<sp/>Xev.h[n]);</highlight></codeline>
<codeline lineno="80"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="81"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="82"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Recalculate<sp/>zs<sp/>everywhere<sp/>maybe<sp/>we<sp/>only<sp/>need<sp/>to<sp/>do<sp/>that<sp/>on<sp/>the<sp/>halo<sp/>?</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="84"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>-1;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth+1);<sp/>j++)</highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>-1;<sp/>i<sp/>&lt;<sp/>(XParam.blkwidth+1);<sp/>i++)</highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>memloc(XParam.halowidth,XParam.blkmemwidth,<sp/>i,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.zs[n]<sp/>=<sp/>zb[n]<sp/>+<sp/>Xev.h[n];</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="94"><highlight class="normal">}</highlight></codeline>
<codeline lineno="95"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RecalculateZs&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>Xev,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>zb);</highlight></codeline>
<codeline lineno="96"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RecalculateZs&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>Xev,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>zb);</highlight></codeline>
<codeline lineno="97"><highlight class="normal"></highlight></codeline>
<codeline lineno="98"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Recalculatehh(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>Xev,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="99"><highlight class="normal">{</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/>n;</highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="105"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//We<sp/>only<sp/>need<sp/>to<sp/>recalculate<sp/>zs<sp/>on<sp/>the<sp/>halo<sp/>side</highlight></codeline>
<codeline lineno="106"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>n<sp/>=<sp/>-1;<sp/>n<sp/>&lt;=<sp/>(XParam.blkwidth);<sp/>n++)</highlight></codeline>
<codeline lineno="107"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="108"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>left<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>-1,<sp/>n,<sp/>ib);</highlight></codeline>
<codeline lineno="109"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>right<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>XParam.blkwidth,<sp/>n,<sp/>ib);</highlight></codeline>
<codeline lineno="110"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>top<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>n,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="111"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bot<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>n,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="112"><highlight class="comment"></highlight></codeline>
<codeline lineno="113"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.zs[left]<sp/>=<sp/>zb[left]<sp/>+<sp/>Xev.h[left];</highlight></codeline>
<codeline lineno="114"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.zs[right]<sp/>=<sp/>zb[right]<sp/>+<sp/>Xev.h[right];</highlight></codeline>
<codeline lineno="115"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.zs[top]<sp/>=<sp/>zb[top]<sp/>+<sp/>Xev.h[top];</highlight></codeline>
<codeline lineno="116"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.zs[bot]<sp/>=<sp/>zb[bot]<sp/>+<sp/>Xev.h[bot];</highlight></codeline>
<codeline lineno="117"><highlight class="comment"></highlight></codeline>
<codeline lineno="118"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//printf(&quot;n=%d;<sp/>zsold=%f;<sp/>zsnew=%f<sp/>(zb=%f<sp/>+<sp/>h=%f)\n&quot;,n,<sp/>Xev.zs[n],<sp/>zb[n]<sp/>+<sp/>Xev.h[n],<sp/>zb[n]<sp/>,<sp/>Xev.h[n]);</highlight></codeline>
<codeline lineno="119"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="120"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="121"><highlight class="normal"></highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Recalculate<sp/>zs<sp/>everywhere<sp/>maybe<sp/>we<sp/>only<sp/>need<sp/>to<sp/>do<sp/>that<sp/>on<sp/>the<sp/>halo<sp/>?</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>-1;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>+<sp/>1);<sp/>j++)</highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>-1;<sp/>i<sp/>&lt;<sp/>(XParam.blkwidth<sp/>+<sp/>1);<sp/>i++)</highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>memloc(XParam.halowidth,<sp/>XParam.blkmemwidth,<sp/>i,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Xev.h[n]<sp/>=<sp/>max(Xev.zs[n]-<sp/>zb[n],(T)0.0)<sp/>;</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="132"><highlight class="normal"></highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="134"><highlight class="normal">}</highlight></codeline>
<codeline lineno="135"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Recalculatehh&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>Xev,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>zb);</highlight></codeline>
<codeline lineno="136"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Recalculatehh&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>Xev,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>zb);</highlight></codeline>
<codeline lineno="137"><highlight class="normal"></highlight></codeline>
<codeline lineno="138"><highlight class="normal"></highlight></codeline>
<codeline lineno="150"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RecalculateZsGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>Xev,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="151"><highlight class="normal">{</highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkmemwidth;</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x<sp/>-1;</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y<sp/>-1;</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/>n;</highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ib<sp/>=<sp/>XBlock.active[ibl];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/>n<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/>Xev.zs[n]<sp/>=<sp/>zb[n]<sp/>+<sp/>Xev.h[n];</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="166"><highlight class="comment"><sp/><sp/><sp/><sp/>if(zb[n]<sp/>&lt;<sp/>XParam.eps)</highlight></codeline>
<codeline lineno="167"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="168"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;ix=%d,<sp/>iy=%d,<sp/>ib=%d,<sp/>n=%d;<sp/>zsold=%f;<sp/>zsnew=%f<sp/>(zb=%f<sp/>+<sp/>h=%f)\n&quot;,ix,iy,ib,<sp/>n,<sp/>Xev.zs[n],<sp/>zb[n]<sp/>+<sp/>Xev.h[n],<sp/>zb[n],<sp/>Xev.h[n]);</highlight></codeline>
<codeline lineno="169"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="170"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="172"><highlight class="normal">}</highlight></codeline>
<codeline lineno="173"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RecalculateZsGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>Xev,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>zb);</highlight></codeline>
<codeline lineno="174"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RecalculateZsGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>Xev,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>zb);</highlight></codeline>
<codeline lineno="175"><highlight class="normal"></highlight></codeline>
<codeline lineno="186"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloF(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="187"><highlight class="normal">{</highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib;</highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillLeftFlux(XParam,<sp/>doProlongation,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillBotFlux(XParam,<sp/>doProlongation,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillRightFlux(XParam,<sp/>doProlongation,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillTopFlux(XParam,<sp/>doProlongation,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="198"><highlight class="normal">}</highlight></codeline>
<codeline lineno="199"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloF&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="200"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloF&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="201"><highlight class="normal"></highlight></codeline>
<codeline lineno="210"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="211"><highlight class="normal">{</highlight></codeline>
<codeline lineno="212"><highlight class="normal"></highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloLR(1,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloBT(XParam.blkwidth,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="216"><highlight class="normal"></highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/>fillLeft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>z);</highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/>fillRight<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRight<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/>fillBot<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>z);</highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillBot<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="225"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="226"><highlight class="normal"><sp/><sp/><sp/><sp/>fillTop<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight></codeline>
<codeline lineno="227"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTop<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaStreamSynchronize(stream));</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="230"><highlight class="normal"></highlight></codeline>
<codeline lineno="231"><highlight class="normal">}</highlight></codeline>
<codeline lineno="232"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="233"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="234"><highlight class="normal"></highlight></codeline>
<codeline lineno="235"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="236"><highlight class="normal">{</highlight></codeline>
<codeline lineno="237"><highlight class="normal"></highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloLR(1,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloBT(XParam.blkwidth,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="240"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="241"><highlight class="normal"></highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/>fillLeft<sp/>&lt;&lt;<sp/>&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;<sp/>&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>z);</highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeft<sp/>&lt;&lt;<sp/>&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;<sp/>&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="244"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/><sp/><sp/>fillRight<sp/>&lt;&lt;<sp/>&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;<sp/>&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRight<sp/>&lt;&lt;<sp/>&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;<sp/>&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/>fillBot<sp/>&lt;&lt;<sp/>&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;<sp/>&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>z);</highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillBot<sp/>&lt;&lt;<sp/>&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0&gt;&gt;<sp/>&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/>fillTop<sp/>&lt;&lt;<sp/>&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;<sp/>&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight></codeline>
<codeline lineno="252"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTop<sp/>&lt;&lt;<sp/>&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0&gt;&gt;<sp/>&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaStreamSynchronize(stream));</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="255"><highlight class="normal"></highlight></codeline>
<codeline lineno="256"><highlight class="normal">}</highlight></codeline>
<codeline lineno="257"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="258"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="259"><highlight class="normal"></highlight></codeline>
<codeline lineno="260"><highlight class="normal"></highlight></codeline>
<codeline lineno="263"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPUnew(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="264"><highlight class="normal">{</highlight></codeline>
<codeline lineno="265"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloLR(1,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloBT(XParam.blkwidth,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="267"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="268"><highlight class="normal"></highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloLRx2(2,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="270"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloBTx2(XParam.blkwidth,<sp/>2,<sp/>1);</highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDimx2(ceil(XParam.nblk/2),<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="272"><highlight class="normal"></highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeftnew<sp/>&lt;&lt;&lt;gridDimx2,<sp/>blockDimHaloLRx2,<sp/>0&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.nblk,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="274"><highlight class="normal"><sp/><sp/><sp/><sp/>fillLeft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>z);</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRightnew<sp/>&lt;&lt;&lt;gridDimx2,<sp/>blockDimHaloLRx2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.nblk,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/>fillRight<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillBotnew<sp/>&lt;&lt;&lt;gridDimx2,<sp/>blockDimHaloBTx2,<sp/>0&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.nblk,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/>fillBot<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>z);</highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTopnew<sp/>&lt;&lt;&lt;gridDimx2,<sp/>blockDimHaloBTx2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.nblk,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="283"><highlight class="normal"><sp/><sp/><sp/><sp/>fillTop<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight></codeline>
<codeline lineno="284"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaStreamSynchronize(stream));</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="286"><highlight class="normal"></highlight></codeline>
<codeline lineno="287"><highlight class="normal">}</highlight></codeline>
<codeline lineno="288"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPUnew&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="289"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPUnew&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="290"><highlight class="normal"></highlight></codeline>
<codeline lineno="291"><highlight class="normal"></highlight></codeline>
<codeline lineno="300"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloTopRightC(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="301"><highlight class="normal">{</highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>for<sp/>flux<sp/>term<sp/>and<sp/>actually<sp/>most<sp/>terms,<sp/>only<sp/>top<sp/>and<sp/>right<sp/>neighbours<sp/>are<sp/>needed!</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="303"><highlight class="normal"></highlight></codeline>
<codeline lineno="304"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeft(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="305"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib;</highlight></codeline>
<codeline lineno="306"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HaloFluxCPULR(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HaloFluxCPUBT(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="311"><highlight class="normal"></highlight></codeline>
<codeline lineno="312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRightFlux(XParam,true,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTopFlux(XParam,true,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="314"><highlight class="normal"></highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="317"><highlight class="normal"></highlight></codeline>
<codeline lineno="318"><highlight class="normal"></highlight></codeline>
<codeline lineno="319"><highlight class="normal">}</highlight></codeline>
<codeline lineno="320"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloTopRightC&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="321"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloTopRightC&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="322"><highlight class="normal"></highlight></codeline>
<codeline lineno="323"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLRFluxC(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="324"><highlight class="normal">{</highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>for<sp/>flux<sp/>term<sp/>and<sp/>actually<sp/>most<sp/>terms,<sp/>only<sp/>top<sp/>and<sp/>right<sp/>neighbours<sp/>are<sp/>needed!</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="326"><highlight class="normal"></highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeft(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="328"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib;</highlight></codeline>
<codeline lineno="329"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="330"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HaloFluxCPULR(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//HaloFluxCPUBT(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="334"><highlight class="normal"></highlight></codeline>
<codeline lineno="335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRightFlux(XParam,true,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTopFlux(XParam,true,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="337"><highlight class="normal"></highlight></codeline>
<codeline lineno="338"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="339"><highlight class="normal"></highlight></codeline>
<codeline lineno="340"><highlight class="normal"></highlight></codeline>
<codeline lineno="341"><highlight class="normal"></highlight></codeline>
<codeline lineno="342"><highlight class="normal">}</highlight></codeline>
<codeline lineno="343"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLRFluxC&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="344"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLRFluxC&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="345"><highlight class="normal"></highlight></codeline>
<codeline lineno="346"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBTFluxC(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="347"><highlight class="normal">{</highlight></codeline>
<codeline lineno="348"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>for<sp/>flux<sp/>term<sp/>and<sp/>actually<sp/>most<sp/>terms,<sp/>only<sp/>top<sp/>and<sp/>right<sp/>neighbours<sp/>are<sp/>needed!</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="349"><highlight class="normal"></highlight></codeline>
<codeline lineno="350"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeft(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib;</highlight></codeline>
<codeline lineno="352"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="353"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//HaloFluxCPULR(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HaloFluxCPUBT(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="357"><highlight class="normal"></highlight></codeline>
<codeline lineno="358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRightFlux(XParam,true,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTopFlux(XParam,true,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="360"><highlight class="normal"></highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="362"><highlight class="normal"></highlight></codeline>
<codeline lineno="363"><highlight class="normal"></highlight></codeline>
<codeline lineno="364"><highlight class="normal"></highlight></codeline>
<codeline lineno="365"><highlight class="normal">}</highlight></codeline>
<codeline lineno="366"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBTFluxC&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="367"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBTFluxC&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="368"><highlight class="normal"></highlight></codeline>
<codeline lineno="369"><highlight class="normal"></highlight></codeline>
<codeline lineno="370"><highlight class="normal"></highlight></codeline>
<codeline lineno="371"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloTopRightGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="372"><highlight class="normal">{</highlight></codeline>
<codeline lineno="373"><highlight class="normal"></highlight></codeline>
<codeline lineno="374"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloLR(1,<sp/>16,<sp/>1);</highlight></codeline>
<codeline lineno="375"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloBT(16,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="376"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="377"><highlight class="normal"></highlight></codeline>
<codeline lineno="378"><highlight class="normal"></highlight></codeline>
<codeline lineno="379"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>a);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="380"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRightFlux<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,false,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/><sp/><sp/>HaloFluxGPULR<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="383"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillBot<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>a);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="384"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTopFlux<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,false,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="385"><highlight class="normal"><sp/><sp/><sp/><sp/>HaloFluxGPUBT<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="386"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaStreamSynchronize(stream));</highlight></codeline>
<codeline lineno="387"><highlight class="normal"></highlight></codeline>
<codeline lineno="388"><highlight class="normal">}</highlight></codeline>
<codeline lineno="389"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloTopRightGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="390"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloTopRightGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="391"><highlight class="normal"></highlight></codeline>
<codeline lineno="392"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLeftRightGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="393"><highlight class="normal">{</highlight></codeline>
<codeline lineno="394"><highlight class="normal"></highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloLR(1,<sp/>16,<sp/>1);</highlight></codeline>
<codeline lineno="396"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dim3<sp/>blockDimHaloBT(16,<sp/>1,<sp/>1);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="397"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="398"><highlight class="normal"></highlight></codeline>
<codeline lineno="399"><highlight class="normal"></highlight></codeline>
<codeline lineno="400"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>a);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="401"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRightFlux<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,false,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="402"><highlight class="normal"><sp/><sp/><sp/><sp/>HaloFluxGPULR<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="403"><highlight class="normal"></highlight></codeline>
<codeline lineno="404"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillBot<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>a);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="405"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTopFlux<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,false,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="406"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//HaloFluxGPUBT<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="407"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaStreamSynchronize(stream));</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="408"><highlight class="normal"></highlight></codeline>
<codeline lineno="409"><highlight class="normal">}</highlight></codeline>
<codeline lineno="410"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLeftRightGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="411"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLeftRightGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="412"><highlight class="normal"></highlight></codeline>
<codeline lineno="413"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLeftRightGPUnew(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="414"><highlight class="normal">{</highlight></codeline>
<codeline lineno="415"><highlight class="normal"></highlight></codeline>
<codeline lineno="416"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloLR(2,<sp/>16,<sp/>1);</highlight></codeline>
<codeline lineno="417"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dim3<sp/>blockDimHaloBT(16,<sp/>1,<sp/>1);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="418"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(ceil(XParam.nblk/2),<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="419"><highlight class="normal"></highlight></codeline>
<codeline lineno="420"><highlight class="normal"><sp/><sp/><sp/><sp/>HaloFluxGPULRnew<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="421"><highlight class="normal"></highlight></codeline>
<codeline lineno="422"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="423"><highlight class="normal"></highlight></codeline>
<codeline lineno="424"><highlight class="normal">}</highlight></codeline>
<codeline lineno="425"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLeftRightGPUnew&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="426"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloLeftRightGPUnew&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="427"><highlight class="normal"></highlight></codeline>
<codeline lineno="428"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBotTopGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="429"><highlight class="normal">{</highlight></codeline>
<codeline lineno="430"><highlight class="normal"></highlight></codeline>
<codeline lineno="431"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dim3<sp/>blockDimHaloLR(1,<sp/>16,<sp/>1);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="432"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloBT(16,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="433"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="434"><highlight class="normal"></highlight></codeline>
<codeline lineno="435"><highlight class="normal"></highlight></codeline>
<codeline lineno="436"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillLeft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.LeftBot,<sp/>XBlock.LeftTop,<sp/>XBlock.RightBot,<sp/>XBlock.BotRight,<sp/>XBlock.TopRight,<sp/>a);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="437"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillRightFlux<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,false,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.RightBot,<sp/>XBlock.RightTop,<sp/>XBlock.LeftBot,<sp/>XBlock.BotLeft,<sp/>XBlock.TopLeft,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="438"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//HaloFluxGPULR<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="439"><highlight class="normal"></highlight></codeline>
<codeline lineno="440"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillBot<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.BotLeft,<sp/>XBlock.BotRight,<sp/>XBlock.TopLeft,<sp/>XBlock.LeftTop,<sp/>XBlock.RightTop,<sp/>a);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="441"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillTopFlux<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,false,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>XBlock.TopLeft,<sp/>XBlock.TopRight,<sp/>XBlock.BotLeft,<sp/>XBlock.LeftBot,<sp/>XBlock.RightBot,<sp/>z);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="442"><highlight class="normal"><sp/><sp/><sp/><sp/>HaloFluxGPUBT<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="443"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaStreamSynchronize(stream));</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="444"><highlight class="normal"></highlight></codeline>
<codeline lineno="445"><highlight class="normal">}</highlight></codeline>
<codeline lineno="446"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBotTopGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="447"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBotTopGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="448"><highlight class="normal"></highlight></codeline>
<codeline lineno="449"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBotTopGPUnew(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="450"><highlight class="normal">{</highlight></codeline>
<codeline lineno="451"><highlight class="normal"></highlight></codeline>
<codeline lineno="452"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dim3<sp/>blockDimHaloLR(1,<sp/>16,<sp/>1);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="453"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloBT(16,<sp/>2,<sp/>1);</highlight></codeline>
<codeline lineno="454"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(ceil(XParam.nblk/2),<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="455"><highlight class="normal"></highlight></codeline>
<codeline lineno="456"><highlight class="normal"></highlight></codeline>
<codeline lineno="457"><highlight class="normal"><sp/><sp/><sp/><sp/>HaloFluxGPUBTnew<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0,<sp/>stream<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="459"><highlight class="normal"></highlight></codeline>
<codeline lineno="460"><highlight class="normal">}</highlight></codeline>
<codeline lineno="461"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBotTopGPUnew&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="462"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloBotTopGPUnew&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/>cudaStream_t<sp/>stream,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="463"><highlight class="normal"></highlight></codeline>
<codeline lineno="464"><highlight class="normal"></highlight></codeline>
<codeline lineno="465"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>Xev,<sp/>T*zb)</highlight></codeline>
<codeline lineno="466"><highlight class="normal">{</highlight></codeline>
<codeline lineno="467"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::thread<sp/>t0(fillHaloC&lt;T&gt;,XParam,<sp/>XBlock,<sp/>Xev.h);</highlight></codeline>
<codeline lineno="470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::thread<sp/>t1(fillHaloC&lt;T&gt;,XParam,<sp/>XBlock,<sp/>Xev.zs);</highlight></codeline>
<codeline lineno="471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t2(fillHaloF&lt;T&gt;,XParam,true,<sp/>XBlock,<sp/>Xev.u);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t3(fillHaloF&lt;T&gt;,XParam,true,<sp/>XBlock,<sp/>Xev.v);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="473"><highlight class="normal"></highlight></codeline>
<codeline lineno="474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::thread<sp/>t2(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Xev.u);</highlight></codeline>
<codeline lineno="475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::thread<sp/>t3(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Xev.v);</highlight></codeline>
<codeline lineno="476"><highlight class="normal"></highlight></codeline>
<codeline lineno="477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>t0.join();</highlight></codeline>
<codeline lineno="478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>t1.join();</highlight></codeline>
<codeline lineno="479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>t2.join();</highlight></codeline>
<codeline lineno="480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>t3.join();</highlight></codeline>
<codeline lineno="481"><highlight class="normal"></highlight></codeline>
<codeline lineno="482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.conserveElevation)</highlight></codeline>
<codeline lineno="483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>conserveElevation(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight></codeline>
<codeline lineno="485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.wetdryfix)</highlight></codeline>
<codeline lineno="487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetDryRestriction(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight></codeline>
<codeline lineno="489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="490"><highlight class="normal"></highlight></codeline>
<codeline lineno="491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RecalculateZs(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight></codeline>
<codeline lineno="492"><highlight class="normal"></highlight></codeline>
<codeline lineno="493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maskbnd(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight></codeline>
<codeline lineno="494"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="495"><highlight class="normal">}</highlight></codeline>
<codeline lineno="496"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>Xev,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*zb);</highlight></codeline>
<codeline lineno="497"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>Xev,</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*<sp/>zb);</highlight></codeline>
<codeline lineno="498"><highlight class="normal"></highlight></codeline>
<codeline lineno="499"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>Xev)</highlight></codeline>
<codeline lineno="500"><highlight class="normal">{</highlight></codeline>
<codeline lineno="501"><highlight class="normal"></highlight></codeline>
<codeline lineno="502"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t0(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Xev.h);</highlight></codeline>
<codeline lineno="503"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t1(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Xev.zs);</highlight></codeline>
<codeline lineno="504"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t2(fillHaloF&lt;T&gt;,<sp/>XParam,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>XBlock,<sp/>Xev.u);</highlight></codeline>
<codeline lineno="505"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t3(fillHaloF&lt;T&gt;,<sp/>XParam,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/>XBlock,<sp/>Xev.v);</highlight></codeline>
<codeline lineno="506"><highlight class="normal"></highlight></codeline>
<codeline lineno="507"><highlight class="normal"><sp/><sp/><sp/><sp/>t0.join();</highlight></codeline>
<codeline lineno="508"><highlight class="normal"><sp/><sp/><sp/><sp/>t1.join();</highlight></codeline>
<codeline lineno="509"><highlight class="normal"><sp/><sp/><sp/><sp/>t2.join();</highlight></codeline>
<codeline lineno="510"><highlight class="normal"><sp/><sp/><sp/><sp/>t3.join();</highlight></codeline>
<codeline lineno="511"><highlight class="normal"></highlight></codeline>
<codeline lineno="512"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="513"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//maskbnd(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="514"><highlight class="normal"></highlight></codeline>
<codeline lineno="515"><highlight class="normal">}</highlight></codeline>
<codeline lineno="516"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>Xev);</highlight></codeline>
<codeline lineno="517"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>Xev);</highlight></codeline>
<codeline lineno="518"><highlight class="normal"></highlight></codeline>
<codeline lineno="519"><highlight class="normal"></highlight></codeline>
<codeline lineno="520"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>Xev)</highlight></codeline>
<codeline lineno="521"><highlight class="normal">{</highlight></codeline>
<codeline lineno="522"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_streams<sp/>=<sp/>4;</highlight></codeline>
<codeline lineno="523"><highlight class="normal"></highlight></codeline>
<codeline lineno="524"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaStream_t<sp/>streams[num_streams];</highlight></codeline>
<codeline lineno="525"><highlight class="normal"></highlight></codeline>
<codeline lineno="526"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="527"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));</highlight></codeline>
<codeline lineno="529"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="530"><highlight class="normal"></highlight></codeline>
<codeline lineno="531"><highlight class="normal"></highlight></codeline>
<codeline lineno="532"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[0],<sp/>Xev.h);</highlight></codeline>
<codeline lineno="533"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[1],<sp/>Xev.zs);</highlight></codeline>
<codeline lineno="534"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[2],<sp/>Xev.u);</highlight></codeline>
<codeline lineno="535"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[3],<sp/>Xev.v);</highlight></codeline>
<codeline lineno="536"><highlight class="normal"></highlight></codeline>
<codeline lineno="537"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="538"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStreamDestroy(streams[i]);</highlight></codeline>
<codeline lineno="540"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="541"><highlight class="normal">}</highlight></codeline>
<codeline lineno="542"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>Xev);</highlight></codeline>
<codeline lineno="543"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>Xev);</highlight></codeline>
<codeline lineno="544"><highlight class="normal"></highlight></codeline>
<codeline lineno="545"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>Xev,T<sp/>*<sp/>zb)</highlight></codeline>
<codeline lineno="546"><highlight class="normal">{</highlight></codeline>
<codeline lineno="547"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_streams<sp/>=<sp/>4;</highlight></codeline>
<codeline lineno="548"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHalo(XParam.blkwidth,1,<sp/>1);</highlight></codeline>
<codeline lineno="549"><highlight class="normal"></highlight></codeline>
<codeline lineno="550"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XBlock.mask.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="551"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="552"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimfull(XParam.blkmemwidth,<sp/>XParam.blkmemwidth,<sp/>1);</highlight></codeline>
<codeline lineno="553"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDimfull(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="554"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="555"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaStream_t<sp/>streams[num_streams];</highlight></codeline>
<codeline lineno="556"><highlight class="normal"></highlight></codeline>
<codeline lineno="557"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="558"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));</highlight></codeline>
<codeline lineno="560"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="561"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="562"><highlight class="normal"></highlight></codeline>
<codeline lineno="563"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[0],<sp/>Xev.h);</highlight></codeline>
<codeline lineno="564"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[1],<sp/>Xev.zs);</highlight></codeline>
<codeline lineno="565"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[2],<sp/>Xev.u);</highlight></codeline>
<codeline lineno="566"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[3],<sp/>Xev.v);</highlight></codeline>
<codeline lineno="567"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="568"><highlight class="normal"></highlight></codeline>
<codeline lineno="569"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.conserveElevation)</highlight></codeline>
<codeline lineno="570"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="571"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>conserveElevationGPU(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight></codeline>
<codeline lineno="572"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="573"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.wetdryfix)</highlight></codeline>
<codeline lineno="574"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="575"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetDryRestrictionGPU(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight></codeline>
<codeline lineno="576"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="577"><highlight class="normal"></highlight></codeline>
<codeline lineno="578"><highlight class="normal"><sp/><sp/><sp/><sp/>RecalculateZsGPU<sp/>&lt;&lt;&lt;<sp/>gridDimfull,<sp/>blockDimfull,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight></codeline>
<codeline lineno="579"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="580"><highlight class="normal"></highlight></codeline>
<codeline lineno="581"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//if<sp/>(XBlock.mask.nblk<sp/>&gt;<sp/>0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="582"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="583"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>maskbndGPUleft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[0]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="584"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>maskbndGPUtop<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[1]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="585"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>maskbndGPUright<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[2]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="586"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>maskbndGPUtop<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[3]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Xev,<sp/>zb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="587"><highlight class="normal"></highlight></codeline>
<codeline lineno="588"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="589"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="590"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="591"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStreamDestroy(streams[i]);</highlight></codeline>
<codeline lineno="593"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="594"><highlight class="normal"></highlight></codeline>
<codeline lineno="595"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="596"><highlight class="normal">}</highlight></codeline>
<codeline lineno="597"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>Xev,</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*zb);</highlight></codeline>
<codeline lineno="598"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>Xev,</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>zb);</highlight></codeline>
<codeline lineno="599"><highlight class="normal"></highlight></codeline>
<codeline lineno="600"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structGradientsP" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>Grad)</highlight></codeline>
<codeline lineno="601"><highlight class="normal">{</highlight></codeline>
<codeline lineno="602"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="603"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="604"><highlight class="comment"><sp/><sp/><sp/><sp/>std::thread<sp/>t0(fillHaloF&lt;T&gt;,XParam,<sp/>true,<sp/>XBlock,<sp/>Grad.dhdx);</highlight></codeline>
<codeline lineno="605"><highlight class="comment"><sp/><sp/><sp/><sp/>std::thread<sp/>t1(fillHaloF&lt;T&gt;,XParam,<sp/>true,<sp/>XBlock,<sp/>Grad.dudx);</highlight></codeline>
<codeline lineno="606"><highlight class="comment"><sp/><sp/><sp/><sp/>std::thread<sp/>t2(fillHaloF&lt;T&gt;,XParam,<sp/>true,<sp/>XBlock,<sp/>Grad.dvdx);</highlight></codeline>
<codeline lineno="607"><highlight class="comment"><sp/><sp/><sp/><sp/>std::thread<sp/>t3(fillHaloF&lt;T&gt;,XParam,<sp/>true,<sp/>XBlock,<sp/>Grad.dzsdx);</highlight></codeline>
<codeline lineno="608"><highlight class="comment"></highlight></codeline>
<codeline lineno="609"><highlight class="comment"><sp/><sp/><sp/><sp/>std::thread<sp/>t4(fillHaloF&lt;T&gt;,XParam,<sp/>true,<sp/>XBlock,<sp/>Grad.dhdy);</highlight></codeline>
<codeline lineno="610"><highlight class="comment"><sp/><sp/><sp/><sp/>std::thread<sp/>t5(fillHaloF&lt;T&gt;,XParam,<sp/>true,<sp/>XBlock,<sp/>Grad.dudy);</highlight></codeline>
<codeline lineno="611"><highlight class="comment"><sp/><sp/><sp/><sp/>std::thread<sp/>t6(fillHaloF&lt;T&gt;,XParam,<sp/>true,<sp/>XBlock,<sp/>Grad.dvdy);</highlight></codeline>
<codeline lineno="612"><highlight class="comment"><sp/><sp/><sp/><sp/>std::thread<sp/>t7(fillHaloF&lt;T&gt;,XParam,<sp/>true,<sp/>XBlock,<sp/>Grad.dzsdy);</highlight></codeline>
<codeline lineno="613"><highlight class="comment"></highlight></codeline>
<codeline lineno="614"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="615"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t0(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Grad.dhdx);</highlight></codeline>
<codeline lineno="616"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t1(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Grad.dudx);</highlight></codeline>
<codeline lineno="617"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t2(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Grad.dvdx);</highlight></codeline>
<codeline lineno="618"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t3(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Grad.dzsdx);</highlight></codeline>
<codeline lineno="619"><highlight class="normal"></highlight></codeline>
<codeline lineno="620"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t4(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Grad.dhdy);</highlight></codeline>
<codeline lineno="621"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t5(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Grad.dudy);</highlight></codeline>
<codeline lineno="622"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t6(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Grad.dvdy);</highlight></codeline>
<codeline lineno="623"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t7(fillHaloC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Grad.dzsdy);</highlight></codeline>
<codeline lineno="624"><highlight class="normal"></highlight></codeline>
<codeline lineno="625"><highlight class="normal"><sp/><sp/><sp/><sp/>t0.join();</highlight></codeline>
<codeline lineno="626"><highlight class="normal"><sp/><sp/><sp/><sp/>t1.join();</highlight></codeline>
<codeline lineno="627"><highlight class="normal"><sp/><sp/><sp/><sp/>t2.join();</highlight></codeline>
<codeline lineno="628"><highlight class="normal"><sp/><sp/><sp/><sp/>t3.join();</highlight></codeline>
<codeline lineno="629"><highlight class="normal"><sp/><sp/><sp/><sp/>t4.join();</highlight></codeline>
<codeline lineno="630"><highlight class="normal"><sp/><sp/><sp/><sp/>t5.join();</highlight></codeline>
<codeline lineno="631"><highlight class="normal"><sp/><sp/><sp/><sp/>t6.join();</highlight></codeline>
<codeline lineno="632"><highlight class="normal"><sp/><sp/><sp/><sp/>t7.join();</highlight></codeline>
<codeline lineno="633"><highlight class="normal"></highlight></codeline>
<codeline lineno="634"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="635"><highlight class="normal">}</highlight></codeline>
<codeline lineno="636"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structGradientsP" kindref="compound">GradientsP&lt;float&gt;</ref><sp/>Grad);</highlight></codeline>
<codeline lineno="637"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structGradientsP" kindref="compound">GradientsP&lt;double&gt;</ref><sp/>Grad);</highlight></codeline>
<codeline lineno="638"><highlight class="normal"></highlight></codeline>
<codeline lineno="639"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structGradientsP" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>Grad)</highlight></codeline>
<codeline lineno="640"><highlight class="normal">{</highlight></codeline>
<codeline lineno="641"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_streams<sp/>=<sp/>8;</highlight></codeline>
<codeline lineno="642"><highlight class="normal"></highlight></codeline>
<codeline lineno="643"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaStream_t<sp/>streams[num_streams];</highlight></codeline>
<codeline lineno="644"><highlight class="normal"></highlight></codeline>
<codeline lineno="645"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="646"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));</highlight></codeline>
<codeline lineno="648"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="650"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[0],<sp/>Grad.dhdx);</highlight></codeline>
<codeline lineno="651"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[2],<sp/>Grad.dudx);</highlight></codeline>
<codeline lineno="652"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[3],<sp/>Grad.dvdx);</highlight></codeline>
<codeline lineno="653"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[4],<sp/>Grad.dzsdx);</highlight></codeline>
<codeline lineno="654"><highlight class="normal"></highlight></codeline>
<codeline lineno="655"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[5],<sp/>Grad.dhdy);</highlight></codeline>
<codeline lineno="656"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[6],<sp/>Grad.dudy);</highlight></codeline>
<codeline lineno="657"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[7],<sp/>Grad.dvdy);</highlight></codeline>
<codeline lineno="658"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloGPU(XParam,<sp/>XBlock,<sp/>streams[1],<sp/>Grad.dzsdy);</highlight></codeline>
<codeline lineno="659"><highlight class="normal"></highlight></codeline>
<codeline lineno="660"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="661"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStreamDestroy(streams[i]);</highlight></codeline>
<codeline lineno="663"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="664"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="665"><highlight class="normal">}</highlight></codeline>
<codeline lineno="666"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structGradientsP" kindref="compound">GradientsP&lt;float&gt;</ref><sp/>Grad);</highlight></codeline>
<codeline lineno="667"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structGradientsP" kindref="compound">GradientsP&lt;double&gt;</ref><sp/>Grad);</highlight></codeline>
<codeline lineno="668"><highlight class="normal"></highlight></codeline>
<codeline lineno="669"><highlight class="normal"></highlight></codeline>
<codeline lineno="670"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;T&gt;</ref><sp/>Flux)</highlight></codeline>
<codeline lineno="671"><highlight class="normal">{</highlight></codeline>
<codeline lineno="672"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="674"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t0(fillHaloTopRightC&lt;T&gt;,XParam,<sp/>XBlock,<sp/>Flux.Fhu);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="675"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t1(fillHaloTopRightC&lt;T&gt;,XParam,<sp/>XBlock,<sp/>Flux.Fhv);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="676"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t2(fillHaloTopRightC&lt;T&gt;,XParam,<sp/>XBlock,<sp/>Flux.Fqux);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="677"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t3(fillHaloTopRightC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Fquy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="678"><highlight class="normal"></highlight></codeline>
<codeline lineno="679"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t4(fillHaloTopRightC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Fqvx);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="680"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t5(fillHaloTopRightC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Fqvy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="681"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t6(fillHaloTopRightC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Su);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="682"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//std::thread<sp/>t7(fillHaloTopRightC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Sv);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="683"><highlight class="normal"></highlight></codeline>
<codeline lineno="684"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t0(fillHaloLRFluxC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Fhu);</highlight></codeline>
<codeline lineno="685"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t1(fillHaloLRFluxC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Fqux);</highlight></codeline>
<codeline lineno="686"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t2(fillHaloLRFluxC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Su);</highlight></codeline>
<codeline lineno="687"><highlight class="normal"></highlight></codeline>
<codeline lineno="688"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t6(fillHaloLRFluxC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Fqvx);</highlight></codeline>
<codeline lineno="689"><highlight class="normal"></highlight></codeline>
<codeline lineno="690"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t3(fillHaloBTFluxC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Fhv);</highlight></codeline>
<codeline lineno="691"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t4(fillHaloBTFluxC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Fqvy);</highlight></codeline>
<codeline lineno="692"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t5(fillHaloBTFluxC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Sv);</highlight></codeline>
<codeline lineno="693"><highlight class="normal"></highlight></codeline>
<codeline lineno="694"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t7(fillHaloBTFluxC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>Flux.Fquy);</highlight></codeline>
<codeline lineno="695"><highlight class="normal"></highlight></codeline>
<codeline lineno="696"><highlight class="normal"><sp/><sp/><sp/><sp/>t0.join();</highlight></codeline>
<codeline lineno="697"><highlight class="normal"><sp/><sp/><sp/><sp/>t1.join();</highlight></codeline>
<codeline lineno="698"><highlight class="normal"><sp/><sp/><sp/><sp/>t2.join();</highlight></codeline>
<codeline lineno="699"><highlight class="normal"><sp/><sp/><sp/><sp/>t3.join();</highlight></codeline>
<codeline lineno="700"><highlight class="normal"><sp/><sp/><sp/><sp/>t4.join();</highlight></codeline>
<codeline lineno="701"><highlight class="normal"><sp/><sp/><sp/><sp/>t5.join();</highlight></codeline>
<codeline lineno="702"><highlight class="normal"><sp/><sp/><sp/><sp/>t6.join();</highlight></codeline>
<codeline lineno="703"><highlight class="normal"><sp/><sp/><sp/><sp/>t7.join();</highlight></codeline>
<codeline lineno="704"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="705"><highlight class="normal">}</highlight></codeline>
<codeline lineno="706"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;float&gt;</ref><sp/>Flux);</highlight></codeline>
<codeline lineno="707"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHalo&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;double&gt;</ref><sp/>Flux);</highlight></codeline>
<codeline lineno="708"><highlight class="normal"></highlight></codeline>
<codeline lineno="709"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;T&gt;</ref><sp/>Flux)</highlight></codeline>
<codeline lineno="710"><highlight class="normal">{</highlight></codeline>
<codeline lineno="711"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_streams<sp/>=<sp/>8;</highlight></codeline>
<codeline lineno="712"><highlight class="normal"></highlight></codeline>
<codeline lineno="713"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaStream_t<sp/>streams[num_streams];</highlight></codeline>
<codeline lineno="714"><highlight class="normal"></highlight></codeline>
<codeline lineno="715"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="716"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));</highlight></codeline>
<codeline lineno="718"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="719"><highlight class="normal"></highlight></codeline>
<codeline lineno="720"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHalo(XParam.blkwidth,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="721"><highlight class="normal"></highlight></codeline>
<codeline lineno="722"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XBlock.mask.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="723"><highlight class="normal"></highlight></codeline>
<codeline lineno="724"><highlight class="normal"></highlight></codeline>
<codeline lineno="725"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloLeftRightGPUnew(XParam,<sp/>XBlock,<sp/>streams[0],<sp/>Flux.Fhu);</highlight></codeline>
<codeline lineno="726"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloLeftRightGPUnew(XParam,<sp/>XBlock,<sp/>streams[1],<sp/>Flux.Su);</highlight></codeline>
<codeline lineno="727"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloLeftRightGPUnew(XParam,<sp/>XBlock,<sp/>streams[2],<sp/>Flux.Fqux);</highlight></codeline>
<codeline lineno="728"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloLeftRightGPUnew(XParam,<sp/>XBlock,<sp/>streams[3],<sp/>Flux.Fqvx);</highlight></codeline>
<codeline lineno="729"><highlight class="normal"></highlight></codeline>
<codeline lineno="730"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="731"><highlight class="normal"></highlight></codeline>
<codeline lineno="732"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloBotTopGPUnew(XParam,<sp/>XBlock,<sp/>streams[4],<sp/>Flux.Fquy);</highlight></codeline>
<codeline lineno="733"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloBotTopGPUnew(XParam,<sp/>XBlock,<sp/>streams[5],<sp/>Flux.Fqvy);</highlight></codeline>
<codeline lineno="734"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloBotTopGPUnew(XParam,<sp/>XBlock,<sp/>streams[6],<sp/>Flux.Fhv);</highlight></codeline>
<codeline lineno="735"><highlight class="normal"><sp/><sp/><sp/><sp/>fillHaloBotTopGPUnew(XParam,<sp/>XBlock,<sp/>streams[7],<sp/>Flux.Sv);</highlight></codeline>
<codeline lineno="736"><highlight class="normal"></highlight></codeline>
<codeline lineno="737"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="738"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="739"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStreamSynchronize(streams[i]);</highlight></codeline>
<codeline lineno="741"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="742"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Below<sp/>has<sp/>now<sp/>moved<sp/>to<sp/>its<sp/>own<sp/>function</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="743"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//if<sp/>(XBlock.mask.nblk<sp/>&gt;<sp/>0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="744"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="745"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>maskbndGPUFluxleft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[0]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Flux);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="746"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>maskbndGPUFluxtop<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[1]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Flux);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="747"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>maskbndGPUFluxright<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[2]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Flux);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="748"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>maskbndGPUFluxbot<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[3]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Flux);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="749"><highlight class="normal"></highlight></codeline>
<codeline lineno="750"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="751"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="752"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="753"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="754"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStreamDestroy(streams[i]);</highlight></codeline>
<codeline lineno="756"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="757"><highlight class="normal"></highlight></codeline>
<codeline lineno="758"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="759"><highlight class="normal">}</highlight></codeline>
<codeline lineno="760"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;float&gt;</ref><sp/>Flux);</highlight></codeline>
<codeline lineno="761"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillHaloGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;double&gt;</ref><sp/>Flux);</highlight></codeline>
<codeline lineno="762"><highlight class="normal"></highlight></codeline>
<codeline lineno="763"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>bndmaskGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>Xev,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;T&gt;</ref><sp/>Flux)</highlight></codeline>
<codeline lineno="764"><highlight class="normal">{</highlight></codeline>
<codeline lineno="765"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_streams<sp/>=<sp/>8;</highlight></codeline>
<codeline lineno="766"><highlight class="normal"></highlight></codeline>
<codeline lineno="767"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaStream_t<sp/>streams[num_streams];</highlight></codeline>
<codeline lineno="768"><highlight class="normal"></highlight></codeline>
<codeline lineno="769"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="770"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="771"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));</highlight></codeline>
<codeline lineno="772"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="773"><highlight class="normal"></highlight></codeline>
<codeline lineno="774"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHalo(XParam.blkwidth,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="775"><highlight class="normal"></highlight></codeline>
<codeline lineno="776"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XBlock.mask.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="777"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.mask.nblk<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="778"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="779"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maskbndGPUFluxleft<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[0]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Xev,<sp/>Flux);</highlight></codeline>
<codeline lineno="780"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maskbndGPUFluxtop<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[1]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/><sp/>Flux);</highlight></codeline>
<codeline lineno="781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maskbndGPUFluxright<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[2]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/><sp/>Flux);</highlight></codeline>
<codeline lineno="782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maskbndGPUFluxbot<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHalo,<sp/>0,<sp/>streams[3]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>Flux);</highlight></codeline>
<codeline lineno="783"><highlight class="normal"></highlight></codeline>
<codeline lineno="784"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="785"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="786"><highlight class="normal"></highlight></codeline>
<codeline lineno="787"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="788"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStreamDestroy(streams[i]);</highlight></codeline>
<codeline lineno="790"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="791"><highlight class="normal"></highlight></codeline>
<codeline lineno="792"><highlight class="normal">}</highlight></codeline>
<codeline lineno="793"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>bndmaskGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>Xev,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;float&gt;</ref><sp/>Flux);</highlight></codeline>
<codeline lineno="794"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>bndmaskGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>Xev,<sp/><ref refid="structFluxP" kindref="compound">FluxP&lt;double&gt;</ref><sp/>Flux);</highlight></codeline>
<codeline lineno="795"><highlight class="normal"></highlight></codeline>
<codeline lineno="796"><highlight class="normal"></highlight><highlight class="comment">//template<sp/>&lt;class<sp/>T&gt;<sp/>void<sp/>refine_linearCPU(Param<sp/>XParam,<sp/>int<sp/>ib,<sp/>bool<sp/>isLR,<sp/>bool<sp/>isoposit,<sp/>BlockP&lt;T&gt;<sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="797"><highlight class="normal"></highlight><highlight class="comment">//{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="798"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>int<sp/>Neighblock,<sp/>Mirrorblock;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="799"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="800"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>int<sp/>ir<sp/>=<sp/>isoposit<sp/>?<sp/>0<sp/>:<sp/>XParam.blkwidth<sp/>-<sp/>1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="801"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>int<sp/>iw<sp/>=<sp/>isoposit<sp/>?<sp/>XParam.blkwidth<sp/>:<sp/>-1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="802"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>if<sp/>(isLR)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="803"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="804"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/>Neighblock<sp/>=<sp/>isoposit<sp/>?<sp/>XBlock.RightBot[ib]<sp/>:<sp/>XBlock.LeftBot[ib];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="805"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/>Mirrorblock<sp/>=<sp/>isoposit<sp/>?<sp/>XBlock.LeftBot[Neighblock]<sp/>:<sp/>XBlock.RightBot[Neighblock]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="806"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="807"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="808"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="809"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/>Neighblock<sp/>=<sp/>isoposit<sp/>?<sp/>XBlock.TopLeft[ib]<sp/>:<sp/>XBlock.BotLeft[ib];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="810"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/>Mirrorblock<sp/>=<sp/>isoposit<sp/>?<sp/>XBlock.BotLeft[Neighblock]<sp/>:<sp/>XBlock.TopLeft[Neighblock]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="811"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="812"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="813"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>if<sp/>(XBlock.level[Neighblock]<sp/>&lt;<sp/>XBlock.level[ib])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="814"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="815"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>ilevdx<sp/>=<sp/>calcres(XParam.dx,<sp/>XBlock.level[ib])<sp/>*<sp/>T(0.25);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="816"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>ix<sp/>=<sp/>0;<sp/>ix<sp/>&lt;<sp/>XParam.blkwidth;<sp/>ix++)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="817"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/>{</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="818"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>jj<sp/>=<sp/>Mirrorblock<sp/>==<sp/>ib<sp/>?<sp/>floor(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>floor(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="819"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>il<sp/>=<sp/>isLR<sp/>?<sp/>memloc(XParam,<sp/>ir,<sp/>jj,<sp/>Neighblock)<sp/>:<sp/>memloc(XParam,<sp/>jj,<sp/>ir,<sp/>Neighblock);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="820"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>write<sp/>=<sp/>isLR<sp/>?<sp/>memloc(XParam,<sp/>iw,<sp/>j,<sp/>ib)<sp/>:<sp/>memloc(XParam,<sp/>j,<sp/>iw,<sp/>ib);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="821"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>T(-1.0);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="822"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&gt;<sp/>j<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="823"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="824"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[il]<sp/>+<sp/>(faclr<sp/>*<sp/>dzdx[il]<sp/>+<sp/>facbt<sp/>*<sp/>dzdy[il])<sp/>*<sp/>ilevdx;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="825"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="826"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="827"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="828"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="829"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/>}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="830"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="831"><highlight class="normal"></highlight><highlight class="comment">//}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="832"><highlight class="normal"></highlight><highlight class="comment">//template<sp/>void<sp/>refine_linearCPU&lt;float&gt;(Param<sp/>XParam,<sp/>int<sp/>ib,<sp/>BlockP&lt;float&gt;<sp/>XBlock,<sp/>float*<sp/>z,<sp/>float*<sp/>dzdx,<sp/>float*<sp/>dzdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="833"><highlight class="normal"></highlight><highlight class="comment">//template<sp/>void<sp/>refine_linearCPU&lt;double&gt;(Param<sp/>XParam,<sp/>int<sp/>ib,<sp/>BlockP&lt;double&gt;<sp/>XBlock,<sp/>double*<sp/>z,<sp/>double*<sp/>dzdx,<sp/>double*<sp/>dzdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="834"><highlight class="normal"></highlight></codeline>
<codeline lineno="835"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Left(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T<sp/>*<sp/>dzdx,<sp/>T<sp/>*<sp/>dzdy)</highlight></codeline>
<codeline lineno="836"><highlight class="normal">{</highlight></codeline>
<codeline lineno="837"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="838"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="839"><highlight class="normal"></highlight></codeline>
<codeline lineno="840"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ilevdx<sp/>=<sp/>calcres(XParam.delta,<sp/>XBlock.level[ib])*T(0.5);</highlight></codeline>
<codeline lineno="841"><highlight class="normal"></highlight></codeline>
<codeline lineno="842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.RightBot[XBlock.LeftBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(floor(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(floor(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>jj<sp/>,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>T(1.0);</highlight></codeline>
<codeline lineno="848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&lt;<sp/>(j-T(0.01))<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight></codeline>
<codeline lineno="849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[il]<sp/>+<sp/>(faclr*dzdx[il]+facbt*dzdy[il])<sp/>*<sp/>ilevdx;</highlight></codeline>
<codeline lineno="851"><highlight class="normal"></highlight></codeline>
<codeline lineno="852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight></codeline>
<codeline lineno="853"><highlight class="normal"></highlight></codeline>
<codeline lineno="854"><highlight class="normal"></highlight></codeline>
<codeline lineno="855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="856"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="857"><highlight class="normal">}</highlight></codeline>
<codeline lineno="858"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Left&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="859"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Left&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="860"><highlight class="normal"></highlight></codeline>
<codeline lineno="861"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_LeftGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,T*dzdy)</highlight></codeline>
<codeline lineno="862"><highlight class="normal">{</highlight></codeline>
<codeline lineno="863"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="864"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="865"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>ix<sp/>=<sp/>0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="866"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="867"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="868"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="869"><highlight class="normal"></highlight></codeline>
<codeline lineno="870"><highlight class="normal"></highlight></codeline>
<codeline lineno="871"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="872"><highlight class="normal"></highlight></codeline>
<codeline lineno="873"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="874"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>iy;</highlight></codeline>
<codeline lineno="876"><highlight class="normal"></highlight></codeline>
<codeline lineno="877"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ilevdx<sp/>=<sp/>calcres(XParam.delta,<sp/>XBlock.level[ib])<sp/>*<sp/>T(0.5);</highlight></codeline>
<codeline lineno="878"><highlight class="normal"></highlight></codeline>
<codeline lineno="879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.RightBot[XBlock.LeftBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>:<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="881"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="882"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>T(1.0);</highlight></codeline>
<codeline lineno="884"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&lt;<sp/>(j<sp/>-<sp/>T(0.01))<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight></codeline>
<codeline lineno="885"><highlight class="normal"></highlight></codeline>
<codeline lineno="886"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[il]<sp/>+<sp/>(faclr<sp/>*<sp/>dzdx[il]<sp/>+<sp/>facbt<sp/>*<sp/>dzdy[il])<sp/>*<sp/>ilevdx;</highlight></codeline>
<codeline lineno="887"><highlight class="normal"></highlight></codeline>
<codeline lineno="888"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight></codeline>
<codeline lineno="889"><highlight class="normal"></highlight></codeline>
<codeline lineno="890"><highlight class="normal"></highlight></codeline>
<codeline lineno="891"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="892"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="893"><highlight class="normal">}</highlight></codeline>
<codeline lineno="894"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_LeftGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="895"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_LeftGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="896"><highlight class="normal"></highlight></codeline>
<codeline lineno="897"><highlight class="normal"></highlight></codeline>
<codeline lineno="898"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Right(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight></codeline>
<codeline lineno="899"><highlight class="normal">{</highlight></codeline>
<codeline lineno="900"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="901"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="902"><highlight class="normal"></highlight></codeline>
<codeline lineno="903"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>ilevdx<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib]<sp/>)<sp/>*<sp/>T(0.5);</highlight></codeline>
<codeline lineno="904"><highlight class="normal"></highlight></codeline>
<codeline lineno="905"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="906"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="907"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.LeftBot[XBlock.RightBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(floor(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(floor(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="910"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>T(-1.0);</highlight></codeline>
<codeline lineno="911"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&lt;<sp/>(j<sp/>-<sp/>T(0.01))<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight></codeline>
<codeline lineno="912"><highlight class="normal"></highlight></codeline>
<codeline lineno="913"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[il]<sp/>+<sp/>(faclr<sp/>*<sp/>dzdx[il]<sp/>+<sp/>facbt<sp/>*<sp/>dzdy[il])<sp/>*<sp/>ilevdx;</highlight></codeline>
<codeline lineno="914"><highlight class="normal"></highlight></codeline>
<codeline lineno="915"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight></codeline>
<codeline lineno="916"><highlight class="normal"></highlight></codeline>
<codeline lineno="917"><highlight class="normal"></highlight></codeline>
<codeline lineno="918"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="919"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="920"><highlight class="normal">}</highlight></codeline>
<codeline lineno="921"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Right&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="922"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Right&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="923"><highlight class="normal"></highlight></codeline>
<codeline lineno="924"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_RightGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight></codeline>
<codeline lineno="925"><highlight class="normal">{</highlight></codeline>
<codeline lineno="926"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="927"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="928"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="929"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="930"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="931"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="932"><highlight class="normal"></highlight></codeline>
<codeline lineno="933"><highlight class="normal"></highlight></codeline>
<codeline lineno="934"><highlight class="normal"></highlight></codeline>
<codeline lineno="935"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="936"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="937"><highlight class="normal"></highlight></codeline>
<codeline lineno="938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ilevdx<sp/>=<sp/>calcres(XParam.delta,<sp/>XBlock.level[ib])<sp/>*<sp/>T(0.5);</highlight></codeline>
<codeline lineno="939"><highlight class="normal"></highlight></codeline>
<codeline lineno="940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>iy;</highlight></codeline>
<codeline lineno="941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.LeftBot[XBlock.RightBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>:<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="944"><highlight class="normal"></highlight></codeline>
<codeline lineno="945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>T(-1.0);</highlight></codeline>
<codeline lineno="946"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>floor(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&lt;<sp/>(j<sp/>-<sp/>T(0.01))<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight></codeline>
<codeline lineno="947"><highlight class="normal"></highlight></codeline>
<codeline lineno="948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[il]<sp/>+<sp/>(faclr<sp/>*<sp/>dzdx[il]<sp/>+<sp/>facbt<sp/>*<sp/>dzdy[il])<sp/>*<sp/>ilevdx;</highlight></codeline>
<codeline lineno="949"><highlight class="normal"></highlight></codeline>
<codeline lineno="950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight></codeline>
<codeline lineno="951"><highlight class="normal"></highlight></codeline>
<codeline lineno="952"><highlight class="normal"></highlight></codeline>
<codeline lineno="953"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="954"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="955"><highlight class="normal">}</highlight></codeline>
<codeline lineno="956"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_RightGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="957"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_RightGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="958"><highlight class="normal"></highlight></codeline>
<codeline lineno="959"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Bot(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight></codeline>
<codeline lineno="960"><highlight class="normal">{</highlight></codeline>
<codeline lineno="961"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="962"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="963"><highlight class="normal"></highlight></codeline>
<codeline lineno="964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>ilevdx<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib])<sp/>*<sp/>T(0.5);</highlight></codeline>
<codeline lineno="965"><highlight class="normal"></highlight></codeline>
<codeline lineno="966"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>XParam.blkwidth;<sp/>i++)</highlight></codeline>
<codeline lineno="967"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="968"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii<sp/>=<sp/>XBlock.TopLeft[XBlock.BotLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(floor(i<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(floor(i<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="969"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jl<sp/>=<sp/>memloc(XParam,<sp/><sp/>ii,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="970"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>i,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="971"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="972"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>T(1.0);</highlight></codeline>
<codeline lineno="973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>floor(i<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&lt;<sp/>(i<sp/>-<sp/>T(0.01))<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight></codeline>
<codeline lineno="974"><highlight class="normal"></highlight></codeline>
<codeline lineno="975"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[jl]<sp/>+<sp/>(faclr<sp/>*<sp/>dzdx[jl]<sp/>+<sp/>facbt<sp/>*<sp/>dzdy[jl])<sp/>*<sp/>ilevdx;</highlight></codeline>
<codeline lineno="976"><highlight class="normal"></highlight></codeline>
<codeline lineno="977"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight></codeline>
<codeline lineno="978"><highlight class="normal"></highlight></codeline>
<codeline lineno="979"><highlight class="normal"></highlight></codeline>
<codeline lineno="980"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="981"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="982"><highlight class="normal">}</highlight></codeline>
<codeline lineno="983"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Bot&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="984"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Bot&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="985"><highlight class="normal"></highlight></codeline>
<codeline lineno="986"><highlight class="normal"></highlight></codeline>
<codeline lineno="987"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_BotGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight></codeline>
<codeline lineno="988"><highlight class="normal">{</highlight></codeline>
<codeline lineno="989"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="990"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="991"><highlight class="normal"></highlight></codeline>
<codeline lineno="992"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="993"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="994"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="995"><highlight class="normal"></highlight></codeline>
<codeline lineno="996"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="997"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="998"><highlight class="normal"></highlight></codeline>
<codeline lineno="999"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ilevdx<sp/>=<sp/>calcres(XParam.delta,<sp/>XBlock.level[ib])<sp/>*<sp/>T(0.5);</highlight></codeline>
<codeline lineno="1000"><highlight class="normal"></highlight></codeline>
<codeline lineno="1001"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>ix;</highlight></codeline>
<codeline lineno="1002"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii<sp/>=<sp/>XBlock.TopLeft[XBlock.BotLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>floor(i<sp/>*<sp/>(T)0.5)<sp/>:<sp/>floor(i<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="1003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ii,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="1004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>i,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="1005"><highlight class="normal"></highlight></codeline>
<codeline lineno="1006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>T(1.0);</highlight></codeline>
<codeline lineno="1007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>floor(i<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&lt;<sp/>(i<sp/>-<sp/>T(0.01))<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight></codeline>
<codeline lineno="1008"><highlight class="normal"></highlight></codeline>
<codeline lineno="1009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[jl]<sp/>+<sp/>(faclr<sp/>*<sp/>dzdx[jl]<sp/>+<sp/>facbt<sp/>*<sp/>dzdy[jl])<sp/>*<sp/>ilevdx;</highlight></codeline>
<codeline lineno="1010"><highlight class="normal"></highlight></codeline>
<codeline lineno="1011"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight></codeline>
<codeline lineno="1012"><highlight class="normal"></highlight></codeline>
<codeline lineno="1013"><highlight class="normal"></highlight></codeline>
<codeline lineno="1014"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1015"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1016"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1017"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_BotGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1018"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_BotGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1019"><highlight class="normal"></highlight></codeline>
<codeline lineno="1020"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Top(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight></codeline>
<codeline lineno="1021"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1022"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="1023"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1024"><highlight class="normal"></highlight></codeline>
<codeline lineno="1025"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ilevdx<sp/>=<sp/>calcres(XParam.delta,<sp/>XBlock.level[ib])<sp/>*<sp/>T(0.5);</highlight></codeline>
<codeline lineno="1026"><highlight class="normal"></highlight></codeline>
<codeline lineno="1027"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>XParam.blkwidth;<sp/>i++)</highlight></codeline>
<codeline lineno="1028"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii<sp/>=<sp/>XBlock.BotLeft[XBlock.TopLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(floor(i<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(floor(i<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="1030"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jl<sp/>=<sp/>memloc(XParam,<sp/>ii<sp/>,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="1031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>i,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="1032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1033"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>T(-1.0);</highlight></codeline>
<codeline lineno="1034"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>floor(i<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&lt;<sp/>(i<sp/>-<sp/>T(0.01))<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight></codeline>
<codeline lineno="1035"><highlight class="normal"></highlight></codeline>
<codeline lineno="1036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[jl]<sp/>+<sp/>(faclr<sp/>*<sp/>dzdx[jl]<sp/>+<sp/>facbt<sp/>*<sp/>dzdy[jl])<sp/>*<sp/>ilevdx;</highlight></codeline>
<codeline lineno="1037"><highlight class="normal"></highlight></codeline>
<codeline lineno="1038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight></codeline>
<codeline lineno="1039"><highlight class="normal"></highlight></codeline>
<codeline lineno="1040"><highlight class="normal"></highlight></codeline>
<codeline lineno="1041"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1042"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1043"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1044"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Top&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1045"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_Top&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1046"><highlight class="normal"></highlight></codeline>
<codeline lineno="1047"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_TopGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight></codeline>
<codeline lineno="1048"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1049"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1050"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1051"><highlight class="normal"></highlight></codeline>
<codeline lineno="1052"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="1053"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="1054"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1055"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="1056"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1057"><highlight class="normal"></highlight></codeline>
<codeline lineno="1058"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ilevdx<sp/>=<sp/>calcres(XParam.delta,<sp/>XBlock.level[ib])<sp/>*<sp/>T(0.5);</highlight></codeline>
<codeline lineno="1059"><highlight class="normal"></highlight></codeline>
<codeline lineno="1060"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>ix;</highlight></codeline>
<codeline lineno="1061"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii<sp/>=<sp/>XBlock.BotLeft[XBlock.TopLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>floor(i<sp/>*<sp/>(T)0.5)<sp/>:<sp/>floor(i<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="1062"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ii<sp/>,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="1063"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>i,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="1064"><highlight class="normal"></highlight></codeline>
<codeline lineno="1065"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>facbt<sp/>=<sp/>T(-1.0);</highlight></codeline>
<codeline lineno="1066"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>faclr<sp/>=<sp/>floor(i<sp/>*<sp/>(T)0.5)<sp/>*<sp/>T(2.0)<sp/>&lt;<sp/>(i<sp/>-<sp/>T(0.01))<sp/>?<sp/>1.0<sp/>:<sp/>-1.0;</highlight></codeline>
<codeline lineno="1067"><highlight class="normal"></highlight></codeline>
<codeline lineno="1068"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>newz<sp/>=<sp/>z[jl]<sp/>+<sp/>(faclr<sp/>*<sp/>dzdx[jl]<sp/>+<sp/>facbt<sp/>*<sp/>dzdy[jl])<sp/>*<sp/>ilevdx;</highlight></codeline>
<codeline lineno="1069"><highlight class="normal"></highlight></codeline>
<codeline lineno="1070"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>newz;</highlight></codeline>
<codeline lineno="1071"><highlight class="normal"></highlight></codeline>
<codeline lineno="1072"><highlight class="normal"></highlight></codeline>
<codeline lineno="1073"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1074"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1075"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1076"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_TopGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1077"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear_TopGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1078"><highlight class="normal"></highlight></codeline>
<codeline lineno="1079"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight></codeline>
<codeline lineno="1080"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1081"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="1082"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1083"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1084"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refine_linear_Left(XParam,<sp/>ib,<sp/>XBlock,<sp/>z,<sp/>dzdx,<sp/>dzdy);</highlight></codeline>
<codeline lineno="1085"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refine_linear_Right(XParam,<sp/>ib,<sp/>XBlock,<sp/>z,<sp/>dzdx,<sp/>dzdy);</highlight></codeline>
<codeline lineno="1086"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refine_linear_Top(XParam,<sp/>ib,<sp/>XBlock,<sp/>z,<sp/>dzdx,<sp/>dzdy);</highlight></codeline>
<codeline lineno="1087"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refine_linear_Bot(XParam,<sp/>ib,<sp/>XBlock,<sp/>z,<sp/>dzdx,<sp/>dzdy);</highlight></codeline>
<codeline lineno="1088"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1089"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1090"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1091"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linear&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1092"><highlight class="normal"></highlight></codeline>
<codeline lineno="1093"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linearGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z,<sp/>T*<sp/>dzdx,<sp/>T*<sp/>dzdy)</highlight></codeline>
<codeline lineno="1094"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1095"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloLR(1,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="1096"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimHaloBT(XParam.blkwidth,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="1097"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="1098"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1099"><highlight class="normal"><sp/><sp/><sp/><sp/>refine_linear_LeftGPU&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0&gt;&gt;&gt;(XParam,<sp/>XBlock,<sp/>z,<sp/>dzdx,<sp/>dzdy);</highlight></codeline>
<codeline lineno="1100"><highlight class="normal"><sp/><sp/><sp/><sp/>refine_linear_RightGPU<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z,<sp/>dzdx,<sp/>dzdy);</highlight></codeline>
<codeline lineno="1101"><highlight class="normal"><sp/><sp/><sp/><sp/>refine_linear_TopGPU<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z,<sp/>dzdx,<sp/>dzdy);</highlight></codeline>
<codeline lineno="1102"><highlight class="normal"><sp/><sp/><sp/><sp/>refine_linear_BotGPU<sp/>&lt;&lt;&lt;gridDim,<sp/>blockDimHaloBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>z,<sp/>dzdx,<sp/>dzdy);</highlight></codeline>
<codeline lineno="1103"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="1104"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1105"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1106"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linearGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1107"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>refine_linearGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dzdy);</highlight></codeline>
<codeline lineno="1108"><highlight class="normal"></highlight></codeline>
<codeline lineno="1109"><highlight class="normal"></highlight></codeline>
<codeline lineno="1110"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>HaloFluxCPULR(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T<sp/>*z)</highlight></codeline>
<codeline lineno="1111"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1112"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>i,il,itl;</highlight></codeline>
<codeline lineno="1113"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1114"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="1116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1119"><highlight class="normal"></highlight></codeline>
<codeline lineno="1120"><highlight class="normal"></highlight></codeline>
<codeline lineno="1121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j*2;</highlight></codeline>
<codeline lineno="1122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>jj+1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1124"><highlight class="normal"></highlight></codeline>
<codeline lineno="1125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1127"><highlight class="normal"></highlight></codeline>
<codeline lineno="1128"><highlight class="normal"></highlight></codeline>
<codeline lineno="1129"><highlight class="normal"></highlight></codeline>
<codeline lineno="1130"><highlight class="normal"></highlight></codeline>
<codeline lineno="1131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1133"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1134"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1135"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="1137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1140"><highlight class="normal"></highlight></codeline>
<codeline lineno="1141"><highlight class="normal"></highlight></codeline>
<codeline lineno="1142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1145"><highlight class="normal"></highlight></codeline>
<codeline lineno="1146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1147"><highlight class="normal"></highlight></codeline>
<codeline lineno="1148"><highlight class="normal"></highlight></codeline>
<codeline lineno="1149"><highlight class="normal"></highlight></codeline>
<codeline lineno="1150"><highlight class="normal"></highlight></codeline>
<codeline lineno="1151"><highlight class="normal"></highlight></codeline>
<codeline lineno="1152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1154"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1155"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1156"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="1158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1161"><highlight class="normal"></highlight></codeline>
<codeline lineno="1162"><highlight class="normal"></highlight></codeline>
<codeline lineno="1163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1166"><highlight class="normal"></highlight></codeline>
<codeline lineno="1167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1168"><highlight class="normal"></highlight></codeline>
<codeline lineno="1169"><highlight class="normal"></highlight></codeline>
<codeline lineno="1170"><highlight class="normal"></highlight></codeline>
<codeline lineno="1171"><highlight class="normal"></highlight></codeline>
<codeline lineno="1172"><highlight class="normal"></highlight></codeline>
<codeline lineno="1173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1175"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1176"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightTop[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1177"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="1179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1188"><highlight class="normal"></highlight></codeline>
<codeline lineno="1189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1190"><highlight class="normal"></highlight></codeline>
<codeline lineno="1191"><highlight class="normal"></highlight></codeline>
<codeline lineno="1192"><highlight class="normal"></highlight></codeline>
<codeline lineno="1193"><highlight class="normal"></highlight></codeline>
<codeline lineno="1194"><highlight class="normal"></highlight></codeline>
<codeline lineno="1195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1197"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1198"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1199"><highlight class="normal"></highlight></codeline>
<codeline lineno="1200"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>HaloFluxGPULR(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="1201"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1202"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>i,<sp/>il,<sp/>itl;</highlight></codeline>
<codeline lineno="1203"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1204"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1205"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>ix<sp/>=<sp/>0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1206"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="1207"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="1208"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1209"><highlight class="normal"></highlight></codeline>
<codeline lineno="1210"><highlight class="normal"></highlight></codeline>
<codeline lineno="1211"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>iy;</highlight></codeline>
<codeline lineno="1212"><highlight class="normal"></highlight></codeline>
<codeline lineno="1213"><highlight class="normal"></highlight></codeline>
<codeline lineno="1214"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1215"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1221"><highlight class="normal"></highlight></codeline>
<codeline lineno="1222"><highlight class="normal"></highlight></codeline>
<codeline lineno="1223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1226"><highlight class="normal"></highlight></codeline>
<codeline lineno="1227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1228"><highlight class="normal"></highlight></codeline>
<codeline lineno="1229"><highlight class="normal"></highlight></codeline>
<codeline lineno="1230"><highlight class="normal"></highlight></codeline>
<codeline lineno="1231"><highlight class="normal"></highlight></codeline>
<codeline lineno="1232"><highlight class="normal"></highlight></codeline>
<codeline lineno="1233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1235"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1236"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1237"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1243"><highlight class="normal"></highlight></codeline>
<codeline lineno="1244"><highlight class="normal"></highlight></codeline>
<codeline lineno="1245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1248"><highlight class="normal"></highlight></codeline>
<codeline lineno="1249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1250"><highlight class="normal"></highlight></codeline>
<codeline lineno="1251"><highlight class="normal"></highlight></codeline>
<codeline lineno="1252"><highlight class="normal"></highlight></codeline>
<codeline lineno="1253"><highlight class="normal"></highlight></codeline>
<codeline lineno="1254"><highlight class="normal"></highlight></codeline>
<codeline lineno="1255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1257"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1258"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1259"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1265"><highlight class="normal"></highlight></codeline>
<codeline lineno="1266"><highlight class="normal"></highlight></codeline>
<codeline lineno="1267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1270"><highlight class="normal"></highlight></codeline>
<codeline lineno="1271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1272"><highlight class="normal"></highlight></codeline>
<codeline lineno="1273"><highlight class="normal"></highlight></codeline>
<codeline lineno="1274"><highlight class="normal"></highlight></codeline>
<codeline lineno="1275"><highlight class="normal"></highlight></codeline>
<codeline lineno="1276"><highlight class="normal"></highlight></codeline>
<codeline lineno="1277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1279"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1280"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightTop[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1281"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1284"><highlight class="normal"></highlight></codeline>
<codeline lineno="1285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1288"><highlight class="normal"></highlight></codeline>
<codeline lineno="1289"><highlight class="normal"></highlight></codeline>
<codeline lineno="1290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1292"><highlight class="normal"></highlight></codeline>
<codeline lineno="1293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1294"><highlight class="normal"></highlight></codeline>
<codeline lineno="1295"><highlight class="normal"></highlight></codeline>
<codeline lineno="1296"><highlight class="normal"></highlight></codeline>
<codeline lineno="1297"><highlight class="normal"></highlight></codeline>
<codeline lineno="1298"><highlight class="normal"></highlight></codeline>
<codeline lineno="1299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1301"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1302"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1303"><highlight class="normal"></highlight></codeline>
<codeline lineno="1304"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>HaloFluxGPULRnew(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="1305"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1306"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>i,<sp/>il,<sp/>itl;</highlight></codeline>
<codeline lineno="1307"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1308"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1309"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>ix<sp/>=<sp/>0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1310"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="1311"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;</highlight></codeline>
<codeline lineno="1312"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ibl<sp/>&lt;<sp/>XParam.nblk)</highlight></codeline>
<codeline lineno="1313"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1314"><highlight class="normal"></highlight></codeline>
<codeline lineno="1315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1316"><highlight class="normal"></highlight></codeline>
<codeline lineno="1317"><highlight class="normal"></highlight></codeline>
<codeline lineno="1318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>iy;</highlight></codeline>
<codeline lineno="1319"><highlight class="normal"></highlight></codeline>
<codeline lineno="1320"><highlight class="normal"></highlight></codeline>
<codeline lineno="1321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1323"><highlight class="normal"></highlight></codeline>
<codeline lineno="1324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1328"><highlight class="normal"></highlight></codeline>
<codeline lineno="1329"><highlight class="normal"></highlight></codeline>
<codeline lineno="1330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1333"><highlight class="normal"></highlight></codeline>
<codeline lineno="1334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1335"><highlight class="normal"></highlight></codeline>
<codeline lineno="1336"><highlight class="normal"></highlight></codeline>
<codeline lineno="1337"><highlight class="normal"></highlight></codeline>
<codeline lineno="1338"><highlight class="normal"></highlight></codeline>
<codeline lineno="1339"><highlight class="normal"></highlight></codeline>
<codeline lineno="1340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1345"><highlight class="normal"></highlight></codeline>
<codeline lineno="1346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1347"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1350"><highlight class="normal"></highlight></codeline>
<codeline lineno="1351"><highlight class="normal"></highlight></codeline>
<codeline lineno="1352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1355"><highlight class="normal"></highlight></codeline>
<codeline lineno="1356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1357"><highlight class="normal"></highlight></codeline>
<codeline lineno="1358"><highlight class="normal"></highlight></codeline>
<codeline lineno="1359"><highlight class="normal"></highlight></codeline>
<codeline lineno="1360"><highlight class="normal"></highlight></codeline>
<codeline lineno="1361"><highlight class="normal"></highlight></codeline>
<codeline lineno="1362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1367"><highlight class="normal"></highlight></codeline>
<codeline lineno="1368"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1372"><highlight class="normal"></highlight></codeline>
<codeline lineno="1373"><highlight class="normal"></highlight></codeline>
<codeline lineno="1374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1377"><highlight class="normal"></highlight></codeline>
<codeline lineno="1378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1379"><highlight class="normal"></highlight></codeline>
<codeline lineno="1380"><highlight class="normal"></highlight></codeline>
<codeline lineno="1381"><highlight class="normal"></highlight></codeline>
<codeline lineno="1382"><highlight class="normal"></highlight></codeline>
<codeline lineno="1383"><highlight class="normal"></highlight></codeline>
<codeline lineno="1384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightTop[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1391"><highlight class="normal"></highlight></codeline>
<codeline lineno="1392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1394"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1395"><highlight class="normal"></highlight></codeline>
<codeline lineno="1396"><highlight class="normal"></highlight></codeline>
<codeline lineno="1397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1398"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1399"><highlight class="normal"></highlight></codeline>
<codeline lineno="1400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1401"><highlight class="normal"></highlight></codeline>
<codeline lineno="1402"><highlight class="normal"></highlight></codeline>
<codeline lineno="1403"><highlight class="normal"></highlight></codeline>
<codeline lineno="1404"><highlight class="normal"></highlight></codeline>
<codeline lineno="1405"><highlight class="normal"></highlight></codeline>
<codeline lineno="1406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1408"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1409"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1410"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1411"><highlight class="normal"></highlight></codeline>
<codeline lineno="1412"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>HaloFluxCPUBT(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="1413"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1414"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>i,<sp/>il,<sp/>itl;</highlight></codeline>
<codeline lineno="1415"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1416"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="1418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="1421"><highlight class="normal"></highlight></codeline>
<codeline lineno="1422"><highlight class="normal"></highlight></codeline>
<codeline lineno="1423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>XParam.blkwidth,<sp/><sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="1425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam,<sp/>jj+1,<sp/>XParam.blkwidth,<sp/><sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="1426"><highlight class="normal"></highlight></codeline>
<codeline lineno="1427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1428"><highlight class="normal"></highlight></codeline>
<codeline lineno="1429"><highlight class="normal"></highlight></codeline>
<codeline lineno="1430"><highlight class="normal"></highlight></codeline>
<codeline lineno="1431"><highlight class="normal"></highlight></codeline>
<codeline lineno="1432"><highlight class="normal"></highlight></codeline>
<codeline lineno="1433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1434"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1435"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1436"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotRight[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1437"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1438"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="1439"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1440"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1441"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="1442"><highlight class="normal"></highlight></codeline>
<codeline lineno="1443"><highlight class="normal"></highlight></codeline>
<codeline lineno="1444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1445"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam,<sp/><sp/>jj,<sp/>XParam.blkwidth,<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="1446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam,<sp/><sp/>jj<sp/>+<sp/>1,<sp/>XParam.blkwidth,<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="1447"><highlight class="normal"></highlight></codeline>
<codeline lineno="1448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1449"><highlight class="normal"></highlight></codeline>
<codeline lineno="1450"><highlight class="normal"></highlight></codeline>
<codeline lineno="1451"><highlight class="normal"></highlight></codeline>
<codeline lineno="1452"><highlight class="normal"></highlight></codeline>
<codeline lineno="1453"><highlight class="normal"></highlight></codeline>
<codeline lineno="1454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1456"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1457"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1458"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="1460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="1463"><highlight class="normal"></highlight></codeline>
<codeline lineno="1464"><highlight class="normal"></highlight></codeline>
<codeline lineno="1465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>0,<sp/><sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="1467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="1468"><highlight class="normal"></highlight></codeline>
<codeline lineno="1469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1470"><highlight class="normal"></highlight></codeline>
<codeline lineno="1471"><highlight class="normal"></highlight></codeline>
<codeline lineno="1472"><highlight class="normal"></highlight></codeline>
<codeline lineno="1473"><highlight class="normal"></highlight></codeline>
<codeline lineno="1474"><highlight class="normal"></highlight></codeline>
<codeline lineno="1475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1477"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1478"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopRight[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1479"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="1481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1482"><highlight class="normal"></highlight></codeline>
<codeline lineno="1483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="1486"><highlight class="normal"></highlight></codeline>
<codeline lineno="1487"><highlight class="normal"></highlight></codeline>
<codeline lineno="1488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="1489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="1490"><highlight class="normal"></highlight></codeline>
<codeline lineno="1491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1492"><highlight class="normal"></highlight></codeline>
<codeline lineno="1493"><highlight class="normal"></highlight></codeline>
<codeline lineno="1494"><highlight class="normal"></highlight></codeline>
<codeline lineno="1495"><highlight class="normal"></highlight></codeline>
<codeline lineno="1496"><highlight class="normal"></highlight></codeline>
<codeline lineno="1497"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1499"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1500"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1501"><highlight class="normal"></highlight></codeline>
<codeline lineno="1502"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>HaloFluxGPUBT(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="1503"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1504"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>i,<sp/>il,<sp/>itl;</highlight></codeline>
<codeline lineno="1505"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1506"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1507"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="1508"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>iy<sp/>=<sp/>threadIdx.x;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1509"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="1510"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1511"><highlight class="normal"></highlight></codeline>
<codeline lineno="1512"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>ix;</highlight></codeline>
<codeline lineno="1513"><highlight class="normal"></highlight></codeline>
<codeline lineno="1514"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1515"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>j,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="1520"><highlight class="normal"></highlight></codeline>
<codeline lineno="1521"><highlight class="normal"></highlight></codeline>
<codeline lineno="1522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>XParam.blkwidth,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="1524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XParam.blkwidth,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="1525"><highlight class="normal"></highlight></codeline>
<codeline lineno="1526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1527"><highlight class="normal"></highlight></codeline>
<codeline lineno="1528"><highlight class="normal"></highlight></codeline>
<codeline lineno="1529"><highlight class="normal"></highlight></codeline>
<codeline lineno="1530"><highlight class="normal"></highlight></codeline>
<codeline lineno="1531"><highlight class="normal"></highlight></codeline>
<codeline lineno="1532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1534"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1535"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotRight[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1536"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>j,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="1541"><highlight class="normal"></highlight></codeline>
<codeline lineno="1542"><highlight class="normal"></highlight></codeline>
<codeline lineno="1543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>XParam.blkwidth,<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="1545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XParam.blkwidth,<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="1546"><highlight class="normal"></highlight></codeline>
<codeline lineno="1547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1548"><highlight class="normal"></highlight></codeline>
<codeline lineno="1549"><highlight class="normal"></highlight></codeline>
<codeline lineno="1550"><highlight class="normal"></highlight></codeline>
<codeline lineno="1551"><highlight class="normal"></highlight></codeline>
<codeline lineno="1552"><highlight class="normal"></highlight></codeline>
<codeline lineno="1553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1555"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1556"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1557"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1558"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1560"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1561"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="1562"><highlight class="normal"></highlight></codeline>
<codeline lineno="1563"><highlight class="normal"></highlight></codeline>
<codeline lineno="1564"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1565"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="1566"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="1567"><highlight class="normal"></highlight></codeline>
<codeline lineno="1568"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1569"><highlight class="normal"></highlight></codeline>
<codeline lineno="1570"><highlight class="normal"></highlight></codeline>
<codeline lineno="1571"><highlight class="normal"></highlight></codeline>
<codeline lineno="1572"><highlight class="normal"></highlight></codeline>
<codeline lineno="1573"><highlight class="normal"></highlight></codeline>
<codeline lineno="1574"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1575"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1576"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1577"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopRight[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1578"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1579"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1580"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1581"><highlight class="normal"></highlight></codeline>
<codeline lineno="1582"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1583"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1584"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="1585"><highlight class="normal"></highlight></codeline>
<codeline lineno="1586"><highlight class="normal"></highlight></codeline>
<codeline lineno="1587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="1588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="1589"><highlight class="normal"></highlight></codeline>
<codeline lineno="1590"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1591"><highlight class="normal"></highlight></codeline>
<codeline lineno="1592"><highlight class="normal"></highlight></codeline>
<codeline lineno="1593"><highlight class="normal"></highlight></codeline>
<codeline lineno="1594"><highlight class="normal"></highlight></codeline>
<codeline lineno="1595"><highlight class="normal"></highlight></codeline>
<codeline lineno="1596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1598"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1599"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1600"><highlight class="normal"></highlight></codeline>
<codeline lineno="1601"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>HaloFluxGPUBTnew(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="1602"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1603"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>i,<sp/>il,<sp/>itl;</highlight></codeline>
<codeline lineno="1604"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1605"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1606"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="1607"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>iy<sp/>=<sp/>threadIdx.x;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1608"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>threadIdx.y<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.y;</highlight></codeline>
<codeline lineno="1609"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ibl<sp/>&lt;<sp/>XParam.nblk)</highlight></codeline>
<codeline lineno="1610"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1611"><highlight class="normal"></highlight></codeline>
<codeline lineno="1612"><highlight class="normal"></highlight></codeline>
<codeline lineno="1613"><highlight class="normal"></highlight></codeline>
<codeline lineno="1614"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1615"><highlight class="normal"></highlight></codeline>
<codeline lineno="1616"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>ix;</highlight></codeline>
<codeline lineno="1617"><highlight class="normal"></highlight></codeline>
<codeline lineno="1618"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1619"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1620"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1623"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>j,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="1624"><highlight class="normal"></highlight></codeline>
<codeline lineno="1625"><highlight class="normal"></highlight></codeline>
<codeline lineno="1626"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>XParam.blkwidth,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="1628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XParam.blkwidth,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="1629"><highlight class="normal"></highlight></codeline>
<codeline lineno="1630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1631"><highlight class="normal"></highlight></codeline>
<codeline lineno="1632"><highlight class="normal"></highlight></codeline>
<codeline lineno="1633"><highlight class="normal"></highlight></codeline>
<codeline lineno="1634"><highlight class="normal"></highlight></codeline>
<codeline lineno="1635"><highlight class="normal"></highlight></codeline>
<codeline lineno="1636"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1637"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1638"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1639"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotRight[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>j,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="1645"><highlight class="normal"></highlight></codeline>
<codeline lineno="1646"><highlight class="normal"></highlight></codeline>
<codeline lineno="1647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>XParam.blkwidth,<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="1649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>XParam.blkwidth,<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="1650"><highlight class="normal"></highlight></codeline>
<codeline lineno="1651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1652"><highlight class="normal"></highlight></codeline>
<codeline lineno="1653"><highlight class="normal"></highlight></codeline>
<codeline lineno="1654"><highlight class="normal"></highlight></codeline>
<codeline lineno="1655"><highlight class="normal"></highlight></codeline>
<codeline lineno="1656"><highlight class="normal"></highlight></codeline>
<codeline lineno="1657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1663"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1664"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1665"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="1666"><highlight class="normal"></highlight></codeline>
<codeline lineno="1667"><highlight class="normal"></highlight></codeline>
<codeline lineno="1668"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="1670"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="1671"><highlight class="normal"></highlight></codeline>
<codeline lineno="1672"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1673"><highlight class="normal"></highlight></codeline>
<codeline lineno="1674"><highlight class="normal"></highlight></codeline>
<codeline lineno="1675"><highlight class="normal"></highlight></codeline>
<codeline lineno="1676"><highlight class="normal"></highlight></codeline>
<codeline lineno="1677"><highlight class="normal"></highlight></codeline>
<codeline lineno="1678"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1679"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1680"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1681"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopRight[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1682"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1683"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1684"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1685"><highlight class="normal"></highlight></codeline>
<codeline lineno="1686"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="1689"><highlight class="normal"></highlight></codeline>
<codeline lineno="1690"><highlight class="normal"></highlight></codeline>
<codeline lineno="1691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>il<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="1692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itl<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="1693"><highlight class="normal"></highlight></codeline>
<codeline lineno="1694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[il]<sp/>+<sp/>z[itl]);</highlight></codeline>
<codeline lineno="1695"><highlight class="normal"></highlight></codeline>
<codeline lineno="1696"><highlight class="normal"></highlight></codeline>
<codeline lineno="1697"><highlight class="normal"></highlight></codeline>
<codeline lineno="1698"><highlight class="normal"></highlight></codeline>
<codeline lineno="1699"><highlight class="normal"></highlight></codeline>
<codeline lineno="1700"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1701"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1703"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1704"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1705"><highlight class="normal"></highlight></codeline>
<codeline lineno="1706"><highlight class="normal"></highlight></codeline>
<codeline lineno="1707"><highlight class="normal"></highlight></codeline>
<codeline lineno="1708"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillLeft(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>&amp;z)</highlight></codeline>
<codeline lineno="1709"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1710"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,bb;</highlight></codeline>
<codeline lineno="1711"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>write;</highlight></codeline>
<codeline lineno="1712"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="1713"><highlight class="normal"></highlight></codeline>
<codeline lineno="1714"><highlight class="normal"></highlight></codeline>
<codeline lineno="1715"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1716"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="1718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1719"><highlight class="normal"></highlight></codeline>
<codeline lineno="1720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="1723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1724"><highlight class="normal"></highlight></codeline>
<codeline lineno="1725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="1728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1730"><highlight class="normal"></highlight></codeline>
<codeline lineno="1731"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="1734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1738"><highlight class="normal"></highlight></codeline>
<codeline lineno="1739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="1740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1742"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1747"><highlight class="normal"></highlight></codeline>
<codeline lineno="1748"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="1749"><highlight class="normal"></highlight></codeline>
<codeline lineno="1750"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1752"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1753"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[<sp/>XBlock.LeftBot[ib]<sp/>])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1754"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="1756"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1757"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1758"><highlight class="normal"></highlight></codeline>
<codeline lineno="1759"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>j,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="1762"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1763"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1764"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]<sp/>]&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="1765"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1766"><highlight class="normal"></highlight></codeline>
<codeline lineno="1767"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth<sp/>/<sp/>2;<sp/>j++)</highlight></codeline>
<codeline lineno="1768"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1769"><highlight class="normal"></highlight></codeline>
<codeline lineno="1770"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1771"><highlight class="normal"></highlight></codeline>
<codeline lineno="1772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1773"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.LeftBot[ib];</highlight></codeline>
<codeline lineno="1774"><highlight class="normal"></highlight></codeline>
<codeline lineno="1775"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="1776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="1777"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="1778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="1779"><highlight class="normal"></highlight></codeline>
<codeline lineno="1780"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="1781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1783"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="1784"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1785"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="1786"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1788"><highlight class="normal"></highlight></codeline>
<codeline lineno="1789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1790"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1791"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="1792"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1793"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1794"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="1797"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>(XParam.blkwidth<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.LeftTop[ib];</highlight></codeline>
<codeline lineno="1801"><highlight class="normal"></highlight></codeline>
<codeline lineno="1802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1803"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>z[read];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1805"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="1806"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="1807"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="1808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="1809"><highlight class="normal"></highlight></codeline>
<codeline lineno="1810"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="1811"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1812"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1813"><highlight class="normal"></highlight></codeline>
<codeline lineno="1814"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1815"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1816"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1817"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="1818"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1819"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1820"><highlight class="normal"></highlight></codeline>
<codeline lineno="1821"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="1822"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1823"><highlight class="normal"></highlight></codeline>
<codeline lineno="1824"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.RightBot[XBlock.LeftBot[ib]]<sp/>==<sp/>ib?<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5)):<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5)+<sp/>XParam.blkwidth/2);</highlight></codeline>
<codeline lineno="1825"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>3.0);</highlight></codeline>
<codeline lineno="1826"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>j<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="1827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>j<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="1828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1829"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="1830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir=<sp/>memloc(XParam,<sp/>XParam.blkwidth-1,<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth-1,<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//2<sp/>scenarios<sp/>here<sp/>ib<sp/>is<sp/>the<sp/>rightbot<sp/>neighbour<sp/>of<sp/>the<sp/>leftbot<sp/>block<sp/>or<sp/>ib<sp/>is<sp/>the<sp/>righttop<sp/>neighbour</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1833"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightBot[XBlock.LeftBot[ib]]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="1834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="1836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[XBlock.LeftBot[ib]]<sp/>==<sp/>XBlock.LeftBot[ib])<sp/></highlight><highlight class="comment">//<sp/>no<sp/>botom<sp/>of<sp/>leftbot<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1838"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(0.5)<sp/>*<sp/>(T(1.0)<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="1840"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="1841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="1842"><highlight class="normal"></highlight></codeline>
<codeline lineno="1843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotRight[XBlock.LeftBot[ib]]]<sp/>&lt;<sp/>XBlock.level[XBlock.LeftBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>but<sp/>is<sp/>coarser</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="1847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="1848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="1849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth-1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotRight[XBlock.LeftBot[ib]]);</highlight></codeline>
<codeline lineno="1850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotRight[XBlock.LeftBot[ib]]]<sp/>==<sp/>XBlock.level[XBlock.LeftBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>same<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1853"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotRight[XBlock.LeftBot[ib]]);</highlight></codeline>
<codeline lineno="1854"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotRight[XBlock.LeftBot[ib]]]<sp/>&gt;<sp/>XBlock.level[XBlock.LeftBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>higher<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1857"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="1858"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="1859"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="1860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotRight[XBlock.LeftBot[ib]]);</highlight></codeline>
<codeline lineno="1861"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1862"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1864"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1865"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="comment">//righttopleftif<sp/>==<sp/>ib</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1870"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>(XParam.blkwidth<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="1871"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1872"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[XBlock.LeftTop[ib]]<sp/>==<sp/>XBlock.LeftTop[ib])<sp/></highlight><highlight class="comment">//<sp/>no<sp/>botom<sp/>of<sp/>leftbot<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1873"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(0.5*(1.0-w1));</highlight></codeline>
<codeline lineno="1875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="1876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="1877"><highlight class="normal"></highlight></codeline>
<codeline lineno="1878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopRight[XBlock.LeftTop[ib]]]<sp/>&lt;<sp/>XBlock.level[XBlock.LeftTop[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>but<sp/>is<sp/>coarser</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1881"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="1882"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="1883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="1884"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,0,<sp/>XBlock.TopRight[XBlock.LeftTop[ib]]);</highlight></codeline>
<codeline lineno="1885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1886"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopRight[XBlock.LeftTop[ib]]]<sp/>==<sp/>XBlock.level[XBlock.LeftTop[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>same<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1887"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1888"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>0,<sp/>XBlock.TopRight[XBlock.LeftTop[ib]]);</highlight></codeline>
<codeline lineno="1889"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1890"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopRight[XBlock.LeftTop[ib]]]<sp/>&gt;<sp/>XBlock.level[XBlock.LeftTop[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>higher<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1891"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1892"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="1893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="1894"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="1895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>0,<sp/>XBlock.TopRight[XBlock.LeftTop[ib]]);</highlight></codeline>
<codeline lineno="1896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1897"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1898"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1899"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1900"><highlight class="normal"></highlight></codeline>
<codeline lineno="1901"><highlight class="normal"></highlight></codeline>
<codeline lineno="1902"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>w1<sp/>*<sp/>z[ii]<sp/>+<sp/>w2<sp/>*<sp/>z[ir]<sp/>+<sp/>w3<sp/>*<sp/>z[it];</highlight></codeline>
<codeline lineno="1903"><highlight class="normal"></highlight></codeline>
<codeline lineno="1904"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1905"><highlight class="normal"></highlight></codeline>
<codeline lineno="1906"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1907"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1908"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1909"><highlight class="normal"></highlight></codeline>
<codeline lineno="1910"><highlight class="normal"></highlight></codeline>
<codeline lineno="1911"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1912"><highlight class="normal"></highlight></codeline>
<codeline lineno="1913"><highlight class="normal"></highlight></codeline>
<codeline lineno="1914"><highlight class="normal"></highlight></codeline>
<codeline lineno="1915"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillLeft(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>topright,<sp/>T<sp/>*<sp/>a)</highlight></codeline>
<codeline lineno="1916"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1917"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1918"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1919"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>ix<sp/>=<sp/>0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1920"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="1921"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="1922"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="1923"><highlight class="normal"></highlight></codeline>
<codeline lineno="1924"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="1925"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LB<sp/>=<sp/>leftbot[ib];</highlight></codeline>
<codeline lineno="1926"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LT<sp/>=<sp/>lefttop[ib];</highlight></codeline>
<codeline lineno="1927"><highlight class="normal"></highlight></codeline>
<codeline lineno="1928"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RBLB<sp/>=<sp/>rightbot[LB];</highlight></codeline>
<codeline lineno="1929"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BRLB<sp/>=<sp/>botright[LB];</highlight></codeline>
<codeline lineno="1930"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TRLT<sp/>=<sp/>topright[LT];</highlight></codeline>
<codeline lineno="1931"><highlight class="normal"></highlight></codeline>
<codeline lineno="1932"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levBRLB<sp/>=<sp/>level[BRLB];</highlight></codeline>
<codeline lineno="1933"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTRLT<sp/>=<sp/>level[TRLT];</highlight></codeline>
<codeline lineno="1934"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levLB<sp/>=<sp/>level[LB];</highlight></codeline>
<codeline lineno="1935"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levLT<sp/>=<sp/>level[LT];</highlight></codeline>
<codeline lineno="1936"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>-1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1937"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="1938"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="1939"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="1940"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="1941"><highlight class="normal"></highlight></codeline>
<codeline lineno="1942"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="1943"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1944"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1946"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1947"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="1948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1949"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="1952"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1953"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1954"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="1955"><highlight class="normal"></highlight></codeline>
<codeline lineno="1956"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1957"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1958"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1959"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1960"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1961"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj,<sp/>LT);</highlight></codeline>
<codeline lineno="1962"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj,<sp/>LT);</highlight></codeline>
<codeline lineno="1963"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="1964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="1965"><highlight class="normal"></highlight></codeline>
<codeline lineno="1966"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="1967"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1968"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1969"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1970"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1971"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLB<sp/>==<sp/>lev<sp/>)</highlight></codeline>
<codeline lineno="1972"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>iy,<sp/>LB);</highlight></codeline>
<codeline lineno="1974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="1975"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1976"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLB<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="1977"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1978"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1979"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1980"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1981"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj,<sp/>LB);</highlight></codeline>
<codeline lineno="1982"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj,<sp/>LB);</highlight></codeline>
<codeline lineno="1983"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>LB);</highlight></codeline>
<codeline lineno="1984"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>LB);</highlight></codeline>
<codeline lineno="1985"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="1986"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1987"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1988"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1989"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="1990"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1992"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="1993"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1994"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1996"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1997"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1998"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj,<sp/>LT);</highlight></codeline>
<codeline lineno="1999"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj,<sp/>LT);</highlight></codeline>
<codeline lineno="2000"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="2001"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="2002"><highlight class="normal"></highlight></codeline>
<codeline lineno="2003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2006"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2007"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLB<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="2008"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>RBLB==ib?<sp/>ceil(iy<sp/>*<sp/>(T)0.5):<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.y<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="2010"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>(T)1.0<sp/>/<sp/>(T)3.0;</highlight></codeline>
<codeline lineno="2011"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="2012"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="2013"><highlight class="normal"></highlight></codeline>
<codeline lineno="2014"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2015"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>jj,<sp/>LB);</highlight></codeline>
<codeline lineno="2016"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>jj<sp/>-<sp/>1,<sp/>LB);</highlight></codeline>
<codeline lineno="2017"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RBLB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2018"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2019"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="2020"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2021"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BRLB<sp/>==<sp/>LB)</highlight></codeline>
<codeline lineno="2022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2023"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>(T)0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="2024"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2025"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="2026"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2027"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBRLB<sp/>&lt;<sp/>levLB)</highlight></codeline>
<codeline lineno="2028"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2030"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BRLB);</highlight></codeline>
<codeline lineno="2033"><highlight class="normal"></highlight></codeline>
<codeline lineno="2034"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2035"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBRLB<sp/>==<sp/>levLB)</highlight></codeline>
<codeline lineno="2036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BRLB);</highlight></codeline>
<codeline lineno="2038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBRLB<sp/>&gt;<sp/>levLB)</highlight></codeline>
<codeline lineno="2040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2041"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="2042"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="2043"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="2044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BRLB);</highlight></codeline>
<codeline lineno="2045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2046"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2048"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2050"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>==<sp/>(blockDim.y<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="2051"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TRLT<sp/>==<sp/>LT)</highlight></codeline>
<codeline lineno="2053"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="2055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="2057"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2058"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTRLT<sp/>&lt;<sp/>levLT)</highlight></codeline>
<codeline lineno="2059"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2060"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2061"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2062"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2063"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>0,<sp/>TRLT);</highlight></codeline>
<codeline lineno="2064"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2065"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTRLT<sp/>==<sp/>levLT)</highlight></codeline>
<codeline lineno="2066"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2067"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>0,<sp/>TRLT);</highlight></codeline>
<codeline lineno="2068"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2069"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTRLT<sp/>&gt;<sp/>levLT)</highlight></codeline>
<codeline lineno="2070"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2071"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2072"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="2073"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2074"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>0,<sp/>TRLT);</highlight></codeline>
<codeline lineno="2075"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2076"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2077"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2078"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2079"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>w1<sp/>*<sp/>a[ii]<sp/>+<sp/>w2<sp/>*<sp/>a[ir]<sp/>+<sp/>w3<sp/>*<sp/>a[it];</highlight></codeline>
<codeline lineno="2080"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2081"><highlight class="normal"></highlight></codeline>
<codeline lineno="2082"><highlight class="normal"><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="2083"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2084"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillLeft&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="2085"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillLeft&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="2086"><highlight class="normal"></highlight></codeline>
<codeline lineno="2095"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillLeftnew(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="2096"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2097"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2098"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2099"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>ix<sp/>=<sp/>0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2100"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="2101"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//need<sp/>to<sp/>take<sp/>min<sp/>of<sp/>ibl<sp/>or<sp/>total<sp/>number<sp/>of<sp/>blks<sp/>in<sp/>case<sp/>nblk<sp/>is<sp/>not<sp/>dividable<sp/>by<sp/>2</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2102"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;;</highlight></codeline>
<codeline lineno="2103"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ibl<sp/>&lt;<sp/>nblk)</highlight></codeline>
<codeline lineno="2104"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2105"><highlight class="normal"></highlight></codeline>
<codeline lineno="2106"><highlight class="normal"></highlight></codeline>
<codeline lineno="2107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="2108"><highlight class="normal"></highlight></codeline>
<codeline lineno="2109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="2110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LB<sp/>=<sp/>leftbot[ib];</highlight></codeline>
<codeline lineno="2111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LT<sp/>=<sp/>lefttop[ib];</highlight></codeline>
<codeline lineno="2112"><highlight class="normal"></highlight></codeline>
<codeline lineno="2113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RBLB<sp/>=<sp/>rightbot[LB];</highlight></codeline>
<codeline lineno="2114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BRLB<sp/>=<sp/>botright[LB];</highlight></codeline>
<codeline lineno="2115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TRLT<sp/>=<sp/>topright[LT];</highlight></codeline>
<codeline lineno="2116"><highlight class="normal"></highlight></codeline>
<codeline lineno="2117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levBRLB<sp/>=<sp/>level[BRLB];</highlight></codeline>
<codeline lineno="2118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTRLT<sp/>=<sp/>level[TRLT];</highlight></codeline>
<codeline lineno="2119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levLB<sp/>=<sp/>level[LB];</highlight></codeline>
<codeline lineno="2120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levLT<sp/>=<sp/>level[LT];</highlight></codeline>
<codeline lineno="2121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>-1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="2123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="2124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="2125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="2126"><highlight class="normal"></highlight></codeline>
<codeline lineno="2127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2140"><highlight class="normal"></highlight></codeline>
<codeline lineno="2141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2144"><highlight class="normal"></highlight></codeline>
<codeline lineno="2145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj,<sp/>LT);</highlight></codeline>
<codeline lineno="2147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj,<sp/>LT);</highlight></codeline>
<codeline lineno="2148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="2149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="2150"><highlight class="normal"></highlight></codeline>
<codeline lineno="2151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2154"><highlight class="normal"></highlight></codeline>
<codeline lineno="2155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLB<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="2157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>iy,<sp/>LB);</highlight></codeline>
<codeline lineno="2159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLB<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="2162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj,<sp/>LB);</highlight></codeline>
<codeline lineno="2167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj,<sp/>LB);</highlight></codeline>
<codeline lineno="2168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>LB);</highlight></codeline>
<codeline lineno="2169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>LB);</highlight></codeline>
<codeline lineno="2170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2182"><highlight class="normal"></highlight></codeline>
<codeline lineno="2183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj,<sp/>LT);</highlight></codeline>
<codeline lineno="2184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj,<sp/>LT);</highlight></codeline>
<codeline lineno="2185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="2186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>(blockDim.y<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="2187"><highlight class="normal"></highlight></codeline>
<codeline lineno="2188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLB<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="2193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>RBLB<sp/>==<sp/>ib<sp/>?<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.y<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="2195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>(T)1.0<sp/>/<sp/>(T)3.0;</highlight></codeline>
<codeline lineno="2196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="2197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="2198"><highlight class="normal"></highlight></codeline>
<codeline lineno="2199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>jj,<sp/>LB);</highlight></codeline>
<codeline lineno="2201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>jj<sp/>-<sp/>1,<sp/>LB);</highlight></codeline>
<codeline lineno="2202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RBLB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="2205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BRLB<sp/>==<sp/>LB)</highlight></codeline>
<codeline lineno="2207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>(T)0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="2209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="2211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBRLB<sp/>&lt;<sp/>levLB)</highlight></codeline>
<codeline lineno="2213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BRLB);</highlight></codeline>
<codeline lineno="2218"><highlight class="normal"></highlight></codeline>
<codeline lineno="2219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBRLB<sp/>==<sp/>levLB)</highlight></codeline>
<codeline lineno="2221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BRLB);</highlight></codeline>
<codeline lineno="2223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBRLB<sp/>&gt;<sp/>levLB)</highlight></codeline>
<codeline lineno="2225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="2227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="2228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="2229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BRLB);</highlight></codeline>
<codeline lineno="2230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>==<sp/>(blockDim.y<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="2236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TRLT<sp/>==<sp/>LT)</highlight></codeline>
<codeline lineno="2238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="2240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="2242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTRLT<sp/>&lt;<sp/>levLT)</highlight></codeline>
<codeline lineno="2244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>0,<sp/>TRLT);</highlight></codeline>
<codeline lineno="2249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTRLT<sp/>==<sp/>levLT)</highlight></codeline>
<codeline lineno="2251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>0,<sp/>TRLT);</highlight></codeline>
<codeline lineno="2253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTRLT<sp/>&gt;<sp/>levLT)</highlight></codeline>
<codeline lineno="2255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="2258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>0,<sp/>TRLT);</highlight></codeline>
<codeline lineno="2260"><highlight class="normal"></highlight></codeline>
<codeline lineno="2261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>w1<sp/>*<sp/>a[ii]<sp/>+<sp/>w2<sp/>*<sp/>a[ir]<sp/>+<sp/>w3<sp/>*<sp/>a[it];</highlight></codeline>
<codeline lineno="2265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2266"><highlight class="normal"></highlight></codeline>
<codeline lineno="2267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="2268"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2269"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2270"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillLeftnew&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="2271"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillLeftnew&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="2272"><highlight class="normal"></highlight></codeline>
<codeline lineno="2273"><highlight class="normal"></highlight></codeline>
<codeline lineno="2274"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillLeftFlux(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="2275"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2276"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>bb;</highlight></codeline>
<codeline lineno="2277"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>write;</highlight></codeline>
<codeline lineno="2278"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/><sp/>it;</highlight></codeline>
<codeline lineno="2279"><highlight class="normal"></highlight></codeline>
<codeline lineno="2280"><highlight class="normal"></highlight></codeline>
<codeline lineno="2281"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2282"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="2284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2285"><highlight class="normal"></highlight></codeline>
<codeline lineno="2286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2290"><highlight class="normal"></highlight></codeline>
<codeline lineno="2291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2296"><highlight class="normal"></highlight></codeline>
<codeline lineno="2297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2304"><highlight class="normal"></highlight></codeline>
<codeline lineno="2305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="2310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="2312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2313"><highlight class="normal"></highlight></codeline>
<codeline lineno="2314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/><sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="2315"><highlight class="normal"></highlight></codeline>
<codeline lineno="2316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2318"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2319"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.LeftBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2320"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="2322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2324"><highlight class="normal"></highlight></codeline>
<codeline lineno="2325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>j,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="2327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2329"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2330"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="2331"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2332"><highlight class="normal"></highlight></codeline>
<codeline lineno="2333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth<sp/>/<sp/>2;<sp/>j++)</highlight></codeline>
<codeline lineno="2334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2335"><highlight class="normal"></highlight></codeline>
<codeline lineno="2336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2337"><highlight class="normal"></highlight></codeline>
<codeline lineno="2338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.LeftBot[ib];</highlight></codeline>
<codeline lineno="2340"><highlight class="normal"></highlight></codeline>
<codeline lineno="2341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2345"><highlight class="normal"></highlight></codeline>
<codeline lineno="2346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="2347"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2354"><highlight class="normal"></highlight></codeline>
<codeline lineno="2355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>8)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.LeftTop[ib];</highlight></codeline>
<codeline lineno="2367"><highlight class="normal"></highlight></codeline>
<codeline lineno="2368"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>z[read];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2375"><highlight class="normal"></highlight></codeline>
<codeline lineno="2376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="2377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2379"><highlight class="normal"></highlight></codeline>
<codeline lineno="2380"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2381"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2382"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="2384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2386"><highlight class="normal"></highlight></codeline>
<codeline lineno="2387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//T<sp/>w1,<sp/>w2,<sp/>w3;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2388"><highlight class="normal"></highlight></codeline>
<codeline lineno="2389"><highlight class="normal"></highlight></codeline>
<codeline lineno="2390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.RightBot[XBlock.LeftBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="2391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2392"><highlight class="normal"></highlight></codeline>
<codeline lineno="2393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="2394"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(doProlongation)</highlight></codeline>
<codeline lineno="2395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[ii];</highlight></codeline>
<codeline lineno="2396"><highlight class="normal"></highlight></codeline>
<codeline lineno="2397"><highlight class="normal"></highlight></codeline>
<codeline lineno="2398"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2400"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2401"><highlight class="normal"></highlight></codeline>
<codeline lineno="2402"><highlight class="normal"></highlight></codeline>
<codeline lineno="2403"><highlight class="normal"></highlight></codeline>
<codeline lineno="2404"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2405"><highlight class="normal"></highlight></codeline>
<codeline lineno="2406"><highlight class="normal"></highlight></codeline>
<codeline lineno="2407"><highlight class="normal"></highlight></codeline>
<codeline lineno="2408"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRight(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="2409"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2410"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>bb;</highlight></codeline>
<codeline lineno="2411"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>write;</highlight></codeline>
<codeline lineno="2412"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="2413"><highlight class="normal"></highlight></codeline>
<codeline lineno="2414"><highlight class="normal"></highlight></codeline>
<codeline lineno="2415"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2416"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="2418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2419"><highlight class="normal"></highlight></codeline>
<codeline lineno="2420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth-1,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2422"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2424"><highlight class="normal"></highlight></codeline>
<codeline lineno="2425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2428"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2429"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2430"><highlight class="normal"></highlight></codeline>
<codeline lineno="2431"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2434"><highlight class="normal"></highlight></codeline>
<codeline lineno="2435"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2436"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2437"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2438"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2439"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2440"><highlight class="normal"></highlight></codeline>
<codeline lineno="2441"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2442"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2443"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>(XParam.blkwidth<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2445"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="2446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="2447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="2448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="2449"><highlight class="normal"></highlight></codeline>
<codeline lineno="2450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="2451"><highlight class="normal"></highlight></codeline>
<codeline lineno="2452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2454"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2455"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.RightBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2456"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="2458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2460"><highlight class="normal"></highlight></codeline>
<codeline lineno="2461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="2463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2465"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2466"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="2467"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2468"><highlight class="normal"></highlight></codeline>
<codeline lineno="2469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth<sp/>/<sp/>2;<sp/>j++)</highlight></codeline>
<codeline lineno="2470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2471"><highlight class="normal"></highlight></codeline>
<codeline lineno="2472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2473"><highlight class="normal"></highlight></codeline>
<codeline lineno="2474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.RightBot[ib];</highlight></codeline>
<codeline lineno="2476"><highlight class="normal"></highlight></codeline>
<codeline lineno="2477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2481"><highlight class="normal"></highlight></codeline>
<codeline lineno="2482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="2483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2490"><highlight class="normal"></highlight></codeline>
<codeline lineno="2491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth-1,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2496"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2497"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>(XParam.blkwidth<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.RightTop[ib];</highlight></codeline>
<codeline lineno="2503"><highlight class="normal"></highlight></codeline>
<codeline lineno="2504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>z[read];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2511"><highlight class="normal"></highlight></codeline>
<codeline lineno="2512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="2513"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2515"><highlight class="normal"></highlight></codeline>
<codeline lineno="2516"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2517"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2518"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="2520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2522"><highlight class="normal"></highlight></codeline>
<codeline lineno="2523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="2524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2525"><highlight class="normal"></highlight></codeline>
<codeline lineno="2526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.LeftBot[XBlock.RightBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="2527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>3.0);</highlight></codeline>
<codeline lineno="2528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>j<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="2529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>j<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="2530"><highlight class="normal"></highlight></codeline>
<codeline lineno="2531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth-1,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="2532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="2533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="2534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//2<sp/>scenarios<sp/>here<sp/>ib<sp/>is<sp/>the<sp/>leftbot<sp/>neighbour<sp/>of<sp/>the<sp/>rightbot<sp/>block<sp/>or<sp/>ib<sp/>is<sp/>the<sp/>lefttop<sp/>neighbour</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftBot[XBlock.RightBot[ib]]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="2538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotLeft[XBlock.RightBot[ib]]<sp/>==<sp/>XBlock.RightBot[ib])<sp/></highlight><highlight class="comment">//<sp/>no<sp/>botom<sp/>of<sp/>leftbot<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1));</highlight></codeline>
<codeline lineno="2542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="2544"><highlight class="normal"></highlight></codeline>
<codeline lineno="2545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[XBlock.RightBot[ib]]]<sp/>&lt;<sp/>XBlock.level[XBlock.RightBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>but<sp/>is<sp/>coarser</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2549"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotLeft[XBlock.RightBot[ib]]);</highlight></codeline>
<codeline lineno="2552"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[XBlock.RightBot[ib]]]<sp/>==<sp/>XBlock.level[XBlock.RightBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>same<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2555"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotLeft[XBlock.RightBot[ib]]);</highlight></codeline>
<codeline lineno="2556"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2557"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[XBlock.RightBot[ib]]]<sp/>&gt;<sp/>XBlock.level[XBlock.RightBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>higher<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2558"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="2560"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="2561"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="2562"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotLeft[XBlock.RightBot[ib]]);</highlight></codeline>
<codeline lineno="2563"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2564"><highlight class="normal"></highlight></codeline>
<codeline lineno="2565"><highlight class="normal"></highlight></codeline>
<codeline lineno="2566"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2567"><highlight class="normal"></highlight></codeline>
<codeline lineno="2568"><highlight class="normal"></highlight></codeline>
<codeline lineno="2569"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2570"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2571"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2572"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>(XParam.blkwidth<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="2573"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2574"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopLeft[XBlock.RightTop[ib]]<sp/>==<sp/>XBlock.RightTop[ib])<sp/></highlight><highlight class="comment">//<sp/>no<sp/>botom<sp/>of<sp/>leftbot<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2575"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2576"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1));</highlight></codeline>
<codeline lineno="2577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2578"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="2579"><highlight class="normal"></highlight></codeline>
<codeline lineno="2580"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2581"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[XBlock.RightTop[ib]]]<sp/>&lt;<sp/>XBlock.level[XBlock.RightTop[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>but<sp/>is<sp/>coarser</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2582"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2583"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2584"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="2586"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>0,<sp/>XBlock.TopLeft[XBlock.RightTop[ib]]);</highlight></codeline>
<codeline lineno="2587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[XBlock.RightTop[ib]]]<sp/>==<sp/>XBlock.level[XBlock.RightTop[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>same<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2589"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2590"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>0,<sp/>XBlock.TopLeft[XBlock.RightTop[ib]]);</highlight></codeline>
<codeline lineno="2591"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[XBlock.RightTop[ib]]]<sp/>&gt;<sp/>XBlock.level[XBlock.RightTop[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>higher<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="2596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>0,<sp/>XBlock.TopLeft[XBlock.RightTop[ib]]);</highlight></codeline>
<codeline lineno="2598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2600"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2601"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2602"><highlight class="normal"></highlight></codeline>
<codeline lineno="2603"><highlight class="normal"></highlight></codeline>
<codeline lineno="2604"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>w1<sp/>*<sp/>z[ii]<sp/>+<sp/>w2<sp/>*<sp/>z[ir]<sp/>+<sp/>w3<sp/>*<sp/>z[it];</highlight></codeline>
<codeline lineno="2605"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2606"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2607"><highlight class="normal"></highlight></codeline>
<codeline lineno="2608"><highlight class="normal"></highlight></codeline>
<codeline lineno="2609"><highlight class="normal"></highlight></codeline>
<codeline lineno="2610"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2611"><highlight class="normal"></highlight></codeline>
<codeline lineno="2612"><highlight class="normal"></highlight></codeline>
<codeline lineno="2613"><highlight class="normal"></highlight></codeline>
<codeline lineno="2614"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRight(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>rightbot,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>leftbot,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*botleft,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="2615"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2616"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2617"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2618"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>ix<sp/>=<sp/>blockDim.y<sp/>-<sp/>1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2619"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="2620"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="2621"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="2622"><highlight class="normal"></highlight></codeline>
<codeline lineno="2623"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RB<sp/>=<sp/>rightbot[ib];</highlight></codeline>
<codeline lineno="2624"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RT<sp/>=<sp/>righttop[ib];</highlight></codeline>
<codeline lineno="2625"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>LB<sp/>=<sp/>leftbot[ib];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2626"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>BL<sp/>=<sp/>botleft[ib];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2627"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LBRB<sp/>=<sp/>leftbot[RB];</highlight></codeline>
<codeline lineno="2628"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TLRT<sp/>=<sp/>topleft[RT];</highlight></codeline>
<codeline lineno="2629"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BLRB<sp/>=<sp/>botleft[RB];</highlight></codeline>
<codeline lineno="2630"><highlight class="normal"></highlight></codeline>
<codeline lineno="2631"><highlight class="normal"></highlight></codeline>
<codeline lineno="2632"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="2633"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRB<sp/>=<sp/>level[RB];</highlight></codeline>
<codeline lineno="2634"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRT<sp/>=<sp/>level[RT];</highlight></codeline>
<codeline lineno="2635"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levBLRB<sp/>=<sp/>level[BLRB];</highlight></codeline>
<codeline lineno="2636"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTLRT<sp/>=<sp/>level[TLRT];</highlight></codeline>
<codeline lineno="2637"><highlight class="normal"></highlight></codeline>
<codeline lineno="2638"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2639"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="2640"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="2641"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="2642"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="2643"><highlight class="normal"></highlight></codeline>
<codeline lineno="2644"><highlight class="normal"></highlight></codeline>
<codeline lineno="2645"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2646"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2655"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="2663"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="2664"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="2665"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="2666"><highlight class="normal"></highlight></codeline>
<codeline lineno="2667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2668"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2670"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2671"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="2672"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>RB);</highlight></codeline>
<codeline lineno="2674"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2675"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2676"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="2677"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2678"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2679"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2680"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2681"><highlight class="normal"></highlight></codeline>
<codeline lineno="2682"><highlight class="normal"></highlight></codeline>
<codeline lineno="2683"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RB);</highlight></codeline>
<codeline lineno="2684"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RB);</highlight></codeline>
<codeline lineno="2685"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RB);</highlight></codeline>
<codeline lineno="2686"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RB);</highlight></codeline>
<codeline lineno="2687"><highlight class="normal"></highlight></codeline>
<codeline lineno="2688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2690"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2693"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2696"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2697"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2699"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2700"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2701"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="2702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="2703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="2704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="2705"><highlight class="normal"></highlight></codeline>
<codeline lineno="2706"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2707"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2708"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2709"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2710"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="2711"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>LBRB<sp/>==<sp/>ib<sp/>?<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.y<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="2714"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>3.0;</highlight></codeline>
<codeline lineno="2715"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="2716"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="2717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RB);</highlight></codeline>
<codeline lineno="2719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>-<sp/>1,<sp/>RB);</highlight></codeline>
<codeline lineno="2720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LBRB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="2723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BLRB<sp/>==<sp/>RB)</highlight></codeline>
<codeline lineno="2725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="2727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="2729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2730"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBLRB<sp/>&lt;<sp/>levRB)</highlight></codeline>
<codeline lineno="2731"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BLRB);</highlight></codeline>
<codeline lineno="2736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBLRB<sp/>==<sp/>levRB)</highlight></codeline>
<codeline lineno="2738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BLRB);</highlight></codeline>
<codeline lineno="2740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBLRB<sp/>&gt;<sp/>levRB)</highlight></codeline>
<codeline lineno="2742"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="2745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BLRB);</highlight></codeline>
<codeline lineno="2747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2748"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2749"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2750"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>==<sp/>(blockDim.y<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="2753"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TLRT<sp/>==<sp/>RT)</highlight></codeline>
<codeline lineno="2755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2756"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="2757"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2758"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="2759"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTLRT<sp/>&lt;<sp/>levRT)</highlight></codeline>
<codeline lineno="2761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2762"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2763"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2764"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2765"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>TLRT);</highlight></codeline>
<codeline lineno="2766"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2767"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTLRT<sp/>==<sp/>levRT)</highlight></codeline>
<codeline lineno="2768"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2769"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>TLRT);</highlight></codeline>
<codeline lineno="2770"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2771"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTLRT<sp/>&gt;<sp/>levRT)</highlight></codeline>
<codeline lineno="2772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2773"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="2775"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>TLRT);</highlight></codeline>
<codeline lineno="2777"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2779"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2780"><highlight class="normal"></highlight></codeline>
<codeline lineno="2781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read=<sp/>w1<sp/>*<sp/>a[ii]<sp/>+<sp/>w2<sp/>*<sp/>a[ir]<sp/>+<sp/>w3<sp/>*<sp/>a[it];</highlight></codeline>
<codeline lineno="2782"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2783"><highlight class="normal"><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="2784"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2785"><highlight class="normal"></highlight></codeline>
<codeline lineno="2786"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRight&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="2787"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRight&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="2788"><highlight class="normal"></highlight></codeline>
<codeline lineno="2789"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightnew(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="2790"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2791"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2792"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2793"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>ix<sp/>=<sp/>blockDim.y<sp/>-<sp/>1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2794"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="2795"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;</highlight></codeline>
<codeline lineno="2796"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ibl<sp/>&lt;<sp/>nblk)</highlight></codeline>
<codeline lineno="2797"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="2799"><highlight class="normal"></highlight></codeline>
<codeline lineno="2800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RB<sp/>=<sp/>rightbot[ib];</highlight></codeline>
<codeline lineno="2801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RT<sp/>=<sp/>righttop[ib];</highlight></codeline>
<codeline lineno="2802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>LB<sp/>=<sp/>leftbot[ib];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2803"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>BL<sp/>=<sp/>botleft[ib];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LBRB<sp/>=<sp/>leftbot[RB];</highlight></codeline>
<codeline lineno="2805"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TLRT<sp/>=<sp/>topleft[RT];</highlight></codeline>
<codeline lineno="2806"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BLRB<sp/>=<sp/>botleft[RB];</highlight></codeline>
<codeline lineno="2807"><highlight class="normal"></highlight></codeline>
<codeline lineno="2808"><highlight class="normal"></highlight></codeline>
<codeline lineno="2809"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="2810"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRB<sp/>=<sp/>level[RB];</highlight></codeline>
<codeline lineno="2811"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRT<sp/>=<sp/>level[RT];</highlight></codeline>
<codeline lineno="2812"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levBLRB<sp/>=<sp/>level[BLRB];</highlight></codeline>
<codeline lineno="2813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTLRT<sp/>=<sp/>level[TLRT];</highlight></codeline>
<codeline lineno="2814"><highlight class="normal"></highlight></codeline>
<codeline lineno="2815"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2816"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="2817"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="2818"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="2819"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="2820"><highlight class="normal"></highlight></codeline>
<codeline lineno="2821"><highlight class="normal"></highlight></codeline>
<codeline lineno="2822"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2823"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2824"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2825"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2826"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2829"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2833"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2838"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="2840"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="2841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="2842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="2843"><highlight class="normal"></highlight></codeline>
<codeline lineno="2844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="2849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>RB);</highlight></codeline>
<codeline lineno="2851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2853"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="2854"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2857"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2858"><highlight class="normal"></highlight></codeline>
<codeline lineno="2859"><highlight class="normal"></highlight></codeline>
<codeline lineno="2860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RB);</highlight></codeline>
<codeline lineno="2861"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RB);</highlight></codeline>
<codeline lineno="2862"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RB);</highlight></codeline>
<codeline lineno="2863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RB);</highlight></codeline>
<codeline lineno="2864"><highlight class="normal"></highlight></codeline>
<codeline lineno="2865"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2870"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2871"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2872"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2873"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2877"><highlight class="normal"></highlight></codeline>
<codeline lineno="2878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="2879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="2880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="2881"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="2882"><highlight class="normal"></highlight></codeline>
<codeline lineno="2883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2884"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2886"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2887"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="2888"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2889"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2890"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>LBRB<sp/>==<sp/>ib<sp/>?<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.y<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="2891"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>3.0;</highlight></codeline>
<codeline lineno="2892"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="2893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="2894"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RB);</highlight></codeline>
<codeline lineno="2896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>-<sp/>1,<sp/>RB);</highlight></codeline>
<codeline lineno="2897"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LBRB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2898"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2899"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="2900"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2901"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BLRB<sp/>==<sp/>RB)</highlight></codeline>
<codeline lineno="2902"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2903"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="2904"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2905"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="2906"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2907"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBLRB<sp/>&lt;<sp/>levRB)</highlight></codeline>
<codeline lineno="2908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2910"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2911"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2912"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BLRB);</highlight></codeline>
<codeline lineno="2913"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2914"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBLRB<sp/>==<sp/>levRB)</highlight></codeline>
<codeline lineno="2915"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2916"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BLRB);</highlight></codeline>
<codeline lineno="2917"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2918"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBLRB<sp/>&gt;<sp/>levRB)</highlight></codeline>
<codeline lineno="2919"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2920"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2921"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="2922"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2923"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>BLRB);</highlight></codeline>
<codeline lineno="2924"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2925"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2926"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2927"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2928"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2929"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>==<sp/>(blockDim.y<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="2930"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2931"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TLRT<sp/>==<sp/>RT)</highlight></codeline>
<codeline lineno="2932"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="2934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="2935"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="2936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTLRT<sp/>&lt;<sp/>levRT)</highlight></codeline>
<codeline lineno="2938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="2942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>TLRT);</highlight></codeline>
<codeline lineno="2943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2944"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTLRT<sp/>==<sp/>levRT)</highlight></codeline>
<codeline lineno="2945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2946"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>TLRT);</highlight></codeline>
<codeline lineno="2947"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTLRT<sp/>&gt;<sp/>levRT)</highlight></codeline>
<codeline lineno="2949"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="2952"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="2953"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>TLRT);</highlight></codeline>
<codeline lineno="2954"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2955"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2956"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2957"><highlight class="normal"></highlight></codeline>
<codeline lineno="2958"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>w1<sp/>*<sp/>a[ii]<sp/>+<sp/>w2<sp/>*<sp/>a[ir]<sp/>+<sp/>w3<sp/>*<sp/>a[it];</highlight></codeline>
<codeline lineno="2959"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2960"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="2961"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2962"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2963"><highlight class="normal"></highlight></codeline>
<codeline lineno="2964"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightnew&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="2965"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightnew&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="2966"><highlight class="normal"></highlight></codeline>
<codeline lineno="2967"><highlight class="normal"></highlight></codeline>
<codeline lineno="2968"><highlight class="normal"></highlight></codeline>
<codeline lineno="2969"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightFlux(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="2970"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2971"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>bb;</highlight></codeline>
<codeline lineno="2972"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>write;</highlight></codeline>
<codeline lineno="2973"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/>it;</highlight></codeline>
<codeline lineno="2974"><highlight class="normal"></highlight></codeline>
<codeline lineno="2975"><highlight class="normal"></highlight></codeline>
<codeline lineno="2976"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2977"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2978"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="2979"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2980"><highlight class="normal"></highlight></codeline>
<codeline lineno="2981"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2982"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2983"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2984"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2985"><highlight class="normal"></highlight></codeline>
<codeline lineno="2986"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2987"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2988"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="2989"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2990"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2991"><highlight class="normal"></highlight></codeline>
<codeline lineno="2992"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2993"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2994"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="2995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2996"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2997"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2998"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2999"><highlight class="normal"></highlight></codeline>
<codeline lineno="3000"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3001"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3002"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="3003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>8)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3008"><highlight class="normal"></highlight></codeline>
<codeline lineno="3009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="3010"><highlight class="normal"></highlight></codeline>
<codeline lineno="3011"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3012"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3013"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3014"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.RightBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3015"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3016"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="3017"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3018"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3019"><highlight class="normal"></highlight></codeline>
<codeline lineno="3020"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="3021"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="3022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3023"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3024"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3025"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="3026"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3027"><highlight class="normal"></highlight></codeline>
<codeline lineno="3028"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth<sp/>/<sp/>2;<sp/>j++)</highlight></codeline>
<codeline lineno="3029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3030"><highlight class="normal"></highlight></codeline>
<codeline lineno="3031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="3032"><highlight class="normal"></highlight></codeline>
<codeline lineno="3033"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3034"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.RightBot[ib];</highlight></codeline>
<codeline lineno="3035"><highlight class="normal"></highlight></codeline>
<codeline lineno="3036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="3037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="3039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3040"><highlight class="normal"></highlight></codeline>
<codeline lineno="3041"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3042"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="3043"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3046"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3048"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3050"><highlight class="normal"></highlight></codeline>
<codeline lineno="3051"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>j,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3053"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3057"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3058"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3059"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3060"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3061"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>8)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3062"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.RightTop[ib];</highlight></codeline>
<codeline lineno="3063"><highlight class="normal"></highlight></codeline>
<codeline lineno="3064"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3065"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3066"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>z[read];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3067"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="3068"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3069"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="3070"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3071"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="3072"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3073"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3074"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3075"><highlight class="normal"></highlight></codeline>
<codeline lineno="3076"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3077"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3078"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3079"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="3080"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3081"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>j,<sp/>ib);</highlight></codeline>
<codeline lineno="3082"><highlight class="normal"></highlight></codeline>
<codeline lineno="3083"><highlight class="normal"></highlight></codeline>
<codeline lineno="3084"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.LeftBot[XBlock.RightBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(floor(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(floor(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="3085"><highlight class="normal"></highlight></codeline>
<codeline lineno="3086"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="3087"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(doProlongation)</highlight></codeline>
<codeline lineno="3088"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[ii];</highlight></codeline>
<codeline lineno="3089"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3090"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3091"><highlight class="normal"></highlight></codeline>
<codeline lineno="3092"><highlight class="normal"></highlight></codeline>
<codeline lineno="3093"><highlight class="normal"></highlight></codeline>
<codeline lineno="3094"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3095"><highlight class="normal"></highlight></codeline>
<codeline lineno="3096"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightFlux&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*&amp;<sp/>z);</highlight></codeline>
<codeline lineno="3097"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightFlux&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*&amp;<sp/>z);</highlight></codeline>
<codeline lineno="3098"><highlight class="normal"></highlight></codeline>
<codeline lineno="3099"><highlight class="normal"></highlight></codeline>
<codeline lineno="3100"><highlight class="normal"></highlight></codeline>
<codeline lineno="3101"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightFlux(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="3102"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3103"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3104"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3105"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>ix<sp/>=<sp/>blockDim.y<sp/>-<sp/>1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3106"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="3107"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="3108"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="3109"><highlight class="normal"></highlight></codeline>
<codeline lineno="3110"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RB<sp/>=<sp/>rightbot[ib];</highlight></codeline>
<codeline lineno="3111"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RT<sp/>=<sp/>righttop[ib];</highlight></codeline>
<codeline lineno="3112"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>LB<sp/>=<sp/>leftbot[ib];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3113"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>BL<sp/>=<sp/>botleft[ib];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3114"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LBRB<sp/>=<sp/>leftbot[RB];</highlight></codeline>
<codeline lineno="3115"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>TLRT<sp/>=<sp/>topleft[RT];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3116"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>BLRB<sp/>=<sp/>botleft[RB];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3117"><highlight class="normal"></highlight></codeline>
<codeline lineno="3118"><highlight class="normal"></highlight></codeline>
<codeline lineno="3119"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="3120"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRB<sp/>=<sp/>level[RB];</highlight></codeline>
<codeline lineno="3121"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>levRT<sp/>=<sp/>level[RT];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3122"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>levBLRB<sp/>=<sp/>level[BLRB];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3123"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>levTLRT<sp/>=<sp/>level[TLRT];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3124"><highlight class="normal"></highlight></codeline>
<codeline lineno="3125"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3126"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="3127"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it;</highlight></codeline>
<codeline lineno="3128"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="3129"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//T<sp/>w1,<sp/>w2;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3130"><highlight class="normal"></highlight></codeline>
<codeline lineno="3131"><highlight class="normal"></highlight></codeline>
<codeline lineno="3132"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RB<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3133"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="3150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RT);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="3152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3153"><highlight class="normal"></highlight></codeline>
<codeline lineno="3154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.5)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[it]);</highlight></codeline>
<codeline lineno="3155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3157"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3158"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="3159"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>RB);</highlight></codeline>
<codeline lineno="3161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3162"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3163"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="3164"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(blockDim.y<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3168"><highlight class="normal"></highlight></codeline>
<codeline lineno="3169"><highlight class="normal"></highlight></codeline>
<codeline lineno="3170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RB);</highlight></codeline>
<codeline lineno="3171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RB);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RB);</highlight></codeline>
<codeline lineno="3173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RB);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3174"><highlight class="normal"></highlight></codeline>
<codeline lineno="3175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.5)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[it]);</highlight></codeline>
<codeline lineno="3176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RT<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.y<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>(blockDim.y<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3187"><highlight class="normal"></highlight></codeline>
<codeline lineno="3188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RT);</highlight></codeline>
<codeline lineno="3189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>RT);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight></codeline>
<codeline lineno="3191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>+<sp/>1,<sp/>RT);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3192"><highlight class="normal"></highlight></codeline>
<codeline lineno="3193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.5)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[it]<sp/>);</highlight></codeline>
<codeline lineno="3194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3196"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3197"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRB<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="3198"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>LBRB<sp/>==<sp/>ib<sp/>?<sp/>floor(iy<sp/>*<sp/>(T)0.5)<sp/>:<sp/>floor(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.y<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="3201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>RB);</highlight></codeline>
<codeline lineno="3204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(doProlongation)</highlight></codeline>
<codeline lineno="3206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[ir];</highlight></codeline>
<codeline lineno="3207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[write];</highlight></codeline>
<codeline lineno="3210"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3211"><highlight class="normal"><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="3212"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3213"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightFlux&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="3214"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillRightFlux&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="3215"><highlight class="normal"></highlight></codeline>
<codeline lineno="3216"><highlight class="normal"></highlight></codeline>
<codeline lineno="3217"><highlight class="normal"></highlight></codeline>
<codeline lineno="3218"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillBot(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="3219"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3220"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>bb;</highlight></codeline>
<codeline lineno="3221"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>write;</highlight></codeline>
<codeline lineno="3222"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="3223"><highlight class="normal"></highlight></codeline>
<codeline lineno="3224"><highlight class="normal"></highlight></codeline>
<codeline lineno="3225"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3226"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="3228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3229"><highlight class="normal"></highlight></codeline>
<codeline lineno="3230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3234"><highlight class="normal"></highlight></codeline>
<codeline lineno="3235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3240"><highlight class="normal"></highlight></codeline>
<codeline lineno="3241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3248"><highlight class="normal"></highlight></codeline>
<codeline lineno="3249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,j,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="3252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>8)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,jj,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,jj,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,jj+1,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,jj+1,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3257"><highlight class="normal"></highlight></codeline>
<codeline lineno="3258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="3259"><highlight class="normal"></highlight></codeline>
<codeline lineno="3260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3262"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3263"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.BotLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3264"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="3266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3268"><highlight class="normal"></highlight></codeline>
<codeline lineno="3269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,j,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="3270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="3271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3273"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3274"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="3275"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3276"><highlight class="normal"></highlight></codeline>
<codeline lineno="3277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth<sp/>/<sp/>2;<sp/>j++)</highlight></codeline>
<codeline lineno="3278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3279"><highlight class="normal"></highlight></codeline>
<codeline lineno="3280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="3281"><highlight class="normal"></highlight></codeline>
<codeline lineno="3282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.BotLeft[ib];</highlight></codeline>
<codeline lineno="3284"><highlight class="normal"></highlight></codeline>
<codeline lineno="3285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>bb);</highlight></codeline>
<codeline lineno="3286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>bb);</highlight></codeline>
<codeline lineno="3287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>bb);</highlight></codeline>
<codeline lineno="3288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>bb);</highlight></codeline>
<codeline lineno="3289"><highlight class="normal"></highlight></codeline>
<codeline lineno="3290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="3291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>botright<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3298"><highlight class="normal"></highlight></codeline>
<codeline lineno="3299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>8)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.BotRight[ib];</highlight></codeline>
<codeline lineno="3311"><highlight class="normal"></highlight></codeline>
<codeline lineno="3312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>z[read];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>bb);</highlight></codeline>
<codeline lineno="3316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>bb);</highlight></codeline>
<codeline lineno="3317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>bb);</highlight></codeline>
<codeline lineno="3318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>bb);</highlight></codeline>
<codeline lineno="3319"><highlight class="normal"></highlight></codeline>
<codeline lineno="3320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="3321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3323"><highlight class="normal"></highlight></codeline>
<codeline lineno="3324"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3325"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3326"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="3328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="3330"><highlight class="normal"></highlight></codeline>
<codeline lineno="3331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="3332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3333"><highlight class="normal"></highlight></codeline>
<codeline lineno="3334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.TopLeft[XBlock.BotLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="3335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>3.0);</highlight></codeline>
<codeline lineno="3336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>j<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="3337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>j<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="3338"><highlight class="normal"></highlight></codeline>
<codeline lineno="3339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="3341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>-1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="3342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//2<sp/>scenarios<sp/>here<sp/>ib<sp/>is<sp/>the<sp/>rightbot<sp/>neighbour<sp/>of<sp/>the<sp/>leftbot<sp/>block<sp/>or<sp/>ib<sp/>is<sp/>the<sp/>righttop<sp/>neighbour</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopLeft[XBlock.BotLeft[ib]]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="3346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3347"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[XBlock.BotLeft[ib]]<sp/>==<sp/>XBlock.BotLeft[ib])<sp/></highlight><highlight class="comment">//<sp/>no<sp/>botom<sp/>of<sp/>leftbot<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1));</highlight></codeline>
<codeline lineno="3350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="3351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="3352"><highlight class="normal"></highlight></codeline>
<codeline lineno="3353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]]<sp/>&lt;<sp/>XBlock.level[XBlock.BotLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>but<sp/>is<sp/>coarser</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="3357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="3358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="3359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]]);</highlight></codeline>
<codeline lineno="3360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]]<sp/>==<sp/>XBlock.level[XBlock.BotLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>same<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]]);</highlight></codeline>
<codeline lineno="3364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]]<sp/>&gt;<sp/>XBlock.level[XBlock.BotLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>higher<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="3368"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="3369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="3370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]]);</highlight></codeline>
<codeline lineno="3371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3372"><highlight class="normal"></highlight></codeline>
<codeline lineno="3373"><highlight class="normal"></highlight></codeline>
<codeline lineno="3374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3375"><highlight class="normal"></highlight></codeline>
<codeline lineno="3376"><highlight class="normal"></highlight></codeline>
<codeline lineno="3377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="comment">//righttopleftif<sp/>==<sp/>ib</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>(XParam.blkwidth<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="3381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[XBlock.BotRight[ib]]<sp/>==<sp/>XBlock.BotRight[ib])<sp/></highlight><highlight class="comment">//<sp/>no<sp/>botom<sp/>of<sp/>leftbot<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1));</highlight></codeline>
<codeline lineno="3385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="3386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="3387"><highlight class="normal"></highlight></codeline>
<codeline lineno="3388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightTop[XBlock.BotRight[ib]]]<sp/>&lt;<sp/>XBlock.level[XBlock.BotRight[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>but<sp/>is<sp/>coarser</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="3392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="3393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="3394"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.RightTop[XBlock.BotRight[ib]]);</highlight></codeline>
<codeline lineno="3395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightTop[XBlock.BotRight[ib]]]<sp/>==<sp/>XBlock.level[XBlock.BotRight[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>same<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3398"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,0,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.RightTop[XBlock.BotRight[ib]]);</highlight></codeline>
<codeline lineno="3399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightTop[XBlock.BotRight[ib]]]<sp/>&gt;<sp/>XBlock.level[XBlock.BotRight[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>higher<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="3403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="3404"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="3405"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,0,XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.RightTop[XBlock.BotRight[ib]]);</highlight></codeline>
<codeline lineno="3406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3408"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3409"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3410"><highlight class="normal"></highlight></codeline>
<codeline lineno="3411"><highlight class="normal"></highlight></codeline>
<codeline lineno="3412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>w1<sp/>*<sp/>z[ii]<sp/>+<sp/>w2<sp/>*<sp/>z[ir]<sp/>+<sp/>w3<sp/>*<sp/>z[it];</highlight></codeline>
<codeline lineno="3413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3414"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3415"><highlight class="normal"></highlight></codeline>
<codeline lineno="3416"><highlight class="normal"></highlight></codeline>
<codeline lineno="3417"><highlight class="normal"></highlight></codeline>
<codeline lineno="3418"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3419"><highlight class="normal"></highlight></codeline>
<codeline lineno="3420"><highlight class="normal"></highlight></codeline>
<codeline lineno="3421"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillBot(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="3422"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3423"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3424"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3425"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="3426"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>iy<sp/>=<sp/>0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3427"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="3428"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3429"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="3430"><highlight class="normal"></highlight></codeline>
<codeline lineno="3431"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BL<sp/>=<sp/>botleft[ib];</highlight></codeline>
<codeline lineno="3432"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BR<sp/>=<sp/>botright[ib];</highlight></codeline>
<codeline lineno="3433"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TLBL<sp/>=<sp/>topleft[BL];</highlight></codeline>
<codeline lineno="3434"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LTBL<sp/>=<sp/>lefttop[BL];</highlight></codeline>
<codeline lineno="3435"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RTBR<sp/>=<sp/>righttop[BR];</highlight></codeline>
<codeline lineno="3436"><highlight class="normal"></highlight></codeline>
<codeline lineno="3437"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="3438"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levBL<sp/>=<sp/>level[BL];</highlight></codeline>
<codeline lineno="3439"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levBR<sp/>=<sp/>level[BR];</highlight></codeline>
<codeline lineno="3440"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levLTBL<sp/>=<sp/>level[LTBL];</highlight></codeline>
<codeline lineno="3441"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRTBR<sp/>=<sp/>level[RTBR];</highlight></codeline>
<codeline lineno="3442"><highlight class="normal"></highlight></codeline>
<codeline lineno="3443"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="3444"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="3445"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="3446"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="3447"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="3448"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3449"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x/2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BR);</highlight></codeline>
<codeline lineno="3466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BR);</highlight></codeline>
<codeline lineno="3467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BR);</highlight></codeline>
<codeline lineno="3468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BR);</highlight></codeline>
<codeline lineno="3469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3472"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3473"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBL<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="3474"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BL);</highlight></codeline>
<codeline lineno="3476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3477"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3478"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBL<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="3479"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BL);</highlight></codeline>
<codeline lineno="3484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BL);</highlight></codeline>
<codeline lineno="3485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BL);</highlight></codeline>
<codeline lineno="3486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BL);</highlight></codeline>
<codeline lineno="3487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3496"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3497"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x/2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BR);</highlight></codeline>
<codeline lineno="3500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BR);</highlight></codeline>
<codeline lineno="3501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BR);</highlight></codeline>
<codeline lineno="3502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BR);</highlight></codeline>
<codeline lineno="3503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3506"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3507"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBL<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="3508"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>TLBL<sp/>==<sp/>ib<sp/>?<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.x<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="3510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>3.0;</highlight></codeline>
<codeline lineno="3511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="3512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="3513"><highlight class="normal"></highlight></codeline>
<codeline lineno="3514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>BL);</highlight></codeline>
<codeline lineno="3516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>BL);</highlight></codeline>
<codeline lineno="3517"><highlight class="normal"></highlight></codeline>
<codeline lineno="3518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TLBL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="3521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LTBL<sp/>==<sp/>BL)</highlight></codeline>
<codeline lineno="3523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="3525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="3526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="3527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLTBL<sp/>&lt;<sp/>levBL)</highlight></codeline>
<codeline lineno="3529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3530"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>LTBL);</highlight></codeline>
<codeline lineno="3534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLTBL<sp/>==<sp/>levBL)</highlight></codeline>
<codeline lineno="3536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>LTBL);</highlight></codeline>
<codeline lineno="3538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLTBL<sp/>&gt;<sp/>levBL)</highlight></codeline>
<codeline lineno="3540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="3543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>LTBL);</highlight></codeline>
<codeline lineno="3545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3549"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>(blockDim.x<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="3551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3552"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RTBR<sp/>==<sp/>BR)</highlight></codeline>
<codeline lineno="3553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="3555"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="3556"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="3557"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3558"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRTBR<sp/>&lt;<sp/>levBR)</highlight></codeline>
<codeline lineno="3559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3560"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3561"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3562"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3563"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,0,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>RTBR);</highlight></codeline>
<codeline lineno="3564"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3565"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRTBR<sp/>==<sp/>levBR)</highlight></codeline>
<codeline lineno="3566"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3567"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,0,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>RTBR);</highlight></codeline>
<codeline lineno="3568"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3569"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRTBR<sp/>&gt;<sp/>levBR)</highlight></codeline>
<codeline lineno="3570"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3571"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3572"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="3573"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3574"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>RTBR);</highlight></codeline>
<codeline lineno="3575"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3576"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3578"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>w1<sp/>*<sp/>a[ii]<sp/>+<sp/>w2<sp/>*<sp/>a[ir]<sp/>+<sp/>w3<sp/>*<sp/>a[it];</highlight></codeline>
<codeline lineno="3579"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3580"><highlight class="normal"><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="3581"><highlight class="normal"></highlight></codeline>
<codeline lineno="3582"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3583"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillBot&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="3584"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillBot&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="3585"><highlight class="normal"></highlight></codeline>
<codeline lineno="3586"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillBotnew(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="3587"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3588"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3589"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3590"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="3591"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>iy<sp/>=<sp/>0;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3592"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>threadIdx.y<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.y;</highlight></codeline>
<codeline lineno="3593"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ibl<sp/>&lt;<sp/>nblk)</highlight></codeline>
<codeline lineno="3594"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="3596"><highlight class="normal"></highlight></codeline>
<codeline lineno="3597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BL<sp/>=<sp/>botleft[ib];</highlight></codeline>
<codeline lineno="3598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BR<sp/>=<sp/>botright[ib];</highlight></codeline>
<codeline lineno="3599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TLBL<sp/>=<sp/>topleft[BL];</highlight></codeline>
<codeline lineno="3600"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LTBL<sp/>=<sp/>lefttop[BL];</highlight></codeline>
<codeline lineno="3601"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RTBR<sp/>=<sp/>righttop[BR];</highlight></codeline>
<codeline lineno="3602"><highlight class="normal"></highlight></codeline>
<codeline lineno="3603"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="3604"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levBL<sp/>=<sp/>level[BL];</highlight></codeline>
<codeline lineno="3605"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levBR<sp/>=<sp/>level[BR];</highlight></codeline>
<codeline lineno="3606"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levLTBL<sp/>=<sp/>level[LTBL];</highlight></codeline>
<codeline lineno="3607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRTBR<sp/>=<sp/>level[RTBR];</highlight></codeline>
<codeline lineno="3608"><highlight class="normal"></highlight></codeline>
<codeline lineno="3609"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="3610"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="3611"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="3612"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="3613"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="3614"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3615"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3616"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3617"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3618"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3619"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3620"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3623"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3625"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3626"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BR);</highlight></codeline>
<codeline lineno="3632"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BR);</highlight></codeline>
<codeline lineno="3633"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BR);</highlight></codeline>
<codeline lineno="3634"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BR);</highlight></codeline>
<codeline lineno="3635"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3636"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3637"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3638"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3639"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBL<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="3640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BL);</highlight></codeline>
<codeline lineno="3642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBL<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="3645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BL);</highlight></codeline>
<codeline lineno="3650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BL);</highlight></codeline>
<codeline lineno="3651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BL);</highlight></codeline>
<codeline lineno="3652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BL);</highlight></codeline>
<codeline lineno="3653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3655"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3663"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3664"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3665"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BR);</highlight></codeline>
<codeline lineno="3666"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BR);</highlight></codeline>
<codeline lineno="3667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>1),<sp/>BR);</highlight></codeline>
<codeline lineno="3668"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(blockDim.x<sp/>-<sp/>2),<sp/>BR);</highlight></codeline>
<codeline lineno="3669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3670"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3671"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3672"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levBL<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="3674"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3675"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>TLBL<sp/>==<sp/>ib<sp/>?<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.x<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="3676"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>3.0;</highlight></codeline>
<codeline lineno="3677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="3678"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="3679"><highlight class="normal"></highlight></codeline>
<codeline lineno="3680"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3681"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>BL);</highlight></codeline>
<codeline lineno="3682"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>BL);</highlight></codeline>
<codeline lineno="3683"><highlight class="normal"></highlight></codeline>
<codeline lineno="3684"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TLBL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3685"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3686"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="3687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LTBL<sp/>==<sp/>BL)</highlight></codeline>
<codeline lineno="3689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3690"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="3691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="3692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="3693"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLTBL<sp/>&lt;<sp/>levBL)</highlight></codeline>
<codeline lineno="3695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3696"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3697"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3699"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>LTBL);</highlight></codeline>
<codeline lineno="3700"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3701"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLTBL<sp/>==<sp/>levBL)</highlight></codeline>
<codeline lineno="3702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>LTBL);</highlight></codeline>
<codeline lineno="3704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3705"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLTBL<sp/>&gt;<sp/>levBL)</highlight></codeline>
<codeline lineno="3706"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3707"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3708"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="3709"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3710"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>LTBL);</highlight></codeline>
<codeline lineno="3711"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3714"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3715"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3716"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>(blockDim.x<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="3717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RTBR<sp/>==<sp/>BR)</highlight></codeline>
<codeline lineno="3719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="3721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="3722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="3723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRTBR<sp/>&lt;<sp/>levBR)</highlight></codeline>
<codeline lineno="3725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="3729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>RTBR);</highlight></codeline>
<codeline lineno="3730"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3731"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRTBR<sp/>==<sp/>levBR)</highlight></codeline>
<codeline lineno="3732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>RTBR);</highlight></codeline>
<codeline lineno="3734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRTBR<sp/>&gt;<sp/>levBR)</highlight></codeline>
<codeline lineno="3736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="3739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="3740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>RTBR);</highlight></codeline>
<codeline lineno="3741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3742"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>w1<sp/>*<sp/>a[ii]<sp/>+<sp/>w2<sp/>*<sp/>a[ir]<sp/>+<sp/>w3<sp/>*<sp/>a[it];</highlight></codeline>
<codeline lineno="3745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="3747"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3748"><highlight class="normal"></highlight></codeline>
<codeline lineno="3749"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3750"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillBotnew&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="3751"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillBotnew&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>lefttop,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>righttop,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="3752"><highlight class="normal"></highlight></codeline>
<codeline lineno="3753"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillBotFlux(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="3754"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3755"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>bb;</highlight></codeline>
<codeline lineno="3756"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>write;</highlight></codeline>
<codeline lineno="3757"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/>ir,<sp/>it;</highlight></codeline>
<codeline lineno="3758"><highlight class="normal"></highlight></codeline>
<codeline lineno="3759"><highlight class="normal"></highlight></codeline>
<codeline lineno="3760"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3761"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3762"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="3763"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3764"><highlight class="normal"></highlight></codeline>
<codeline lineno="3765"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3766"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3767"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3768"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3769"><highlight class="normal"></highlight></codeline>
<codeline lineno="3770"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3771"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3773"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3775"><highlight class="normal"></highlight></codeline>
<codeline lineno="3776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3777"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3779"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3780"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3783"><highlight class="normal"></highlight></codeline>
<codeline lineno="3784"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3785"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3786"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="3787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>8)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3788"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotRight[ib]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3790"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3791"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotRight[ib]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3792"><highlight class="normal"></highlight></codeline>
<codeline lineno="3793"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[it]<sp/>);</highlight></codeline>
<codeline lineno="3794"><highlight class="normal"></highlight></codeline>
<codeline lineno="3795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3797"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3798"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.BotLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3799"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="3801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3803"><highlight class="normal"></highlight></codeline>
<codeline lineno="3804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="3805"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="3806"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3807"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3808"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3809"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="3810"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3811"><highlight class="normal"></highlight></codeline>
<codeline lineno="3812"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth<sp/>/<sp/>2;<sp/>j++)</highlight></codeline>
<codeline lineno="3813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3814"><highlight class="normal"></highlight></codeline>
<codeline lineno="3815"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="3816"><highlight class="normal"></highlight></codeline>
<codeline lineno="3817"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3818"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.BotLeft[ib];</highlight></codeline>
<codeline lineno="3819"><highlight class="normal"></highlight></codeline>
<codeline lineno="3820"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>bb);</highlight></codeline>
<codeline lineno="3821"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3822"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>bb);</highlight></codeline>
<codeline lineno="3823"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3824"><highlight class="normal"></highlight></codeline>
<codeline lineno="3825"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="3826"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>botright<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3829"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3833"><highlight class="normal"></highlight></codeline>
<codeline lineno="3834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3838"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3840"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>8)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.BotRight[ib];</highlight></codeline>
<codeline lineno="3846"><highlight class="normal"></highlight></codeline>
<codeline lineno="3847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>z[read];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>bb);</highlight></codeline>
<codeline lineno="3851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>bb);</highlight></codeline>
<codeline lineno="3853"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3854"><highlight class="normal"></highlight></codeline>
<codeline lineno="3855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/><sp/>+<sp/>z[it]<sp/>);</highlight></codeline>
<codeline lineno="3856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3857"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3858"><highlight class="normal"></highlight></codeline>
<codeline lineno="3859"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3860"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3861"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3862"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="3863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3864"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="3865"><highlight class="normal"></highlight></codeline>
<codeline lineno="3866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//T<sp/>w1,<sp/>w2,<sp/>w3;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3867"><highlight class="normal"></highlight></codeline>
<codeline lineno="3868"><highlight class="normal"></highlight></codeline>
<codeline lineno="3869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.TopLeft[XBlock.BotLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="3870"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3871"><highlight class="normal"></highlight></codeline>
<codeline lineno="3872"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ii<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>ib);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3873"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="3874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(doProlongation)</highlight></codeline>
<codeline lineno="3875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[ir];</highlight></codeline>
<codeline lineno="3876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3877"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3878"><highlight class="normal"></highlight></codeline>
<codeline lineno="3879"><highlight class="normal"></highlight></codeline>
<codeline lineno="3880"><highlight class="normal"></highlight></codeline>
<codeline lineno="3881"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3882"><highlight class="normal"></highlight></codeline>
<codeline lineno="3883"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTop(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="3884"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3885"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>bb;</highlight></codeline>
<codeline lineno="3886"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>write;</highlight></codeline>
<codeline lineno="3887"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="3888"><highlight class="normal"></highlight></codeline>
<codeline lineno="3889"><highlight class="normal"></highlight></codeline>
<codeline lineno="3890"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3891"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3892"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="3893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3894"><highlight class="normal"></highlight></codeline>
<codeline lineno="3895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,j,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,j,<sp/>XParam.blkwidth,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3897"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3898"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3899"><highlight class="normal"></highlight></codeline>
<codeline lineno="3900"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3901"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3902"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3903"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3904"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3905"><highlight class="normal"></highlight></codeline>
<codeline lineno="3906"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3907"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3910"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3911"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3912"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3913"><highlight class="normal"></highlight></codeline>
<codeline lineno="3914"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3915"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3916"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="3917"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>(XParam.blkwidth<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3918"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="3919"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>1,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="3920"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="3921"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="3922"><highlight class="normal"></highlight></codeline>
<codeline lineno="3923"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="3924"><highlight class="normal"></highlight></codeline>
<codeline lineno="3925"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3926"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3927"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3928"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.TopLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3929"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3930"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="3931"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3932"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3933"><highlight class="normal"></highlight></codeline>
<codeline lineno="3934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="3935"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="3936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3938"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3939"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="3940"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3941"><highlight class="normal"></highlight></codeline>
<codeline lineno="3942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth<sp/>/<sp/>2;<sp/>j++)</highlight></codeline>
<codeline lineno="3943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3944"><highlight class="normal"></highlight></codeline>
<codeline lineno="3945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="3946"><highlight class="normal"></highlight></codeline>
<codeline lineno="3947"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.TopLeft[ib];</highlight></codeline>
<codeline lineno="3949"><highlight class="normal"></highlight></codeline>
<codeline lineno="3950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,jj,<sp/>0,<sp/>bb);</highlight></codeline>
<codeline lineno="3951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,jj,<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="3952"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,jj<sp/>+<sp/>1,<sp/>0,<sp/>bb);</highlight></codeline>
<codeline lineno="3953"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,jj<sp/>+<sp/>1,<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="3954"><highlight class="normal"></highlight></codeline>
<codeline lineno="3955"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="3956"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3957"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3958"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3959"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3960"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3961"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3962"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3963"><highlight class="normal"></highlight></codeline>
<codeline lineno="3964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,j,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3965"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3966"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="3967"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3968"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3969"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3970"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3971"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="3972"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>(XParam.blkwidth<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3975"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.TopRight[ib];</highlight></codeline>
<codeline lineno="3976"><highlight class="normal"></highlight></codeline>
<codeline lineno="3977"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3978"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j<sp/>,<sp/>XParam.blkwidth,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3979"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>z[read];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3980"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,jj,<sp/>0,<sp/>bb);</highlight></codeline>
<codeline lineno="3981"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,jj,<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="3982"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,jj<sp/>+<sp/>1,<sp/>0,<sp/>bb);</highlight></codeline>
<codeline lineno="3983"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,jj<sp/>+<sp/>1,<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="3984"><highlight class="normal"></highlight></codeline>
<codeline lineno="3985"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="3986"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3987"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3988"><highlight class="normal"></highlight></codeline>
<codeline lineno="3989"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3990"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3991"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3992"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="3993"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3994"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="3995"><highlight class="normal"></highlight></codeline>
<codeline lineno="3996"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="3997"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3998"><highlight class="normal"></highlight></codeline>
<codeline lineno="3999"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.BotLeft[XBlock.TopLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="4000"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>3.0);</highlight></codeline>
<codeline lineno="4001"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>j<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="4002"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(j<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>j<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="4003"><highlight class="normal"></highlight></codeline>
<codeline lineno="4004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,j,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,jj,<sp/>0,<sp/><sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="4006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,jj-1,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="4007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//2<sp/>scenarios<sp/>here<sp/>ib<sp/>is<sp/>the<sp/>leftbot<sp/>neighbour<sp/>of<sp/>the<sp/>rightbot<sp/>block<sp/>or<sp/>ib<sp/>is<sp/>the<sp/>lefttop<sp/>neighbour</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotLeft[XBlock.TopLeft[ib]]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4010"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="4011"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4012"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftBot[XBlock.TopLeft[ib]]<sp/>==<sp/>XBlock.TopLeft[ib])<sp/></highlight><highlight class="comment">//<sp/>no<sp/>botom<sp/>of<sp/>leftbot<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4013"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4014"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1));</highlight></codeline>
<codeline lineno="4015"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="4016"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="4017"><highlight class="normal"></highlight></codeline>
<codeline lineno="4018"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4019"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]]<sp/>&lt;<sp/>XBlock.level[XBlock.TopLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>but<sp/>is<sp/>coarser</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4020"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4021"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="4022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="4023"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="4024"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,0,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="4025"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4026"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]]<sp/>==<sp/>XBlock.level[XBlock.TopLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>same<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4027"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4028"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/><sp/>XParam.blkwidth<sp/>-<sp/>1,0,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="4029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4030"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]]<sp/>&gt;<sp/>XBlock.level[XBlock.TopLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>higher<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="4033"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="4034"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="4035"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>0,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="4036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4037"><highlight class="normal"></highlight></codeline>
<codeline lineno="4038"><highlight class="normal"></highlight></codeline>
<codeline lineno="4039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4040"><highlight class="normal"></highlight></codeline>
<codeline lineno="4041"><highlight class="normal"></highlight></codeline>
<codeline lineno="4042"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4043"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>(XParam.blkwidth<sp/>-<sp/>1))</highlight></codeline>
<codeline lineno="4046"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightBot[XBlock.TopRight[ib]]<sp/>==<sp/>XBlock.TopRight[ib])<sp/></highlight><highlight class="comment">//<sp/>no<sp/>botom<sp/>of<sp/>leftbot<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4048"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1));</highlight></codeline>
<codeline lineno="4050"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="4051"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="4052"><highlight class="normal"></highlight></codeline>
<codeline lineno="4053"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]]<sp/>&lt;<sp/>XBlock.level[XBlock.TopRight[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>but<sp/>is<sp/>coarser</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(4.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="4057"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="4058"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(5.0<sp/>/<sp/>10.0);</highlight></codeline>
<codeline lineno="4059"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>0,<sp/>XBlock.RightBot[XBlock.TopRight[ib]]);</highlight></codeline>
<codeline lineno="4060"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4061"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]]<sp/>==<sp/>XBlock.level[XBlock.TopRight[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>same<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4062"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4063"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>0,<sp/>XBlock.RightBot[XBlock.TopRight[ib]]);</highlight></codeline>
<codeline lineno="4064"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4065"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]]<sp/>&gt;<sp/>XBlock.level[XBlock.TopRight[ib]])<sp/></highlight><highlight class="comment">//<sp/>exists<sp/>with<sp/>higher<sp/>level</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4066"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4067"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="4068"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>T(1.0<sp/>/<sp/>2.0);</highlight></codeline>
<codeline lineno="4069"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>T(1.0<sp/>/<sp/>4.0);</highlight></codeline>
<codeline lineno="4070"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,0,<sp/>XBlock.RightBot[XBlock.TopRight[ib]]);</highlight></codeline>
<codeline lineno="4071"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4072"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4073"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4074"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4075"><highlight class="normal"></highlight></codeline>
<codeline lineno="4076"><highlight class="normal"></highlight></codeline>
<codeline lineno="4077"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>w1<sp/>*<sp/>z[ii]<sp/>+<sp/>w2<sp/>*<sp/>z[ir]<sp/>+<sp/>w3<sp/>*<sp/>z[it];</highlight></codeline>
<codeline lineno="4078"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4079"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4080"><highlight class="normal"></highlight></codeline>
<codeline lineno="4081"><highlight class="normal"></highlight></codeline>
<codeline lineno="4082"><highlight class="normal"></highlight></codeline>
<codeline lineno="4083"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4084"><highlight class="normal"></highlight></codeline>
<codeline lineno="4085"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTop(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>topright,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/><sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="4086"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4087"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4088"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4089"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="4090"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>iy<sp/>=<sp/>blockDim.x-1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4091"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="4092"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="4093"><highlight class="normal"></highlight></codeline>
<codeline lineno="4094"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TL<sp/>=<sp/>topleft[ib];</highlight></codeline>
<codeline lineno="4095"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TR<sp/>=<sp/>topright[ib];</highlight></codeline>
<codeline lineno="4096"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LBTL<sp/>=<sp/>leftbot[TL];</highlight></codeline>
<codeline lineno="4097"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BLTL<sp/>=<sp/>botleft[TL];</highlight></codeline>
<codeline lineno="4098"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RBTR<sp/>=<sp/>rightbot[TR];</highlight></codeline>
<codeline lineno="4099"><highlight class="normal"></highlight></codeline>
<codeline lineno="4100"><highlight class="normal"></highlight></codeline>
<codeline lineno="4101"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="4102"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTL<sp/>=<sp/>level[TL];</highlight></codeline>
<codeline lineno="4103"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTR<sp/>=<sp/>level[TR];</highlight></codeline>
<codeline lineno="4104"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levLBTL<sp/>=<sp/>level[LBTL];</highlight></codeline>
<codeline lineno="4105"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRBTR<sp/>=<sp/>level[RBTR];</highlight></codeline>
<codeline lineno="4106"><highlight class="normal"></highlight></codeline>
<codeline lineno="4107"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x,<sp/>ib);</highlight></codeline>
<codeline lineno="4108"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="4109"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="4110"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="4111"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="4112"><highlight class="normal"></highlight></codeline>
<codeline lineno="4113"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4114"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TR);</highlight></codeline>
<codeline lineno="4132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TR);</highlight></codeline>
<codeline lineno="4134"><highlight class="normal"></highlight></codeline>
<codeline lineno="4135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4138"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4139"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="4140"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4143"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4144"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="4145"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="4150"><highlight class="normal"></highlight></codeline>
<codeline lineno="4151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TL);</highlight></codeline>
<codeline lineno="4153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TL);</highlight></codeline>
<codeline lineno="4155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x-1,<sp/>ib);</highlight></codeline>
<codeline lineno="4162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TR);</highlight></codeline>
<codeline lineno="4169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TR);</highlight></codeline>
<codeline lineno="4171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4174"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4175"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="4176"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>BLTL<sp/>==<sp/>ib<sp/>?<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.x<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="4178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>3.0;</highlight></codeline>
<codeline lineno="4179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="4180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="4181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BLTL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="4187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LBTL<sp/>==<sp/>TL)</highlight></codeline>
<codeline lineno="4189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="4191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="4192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="4193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLBTL<sp/>&lt;<sp/>levTL)</highlight></codeline>
<codeline lineno="4195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>0,<sp/>LBTL);</highlight></codeline>
<codeline lineno="4200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLBTL<sp/>==<sp/>levTL)</highlight></codeline>
<codeline lineno="4202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>0,<sp/>LBTL);</highlight></codeline>
<codeline lineno="4204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLBTL<sp/>&gt;<sp/>levTL)</highlight></codeline>
<codeline lineno="4206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="4209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>0,<sp/>LBTL);</highlight></codeline>
<codeline lineno="4211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>blockDim.x<sp/>-<sp/>1)</highlight></codeline>
<codeline lineno="4217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RBTR<sp/>==<sp/>TR)</highlight></codeline>
<codeline lineno="4219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="4221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="4222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="4223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRBTR<sp/>&lt;<sp/>levTR)</highlight></codeline>
<codeline lineno="4225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>RBTR);</highlight></codeline>
<codeline lineno="4230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRBTR<sp/>==<sp/>levTR)</highlight></codeline>
<codeline lineno="4232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>RBTR);</highlight></codeline>
<codeline lineno="4234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRBTR<sp/>&gt;<sp/>levTR)</highlight></codeline>
<codeline lineno="4236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="4239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,0,<sp/>0,<sp/>RBTR);</highlight></codeline>
<codeline lineno="4241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read=<sp/>w1<sp/>*<sp/>a[ii]<sp/>+<sp/>w2<sp/>*<sp/>a[ir]<sp/>+<sp/>w3<sp/>*<sp/>a[it];</highlight></codeline>
<codeline lineno="4245"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4246"><highlight class="normal"><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="4247"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4248"><highlight class="normal"></highlight></codeline>
<codeline lineno="4249"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTop&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="4250"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTop&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="4251"><highlight class="normal"></highlight></codeline>
<codeline lineno="4252"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopnew(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="4253"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4254"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4255"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4256"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="4257"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>iy<sp/>=<sp/>blockDim.x-1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4258"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>threadIdx.y<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.y;</highlight></codeline>
<codeline lineno="4259"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ibl<sp/>&lt;<sp/>nblk)</highlight></codeline>
<codeline lineno="4260"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="4262"><highlight class="normal"></highlight></codeline>
<codeline lineno="4263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TL<sp/>=<sp/>topleft[ib];</highlight></codeline>
<codeline lineno="4264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TR<sp/>=<sp/>topright[ib];</highlight></codeline>
<codeline lineno="4265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LBTL<sp/>=<sp/>leftbot[TL];</highlight></codeline>
<codeline lineno="4266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BLTL<sp/>=<sp/>botleft[TL];</highlight></codeline>
<codeline lineno="4267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RBTR<sp/>=<sp/>rightbot[TR];</highlight></codeline>
<codeline lineno="4268"><highlight class="normal"></highlight></codeline>
<codeline lineno="4269"><highlight class="normal"></highlight></codeline>
<codeline lineno="4270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="4271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTL<sp/>=<sp/>level[TL];</highlight></codeline>
<codeline lineno="4272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTR<sp/>=<sp/>level[TR];</highlight></codeline>
<codeline lineno="4273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levLBTL<sp/>=<sp/>level[LBTL];</highlight></codeline>
<codeline lineno="4274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levRBTR<sp/>=<sp/>level[RBTR];</highlight></codeline>
<codeline lineno="4275"><highlight class="normal"></highlight></codeline>
<codeline lineno="4276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x,<sp/>ib);</highlight></codeline>
<codeline lineno="4277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="4278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="4279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="4280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>w1,<sp/>w2,<sp/>w3;</highlight></codeline>
<codeline lineno="4281"><highlight class="normal"></highlight></codeline>
<codeline lineno="4282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TR);</highlight></codeline>
<codeline lineno="4301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TR);</highlight></codeline>
<codeline lineno="4303"><highlight class="normal"></highlight></codeline>
<codeline lineno="4304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="4309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="4314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4318"><highlight class="normal"></highlight></codeline>
<codeline lineno="4319"><highlight class="normal"></highlight></codeline>
<codeline lineno="4320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TL);</highlight></codeline>
<codeline lineno="4322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TL);</highlight></codeline>
<codeline lineno="4324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TR);</highlight></codeline>
<codeline lineno="4338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TR);</highlight></codeline>
<codeline lineno="4340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="4345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>BLTL<sp/>==<sp/>ib<sp/>?<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.x<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="4347"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>3.0;</highlight></codeline>
<codeline lineno="4348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(1.0<sp/>/<sp/>6.0)<sp/>:<sp/>T(0.5);</highlight></codeline>
<codeline lineno="4349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.5)<sp/>:<sp/>T(1.0<sp/>/<sp/>6.0);</highlight></codeline>
<codeline lineno="4350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BLTL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="4356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(LBTL<sp/>==<sp/>TL)</highlight></codeline>
<codeline lineno="4358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="4360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="4361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>ir;</highlight></codeline>
<codeline lineno="4362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLBTL<sp/>&lt;<sp/>levTL)</highlight></codeline>
<codeline lineno="4364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4368"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>0,<sp/>LBTL);</highlight></codeline>
<codeline lineno="4369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLBTL<sp/>==<sp/>levTL)</highlight></codeline>
<codeline lineno="4371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>0,<sp/>LBTL);</highlight></codeline>
<codeline lineno="4373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levLBTL<sp/>&gt;<sp/>levTL)</highlight></codeline>
<codeline lineno="4375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="4378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>0,<sp/>LBTL);</highlight></codeline>
<codeline lineno="4380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>blockDim.x<sp/>-<sp/>1)</highlight></codeline>
<codeline lineno="4386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(RBTR<sp/>==<sp/>TR)</highlight></codeline>
<codeline lineno="4388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>0.5<sp/>*<sp/>(1.0<sp/>-<sp/>w1);</highlight></codeline>
<codeline lineno="4390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>w3;</highlight></codeline>
<codeline lineno="4391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="4392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRBTR<sp/>&lt;<sp/>levTR)</highlight></codeline>
<codeline lineno="4394"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>4.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>5.0<sp/>/<sp/>10.0;</highlight></codeline>
<codeline lineno="4398"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>RBTR);</highlight></codeline>
<codeline lineno="4399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRBTR<sp/>==<sp/>levTR)</highlight></codeline>
<codeline lineno="4401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>RBTR);</highlight></codeline>
<codeline lineno="4403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4404"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levRBTR<sp/>&gt;<sp/>levTR)</highlight></codeline>
<codeline lineno="4405"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w1<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w2<sp/>=<sp/>1.0<sp/>/<sp/>2.0;</highlight></codeline>
<codeline lineno="4408"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>w3<sp/>=<sp/>1.0<sp/>/<sp/>4.0;</highlight></codeline>
<codeline lineno="4409"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>RBTR);</highlight></codeline>
<codeline lineno="4410"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4411"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>w1<sp/>*<sp/>a[ii]<sp/>+<sp/>w2<sp/>*<sp/>a[ir]<sp/>+<sp/>w3<sp/>*<sp/>a[it];</highlight></codeline>
<codeline lineno="4414"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="4416"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4417"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4418"><highlight class="normal"></highlight></codeline>
<codeline lineno="4419"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopnew&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="4420"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopnew&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="4421"><highlight class="normal"></highlight></codeline>
<codeline lineno="4422"><highlight class="normal"></highlight></codeline>
<codeline lineno="4423"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopFlux(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="4424"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4425"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>bb;</highlight></codeline>
<codeline lineno="4426"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>write;</highlight></codeline>
<codeline lineno="4427"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/>ir,<sp/>it;</highlight></codeline>
<codeline lineno="4428"><highlight class="normal"></highlight></codeline>
<codeline lineno="4429"><highlight class="normal"></highlight></codeline>
<codeline lineno="4430"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4431"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j++)</highlight></codeline>
<codeline lineno="4433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4434"><highlight class="normal"></highlight></codeline>
<codeline lineno="4435"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4436"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4437"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="4438"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4439"><highlight class="normal"></highlight></codeline>
<codeline lineno="4440"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4441"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4442"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="4443"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4445"><highlight class="normal"></highlight></codeline>
<codeline lineno="4446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="4449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4453"><highlight class="normal"></highlight></codeline>
<codeline lineno="4454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="4455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="4457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>(XParam.blkwidth<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>1,<sp/>XBlock.TopRight[ib]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>XBlock.TopRight[ib]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4462"><highlight class="normal"></highlight></codeline>
<codeline lineno="4463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[it]<sp/>);</highlight></codeline>
<codeline lineno="4464"><highlight class="normal"></highlight></codeline>
<codeline lineno="4465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4467"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4468"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.TopLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4469"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="4471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4473"><highlight class="normal"></highlight></codeline>
<codeline lineno="4474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="4475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="4476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="4477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4478"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4479"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4480"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4481"><highlight class="normal"></highlight></codeline>
<codeline lineno="4482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth<sp/>/<sp/>2;<sp/>j++)</highlight></codeline>
<codeline lineno="4483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4484"><highlight class="normal"></highlight></codeline>
<codeline lineno="4485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="4486"><highlight class="normal"></highlight></codeline>
<codeline lineno="4487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>j<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.TopLeft[ib];</highlight></codeline>
<codeline lineno="4489"><highlight class="normal"></highlight></codeline>
<codeline lineno="4490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>0,<sp/>bb);</highlight></codeline>
<codeline lineno="4491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>1,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>bb);</highlight></codeline>
<codeline lineno="4493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4494"><highlight class="normal"></highlight></codeline>
<codeline lineno="4495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/><sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="4496"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4497"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="4501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4503"><highlight class="normal"></highlight></codeline>
<codeline lineno="4504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight><highlight class="comment">//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[read];</highlight></codeline>
<codeline lineno="4507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>(XParam.blkwidth<sp/>/<sp/>2);<sp/>j<sp/>&lt;<sp/>(XParam.blkwidth);<sp/>j++)</highlight></codeline>
<codeline lineno="4512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4513"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(j<sp/>-<sp/>(XParam.blkwidth<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bb<sp/>=<sp/>XBlock.TopRight[ib];</highlight></codeline>
<codeline lineno="4516"><highlight class="normal"></highlight></codeline>
<codeline lineno="4517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>j,<sp/>ib);//<sp/>1<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);<sp/></highlight><highlight class="comment">//0<sp/>+<sp/>(j<sp/>+<sp/>XParam.halowidth)<sp/>*<sp/>XParam.blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>XParam.blksize;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//z[write]<sp/>=<sp/>z[read];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>0,<sp/>bb);</highlight></codeline>
<codeline lineno="4521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>1,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>bb);</highlight></codeline>
<codeline lineno="4523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>bb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4524"><highlight class="normal"></highlight></codeline>
<codeline lineno="4525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[ii]<sp/><sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="4526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4528"><highlight class="normal"></highlight></codeline>
<codeline lineno="4529"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4530"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4531"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>XParam.blkwidth;<sp/>j++)</highlight></codeline>
<codeline lineno="4533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>j,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="4535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj<sp/>=<sp/>XBlock.BotLeft[XBlock.TopLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(floor(j<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(floor(j<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="4536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="4537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="4538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="4539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(doProlongation)</highlight></codeline>
<codeline lineno="4540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>z[ir];</highlight></codeline>
<codeline lineno="4541"><highlight class="normal"></highlight></codeline>
<codeline lineno="4542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4543"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4544"><highlight class="normal"></highlight></codeline>
<codeline lineno="4545"><highlight class="normal"></highlight></codeline>
<codeline lineno="4546"><highlight class="normal"></highlight></codeline>
<codeline lineno="4547"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4548"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopFlux&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*&amp;<sp/>z);</highlight></codeline>
<codeline lineno="4549"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopFlux&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*&amp;<sp/>z);</highlight></codeline>
<codeline lineno="4550"><highlight class="normal"></highlight></codeline>
<codeline lineno="4551"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopFlux(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/>T*<sp/>a)</highlight></codeline>
<codeline lineno="4552"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4553"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4554"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4555"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="4556"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>iy<sp/>=<sp/>blockDim.x<sp/>-<sp/>1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4557"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="4558"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="4559"><highlight class="normal"></highlight></codeline>
<codeline lineno="4560"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TL<sp/>=<sp/>topleft[ib];</highlight></codeline>
<codeline lineno="4561"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TR<sp/>=<sp/>topright[ib];</highlight></codeline>
<codeline lineno="4562"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>LBTL<sp/>=<sp/>leftbot[TL];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4563"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BLTL<sp/>=<sp/>botleft[TL];</highlight></codeline>
<codeline lineno="4564"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>RBTR<sp/>=<sp/>rightbot[TR];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4565"><highlight class="normal"></highlight></codeline>
<codeline lineno="4566"><highlight class="normal"></highlight></codeline>
<codeline lineno="4567"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="4568"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>levTL<sp/>=<sp/>level[TL];</highlight></codeline>
<codeline lineno="4569"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>levTR<sp/>=<sp/>level[TR];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4570"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>levLBTL<sp/>=<sp/>level[LBTL];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4571"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>levRBTR<sp/>=<sp/>level[RBTR];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4572"><highlight class="normal"></highlight></codeline>
<codeline lineno="4573"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x,<sp/>ib);</highlight></codeline>
<codeline lineno="4574"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="4575"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>jj,<sp/>ii,<sp/>ir,<sp/>it;</highlight></codeline>
<codeline lineno="4576"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>a_read;</highlight></codeline>
<codeline lineno="4577"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//T<sp/>w1,<sp/>w2,<sp/>w3;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4578"><highlight class="normal"></highlight></codeline>
<codeline lineno="4579"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TL<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4580"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4581"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4582"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4583"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4584"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4586"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4589"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4590"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4591"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TR);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TR);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4600"><highlight class="normal"></highlight></codeline>
<codeline lineno="4601"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.5)<sp/>*<sp/>(a[ii]<sp/><sp/>+<sp/>a[it]<sp/>);</highlight></codeline>
<codeline lineno="4602"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4603"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4604"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4605"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>==<sp/>lev)</highlight></codeline>
<codeline lineno="4606"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4608"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4609"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4610"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>&gt;<sp/>lev)</highlight></codeline>
<codeline lineno="4611"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4612"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(blockDim.x<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4613"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4614"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4615"><highlight class="normal"></highlight></codeline>
<codeline lineno="4616"><highlight class="normal"></highlight></codeline>
<codeline lineno="4617"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4618"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TL);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4619"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4620"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TL);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.5)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[it]);</highlight></codeline>
<codeline lineno="4622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4623"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4625"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TR<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4626"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>blockDim.x<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4632"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>(blockDim.x<sp/>/<sp/>2))<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4633"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4634"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>TR);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4635"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4636"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//itr<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>1,<sp/>TR);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4637"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>T(0.5)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[it]);</highlight></codeline>
<codeline lineno="4638"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4639"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4640"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4641"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(levTL<sp/>&lt;<sp/>lev)</highlight></codeline>
<codeline lineno="4642"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>BLTL<sp/>==<sp/>ib<sp/>?<sp/>floor(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>floor(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>blockDim.x<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="4644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="4645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(doProlongation)</highlight></codeline>
<codeline lineno="4647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/>a[ir];</highlight></codeline>
<codeline lineno="4648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_read<sp/>=<sp/><sp/>a[write];</highlight></codeline>
<codeline lineno="4650"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4651"><highlight class="normal"><sp/><sp/><sp/><sp/>a[write]<sp/>=<sp/>a_read;</highlight></codeline>
<codeline lineno="4652"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4653"><highlight class="normal"></highlight></codeline>
<codeline lineno="4654"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopFlux&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="4655"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillTopFlux&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>doProlongation,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>topright,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>botleft,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>leftbot,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>rightbot,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a);</highlight></codeline>
<codeline lineno="4656"><highlight class="normal"></highlight></codeline>
<codeline lineno="4657"><highlight class="normal"></highlight></codeline>
<codeline lineno="4658"><highlight class="normal"></highlight></codeline>
<codeline lineno="4659"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="4660"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4661"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib;</highlight></codeline>
<codeline lineno="4662"><highlight class="normal"></highlight></codeline>
<codeline lineno="4663"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="4664"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4665"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="4666"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillCorners(XParam,<sp/>ib,<sp/>XBlock,<sp/>z);</highlight></codeline>
<codeline lineno="4667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="4668"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4669"><highlight class="normal"></highlight></codeline>
<codeline lineno="4670"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4671"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*&amp;<sp/>z);</highlight></codeline>
<codeline lineno="4672"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*&amp;<sp/>z);</highlight></codeline>
<codeline lineno="4673"><highlight class="normal"></highlight></codeline>
<codeline lineno="4674"><highlight class="normal"></highlight></codeline>
<codeline lineno="4675"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;T&gt;</ref>&amp;<sp/>Xev)</highlight></codeline>
<codeline lineno="4676"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4677"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib;</highlight></codeline>
<codeline lineno="4678"><highlight class="normal"></highlight></codeline>
<codeline lineno="4679"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="4680"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4681"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="4682"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillCorners(XParam,<sp/>ib,<sp/>XBlock,<sp/>Xev.h);</highlight></codeline>
<codeline lineno="4683"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillCorners(XParam,<sp/>ib,<sp/>XBlock,<sp/>Xev.zs);</highlight></codeline>
<codeline lineno="4684"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillCorners(XParam,<sp/>ib,<sp/>XBlock,<sp/>Xev.u);</highlight></codeline>
<codeline lineno="4685"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fillCorners(XParam,<sp/>ib,<sp/>XBlock,<sp/>Xev.v);</highlight></codeline>
<codeline lineno="4686"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4687"><highlight class="normal"></highlight></codeline>
<codeline lineno="4688"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4689"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;float&gt;</ref>&amp;<sp/>Xev);</highlight></codeline>
<codeline lineno="4690"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/><ref refid="structEvolvingP" kindref="compound">EvolvingP&lt;double&gt;</ref>&amp;<sp/>Xev);</highlight></codeline>
<codeline lineno="4691"><highlight class="normal"></highlight></codeline>
<codeline lineno="4692"><highlight class="normal"></highlight></codeline>
<codeline lineno="4693"><highlight class="normal"></highlight></codeline>
<codeline lineno="4694"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*&amp;<sp/>z)</highlight></codeline>
<codeline lineno="4695"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4696"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Run<sp/>only<sp/>this<sp/>function<sp/>after<sp/>the<sp/>filling<sp/>the<sp/>other<sp/>bit<sp/>of<sp/>halo<sp/>(i.e.<sp/>fctn<sp/>fillleft...)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4697"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Most<sp/>of<sp/>the<sp/>time<sp/>the<sp/>cormers<sp/>are<sp/>not<sp/>needed.<sp/>they<sp/>are<sp/>when<sp/>refining<sp/>a<sp/>cell!<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4698"><highlight class="normal"></highlight></codeline>
<codeline lineno="4699"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="4700"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>zz;</highlight></codeline>
<codeline lineno="4701"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>write;</highlight></codeline>
<codeline lineno="4702"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="4703"><highlight class="normal"></highlight></codeline>
<codeline lineno="4704"><highlight class="normal"></highlight></codeline>
<codeline lineno="4705"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Bottom<sp/>left<sp/>corner</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4706"><highlight class="normal"><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="4707"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//check<sp/>that<sp/>there<sp/>is<sp/>a<sp/>block<sp/>there<sp/>and<sp/>if<sp/>there<sp/>is<sp/>calculate<sp/>the<sp/>value<sp/>depending<sp/>on<sp/>the<sp/>level<sp/>of<sp/>that<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4708"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[XBlock.BotLeft[ib]]<sp/>==<sp/>XBlock.BotLeft[ib])<sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>no<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4709"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4710"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[memloc(XParam,<sp/>-1,<sp/>0,<sp/>ib)]<sp/>+<sp/>z[memloc(XParam,<sp/>0,<sp/>-1,<sp/>ib)]);</highlight></codeline>
<codeline lineno="4711"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4712"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]]<sp/>==<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4713"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4714"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>z[memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]])];</highlight></codeline>
<codeline lineno="4715"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4716"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4717"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]]);</highlight></codeline>
<codeline lineno="4719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>2,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]]);</highlight></codeline>
<codeline lineno="4720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>2,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]]);</highlight></codeline>
<codeline lineno="4721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>2,<sp/>XParam.blkwidth<sp/>-<sp/>2,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]]);</highlight></codeline>
<codeline lineno="4722"><highlight class="normal"></highlight></codeline>
<codeline lineno="4723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="4724"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4725"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4726"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.LeftTop[XBlock.BotLeft[ib]]);</highlight></codeline>
<codeline lineno="4728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>-<sp/>1,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="4729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,0,<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4730"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.5)<sp/>*<sp/>z[ii]<sp/>+<sp/>T(0.25)<sp/>*<sp/>(z[ir]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="4731"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4732"><highlight class="normal"></highlight></codeline>
<codeline lineno="4733"><highlight class="normal"><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>zz;</highlight></codeline>
<codeline lineno="4734"><highlight class="normal"></highlight></codeline>
<codeline lineno="4735"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Top<sp/>Left<sp/>corner</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4736"><highlight class="normal"><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="4737"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//check<sp/>that<sp/>there<sp/>is<sp/>a<sp/>block<sp/>there<sp/>and<sp/>if<sp/>there<sp/>is<sp/>calculate<sp/>the<sp/>value<sp/>depending<sp/>on<sp/>the<sp/>level<sp/>of<sp/>that<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4738"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftBot[XBlock.TopLeft[ib]]<sp/>==<sp/>XBlock.TopLeft[ib])<sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>no<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4739"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[memloc(XParam,<sp/>-1,<sp/>XParam.blkwidth-1,<sp/>ib)]<sp/>+<sp/>z[memloc(XParam,<sp/>0,<sp/>XParam.blkwidth,<sp/>ib)]);</highlight></codeline>
<codeline lineno="4741"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4742"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]]<sp/>==<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4743"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>z[memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>0,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]])];</highlight></codeline>
<codeline lineno="4745"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4746"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4747"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4748"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>0,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="4749"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>1,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="4750"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>2,<sp/>0,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="4751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>2,<sp/>1,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="4752"><highlight class="normal"></highlight></codeline>
<codeline lineno="4753"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="4754"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4755"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4756"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4757"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>0,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="4758"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>-1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4759"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="4760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.5)<sp/>*<sp/>z[ii]<sp/>+<sp/>T(0.25)<sp/>*<sp/>(z[ir]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="4761"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4762"><highlight class="normal"></highlight></codeline>
<codeline lineno="4763"><highlight class="normal"><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>zz;</highlight></codeline>
<codeline lineno="4764"><highlight class="normal"></highlight></codeline>
<codeline lineno="4765"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Top<sp/>Right<sp/>corner</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4766"><highlight class="normal"><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="4767"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//check<sp/>that<sp/>there<sp/>is<sp/>a<sp/>block<sp/>there<sp/>and<sp/>if<sp/>there<sp/>is<sp/>calculate<sp/>the<sp/>value<sp/>depending<sp/>on<sp/>the<sp/>level<sp/>of<sp/>that<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4768"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightBot[XBlock.TopRight[ib]]<sp/>==<sp/>XBlock.TopRight[ib])<sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>no<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4769"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4770"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[memloc(XParam,<sp/>XParam.blkwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib)]<sp/>+<sp/>z[memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth,<sp/>ib)]);</highlight></codeline>
<codeline lineno="4771"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4772"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]]<sp/>==<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4773"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>z[memloc(XParam,<sp/>0,<sp/>0,<sp/>XBlock.RightBot[XBlock.TopRight[ib]])];</highlight></codeline>
<codeline lineno="4775"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4776"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4777"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>0,<sp/>XBlock.RightBot[XBlock.TopRight[ib]]);</highlight></codeline>
<codeline lineno="4779"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>1,<sp/>XBlock.RightBot[XBlock.TopRight[ib]]);</highlight></codeline>
<codeline lineno="4780"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>0,<sp/>XBlock.RightBot[XBlock.TopRight[ib]]);</highlight></codeline>
<codeline lineno="4781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>1,<sp/>XBlock.RightBot[XBlock.TopRight[ib]]);</highlight></codeline>
<codeline lineno="4782"><highlight class="normal"></highlight></codeline>
<codeline lineno="4783"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="4784"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4785"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4786"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>0,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="4788"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth-1,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="4790"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.5)<sp/>*<sp/>z[ii]<sp/>+<sp/>T(0.25)<sp/>*<sp/>(<sp/>z[ir]<sp/>+<sp/><sp/>z[it]);</highlight></codeline>
<codeline lineno="4791"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4792"><highlight class="normal"></highlight></codeline>
<codeline lineno="4793"><highlight class="normal"><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>zz;</highlight></codeline>
<codeline lineno="4794"><highlight class="normal"></highlight></codeline>
<codeline lineno="4795"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Bot<sp/>Right<sp/>corner</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4796"><highlight class="normal"><sp/><sp/><sp/><sp/>write<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="4797"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//check<sp/>that<sp/>there<sp/>is<sp/>a<sp/>block<sp/>there<sp/>and<sp/>if<sp/>there<sp/>is<sp/>calculate<sp/>the<sp/>value<sp/>depending<sp/>on<sp/>the<sp/>level<sp/>of<sp/>that<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4798"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightBot[XBlock.BotRight[ib]]<sp/>==<sp/>XBlock.BotRight[ib])<sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>no<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4799"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.5)<sp/>*<sp/>(z[memloc(XParam,<sp/>XParam.blkwidth-1,<sp/>-<sp/>1,<sp/>ib)]<sp/>+<sp/>z[memloc(XParam,<sp/>XParam.blkwidth<sp/>,<sp/>0,<sp/>ib)]);</highlight></codeline>
<codeline lineno="4801"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4802"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[XBlock.BotRight[ib]]]<sp/>==<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4803"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>z[memloc(XParam,<sp/>0,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.RightBot[XBlock.BotRight[ib]])];</highlight></codeline>
<codeline lineno="4805"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4806"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[XBlock.BotRight[ib]]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4807"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.RightBot[XBlock.BotRight[ib]]);</highlight></codeline>
<codeline lineno="4809"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>XParam.blkwidth<sp/>-<sp/>2,<sp/>XBlock.RightBot[XBlock.BotRight[ib]]);</highlight></codeline>
<codeline lineno="4810"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.RightBot[XBlock.BotRight[ib]]);</highlight></codeline>
<codeline lineno="4811"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>2,<sp/>XBlock.RightBot[XBlock.BotRight[ib]]);</highlight></codeline>
<codeline lineno="4812"><highlight class="normal"></highlight></codeline>
<codeline lineno="4813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.25)<sp/>*<sp/>(z[ii]<sp/>+<sp/>z[ir]<sp/>+<sp/>z[it]<sp/>+<sp/>z[itr]);</highlight></codeline>
<codeline lineno="4814"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4815"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[XBlock.BotRight[ib]]]<sp/>&lt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4816"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4817"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.LeftBot[XBlock.TopLeft[ib]]);</highlight></codeline>
<codeline lineno="4818"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="4819"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="4820"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zz<sp/>=<sp/>T(0.5)<sp/>*<sp/>z[ii]<sp/>+<sp/>T(0.25)<sp/>*<sp/>(z[ir]<sp/>+<sp/>z[it]);</highlight></codeline>
<codeline lineno="4821"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4822"><highlight class="normal"></highlight></codeline>
<codeline lineno="4823"><highlight class="normal"><sp/><sp/><sp/><sp/>z[write]<sp/>=<sp/>zz;</highlight></codeline>
<codeline lineno="4824"><highlight class="normal"></highlight></codeline>
<codeline lineno="4825"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4826"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*&amp;<sp/>z);</highlight></codeline>
<codeline lineno="4827"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCorners&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*&amp;<sp/>z);</highlight></codeline>
<codeline lineno="4828"><highlight class="normal"></highlight></codeline>
<codeline lineno="4829"><highlight class="normal"></highlight></codeline>
<codeline lineno="4830"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCornersGPU(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>z)</highlight></codeline>
<codeline lineno="4831"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4832"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4833"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth<sp/>=<sp/>XParam.halowidth;</highlight></codeline>
<codeline lineno="4834"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4835"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="4836"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>iy<sp/>=<sp/>threadIdx.y;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4837"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>iy<sp/>=<sp/>blockDim.x-1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4838"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="4839"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="4840"><highlight class="normal"></highlight></codeline>
<codeline lineno="4841"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TL<sp/>=<sp/>XBlock.TopLeft[ib];</highlight></codeline>
<codeline lineno="4842"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>TR<sp/>=<sp/>XBlock.TopRight[ib];</highlight></codeline>
<codeline lineno="4843"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LB<sp/>=<sp/>XBlock.LeftBot[ib];</highlight></codeline>
<codeline lineno="4844"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LT<sp/>=<sp/>XBlock.LeftTop[ib];</highlight></codeline>
<codeline lineno="4845"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BL<sp/>=<sp/>XBlock.BotLeft[ib];</highlight></codeline>
<codeline lineno="4846"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BR<sp/>=<sp/>XBlock.BotRight[ib];</highlight></codeline>
<codeline lineno="4847"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RB<sp/>=<sp/>XBlock.RightBot[ib];</highlight></codeline>
<codeline lineno="4848"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>RT<sp/>=<sp/>XBlock.RightTop[ib];</highlight></codeline>
<codeline lineno="4849"><highlight class="normal"></highlight></codeline>
<codeline lineno="4850"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>LBTL<sp/>=<sp/>XBlock.leftbot[TL];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4851"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>BLTL<sp/>=<sp/>XBlock.botleft[TL];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4852"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>RBTR<sp/>=<sp/>XBlock.rightbot[TR];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4853"><highlight class="normal"></highlight></codeline>
<codeline lineno="4854"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iout,<sp/>ii;</highlight></codeline>
<codeline lineno="4855"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="4856"><highlight class="normal"></highlight></codeline>
<codeline lineno="4857"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="4858"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4859"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Bot<sp/>left<sp/>corner</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4860"><highlight class="normal"></highlight></codeline>
<codeline lineno="4861"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iout<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>-1,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="4862"><highlight class="normal"></highlight></codeline>
<codeline lineno="4863"><highlight class="normal"></highlight></codeline>
<codeline lineno="4864"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BL<sp/>==<sp/>ib<sp/>&amp;&amp;<sp/>LB<sp/>==<sp/>ib)</highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4865"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="4867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4870"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BL<sp/>!=<sp/>ib)</highlight></codeline>
<codeline lineno="4871"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4872"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>-1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>BL);</highlight></codeline>
<codeline lineno="4873"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>-1,<sp/>LB);</highlight></codeline>
<codeline lineno="4877"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4878"><highlight class="normal"></highlight></codeline>
<codeline lineno="4879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[iout]<sp/>=<sp/>z[ii];</highlight></codeline>
<codeline lineno="4881"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4882"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>1)</highlight></codeline>
<codeline lineno="4883"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4884"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="4885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Top<sp/>left<sp/>corner</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4886"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iout<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>-1,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="4887"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TL<sp/>==<sp/>ib<sp/>&amp;&amp;<sp/>LT<sp/>==<sp/>ib)</highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4888"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4889"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4890"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4891"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4892"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TL<sp/>!=<sp/>ib)</highlight></codeline>
<codeline lineno="4894"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>-1,<sp/>0,<sp/>TL);</highlight></codeline>
<codeline lineno="4896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4897"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4898"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4899"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>LT);</highlight></codeline>
<codeline lineno="4900"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4901"><highlight class="normal"></highlight></codeline>
<codeline lineno="4902"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4903"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[iout]<sp/>=<sp/>z[ii];</highlight></codeline>
<codeline lineno="4904"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="4905"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4906"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>2)</highlight></codeline>
<codeline lineno="4907"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Top<sp/>right<sp/>corner</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iout<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>XParam.blkwidth,<sp/>ib);</highlight></codeline>
<codeline lineno="4910"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TR<sp/>==<sp/>ib<sp/>&amp;&amp;<sp/>RT<sp/>==<sp/>ib)</highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4911"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4912"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4913"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4914"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4915"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4916"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(TR<sp/>!=<sp/>ib)</highlight></codeline>
<codeline lineno="4917"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4918"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>0,<sp/>TR);</highlight></codeline>
<codeline lineno="4919"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4920"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4921"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4922"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>XParam.blkwidth,<sp/>RT);</highlight></codeline>
<codeline lineno="4923"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4924"><highlight class="normal"></highlight></codeline>
<codeline lineno="4925"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4926"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[iout]<sp/>=<sp/>z[ii];</highlight></codeline>
<codeline lineno="4927"><highlight class="normal"></highlight></codeline>
<codeline lineno="4928"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4929"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>==<sp/>3)</highlight></codeline>
<codeline lineno="4930"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4931"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Bot<sp/>right<sp/>corner</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4932"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iout<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>-1,<sp/>ib);</highlight></codeline>
<codeline lineno="4933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BR<sp/>==<sp/>ib<sp/>&amp;&amp;<sp/>RB<sp/>==<sp/>ib)</highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4935"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="4936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(BR<sp/>!=<sp/>ib)</highlight></codeline>
<codeline lineno="4940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>BR);</highlight></codeline>
<codeline lineno="4942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4944"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>-1,<sp/>RB);</highlight></codeline>
<codeline lineno="4946"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4947"><highlight class="normal"></highlight></codeline>
<codeline lineno="4948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4949"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[iout]<sp/>=<sp/>z[ii];</highlight></codeline>
<codeline lineno="4950"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4951"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="4952"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4953"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCornersGPU&lt;float&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
<codeline lineno="4954"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>fillCornersGPU&lt;double&gt;(<ref refid="classParam" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="structBlockP" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>z);</highlight></codeline>
    </programlisting>
    <location file="src/Halo.cu"/>
  </compounddef>
</doxygen>
