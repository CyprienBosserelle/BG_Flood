{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TMP Examples of Mkdocs material","text":""},{"location":"#mkdoc-material-set-up","title":"Mkdoc-material set-up!","text":""},{"location":"#welcome-to-mkdocs-by-alice","title":"Welcome to MkDocs by Alice","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"#test-of-mkdoc-functionnalities","title":"Test of mkdoc functionnalities","text":""},{"location":"#admonitions-link","title":"Admonitions (link):","text":"<p>Phasellus posuere in sem ut cursus</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"#latex","title":"Latex:","text":"<p>Latex is working : \\(d_n\\) or  $$ d_n={$rac{10}{5}} $$</p>"},{"location":"#pictures","title":"Pictures:","text":"Image caption <p>based on @10.1016/j.envsoft.2016.11.012</p>"},{"location":"#references","title":"References","text":"<p>$full_bibliography</p>"},{"location":"#adding-nice-videos","title":"Adding nice videos","text":"<p>see Home!</p>"},{"location":"Home/","title":"Home","text":""},{"location":"Home/#welcome-to-the-bg_flood-documentation","title":"Welcome to the BG_Flood documentation !","text":"<p>BG-Flood is a Shallow Water Equation (SWE) model based on the St Venant formulation of Basilisk but applied to a Block Uniform Quadtree memory structure on the GPU (based on Vacondio et al.).</p> <p>The model is designed to simulate flood/inundation caused by tsunami, river, rain, tide or storm surge (from wind stress or atmospherique pressure differential) or any combination of these. The model does not (yet) include the effect of wind waves. The model is not restricted to simulating inundation hazard and can also be used for depth averaged circulation simulation. </p> <p>Info</p> <p>This wiki is to help users getting started on using the model.  This is work in progress... If you have any issue/question post it on the issue board. While the model is fairly user friendly, it was designed for users with a basic understanding of hydrodynamics and some experience in modelling. The wiki (and the model) expect that users have some experience in basic file manipulations and are comfortable with handling NetCDF files for input and output.</p> <p>This code is an open-source shallow water solver. Designed to be fast, it run on GPUs and generate its own adaptative mesh. It is mainly used in a context of flooding:</p> <ul> <li>fresh water flooding (fluvial and pluvial)</li> <li>tsunami propagation and run-off</li> </ul> <p> </p>"},{"location":"Home/#model-development-stage","title":"Model development stage","text":"<p>BG-Flood is still in early development stage but is already useful for real inundation simulation.       </p> <p>The master branch is at stage 4 of development with 5 stage planned as below:</p> <ul> <li> Cartesian naive formulation</li> <li> Same but with some ease of use for modelling studie</li> <li> Block Uniform formulation at constant level with masked blocks (with a full swing of user friendly capabilities)</li> <li> Static Block uniform Quad-tree formulation (i.e. adapted mesh at the first step only )</li> <li> Set of core solvers:<ul> <li> Reimann</li> <li> Kurganov</li> <li> new one...</li> </ul> </li> <li> fully adaptive Block uniform Quad-tree formulation  (i.e. basilisk style wavelet refine)</li> </ul> <p></p> <p>Testing CI test (development branch): </p>"},{"location":"Install/","title":"Installation","text":""},{"location":"Install/#installation-of-bg_flood","title":"Installation of BG_Flood","text":"<p>Warning</p> <p>BG_Flood has been written in CUDA language, C++ based language created by NVIDIA to interact directly with their GPUs.  Even if the code can run on CPU (for testing purposes for example), it will be performant on NVIDIA GPUs. The best performances  are observed on large NVIDIA GPUs on supercomputers.</p> <p>The code has only two main dependencies:</p> <ul> <li>CUDA</li> <li>netcdf</li> </ul>"},{"location":"Install/#windows-10-11","title":"Windows 10 - 11","text":"<p>On windows OS you should be able to use the binaries/executable we make available in each release. Simply download and unzip the file in a suitable directory and either add the folder to your PATH or move the dll and .exe around where you want to run. </p>"},{"location":"Install/#build-from-source","title":"Build from source","text":"<p>To build BG_Flood from source on Windows you will need to have pre-install:</p> <ul> <li>Visual Studio Community with C++ component installed</li> <li>Compatible (Cuda toolkit)[https://developer.nvidia.com/cuda-toolkit]</li> <li>Downloaded/cloned/forked source of the repo</li> <li>Netcdf developer install (i.e. netcdf.h and netcdf.lib)</li> </ul> <p>Setup on Visual Studio</p> <ul> <li>start a new empty project</li> <li>add CUDA build dependencies to the project</li> <li>add NetCDF folder(s) to the include and library directories in the project properties</li> <li>add \"netcdf.lib\" to the input (Properties -&gt; Linker -&gt; Input)</li> <li>switch the \"Generate Relocatable device code\" to Yes (Properties -&gt; CUDA C/C++ -&gt; Common)</li> <li>disable deprecation add _CRT_SECURE_NO_WARNINGS to preprocessor definition (Properties -&gt; C/C++ -&gt; Preprocessor)</li> </ul>"},{"location":"Install/#linux","title":"Linux","text":"<p>Make sure you have latest CUDA Toolkit, g++ and NetCDF libraries installed.</p> <pre><code>sudo apt-get install nvidia-cuda-dev\nsudo apt-get install g++\nsudo apt-get install libnetcdf-dev\n</code></pre> <p>Note</p> <p>Make sure the GPU driver being used is the Nvidia driver!</p> <p>Do a quick comand line test to see if nvcc (CUDA compiler) is available from here.</p> <p>If not, you may need to modify the cuda path in the makefile (line 155) : </p><pre><code>NVCC          := nvcc -ccbin $(HOST_COMPILER)\n</code></pre> <p>Warning</p> <p>The code can compile for multiple GPU architecture but later compiler do not support old GPU (2.0 is no longer supported). If needed, remove unsupported architecture in line 213 of the makefile.</p> <p>Then just type  </p><pre><code>make\n</code></pre> <p>Success</p> <p>Many warning will show up but that is OK...</p>"},{"location":"Install/#supercomputers","title":"Supercomputers","text":"<p>The code can be run on local machines with NVIDIA GPU but it will get better performance by running on large GPU.</p>"},{"location":"Install/#esnz-supercomputer-cascade","title":"ESNZ supercomputer: Cascade","text":"<p>This machine is set-up using stack and all tools need to be install through it before compiling/running the code. The PBS job manager is used.</p>"},{"location":"Install/#compiling-the-code","title":"Compiling the code","text":"<pre><code>. $(ls /opt/niwa/profile/spack_* | tail -1)\nspack load netcdf-c@4.9.2%gcc@11.5.0 cuda@12.8.0\nnclib=`nc-config --libdir`\nexport LD_LIBRARY_PATH=\"${nclib}:$LD_LIBRARY_PATH\"\n\ncd BG_Flood_Folder\n\nmake -j 10\n</code></pre> <p>Note</p> <p>Spack load doesn't set LD_LIBRARY_PATH so running executable won't find libnetcdf.  Also it doesn't set LDFLAGS=-Wl,-rpath (and Makefile doesn't honour LDFLAGS anyway), so libnetcdf path isn't linked in.  So hack this in for now.</p>"},{"location":"Install/#running-the-code","title":"Running the code","text":"<pre><code>#!/bin/bash\n\n#PBS -N *my_pbs_job_name*\n#PBS -l select=1:ncpus=4:ngpus=1:mem=32gb\n#PBS -l walltime=72:00:00\n#PBS -q a100q=\"\"\n#PBS -A *myaccount*\n#PBS -W umask=027\n\n# Change to running directory if required\ncd *my_case_dir*\n\n# Launch of the solver\nBG_Flood BG_param.txt\n</code></pre>"},{"location":"Install/#nesi","title":"NESI","text":"<p>Depreciated</p> <p>NESI supercomputer has now been closed and replaced by REANZ new generation of machines.</p> <p>The code is actually running on New Zealand eScience Infrastructure (NeSI). This national center uses a module systems associated to the slurm job manager.</p>"},{"location":"Install/#compiling-the-code_1","title":"Compiling the code","text":"<p>The Code needs to be compile on the machine, using the sources from the github repository. Due to the code dependency to CUDA and netCDF, two modules need to be loaded:</p> <ul> <li> <p>On Maui: </p><pre><code>module load CUDA\\11.4.1\nmodule load netCDF-C++4/4.3.0-GCC-7.1.0\n</code></pre> </li> <li> <p>On Mahuika: </p><pre><code>module load CUDA/11.4.1\nmodule load netCDF-C++4/4.3.1-gimpi-2020a\n</code></pre> </li> </ul>"},{"location":"Install/#running-the-code_1","title":"Running the code","text":"<ul> <li> <p>Example of a slurm file on Maui: </p><pre><code>#!/bin/bash\n#SBATCH --job-name=MY-TEST-NAME\n#SBATCH --time=8:00:00\n#SBATCH --account=MY-NESI-ACCOUNT\n#SBATCH --partition=nesi_gpu\n#SBATCH --gres=gpu\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=2\n#SBATCH --mem=5GB\n\n#Running directory (to be completed)\nBGFLOOD=/nesi/project/XXXXXXXXXXXXXXX\n\ncd ${BGFLOOD}\n\nmodule load CUDA/11.4.1\nmodule load netCDF-C++4/4.3.0-GCC-7.1.0\n\n# Launching the executable\nsrun ./BG_Flood_Maui\n\necho \"output_file = Output/${testname}/BGoutput-${reftime}.nc\"\n\necho \"end of setup_run_BG.sh\"\n</code></pre> </li> <li> <p>Example of a slurm file on Mahuika: </p><pre><code>#!/bin/bash\n#SBATCH --job-name=MY-TEST-NAME\n#SBATCH --time=05:00:00\n#SBATCH --account=MY-NESI-ACCOUNT\n#SBATCH --gpus-per-node=1\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=1\n#SBATCH --mem=1GB\n\n#Running directory (to be completed)\nBGFLOOD=/nesi/project/XXXXXXXXXXXXXXX\n\ncd ${BGFLOOD}\n\n#module load netCDF-C++4/4.3.0-gimkl-2017a\nmodule load netCDF-C++4/4.3.1-gimpi-2020a\nmodule load CUDA/11.4.1\n\n# Launching the executable\nsrun ./BG_Flood_Mahuika\n\necho \"output_file = Output/${testname}/BGoutput-${reftime}.nc\"\n\necho \"end of setup_run_BG.sh\"\n</code></pre> </li> </ul>"},{"location":"Manual/","title":"Manual","text":""},{"location":"Manual/#manual","title":"Manual","text":"<p>BG_Flood is a hydrodynamics model for simulating 2D depth-averaged flow. The following manual describes how to use the model but does not go into details about the model equations.</p> <p>Warning</p> <p>This manual is under revision and not up-to-date with the last version of the code. Please, use the Parameters and Forcings list as a reference</p>"},{"location":"Manual/#model-controls","title":"Model controls","text":"<p>BG_Flood model reads an instruction file (or param file) that tells the model what to do and what forcing files to read. when instructions are not explicitely given the model will use the default value. How to use the param file is important for making BG_Flood do what you want it to do.</p> <p>By default this instruction file is called <code>BG_param.txt</code>.</p>"},{"location":"Manual/#bg_paramtxt","title":"BG_param.txt","text":"<p>All the model inputs are controlled by the <code>BG_param.txt</code> file. It is a simple text file that contains the parameters of the model that the user wishes to change. While it is easy to build such file manually but also it is easy to use script and/or programming language to generate and modify text file to automatically to build and run many simulations.</p>"},{"location":"Manual/#how-to-use-the-bg_paramtxt-file","title":"How to use the BG_param.txt file","text":"<p>Model parameters can be modified in the file by specifying the parameter name, the equal sign, the desired value(s) for the parameter and optionally a semi-column : </p><pre><code>#My Dummy BG_param files\n#Any lines starting with the Hash tag will be ignored\n#You can also leave blank lines\n\n# Parameter order does not really matter but if you specify a parameter twice the first value will be overwritten\n\n# You can only put one parameter per line\nbathy = mybathyfile.nc\n\n#Any number of leading space or space between the parameter name and the equal sign will be accepted. Tabs are not acceptable\n    theta       =      1.0\n#Obviously you have to put the right name down (spelling and not case sensitive) otherwise the line will be ignored\ntteettaa = 1.22\n\n#If you want to add a comment at the end of a line with a parameter you can do it after putting a semi column e.g.:\nCFL = 9; Was 0.5 but I don't know what I'm doing\n\n#The model has only one required parameter and that is the (level 0) bathymetry grid name\n</code></pre>"},{"location":"Manual/#general-comment-about-input-files","title":"General comment about input files","text":"<p>Some parameters expect a filename (e.g. <code>bathy</code>). While the model will accept any extension there are a couple of requirement. For spatially varying inputs, the extension controls how the file is read. You can use ESRI ascii grids <code>.asc</code>, mid-depth files <code>.md</code> or NetCDF <code>.nc</code>. NetCDF files are recommended and expected to have the <code>.nc</code> extension. Since NetCDF files can have several variables you can enforce (recommended) the variable being read by appending <code>?var</code> to the file name (e.g. <code>bathy = mybathyfile.nc?z</code>).</p> <p>For spatially and temporally varying input (e.g. wind or atmospheric pressure) a/multiple NetCDF file with a 3D variable is expected (see here).</p> <p>Where the file input is a timeserie (e.g. boundary forcing), then the file extension is ignored but a text file is expected.</p>"},{"location":"Manual/#list-of-parameters","title":"List of Parameters","text":"<p>Remember that the only required parameter to run the model is the bathymetry file. But if you want to run something fun you will need to specify boundary conditions, initial conditions and/or some forcings.</p> <p>Full list of the parameters</p>"},{"location":"Manual/#bathymetrytopography-files","title":"Bathymetry/topography files","text":"<p>Input bathymetry data as a regular grid using <code>.asc</code>, <code>.nc</code>, <code>.md</code>. This is a required parameter that ultimately also defines the extend of the model domain and model resolution (if not defined by the user).</p> <p><code>bathy = My_bathy_file.asc</code></p> <p>The correct way of reading the file will be dedicated by the file extension. For <code>.nc</code> (netcdf) files you can specify the name of the variable in the file as: <code>mybathyfile.nc?myvar</code> (will look for <code>zb</code> if none are specified). </p> <p>This input file is critical as it defines the extent of the model grid and the base resolution in the model.</p> <p>Note: </p> <p>Note</p> <p>Different files can be provided to the code (using the instruction line multiple times). The code will use the last one having information at a given location when interpolating the data to create the bottom elevation (<code>zb</code>) variable.</p>"},{"location":"Manual/#conputational-mesh","title":"Conputational mesh","text":"<p>BG_Flood generates its own mesh</p> <p>By default, it is a quad regular mesh based on the DEM (Digital Elevation Model) extend and resolution.  The extend of the mesh and resolution of the mesh can be modify by the user. The mesh can also be refined/coarsen in areas or following patterns prescribed by the user.</p>"},{"location":"Manual/#masking","title":"Masking","text":"<p>Parts of the input bathymetry can be masked and excluded from the computation. The model extent (and locations of side boundaries) will remain the same but entire blocks can be removed from the computational memory. These area will appear as NaN in the output file. The input grid is first devided in blocks of 16x16. If all the value within a block exceed the mask value (9999 as default) then that block is excluded from memory and no computation will occur there. An \"area of interest\" (AOI) can also be used to select a part of the domain. If none of the cells of a block is located in this area, that block will be excluded from memory. The AOI is prefered other the mask method as the later can create waterfalls on the borders of the domain, specially if the rain-on-grid method is used.</p> <p>There are no fancy treatment of the boundaries of masked blocks so it is safer to select a mask threshold (<code>mask</code>) to keep most of the masked are dry. If water tries to cross to a masked block, The boundary of blocks are treated as Neumann (no gradient) boundaries so the bathymetry of the 2 cells adjacent to a masked block are set to the same value (the value of the second cell removed from the masked block). </p>"},{"location":"Manual/#boundaries","title":"Boundaries","text":"<p>Four type of boundaries can be applied at the edge of the model. By default neumann (no perpendicular gradient) is applied. </p> <ul> <li>0: No slip (wall)</li> <li>1: Neumann</li> <li>2: dirichlets (water level )</li> <li>3: Absorbing (only 1D/perpendicular absorbion is implemented)</li> <li>(4: 2D Absorbing (Not implemented yet))</li> </ul> <p>For Boundary type 2 and 3 (Dirichlet and Absorbing) the level at the boundary level is imposed from a file so a file needs to be sepcified: </p><pre><code>    left = 1;\n    right = mybndfile.txt,3;\n    top = mybndfile.txt,3;\n</code></pre>"},{"location":"Manual/#boundary-file-for-type-2-or-3","title":"Boundary file (for type 2 or 3)","text":"<p>Water level boundary file are needed to type 2 and 3 boundaries. The files are 2 (or more) columns, one with time in the first column and water level is the other(s). Note that the time step in the file doesn't need to be constant. The model will linearly interpolated between steps in the file. The file can be either comma separated or tab separated. This is automatically detected.</p>"},{"location":"Manual/#uniform-boundary-file","title":"Uniform boundary file","text":"<p>For uniform boundary condition (along the boundary axis) the files needs to be 2 column: </p><pre><code>    # Water level boundary\n    0.0  1.2\n    3600.0  1.2\n    36000.0  1.22\n    36060.0  1.25\n    36120.0  1.24\n</code></pre>"},{"location":"Manual/#variable-boundary-file","title":"Variable boundary file","text":"<p>For Variable boundary condition (along the boundary axis) the files needs to be 3+ columns. The boundary axis is then divided by the number of boundary column and the water level is interpolated between location, for example: </p><pre><code>    # Water level boundary\n    0.0  1.2 0.0\n    3600.0  1.2 0.0\n    36000.0  1.22 0.0\n    36060.0  1.25 0.0\n    36120.0  1.24 0.0\n</code></pre> <p>Here the the water level on the near-end of the boundary (left for bottom and top bnds; bottom for left and right bnds) axis will vary between 1.2 and 1.25 but the far-end (right for bottom and top bnd and top for left and right bnds) will remain constant at 0.0.</p> <p>Here is an example with 3 water level column: </p><pre><code>     # Water level boundary\n    0.0 0.0 1.2 0.0\n    3600.0 0.0 1.2 0.0\n    36000.0 0.0 1.2 0.0\n    36060.0 0.0 1.2 0.0\n    36120.0 0.0 1.2 0.0 \n</code></pre> <p>In this case both near and far end of the boundary axis will remain zero and the center of the boundary axis will be 1.2m. </p> <p>There is no restriction in the number of columns. These values from each column will be forced uniformly spaced on the boundary and forcing in between will be linearly interpolated.</p>"},{"location":"Manual/#bottom-friction","title":"Bottom friction","text":"<p>Bottom friction is applied implicitly in the model (applied to velocities after momentum and continuity equations are solved).  There are 3 friction equations implemented defined in <code>BG_param.txt</code> as:</p> <ul> <li><code>frictionmodel = 0</code>: Basic Quadratic friction law (expecting the non-dimensional friction coefficient \\(c_f\\) )</li> <li><code>frictionmodel = 1</code>: Roughtness length model from Smart (expecting a \\(z_0\\) parameter in \\(c_f\\))</li> <li><code>frictionmodel = -1</code>: Manning's friction model (expecting a Manning n parameter \\(c_f\\)) Quadratic friction is the default, with a uniform friction coefficient:</li> </ul> <p></p><pre><code>  frictionmodel = 0\n  cf = 0.001\n</code></pre> If a uniform friction is required add <code>cf=</code> to your <code>BG_param.txt</code> with the desired value. <code>cf</code> keyword is also used for the \\(z0\\) of Smart formulation and \\(n\\) of the Manning formulation.  <p>For non-uniform friction parameter use the keyword  <code>cfmap</code> or <code>roughnessmap</code> and assign an <code>.asc</code> or <code>.nc</code> file. For nc files you may need to supply the netcdf variable name: e.g. <code>cfmap=final_rough.nc?zo</code>. The roughness grid does not need to match the model grid dimension and coarser friction grid will be interpolated to the model grid cells and model cells outside of the forcing domain will be extrapolated (nearest value).</p>"},{"location":"Manual/#rivers-and-area-discharge","title":"Rivers and Area discharge","text":"<p>At this stage river can only be added to the model as a vertical discharge where the water is added to a rectangle on the model with no velocity. To add rivers add a line per river with the parameters: <code>river = Fluxfile,xstart,xend,ystart,yend;</code> where <code>Fluxfile</code> is a 2 column text file containing time and dicharge in \\(m^3/s\\); <code>xstart</code> is the left coordinate of the rectangle where the vertical discharge is applied, <code>xend</code> is the right coordinate of the rectangle, <code>ystart</code> is the bottom coordinate of the rectangle and <code>yend</code> is the top coordinate of the rectangle.  Example: </p><pre><code>    river = Votualevu_R.txt,1867430,1867455,3914065,3914090;\n    river = Mulomulo_R.txt,1867052,1867072,3911853,3911873;\n</code></pre>"},{"location":"Manual/#wind-atm-pressure-forcing","title":"Wind atm pressure forcing","text":""},{"location":"Manual/#wind-forcing-may-contain-bugs","title":"Wind forcing (may contain bugs)","text":"<p>The hydrodynamics can be forced using a linear wind drag. the linear drag can be influenced with the keyword <code>Cd</code>. Wind input is defined with the keyword <code>windfiles</code>. There are several ways to use the keyword.</p>"},{"location":"Manual/#spatially-uniform-txt-file","title":"spatially uniform txt file:","text":"<pre><code>windfiles=mywind.txt\n</code></pre> where <code>mywind.txt</code> is a text file with 3 column (time (\\(s\\)), wind speed (\\(m/s\\)) and wind direction (\\(\\,^{{\\circ}}\\) North)). If the grid is in acoordinate system rotated from the north and a <code>grdalpha</code> is specified, the wind will be automatically rotated to the grid orientation."},{"location":"Manual/#spatially-and-time-varying-input","title":"Spatially and time varying input","text":"<pre><code>windfiles=mywind.nc?uw,mywind.nc?vw\n</code></pre> Here two arguments separated with a comma are expected. The first argument is the netcdf file and variable name containing the U component of the wind (along the X axis) and the second argument is the netcdf file and variable name containing the V component of the wind (along the Y axis). Both can be in the same netcdf file as in the example or in separate netcdf files (add the variable name with a <code>?</code> similarly to other netcdf input options). The dimension of the wind forcing grid does not need to match the model grid dimension and coarser forcing will be interpolated to the model grid cells and model cells outside of the forcing domain will be extrapolated (nearest value)."},{"location":"Manual/#atmospheric-pressure-forcing","title":"Atmospheric pressure forcing","text":"<p>Spatially constant atmospheric pressure forcing is not relevant so only spatially varying forcing is feasable. Like for the wind this is done through a netcdf file: </p><pre><code>atmpfile=myncfile.nc?atmpres\n</code></pre> The forcing pressure is expected to be in Pa and the effect of the atmospheric pressure gradient is calculated as the difference to a reference pressure <code>Paref=101300.0</code> converted to a height using <code>Pa2m=0.00009916</code>. If using hPa your will need to also change the reference pressure to <code>Paref=1013.0</code> and the conversion parameter to <code>Pa2m=0.009916</code>. As with the  wind forcing, the forcing grid does not need to match the model grid dimension and coarser forcing will be interpolated to the model grid cells and model cells outside of the forcing domain will be extrapolated (nearest value)."},{"location":"Manual/#outputs","title":"Outputs","text":"<p>There is two types of outputs:  - map outputs of 2D variables regularly through time.  - time-series output of basic values, at a chosen position, at each time step.</p>"},{"location":"Manual/#map-outputs","title":"Map outputs","text":"<p>These maps are output as a nc file, with information on coordinates and blocks.</p> <p>The map output can be modify by: - defining a timestep (in \\(s\\)) for these outputs: </p><pre><code>outputtimestep = 3600.0;\n</code></pre> - changing the set of variables in the output file (from the list given in the manual) <pre><code>outvars = zs,h,u,v,zb,hmax,Umax,hUmax,twet;\n</code></pre> - changing the name of the output file: <pre><code>outfile = Results_tuto_basicRun.nc;\n</code></pre> <ul> <li>choosing one or more zones to outputs (by default, the full domain is output):  <code>{txt} outzone=MyZoneName.nc,x1,x2,y1,y2; outzone=MyZoneNameb.nc,x1b,x2b,y1b,y2b;</code> </li> <li>saving the output as float (variables are saved as short integer by default.): <pre><code>smallnc = 0;\n</code></pre></li> </ul> <p>By default, the variables outputs are the one listed in the following paragraph: Default snapshot outputs.</p>"},{"location":"Manual/#default-snapshot-outputs","title":"Default snapshot outputs","text":"Parameter Definition Unit u U  velocity (at cell center) zonal velocity positive right [m/s] v V  velocity (at cell center) meridional velocity positive right [m/s] h water depth at cell center [m] zs Water level elevation above datum [m] zb Topography elevation above datum [m]"},{"location":"Manual/#complementary-variables","title":"Complementary variables","text":"Parameter Definition Unit vort Vorticity [rotation/s] cf Bottom friction coefficient (Manning n or z0) varies with model used"},{"location":"Manual/#meanaveraged-output-between-output-steps","title":"Mean/averaged output between output steps","text":"<p>This is for averaging variables in between output steps, useful for mean tidal flow calculation that averages out vortices. The average time is <code>outtimestep</code>.</p> Parameter Definition Unit umean Averaged u  velocity (at cell center) zonal velocity positive right [m/s] vmean Averaged v  velocity (at cell center) meridional velocity positive right [m/s] hmean Averaged water depth at cell center [m] zsmean Averaged Water level elevation above datum [m]"},{"location":"Manual/#max-output","title":"Max output","text":"<p>The max can be calculated for the overall simulation (default) or between output steps ( if <code>resetmax = 1;</code>)</p> Parameter Definition Unit umax Maximum u  velocity (at cell center) zonal velocity positive right [m/s] vmax Maximum v  velocity (at cell center) meridional velocity positive right [m/s] hmax Maximum water depth at cell center [m] zsmax Maximum Water level elevation above datum [m]"},{"location":"Manual/#risk-assesment-related-output","title":"Risk assesment related output","text":"<p>These variables are used to evaluate the damage resulting from the innundation (as a complement to hmax for example).</p> Parameter Definition Unit hUmax Maximum of h time the velocity (U for amplitude of (u,v)) [m2/s] Umax Maximum of the velocity (U for amplitude of (u,v)) [m/s] twet Duration innundation of the cell in s (h&gt;0.1m) [s]"},{"location":"Manual/#model-related-outputs","title":"Model related outputs","text":"<p>These outputs  will be produce only if the associated model/forcing is used.</p> <p>If an atmospheric forcing is used:</p> Parameter Definition Unit Patm Atmospheric pressure [Pa] datmpdx/datmpdy Gradients of atmospheric pressure [Pa/m] <p>If the infiltration model (ILCL) is used, the quantity of water that infiltrate in the ground is saved, as a cumulated value in hgw.</p> Parameter Definition Unit il Initial loss coefficient [mm] cl Continuous loss coefficient [mm/hr] hgw Cumulated height of infiltrated water in the ground [m]"},{"location":"Manual/#other-gradients-and-intermediate-terms-of-the-equations","title":"Other gradients and intermediate terms of the equations","text":"<p>Terms of the equation can also been output such as the gradients (for error tracking mainly):</p> Parameter Definition Unit dhdx / dhdy Gradient of water elevation (h) in the x and y direction respectively [] dzsdx / dzsdy Gradient of the water surface (zs) in the x and y direction respectively [] dudx / dudy Gradient of x-velocity (u) in the x and y direction respectively [s-1] dvdx / dvdy Gradient of y-velocity (v) in the x and y direction respectively [s-1] Fhu / Fhv Flux of h time u in the x and y direction respectively [m2/s2] Fqux / Fqvx XXXXXXXXXXXX [XXX] Su / Sv Topographic source term [XXX] dh Variation in elevation [m] du / dv Variation of the x- and y-velocity respectively [m/s]"},{"location":"Manual/#point-or-time-serie-output","title":"Point or Time-Serie output","text":"<p>For each Time-Serie output needed, a line with the destination file and the postition is needed:</p> <p></p><pre><code>TSnodesout=Offshore.txt,xloc,yloc;\n</code></pre> The file contains 5 colums \\((t, zs, h, u,v)\\) with the value at the nearest grid point (to the position defined by the user)."},{"location":"Manual/#adaptative-grid","title":"Adaptative grid","text":"<p>At the stage of development, the code will adapt the grid only before the computation but not along the calcul.</p> <p>The code is based on a Block-uniform quadtree mesh. Each block, actually a 16 by 16 cells, is one unit of computation in the GPU. These blocks can have different resolutions (but the resolution does not change during the computation at this stage).</p> <p>By default, the initial resolution of the grid is the resolution of the bathymetry/topographic data. To refine or coarsen the grid, you can weather use the <code>dx</code> key word and choose a new resolution for the whole domain; wether use different levels of resolution.  The reference level, correponding to the bathymetry resolution or \\(dx\\) if defined by the user, will be the level 0. Levels of resolution are then defined in relation to the reference levels using positive integers to increase the resolution or refine and negative integer to coarsen the grid by a multiple of two. For a given level  \\(n\\) , the resolution  \\(dx_n\\)   will be: $$ dx_n=$rac{dx_0}{2^n} $$</p> <p>with  \\(dx_0\\) the resolution at level 0. </p> <p>When refinning using the level implementation, different key words are expected:</p> <ul> <li><code>Initlevel</code>: level used to create the first mesh created by the code in the mesh refinement process (only a technical information)</li> <li><code>Maxlevel</code>: maximim level of refinement (over-ruling other commands)</li> <li><code>Minlevel</code>: minimum level of refinement (over-ruling other commands)</li> </ul> <p>The grid can also be unregular with an adaptition of the grid to the model (variables at initialisation step or user-defined refinement map). In this case, the cells will be devided in 4 cells for refinement, or 4 cells merged in one for coarsening. The code will ensure a progressive change of resolution (no cell should have a neighbour with more than 1 level of resolution of difference.)</p> <p>The different methods of refinement available in the code are called using the key word \"Adaptation\". The refinement can be based on a classical input variable or a variable calculated during the initialisation:</p> <ul> <li><code>Threshold</code>: impose a threshold for a different level of resolution</li> <li><code>Inrange</code>: impose a range for a different level of resolution</li> <li><code>Targetlevel</code>: the levels of resolution will be targeted but will be overruled by the maxlevel, minlevel entrance.</li> </ul> <p>For example, for the adaptation with targeted levels: </p><pre><code>initlevel = init ;\nmaxlevel =  max ;\nminlevel = min ;\nAdaptation = Targetlevel,MyLevelMap.nc?levels ;\n</code></pre> Where max and min represent the range of level expected, and init is a number in this range (it is advice to use the min level). MyLevelMap is a netcdf 2D map of levels, that can have a different resolution and dimension from the computational grid. The amplitude of the levels on the map can also be larger than than min/max. All these levels are positive or negative integer. <p>For a bathymetry map of \\(10\\)m resolution ( or <code>dx=10</code>), we can use <code>minlevel=-3</code>, <code>maxlevel=2</code> and <code>initlevel=-3</code> to create a grid where coarser cell will be \\(10/2^{-3}=80\\)m and the thinner \\(10/2^2=2.5\\)m. The level file would contains a 2D map with integer values from -3 to 2.</p>"},{"location":"ParametersList-py/","title":"Parameters list","text":""},{"location":"ParametersList-py/#paramter-and-forcing-list-for-bg_flood","title":"Paramter and Forcing list for BG_Flood","text":"<p>BG_flood user interface consists in a text file (<code>BG_param.txt</code> by default), associating key words to user chosen input parameters and forcing information.</p>"},{"location":"ParametersList-py/#list-of-the-input-parameters","title":"List of the input Parameters","text":""},{"location":"ParametersList-py/#general-parameters","title":"General parameters","text":"Reference Keys default Explanation test test -1 -1: no test, 99: run all independent tests, X: run test X g g 9.81 Acceleration of gravity in m.s-2 rho rho 1025.0 Fluid density in kg.m-3 eps eps 0.0001 Drying height in m (if h&lt;eps, the surface is concidered dry) dt dt 0.0 Model time step in s. CFL CFL 0.5 Current Freidrich Limiter criterium (between 0 and 1. Higher values may make the model unstable) theta theta 1.3 Minmod limiter parameter, theta in [1,2]. Can be used to tune the momentum dissipation (theta=1 gives minmod the most dissipative limiter and theta = 2 gives superbee, the least dissipative). VelThreshold VelThreshold , vthresh , vmax , velmax -1.0 Using Velocity threshold if the the velocuity exceeds that threshold. Advice value of 16.0 to use or negative value (-1) to turn off frictionmodel frictionmodel 0 Bottom friction model flag (-1: Manning model, 0: quadratic, 1: Smart roughtness length model) Toutput Toutput 0 Bottom friction model flag (-1: Manning model, 0: quadratic, 1: Smart roughtness length model) cf cf , roughness , cfmap 0.0001 Bottom friction coefficient for the model (if constant) Cd Cd 0.002 Wind drag coefficient il il , Rain_il , initialloss 0.0 Initial Loss value (if constant) cl cl , Rain_cl , continuousloss 0.0 Continuous Loss value (if constant) conserveElevation conserveElevation false Switch to force the conservation of zs instead of h at the interface between coarse and fine blocks wetdryfix wetdryfix , reminstab , fixinstab true Switch to remove wet/dry instability (i.e. true reoves instability and false leaves the model as is) Pa2m Pa2m 0.00009916 Conversion between atmospheric pressure changes to water level changes in Pa (if unit is hPa then user should use 0.009916) Paref Paref 101300.0 Reference pressure in Pa (if unit is hPa then user should use 1013.0) GPUDEVICE GPUDEVICE , gpu 0 0: first available GPU, -1: CPU single core, 2+: other GPU doubleprecision doubleprecision 0 0: float precision, 1: double precision (for the solver and math) savebyblk savebyblk , writebyblk , saveperblk , writeperblk , savebyblock , writebyblock , saveperblock , writeperblock true engine engine 1 1: Buttinger-Kreuzhuber et al. 2019, 2: Kurganov (Popinet 2011), 3: KurganovATMP same as Kurganov but with atmospheric forcing terms"},{"location":"ParametersList-py/#grid-parameters","title":"Grid parameters","text":"Reference Keys default Explanation dx dx nan(\"\") Grid resolution, in m for a metric grid or in decimal degree for a sperical grid. nx nx 0 Initial/input grid size (number of nodes) in x direction ny ny 0 Initial/input grid size (number of nodes) in y direction xo xo , xmin nan(\"\") Grid x origin (if not alter by the user, will be defined based on the topography/bathymetry input map) yo yo , ymin nan(\"\") Grid y origin (if not alter by the user, will be defined based on the topography/bathymetry input map) ymax ymax nan(\"\") Grid ymax (if not alter by the user, will be defined based on the topography/bathymetry input map) xmax xmax nan(\"\") Grid xmax (if not alter by the user, will be defined based on the topography/bathymetry input map) grdalpha grdalpha nan(\"\") Grid rotation on Y axis from the North input in degrees but later converted to rad posdown posdown 0 Flag for bathy input. Model requirement is positive up  so if posdown ==1 then zb=zb*-1.0f spherical spherical , geo 0 Flag for sperical coordinate (still in development) Radius Radius 6371220. Earth radius [m] mask mask 9999.0 Mask any zb above this value. If the entire Block is masked then it is not allocated in the memory"},{"location":"ParametersList-py/#adaptation","title":"Adaptation","text":"Reference Keys default Explanation initlevel initlevel 0 Initial level of grid adaptation (based on dx if defined by the user or on the resolution of the topography/bathymetry input) maxlevel maxlevel -99999 Maximum level for grid adaptation (overwrite the adaptation map if use) minlevel minlevel -99999 Minumim level for grid adaptation (overwrite the adaptation map if use) membuffer membuffer 1.05 Needs to allocate more memory than initially needed so adaptation can happen without memory reallocation"},{"location":"ParametersList-py/#timekeeping","title":"Timekeeping","text":"Reference Keys default Explanation outputtimestep outputtimestep , outtimestep , outputstep 0.0 Number of seconds between netCDF outputs, 0.0 for none endtime endtime , stoptime , end , stop , end_time , stop_time 0.0 Number of seconds between netCDF outputs, 0.0 for none totaltime totaltime , inittime , starttime , start_time , init_time , start , init 0.0 Total simulation time in s dtinit dtinit -1 Maximum initial time steps in s (should be positive, advice 0.1 if dry domain initialement) dtmin dtmin 0.0005 Minimum accepted time steps in s (a lower value will be concidered a crash of the code, and stop the run) reftime reftime , referencetime , timeref \"\" Reference time string as yyyy-mm-ddTHH:MM:SS"},{"location":"ParametersList-py/#boundaries","title":"Boundaries","text":"Reference Keys default Explanation aoibnd aoibnd , remainderbnd , remainbndtype , aoibndtype 0; // Boundary type for AOI: 0=wall; 1 neumann 3 absorbing bndrelaxtime bndrelaxtime 3600.0 Realxation time for absorbing boundary bndfiltertime bndfiltertime 60.0 Filtering time for absorbing boundary"},{"location":"ParametersList-py/#initialisation","title":"Initialisation","text":"Reference Keys default Explanation zsinit zsinit , initzs nan(\"\") Init zs for cold start in m. If not specified by user and no bnd file = 1 then sanity check will set it to 0.0 zsoffset zsoffset nan(\"\") Add a water level offset in m to initial conditions and boundaries (0.0 by default) hotstartfile hotstartfile None Allow to hotstart (or restart) the computation providing a netcdf file containing at least zb, h or zs, u and v hotstep hotstep 0 Step to read if hotstart file has multiple steps (step and not (computation) time) bndtaper bndtaper 0.0 number of second to taper boundary values to smooth transition with initial conditions default is no tapering but 600s is good practice"},{"location":"ParametersList-py/#outputs","title":"Outputs","text":"Reference Keys default Explanation TSnodesout TSnodesout , TSOutput None Time serie output, giving a file name and a (x,y) position(which will be converted to nearest grid position).This keyword can be used multiple times to extract time series at different locations.The data is stocked for each timestep and written by flocs.The resulting file contains (t,zs,h,u,v)Example: \"TSnodesout = Offshore.txt,3101.00,4982.57\" (filename,x,y) outfile outfile \"Output.nc\" Netcdf output file name (if it exists, a number will be happened to the file name to not overwrite it) outvars outvars \"zb\", \"zs\", \"u\", \"v\", \"h\" List of names of the variables to output (for 2D maps)Supported variables = \"zb\", \"zs\", \"u\", \"v\", \"h\", \"hmean\", \"zsmean\", \"umean\", \"vmean\", \"hUmean\", \"Umean\", \"hmax\", \"zsmax\", \"umax\", \"vmax\", \"hUmax\", \"Umax\", \"twet\", \"dhdx\",\"dhdy\",\"dzsdx\",\"dzsdy\",\"dudx\",\"dudy\",\"dvdx\",\"dvdy\",\"Fhu\",\"Fhv\",\"Fqux\",\"Fqvy\",\"Fquy\",\"Fqvx\",\"Su\",\"Sv\",\"dh\",\"dhu\",\"dhv\",\"cf\",\"Patm\", \"datmpdx\",\"datmpdy\",\"il\",\"cl\",\"hgw\";Example: \"outvars = zs,h,u,v,zb,hmax,Umax;\" outzone outzone Full domain Zoned output (netcdf file), giving a file name and the position of two corner points(which will be converted to a rectagle containing full blocks).Time vector or values can also be added to specified special outputs for this one in particular.This keyword can be used multiple times to output maps of different areas.Example: \"outzone=zoomed.nc,5.3,5.4,0.5,0.8;\" (filename,x1,x2,y1,y2) or \"outzone=zoomed.nc,5.3,5.4,0.5,0.8, 3600:360:7200;\" (filename,x1,x2,y1,y2, t_init:t_step:t_end) resetmax resetmax false Switch to reset the \"max\" outputs after each output (reset if 1, no reset if 0) outishift outishift 0 DEBUGGING ONLY: allow cell shift (1 or -1) in x direction to visualise the halo around blocks in the output outjshift outjshift 0 DEBUGGING ONLY: allow cell shift (1 or -1) in y direction to visualise the halo around blocks in the output"},{"location":"ParametersList-py/#netcdf-parameters","title":"Netcdf parameters","text":"Reference Keys default Explanation smallnc smallnc 1 Short integer conversion for netcdf outputs. 1: save as short integer for the netcdf file, if 0 then save all variables as float scalefactor scalefactor 0.01f Scale factor used for the short integer conversion for netcdf outputs. This follow the COARDS convention. addoffset addoffset 0.0f Offset add during the short integer conversion for netcdf outputs (follow the COARDS convention)"},{"location":"ParametersList-py/#paraview-catalyst-parameters-special-use-with-paraview","title":"ParaView Catalyst parameters (special use with ParaView)","text":"Reference Keys default Explanation use_catalyst use_catalyst 0 Switch to use ParaView Catalyst catalyst_python_pipeline catalyst_python_pipeline 0 Pipeline to use ParaView Catalyst vtk_output_frequency vtk_output_frequency 0 Output frequency for ParaView Catalyst vtk_output_time_interval vtk_output_time_interval 1.0 Output time step for ParaView Catalyst vtk_outputfile_root vtk_outputfile_root \"bg_out\" output file name for ParaView Catalyst python_pipeline python_pipeline \"coproc.py\" python pipeline for ParaView Catalyst rainbnd rainbnd , rainonbnd false when false it force the rain forcing on the bnd cells to be null. adaptmaxiteration adaptmaxiteration , maxiterationadapt 20 Maximum number of iteration for adaptation. default 20"},{"location":"ParametersList-py/#list-of-the-forcings-inputs","title":"List of the Forcings' inputs","text":"Reference Keys default Example Explanation cf cf , roughness , cfmap (see constant in parameters) cf=0.001;cf=bottom_friction.nc?bfc; Bottom friction coefficient map (associated to the chosen bottom friction model: n, z0, ...)A list of roughness map can be provide. At any grid point, the last one defined will be used. il il , Rain_il , initialloss (see constant in parameters) il=rain_loss.nc?initial_loss; Initial Rain loss coefficient map (in mm) cl cl , Rain_cl , continuousloss (see constant in parameters) cl=rain_loss.nc?continuous_loss; Continuous Rain loss coefficient map (in mm/h) Bathy Bathy , bathyfile , bathymetry , depfile , depthfile , topofile , topo , DEM None but input NECESSARY bathy=Westport_DEM_2020.nc?ztopo=Westport_DEM_2020.asc Bathymetry/Topography input, ONLY NECESSARY INPUTDifferent format are accepted: .asc, .nc, .md. , the grid must be regular with growing coordinate.This grid will define the extend of the model domain and model resolution (if not inform by the user).The coordinate can be cartesian or spherical (still in development).A list of file can also be use to provide a thiner resolution localy by using the key word each time on a different line.The first file will be use to define the domain area and base resolution but the following filewill be used during the refinement process. AOI AOI , aoipoly N/A AOI=myarea.gmt; Area of interest polygonthe input file is a text file with 2 columns containing the coordinate of a closed polygon (last line==first line) left left , leftbndfile , leftbnd 1 left = 0;left = leftBnd.txt,2; 0:Wall (no slip); 1:neumann (zeros gradient) [Default]; 2:sealevel dirichlet; 3: Absorbing 1D 4: Absorbing 2D (not yet implemented)For type 2 and 3 boundary, a file need to be added to determine the vaules at the boundary. This file will consist in a first column containing time (with possibly variable time steps) and forcing values in the following columns (1 column of values corresponding to a constant value along the boundary, 2 columns correspond to values at boundary edges with linear evolution in between, n columns correspond to n regularly spaced values applied along the boundary) right right , rightbndfile , rightbnd 1 right = 0;right = rightBnd.txt,2; Same as left boundary top top , topbndfile , topbnd 1 top = 0;top = topBnd.txt,2; Same as left boundary bot bot , botbndfile , botbnd , bottom 1 bot = 0;bot = botBnd.txt,2; Same as left boundary deform deform None deform = myDeform.nc?z_def,3.0,10.0;deform = filename, time of initial rupture, rising time; Deform are maps to apply to both zs and zb; this is often co-seismic vertical deformation used to generate tsunami initial waveHere you can spread the deformation across a certain amount of time and apply it at any point in the model. rivers rivers , river None river = Votualevu_R.txt,1867430,1867455,3914065,3914090;river = Fluxfile, xstart, xend, ystart, yend; The river is added as a vertical discharge (m3/s) on a chosen area (the user input consists in a time serie and a rectangular area definition).The whole cells containing the corners of the area will be included in the area, no horizontal velocity is applied.To add multiple rivers, just add different lines in the input file (one by river). Wind Wind , windfiles None Wind = mywind.nc?uw,mywind.nc?vwWind = MyWind.txt Spacially varying (.nc): 2 files are given, 1st file is U wind and second is V wind (no rotation of the data is performed)Spacially uniform (.txt): 1 file is given then a 3 column file is expected, showing time, windspeed and direction.Wind direction is rotated (later) to the grid direction (using grdalpha input parameter) Atmp Atmp , atmpfile None Atmp=AtmosphericPressure.nc?p Atmospheric forcing file. The forcing pressure is expected to be in Pa and the effect of the atmospheric pressure gradient is calculated as the difference to a reference pressure Paref, converted to a height using the Pa2m parameter. Rain Rain , rainfile None rain=rain_forcing.txt rain=rain_forcing.nc?RainIntensity This allow to force a time varying, space varying rain intensity on the model, in mm/h.Spacially varrying (rain map), a netcdf file is expected (with the variable associated to the rain after \"?\").Spacially uniform: the rain is forced using a time serie using a 2 column values table containing time (not necessary unformly distributed) and rain."},{"location":"ParametersList-py/#list-of-the-non-identified-inputs","title":"List of the non-identified inputs","text":"Reference Keys MassConservation MassConservation , MassCon , forcemassconservation , forcevolumeconservation , Volumeconservation , VolumeCon , ForceMassConserve , ForceVolConserve Adaptation Adaptation crs crs , spatialref , spatial_ref , wtk , crsinfo , crs_info bathyfile bathyfile bathymetry bathymetry depfile depfile bnd bnd , bndseg cavity cavity <p>Note</p> <p>The keys are not case sensitive.</p>"},{"location":"README_doc/","title":"Documentation Generation","text":""},{"location":"README_doc/#documentation-generation","title":"Documentation Generation","text":"<p>The documentation is generated using: - Doxygen to extract the code information (from .cu, .h and *.cpp files) - Mkdocs-material to generate the markdown part of the documentation - mkdoxy pluggin is added convert XML files generated by doxygen in markdown and include them in the documentation.</p> <p>The documentation is located in the \"docs\" folder. Mkdocs documentation is configured using the mkdocs.yml file (located in root folder). The documentation set-up (librarys...) is saved in the pyproject.toml.</p> <p>The documentation is then deployed directly from the github page of the code, using a workflow action. When this action is triggered, the documentation pages are updated and pushed in a special branch: \"gh-page\" and deplyed from there.</p> <p>Different pluggins have been added to improve the documentation: - mkdocs-awesome-nav : to improve the navigation and use of glob type notation to get for example all the md files in a folder</p>"},{"location":"References/","title":"References","text":""},{"location":"References/#references","title":"References","text":"<p>Prefered BG_Flood citation</p> <p><sup>1</sup>Cyprien Bosserelle, Emily Lane, and Alice Harang. Coastal flooding and port infrastructure: a case study of apia, samoa. Coasts and Ports, 2022.</p>"},{"location":"References/#acknowledgments","title":"Acknowledgments","text":"<ul> <li>Basilisk and its teams from where this code originate</li> <li>ESNZ (previously NIWA)</li> <li>"},{"location":"References/#list-of-references","title":"List of references","text":"<p>Full reference list from work used in the development of BG_Flood and produced using the code.</p> <ol> <li> <p>Cyprien Bosserelle, Emily Lane, and Alice Harang. Coastal flooding and port infrastructure: a case study of apia, samoa. Coasts and Ports, 2022.\u00a0\u21a9</p> </li> <li> <p>Renato Vacondio, Alessandro Dal Pal\u00f9, Alessia Ferrari, Paolo Mignosa, Francesca Aureli, and Susanna Dazzi. A non-uniform efficient grid type for gpu-parallel shallow water equations models. Environ. Model. Softw., 88(C):119\u2013137, February 2017. URL: https://doi.org/10.1016/j.envsoft.2016.11.012, doi:10.1016/j.envsoft.2016.11.012.\u00a0\u21a9</p> </li> <li> <p>Rebecca Welsh, Shaun Williams, Cyprien Bosserelle, Ryan Paulik, Josephina Chan Ting, Alec Wild, and Lameko Talia. Sea-level rise effects on changing hazard exposure to far-field tsunamis in a volcanic pacific island. Journal of Marine Science and Engineering, 2023. URL: https://www.mdpi.com/2077-1312/11/5/945, doi:10.3390/jmse11050945.\u00a0\u21a9</p> </li> </ol>"},{"location":"Tutorial_intro/","title":"Introduction","text":""},{"location":"Tutorial_intro/#tutorials","title":"Tutorials","text":"<p>Here is a list of all the available tutorials:</p> <ul> <li> <p>Jet tutorial (Julia): Simple tutorial presenting a jet simulation in BG_Flood. All imputs files are generated manually or with Julia.</p> </li> <li> <p>Gaussian wave: Simple tutoral presenting a Gaussian wave propagation</p> </li> <li> <p>Transpacific tsunami: Simple tutorial presenting a transpacific tsunami propagation</p> </li> <li> <p>River flooding tutorial: Simple tutorial that go through the construction of a simple <code>BG_param.txt</code> file for fluvial and pluvial flooding. Some realistic input files are provided.</p> </li> <li> <p>Monia tutorial (Julia): still in construction</p> </li> </ul>"},{"location":"Tutorial_jet_Julia2/","title":"Tutorial jet Julia2","text":"<p>@page TutorialJetJulia Jet tutorial with Julia</p> <p>This is a very simple example that shows the model stability in transitional flows.</p>"},{"location":"Tutorial_jet_Julia2/#make-a-bathymetry","title":"Make a bathymetry","text":"<p>Below is a Julia script to make the bathymetry.</p> <pre><code>using GMT\n\nny=16*16;\nnx=16*32;\n\ndx=5.0;\n\nxmin=0;\nxmax=nx*dx;\n\nymin=0;\nymax=ny*dx;\n\nBathy=zeros(nx,ny);\n\nBathy.=-5.0;\n\nBathy[170:172,:].=5.0;\nBathy[170:172,127:129].=-5.0;\n\nBathy[:,1:2].=5.0;\nBathy[:,(end-1):end].=5.0;\n\nG = mat2grid(transpose(Bathy), 1,[xmin xmax ymin ymax -5.0 5.0 1 dx dx])\ncmap = grd2cpt(G);      # Compute a colormap with the grid's data range\ngrdimage(G, lw=:thinnest, color=cmap, fmt=:png, show=true)\n\ngmtwrite(\"bathy.asc\", G; id=\"ef\");\n</code></pre> <p>The result is a grid domain looking like this:  You can also use the bathy.asc file in the example folder.</p>"},{"location":"Tutorial_jet_Julia2/#make-bnd-files","title":"Make Bnd files","text":"<p>We are going to set the water level to 0.0m on the right and 1.0 on the left and keep it constant. To dio that we create 2 files <code>right.txt</code> and <code>left.bnd</code></p>"},{"location":"Tutorial_jet_Julia2/#rightbnd","title":"<code>right.bnd</code>","text":"<pre><code># This is the right boundary\n0.0 0.0\n3600.0 0.0\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#leftbnd","title":"<code>left.bnd</code>","text":"<pre><code># This is the right boundary\n0.0 1.0\n3600.0 1.0\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#set-up-the-bg_paramtxt-file","title":"Set up the <code>BG_param.txt</code> file","text":"<p>First it is good practice to document your parameter file:</p> <pre><code>##############################\n## Jet demo\n# CB 04/05/2019\n</code></pre> <p>Then specify the bathymetry file to use. We will use the entire domain and resolution of the file so no need for other parameter for specifying the domain.</p> <pre><code>bathy=bathy.asc\n</code></pre> <p>Specify the parameter theta to control the numerical diffusion of the model. but first let's leave it to the default.</p> <pre><code>theta=1.3;\n</code></pre> <p>This is a relatively small model so we can force the netcdf variable to be saved as floats.</p> <pre><code>smallnc=0\n</code></pre> <p>Sepcify the model duration, output timestep and output file name and variables</p> <pre><code>endtime=1800\nouttimestep=10\noutfile=Jet_demo.nc\noutvars=zb,uu,vv,zs,vort;\n</code></pre> <p>Specify absorbing boundaries for left and right (There is a wal at the top and bottom so no need to specify any boundary there).</p> <pre><code>right = 3; # Absorbing bnd\nrightbndfile = right.bnd\n\nleft=3; # Absorbing bnd\nleftbndfile = left.txt\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#run-the-model","title":"Run the model","text":"<p>If you are on windows simply double-click on the executable and in linux launch the binary.</p> <p>Vorticity output should look like this:</p> <p>Video</p>"},{"location":"Tutorial_jet_Julia2/#things-to-try","title":"Things to try","text":"<ul> <li>What happens when using a different value for theta (1-2.0)</li> <li>What happens when specifying a different type of boundary on the right </li> <li>What happens when you bring the boundary close to the jet</li> <li>Why is the jet so unstable/asymmetrical? (what are the initial condition like?)</li> </ul>"},{"location":"Tutorial_jet_Julia2/#gaussian-wave","title":"Gaussian Wave","text":"<p>This is a great example to test whether there are bugs in the model and how the boundary work.</p>"},{"location":"Tutorial_jet_Julia2/#bathymetry","title":"Bathymetry","text":"<p>We start with a flat bathymetry with 0.0 everywhere. You still need a file for that!</p> <p>Here a couple of suggestion on making the file: Using GMT: <code>grdmath -R-5/5/-5/5 -I0.03921 0 MUL = bathy.nc</code></p> <p>Using Julia: See section below with the hotstart file.</p> <p>In any case you can pick up the file in the example folder.</p>"},{"location":"Tutorial_jet_Julia2/#hortstart","title":"Hortstart","text":"<p>We want to setup a bump in the water level centered in the middle of the bathy. IN the example below this is done using Julia, but it should be easily done in Matlab or Python. Note that the script below also generates a bathymetry file.</p> <pre><code>using GMT\n\nxo=-5;\nyo=-5;\n\nnx=16*16;\nny=16*16;\n\nlen=10.0;\n\ndx=len/(nx-1);\n\nxx=collect(xo:len/(nx-1):(len+xo));\nyy=collect(yo:len/(ny-1):(len+yo));\n\n# Make a bathy file\nzb=zeros(nx,ny);\nG = mat2grid(transpose(zb), 1,[xx[1] xx[end] yy[1] yy[end] minimum(zb) maximum(zb) 1 dx dx])\ngmtwrite(\"bathy.asc\", G; id=\"ef\");\n\n#make the hotstart file\nhh=zeros(nx,ny);\nfor i=1:nx\n    for j=1:ny\n        hh[i,j] = 1.0.+ 1.0.*exp.(-1.0*(xx[i].*xx[i] .+ yy[j].*yy[j]));\n        #hh[i,j] =\n    end\nend\n\nG = mat2grid(transpose(hh), 1,[xx[1] xx[end] yy[1] yy[end] minimum(hh) maximum(hh) 1 dx dx])\ncmap = grd2cpt(G);      # Compute a colormap with the grid's data range\ngrdimage(G, lw=:thinnest, color=cmap, fmt=:png, show=true)\n\ngmtwrite(\"gauss.asc\", G; id=\"ef\");\ngmtwrite(\"gauss.nc\", G);\n# GMT netcdf variable is \"z\" by default but the hotstart file needs \"zs\" for water surface\ngmt(\"grdmath gauss.nc 1.0 MUL = gauss_zs.nc?zs\");\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#make-bnd-files_1","title":"Make Bnd files","text":"<p>We are going to set the water level to 0.0m on all 4 sides and keep it constant. To do that we create 1 files <code>zero.txt</code>:</p> <pre><code># This is the a boundary\n0.0 0.0\n3600.0 0.0\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#set-up-the-bg_paramtxt-file_1","title":"Set up the <code>BG_param.txt</code> file","text":"<p>First it is good practice to document your parameter file:</p> <pre><code>##############################\n## Gaussian bump demo\n# CB 04/05/2019\n</code></pre> <p>Then specify the bathymetry file to use. We will use the entire domain and resolution of the file so no need for other parameter for specifying the domain.</p> <pre><code>bathy=bathy.asc\n</code></pre> <p>This is a relatively small model so we can force the netcdf variable to be saved as floats.</p> <pre><code>smallnc=0\n</code></pre> <p>Specify the hotstart file:</p> <pre><code>hotstartfile=gauss_zs.nc;\n</code></pre> <p>Boundary conditions are all the same :</p> <pre><code>right = 3; # Absorbing bnd\nrightbndfile = zeros.txt\n\ntop = 3; # Absorbing bnd\ntopbndfile = zeros.txt\n\nbot = 3; # Absorbing bnd\nbotbndfile = zeros.txt\n\nleft=3; # Absorbing bnd\nleftbndfile=zeros.txt\n</code></pre> <p>Time keeping:</p> <pre><code>endtime=20;\nouttimestep=1;\n</code></pre> <p>Output parameters:</p> <pre><code># Netcdf file for snapshot of the model domain\noutfile=Gauss_demo.nc\noutvars=zb,uu,vv,zs,vort;\n\n# Outpout a single txt file with all the model steps at the nearest node to location x=0.0, y=-4.0\n# This file will contain 5 column: time,zs,hh,uu,vv\nTSOfile=Southside.txt;\nTSnode=0.0,-4.0;\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#run-the-model_1","title":"Run the model","text":"<p>Plot Southside.txt in your favorite tool.</p>"},{"location":"Tutorial_jet_Julia2/#things-to-try_1","title":"Things to try:","text":"<ul> <li>What happens with different boundary types</li> <li>Try running with double precision. What is the difference?</li> </ul>"},{"location":"Tutorial_jet_Julia2/#transpacific-tsunami","title":"Transpacific tsunami","text":"<p>This tutorial is the next stat from the Gaussian wave. Here we produce a realistic tsunami and let it propagate across the Pacific.</p>"},{"location":"Tutorial_jet_Julia2/#bathy-and-domain-definition","title":"Bathy and domain definition","text":"<p>The bathymetry file we are using was extracted from the GEBCO gobal bathymetry using GMT command grdcut / grdsample. This section needs a tutorial of its own. Here in the <code>BG_param.txt</code> we specify the file name and that it is a spherical model domain.</p> <pre><code># Bathymetry file\nbathy = Tpac_big.asc;\nspherical = 1;\n</code></pre> <p>The file covers a bigger area than we want to use for the simulation so we restict the domain:</p> <pre><code>ymin=-78.0\nymax=14.32\n\ndx=0.08;\n</code></pre> <p>Also we do not want to simulate Blocks that are entirely covered in land where the elevation is bigger than say 30.0m above the datum</p> <pre><code>mask = 30.0;\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#initial-tsunami-wave","title":"Initial tsunami wave","text":"<p>See matlab file in the folder or simply use:</p> <pre><code>hotstartfile=Maule_zs_init_simpleflt.nc;\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#boundary","title":"Boundary","text":"<p>In the previous tutorial you have seen how different boundary type let's wave through with minimal reflection. You choose.</p>"},{"location":"Tutorial_jet_Julia2/#time-keeping","title":"Time Keeping","text":"<pre><code>totaltime = 0.000000; # Start time\nendtime = 54000.000000;\noutputtimestep = 600.000000;\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#outputs","title":"Outputs","text":"<pre><code>outvars = hh,zs,zsmax;\n# Files\noutfile = Output_simple_fault.nc;\nsmallnc = 0; #if smallnc==1 all Output are scaled and saved as a short int\n\nTSnode = -86.374,-17.984\nTSOfile = SW_Lima.txt\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#things-to-try_2","title":"Things to try","text":"<ul> <li>Try changing the model domain and resolution. What happens if part of the domain is outside of the area covered by the bathymetry?</li> <li>Try outputing a time series near Christchurch</li> </ul>"},{"location":"Tutorial_jet_Julia2/#river-rain-waikanae-example","title":"River + Rain = Waikanae example","text":"<p>Here we setup a model of the Waikanae Catchment (on the Kapiti Coast in New Zealand) force the tide on one of the open boundary </p>"},{"location":"paper/","title":"'BG_Flood: Adaptive GPU-capable hydrodynamics model for flood and inundation '","text":"<ul> <li>C++</li> <li>CUDA</li> <li>flood</li> <li>inundation</li> <li>tsunami</li> <li>storm-surge</li> <li>adaptive mesh refinement</li> <li>GPU</li> </ul> <p>authors:   - name: Cyprien Bosserelle  q  corresponding: true # (This is how to denote the corresponding author)     orcid: 0000-0000-0000-0000     equal-contrib: true     affiliation: 1   - name: Alice Harang     equal-contrib: true # (This is how you can denote equal contributions between multiple authors)     orcid: 0000-0000-0000-0000     affiliation: 1   - name: Emily Lane     affiliation: 1 affiliations:  - name: Earth Sciences New Zealand    index: 1</p> <p>date: 1 July 2025 bibliography: paper.bib</p>"},{"location":"paper/#summary","title":"Summary","text":"<p>Flood hazard assessment and forecasting aften require physics-based simulations. These simulation are often completted using hydrodynamics models using high resolution to capture small landscape and flow features (e.g. small drains, hydraulic jump), but also capture large scale domain where the hazard forms and or amplifies (e.g. river catchment, continental shelf). this is only acheivable with unstructured and adaptive mesh. Unfortunatly most available open-source codes only provide unstructured mest that rely heavily on user's input for generating a suitable mesh. These model also do not generally offer a flexibility in reverting mesh generation. Most available open-source model also do not offer GPU enabled code that is well optimised and instead for the few that can offer  </p> <p>Enabling GPU and semi-automatic mesh refinement is critical to enable rapid devlopement of flood assessment that doesn't compromise physics simulated.     </p>"},{"location":"paper/#statement-of-need","title":"Statement of need","text":"<p>BG_Flood is a numerical model for simulating shallow water hydrodynamics on the GPU using an Adaptive Mesh Refinment type grid. The model was designed with the goal of simulating inundation (River, Storm surge or tsunami). The model uses a Block Uniform Quadtree approach that runs on the GPU with adaptive mesh being generated at the start of tee simulation.</p> <p>The core SWE engines and adaptivity has been inspired and taken from St Venant solver from Basilisk (Popinet XXXX) and the CUDA GPU memory model has been inspired by the work from (Vacondio et al. 2017). The rest of the implementation</p>"},{"location":"examples/GaussianWave/","title":"GaussianWave","text":"<p>@page GaussianWave Gaussian wave verification</p>"},{"location":"examples/GaussianWave/#intro","title":"Intro","text":"<p>This is a basic but common test to verify the integrity of the model equations. This test is also good to show different type of boundaries reflect waves. </p>"},{"location":"examples/GaussianWave/#goal","title":"Goal","text":"<ul> <li>Check that the solution produces symmetrical results</li> <li>Test hotstart condition</li> <li>Show how different boundary formulation absorb wave</li> </ul>"},{"location":"examples/GaussianWave/#settings","title":"Settings","text":""},{"location":"examples/GaussianWave/#you-will-need","title":"You will need:","text":"<ul> <li>Flat bottom bathymetry file. (See below) </li> <li>Hotstart file. here only water level is needed to hotstart the water surface (zs)</li> </ul>"},{"location":"examples/GaussianWave/#bathy","title":"Bathy","text":""},{"location":"examples/GaussianWave/#initial-conditon","title":"Initial conditon","text":"<p>Here we follow a similar initial condition as in Basilisk</p>"},{"location":"examples/GaussianWave/#bg_paramtxt","title":"BG_param.txt","text":"<pre><code>bathy = bathy.nc?z;\n# Model controls\ngpudevice = 0;\nspherical = 0;\ntheta=1.3;\ndoubleprecision=1\nzsinit=0.0\nhotstartfile=zsinit.nc\n# Flow parameters\neps = 0.00010000;\ncf=0.0000;\nfrictionmodel = 0\n# Timekeeping parameters\nCFL = 0.500000;\noutputtimestep = 600.0;\noutvars = zb, hh, uu, vv, hhmax, zs, zsmax;\nendtime = 18000.0;\nleft=2;\nright=2;\ntop=2;\nbot=2;\ntopbndfile=bnbzero.txt;\nbotbndfile=bnbzero.txt;\nrightbndfile=bnbzero.txt;\nleftbndfile=bnbzero.txt;\nsmallnc=0;\noutfile = Testbed-Gaussian.nc;\n</code></pre>"},{"location":"examples/GaussianWave/#result","title":"Result","text":""},{"location":"examples/GaussianWave/#run-times","title":"Run times","text":""},{"location":"examples/Monai/","title":"Monai","text":"<p>@page Monai Monai test Case</p>"},{"location":"examples/Monai/#goals","title":"Goals","text":"<ul> <li>Check Boundary forcing</li> <li>Check wave propagation and runup on complex topography against experimental data</li> </ul>"},{"location":"examples/Monai/#status","title":"Status","text":"<p>Success</p>"},{"location":"examples/Monai/#settings","title":"Settings","text":""},{"location":"examples/Monai/#results","title":"Results","text":"<p>Model behaves similar to other codes and ca reproduce the bulk of the tsunami waves. Results are comparable to the same class of models. The double precision simulation is virtually identical to the Double precision run confirming that in this case there is not much point on using the Double precision.</p> <p>skill assessment: Single precision</p> ------------- RMS error (m) Will-corr BSS Gauge 1 0.003391 0.978040 0.910979 Gauge 2 0.003735 0.965899 0.870943 Gauge 3 0.003284 0.976699 0.884080 <p>Double precision</p> ------------- RMS error (m) Will-corr BSS Gauge 1 0.003391 0.978039 0.910981 Gauge 2 0.003733 0.965948 0.871093 Gauge 3 0.003283 0.976704 0.884097 <p> Figure 1. Measured and simulated timeseries for the Monai benchmark</p>"},{"location":"examples/Monai/#run-times","title":"Run times","text":"GPU Quadro K620 GeForce GTS 450 other GPU Single Precision (s) 27 20 XX Double Precision (s) XX 34 XX"},{"location":"examples/RainOnGrid/","title":"RainOnGrid","text":"<p>@page RainOnGrid Rain on grid</p>"},{"location":"examples/RainOnGrid/#rain-on-grid","title":"Rain-on-grid","text":""},{"location":"examples/RainOnGrid/#goals","title":"Goals","text":"<ul> <li>Check rainfall forcing</li> <li>Check model mass conservation</li> <li>Compare model performance to experimental data</li> </ul>"},{"location":"examples/RainOnGrid/#settings","title":"Settings","text":""},{"location":"examples/RainOnGrid/#results","title":"Results","text":""},{"location":"modules/NewGradient/","title":"New Gradient Method","text":"<p>Halo and gradient</p> <p>Using multi-resolution in BG_Flood, we need to keep track of how blocks with different resolutions talk to each other. This page tries to explain how this is done.</p>"},{"location":"modules/NewGradient/#why-halo","title":"Why halo","text":"<p>In BUQ grid we keep track of a ring of cells (halo) on every edge of the block. These cells store the information corresponding to the neighbor cells on the neighbor block. If the neighbor block is at the same level of refinement, the values in the halo are a simple copy otherwise they are calculated using the operations described below. The point of the halo is that, when doing operations on a block, the model doesn't need to look at other blocks. It also makes it cleaner and avoid repeating the costly calculation needed when two blocks are at a different levels of refinment.</p> <p>The halo cells exist for all variables including gradients so, even when looking at immediate neighbor cells we can make 2nd order calculations. </p> <p>Here is a diagram for a block of 16x16 cells:</p> <p></p>"},{"location":"modules/NewGradient/#restriction-and-prolongation","title":"Restriction and prolongation","text":"<p>In Basilisk the operation to calculate a value from one level to another are called restriction and prolongation depending whether you calculate from coarse to fine or fine to coarse.</p> <p>If the two blocks are the same level of refinement:</p> <p></p> <p>otherwise:</p> <p></p>"},{"location":"modules/NewGradient/#prolongation","title":"Prolongation","text":"<p>Prolongation is the action of extending a value from a coarse cell to a finer cell. Often this is done by using the gradient value.  e.g.:</p> \\[ HaloB = A + Gradient(A) * dx * 0.5 \\]"},{"location":"modules/NewGradient/#restriction","title":"Restriction","text":"<p>Restriction is where we calculate the value of a coarse cell from values of fine cells. This is usually done with cell average.</p> \\[ HaloA = 0.25*(B1+B2+B3+B4) \\]"},{"location":"modules/NewGradient/#filling-the-halo-the-chicken-and-the-egg","title":"Filling the Halo: The chicken and the egg.","text":"<p>When doing a prolongation operation one needs the gradient of the variable but to calculate gradient the halo needs to be filled. This is a chicken and egg situation.</p> <p>The naive way of doing this is to first do restiction, calculate a gradient (everywhere), then doing the prolongation and then recalculating the gradient (everywhere) to fix the gradient in the cell neighboring prologation cells. This is inefficient!</p> <p>Instead we first fill the halo for straight copy cells and restriction cells. Then calculate gradient (everywhere) and then do the prolongation where needed and then recalculating the gradient on cells near halo only.</p>"},{"location":"modules/NewGradient/#conserving-elevation","title":"Conserving elevation","text":"<p>Using prolongation at the wet/dry interface can lead to inconsistencies between \\(h\\) and \\(zs\\). To limit the inconsistency \\(zs\\) is calculated from \\(h\\) after a prolongation calculation (see refine_linear). While this conserves mass, it, however, leads to a violation of the lake-at-rest resulting in (small) spurious velocity at that interface. To remove the instability and preserve the elevation of the water (rather than its mass) we use a conserve elevation option (conserveelevation = true). This gets rid of the instability and preserves the elevation of the water level but then violates the mass conservation.</p>"},{"location":"modules/NewGradient/#fluxes-halo-are-a-bit-different","title":"Fluxes halo are a bit different","text":""},{"location":"modules/RainLoss_ILCL-model/","title":"Ground infiltration","text":"<p>Ground infiltration: Initial Loss - Continuous Loss</p> <p>Rainfall is often absorbed in soil and leaf litter before joining surface flow.The default behaviour of BG_Flood is to assume the rainfall given as input is actually runoff (i.e. rainfall exess that will make the surface flows). Instead a basic initial - continuous loss model can be apply to approximate runoff. </p>"},{"location":"modules/RainLoss_ILCL-model/#model-implemented","title":"Model implemented","text":"<p>The Initial Loss - Continuous Loss (ILCL) is a very basic model for infiltration of surface water in the soil. It requires the input of two maps, based on the soil properties: one containing an initial loss coefficient \\(il\\) in mm, the second containing a continuous loss coefficient \\(cl\\) in mm/hr.</p> <p>In this model, the initial and continuous losses are applied directly on the water elevation computed on each cell (and not by modifying the rain input). The value of the initial loss \\(il\\) is estimated to be the total of water infiltrating in the ground before the beginning of the surface runoff, whereas the continuous loss \\(cl\\) is the loss that occurs, on wet cells, from the begining of the surface runoff to the end of the simulation. The water absorbed in the ground will be tracked using the ground water elevation variable \\(hgw\\) but wont be reintroduced to the surface flow through the computation process.</p> <p>On each cell, at each simulation step, we can express the quantity of water absorbed in the ground \\(ha_{t}\\) using:</p> \\[ ha_{t} = \\begin{cases}   h_{t} &amp; \\text{if} \\;\\; hgw_{t-1} + h_{t} &lt; il\\\\      cl &amp; \\text{if}\\;\\; hgw_{t-1} &gt; il\\\\      \\min(il - hgw_{t-1} + cl\\,,\\, h_{t}) &amp; \\text{otherwise} \\end{cases} \\] <p>where \\(il\\) and \\(cl\\) are respectively the initial loss and continuous loss coefficient at a given cell location, and \\(hgw_{t}\\) is the accumulated ground water at this cell location since the begining of the simulation.</p> <p>The water absorbed is then added to the ground water tracking variable:</p> \\[ hgw_{t}=hgw_{t-1} + ha_{t} \\] <p>and removed from the surface water height and the surface water elevation (not shown here):</p> \\[ h_{t \\;final} = h_{t} - ha_{t} \\] <p>The following figure shows a representation of the initial loss - continuing loss model with \\(il = 10 mm\\) and \\(cl = 1 mm/s\\) :</p> <p></p> <p>Initial loss and continuing loss reprensentation during a cell-wetting event</p> <p>Note</p> <p>All cells that are initially wet at the begining of the simulation (\\(h &gt; XParam.eps\\)) will have their initial loss (\\(il\\)) set to 0.0, in order to be consistent with the physic of the model.</p> <p>Warning</p> <p>This model is meant to be used with the rain on grid feature. The model is applied indistinctively to water from any source and can cause unexpected results if misused.</p>"},{"location":"modules/RainLoss_ILCL-model/#testcase-for-the-ilcl-model","title":"Testcase for the ILCL model","text":"<p>The ILCL model is tested in the Westport (ANZ) area, on the Orowaiti river (with a uniform 5m grid). A 20mm/hr rain is uniformly applied on the domain during 30 minutes. An initial loss of 5mm and an continuous loss of 5mm/h are used to define infiltration uniformly on the domain. The results, compared to a reference case without infiltration, are presented in the following figure. </p>"},{"location":"modules/RainLoss_ILCL-model/#reference-values","title":"Reference values","text":"<p>Some reference values for the \\(il\\) and \\(cl\\) coefficients can be found in the literature. Some relate to entire subcatchment and are estimated from hydrology, other can be defined using local information (type of soil, rain antecedents, soil layer depth, ...). Whatever you select, be mindfull the model is likely to be very sensitive to rainfall loss.</p> <p>The Initial loss is usually defined based on the antecedent moisture conditions and the soil layer depth and range from 0 to 50mm. The Australian Rainfall &amp; Runoff project concidere the initial loss value at a catchemnt scale and observed a low mean value of 1.1mm in urban catchments; in rural catchment, the initial loss is highly variable with a mean of 32mm and a standard deviation of 17mm.</p> <p>The Constant loss rate can typically be related to the saturated hydraulic conductivity. The following table as been produced by Rawls, Brakensiek, and Miller (1983) using mesurements on soil samples from the USA.</p> Soil texture class Hydraulic conductivity or continuous loss (mm/h) Sand 117.8 Loamy sand 29.9 Sandy loam 10.9 Loam 3.4 Silt loam 6.5 Sandy clay loam 1.5 Clay loam 1.0 Silty clay loam 1.0 Sandy clay 0.6 Silty clay 0.5 Clay 0.3 <p>Below is the ARR 2016 Rainfall Loss Parameters for Urban area, depending of the surface type: | Urban Surface | Burst Initial loss (mm) | Continuing loss (mm/hr) | | :-------------: | ----------------------- | ----------------------- | | Effective Impervious Area | 0.4 | 0.0 | | Indirectly Connected Area | 16.1 | 1.6 | | Urban Pervious Area | 26.9 |1.6|</p> <p>Below is an other example of compilation of some of these values from https://help.innovyze.com/display/xprafts/Initial+and+Continuing+Loss+Model.</p> <p></p>"},{"location":"modules/Wetdryfix-Conservelevation/","title":"Wet-dry fix","text":""},{"location":"modules/Wetdryfix-Conservelevation/#conserve-elevation","title":"Conserve Elevation","text":"<p>At the interface of coarse and fine blocks we often cannot strictly conserve both mass (h) and water elevation. The difference in most cases is relatively small but near the wet/dry interface, trying to conserve mass leads to instabilities. Since these instabilities are a bit annoying by default BG_Flood enforces the conservation of elevation at the interface between coarse and fine blocks where wet and dry cells are present. This might lead to a mismatch between the expected volume and actual volume when simulating rain or river flooding. Similarly, ignoring the conserve elevation requirement when simulating a tsunami can lead to a underestimate of the tsunami. The impact of these switch is small and we can show how small they are below.</p> <p>Below are two examples of basic flood model to test the impact of the wet/dry instability fix (hereafter wetdryfix) on mass conservation. Further below is to test the impact of the wetdryfix and conserve elevation routimne (hereafter conserveElevation) on a tsunami wave propagating on a real steep bathymetry (Samoa).</p>"},{"location":"modules/Wetdryfix-Conservelevation/#mass-conservation-implication","title":"Mass conservation implication","text":"<p>Using the Waikanae topo with cst rain at 50mm/h for 1 hour. using the rainbnd option and wall bnd on all side. Results are undestinguishable from each other and after 1 hr the model has 100.48% of the theoretical volume of water in both with and without the wetdryfix.  </p> <p>For comparison the current Dev branch has 100.19% of the theoretical volume. While this is somehow better it does not really undermine the new branch (i.e. the dev branch might get closer to the theory for the wrong raisons), the bugfixes and instability improvement of this branch are totally justified. </p> <p>results:</p> % of theoretical volume runtime Wetdry fix 100.48% 97s NO Wetdryfix 100.48% 96s"},{"location":"modules/Wetdryfix-Conservelevation/#tsumani-test-results","title":"Tsumani test results","text":"<p>The impact of the wet/dry fix should be much more obvious in tsunami simulation but here conserve elevation should be used in most tsunami cases.</p>"},{"location":"modules/Wetdryfix-Conservelevation/#no-wetdryfix","title":"No wetdryfix","text":"<p>switching off the wetdryfix causes instability that really have an impact on tsunami wave. Here the instability are clearly visible in the map and in the comparison are seen as 0.01 m waves before the tsunami wave arrive.</p> <p></p>"},{"location":"modules/Wetdryfix-Conservelevation/#wetdryfix","title":"Wetdryfix","text":"<p>When using the wetdryfix the instabilities disappear and the solution is smoother.</p> <p></p>"},{"location":"modules/Wetdryfix-Conservelevation/#comparison-wetdryfix-vs-no-wetdryfix","title":"Comparison Wetdryfix vs no Wetdryfix","text":"<p>The instabilities are more obvious when we look at a transect diagonally from the plot above. These instabilities have a notable affect the height of the tsunami wave... a lot! This justifies that we should have the wetdryfix switched on by default.</p> <p></p>"},{"location":"modules/Wetdryfix-Conservelevation/#conserve-elevation_1","title":"Conserve Elevation","text":"<p>When running tsunami/storm surge simulation without rivers or rain then the conserve elevation should be switched on. This doesn't make a considerable impact on the tsunami wave (see transect above the red and blue line are indistinguishable) I'm not sure why the difference is so small but there is a difference. Below is the difference between the wetdryfix and conservelevation routine. it produces a difference of O(10-5).</p> <p></p>"},{"location":"tools/Compile-under-linux/","title":"Compile under linux","text":"<p>@page Compile-under-linux Compilation on Linux</p> <p>Make sure you have latest CUDA Toolkit, g++ and NetCDF libraries installed.</p> <pre><code>sudo apt-get install nvidia-cuda-dev\nsudo apt-get install g++\nsudo apt-get install libnetcdf-dev\n</code></pre> <p>Also make sure the GPU driver being used is the Nvidia driver!</p> <p>Do a quick comand line test to see if nvcc (CUDA compiler) is available from here. If not, You may need to modify the cuda path in the makefile (line 155) </p><pre><code>NVCC          := nvcc -ccbin $(HOST_COMPILER)\n</code></pre> <p>The code can compile for multiple GPU architecture but later compiler do not support old GPU (2.0 is no longer supported) Remove unsupported architecture in line 213 of the makefile</p> <p>Then just type  <code>{.bash}  make</code></p> <p>Many warning will show up but that is OK.</p>"},{"location":"tools/Use-On-SuperComputer/","title":"Use On SuperComputer","text":"<p>@page Use-On-SuperComputer Use on SuperComputer</p> <p>The code can be run on local machines with NVIDIA GPU but it will get better performance by running on large GPU.</p> <p>The code is actually running on New Zealand eScience Infrastructure (NeSI).</p>"},{"location":"tools/Use-On-SuperComputer/#compiling-the-code","title":"Compiling the code","text":"<p>The Code needs to be compile on the machine, using the sources grom the github repository. Due to the code dependency to CUDA and netCDF, two modules need to be loaded: * On Maui:  <code>{bash}  module load CUDA\\11.4.1 module load netCDF-C++4/4.3.0-GCC-7.1.0</code> * On Mahuika:  <code>{bash} module load CUDA/11.4.1 module load netCDF-C++4/4.3.1-gimpi-2020a</code></p>"},{"location":"tools/Use-On-SuperComputer/#running-the-code","title":"Running the code","text":"<ul> <li> <p>Example of a slurm file on Maui: </p><pre><code>#!/bin/bash\n#SBATCH --job-name=MY-TEST-NAME\n#SBATCH --time=8:00:00\n#SBATCH --account=MY-NESI-ACCOUNT\n#SBATCH --partition=nesi_gpu\n#SBATCH --gres=gpu\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=2\n#SBATCH --mem=5GB\n\n#Running directory (to be completed)\nBGFLOOD=/nesi/project/XXXXXXXXXXXXXXX\n\ncd ${BGFLOOD}\n\nmodule load CUDA/11.4.1\nmodule load netCDF-C++4/4.3.0-GCC-7.1.0\n\n# Launching the executable\nsrun ./BG_Flood_Maui\n\necho \"output_file = Output/${testname}/BGoutput-${reftime}.nc\"\n\necho \"end of setup_run_BG.sh\"\n</code></pre> </li> <li> <p>Example of a slurm file on Mahuika: </p><pre><code>#!/bin/bash\n#SBATCH --job-name=MY-TEST-NAME\n#SBATCH --time=05:00:00\n#SBATCH --account=MY-NESI-ACCOUNT\n#SBATCH --gpus-per-node=1\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=1\n#SBATCH --mem=1GB\n\n#Running directory (to be completed)\nBGFLOOD=/nesi/project/XXXXXXXXXXXXXXX\n\ncd ${BGFLOOD}\n\n#module load netCDF-C++4/4.3.0-gimkl-2017a\nmodule load netCDF-C++4/4.3.1-gimpi-2020a\nmodule load CUDA/11.4.1\n\n# Launching the executable\nsrun ./BG_Flood_Mahuika\n\necho \"output_file = Output/${testname}/BGoutput-${reftime}.nc\"\n\necho \"end of setup_run_BG.sh\"\n</code></pre> </li> </ul>"},{"location":"tutorial/Gaussian_Wave_Julia/","title":"Gaussian wave","text":""},{"location":"tutorial/Gaussian_Wave_Julia/#gaussian-wave","title":"Gaussian Wave","text":"<p>This is a great example to test whether there are bugs in the model and how the boundary work.</p>"},{"location":"tutorial/Gaussian_Wave_Julia/#bathymetry","title":"Bathymetry","text":"<p>We start with a flat bathymetry with 0.0 everywhere. You still need a file for that!</p> <p>Here a couple of suggestion on making the file:</p> <ul> <li>Using GMT: <pre><code>grdmath -R-5/5/-5/5 -I0.03921 0 MUL = bathy.nc\n</code></pre></li> </ul> <p>Using Julia: See section below with the hotstart file.</p> <p>In any case you can pick up the file in the example folder.</p>"},{"location":"tutorial/Gaussian_Wave_Julia/#hortstart","title":"Hortstart","text":"<p>We want to setup a bump in the water level centered in the middle of the bathy. IN the example below this is done using Julia, but it should be easily done in Matlab or Python. Note that the script below also generates a bathymetry file.</p> <pre><code>    using GMT\n\n    xo=-5;\n    yo=-5;\n\n    nx=16*16;\n    ny=16*16;\n\n    len=10.0;\n\n    dx=len/(nx-1);\n\n    xx=collect(xo:len/(nx-1):(len+xo));\n    yy=collect(yo:len/(ny-1):(len+yo));\n\n    # Make a bathy file\n    zb=zeros(nx,ny);\n    G = mat2grid(transpose(zb), 1,[xx[1] xx[end] yy[1] yy[end] minimum(zb) maximum(zb) 1 dx dx])\n    gmtwrite(\"bathy.asc\", G; id=\"ef\");\n\n    #make the hotstart file\n    hh=zeros(nx,ny);\n    for i=1:nx\n        for j=1:ny\n            hh[i,j] = 1.0.+ 1.0.*exp.(-1.0*(xx[i].*xx[i] .+ yy[j].*yy[j]));\n            #hh[i,j] =\n        end\n    end\n\n    G = mat2grid(transpose(hh), 1,[xx[1] xx[end] yy[1] yy[end] minimum(hh) maximum(hh) 1 dx dx])\n    cmap = grd2cpt(G);      # Compute a colormap with the grid's data range\n    grdimage(G, lw=:thinnest, color=cmap, fmt=:png, show=true)\n\n    gmtwrite(\"gauss.asc\", G; id=\"ef\");\n    gmtwrite(\"gauss.nc\", G);\n    # GMT netcdf variable is \"z\" by default but the hotstart file needs \"zs\" for water surface\n    gmt(\"grdmath gauss.nc 1.0 MUL = gauss_zs.nc?zs\");\n</code></pre>"},{"location":"tutorial/Gaussian_Wave_Julia/#make-bnd-files","title":"Make Bnd files","text":"<p>We are going to set the water level to 0.0m on all 4 sides and keep it constant. To do that we create 1 files <code>zero.txt</code>: </p><pre><code>    # This is the a boundary\n    0.0 0.0\n    3600.0 0.0\n</code></pre>"},{"location":"tutorial/Gaussian_Wave_Julia/#set-up-the-bg_paramtxt-file","title":"Set up the <code>BG_param.txt</code> file","text":"<p>First it is good practice to document your parameter file: </p>BG_param.txt<pre><code>    ##############################\n    ## Gaussian bump demo\n    # CB 04/05/2019\n</code></pre> Then specify the bathymetry file to use. We will use the entire domain and resolution of the file so no need for other parameter for specifying the domain. <pre><code>    bathy=bathy.asc\n</code></pre> This is a relatively small model so we can force the netcdf variable to be saved as floats. <pre><code>    smallnc=0\n</code></pre> Specify the hotstart file: <pre><code>    hotstartfile=gauss_zs.nc;\n</code></pre> Boundary conditions are all the same : <pre><code>    right = 3; # Absorbing bnd\n    rightbndfile = zeros.txt\n\n    top = 3; # Absorbing bnd\n    topbndfile = zeros.txt\n\n    bot = 3; # Absorbing bnd\n    botbndfile = zeros.txt\n\n    left=3; # Absorbing bnd\n    leftbndfile=zeros.txt\n</code></pre> Time keeping: <pre><code>    endtime=20;\n    outtimestep=1;\n</code></pre> Output parameters: <pre><code>    # Netcdf file for snapshot of the model domain\n    outfile=Gauss_demo.nc\n    outvars=zb,uu,vv,zs,vort;\n\n    # Outpout a single txt file with all the model steps at the nearest node to location x=0.0, y=-4.0\n    # This file will contain 5 column: time,zs,hh,uu,vv\n    TSOfile=Southside.txt;\n    TSnode=0.0,-4.0;\n</code></pre>"},{"location":"tutorial/Gaussian_Wave_Julia/#run-the-model","title":"Run the model","text":"<p>Plot Southside.txt in your favorite tool.</p>"},{"location":"tutorial/Gaussian_Wave_Julia/#things-to-try","title":"Things to try","text":"<ul> <li>What happens with different boundary types</li> <li>Try running with double precision. What is the difference?</li> </ul>"},{"location":"tutorial/Transpacific_tsunami/","title":"Transpacific tsunami","text":""},{"location":"tutorial/Transpacific_tsunami/#transpacific-tsunami","title":"Transpacific tsunami","text":"<p>This tutorial is the next stat from the Gaussian wave. Here we produce a realistic tsunami and let it propagate across the Pacific.</p>"},{"location":"tutorial/Transpacific_tsunami/#bathy-and-domain-definition","title":"Bathy and domain definition","text":"<p>The bathymetry file we are using was extracted from the GEBCO gobal bathymetry using GMT command grdcut / grdsample. This section needs a tutorial of its own. Here in the <code>BG_param.txt</code> we specify the file name and that it is a spherical model domain. </p>BG_param.txt<pre><code>    # Bathymetry file\n    bathy = Tpac_big.asc;\n    spherical = 1;\n</code></pre> The file covers a bigger area than we want to use for the simulation so we restict the domain: <pre><code>    ymin=-78.0\n    ymax=14.32\n\n    dx=0.08;\n</code></pre> Also we do not want to simulate Blocks that are entirely covered in land where the elevation is bigger than say 30.0m above the datum <pre><code>    mask = 30.0;\n</code></pre>"},{"location":"tutorial/Transpacific_tsunami/#initial-tsunami-wave","title":"Initial tsunami wave","text":"<p>See matlab file in the folder or simply use: </p><pre><code>    hotstartfile=Maule_zs_init_simpleflt.nc;\n</code></pre>"},{"location":"tutorial/Transpacific_tsunami/#boundary","title":"Boundary","text":"<p>In the previous tutorial you have seen how different boundary type let's wave through with minimal reflection. You choose.</p>"},{"location":"tutorial/Transpacific_tsunami/#time-keeping","title":"Time Keeping","text":"<pre><code>    totaltime = 0.000000; # Start time\n    endtime = 54000.000000;\n    outputtimestep = 600.000000;\n</code></pre>"},{"location":"tutorial/Transpacific_tsunami/#outputs","title":"Outputs","text":"<pre><code>    outvars = hh,zs,zsmax;\n    # Files\n    outfile = Output_simple_fault.nc;\n    smallnc = 0; #if smallnc==1 all Output are scaled and saved as a short int\n\n    TSnode = -86.374,-17.984\n    TSOfile = SW_Lima.txt\n</code></pre>"},{"location":"tutorial/Transpacific_tsunami/#things-to-try","title":"Things to try","text":"<ul> <li>Try changing the model domain and resolution. What happens if part of the domain is outside of the area covered by the bathymetry?</li> <li>Try outputing a time series near Christchurch</li> </ul>"},{"location":"tutorial/TutorialJetJulia/","title":"Jet and Julia","text":""},{"location":"tutorial/TutorialJetJulia/#jet-tutorial-with-julia","title":"Jet tutorial with Julia","text":"<p>This is a very simple example that shows the model stability in transitional flows.</p>"},{"location":"tutorial/TutorialJetJulia/#make-a-bathymetry","title":"Make a bathymetry","text":"<p>Below is a Julia script to make the bathymetry. </p><pre><code>    using GMT\n\n    ny=16*16;\n    nx=16*32;\n\n    dx=5.0;\n\n    xmin=0;\n    xmax=nx*dx;\n\n    ymin=0;\n    ymax=ny*dx;\n\n    Bathy=zeros(nx,ny);\n\n    Bathy.=-5.0;\n\n    Bathy[170:172,:].=5.0;\n    Bathy[170:172,127:129].=-5.0;\n\n    Bathy[:,1:2].=5.0;\n    Bathy[:,(end-1):end].=5.0;\n\n    G = mat2grid(transpose(Bathy), 1,[xmin xmax ymin ymax -5.0 5.0 1 dx dx])\n    cmap = grd2cpt(G);      # Compute a colormap with the grid's data range\n    grdimage(G, lw=:thinnest, color=cmap, fmt=:png, show=true)\n\n    gmtwrite(\"bathy.asc\", G; id=\"ef\");\n</code></pre> <p>The result is a grid domain looking like this:  You can also use the bathy.asc file in the example folder.</p>"},{"location":"tutorial/TutorialJetJulia/#make-bnd-files","title":"Make Bnd files","text":"<p>We are going to set the water level to 0.0m on the right and 1.0 on the left and keep it constant. To do that we create 2 files <code>right.txt</code> and <code>left.bnd</code></p> right.bnd<pre><code># This is the right boundary\n0.0 0.0\n3600.0 0.0\n</code></pre> left.bnd<pre><code># This is the left boundary\n0.0 1.0\n3600.0 1.0\n</code></pre>"},{"location":"tutorial/TutorialJetJulia/#set-up-the-bg_paramtxt-file","title":"Set up the <code>BG_param.txt</code> file","text":"<p>First it is good practice to document your parameter file:</p> <p></p>BG_param.txt<pre><code>    ##############################\n    ## Jet demo\n    # CB 04/05/2019\n</code></pre> Then specify the bathymetry file to use. We will use the entire domain and resolution of the file so no need for other parameter for specifying the domain. <pre><code>    bathy=bathy.asc\n</code></pre> Specify the parameter theta to control the numerical diffusion of the model. but first let's leave it to the default. <pre><code>    theta=1.3;\n</code></pre> This is a relatively small model so we can force the netcdf variable to be saved as floats. <pre><code>    smallnc=0\n</code></pre> Sepcify the model duration, output timestep and output file name and variables <pre><code>    endtime=1800\n    outtimestep=10\n    outfile=Jet_demo.nc\n    outvars=zb,uu,vv,zs,vort;\n</code></pre> Specify absorbing boundaries for left and right (There is a wal at the top and bottom so no need to specify any boundary there). <pre><code>    right = 3; # Absorbing bnd\n    rightbndfile = right.bnd\n\n    left=3; # Absorbing bnd\n    leftbndfile = left.txt\n</code></pre>"},{"location":"tutorial/TutorialJetJulia/#run-the-model","title":"Run the model","text":"<p>If you are on windows simply double-click on the executable and on linux launch the binary.</p> <p>Vorticity output (<code>vort</code> variable) should look like this:</p> <p></p>"},{"location":"tutorial/TutorialJetJulia/#things-to-try","title":"Things to try","text":"<ul> <li>What happens when using a different value for theta (1-2.0)</li> <li>What happens when specifying a different type of boundary on the right </li> <li>What happens when you bring the boundary close to the jet</li> <li>Why is the jet so unstable/asymmetrical? (what are the initial condition like?)</li> </ul>"},{"location":"tutorial/TutorialMonaiJulia/","title":"Monai and Julia","text":"<p>Monai tutorial with Julia</p> <p>This is a tutorial realised for BG_Flood on Julia.</p>"},{"location":"tutorial/TutorialMonaiJulia/#goals","title":"Goals","text":"<ul> <li>Check Boundary forcing</li> <li>Check wave propagation and runup on complex topography against experimental data</li> </ul>"},{"location":"tutorial/TutorialMonaiJulia/#status","title":"Status","text":"<p>Success</p>"},{"location":"tutorial/TutorialMonaiJulia/#settings","title":"Settings","text":""},{"location":"tutorial/TutorialMonaiJulia/#results","title":"Results","text":"<p>Model behaves similar to other codes and ca reproduce the bulk of the tsunami waves. Results are comparable to the same class of models. The double precision simulation is virtually identical to the Double precision run confirming that in this case there is not much point on using the Double precision.</p> <p>skill assessment: Single precision</p> ------------- RMS error (m) Will-corr BSS Gauge 1 0.003391 0.978040 0.910979 Gauge 2 0.003735 0.965899 0.870943 Gauge 3 0.003284 0.976699 0.884080 <p>Double precision</p> ------------- RMS error (m) Will-corr BSS Gauge 1 0.003391 0.978039 0.910981 Gauge 2 0.003733 0.965948 0.871093 Gauge 3 0.003283 0.976704 0.884097 <p> Figure 1. Measured and simulated timeseries for the Monai benchmark</p>"},{"location":"tutorial/TutorialMonaiJulia/#run-times","title":"Run times","text":"GPU Quadro K620 GeForce GTS 450 other GPU Single Precision (s) 27 20 XX Double Precision (s) XX 34 XX"},{"location":"tutorial/TutorialRiver/","title":"Coastal fluvial flooding","text":""},{"location":"tutorial/TutorialRiver/#river-flooding-tutorial","title":"River flooding tutorial","text":"<p>The objectif of this tutorial is to explain how to use the code BG_Flood to model river flooding. As the code allows rain on grid, we will look at pluvial and fluvial flooding.</p> <p>This testcase aims to broadly reproduce the flooding event that occured from the 16 to the 18 of July 2021 (a 1 in 50 year flood event).  During this event, the Buller river, passing through the town of Westport, on the West Coast of the South Island of Aotearoa New Zealand, get out of its primary bed and flooded the Westport area.</p> <p>Prerequisite</p> <p>Before begining this tutoral, the user is expected to have downloaded the windows executable (last release on github) or compiled the sources (version &gt; 0.8) of the BG_flood code on linux.</p> <p>During this tutorial, we will build, step by step, a test case</p>"},{"location":"tutorial/TutorialRiver/#param-file","title":"Param file","text":"<p>The interface with BG_flood software is done using only a text file: <code>BG_param.txt</code> (This is the name of the input parameter file by defauls, an other name can be use as first variable when lauching BG_Flood.)</p> <p>This file consists in a list of key words and inputs, separated by a \"=\" sign.  For a full list of the available key words and a further description of this file, please refer to the [parameter list]{../ParametersList-py.md} and the [manual]{../Manual.md}.</p>"},{"location":"tutorial/TutorialRiver/#preparation-of-the-topographybathymetry-dem-digital-elevation-model","title":"Preparation of the topography/bathymetry (DEM: Digital Elevation Model)","text":"<p>The DEM, topography or bathymetry file is the only necessary file to be added to BG_param file to run the model. </p><pre><code>DEM = Wesport_DEM_8m.nc?z;\n</code></pre> <p></p> <p>Note</p> <p>Different formats can be used for this file ( ASCII: .asc or NetCDF .nc principally). As Netcdf files can contain different variables, the \"?\" follows by the name of the variable is needed.</p> <p>Without further information, the code will run will default values for physical parameters and initialisation, Neumann boundaries and no external forcing:</p> <p></p> <p>A result files: <code>output.nc</code> is created (here opened with the [PyNcView]{https://pyncview.software.informer.com/}) </p> <p></p> <p>It contains 2D spatial fields saved regularly in time. It details the blocs information:</p> <ul> <li><code>blockid</code>: block index</li> <li><code>blocklevel</code>: level of refinement for each block</li> <li><code>blockstatus</code>: Is the block active ?</li> <li><code>blockwidth</code>: number of cells in x or y direction in the block (not considering halo cells for computational purpose only)</li> <li><code>blockxo</code>/<code>blockyo</code>: coordinate of the bottom left corner of he block</li> </ul> <p>the time 1D variables or coordinates:</p> <ul> <li><code>time</code>: time vector in second or real time</li> <li><code>xx</code>/<code>yy</code> axis: spacial coordinate in m (by default)</li> </ul> <p>and the by default outputs:</p> <ul> <li><code>h</code> : the water depth in m</li> <li><code>u</code> : the veloctity vector component in the x direction</li> <li><code>v</code>: the velocity vector component in the y direction</li> <li><code>zb</code>: the bottom/ground elevation (m from vertical projection reference)</li> <li><code>zs</code>: the surface water elevation (m from vertical projection reference)</li> </ul> <p>(see manual for further description of the variables).</p> <p>Note</p> <p>In BG_Flood, the memory is organised in blocked for an optimal parallelisation on GPU. All the cells on a block will share some status and parameter such as the level of refinement (or cell size) and the active status.</p> <p>A log file: <code>BG_log.txt</code> (very similaire to the shell outputs) is also created to keep the terminal output information:</p> <p></p>"},{"location":"tutorial/TutorialRiver/#basic-fluvial-flooding-set-up","title":"Basic fluvial flooding set-up","text":""},{"location":"tutorial/TutorialRiver/#river-discharge","title":"River discharge","text":"<p>The river are (at this stage) forced by a vertical discharge on a user defined rectagular area: </p><pre><code>river = river_discharge_TeKuha2.txt,1490249,1490427,5367640,5367805;\n</code></pre> where the four final numbers are: \\(x_1\\), \\(x_2\\), \\(y_1\\), \\(y_2\\), to define the area for the vertical discharge and a text file containing the time-serie of the discharge (first column: time (\\(s\\)) from reference time, second column: river discharge in \\(m^3s^{-1}\\)). <p></p> <p>This file has been generated from an observed hydrograph, with data saved every \\(5\\)min, in second from the begining of the simulation (or event):</p> <p></p> <p>For each new river, just add the a similar river input line in the parameter file.</p>"},{"location":"tutorial/TutorialRiver/#timekeeping-parameters","title":"Timekeeping parameters","text":"<p>In this code, the time is defined in second, relative to some reference or the start of the simulation by default.</p> <p>The end of the simulation is prescribed in second as : </p><pre><code>endtime = 21600;\n</code></pre> <p>The time steps can't be defined by the used, it will be automatically computed as the more restrictive one in the domain by the solver, using the prescribe CFL (Current Friedrich Limiter) value, \\(CFL=0.5000\\) by default.</p> <p>The simulation begin, by default at \\(t=0(s)\\), but this can modify using \"totaltime\":  </p><pre><code>totaltime = 3600;\n</code></pre> to begin one hour after the reference time (used in the forcings for example).  <p>Note</p> <p>The code was initially designed to consider time only through duration in second. We can now use dates to defined time in the forcings and the param file, including a time reference. </p>"},{"location":"tutorial/TutorialRiver/#outputs","title":"Outputs","text":"<p>There is two types of outputs:</p> <ul> <li>map outputs of 2D variables regularly through time</li> <li>time-serie (TS) output of basic values, at a chosen point position, at each time step.</li> </ul>"},{"location":"tutorial/TutorialRiver/#map-outputs","title":"Map outputs","text":"<p>By default, there is only a map output at the begining and end of the simulation.</p> <p>The map output can be modify by:</p> <ul> <li>defining a timestep (in s) for these outputs: <pre><code>outputtimestep = 3600.0;\n</code></pre></li> <li>changing the set of variables in the output file (from the list given in the manual) <pre><code>outvars = zs,h,u,v,zb,hmax,Umax,hUmax,twet;\n</code></pre> The \"max\" variables will be the maximum value during the whole simulation. To reset it between the outputs, see the resetmax variable. There is also special variables for risk assesment after inundation (Umax, hmax, hUmax, twet)</li> <li>changing the name of the output file: <pre><code>outfile = Results_tuto_basicRun.nc;\n</code></pre></li> <li>saving the output as float (variables are saved as short integer by default.): <pre><code>smallnc = 0;\n</code></pre></li> </ul>"},{"location":"tutorial/TutorialRiver/#time-serie-outputs","title":"Time-Serie outputs","text":"<p>For each TS output needed, a line with the destination file and the postition is needed:</p> <p></p><pre><code>TSnodesout=Offshore.txt,1482120,53814890;\n</code></pre> corresponding to <code>TSnodesout=filename.txt,x_p,y_p;</code> The file contains 5 colums \\((t, zs, h, u,v)\\) with the value at the nearest grid point (to the position defined by the user)."},{"location":"tutorial/TutorialRiver/#resolution","title":"Resolution","text":"<p>For a first test, we will modify the resolution and set it to 40m to decrease the computational time: </p><pre><code>dx=40;\n</code></pre>"},{"location":"tutorial/TutorialRiver/#basic-fluvial-innundation-results","title":"Basic fluvial innundation results","text":"<p>This the shell output:  It shows that 1 river has been added to the model, and also the time progression with 5 map outputs (in addition to the initial time step).</p> <p>In the outputs, we get the different fields requested, for 6 different times. </p> <p>The Time-Serie output is: </p>"},{"location":"tutorial/TutorialRiver/#completing-the-set-up","title":"Completing the set-up","text":""},{"location":"tutorial/TutorialRiver/#adding-boundary-conditions","title":"Adding boundary conditions","text":"<p>Boundaries' conditions are refered by their position, using 'top/bottom/right/left' keywords. They are associated to a boundary type ( 0:wall; 1: Neumann (Default); 2:Dirichlet (zs); 3: abs1d) and possibly a file containing a time serie. In this case, the file name is placed before the type, coma-separated. </p> <p>In this case, we will use tide boundaries at when at least a part of the boundary is open on the sea, i.e. for the top, left and right boundaries. At the bottom, we will conserve the default value: 1. </p><pre><code>left = tide_westport.txt,2; \nright = tide_westport.txt,2; \ntop = tide_westport.txt,2; \n</code></pre> <p>In this case, as the boundaries are relatively small compared to the time wave length, we will used the same value along all the boundaries. We will then have only two columns in the file: Time and one elevation. tide_file ``` txt \"tide_westport.txt\" 0.000000    0.714714  600.000000  0.794714  1200.000000     0.864714  1800.000000     0.934714  2400.000000     0.994714  3000.000000     1.054714  3600.000000     1.104714  4200.000000     1.144714  4800.000000     1.174714  5400.000000     1.194714  6000.000000     1.214714  6600.000000     1.214714  7200.000000     1.214714  7800.000000     1.204714  8400.000000     1.184714            ... 336600.000000   -0.635286  337200.000000   -0.705286  337800.000000   -0.765286  338400.000000   -0.825286  339000.000000   -0.875286  339600.000000   -0.915286  340200.000000   -0.955286 </p> <pre><code>They correspond to a classic time Serie observed offshore of the river mouth.\n\n![Tide](../figure/tide_westport.png)\n\n!!! note \n    If more values are added to the file (more columns), they will be regularly spread along the boundary and the forcing will be linearly interpolated between these values. \n\n\n## Bottom friction\nDifferent models from bottom friction are available.\nBy default, the model used is -1 corresponding to a Manning model.\nHere, we will use the model 1 corresponding to a roughness length (see manual for more information on the Bottom friction models).\nThe associated field (ASC or netCDF) or value must be enter with the key word\n``` txt\nfrictionmodel=1;\ncf=z0_100423_rec3.asc; #cf=0.01;  #If using a uniform value\n</code></pre> <p></p> <p>Warning</p> <p>The model allows a roughness heigh or manning number map smaller than the computational domain and will extrapolate outside of the map.</p>"},{"location":"tutorial/TutorialRiver/#initialisation","title":"Initialisation","text":"<p>By default, the model is initialised by a plane water surface located at \\(z=0.0\\).</p> <p>This water level can be modify, depending of the local mean sea level and the vertical projection used to create the DEM, using: </p><pre><code>zsinit=-1.39; #in metre\n</code></pre> The model can also be initialised using a restart/hot start. A file containing a least the files zb, h or zs, u and v must be provided, with the steps (and no the time value) to use for the restart. <pre><code>hotstartfile = output_4.nc;\nhotstep=5;\n</code></pre> <p>Warning</p> <p>the code can be restarted only from an uniform grid (and not from results with multi-level of resolutions).</p>"},{"location":"tutorial/TutorialRiver/#model-controls","title":"Model controls","text":"<p>Some variables can be used to adjust the model (see Manual for more details):</p> <ul> <li>run on CPU (or choose a GPU to run on): <pre><code>gpudevice=0;\n</code></pre> By default, the code will detect if there is a suitable GPU on the machine.</li> <li>Double precision instead of a float precision during the computation: <pre><code>doubleprecision = 1;\n</code></pre></li> <li>Minmod limiter parameter (to tune momentum dissipation \\(\\in [1,2]\\)) <pre><code>theta=1.3; #default value=1.3\n</code></pre></li> <li>Minimum heigh to concidere a cell wet (m) <pre><code>eps = 0.00010000; #default=0.0001\n</code></pre></li> </ul>"},{"location":"tutorial/TutorialRiver/#adding-the-rain","title":"... Adding the rain","text":"<p>The model allows rain on grid forcing to model pluvial inundations.</p>"},{"location":"tutorial/TutorialRiver/#rain-forcing","title":"Rain forcing","text":"<p>A rain intensity in \\(mm.h^{-1}\\), time and space varying can be forced in the model.</p> <p>The rain can be forced with a time serie (with uniform values on the domain) or a netCDF file if a spacial file is available:</p> <ul> <li>Time serie forcing: <pre><code>rainfall=rain_westport.txt\n</code></pre></li> <li>Spacial file forcing: <pre><code>rainfile=VCSN_buller_202107_dailynzcsmcov_disaggdaily_500m_nztm_clipped.nc?depth;\n</code></pre> Here, we will use a time serie: </li> </ul> <p>If the data is given in \"rain height\", a post-processing to turn it in rain intensity will be needed (at least at this stage of development).</p> <p>Using the rain on grid forcing will activate all the cells of the domain and will increase the computational time of the simulation.  Part of the domain can be \"de-activate\" (the blocs memory will not be allocated for this area) using different methods:</p> <ul> <li>using the <code>x0</code> / <code>xmax</code> / <code>y0</code> / <code>ymax</code> keywords to restrain the extend of the computational domain (but still rectangular) <pre><code>x0=1475000; #m\n</code></pre></li> <li>a manual mask with values 999 in the bathymetry will be read by the code as \"non-active\" area</li> <li>masking all the bloc with all cells having an elevation superior to some value: <pre><code>mask=250; #m\n</code></pre></li> <li>using a shape file to define a \"area of interest\": <pre><code>AOI=Domain_buffered-sea2.gmt;\n</code></pre></li> </ul> <p>Method advised</p> <p>The last method, consisting in using a contour to identify the area we want to include, is advised as the method allows for example to select a catchment, or any complex contour shape. The expected shape is a *.gmt file that can be generated from a contour using GMT tools or directly as a column of x,y points looped (first point = last point).</p>"},{"location":"tutorial/TutorialRiver/#refining-the-grid-in-area-of-interest","title":"Refining the grid in area of interest","text":"<p>The code is based on a Block-uniform quadtree mesh. Each block, actually a 16 by 16 cells, is one unit of computation in the GPU. These blocks can have different resolutions (but resolution does not change during the computation at this stage).</p> <p>The initial resolution of the grid is the resolution of the bathymetry/topographic data. To refine or coarsen the grid, you can weather use the \"dx\" key word and choose a new resolution for the whole domain; wether use the levels of resolution. The reference level, correponding to the bathymetry resolution will be the level 0. Levels of resolution are then defined in relation to the reference levels using positive integers to increase the resolution or refine and negative integer to coarsen the grid by a multiple of two. For a given level  \\(n\\) , the resolution  \\(dx_n\\) will be: $$ dx_n=\\frac{dx_0}{2^n} $$</p> <p>with  \\(dx_0\\) the resolution at level 0. </p> <p>When refinning using the level implementation, different key words are expected:</p> <ul> <li><code>Initlevel</code>: level used to create the first mesh created by the code in the mesh refinement process</li> <li><code>Maxlevel</code>: maximim level of refinement (over-ruling other commands)</li> <li><code>Minlevel</code>: minimum level of refinement (over-ruling other commands)</li> </ul> <p>The grid can also be unregular with an adaptition of the grid to the model (variables at initialisation step or user-defined refinement map). In this case, the cells will be devided in 4 cells for refinement, or 4 cells merged in one for coarsening. The code will ensure a progressive change of resolution (no cell should have a neighbour with more than 1 level of resolution of difference.)</p> <p>The different methods of refinement available in the code are called using the key word \"Adaptation\". The refinement can be based on a classical input variable or a variable calculated during the initialisation:</p> <ul> <li><code>Threshold</code>: impose a threshold for a different level of resolution</li> <li><code>Inrange</code>: impose a range for a different level of resolutuion or it can be defined using a map of target levels for refinement:</li> <li><code>Targetlevel</code>: the levels of resolution will be targeted but will be overruled by the maxlevel, minlevel entrance.</li> </ul> <p>To refine the grid for this case, we will use the former coarse simulation and create a map for values where hmax is strictly positive (and/or \\(umax\\),\\(vmax\\) different from zero), after removing the sea area. </p> <p>Here, the bathymetry map resolution is a 10m resolution (\\(dx=10m\\)). We will impose:</p> <ul> <li>a level -3 resolution ( \\(dx_{-3}=80m\\)) in the background domain, </li> <li>a level 1 resolution ( \\(dx_1=5m\\)) in the flooded area</li> <li>a level 2 resolution ( \\(dx_2=2.5m\\))  in the main river bed area. </li> </ul> Maximum water depth obtained using a coarse uniform mesh, used to inform refinement. Refinement map obtained based on coarse model, used to enforce refinement. Mesh refinement generated by the code. <p>To use it, the following options need to be added to the param file: </p><pre><code>initlevel = -3 ;\nmaxlevel = 2 ;\nminlevel = -3 ;\nAdaptation = Targetlevel,refin_mask.nc?z ;\n</code></pre> <p>Note</p> <p>In order to optimise the results when using a refined grid, different bathymetry files can be provided. A higher resolution one with smaller extend can be provided as a second DEM and will be use by the code when refining the grid (the code will use the last entered, having the info available):  </p><pre><code>DEM = Wesport_DEM_8m.nc?z;\nDEM = Wesport_DEM_2m_zoomed.nc?z;\n</code></pre>  Similarly, different input files can be used for the roughness coefficient.  <p>Note again ...</p> <p>The code also allows for zone outputs: the output of different zones defined by the user (<code>output-file-name,x1,x2,y1,y2</code>):  </p><pre><code>outzone=zoomed.nc,5.3,5.4,0.5,0.8;\n</code></pre>"},{"location":"tutorial/TutorialRiver/#results","title":"Results:","text":"<p>This is the logfile: </p>BG_log.txt<pre><code>#################################\nBG_Flood v0.8\n#################################\n#################################\n#\nmodel started at 21-02-2023 21:22:53\n\nReading parameter file: BG_param.txt ...\n\nReading bathymetry grid data...\nReading forcing metadata. file: Westport_DEM_8m.nc extension: nc\nForcing grid info: nx=2604 ny=3137 dx=8.000000 grdalpha=0.000000 xo=1474101.125000 xmax=1494925.125000 yo=5364343.000000 ymax=5389431.000000\n\nReading boundary data...\n\nRead Roughness map (cf) data...\nReading forcing metadata. file: z0_100423_rec3.asc extension: asc\nFor asc of bathy file please specify grdalpha in the BG_param.txt (default 0)\nForcing grid info: nx=1724 ny=2420 dx=4.800000 grdalpha=0.000000 xo=1480847.600000 xmax=1489118.000000 yo=5369291.600000 ymax=5380902.800000\n\nRead Target level data...\nReading forcing metadata. file: refin_mask.nc extension: nc\nForcing grid info: nx=624 ny=400 dx=50.000000 grdalpha=0.000000 xo=1469074.407363 xmax=1500224.407363 yo=5364597.770576 ymax=5384547.770576\n\nPreparing rivers (1 rivers)\n\nPreparing Rain forcing\n\nAdjusted model domain (xo/xmax/yo/ymax): \n    1474097.125000/1495057.125000/5364339.000000/5389459.000000\n     Initial resolution (level 2) = 10.000000\nThere are 1 GPU devices on this machine\nUsing Device: NVIDIA T500\n\nInitializing mesh\n    Initial number of blocks: 20567; Will be allocating 21596 in memory.\n\nInitial condition:\n    Warm start\n    Initializing rivers\nAdapting mesh\n     Iteration 1\n        There are 20567 active blocks (21596 blocks allocated in memory), 0 blocks to be refined, 4723 blocks to be coarsen (with neighbour); 1675 blocks untouched; 14169 blocks to be freed (1029 are already available) 0 new blocks will be created\n     Iteration 2\n        There are 6398 active blocks (21596 blocks allocated in memory), 0 blocks to be refined, 1023 blocks to be coarsen (with neighbour); 2306 blocks untouched; 3069 blocks to be freed (15198 are already available) 0 new blocks will be created\n     Iteration 3\n        There are 3329 active blocks (21596 blocks allocated in memory), 0 blocks to be refined, 179 blocks to be coarsen (with neighbour); 2613 blocks untouched; 537 blocks to be freed (18267 are already available) 0 new blocks will be created\n     Iteration 4\n        There are 2792 active blocks (21596 blocks allocated in memory), 0 blocks to be refined, 18 blocks to be coarsen (with neighbour); 2720 blocks untouched; 54 blocks to be freed (18804 are already available) 0 new blocks will be created\n     Iteration 5\n        There are 2738 active blocks (21596 blocks allocated in memory), 0 blocks to be refined, 1 blocks to be coarsen (with neighbour); 2734 blocks untouched; 3 blocks to be freed (18858 are already available) 0 new blocks will be created\n     Iteration 6\n        There are 2735 active blocks (21596 blocks allocated in memory), 0 blocks to be refined, 0 blocks to be coarsen (with neighbour); 2735 blocks untouched; 0 blocks to be freed (18861 are already available) 0 new blocks will be created\n\nInitial condition:\n    Warm start\n    Initializing rivers\nSetting up GPU\n\nModel setup complete\n#################################\nInitialising model main loop\nCreate netCDF output file...\nWarning! Output file name already exist   \nNew file name: Results_tuto_basicRun_2.nc\n        Completed\nModel Running...\nOutput to map. Totaltime = 7200.000000 s; Mean dt = 2.230207e-01 s\n</code></pre> In the model output, each resolution is store independently.  When open with pyncview, we can visualise each layer. QGIS can merge all these layer togather or a postratement steps will be needed. <p></p>"},{"location":"tutorial/TutorialRiver/#ground-infiltration-losses-basic-ilcl-model","title":"Ground infiltration losses (Basic ILCL model)","text":"<p>An Initial Loss, Continuous Loss model has been implemented in the code (see ILCL page).  </p> <p>To use it, provide maps for the two coefficient as follow:  <code>txt initialloss=InitialLoss.asc; continuousloss=ContinuousLoss.asc;</code> </p>"},{"location":"tutorial/TutorialRiver/#_1","title":"Coastal fluvial flooding","text":""},{"location":"BGFlood/annotated/","title":"List","text":""},{"location":"BGFlood/annotated/#class-list","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class AOIinfo </li> <li>struct AdaptP </li> <li>struct AdvanceP </li> <li>struct BlockP </li> <li>struct BndblockP </li> <li>struct DynForcingP </li> <li>struct EvolvingMLP </li> <li>struct EvolvingP </li> <li>struct EvolvingP_M </li> <li>class Flowin </li> <li>struct FluxMLP </li> <li>struct FluxP </li> <li>struct Forcing </li> <li>struct GradientsMLP </li> <li>struct GradientsP </li> <li>struct Loop </li> <li>class Mapparam </li> <li>struct Model </li> <li>class Param </li> <li>class Pointout </li> <li>class Polygon </li> <li>class River </li> <li>struct RiverBlk </li> <li>struct RiverInfo </li> <li>class SLTS </li> <li>struct SharedMemory </li> <li>struct SharedMemory&lt; double &gt; </li> <li>struct StaticForcingP </li> <li>class TSoutnode </li> <li>class T_output </li> <li>struct TexSetP </li> <li>struct TimeP </li> <li>class Vertex </li> <li>class Windin </li> <li>struct bndTexP </li> <li>class bndparam </li> <li>class bndsegment </li> <li>class bndsegmentside </li> <li>class deformmap </li> <li>class forcingmap </li> <li>class inputmap </li> <li>struct maskinfo </li> <li>struct outP </li> <li>struct outzoneB </li> <li>class outzoneP </li> <li>namespace utils </li> </ul>"},{"location":"BGFlood/files/","title":"Files","text":""},{"location":"BGFlood/files/#file-list","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir src <ul> <li>file AdaptCriteria.cu </li> <li>file AdaptCriteria.h </li> <li>file Adaptation.cu </li> <li>file Adaptation.h </li> <li>file Advection.cu </li> <li>file Advection.h </li> <li>file Arrays.h </li> <li>file BG_Flood.cu </li> <li>file BG_Flood.h </li> <li>file Boundary.cu </li> <li>file Boundary.h </li> <li>file ConserveElevation.cu </li> <li>file ConserveElevation.h </li> <li>file FlowCPU.cu </li> <li>file FlowCPU.h </li> <li>file FlowGPU.cu </li> <li>file FlowGPU.h </li> <li>file FlowMLGPU.cu </li> <li>file FlowMLGPU.h </li> <li>file Forcing.h </li> <li>file Friction.cu </li> <li>file Friction.h </li> <li>file General.h </li> <li>file Gradients.cu </li> <li>file Gradients.h </li> <li>file GridManip.cu </li> <li>file GridManip.h </li> <li>file Halo.cu </li> <li>file Halo.h </li> <li>file InitEvolv.cu </li> <li>file InitEvolv.h </li> <li>file InitialConditions.cu </li> <li>file InitialConditions.h </li> <li>file Input.h </li> <li>file Kurganov.cu </li> <li>file Kurganov.h </li> <li>file Mainloop.cu </li> <li>file Mainloop.h </li> <li>file Meanmax.cu </li> <li>file Meanmax.h </li> <li>file MemManagement.cu </li> <li>file MemManagement.h </li> <li>file Mesh.cu </li> <li>file Mesh.h </li> <li>file Multilayer.cu </li> <li>file Multilayer.h </li> <li>file Param.h </li> <li>file Poly.cu </li> <li>file Poly.h </li> <li>file ReadForcing.cu </li> <li>file ReadForcing.h </li> <li>file ReadInput.cu </li> <li>file ReadInput.h </li> <li>file Read_netcdf.cu </li> <li>file Read_netcdf.h </li> <li>file Reimann.cu </li> <li>file Reimann.h </li> <li>file Setup_GPU.cu </li> <li>file Setup_GPU.h </li> <li>file Spherical.cu </li> <li>file Spherical.h </li> <li>file Testing.cu </li> <li>file Testing.h </li> <li>file Updateforcing.cu </li> <li>file Updateforcing.h </li> <li>file Util_CPU.cu </li> <li>file Util_CPU.h </li> <li>file Write_netcdf.cu </li> <li>file Write_netcdf.h </li> <li>file Write_txtlog.cpp </li> <li>file Write_txtlog.h </li> <li>file utctime.cu </li> <li>file utctime.h </li> </ul> </li> </ul>"},{"location":"BGFlood/classAOIinfo/","title":"Class AOIinfo","text":""},{"location":"BGFlood/classAOIinfo/#class-aoiinfo","title":"Class AOIinfo","text":"<p>ClassList &gt; AOIinfo</p>"},{"location":"BGFlood/classAOIinfo/#public-attributes","title":"Public Attributes","text":"Type Name bool active   = <code>false</code> std::string file Polygon poly"},{"location":"BGFlood/classAOIinfo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classAOIinfo/#variable-active","title":"variable active","text":"<pre><code>bool AOIinfo::active;\n</code></pre>"},{"location":"BGFlood/classAOIinfo/#variable-file","title":"variable file","text":"<pre><code>std::string AOIinfo::file;\n</code></pre>"},{"location":"BGFlood/classAOIinfo/#variable-poly","title":"variable poly","text":"<pre><code>Polygon AOIinfo::poly;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/structAdaptP/","title":"Struct AdaptP","text":""},{"location":"BGFlood/structAdaptP/#struct-adaptp","title":"Struct AdaptP","text":"<p>ClassList &gt; AdaptP</p>"},{"location":"BGFlood/structAdaptP/#public-attributes","title":"Public Attributes","text":"Type Name int * availblk bool * coarsen int * csumblk int * invactive int * newlevel bool * refine"},{"location":"BGFlood/structAdaptP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structAdaptP/#variable-availblk","title":"variable availblk","text":"<pre><code>int* AdaptP::availblk;\n</code></pre>"},{"location":"BGFlood/structAdaptP/#variable-coarsen","title":"variable coarsen","text":"<pre><code>bool* AdaptP::coarsen;\n</code></pre>"},{"location":"BGFlood/structAdaptP/#variable-csumblk","title":"variable csumblk","text":"<pre><code>int * AdaptP::csumblk;\n</code></pre>"},{"location":"BGFlood/structAdaptP/#variable-invactive","title":"variable invactive","text":"<pre><code>int* AdaptP::invactive;\n</code></pre>"},{"location":"BGFlood/structAdaptP/#variable-newlevel","title":"variable newlevel","text":"<pre><code>int* AdaptP::newlevel;\n</code></pre>"},{"location":"BGFlood/structAdaptP/#variable-refine","title":"variable refine","text":"<pre><code>bool * AdaptP::refine;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/structAdvanceP/","title":"Struct AdvanceP","text":""},{"location":"BGFlood/structAdvanceP/#struct-advancep","title":"Struct AdvanceP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; AdvanceP</p>"},{"location":"BGFlood/structAdvanceP/#public-attributes","title":"Public Attributes","text":"Type Name T * dh T * dhu T * dhv"},{"location":"BGFlood/structAdvanceP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structAdvanceP/#variable-dh","title":"variable dh","text":"<pre><code>T* AdvanceP&lt; T &gt;::dh;\n</code></pre>"},{"location":"BGFlood/structAdvanceP/#variable-dhu","title":"variable dhu","text":"<pre><code>T* AdvanceP&lt; T &gt;::dhu;\n</code></pre>"},{"location":"BGFlood/structAdvanceP/#variable-dhv","title":"variable dhv","text":"<pre><code>T* AdvanceP&lt; T &gt;::dhv;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/structBlockP/","title":"Struct BlockP","text":""},{"location":"BGFlood/structBlockP/#struct-blockp","title":"Struct BlockP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; BlockP</p>"},{"location":"BGFlood/structBlockP/#public-attributes","title":"Public Attributes","text":"Type Name int * BotLeft int * BotRight int * LeftBot int * LeftTop int * RightBot int * RightTop int * TopLeft int * TopRight int * active int * activeCell int * level maskinfo mask std::vector&lt; outzoneB &gt; outZone T * xo T * yo"},{"location":"BGFlood/structBlockP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structBlockP/#variable-botleft","title":"variable BotLeft","text":"<pre><code>int* BlockP&lt; T &gt;::BotLeft;\n</code></pre>"},{"location":"BGFlood/structBlockP/#variable-botright","title":"variable BotRight","text":"<pre><code>int * BlockP&lt; T &gt;::BotRight;\n</code></pre>"},{"location":"BGFlood/structBlockP/#variable-leftbot","title":"variable LeftBot","text":"<pre><code>int* BlockP&lt; T &gt;::LeftBot;\n</code></pre>"},{"location":"BGFlood/structBlockP/#variable-lefttop","title":"variable LeftTop","text":"<pre><code>int * BlockP&lt; T &gt;::LeftTop;\n</code></pre>"},{"location":"BGFlood/structBlockP/#variable-rightbot","title":"variable RightBot","text":"<pre><code>int* BlockP&lt; T &gt;::RightBot;\n</code></pre>"},{"location":"BGFlood/structBlockP/#variable-righttop","title":"variable RightTop","text":"<pre><code>int * BlockP&lt; T &gt;::RightTop;\n</code></pre>"},{"location":"BGFlood/structBlockP/#variable-topleft","title":"variable TopLeft","text":"<pre><code>int* BlockP&lt; T &gt;::TopLeft;\n</code></pre>"},{"location":"BGFlood/structBlockP/#variable-topright","title":"variable TopRight","text":"<pre><code>int * BlockP&lt; T &gt;::TopRight;\n</code></pre>"},{"location":"BGFlood/structBlockP/#variable-active","title":"variable active","text":"<pre><code>int* BlockP&lt; T &gt;::active;\n</code></pre>"},{"location":"BGFlood/structBlockP/#variable-activecell","title":"variable activeCell","text":"<pre><code>int* BlockP&lt; T &gt;::activeCell;\n</code></pre>"},{"location":"BGFlood/structBlockP/#variable-level","title":"variable level","text":"<pre><code>int* BlockP&lt; T &gt;::level;\n</code></pre>"},{"location":"BGFlood/structBlockP/#variable-mask","title":"variable mask","text":"<pre><code>maskinfo BlockP&lt; T &gt;::mask;\n</code></pre>"},{"location":"BGFlood/structBlockP/#variable-outzone","title":"variable outZone","text":"<pre><code>std::vector&lt;outzoneB&gt; BlockP&lt; T &gt;::outZone;\n</code></pre>"},{"location":"BGFlood/structBlockP/#variable-xo","title":"variable xo","text":"<pre><code>T* BlockP&lt; T &gt;::xo;\n</code></pre>"},{"location":"BGFlood/structBlockP/#variable-yo","title":"variable yo","text":"<pre><code>T * BlockP&lt; T &gt;::yo;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/structBndblockP/","title":"Struct BndblockP","text":""},{"location":"BGFlood/structBndblockP/#struct-bndblockp","title":"Struct BndblockP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; BndblockP</p>"},{"location":"BGFlood/structBndblockP/#public-attributes","title":"Public Attributes","text":"Type Name RiverInfo&lt; T &gt; Riverinfo int * Tsout int * bot int * left int nblkTs int nblkriver int nbndblkbot int nbndblkleft int nbndblkright int nbndblktop int * right int * river int * top"},{"location":"BGFlood/structBndblockP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structBndblockP/#variable-riverinfo","title":"variable Riverinfo","text":"<pre><code>RiverInfo&lt;T&gt; BndblockP&lt; T &gt;::Riverinfo;\n</code></pre>"},{"location":"BGFlood/structBndblockP/#variable-tsout","title":"variable Tsout","text":"<pre><code>int* BndblockP&lt; T &gt;::Tsout;\n</code></pre>"},{"location":"BGFlood/structBndblockP/#variable-bot","title":"variable bot","text":"<pre><code>int* BndblockP&lt; T &gt;::bot;\n</code></pre>"},{"location":"BGFlood/structBndblockP/#variable-left","title":"variable left","text":"<pre><code>int* BndblockP&lt; T &gt;::left;\n</code></pre>"},{"location":"BGFlood/structBndblockP/#variable-nblkts","title":"variable nblkTs","text":"<pre><code>int BndblockP&lt; T &gt;::nblkTs;\n</code></pre>"},{"location":"BGFlood/structBndblockP/#variable-nblkriver","title":"variable nblkriver","text":"<pre><code>int BndblockP&lt; T &gt;::nblkriver;\n</code></pre>"},{"location":"BGFlood/structBndblockP/#variable-nbndblkbot","title":"variable nbndblkbot","text":"<pre><code>int BndblockP&lt; T &gt;::nbndblkbot;\n</code></pre>"},{"location":"BGFlood/structBndblockP/#variable-nbndblkleft","title":"variable nbndblkleft","text":"<pre><code>int BndblockP&lt; T &gt;::nbndblkleft;\n</code></pre>"},{"location":"BGFlood/structBndblockP/#variable-nbndblkright","title":"variable nbndblkright","text":"<pre><code>int BndblockP&lt; T &gt;::nbndblkright;\n</code></pre>"},{"location":"BGFlood/structBndblockP/#variable-nbndblktop","title":"variable nbndblktop","text":"<pre><code>int BndblockP&lt; T &gt;::nbndblktop;\n</code></pre>"},{"location":"BGFlood/structBndblockP/#variable-right","title":"variable right","text":"<pre><code>int* BndblockP&lt; T &gt;::right;\n</code></pre>"},{"location":"BGFlood/structBndblockP/#variable-river","title":"variable river","text":"<pre><code>int* BndblockP&lt; T &gt;::river;\n</code></pre>"},{"location":"BGFlood/structBndblockP/#variable-top","title":"variable top","text":"<pre><code>int* BndblockP&lt; T &gt;::top;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/structDynForcingP/","title":"Struct DynForcingP","text":""},{"location":"BGFlood/structDynForcingP/#struct-dynforcingp","title":"Struct DynForcingP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; DynForcingP</p> <p>Inherits the following classes: forcingmap</p>"},{"location":"BGFlood/structDynForcingP/#public-attributes","title":"Public Attributes","text":"Type Name T * after T * after_g T * before T * before_g T clampedge   = <code>0.0</code> T * now T * now_g T * val"},{"location":"BGFlood/structDynForcingP/#public-attributes-inherited-from-forcingmap","title":"Public Attributes inherited from forcingmap","text":"<p>See forcingmap</p> Type Name TexSetP GPU double dt std::string inputfile int instep   = <code>0</code> double nowvalue int nt double tmax double to std::vector&lt; Windin &gt; unidata bool uniform   = <code>false</code>"},{"location":"BGFlood/structDynForcingP/#public-attributes-inherited-from-inputmap","title":"Public Attributes inherited from inputmap","text":"<p>See inputmap</p> Type Name double denanval   = <code>NAN</code> double dx   = <code>0.0</code> double dy   = <code>0.0</code> std::string extension bool flipxx   = <code>false</code> bool flipyy   = <code>false</code> double grdalpha   = <code>0.0</code> std::string inputfile int nx   = <code>0</code> int ny   = <code>0</code> std::string varname double xmax   = <code>0.0</code> double xo   = <code>0.0</code> double ymax   = <code>0.0</code> double yo   = <code>0.0</code>"},{"location":"BGFlood/structDynForcingP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structDynForcingP/#variable-after","title":"variable after","text":"<pre><code>T * DynForcingP&lt; T &gt;::after;\n</code></pre>"},{"location":"BGFlood/structDynForcingP/#variable-after_g","title":"variable after_g","text":"<pre><code>T * DynForcingP&lt; T &gt;::after_g;\n</code></pre>"},{"location":"BGFlood/structDynForcingP/#variable-before","title":"variable before","text":"<pre><code>T* DynForcingP&lt; T &gt;::before;\n</code></pre>"},{"location":"BGFlood/structDynForcingP/#variable-before_g","title":"variable before_g","text":"<pre><code>T* DynForcingP&lt; T &gt;::before_g;\n</code></pre>"},{"location":"BGFlood/structDynForcingP/#variable-clampedge","title":"variable clampedge","text":"<pre><code>T DynForcingP&lt; T &gt;::clampedge;\n</code></pre>"},{"location":"BGFlood/structDynForcingP/#variable-now","title":"variable now","text":"<pre><code>T* DynForcingP&lt; T &gt;::now;\n</code></pre>"},{"location":"BGFlood/structDynForcingP/#variable-now_g","title":"variable now_g","text":"<pre><code>T* DynForcingP&lt; T &gt;::now_g;\n</code></pre>"},{"location":"BGFlood/structDynForcingP/#variable-val","title":"variable val","text":"<pre><code>T* DynForcingP&lt; T &gt;::val;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/structEvolvingMLP/","title":"Struct EvolvingMLP","text":""},{"location":"BGFlood/structEvolvingMLP/#struct-evolvingmlp","title":"Struct EvolvingMLP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; EvolvingMLP</p>"},{"location":"BGFlood/structEvolvingMLP/#public-attributes","title":"Public Attributes","text":"Type Name T * h T * u T * v"},{"location":"BGFlood/structEvolvingMLP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structEvolvingMLP/#variable-h","title":"variable h","text":"<pre><code>T* EvolvingMLP&lt; T &gt;::h;\n</code></pre>"},{"location":"BGFlood/structEvolvingMLP/#variable-u","title":"variable u","text":"<pre><code>T* EvolvingMLP&lt; T &gt;::u;\n</code></pre>"},{"location":"BGFlood/structEvolvingMLP/#variable-v","title":"variable v","text":"<pre><code>T* EvolvingMLP&lt; T &gt;::v;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/structEvolvingP/","title":"Struct EvolvingP","text":""},{"location":"BGFlood/structEvolvingP/#struct-evolvingp","title":"Struct EvolvingP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; EvolvingP</p> <p>Inherited by the following classes: EvolvingP_M</p>"},{"location":"BGFlood/structEvolvingP/#public-attributes","title":"Public Attributes","text":"Type Name T * h T * u T * v T * zs"},{"location":"BGFlood/structEvolvingP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structEvolvingP/#variable-h","title":"variable h","text":"<pre><code>T* EvolvingP&lt; T &gt;::h;\n</code></pre>"},{"location":"BGFlood/structEvolvingP/#variable-u","title":"variable u","text":"<pre><code>T* EvolvingP&lt; T &gt;::u;\n</code></pre>"},{"location":"BGFlood/structEvolvingP/#variable-v","title":"variable v","text":"<pre><code>T* EvolvingP&lt; T &gt;::v;\n</code></pre>"},{"location":"BGFlood/structEvolvingP/#variable-zs","title":"variable zs","text":"<pre><code>T* EvolvingP&lt; T &gt;::zs;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/structEvolvingP__M/","title":"Struct EvolvingP_M","text":""},{"location":"BGFlood/structEvolvingP__M/#struct-evolvingp_m","title":"Struct EvolvingP_M","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; EvolvingP_M</p> <p>Inherits the following classes: EvolvingP</p>"},{"location":"BGFlood/structEvolvingP__M/#public-attributes","title":"Public Attributes","text":"Type Name T * U T * hU"},{"location":"BGFlood/structEvolvingP__M/#public-attributes-inherited-from-evolvingp","title":"Public Attributes inherited from EvolvingP","text":"<p>See EvolvingP</p> Type Name T * h T * u T * v T * zs"},{"location":"BGFlood/structEvolvingP__M/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structEvolvingP__M/#variable-u","title":"variable U","text":"<pre><code>T* EvolvingP_M&lt; T &gt;::U;\n</code></pre>"},{"location":"BGFlood/structEvolvingP__M/#variable-hu","title":"variable hU","text":"<pre><code>T* EvolvingP_M&lt; T &gt;::hU;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/classFlowin/","title":"Class Flowin","text":""},{"location":"BGFlood/classFlowin/#class-flowin","title":"Class Flowin","text":"<p>ClassList &gt; Flowin</p>"},{"location":"BGFlood/classFlowin/#public-attributes","title":"Public Attributes","text":"Type Name double q double time"},{"location":"BGFlood/classFlowin/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classFlowin/#variable-q","title":"variable q","text":"<pre><code>double Flowin::q;\n</code></pre>"},{"location":"BGFlood/classFlowin/#variable-time","title":"variable time","text":"<pre><code>double Flowin::time;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/structFluxMLP/","title":"Struct FluxMLP","text":""},{"location":"BGFlood/structFluxMLP/#struct-fluxmlp","title":"Struct FluxMLP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; FluxMLP</p>"},{"location":"BGFlood/structFluxMLP/#public-attributes","title":"Public Attributes","text":"Type Name T * Fux T * Fuy T * Fvx T * Fvy T * hau T * hav T * hfu T * hfv T * hu T * hv"},{"location":"BGFlood/structFluxMLP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structFluxMLP/#variable-fux","title":"variable Fux","text":"<pre><code>T* FluxMLP&lt; T &gt;::Fux;\n</code></pre>"},{"location":"BGFlood/structFluxMLP/#variable-fuy","title":"variable Fuy","text":"<pre><code>T* FluxMLP&lt; T &gt;::Fuy;\n</code></pre>"},{"location":"BGFlood/structFluxMLP/#variable-fvx","title":"variable Fvx","text":"<pre><code>T * FluxMLP&lt; T &gt;::Fvx;\n</code></pre>"},{"location":"BGFlood/structFluxMLP/#variable-fvy","title":"variable Fvy","text":"<pre><code>T * FluxMLP&lt; T &gt;::Fvy;\n</code></pre>"},{"location":"BGFlood/structFluxMLP/#variable-hau","title":"variable hau","text":"<pre><code>T* FluxMLP&lt; T &gt;::hau;\n</code></pre>"},{"location":"BGFlood/structFluxMLP/#variable-hav","title":"variable hav","text":"<pre><code>T * FluxMLP&lt; T &gt;::hav;\n</code></pre>"},{"location":"BGFlood/structFluxMLP/#variable-hfu","title":"variable hfu","text":"<pre><code>T* FluxMLP&lt; T &gt;::hfu;\n</code></pre>"},{"location":"BGFlood/structFluxMLP/#variable-hfv","title":"variable hfv","text":"<pre><code>T * FluxMLP&lt; T &gt;::hfv;\n</code></pre>"},{"location":"BGFlood/structFluxMLP/#variable-hu","title":"variable hu","text":"<pre><code>T* FluxMLP&lt; T &gt;::hu;\n</code></pre>"},{"location":"BGFlood/structFluxMLP/#variable-hv","title":"variable hv","text":"<pre><code>T * FluxMLP&lt; T &gt;::hv;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/structFluxP/","title":"Struct FluxP","text":""},{"location":"BGFlood/structFluxP/#struct-fluxp","title":"Struct FluxP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; FluxP</p>"},{"location":"BGFlood/structFluxP/#public-attributes","title":"Public Attributes","text":"Type Name T * Fhu T * Fhv T * Fqux T * Fquy T * Fqvx T * Fqvy T * Su T * Sv"},{"location":"BGFlood/structFluxP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structFluxP/#variable-fhu","title":"variable Fhu","text":"<pre><code>T* FluxP&lt; T &gt;::Fhu;\n</code></pre>"},{"location":"BGFlood/structFluxP/#variable-fhv","title":"variable Fhv","text":"<pre><code>T * FluxP&lt; T &gt;::Fhv;\n</code></pre>"},{"location":"BGFlood/structFluxP/#variable-fqux","title":"variable Fqux","text":"<pre><code>T* FluxP&lt; T &gt;::Fqux;\n</code></pre>"},{"location":"BGFlood/structFluxP/#variable-fquy","title":"variable Fquy","text":"<pre><code>T * FluxP&lt; T &gt;::Fquy;\n</code></pre>"},{"location":"BGFlood/structFluxP/#variable-fqvx","title":"variable Fqvx","text":"<pre><code>T* FluxP&lt; T &gt;::Fqvx;\n</code></pre>"},{"location":"BGFlood/structFluxP/#variable-fqvy","title":"variable Fqvy","text":"<pre><code>T * FluxP&lt; T &gt;::Fqvy;\n</code></pre>"},{"location":"BGFlood/structFluxP/#variable-su","title":"variable Su","text":"<pre><code>T* FluxP&lt; T &gt;::Su;\n</code></pre>"},{"location":"BGFlood/structFluxP/#variable-sv","title":"variable Sv","text":"<pre><code>T * FluxP&lt; T &gt;::Sv;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/structForcing/","title":"Struct Forcing","text":""},{"location":"BGFlood/structForcing/#struct-forcing","title":"Struct Forcing","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; Forcing</p>"},{"location":"BGFlood/structForcing/#public-attributes","title":"Public Attributes","text":"Type Name AOIinfo AOI DynForcingP&lt; T &gt; Atmp std::vector&lt; StaticForcingP&lt; T &gt; &gt; Bathy DynForcingP&lt; T &gt; Rain DynForcingP&lt; T &gt; UWind DynForcingP&lt; T &gt; VWind std::vector&lt; bndsegment &gt; bndseg bndparam bot std::vector&lt; StaticForcingP&lt; T &gt; &gt; cf StaticForcingP&lt; T &gt; cl std::vector&lt; deformmap&lt; T &gt; &gt; deform StaticForcingP&lt; T &gt; il bndparam left bndparam right std::vector&lt; River &gt; rivers std::vector&lt; StaticForcingP&lt; int &gt; &gt; targetadapt bndparam top"},{"location":"BGFlood/structForcing/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structForcing/#variable-aoi","title":"variable AOI","text":"<pre><code>AOIinfo Forcing&lt; T &gt;::AOI;\n</code></pre>"},{"location":"BGFlood/structForcing/#variable-atmp","title":"variable Atmp","text":"<pre><code>DynForcingP&lt;T&gt; Forcing&lt; T &gt;::Atmp;\n</code></pre>"},{"location":"BGFlood/structForcing/#variable-bathy","title":"variable Bathy","text":"<pre><code>std::vector&lt;StaticForcingP&lt;T&gt; &gt; Forcing&lt; T &gt;::Bathy;\n</code></pre>"},{"location":"BGFlood/structForcing/#variable-rain","title":"variable Rain","text":"<pre><code>DynForcingP&lt;T&gt; Forcing&lt; T &gt;::Rain;\n</code></pre>"},{"location":"BGFlood/structForcing/#variable-uwind","title":"variable UWind","text":"<pre><code>DynForcingP&lt;T&gt; Forcing&lt; T &gt;::UWind;\n</code></pre>"},{"location":"BGFlood/structForcing/#variable-vwind","title":"variable VWind","text":"<pre><code>DynForcingP&lt;T&gt; Forcing&lt; T &gt;::VWind;\n</code></pre>"},{"location":"BGFlood/structForcing/#variable-bndseg","title":"variable bndseg","text":"<pre><code>std::vector&lt;bndsegment&gt; Forcing&lt; T &gt;::bndseg;\n</code></pre>"},{"location":"BGFlood/structForcing/#variable-bot","title":"variable bot","text":"<pre><code>bndparam Forcing&lt; T &gt;::bot;\n</code></pre>"},{"location":"BGFlood/structForcing/#variable-cf","title":"variable cf","text":"<pre><code>std::vector&lt;StaticForcingP&lt;T&gt; &gt; Forcing&lt; T &gt;::cf;\n</code></pre>"},{"location":"BGFlood/structForcing/#variable-cl","title":"variable cl","text":"<pre><code>StaticForcingP&lt;T&gt; Forcing&lt; T &gt;::cl;\n</code></pre>"},{"location":"BGFlood/structForcing/#variable-deform","title":"variable deform","text":"<pre><code>std::vector&lt;deformmap&lt;T&gt; &gt; Forcing&lt; T &gt;::deform;\n</code></pre>"},{"location":"BGFlood/structForcing/#variable-il","title":"variable il","text":"<pre><code>StaticForcingP&lt;T&gt; Forcing&lt; T &gt;::il;\n</code></pre>"},{"location":"BGFlood/structForcing/#variable-left","title":"variable left","text":"<pre><code>bndparam Forcing&lt; T &gt;::left;\n</code></pre>"},{"location":"BGFlood/structForcing/#variable-right","title":"variable right","text":"<pre><code>bndparam Forcing&lt; T &gt;::right;\n</code></pre>"},{"location":"BGFlood/structForcing/#variable-rivers","title":"variable rivers","text":"<pre><code>std::vector&lt;River&gt; Forcing&lt; T &gt;::rivers;\n</code></pre>"},{"location":"BGFlood/structForcing/#variable-targetadapt","title":"variable targetadapt","text":"<pre><code>std::vector&lt;StaticForcingP&lt;int&gt; &gt; Forcing&lt; T &gt;::targetadapt;\n</code></pre>"},{"location":"BGFlood/structForcing/#variable-top","title":"variable top","text":"<pre><code>bndparam Forcing&lt; T &gt;::top;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/structGradientsMLP/","title":"Struct GradientsMLP","text":""},{"location":"BGFlood/structGradientsMLP/#struct-gradientsmlp","title":"Struct GradientsMLP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; GradientsMLP</p>"},{"location":"BGFlood/structGradientsMLP/#public-attributes","title":"Public Attributes","text":"Type Name T * dhdx T * dhdy T * dudx T * dudy T * dvdx T * dvdy"},{"location":"BGFlood/structGradientsMLP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structGradientsMLP/#variable-dhdx","title":"variable dhdx","text":"<pre><code>T* GradientsMLP&lt; T &gt;::dhdx;\n</code></pre>"},{"location":"BGFlood/structGradientsMLP/#variable-dhdy","title":"variable dhdy","text":"<pre><code>T* GradientsMLP&lt; T &gt;::dhdy;\n</code></pre>"},{"location":"BGFlood/structGradientsMLP/#variable-dudx","title":"variable dudx","text":"<pre><code>T* GradientsMLP&lt; T &gt;::dudx;\n</code></pre>"},{"location":"BGFlood/structGradientsMLP/#variable-dudy","title":"variable dudy","text":"<pre><code>T* GradientsMLP&lt; T &gt;::dudy;\n</code></pre>"},{"location":"BGFlood/structGradientsMLP/#variable-dvdx","title":"variable dvdx","text":"<pre><code>T* GradientsMLP&lt; T &gt;::dvdx;\n</code></pre>"},{"location":"BGFlood/structGradientsMLP/#variable-dvdy","title":"variable dvdy","text":"<pre><code>T* GradientsMLP&lt; T &gt;::dvdy;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/structGradientsP/","title":"Struct GradientsP","text":""},{"location":"BGFlood/structGradientsP/#struct-gradientsp","title":"Struct GradientsP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; GradientsP</p>"},{"location":"BGFlood/structGradientsP/#public-attributes","title":"Public Attributes","text":"Type Name T * dhdx T * dhdy T * dudx T * dudy T * dvdx T * dvdy T * dzbdx T * dzbdy T * dzsdx T * dzsdy"},{"location":"BGFlood/structGradientsP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structGradientsP/#variable-dhdx","title":"variable dhdx","text":"<pre><code>T* GradientsP&lt; T &gt;::dhdx;\n</code></pre>"},{"location":"BGFlood/structGradientsP/#variable-dhdy","title":"variable dhdy","text":"<pre><code>T* GradientsP&lt; T &gt;::dhdy;\n</code></pre>"},{"location":"BGFlood/structGradientsP/#variable-dudx","title":"variable dudx","text":"<pre><code>T* GradientsP&lt; T &gt;::dudx;\n</code></pre>"},{"location":"BGFlood/structGradientsP/#variable-dudy","title":"variable dudy","text":"<pre><code>T* GradientsP&lt; T &gt;::dudy;\n</code></pre>"},{"location":"BGFlood/structGradientsP/#variable-dvdx","title":"variable dvdx","text":"<pre><code>T* GradientsP&lt; T &gt;::dvdx;\n</code></pre>"},{"location":"BGFlood/structGradientsP/#variable-dvdy","title":"variable dvdy","text":"<pre><code>T* GradientsP&lt; T &gt;::dvdy;\n</code></pre>"},{"location":"BGFlood/structGradientsP/#variable-dzbdx","title":"variable dzbdx","text":"<pre><code>T* GradientsP&lt; T &gt;::dzbdx;\n</code></pre>"},{"location":"BGFlood/structGradientsP/#variable-dzbdy","title":"variable dzbdy","text":"<pre><code>T* GradientsP&lt; T &gt;::dzbdy;\n</code></pre>"},{"location":"BGFlood/structGradientsP/#variable-dzsdx","title":"variable dzsdx","text":"<pre><code>T* GradientsP&lt; T &gt;::dzsdx;\n</code></pre>"},{"location":"BGFlood/structGradientsP/#variable-dzsdy","title":"variable dzsdy","text":"<pre><code>T* GradientsP&lt; T &gt;::dzsdy;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/structLoop/","title":"Struct Loop","text":""},{"location":"BGFlood/structLoop/#struct-loop","title":"Struct Loop","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; Loop</p>"},{"location":"BGFlood/structLoop/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; std::vector&lt; Pointout &gt; &gt; TSAllout int atmpstep   = <code>1</code> T atmpuni bool atmpuniform dim3 blockDim double dt double dtmax T epsilon dim3 gridDim T hugenegval T hugeposval int indNextoutputtime   = <code>0</code> int nTSsteps   = <code>0</code> double nextoutputtime int nstep   = <code>0</code> int nstepout   = <code>0</code> const int num_streams   = <code>4</code> int rainstep   = <code>1</code> T rainuni   = <code>T(0.0)</code> bool rainuniform cudaStream_t streams double totaltime T uwinduni   = <code>T(0.0)</code> T vwinduni   = <code>T(0.0)</code> int windstep   = <code>1</code> bool winduniform"},{"location":"BGFlood/structLoop/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structLoop/#variable-tsallout","title":"variable TSAllout","text":"<pre><code>std::vector&lt; std::vector&lt; Pointout &gt; &gt; Loop&lt; T &gt;::TSAllout;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-atmpstep","title":"variable atmpstep","text":"<pre><code>int Loop&lt; T &gt;::atmpstep;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-atmpuni","title":"variable atmpuni","text":"<pre><code>T Loop&lt; T &gt;::atmpuni;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-atmpuniform","title":"variable atmpuniform","text":"<pre><code>bool Loop&lt; T &gt;::atmpuniform;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-blockdim","title":"variable blockDim","text":"<pre><code>dim3 Loop&lt; T &gt;::blockDim;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-dt","title":"variable dt","text":"<pre><code>double Loop&lt; T &gt;::dt;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-dtmax","title":"variable dtmax","text":"<pre><code>double Loop&lt; T &gt;::dtmax;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-epsilon","title":"variable epsilon","text":"<pre><code>T Loop&lt; T &gt;::epsilon;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-griddim","title":"variable gridDim","text":"<pre><code>dim3 Loop&lt; T &gt;::gridDim;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-hugenegval","title":"variable hugenegval","text":"<pre><code>T Loop&lt; T &gt;::hugenegval;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-hugeposval","title":"variable hugeposval","text":"<pre><code>T Loop&lt; T &gt;::hugeposval;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-indnextoutputtime","title":"variable indNextoutputtime","text":"<pre><code>int Loop&lt; T &gt;::indNextoutputtime;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-ntssteps","title":"variable nTSsteps","text":"<pre><code>int Loop&lt; T &gt;::nTSsteps;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-nextoutputtime","title":"variable nextoutputtime","text":"<pre><code>double Loop&lt; T &gt;::nextoutputtime;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-nstep","title":"variable nstep","text":"<pre><code>int Loop&lt; T &gt;::nstep;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-nstepout","title":"variable nstepout","text":"<pre><code>int Loop&lt; T &gt;::nstepout;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-num_streams","title":"variable num_streams","text":"<pre><code>const int Loop&lt; T &gt;::num_streams;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-rainstep","title":"variable rainstep","text":"<pre><code>int Loop&lt; T &gt;::rainstep;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-rainuni","title":"variable rainuni","text":"<pre><code>T Loop&lt; T &gt;::rainuni;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-rainuniform","title":"variable rainuniform","text":"<pre><code>bool Loop&lt; T &gt;::rainuniform;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-streams","title":"variable streams","text":"<pre><code>cudaStream_t Loop&lt; T &gt;::streams[4];\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-totaltime","title":"variable totaltime","text":"<pre><code>double Loop&lt; T &gt;::totaltime;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-uwinduni","title":"variable uwinduni","text":"<pre><code>T Loop&lt; T &gt;::uwinduni;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-vwinduni","title":"variable vwinduni","text":"<pre><code>T Loop&lt; T &gt;::vwinduni;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-windstep","title":"variable windstep","text":"<pre><code>int Loop&lt; T &gt;::windstep;\n</code></pre>"},{"location":"BGFlood/structLoop/#variable-winduniform","title":"variable winduniform","text":"<pre><code>bool Loop&lt; T &gt;::winduniform;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/classMapparam/","title":"Class Mapparam","text":""},{"location":"BGFlood/classMapparam/#class-mapparam","title":"Class Mapparam","text":"<p>ClassList &gt; Mapparam</p> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/structModel/","title":"Struct Model","text":""},{"location":"BGFlood/structModel/#struct-model","title":"Struct Model","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; Model</p>"},{"location":"BGFlood/structModel/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; double &gt; OutputT std::map&lt; std::string, T * &gt; OutputVarMap std::map&lt; std::string, std::string &gt; Outvarlongname std::map&lt; std::string, std::string &gt; Outvarstdname std::map&lt; std::string, std::string &gt; Outvarunits T * Patm T * TSstore AdaptP adapt AdvanceP&lt; T &gt; adv BlockP&lt; T &gt; blocks BndblockP&lt; T &gt; bndblk T * cf T * cl T * datmpdx T * datmpdy EvolvingP_M&lt; T &gt; evmax EvolvingP_M&lt; T &gt; evmean EvolvingP&lt; T &gt; evolv EvolvingP&lt; T &gt; evolv_o FluxP&lt; T &gt; flux FluxMLP&lt; T &gt; fluxml GradientsP&lt; T &gt; grad T * hgw T * il TimeP&lt; T &gt; time T * wettime T * zb"},{"location":"BGFlood/structModel/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structModel/#variable-outputt","title":"variable OutputT","text":"<pre><code>std::vector&lt;double&gt; Model&lt; T &gt;::OutputT;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-outputvarmap","title":"variable OutputVarMap","text":"<pre><code>std::map&lt;std::string, T *&gt; Model&lt; T &gt;::OutputVarMap;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-outvarlongname","title":"variable Outvarlongname","text":"<pre><code>std::map&lt;std::string, std::string&gt; Model&lt; T &gt;::Outvarlongname;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-outvarstdname","title":"variable Outvarstdname","text":"<pre><code>std::map&lt;std::string, std::string&gt; Model&lt; T &gt;::Outvarstdname;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-outvarunits","title":"variable Outvarunits","text":"<pre><code>std::map&lt;std::string, std::string&gt; Model&lt; T &gt;::Outvarunits;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-patm","title":"variable Patm","text":"<pre><code>T* Model&lt; T &gt;::Patm;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-tsstore","title":"variable TSstore","text":"<pre><code>T* Model&lt; T &gt;::TSstore;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-adapt","title":"variable adapt","text":"<pre><code>AdaptP Model&lt; T &gt;::adapt;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-adv","title":"variable adv","text":"<pre><code>AdvanceP&lt;T&gt; Model&lt; T &gt;::adv;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-blocks","title":"variable blocks","text":"<pre><code>BlockP&lt;T&gt; Model&lt; T &gt;::blocks;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-bndblk","title":"variable bndblk","text":"<pre><code>BndblockP&lt;T&gt; Model&lt; T &gt;::bndblk;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-cf","title":"variable cf","text":"<pre><code>T* Model&lt; T &gt;::cf;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-cl","title":"variable cl","text":"<pre><code>T* Model&lt; T &gt;::cl;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-datmpdx","title":"variable datmpdx","text":"<pre><code>T * Model&lt; T &gt;::datmpdx;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-datmpdy","title":"variable datmpdy","text":"<pre><code>T * Model&lt; T &gt;::datmpdy;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-evmax","title":"variable evmax","text":"<pre><code>EvolvingP_M&lt;T&gt; Model&lt; T &gt;::evmax;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-evmean","title":"variable evmean","text":"<pre><code>EvolvingP_M&lt;T&gt; Model&lt; T &gt;::evmean;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-evolv","title":"variable evolv","text":"<pre><code>EvolvingP&lt;T&gt; Model&lt; T &gt;::evolv;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-evolv_o","title":"variable evolv_o","text":"<pre><code>EvolvingP&lt;T&gt; Model&lt; T &gt;::evolv_o;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-flux","title":"variable flux","text":"<pre><code>FluxP&lt;T&gt; Model&lt; T &gt;::flux;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-fluxml","title":"variable fluxml","text":"<pre><code>FluxMLP&lt;T&gt; Model&lt; T &gt;::fluxml;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-grad","title":"variable grad","text":"<pre><code>GradientsP&lt;T&gt; Model&lt; T &gt;::grad;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-hgw","title":"variable hgw","text":"<pre><code>T* Model&lt; T &gt;::hgw;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-il","title":"variable il","text":"<pre><code>T* Model&lt; T &gt;::il;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-time","title":"variable time","text":"<pre><code>TimeP&lt;T&gt; Model&lt; T &gt;::time;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-wettime","title":"variable wettime","text":"<pre><code>T* Model&lt; T &gt;::wettime;\n</code></pre>"},{"location":"BGFlood/structModel/#variable-zb","title":"variable zb","text":"<pre><code>T* Model&lt; T &gt;::zb;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/classParam/","title":"Class Param","text":""},{"location":"BGFlood/classParam/#class-param","title":"Class Param","text":"<p>ClassList &gt; Param</p> <p>More...</p> <ul> <li><code>#include &lt;Param.h&gt;</code></li> </ul>"},{"location":"BGFlood/classParam/#public-attributes","title":"Public Attributes","text":"Type Name std::string AdaptCrit int * AdaptCrit_funct_pointer std::string Adapt_arg1 std::string Adapt_arg2 std::string Adapt_arg3 std::string Adapt_arg4 std::string Adapt_arg5 double CFL   = <code>0.5</code> double Cd   = <code>0.002</code> bool ForceMassConserve   = <code>false</code> int GPUDEVICE   = <code>0</code> size_t GPU_initmem_byte size_t GPU_totalmem_byte double Pa2m   = <code>0.00009916</code> double Paref   = <code>101300.0</code> double Radius   = <code>6371220.</code> std::vector&lt; TSoutnode &gt; TSnodesout T_output Toutput double VelThreshold   = <code>-1.0</code> int adaptmaxiteration   = <code>20</code> float addoffset   = <code>0.0f</code> int aoibnd   = <code>0</code> bool atmpforcing   = <code>false</code> int blkmemwidth   = <code>0</code> int blksize   = <code>0</code> int blkwidth   = <code>16</code> double bndfiltertime   = <code>60.0</code> double bndrelaxtime   = <code>3600.0</code> double bndtaper   = <code>0.0</code> bool botbnd   = <code>false</code> double cf   = <code>0.0001</code> double cl   = <code>0.0</code> bool conserveElevation   = <code>false</code> std::string crs_ref   = <code>\"no\\_crs\"</code> double deformmaxtime   = <code>0.0</code> double delta int doubleprecision   = <code>0</code> double dt   = <code>0.0</code> double dtinit   = <code>-1</code> double dtmin   = <code>0.0005</code> double dx   = <code>nan(\"\")</code> clock_t endcputime double endtime   = <code>std::numeric\\_limits&amp;lt;double&amp;gt;::max()</code> int engine   = <code>1</code> double eps   = <code>0.0001</code> int frictionmodel   = <code>0</code> double g   = <code>9.81</code> double grdalpha   = <code>nan(\"\")</code> int halowidth   = <code>1</code> std::string hotstartfile int hotstep   = <code>0</code> double il   = <code>0.0</code> bool infiltration   = <code>false</code> int initlevel   = <code>0</code> double inittime   = <code>0.0</code> double lat   = <code>0.0</code> bool leftbnd   = <code>false</code> double mask   = <code>9999.0</code> int maxTSstorage   = <code>16384</code> int maxlevel   = <code>-99999</code> double membuffer   = <code>1.05</code> int minlevel   = <code>-99999</code> int navailblk   = <code>0</code> int nblk   = <code>0</code> int nblkmem   = <code>0</code> int nblkriver   = <code>0</code> int nbndblkbot   = <code>0</code> int nbndblkleft   = <code>0</code> int nbndblkright   = <code>0</code> int nbndblktop   = <code>0</code> int nmaskblk   = <code>0</code> int nrivers   = <code>0</code> int nx   = <code>0</code> int ny   = <code>0</code> std::string outfile   = <code>\"Output.nc\"</code> int outishift   = <code>0</code> int outjshift   = <code>0</code> bool outmax   = <code>false</code> bool outmean   = <code>false</code> double outputtimestep   = <code>0.0</code> bool outtwet   = <code>false</code> std::vector&lt; std::string &gt; outvars std::vector&lt; outzoneP &gt; outzone int posdown   = <code>0</code> bool rainbnd   = <code>false</code> bool rainforcing   = <code>false</code> std::string reftime   = <code>\"\"</code> bool resetmax   = <code>false</code> double rho   = <code>1025.0</code> bool rightbnd   = <code>false</code> bool savebyblk   = <code>true</code> float scalefactor   = <code>0.01f</code> clock_t setupcputime int smallnc   = <code>1</code> bool spherical   = <code>0</code> clock_t startcputime int test   = <code>-1</code> double theta   = <code>1.3</code> bool topbnd   = <code>false</code> double totaltime   = <code>0.0</code> double wet_threshold   = <code>0.1</code> bool wetdryfix   = <code>true</code> bool windforcing   = <code>false</code> double xmax   = <code>nan(\"\")</code> double xo   = <code>nan(\"\")</code> double ymax   = <code>nan(\"\")</code> double yo   = <code>nan(\"\")</code> double zsinit   = <code>nan(\"\")</code> double zsoffset   = <code>nan(\"\")</code>"},{"location":"BGFlood/classParam/#detailed-description","title":"Detailed Description","text":"<p>A class. A class for holding model parameters. </p>"},{"location":"BGFlood/classParam/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classParam/#variable-adaptcrit","title":"variable AdaptCrit","text":"<pre><code>std::string Param::AdaptCrit;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-adaptcrit_funct_pointer","title":"variable AdaptCrit_funct_pointer","text":"<pre><code>int* Param::AdaptCrit_funct_pointer;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-adapt_arg1","title":"variable Adapt_arg1","text":"<pre><code>std::string Param::Adapt_arg1;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-adapt_arg2","title":"variable Adapt_arg2","text":"<pre><code>std::string Param::Adapt_arg2;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-adapt_arg3","title":"variable Adapt_arg3","text":"<pre><code>std::string Param::Adapt_arg3;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-adapt_arg4","title":"variable Adapt_arg4","text":"<pre><code>std::string Param::Adapt_arg4;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-adapt_arg5","title":"variable Adapt_arg5","text":"<pre><code>std::string Param::Adapt_arg5;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-cfl","title":"variable CFL","text":"<pre><code>double Param::CFL;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-cd","title":"variable Cd","text":"<pre><code>double Param::Cd;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-forcemassconserve","title":"variable ForceMassConserve","text":"<pre><code>bool Param::ForceMassConserve;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-gpudevice","title":"variable GPUDEVICE","text":"<pre><code>int Param::GPUDEVICE;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-gpu_initmem_byte","title":"variable GPU_initmem_byte","text":"<pre><code>size_t Param::GPU_initmem_byte;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-gpu_totalmem_byte","title":"variable GPU_totalmem_byte","text":"<pre><code>size_t Param::GPU_totalmem_byte;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-pa2m","title":"variable Pa2m","text":"<pre><code>double Param::Pa2m;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-paref","title":"variable Paref","text":"<pre><code>double Param::Paref;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-radius","title":"variable Radius","text":"<pre><code>double Param::Radius;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-tsnodesout","title":"variable TSnodesout","text":"<pre><code>std::vector&lt;TSoutnode&gt; Param::TSnodesout;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-toutput","title":"variable Toutput","text":"<pre><code>T_output Param::Toutput;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-velthreshold","title":"variable VelThreshold","text":"<pre><code>double Param::VelThreshold;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-adaptmaxiteration","title":"variable adaptmaxiteration","text":"<pre><code>int Param::adaptmaxiteration;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-addoffset","title":"variable addoffset","text":"<pre><code>float Param::addoffset;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-aoibnd","title":"variable aoibnd","text":"<pre><code>int Param::aoibnd;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-atmpforcing","title":"variable atmpforcing","text":"<pre><code>bool Param::atmpforcing;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-blkmemwidth","title":"variable blkmemwidth","text":"<pre><code>int Param::blkmemwidth;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-blksize","title":"variable blksize","text":"<pre><code>int Param::blksize;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-blkwidth","title":"variable blkwidth","text":"<pre><code>int Param::blkwidth;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-bndfiltertime","title":"variable bndfiltertime","text":"<pre><code>double Param::bndfiltertime;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-bndrelaxtime","title":"variable bndrelaxtime","text":"<pre><code>double Param::bndrelaxtime;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-bndtaper","title":"variable bndtaper","text":"<pre><code>double Param::bndtaper;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-botbnd","title":"variable botbnd","text":"<pre><code>bool Param::botbnd;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-cf","title":"variable cf","text":"<pre><code>double Param::cf;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-cl","title":"variable cl","text":"<pre><code>double Param::cl;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-conserveelevation","title":"variable conserveElevation","text":"<pre><code>bool Param::conserveElevation;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-crs_ref","title":"variable crs_ref","text":"<pre><code>std::string Param::crs_ref;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-deformmaxtime","title":"variable deformmaxtime","text":"<pre><code>double Param::deformmaxtime;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-delta","title":"variable delta","text":"<pre><code>double Param::delta;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-doubleprecision","title":"variable doubleprecision","text":"<pre><code>int Param::doubleprecision;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-dt","title":"variable dt","text":"<pre><code>double Param::dt;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-dtinit","title":"variable dtinit","text":"<pre><code>double Param::dtinit;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-dtmin","title":"variable dtmin","text":"<pre><code>double Param::dtmin;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-dx","title":"variable dx","text":"<pre><code>double Param::dx;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-endcputime","title":"variable endcputime","text":"<pre><code>clock_t Param::endcputime;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-endtime","title":"variable endtime","text":"<pre><code>double Param::endtime;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-engine","title":"variable engine","text":"<pre><code>int Param::engine;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-eps","title":"variable eps","text":"<pre><code>double Param::eps;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-frictionmodel","title":"variable frictionmodel","text":"<pre><code>int Param::frictionmodel;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-g","title":"variable g","text":"<pre><code>double Param::g;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-grdalpha","title":"variable grdalpha","text":"<pre><code>double Param::grdalpha;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-halowidth","title":"variable halowidth","text":"<pre><code>int Param::halowidth;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-hotstartfile","title":"variable hotstartfile","text":"<pre><code>std::string Param::hotstartfile;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-hotstep","title":"variable hotstep","text":"<pre><code>int Param::hotstep;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-il","title":"variable il","text":"<pre><code>double Param::il;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-infiltration","title":"variable infiltration","text":"<pre><code>bool Param::infiltration;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-initlevel","title":"variable initlevel","text":"<pre><code>int Param::initlevel;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-inittime","title":"variable inittime","text":"<pre><code>double Param::inittime;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-lat","title":"variable lat","text":"<pre><code>double Param::lat;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-leftbnd","title":"variable leftbnd","text":"<pre><code>bool Param::leftbnd;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-mask","title":"variable mask","text":"<pre><code>double Param::mask;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-maxtsstorage","title":"variable maxTSstorage","text":"<pre><code>int Param::maxTSstorage;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-maxlevel","title":"variable maxlevel","text":"<pre><code>int Param::maxlevel;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-membuffer","title":"variable membuffer","text":"<pre><code>double Param::membuffer;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-minlevel","title":"variable minlevel","text":"<pre><code>int Param::minlevel;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-navailblk","title":"variable navailblk","text":"<pre><code>int Param::navailblk;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-nblk","title":"variable nblk","text":"<pre><code>int Param::nblk;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-nblkmem","title":"variable nblkmem","text":"<pre><code>int Param::nblkmem;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-nblkriver","title":"variable nblkriver","text":"<pre><code>int Param::nblkriver;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-nbndblkbot","title":"variable nbndblkbot","text":"<pre><code>int Param::nbndblkbot;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-nbndblkleft","title":"variable nbndblkleft","text":"<pre><code>int Param::nbndblkleft;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-nbndblkright","title":"variable nbndblkright","text":"<pre><code>int Param::nbndblkright;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-nbndblktop","title":"variable nbndblktop","text":"<pre><code>int Param::nbndblktop;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-nmaskblk","title":"variable nmaskblk","text":"<pre><code>int Param::nmaskblk;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-nrivers","title":"variable nrivers","text":"<pre><code>int Param::nrivers;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-nx","title":"variable nx","text":"<pre><code>int Param::nx;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-ny","title":"variable ny","text":"<pre><code>int Param::ny;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-outfile","title":"variable outfile","text":"<pre><code>std::string Param::outfile;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-outishift","title":"variable outishift","text":"<pre><code>int Param::outishift;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-outjshift","title":"variable outjshift","text":"<pre><code>int Param::outjshift;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-outmax","title":"variable outmax","text":"<pre><code>bool Param::outmax;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-outmean","title":"variable outmean","text":"<pre><code>bool Param::outmean;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-outputtimestep","title":"variable outputtimestep","text":"<pre><code>double Param::outputtimestep;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-outtwet","title":"variable outtwet","text":"<pre><code>bool Param::outtwet;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-outvars","title":"variable outvars","text":"<pre><code>std::vector&lt;std::string&gt; Param::outvars;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-outzone","title":"variable outzone","text":"<pre><code>std::vector&lt;outzoneP&gt; Param::outzone;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-posdown","title":"variable posdown","text":"<pre><code>int Param::posdown;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-rainbnd","title":"variable rainbnd","text":"<pre><code>bool Param::rainbnd;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-rainforcing","title":"variable rainforcing","text":"<pre><code>bool Param::rainforcing;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-reftime","title":"variable reftime","text":"<pre><code>std::string Param::reftime;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-resetmax","title":"variable resetmax","text":"<pre><code>bool Param::resetmax;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-rho","title":"variable rho","text":"<pre><code>double Param::rho;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-rightbnd","title":"variable rightbnd","text":"<pre><code>bool Param::rightbnd;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-savebyblk","title":"variable savebyblk","text":"<pre><code>bool Param::savebyblk;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-scalefactor","title":"variable scalefactor","text":"<pre><code>float Param::scalefactor;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-setupcputime","title":"variable setupcputime","text":"<pre><code>clock_t Param::setupcputime;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-smallnc","title":"variable smallnc","text":"<pre><code>int Param::smallnc;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-spherical","title":"variable spherical","text":"<pre><code>bool Param::spherical;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-startcputime","title":"variable startcputime","text":"<pre><code>clock_t Param::startcputime;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-test","title":"variable test","text":"<pre><code>int Param::test;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-theta","title":"variable theta","text":"<pre><code>double Param::theta;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-topbnd","title":"variable topbnd","text":"<pre><code>bool Param::topbnd;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-totaltime","title":"variable totaltime","text":"<pre><code>double Param::totaltime;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-wet_threshold","title":"variable wet_threshold","text":"<pre><code>double Param::wet_threshold;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-wetdryfix","title":"variable wetdryfix","text":"<pre><code>bool Param::wetdryfix;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-windforcing","title":"variable windforcing","text":"<pre><code>bool Param::windforcing;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-xmax","title":"variable xmax","text":"<pre><code>double Param::xmax;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-xo","title":"variable xo","text":"<pre><code>double Param::xo;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-ymax","title":"variable ymax","text":"<pre><code>double Param::ymax;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-yo","title":"variable yo","text":"<pre><code>double Param::yo;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-zsinit","title":"variable zsinit","text":"<pre><code>double Param::zsinit;\n</code></pre>"},{"location":"BGFlood/classParam/#variable-zsoffset","title":"variable zsoffset","text":"<pre><code>double Param::zsoffset;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Param.h</code></p>"},{"location":"BGFlood/classPointout/","title":"Class Pointout","text":""},{"location":"BGFlood/classPointout/#class-pointout","title":"Class Pointout","text":"<p>ClassList &gt; Pointout</p>"},{"location":"BGFlood/classPointout/#public-attributes","title":"Public Attributes","text":"Type Name double h double time double u double v double zs"},{"location":"BGFlood/classPointout/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classPointout/#variable-h","title":"variable h","text":"<pre><code>double Pointout::h;\n</code></pre>"},{"location":"BGFlood/classPointout/#variable-time","title":"variable time","text":"<pre><code>double Pointout::time;\n</code></pre>"},{"location":"BGFlood/classPointout/#variable-u","title":"variable u","text":"<pre><code>double Pointout::u;\n</code></pre>"},{"location":"BGFlood/classPointout/#variable-v","title":"variable v","text":"<pre><code>double Pointout::v;\n</code></pre>"},{"location":"BGFlood/classPointout/#variable-zs","title":"variable zs","text":"<pre><code>double Pointout::zs;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/classPolygon/","title":"Class Polygon","text":""},{"location":"BGFlood/classPolygon/#class-polygon","title":"Class Polygon","text":"<p>ClassList &gt; Polygon</p>"},{"location":"BGFlood/classPolygon/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; Vertex &gt; vertices double xmax double xmin double ymax double ymin"},{"location":"BGFlood/classPolygon/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classPolygon/#variable-vertices","title":"variable vertices","text":"<pre><code>std::vector&lt;Vertex&gt; Polygon::vertices;\n</code></pre>"},{"location":"BGFlood/classPolygon/#variable-xmax","title":"variable xmax","text":"<pre><code>double Polygon::xmax;\n</code></pre>"},{"location":"BGFlood/classPolygon/#variable-xmin","title":"variable xmin","text":"<pre><code>double Polygon::xmin;\n</code></pre>"},{"location":"BGFlood/classPolygon/#variable-ymax","title":"variable ymax","text":"<pre><code>double Polygon::ymax;\n</code></pre>"},{"location":"BGFlood/classPolygon/#variable-ymin","title":"variable ymin","text":"<pre><code>double Polygon::ymin;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/classRiver/","title":"Class River","text":""},{"location":"BGFlood/classRiver/#class-river","title":"Class River","text":"<p>ClassList &gt; River</p>"},{"location":"BGFlood/classRiver/#public-attributes","title":"Public Attributes","text":"Type Name std::string Riverflowfile std::vector&lt; int &gt; block double disarea std::vector&lt; Flowin &gt; flowinput std::vector&lt; int &gt; i std::vector&lt; int &gt; j double tmax double to double xend double xstart double yend double ystart"},{"location":"BGFlood/classRiver/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classRiver/#variable-riverflowfile","title":"variable Riverflowfile","text":"<pre><code>std::string River::Riverflowfile;\n</code></pre>"},{"location":"BGFlood/classRiver/#variable-block","title":"variable block","text":"<pre><code>std::vector&lt;int&gt; River::block;\n</code></pre>"},{"location":"BGFlood/classRiver/#variable-disarea","title":"variable disarea","text":"<pre><code>double River::disarea;\n</code></pre>"},{"location":"BGFlood/classRiver/#variable-flowinput","title":"variable flowinput","text":"<pre><code>std::vector&lt;Flowin&gt; River::flowinput;\n</code></pre>"},{"location":"BGFlood/classRiver/#variable-i","title":"variable i","text":"<pre><code>std::vector&lt;int&gt; River::i;\n</code></pre>"},{"location":"BGFlood/classRiver/#variable-j","title":"variable j","text":"<pre><code>std::vector&lt;int&gt; River::j;\n</code></pre>"},{"location":"BGFlood/classRiver/#variable-tmax","title":"variable tmax","text":"<pre><code>double River::tmax;\n</code></pre>"},{"location":"BGFlood/classRiver/#variable-to","title":"variable to","text":"<pre><code>double River::to;\n</code></pre>"},{"location":"BGFlood/classRiver/#variable-xend","title":"variable xend","text":"<pre><code>double River::xend;\n</code></pre>"},{"location":"BGFlood/classRiver/#variable-xstart","title":"variable xstart","text":"<pre><code>double River::xstart;\n</code></pre>"},{"location":"BGFlood/classRiver/#variable-yend","title":"variable yend","text":"<pre><code>double River::yend;\n</code></pre>"},{"location":"BGFlood/classRiver/#variable-ystart","title":"variable ystart","text":"<pre><code>double River::ystart;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/structRiverBlk/","title":"Struct RiverBlk","text":""},{"location":"BGFlood/structRiverBlk/#struct-riverblk","title":"Struct RiverBlk","text":"<p>ClassList &gt; RiverBlk</p>"},{"location":"BGFlood/structRiverBlk/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; int &gt; block"},{"location":"BGFlood/structRiverBlk/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structRiverBlk/#variable-block","title":"variable block","text":"<pre><code>std::vector&lt;int&gt; RiverBlk::block;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/structRiverInfo/","title":"Struct RiverInfo","text":""},{"location":"BGFlood/structRiverInfo/#struct-riverinfo","title":"Struct RiverInfo","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; RiverInfo</p>"},{"location":"BGFlood/structRiverInfo/#public-attributes","title":"Public Attributes","text":"Type Name int * Xbidir int * Xridib int nbir int nburmax int nribmax T * qnow T * qnow_g T * xend T * xstart T * yend T * ystart"},{"location":"BGFlood/structRiverInfo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structRiverInfo/#variable-xbidir","title":"variable Xbidir","text":"<pre><code>int* RiverInfo&lt; T &gt;::Xbidir;\n</code></pre>"},{"location":"BGFlood/structRiverInfo/#variable-xridib","title":"variable Xridib","text":"<pre><code>int* RiverInfo&lt; T &gt;::Xridib;\n</code></pre>"},{"location":"BGFlood/structRiverInfo/#variable-nbir","title":"variable nbir","text":"<pre><code>int RiverInfo&lt; T &gt;::nbir;\n</code></pre>"},{"location":"BGFlood/structRiverInfo/#variable-nburmax","title":"variable nburmax","text":"<pre><code>int RiverInfo&lt; T &gt;::nburmax;\n</code></pre>"},{"location":"BGFlood/structRiverInfo/#variable-nribmax","title":"variable nribmax","text":"<pre><code>int RiverInfo&lt; T &gt;::nribmax;\n</code></pre>"},{"location":"BGFlood/structRiverInfo/#variable-qnow","title":"variable qnow","text":"<pre><code>T* RiverInfo&lt; T &gt;::qnow;\n</code></pre>"},{"location":"BGFlood/structRiverInfo/#variable-qnow_g","title":"variable qnow_g","text":"<pre><code>T* RiverInfo&lt; T &gt;::qnow_g;\n</code></pre>"},{"location":"BGFlood/structRiverInfo/#variable-xend","title":"variable xend","text":"<pre><code>T* RiverInfo&lt; T &gt;::xend;\n</code></pre>"},{"location":"BGFlood/structRiverInfo/#variable-xstart","title":"variable xstart","text":"<pre><code>T* RiverInfo&lt; T &gt;::xstart;\n</code></pre>"},{"location":"BGFlood/structRiverInfo/#variable-yend","title":"variable yend","text":"<pre><code>T* RiverInfo&lt; T &gt;::yend;\n</code></pre>"},{"location":"BGFlood/structRiverInfo/#variable-ystart","title":"variable ystart","text":"<pre><code>T* RiverInfo&lt; T &gt;::ystart;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/classSLTS/","title":"Class SLTS","text":""},{"location":"BGFlood/classSLTS/#class-slts","title":"Class SLTS","text":"<p>ClassList &gt; SLTS</p>"},{"location":"BGFlood/classSLTS/#public-attributes","title":"Public Attributes","text":"Type Name double time std::vector&lt; double &gt; uuvel std::vector&lt; double &gt; vvvel std::vector&lt; double &gt; wlevs"},{"location":"BGFlood/classSLTS/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classSLTS/#variable-time","title":"variable time","text":"<pre><code>double SLTS::time;\n</code></pre>"},{"location":"BGFlood/classSLTS/#variable-uuvel","title":"variable uuvel","text":"<pre><code>std::vector&lt;double&gt; SLTS::uuvel;\n</code></pre>"},{"location":"BGFlood/classSLTS/#variable-vvvel","title":"variable vvvel","text":"<pre><code>std::vector&lt;double&gt; SLTS::vvvel;\n</code></pre>"},{"location":"BGFlood/classSLTS/#variable-wlevs","title":"variable wlevs","text":"<pre><code>std::vector&lt;double&gt; SLTS::wlevs;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/structSharedMemory/","title":"Struct SharedMemory","text":""},{"location":"BGFlood/structSharedMemory/#struct-sharedmemory","title":"Struct SharedMemory","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; SharedMemory</p>"},{"location":"BGFlood/structSharedMemory/#public-functions","title":"Public Functions","text":"Type Name __device__ operator T* ()  __device__ operator const T * () const"},{"location":"BGFlood/structSharedMemory/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/structSharedMemory/#function-operator-t","title":"function operator T*","text":"<pre><code>inline __device__ SharedMemory::operator T* () \n</code></pre>"},{"location":"BGFlood/structSharedMemory/#function-operator-const-t","title":"function operator const T *","text":"<pre><code>inline __device__ SharedMemory::operator const T * () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Advection.cu</code></p>"},{"location":"BGFlood/structSharedMemory_3_01double_01_4/","title":"Struct SharedMemory&lt; double &gt;","text":""},{"location":"BGFlood/structSharedMemory_3_01double_01_4/#struct-sharedmemory-double","title":"Struct SharedMemory&lt; double &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; SharedMemory&lt; double &gt;</p>"},{"location":"BGFlood/structSharedMemory_3_01double_01_4/#public-functions","title":"Public Functions","text":"Type Name __device__ operator const double * () const __device__ operator double * ()"},{"location":"BGFlood/structSharedMemory_3_01double_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/structSharedMemory_3_01double_01_4/#function-operator-const-double","title":"function operator const double *","text":"<pre><code>inline __device__ SharedMemory&lt; double &gt;::operator const double * () const\n</code></pre>"},{"location":"BGFlood/structSharedMemory_3_01double_01_4/#function-operator-double","title":"function operator double *","text":"<pre><code>inline __device__ SharedMemory&lt; double &gt;::operator double * () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Advection.cu</code></p>"},{"location":"BGFlood/structStaticForcingP/","title":"Struct StaticForcingP","text":""},{"location":"BGFlood/structStaticForcingP/#struct-staticforcingp","title":"Struct StaticForcingP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; StaticForcingP</p> <p>Inherits the following classes: inputmap</p>"},{"location":"BGFlood/structStaticForcingP/#public-attributes","title":"Public Attributes","text":"Type Name T * val"},{"location":"BGFlood/structStaticForcingP/#public-attributes-inherited-from-inputmap","title":"Public Attributes inherited from inputmap","text":"<p>See inputmap</p> Type Name double denanval   = <code>NAN</code> double dx   = <code>0.0</code> double dy   = <code>0.0</code> std::string extension bool flipxx   = <code>false</code> bool flipyy   = <code>false</code> double grdalpha   = <code>0.0</code> std::string inputfile int nx   = <code>0</code> int ny   = <code>0</code> std::string varname double xmax   = <code>0.0</code> double xo   = <code>0.0</code> double ymax   = <code>0.0</code> double yo   = <code>0.0</code>"},{"location":"BGFlood/structStaticForcingP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structStaticForcingP/#variable-val","title":"variable val","text":"<pre><code>T* StaticForcingP&lt; T &gt;::val;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/classTSoutnode/","title":"Class TSoutnode","text":""},{"location":"BGFlood/classTSoutnode/#class-tsoutnode","title":"Class TSoutnode","text":"<p>ClassList &gt; TSoutnode</p>"},{"location":"BGFlood/classTSoutnode/#public-attributes","title":"Public Attributes","text":"Type Name int block int i int j std::string outname double x double y"},{"location":"BGFlood/classTSoutnode/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classTSoutnode/#variable-block","title":"variable block","text":"<pre><code>int TSoutnode::block;\n</code></pre>"},{"location":"BGFlood/classTSoutnode/#variable-i","title":"variable i","text":"<pre><code>int TSoutnode::i;\n</code></pre>"},{"location":"BGFlood/classTSoutnode/#variable-j","title":"variable j","text":"<pre><code>int TSoutnode::j;\n</code></pre>"},{"location":"BGFlood/classTSoutnode/#variable-outname","title":"variable outname","text":"<pre><code>std::string TSoutnode::outname;\n</code></pre>"},{"location":"BGFlood/classTSoutnode/#variable-x","title":"variable x","text":"<pre><code>double TSoutnode::x;\n</code></pre>"},{"location":"BGFlood/classTSoutnode/#variable-y","title":"variable y","text":"<pre><code>double TSoutnode::y;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/classT__output/","title":"Class T_output","text":""},{"location":"BGFlood/classT__output/#class-t_output","title":"Class T_output","text":"<p>ClassList &gt; T_output</p>"},{"location":"BGFlood/classT__output/#public-attributes","title":"Public Attributes","text":"Type Name double end   = <code>NAN</code> double init   = <code>NAN</code> std::vector&lt; std::string &gt; inputstr double tstep   = <code>NAN</code> std::vector&lt; double &gt; val"},{"location":"BGFlood/classT__output/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classT__output/#variable-end","title":"variable end","text":"<pre><code>double T_output::end;\n</code></pre>"},{"location":"BGFlood/classT__output/#variable-init","title":"variable init","text":"<pre><code>double T_output::init;\n</code></pre>"},{"location":"BGFlood/classT__output/#variable-inputstr","title":"variable inputstr","text":"<pre><code>std::vector&lt;std::string&gt; T_output::inputstr;\n</code></pre>"},{"location":"BGFlood/classT__output/#variable-tstep","title":"variable tstep","text":"<pre><code>double T_output::tstep;\n</code></pre>"},{"location":"BGFlood/classT__output/#variable-val","title":"variable val","text":"<pre><code>std::vector&lt;double&gt; T_output::val;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/structTexSetP/","title":"Struct TexSetP","text":""},{"location":"BGFlood/structTexSetP/#struct-texsetp","title":"Struct TexSetP","text":"<p>ClassList &gt; TexSetP</p>"},{"location":"BGFlood/structTexSetP/#public-attributes","title":"Public Attributes","text":"Type Name cudaArray * CudArr cudaChannelFormatDesc channelDesc   = <code>cudaCreateChannelDesc(32, 0, 0, 0, cudaChannelFormatKindFloat)</code> float dx float dy float nowvalue struct cudaResourceDesc resDesc cudaTextureObject_t tex   = <code>0</code> struct cudaTextureDesc texDesc bool uniform float xo float yo"},{"location":"BGFlood/structTexSetP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structTexSetP/#variable-cudarr","title":"variable CudArr","text":"<pre><code>cudaArray* TexSetP::CudArr;\n</code></pre>"},{"location":"BGFlood/structTexSetP/#variable-channeldesc","title":"variable channelDesc","text":"<pre><code>cudaChannelFormatDesc TexSetP::channelDesc;\n</code></pre>"},{"location":"BGFlood/structTexSetP/#variable-dx","title":"variable dx","text":"<pre><code>float TexSetP::dx;\n</code></pre>"},{"location":"BGFlood/structTexSetP/#variable-dy","title":"variable dy","text":"<pre><code>float TexSetP::dy;\n</code></pre>"},{"location":"BGFlood/structTexSetP/#variable-nowvalue","title":"variable nowvalue","text":"<pre><code>float TexSetP::nowvalue;\n</code></pre>"},{"location":"BGFlood/structTexSetP/#variable-resdesc","title":"variable resDesc","text":"<pre><code>struct cudaResourceDesc TexSetP::resDesc;\n</code></pre>"},{"location":"BGFlood/structTexSetP/#variable-tex","title":"variable tex","text":"<pre><code>cudaTextureObject_t TexSetP::tex;\n</code></pre>"},{"location":"BGFlood/structTexSetP/#variable-texdesc","title":"variable texDesc","text":"<pre><code>struct cudaTextureDesc TexSetP::texDesc;\n</code></pre>"},{"location":"BGFlood/structTexSetP/#variable-uniform","title":"variable uniform","text":"<pre><code>bool TexSetP::uniform;\n</code></pre>"},{"location":"BGFlood/structTexSetP/#variable-xo","title":"variable xo","text":"<pre><code>float TexSetP::xo;\n</code></pre>"},{"location":"BGFlood/structTexSetP/#variable-yo","title":"variable yo","text":"<pre><code>float TexSetP::yo;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/structTimeP/","title":"Struct TimeP","text":""},{"location":"BGFlood/structTimeP/#struct-timep","title":"Struct TimeP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; TimeP</p>"},{"location":"BGFlood/structTimeP/#public-attributes","title":"Public Attributes","text":"Type Name T * arrmax T * arrmin T dt T * dtmax T totaltime"},{"location":"BGFlood/structTimeP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structTimeP/#variable-arrmax","title":"variable arrmax","text":"<pre><code>T* TimeP&lt; T &gt;::arrmax;\n</code></pre>"},{"location":"BGFlood/structTimeP/#variable-arrmin","title":"variable arrmin","text":"<pre><code>T * TimeP&lt; T &gt;::arrmin;\n</code></pre>"},{"location":"BGFlood/structTimeP/#variable-dt","title":"variable dt","text":"<pre><code>T TimeP&lt; T &gt;::dt;\n</code></pre>"},{"location":"BGFlood/structTimeP/#variable-dtmax","title":"variable dtmax","text":"<pre><code>T* TimeP&lt; T &gt;::dtmax;\n</code></pre>"},{"location":"BGFlood/structTimeP/#variable-totaltime","title":"variable totaltime","text":"<pre><code>T TimeP&lt; T &gt;::totaltime;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/classVertex/","title":"Class Vertex","text":""},{"location":"BGFlood/classVertex/#class-vertex","title":"Class Vertex","text":"<p>ClassList &gt; Vertex</p>"},{"location":"BGFlood/classVertex/#public-attributes","title":"Public Attributes","text":"Type Name double x double y"},{"location":"BGFlood/classVertex/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classVertex/#variable-x","title":"variable x","text":"<pre><code>double Vertex::x;\n</code></pre>"},{"location":"BGFlood/classVertex/#variable-y","title":"variable y","text":"<pre><code>double Vertex::y;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/classWindin/","title":"Class Windin","text":""},{"location":"BGFlood/classWindin/#class-windin","title":"Class Windin","text":"<p>ClassList &gt; Windin</p>"},{"location":"BGFlood/classWindin/#public-attributes","title":"Public Attributes","text":"Type Name double time double uwind double vwind double wdirection double wspeed"},{"location":"BGFlood/classWindin/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classWindin/#variable-time","title":"variable time","text":"<pre><code>double Windin::time;\n</code></pre>"},{"location":"BGFlood/classWindin/#variable-uwind","title":"variable uwind","text":"<pre><code>double Windin::uwind;\n</code></pre>"},{"location":"BGFlood/classWindin/#variable-vwind","title":"variable vwind","text":"<pre><code>double Windin::vwind;\n</code></pre>"},{"location":"BGFlood/classWindin/#variable-wdirection","title":"variable wdirection","text":"<pre><code>double Windin::wdirection;\n</code></pre>"},{"location":"BGFlood/classWindin/#variable-wspeed","title":"variable wspeed","text":"<pre><code>double Windin::wspeed;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/structbndTexP/","title":"Struct bndTexP","text":""},{"location":"BGFlood/structbndTexP/#struct-bndtexp","title":"Struct bndTexP","text":"<p>ClassList &gt; bndTexP</p>"},{"location":"BGFlood/structbndTexP/#public-attributes","title":"Public Attributes","text":"Type Name TexSetP Uvel TexSetP Vvel TexSetP WLS"},{"location":"BGFlood/structbndTexP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structbndTexP/#variable-uvel","title":"variable Uvel","text":"<pre><code>TexSetP bndTexP::Uvel;\n</code></pre>"},{"location":"BGFlood/structbndTexP/#variable-vvel","title":"variable Vvel","text":"<pre><code>TexSetP bndTexP::Vvel;\n</code></pre>"},{"location":"BGFlood/structbndTexP/#variable-wls","title":"variable WLS","text":"<pre><code>TexSetP bndTexP::WLS;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/classbndparam/","title":"Class bndparam","text":""},{"location":"BGFlood/classbndparam/#class-bndparam","title":"Class bndparam","text":"<p>ClassList &gt; bndparam</p>"},{"location":"BGFlood/classbndparam/#public-attributes","title":"Public Attributes","text":"Type Name bndTexP GPU int * blks int * blks_g std::vector&lt; SLTS &gt; data std::string inputfile int isright   = <code>0</code> int istop   = <code>0</code> int nblk   = <code>0</code> int nbnd bool on   = <code>false</code> float * qmean float * qmean_g int side   = <code>0</code> int type   = <code>1</code>"},{"location":"BGFlood/classbndparam/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classbndparam/#variable-gpu","title":"variable GPU","text":"<pre><code>bndTexP bndparam::GPU;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-blks","title":"variable blks","text":"<pre><code>int* bndparam::blks;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-blks_g","title":"variable blks_g","text":"<pre><code>int* bndparam::blks_g;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-data","title":"variable data","text":"<pre><code>std::vector&lt;SLTS&gt; bndparam::data;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-inputfile","title":"variable inputfile","text":"<pre><code>std::string bndparam::inputfile;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-isright","title":"variable isright","text":"<pre><code>int bndparam::isright;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-istop","title":"variable istop","text":"<pre><code>int bndparam::istop;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-nblk","title":"variable nblk","text":"<pre><code>int bndparam::nblk;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-nbnd","title":"variable nbnd","text":"<pre><code>int bndparam::nbnd;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-on","title":"variable on","text":"<pre><code>bool bndparam::on;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-qmean","title":"variable qmean","text":"<pre><code>float* bndparam::qmean;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-qmean_g","title":"variable qmean_g","text":"<pre><code>float* bndparam::qmean_g;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-side","title":"variable side","text":"<pre><code>int bndparam::side;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-type","title":"variable type","text":"<pre><code>int bndparam::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/classbndsegment/","title":"Class bndsegment","text":""},{"location":"BGFlood/classbndsegment/#class-bndsegment","title":"Class bndsegment","text":"<p>ClassList &gt; bndsegment</p>"},{"location":"BGFlood/classbndsegment/#public-attributes","title":"Public Attributes","text":"Type Name DynForcingP&lt; float &gt; WLmap bndsegmentside bot std::vector&lt; Windin &gt; data std::string inputfile bndsegmentside left int nblk   = <code>0</code> int nbnd bool on   = <code>false</code> Polygon poly std::string polyfile bndsegmentside right bndsegmentside top int type   = <code>1</code> bool uniform   = <code>true</code>"},{"location":"BGFlood/classbndsegment/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classbndsegment/#variable-wlmap","title":"variable WLmap","text":"<pre><code>DynForcingP&lt;float&gt; bndsegment::WLmap;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-bot","title":"variable bot","text":"<pre><code>bndsegmentside bndsegment::bot;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-data","title":"variable data","text":"<pre><code>std::vector&lt;Windin&gt; bndsegment::data;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-inputfile","title":"variable inputfile","text":"<pre><code>std::string bndsegment::inputfile;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-left","title":"variable left","text":"<pre><code>bndsegmentside bndsegment::left;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-nblk","title":"variable nblk","text":"<pre><code>int bndsegment::nblk;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-nbnd","title":"variable nbnd","text":"<pre><code>int bndsegment::nbnd;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-on","title":"variable on","text":"<pre><code>bool bndsegment::on;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-poly","title":"variable poly","text":"<pre><code>Polygon bndsegment::poly;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-polyfile","title":"variable polyfile","text":"<pre><code>std::string bndsegment::polyfile;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-right","title":"variable right","text":"<pre><code>bndsegmentside bndsegment::right;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-top","title":"variable top","text":"<pre><code>bndsegmentside bndsegment::top;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-type","title":"variable type","text":"<pre><code>int bndsegment::type;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-uniform","title":"variable uniform","text":"<pre><code>bool bndsegment::uniform;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/classbndsegmentside/","title":"Class bndsegmentside","text":""},{"location":"BGFlood/classbndsegmentside/#class-bndsegmentside","title":"Class bndsegmentside","text":"<p>ClassList &gt; bndsegmentside</p>"},{"location":"BGFlood/classbndsegmentside/#public-attributes","title":"Public Attributes","text":"Type Name int * blk int * blk_g int isright   = <code>0</code> int istop   = <code>0</code> int nblk   = <code>0</code> float * qmean float * qmean_g"},{"location":"BGFlood/classbndsegmentside/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classbndsegmentside/#variable-blk","title":"variable blk","text":"<pre><code>int* bndsegmentside::blk;\n</code></pre>"},{"location":"BGFlood/classbndsegmentside/#variable-blk_g","title":"variable blk_g","text":"<pre><code>int* bndsegmentside::blk_g;\n</code></pre>"},{"location":"BGFlood/classbndsegmentside/#variable-isright","title":"variable isright","text":"<pre><code>int bndsegmentside::isright;\n</code></pre>"},{"location":"BGFlood/classbndsegmentside/#variable-istop","title":"variable istop","text":"<pre><code>int bndsegmentside::istop;\n</code></pre>"},{"location":"BGFlood/classbndsegmentside/#variable-nblk","title":"variable nblk","text":"<pre><code>int bndsegmentside::nblk;\n</code></pre>"},{"location":"BGFlood/classbndsegmentside/#variable-qmean","title":"variable qmean","text":"<pre><code>float* bndsegmentside::qmean;\n</code></pre>"},{"location":"BGFlood/classbndsegmentside/#variable-qmean_g","title":"variable qmean_g","text":"<pre><code>float* bndsegmentside::qmean_g;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/classdeformmap/","title":"Class deformmap","text":""},{"location":"BGFlood/classdeformmap/#class-deformmap","title":"Class deformmap","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; deformmap</p> <p>Inherits the following classes: inputmap</p>"},{"location":"BGFlood/classdeformmap/#public-attributes","title":"Public Attributes","text":"Type Name TexSetP GPU T clampedge   = <code>0.0</code> double duration   = <code>0.0</code> bool iscavity   = <code>false</code> double startime   = <code>0.0</code> T * val"},{"location":"BGFlood/classdeformmap/#public-attributes-inherited-from-inputmap","title":"Public Attributes inherited from inputmap","text":"<p>See inputmap</p> Type Name double denanval   = <code>NAN</code> double dx   = <code>0.0</code> double dy   = <code>0.0</code> std::string extension bool flipxx   = <code>false</code> bool flipyy   = <code>false</code> double grdalpha   = <code>0.0</code> std::string inputfile int nx   = <code>0</code> int ny   = <code>0</code> std::string varname double xmax   = <code>0.0</code> double xo   = <code>0.0</code> double ymax   = <code>0.0</code> double yo   = <code>0.0</code>"},{"location":"BGFlood/classdeformmap/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classdeformmap/#variable-gpu","title":"variable GPU","text":"<pre><code>TexSetP deformmap&lt; T &gt;::GPU;\n</code></pre>"},{"location":"BGFlood/classdeformmap/#variable-clampedge","title":"variable clampedge","text":"<pre><code>T deformmap&lt; T &gt;::clampedge;\n</code></pre>"},{"location":"BGFlood/classdeformmap/#variable-duration","title":"variable duration","text":"<pre><code>double deformmap&lt; T &gt;::duration;\n</code></pre>"},{"location":"BGFlood/classdeformmap/#variable-iscavity","title":"variable iscavity","text":"<pre><code>bool deformmap&lt; T &gt;::iscavity;\n</code></pre>"},{"location":"BGFlood/classdeformmap/#variable-startime","title":"variable startime","text":"<pre><code>double deformmap&lt; T &gt;::startime;\n</code></pre>"},{"location":"BGFlood/classdeformmap/#variable-val","title":"variable val","text":"<pre><code>T* deformmap&lt; T &gt;::val;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/classforcingmap/","title":"Class forcingmap","text":""},{"location":"BGFlood/classforcingmap/#class-forcingmap","title":"Class forcingmap","text":"<p>ClassList &gt; forcingmap</p> <p>Inherits the following classes: inputmap</p> <p>Inherited by the following classes: DynForcingP,  DynForcingP</p>"},{"location":"BGFlood/classforcingmap/#public-attributes","title":"Public Attributes","text":"Type Name TexSetP GPU double dt std::string inputfile int instep   = <code>0</code> double nowvalue int nt double tmax double to std::vector&lt; Windin &gt; unidata bool uniform   = <code>false</code>"},{"location":"BGFlood/classforcingmap/#public-attributes-inherited-from-inputmap","title":"Public Attributes inherited from inputmap","text":"<p>See inputmap</p> Type Name double denanval   = <code>NAN</code> double dx   = <code>0.0</code> double dy   = <code>0.0</code> std::string extension bool flipxx   = <code>false</code> bool flipyy   = <code>false</code> double grdalpha   = <code>0.0</code> std::string inputfile int nx   = <code>0</code> int ny   = <code>0</code> std::string varname double xmax   = <code>0.0</code> double xo   = <code>0.0</code> double ymax   = <code>0.0</code> double yo   = <code>0.0</code>"},{"location":"BGFlood/classforcingmap/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classforcingmap/#variable-gpu","title":"variable GPU","text":"<pre><code>TexSetP forcingmap::GPU;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-dt","title":"variable dt","text":"<pre><code>double forcingmap::dt;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-inputfile","title":"variable inputfile","text":"<pre><code>std::string forcingmap::inputfile;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-instep","title":"variable instep","text":"<pre><code>int forcingmap::instep;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-nowvalue","title":"variable nowvalue","text":"<pre><code>double forcingmap::nowvalue;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-nt","title":"variable nt","text":"<pre><code>int forcingmap::nt;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-tmax","title":"variable tmax","text":"<pre><code>double forcingmap::tmax;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-to","title":"variable to","text":"<pre><code>double forcingmap::to;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-unidata","title":"variable unidata","text":"<pre><code>std::vector&lt;Windin&gt; forcingmap::unidata;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-uniform","title":"variable uniform","text":"<pre><code>bool forcingmap::uniform;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/classinputmap/","title":"Class inputmap","text":""},{"location":"BGFlood/classinputmap/#class-inputmap","title":"Class inputmap","text":"<p>ClassList &gt; inputmap</p> <p>Inherited by the following classes: StaticForcingP,  deformmap,  forcingmap</p>"},{"location":"BGFlood/classinputmap/#public-attributes","title":"Public Attributes","text":"Type Name double denanval   = <code>NAN</code> double dx   = <code>0.0</code> double dy   = <code>0.0</code> std::string extension bool flipxx   = <code>false</code> bool flipyy   = <code>false</code> double grdalpha   = <code>0.0</code> std::string inputfile int nx   = <code>0</code> int ny   = <code>0</code> std::string varname double xmax   = <code>0.0</code> double xo   = <code>0.0</code> double ymax   = <code>0.0</code> double yo   = <code>0.0</code>"},{"location":"BGFlood/classinputmap/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classinputmap/#variable-denanval","title":"variable denanval","text":"<pre><code>double inputmap::denanval;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-dx","title":"variable dx","text":"<pre><code>double inputmap::dx;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-dy","title":"variable dy","text":"<pre><code>double inputmap::dy;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-extension","title":"variable extension","text":"<pre><code>std::string inputmap::extension;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-flipxx","title":"variable flipxx","text":"<pre><code>bool inputmap::flipxx;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-flipyy","title":"variable flipyy","text":"<pre><code>bool inputmap::flipyy;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-grdalpha","title":"variable grdalpha","text":"<pre><code>double inputmap::grdalpha;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-inputfile","title":"variable inputfile","text":"<pre><code>std::string inputmap::inputfile;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-nx","title":"variable nx","text":"<pre><code>int inputmap::nx;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-ny","title":"variable ny","text":"<pre><code>int inputmap::ny;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-varname","title":"variable varname","text":"<pre><code>std::string inputmap::varname;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-xmax","title":"variable xmax","text":"<pre><code>double inputmap::xmax;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-xo","title":"variable xo","text":"<pre><code>double inputmap::xo;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-ymax","title":"variable ymax","text":"<pre><code>double inputmap::ymax;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-yo","title":"variable yo","text":"<pre><code>double inputmap::yo;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/structmaskinfo/","title":"Struct maskinfo","text":""},{"location":"BGFlood/structmaskinfo/#struct-maskinfo","title":"Struct maskinfo","text":"<p>ClassList &gt; maskinfo</p>"},{"location":"BGFlood/structmaskinfo/#public-attributes","title":"Public Attributes","text":"Type Name int * blks int nblk   = <code>0</code> int * side int type   = <code>0</code>"},{"location":"BGFlood/structmaskinfo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structmaskinfo/#variable-blks","title":"variable blks","text":"<pre><code>int* maskinfo::blks;\n</code></pre>"},{"location":"BGFlood/structmaskinfo/#variable-nblk","title":"variable nblk","text":"<pre><code>int maskinfo::nblk;\n</code></pre>"},{"location":"BGFlood/structmaskinfo/#variable-side","title":"variable side","text":"<pre><code>int* maskinfo::side;\n</code></pre>"},{"location":"BGFlood/structmaskinfo/#variable-type","title":"variable type","text":"<pre><code>int maskinfo::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/structoutP/","title":"Struct outP","text":""},{"location":"BGFlood/structoutP/#struct-outp","title":"Struct outP","text":"<p>ClassList &gt; outP</p>"},{"location":"BGFlood/structoutP/#public-attributes","title":"Public Attributes","text":"Type Name int level double xmax double xmin double ymax double ymin float * z short * z_s"},{"location":"BGFlood/structoutP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structoutP/#variable-level","title":"variable level","text":"<pre><code>int outP::level;\n</code></pre>"},{"location":"BGFlood/structoutP/#variable-xmax","title":"variable xmax","text":"<pre><code>double outP::xmax;\n</code></pre>"},{"location":"BGFlood/structoutP/#variable-xmin","title":"variable xmin","text":"<pre><code>double outP::xmin;\n</code></pre>"},{"location":"BGFlood/structoutP/#variable-ymax","title":"variable ymax","text":"<pre><code>double outP::ymax;\n</code></pre>"},{"location":"BGFlood/structoutP/#variable-ymin","title":"variable ymin","text":"<pre><code>double outP::ymin;\n</code></pre>"},{"location":"BGFlood/structoutP/#variable-z","title":"variable z","text":"<pre><code>float* outP::z;\n</code></pre>"},{"location":"BGFlood/structoutP/#variable-z_s","title":"variable z_s","text":"<pre><code>short* outP::z_s;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/structoutzoneB/","title":"Struct outzoneB","text":""},{"location":"BGFlood/structoutzoneB/#struct-outzoneb","title":"Struct outzoneB","text":"<p>ClassList &gt; outzoneB</p>"},{"location":"BGFlood/structoutzoneB/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; double &gt; OutputT int * blk int index_next_OutputT   = <code>0</code> int maxlevel int minlevel int nblk std::string outname double xmax double xo double ymax double yo"},{"location":"BGFlood/structoutzoneB/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structoutzoneB/#variable-outputt","title":"variable OutputT","text":"<pre><code>std::vector&lt;double&gt; outzoneB::OutputT;\n</code></pre>"},{"location":"BGFlood/structoutzoneB/#variable-blk","title":"variable blk","text":"<pre><code>int* outzoneB::blk;\n</code></pre>"},{"location":"BGFlood/structoutzoneB/#variable-index_next_outputt","title":"variable index_next_OutputT","text":"<pre><code>int outzoneB::index_next_OutputT;\n</code></pre>"},{"location":"BGFlood/structoutzoneB/#variable-maxlevel","title":"variable maxlevel","text":"<pre><code>int outzoneB::maxlevel;\n</code></pre>"},{"location":"BGFlood/structoutzoneB/#variable-minlevel","title":"variable minlevel","text":"<pre><code>int outzoneB::minlevel;\n</code></pre>"},{"location":"BGFlood/structoutzoneB/#variable-nblk","title":"variable nblk","text":"<pre><code>int outzoneB::nblk;\n</code></pre>"},{"location":"BGFlood/structoutzoneB/#variable-outname","title":"variable outname","text":"<pre><code>std::string outzoneB::outname;\n</code></pre>"},{"location":"BGFlood/structoutzoneB/#variable-xmax","title":"variable xmax","text":"<pre><code>double outzoneB::xmax;\n</code></pre>"},{"location":"BGFlood/structoutzoneB/#variable-xo","title":"variable xo","text":"<pre><code>double outzoneB::xo;\n</code></pre>"},{"location":"BGFlood/structoutzoneB/#variable-ymax","title":"variable ymax","text":"<pre><code>double outzoneB::ymax;\n</code></pre>"},{"location":"BGFlood/structoutzoneB/#variable-yo","title":"variable yo","text":"<pre><code>double outzoneB::yo;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/classoutzoneP/","title":"Class outzoneP","text":""},{"location":"BGFlood/classoutzoneP/#class-outzonep","title":"Class outzoneP","text":"<p>ClassList &gt; outzoneP</p>"},{"location":"BGFlood/classoutzoneP/#public-attributes","title":"Public Attributes","text":"Type Name T_output Toutput std::string outname double xend double xstart double yend double ystart"},{"location":"BGFlood/classoutzoneP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classoutzoneP/#variable-toutput","title":"variable Toutput","text":"<pre><code>T_output outzoneP::Toutput;\n</code></pre>"},{"location":"BGFlood/classoutzoneP/#variable-outname","title":"variable outname","text":"<pre><code>std::string outzoneP::outname;\n</code></pre>"},{"location":"BGFlood/classoutzoneP/#variable-xend","title":"variable xend","text":"<pre><code>double outzoneP::xend;\n</code></pre>"},{"location":"BGFlood/classoutzoneP/#variable-xstart","title":"variable xstart","text":"<pre><code>double outzoneP::xstart;\n</code></pre>"},{"location":"BGFlood/classoutzoneP/#variable-yend","title":"variable yend","text":"<pre><code>double outzoneP::yend;\n</code></pre>"},{"location":"BGFlood/classoutzoneP/#variable-ystart","title":"variable ystart","text":"<pre><code>double outzoneP::ystart;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/namespaceutils/","title":"Namespace utils","text":""},{"location":"BGFlood/namespaceutils/#namespace-utils","title":"Namespace utils","text":"<p>Namespace List &gt; utils</p>"},{"location":"BGFlood/namespaceutils/#public-functions","title":"Public Functions","text":"Type Name __host__ __device__ const T &amp; max (const T &amp; a, const T &amp; b)  template __host__ __device__ const double &amp; max&lt; double &gt; (const double &amp; a, const double &amp; b)  template __host__ __device__ const float &amp; max&lt; float &gt; (const float &amp; a, const float &amp; b)  template __host__ __device__ const int &amp; max&lt; int &gt; (const int &amp; a, const int &amp; b)  __host__ __device__ const T &amp; min (const T &amp; a, const T &amp; b)  template __host__ __device__ const double &amp; min&lt; double &gt; (const double &amp; a, const double &amp; b)  template __host__ __device__ const float &amp; min&lt; float &gt; (const float &amp; a, const float &amp; b)  template __host__ __device__ const int &amp; min&lt; int &gt; (const int &amp; a, const int &amp; b)  __host__ __device__ const T &amp; nearest (const T &amp; a, const T &amp; b, const T &amp; c)  __host__ __device__ const T &amp; nearest (const T &amp; a, const T &amp; b)  template __host__ __device__ const double &amp; nearest&lt; double &gt; (const double &amp; a, const double &amp; b, const double &amp; c)  template __host__ __device__ const double &amp; nearest&lt; double &gt; (const double &amp; a, const double &amp; b)  template __host__ __device__ const float &amp; nearest&lt; float &gt; (const float &amp; a, const float &amp; b, const float &amp; c)  template __host__ __device__ const float &amp; nearest&lt; float &gt; (const float &amp; a, const float &amp; b)  template __host__ __device__ const int &amp; nearest&lt; int &gt; (const int &amp; a, const int &amp; b, const int &amp; c)  template __host__ __device__ const int &amp; nearest&lt; int &gt; (const int &amp; a, const int &amp; b)  __host__ __device__ T sq (T a)  template double __host__ __device__ sq&lt; double &gt; (double a)  template float __host__ __device__ sq&lt; float &gt; (float a)  template int __host__ __device__ sq&lt; int &gt; (int a)"},{"location":"BGFlood/namespaceutils/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/namespaceutils/#function-max","title":"function max","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ const T &amp; utils::max (\n    const T &amp; a,\n    const T &amp; b\n) \n</code></pre> <p>Generic max function </p>"},{"location":"BGFlood/namespaceutils/#function-max-double","title":"function max&lt; double &gt;","text":"<pre><code>template __host__ __device__ const double &amp; utils::max&lt; double &gt; (\n    const double &amp; a,\n    const double &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-max-float","title":"function max&lt; float &gt;","text":"<pre><code>template __host__ __device__ const float &amp; utils::max&lt; float &gt; (\n    const float &amp; a,\n    const float &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-max-int","title":"function max&lt; int &gt;","text":"<pre><code>template __host__ __device__ const int &amp; utils::max&lt; int &gt; (\n    const int &amp; a,\n    const int &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-min","title":"function min","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ const T &amp; utils::min (\n    const T &amp; a,\n    const T &amp; b\n) \n</code></pre> <p>Generic min function </p>"},{"location":"BGFlood/namespaceutils/#function-min-double","title":"function min&lt; double &gt;","text":"<pre><code>template __host__ __device__ const double &amp; utils::min&lt; double &gt; (\n    const double &amp; a,\n    const double &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-min-float","title":"function min&lt; float &gt;","text":"<pre><code>template __host__ __device__ const float &amp; utils::min&lt; float &gt; (\n    const float &amp; a,\n    const float &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-min-int","title":"function min&lt; int &gt;","text":"<pre><code>template __host__ __device__ const int &amp; utils::min&lt; int &gt; (\n    const int &amp; a,\n    const int &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-nearest","title":"function nearest","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ const T &amp; utils::nearest (\n    const T &amp; a,\n    const T &amp; b,\n    const T &amp; c\n) \n</code></pre> <p>Generic nearest value function with 3 parameter </p>"},{"location":"BGFlood/namespaceutils/#function-nearest_1","title":"function nearest","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ const T &amp; utils::nearest (\n    const T &amp; a,\n    const T &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-nearest-double","title":"function nearest&lt; double &gt;","text":"<pre><code>template __host__ __device__ const double &amp; utils::nearest&lt; double &gt; (\n    const double &amp; a,\n    const double &amp; b,\n    const double &amp; c\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-nearest-double_1","title":"function nearest&lt; double &gt;","text":"<pre><code>template __host__ __device__ const double &amp; utils::nearest&lt; double &gt; (\n    const double &amp; a,\n    const double &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-nearest-float","title":"function nearest&lt; float &gt;","text":"<pre><code>template __host__ __device__ const float &amp; utils::nearest&lt; float &gt; (\n    const float &amp; a,\n    const float &amp; b,\n    const float &amp; c\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-nearest-float_1","title":"function nearest&lt; float &gt;","text":"<pre><code>template __host__ __device__ const float &amp; utils::nearest&lt; float &gt; (\n    const float &amp; a,\n    const float &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-nearest-int","title":"function nearest&lt; int &gt;","text":"<pre><code>template __host__ __device__ const int &amp; utils::nearest&lt; int &gt; (\n    const int &amp; a,\n    const int &amp; b,\n    const int &amp; c\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-nearest-int_1","title":"function nearest&lt; int &gt;","text":"<pre><code>template __host__ __device__ const int &amp; utils::nearest&lt; int &gt; (\n    const int &amp; a,\n    const int &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-sq","title":"function sq","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T utils::sq (\n    T a\n) \n</code></pre> <p>Generic squaring function </p>"},{"location":"BGFlood/namespaceutils/#function-sq-double","title":"function sq&lt; double &gt;","text":"<pre><code>template double __host__ __device__ utils::sq&lt; double &gt; (\n    double a\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-sq-float","title":"function sq&lt; float &gt;","text":"<pre><code>template float __host__ __device__ utils::sq&lt; float &gt; (\n    float a\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-sq-int","title":"function sq&lt; int &gt;","text":"<pre><code>template int __host__ __device__ utils::sq&lt; int &gt; (\n    int a\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Util_CPU.cu</code></p>"},{"location":"BGFlood/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"Dir src","text":""},{"location":"BGFlood/dir_68267d1309a1af8e8297ef4c3efbcdba/#dir-src","title":"Dir src","text":"<p>FileList &gt; src</p>"},{"location":"BGFlood/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","title":"Files","text":"Type Name file AdaptCriteria.cu file AdaptCriteria.h file Adaptation.cu file Adaptation.h file Advection.cu file Advection.h file Arrays.h file BG_Flood.cu file BG_Flood.h file Boundary.cu file Boundary.h file ConserveElevation.cu file ConserveElevation.h file FlowCPU.cu file FlowCPU.h file FlowGPU.cu file FlowGPU.h file FlowMLGPU.cu file FlowMLGPU.h file Forcing.h file Friction.cu file Friction.h file General.h file Gradients.cu file Gradients.h file GridManip.cu file GridManip.h file Halo.cu file Halo.h file InitEvolv.cu file InitEvolv.h file InitialConditions.cu file InitialConditions.h file Input.h file Kurganov.cu file Kurganov.h file Mainloop.cu file Mainloop.h file Meanmax.cu file Meanmax.h file MemManagement.cu file MemManagement.h file Mesh.cu file Mesh.h file Multilayer.cu file Multilayer.h file Param.h file Poly.cu file Poly.h file ReadForcing.cu file ReadForcing.h file ReadInput.cu file ReadInput.h file Read_netcdf.cu file Read_netcdf.h file Reimann.cu file Reimann.h file Setup_GPU.cu file Setup_GPU.h file Spherical.cu file Spherical.h file Testing.cu file Testing.h file Updateforcing.cu file Updateforcing.h file Util_CPU.cu file Util_CPU.h file Write_netcdf.cu file Write_netcdf.h file Write_txtlog.cpp file Write_txtlog.h file utctime.cu file utctime.h <p>The documentation for this class was generated from the following file <code>src/</code></p>"},{"location":"BGFlood/AdaptCriteria_8cu/","title":"File AdaptCriteria.cu","text":""},{"location":"BGFlood/AdaptCriteria_8cu/#file-adaptcriteriacu","title":"File AdaptCriteria.cu","text":"<p>FileList &gt; src &gt; AdaptCriteria.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AdaptCriteria.h\"</code></li> </ul>"},{"location":"BGFlood/AdaptCriteria_8cu/#public-functions","title":"Public Functions","text":"Type Name int AdaptCriteria (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel)  template int AdaptCriteria&lt; double &gt; (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; XModel)  template int AdaptCriteria&lt; float &gt; (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; XModel)  int Thresholdcriteria (Param XParam, T threshold, T * z, BlockP&lt; T &gt; XBlock, bool * refine, bool * coarsen)  template int Thresholdcriteria&lt; double &gt; (Param XParam, double threshold, double * z, BlockP&lt; double &gt; XBlock, bool * refine, bool * coarsen)  template int Thresholdcriteria&lt; float &gt; (Param XParam, float threshold, float * z, BlockP&lt; float &gt; XBlock, bool * refine, bool * coarsen)  int inrangecriteria (Param XParam, T zmin, T zmax, T * z, BlockP&lt; T &gt; XBlock, bool * refine, bool * coarsen)  template int inrangecriteria&lt; double &gt; (Param XParam, double zmin, double zmax, double * z, BlockP&lt; double &gt; XBlock, bool * refine, bool * coarsen)  template int inrangecriteria&lt; float &gt; (Param XParam, float zmin, float zmax, float * z, BlockP&lt; float &gt; XBlock, bool * refine, bool * coarsen)  int targetlevelcriteria (Param XParam, StaticForcingP&lt; int &gt; targetlevelmap, BlockP&lt; T &gt; XBlock, bool * refine, bool * coarsen)  template int targetlevelcriteria&lt; double &gt; (Param XParam, StaticForcingP&lt; int &gt; targetlevelmap, BlockP&lt; double &gt; XBlock, bool * refine, bool * coarsen)  template int targetlevelcriteria&lt; float &gt; (Param XParam, StaticForcingP&lt; int &gt; targetlevelmap, BlockP&lt; float &gt; XBlock, bool * refine, bool * coarsen)"},{"location":"BGFlood/AdaptCriteria_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/AdaptCriteria_8cu/#function-adaptcriteria","title":"function AdaptCriteria","text":"<pre><code>template&lt;class T&gt;\nint AdaptCriteria (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/AdaptCriteria_8cu/#function-adaptcriteria-double","title":"function AdaptCriteria&lt; double &gt;","text":"<pre><code>template int AdaptCriteria&lt; double &gt; (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/AdaptCriteria_8cu/#function-adaptcriteria-float","title":"function AdaptCriteria&lt; float &gt;","text":"<pre><code>template int AdaptCriteria&lt; float &gt; (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/AdaptCriteria_8cu/#function-thresholdcriteria","title":"function Thresholdcriteria","text":"<pre><code>template&lt;class T&gt;\nint Thresholdcriteria (\n    Param XParam,\n    T threshold,\n    T * z,\n    BlockP &lt; T &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre>"},{"location":"BGFlood/AdaptCriteria_8cu/#function-thresholdcriteria-double","title":"function Thresholdcriteria&lt; double &gt;","text":"<pre><code>template int Thresholdcriteria&lt; double &gt; (\n    Param XParam,\n    double threshold,\n    double * z,\n    BlockP &lt; double &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre>"},{"location":"BGFlood/AdaptCriteria_8cu/#function-thresholdcriteria-float","title":"function Thresholdcriteria&lt; float &gt;","text":"<pre><code>template int Thresholdcriteria&lt; float &gt; (\n    Param XParam,\n    float threshold,\n    float * z,\n    BlockP &lt; float &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre>"},{"location":"BGFlood/AdaptCriteria_8cu/#function-inrangecriteria","title":"function inrangecriteria","text":"<pre><code>template&lt;class T&gt;\nint inrangecriteria (\n    Param XParam,\n    T zmin,\n    T zmax,\n    T * z,\n    BlockP &lt; T &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre>"},{"location":"BGFlood/AdaptCriteria_8cu/#function-inrangecriteria-double","title":"function inrangecriteria&lt; double &gt;","text":"<pre><code>template int inrangecriteria&lt; double &gt; (\n    Param XParam,\n    double zmin,\n    double zmax,\n    double * z,\n    BlockP &lt; double &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre>"},{"location":"BGFlood/AdaptCriteria_8cu/#function-inrangecriteria-float","title":"function inrangecriteria&lt; float &gt;","text":"<pre><code>template int inrangecriteria&lt; float &gt; (\n    Param XParam,\n    float zmin,\n    float zmax,\n    float * z,\n    BlockP &lt; float &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre>"},{"location":"BGFlood/AdaptCriteria_8cu/#function-targetlevelcriteria","title":"function targetlevelcriteria","text":"<pre><code>template&lt;class T&gt;\nint targetlevelcriteria (\n    Param XParam,\n    StaticForcingP &lt; int &gt; targetlevelmap,\n    BlockP &lt; T &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre>"},{"location":"BGFlood/AdaptCriteria_8cu/#function-targetlevelcriteria-double","title":"function targetlevelcriteria&lt; double &gt;","text":"<pre><code>template int targetlevelcriteria&lt; double &gt; (\n    Param XParam,\n    StaticForcingP &lt; int &gt; targetlevelmap,\n    BlockP &lt; double &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre>"},{"location":"BGFlood/AdaptCriteria_8cu/#function-targetlevelcriteria-float","title":"function targetlevelcriteria&lt; float &gt;","text":"<pre><code>template int targetlevelcriteria&lt; float &gt; (\n    Param XParam,\n    StaticForcingP &lt; int &gt; targetlevelmap,\n    BlockP &lt; float &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AdaptCriteria.cu</code></p>"},{"location":"BGFlood/AdaptCriteria_8cu_source/","title":"File AdaptCriteria.cu","text":""},{"location":"BGFlood/AdaptCriteria_8cu_source/#file-adaptcriteriacu","title":"File AdaptCriteria.cu","text":"<p>File List &gt; src &gt; AdaptCriteria.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"AdaptCriteria.h\"\n\n// Adaptation Criteria\ntemplate &lt;class T&gt; int AdaptCriteria(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel)\n{\n    int success = 0;\n    if (XParam.AdaptCrit.compare(\"Threshold\") == 0)\n    {\n        success = Thresholdcriteria(XParam, T(std::stod(XParam.Adapt_arg1)), XModel.OutputVarMap[XParam.Adapt_arg2], XModel.blocks, XModel.adapt.refine, XModel.adapt.coarsen);\n    }\n    if (XParam.AdaptCrit.compare(\"Inrange\") == 0)\n    {\n        success = inrangecriteria(XParam, T(std::stod(XParam.Adapt_arg1)), T(std::stod(XParam.Adapt_arg2)), XModel.OutputVarMap[XParam.Adapt_arg3], XModel.blocks, XModel.adapt.refine, XModel.adapt.coarsen);\n    }\n    if (XParam.AdaptCrit.compare(\"Targetlevel\") == 0)\n    {\n        for (int ig = 0; ig &lt; XForcing.targetadapt.size(); ig++)\n        {\n            targetlevelcriteria(XParam, XForcing.targetadapt[ig], XModel.blocks, XModel.adapt.refine, XModel.adapt.coarsen);\n        }\n    }\n    return success;\n}\ntemplate int AdaptCriteria&lt;float&gt;(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;float&gt; XModel);\ntemplate int AdaptCriteria&lt;double&gt;(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;double&gt; XModel);\n\n\ntemplate &lt;class T&gt; int Thresholdcriteria(Param XParam,T threshold, T* z, BlockP&lt;T&gt; XBlock, bool* refine, bool* coarsen)\n{\n    // Threshold criteria is a general form of wet dry criteria where esp is the threshold and h is the parameter tested\n    // Below is written as a wet dry analogy where wet is vlaue above threshold and dry is below\n\n\n    int success = 0;\n    //int i;\n\n    //Coarsen dry blocks and refine wet ones\n    //CPU version\n\n\n    // To start we assume all values are below the threshold\n    bool iswet = false;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        refine[ib] = false; // only refine if all are wet\n        coarsen[ib] = true; // always try to coarsen\n        iswet = false;\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(XParam, ix, iy, ib);\n                //(ix + XParam.halowidth) + (iy + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n\n                if (z[i] &gt; threshold)\n                {\n                    iswet = true;\n                }\n            }\n        }\n\n\n        refine[ib] = iswet;\n        coarsen[ib] = !iswet;\n\n        //printf(\"ib=%d; refibe[ib]=%s\\n\", ib, iswet ? \"true\" : \"false\");\n    }\n    return success;\n}\ntemplate  int Thresholdcriteria&lt;float&gt;(Param XParam, float threshold, float* z, BlockP&lt;float&gt; XBlock, bool* refine, bool* coarsen);\ntemplate  int Thresholdcriteria&lt;double&gt;(Param XParam, double threshold, double* z, BlockP&lt;double&gt; XBlock, bool* refine, bool* coarsen);\n\ntemplate&lt;class T&gt;\nint inrangecriteria(Param XParam, T zmin, T zmax, T* z, BlockP&lt;T&gt; XBlock, bool* refine, bool* coarsen)\n{\n    // First use a simple refining criteria: zb&gt;zmin &amp;&amp; zb&lt;zmax refine otherwise corasen\n    int success = 0;\n    //int i;\n\n\n    // To start \n    bool isinrange = false;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        refine[ib] = false; // only refine if zb is in range\n        coarsen[ib] = true; // always try to coarsen otherwise\n        isinrange = false;\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = (ix + XParam.halowidth) + (iy + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                if (z[i] &gt;= zmin &amp;&amp; z[i] &lt;= zmax)\n                {\n                    isinrange = true;\n                }\n            }\n        }\n\n\n        refine[ib] = isinrange;\n        coarsen[ib] = !isinrange;\n\n        //printf(\"ib=%d; refibe[ib]=%s\\n\", ib, iswet ? \"true\" : \"false\");\n    }\n    return success;\n}\ntemplate int inrangecriteria&lt;float&gt;(Param XParam, float zmin, float zmax, float* z, BlockP&lt;float&gt; XBlock, bool* refine, bool* coarsen);\ntemplate int inrangecriteria&lt;double&gt;(Param XParam, double zmin, double zmax, double* z, BlockP&lt;double&gt; XBlock, bool* refine, bool* coarsen);\n\ntemplate&lt;class T&gt;\nint targetlevelcriteria(Param XParam, StaticForcingP&lt;int&gt; targetlevelmap, BlockP&lt;T&gt; XBlock, bool* refine, bool* coarsen)\n{\n    int targetlevel;\n    bool uplevel, samelevel;\n    T delta, x, y;\n    int success = 0;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n\n        delta = T(calcres(XParam.dx, XBlock.level[ib]));\n\n        uplevel = false;\n        samelevel = false;\n\n        refine[ib] = false; // only refine if all are wet\n        coarsen[ib] = true; // always try to coarsen\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int n = memloc(XParam, ix, iy, ib);\n                x = T(XParam.xo) + XBlock.xo[ib] + T(ix) * delta;\n                y = T(XParam.yo) + XBlock.yo[ib] + T(iy) * delta;\n\n                targetlevel = int(round(interp2BUQ(x, y, targetlevelmap)));\n\n                if (targetlevel &gt; XBlock.level[ib])\n                {\n                    //printf(\"x=%f; y=%f; target=%d; level=%d\", x, y, targetlevel, XBlock.level[ib]);\n                    uplevel = true;\n\n                }\n                if (targetlevel == XBlock.level[ib])\n                {\n                    samelevel = true;\n\n                }\n\n\n            }\n        }\n\n        if (uplevel)\n        {\n            refine[ib] = true; // only refine if all are wet\n            coarsen[ib] = false;\n        }\n        else if (samelevel)\n        {\n            coarsen[ib] = false;\n        }\n\n    }\n    return success;\n}\ntemplate int targetlevelcriteria&lt;float&gt;(Param XParam, StaticForcingP&lt;int&gt; targetlevelmap, BlockP&lt;float&gt; XBlock, bool* refine, bool* coarsen);\ntemplate int targetlevelcriteria&lt;double&gt;(Param XParam, StaticForcingP&lt;int&gt; targetlevelmap, BlockP&lt;double&gt; XBlock, bool* refine, bool* coarsen);\n</code></pre>"},{"location":"BGFlood/AdaptCriteria_8h/","title":"File AdaptCriteria.h","text":""},{"location":"BGFlood/AdaptCriteria_8h/#file-adaptcriteriah","title":"File AdaptCriteria.h","text":"<p>FileList &gt; src &gt; AdaptCriteria.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Mesh.h\"</code></li> <li><code>#include \"Halo.h\"</code></li> <li><code>#include \"GridManip.h\"</code></li> </ul>"},{"location":"BGFlood/AdaptCriteria_8h/#public-functions","title":"Public Functions","text":"Type Name int AdaptCriteria (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel)  int Thresholdcriteria (Param XParam, T threshold, T * z, BlockP&lt; T &gt; XBlock, bool * refine, bool * coarsen)  int inrangecriteria (Param XParam, T zmin, T zmax, T * z, BlockP&lt; T &gt; XBlock, bool * refine, bool * coarsen)"},{"location":"BGFlood/AdaptCriteria_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/AdaptCriteria_8h/#function-adaptcriteria","title":"function AdaptCriteria","text":"<pre><code>template&lt;class T&gt;\nint AdaptCriteria (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/AdaptCriteria_8h/#function-thresholdcriteria","title":"function Thresholdcriteria","text":"<pre><code>template&lt;class T&gt;\nint Thresholdcriteria (\n    Param XParam,\n    T threshold,\n    T * z,\n    BlockP &lt; T &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre>"},{"location":"BGFlood/AdaptCriteria_8h/#function-inrangecriteria","title":"function inrangecriteria","text":"<pre><code>template&lt;class T&gt;\nint inrangecriteria (\n    Param XParam,\n    T zmin,\n    T zmax,\n    T * z,\n    BlockP &lt; T &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AdaptCriteria.h</code></p>"},{"location":"BGFlood/AdaptCriteria_8h_source/","title":"File AdaptCriteria.h","text":""},{"location":"BGFlood/AdaptCriteria_8h_source/#file-adaptcriteriah","title":"File AdaptCriteria.h","text":"<p>File List &gt; src &gt; AdaptCriteria.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ADAPTCRITERIA_H\n#define ADAPTCRITERIA_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"Mesh.h\"\n#include \"Halo.h\"\n#include \"GridManip.h\"\n\ntemplate &lt;class T&gt; int inrangecriteria(Param XParam, T zmin, T zmax, T* z, BlockP&lt;T&gt; XBlock, bool* refine, bool* coarsen);\ntemplate &lt;class T&gt; int Thresholdcriteria(Param XParam, T threshold, T* z, BlockP&lt;T&gt; XBlock, bool* refine, bool* coarsen);\ntemplate &lt;class T&gt; int AdaptCriteria(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel);\n\n\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/","title":"File Adaptation.cu","text":""},{"location":"BGFlood/Adaptation_8cu/#file-adaptationcu","title":"File Adaptation.cu","text":"<p>FileList &gt; src &gt; Adaptation.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Adaptation.h\"</code></li> </ul>"},{"location":"BGFlood/Adaptation_8cu/#public-functions","title":"Public Functions","text":"Type Name void Adapt (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; &amp; XModel)  void Adaptation (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; &amp; XModel)  template void Adaptation&lt; double &gt; (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; &amp; XModel)  template void Adaptation&lt; float &gt; (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; &amp; XModel)  void Adaptationcleanup (Param &amp; XParam, BlockP&lt; T &gt; &amp; XBlock, AdaptP &amp; XAdapt)  template void Adaptationcleanup&lt; double &gt; (Param &amp; XParam, BlockP&lt; double &gt; &amp; XBlock, AdaptP &amp; XAdapt)  template void Adaptationcleanup&lt; float &gt; (Param &amp; XParam, BlockP&lt; float &gt; &amp; XBlock, AdaptP &amp; XAdapt)  int AddBlocks (int nnewblk, Param &amp; XParam, Model&lt; T &gt; &amp; XModel)  template int AddBlocks&lt; double &gt; (int nnewblk, Param &amp; XParam, Model&lt; double &gt; &amp; XModel)  template int AddBlocks&lt; float &gt; (int nnewblk, Param &amp; XParam, Model&lt; float &gt; &amp; XModel)  int CalcAvailblk (Param &amp; XParam, BlockP&lt; T &gt; XBlock, AdaptP &amp; XAdapt)  template int CalcAvailblk&lt; double &gt; (Param &amp; XParam, BlockP&lt; double &gt; XBlock, AdaptP &amp; XAdapt)  template int CalcAvailblk&lt; float &gt; (Param &amp; XParam, BlockP&lt; float &gt; XBlock, AdaptP &amp; XAdapt)  void InitialAdaptation (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel)  template void InitialAdaptation&lt; double &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; double &gt; &amp; XModel)  template void InitialAdaptation&lt; float &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; float &gt; &amp; XModel)  bool checkBUQsanity (Param XParam, BlockP&lt; T &gt; XBlock)  template bool checkBUQsanity&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock)  template bool checkBUQsanity&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock)  bool checklevel (int ib, int levelib, int neighbourib, int levelneighbour)  bool checkneighbourdistance (double dx, int ib, int levelib, T blocko, int neighbourib, int levelneighbour, T neighbourblocko, bool rightortop)  int checkneighbourrefine (int neighbourib, int levelib, int levelneighbour, bool *&amp; refine, bool *&amp; coarsen)  void coarsen (Param XParam, BlockP&lt; T &gt; &amp; XBlock, AdaptP &amp; XAdapt, EvolvingP&lt; T &gt; XEvo, EvolvingP&lt; T &gt; &amp; XEv)  template void coarsen&lt; double &gt; (Param XParam, BlockP&lt; double &gt; &amp; XBlock, AdaptP &amp; XAdapt, EvolvingP&lt; double &gt; XEvo, EvolvingP&lt; double &gt; &amp; XEv)  template void coarsen&lt; float &gt; (Param XParam, BlockP&lt; float &gt; &amp; XBlock, AdaptP &amp; XAdapt, EvolvingP&lt; float &gt; XEvo, EvolvingP&lt; float &gt; &amp; XEv)  void refine (Param XParam, BlockP&lt; T &gt; &amp; XBlock, AdaptP &amp; XAdapt, EvolvingP&lt; T &gt; XEvo, EvolvingP&lt; T &gt; &amp; XEv)  template void refine&lt; double &gt; (Param XParam, BlockP&lt; double &gt; &amp; XBlock, AdaptP &amp; XAdapt, EvolvingP&lt; double &gt; XEvo, EvolvingP&lt; double &gt; &amp; XEv)  template void refine&lt; float &gt; (Param XParam, BlockP&lt; float &gt; &amp; XBlock, AdaptP &amp; XAdapt, EvolvingP&lt; float &gt; XEvo, EvolvingP&lt; float &gt; &amp; XEv)  bool refinesanitycheck (Param XParam, BlockP&lt; T &gt; XBlock, bool *&amp; refine, bool *&amp; coarsen)"},{"location":"BGFlood/Adaptation_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Adaptation_8cu/#function-adapt","title":"function Adapt","text":"<pre><code>template&lt;class T&gt;\nvoid Adapt (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-adaptation","title":"function Adaptation","text":"<pre><code>template&lt;class T&gt;\nvoid Adaptation (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-adaptation-double","title":"function Adaptation&lt; double &gt;","text":"<pre><code>template void Adaptation&lt; double &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-adaptation-float","title":"function Adaptation&lt; float &gt;","text":"<pre><code>template void Adaptation&lt; float &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-adaptationcleanup","title":"function Adaptationcleanup","text":"<pre><code>template&lt;class T&gt;\nvoid Adaptationcleanup (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-adaptationcleanup-double","title":"function Adaptationcleanup&lt; double &gt;","text":"<pre><code>template void Adaptationcleanup&lt; double &gt; (\n    Param &amp; XParam,\n    BlockP &lt; double &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-adaptationcleanup-float","title":"function Adaptationcleanup&lt; float &gt;","text":"<pre><code>template void Adaptationcleanup&lt; float &gt; (\n    Param &amp; XParam,\n    BlockP &lt; float &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-addblocks","title":"function AddBlocks","text":"<pre><code>template&lt;class T&gt;\nint AddBlocks (\n    int nnewblk,\n    Param &amp; XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-addblocks-double","title":"function AddBlocks&lt; double &gt;","text":"<pre><code>template int AddBlocks&lt; double &gt; (\n    int nnewblk,\n    Param &amp; XParam,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-addblocks-float","title":"function AddBlocks&lt; float &gt;","text":"<pre><code>template int AddBlocks&lt; float &gt; (\n    int nnewblk,\n    Param &amp; XParam,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-calcavailblk","title":"function CalcAvailblk","text":"<pre><code>template&lt;class T&gt;\nint CalcAvailblk (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; XBlock,\n    AdaptP &amp; XAdapt\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-calcavailblk-double","title":"function CalcAvailblk&lt; double &gt;","text":"<pre><code>template int CalcAvailblk&lt; double &gt; (\n    Param &amp; XParam,\n    BlockP &lt; double &gt; XBlock,\n    AdaptP &amp; XAdapt\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-calcavailblk-float","title":"function CalcAvailblk&lt; float &gt;","text":"<pre><code>template int CalcAvailblk&lt; float &gt; (\n    Param &amp; XParam,\n    BlockP &lt; float &gt; XBlock,\n    AdaptP &amp; XAdapt\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-initialadaptation","title":"function InitialAdaptation","text":"<pre><code>template&lt;class T&gt;\nvoid InitialAdaptation (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-initialadaptation-double","title":"function InitialAdaptation&lt; double &gt;","text":"<pre><code>template void InitialAdaptation&lt; double &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-initialadaptation-float","title":"function InitialAdaptation&lt; float &gt;","text":"<pre><code>template void InitialAdaptation&lt; float &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-checkbuqsanity","title":"function checkBUQsanity","text":"<pre><code>template&lt;class T&gt;\nbool checkBUQsanity (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-checkbuqsanity-double","title":"function checkBUQsanity&lt; double &gt;","text":"<pre><code>template bool checkBUQsanity&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-checkbuqsanity-float","title":"function checkBUQsanity&lt; float &gt;","text":"<pre><code>template bool checkBUQsanity&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-checklevel","title":"function checklevel","text":"<pre><code>bool checklevel (\n    int ib,\n    int levelib,\n    int neighbourib,\n    int levelneighbour\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-checkneighbourdistance","title":"function checkneighbourdistance","text":"<pre><code>template&lt;class T&gt;\nbool checkneighbourdistance (\n    double dx,\n    int ib,\n    int levelib,\n    T blocko,\n    int neighbourib,\n    int levelneighbour,\n    T neighbourblocko,\n    bool rightortop\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-checkneighbourrefine","title":"function checkneighbourrefine","text":"<pre><code>int checkneighbourrefine (\n    int neighbourib,\n    int levelib,\n    int levelneighbour,\n    bool *&amp; refine,\n    bool *&amp; coarsen\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-coarsen","title":"function coarsen","text":"<pre><code>template&lt;class T&gt;\nvoid coarsen (\n    Param XParam,\n    BlockP &lt; T &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt,\n    EvolvingP &lt; T &gt; XEvo,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-coarsen-double","title":"function coarsen&lt; double &gt;","text":"<pre><code>template void coarsen&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt,\n    EvolvingP &lt; double &gt; XEvo,\n    EvolvingP &lt; double &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-coarsen-float","title":"function coarsen&lt; float &gt;","text":"<pre><code>template void coarsen&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt,\n    EvolvingP &lt; float &gt; XEvo,\n    EvolvingP &lt; float &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-refine","title":"function refine","text":"<pre><code>template&lt;class T&gt;\nvoid refine (\n    Param XParam,\n    BlockP &lt; T &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt,\n    EvolvingP &lt; T &gt; XEvo,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-refine-double","title":"function refine&lt; double &gt;","text":"<pre><code>template void refine&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt,\n    EvolvingP &lt; double &gt; XEvo,\n    EvolvingP &lt; double &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-refine-float","title":"function refine&lt; float &gt;","text":"<pre><code>template void refine&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt,\n    EvolvingP &lt; float &gt; XEvo,\n    EvolvingP &lt; float &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8cu/#function-refinesanitycheck","title":"function refinesanitycheck","text":"<pre><code>template&lt;class T&gt;\nbool refinesanitycheck (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    bool *&amp; refine,\n    bool *&amp; coarsen\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Adaptation.cu</code></p>"},{"location":"BGFlood/Adaptation_8cu_source/","title":"File Adaptation.cu","text":""},{"location":"BGFlood/Adaptation_8cu_source/#file-adaptationcu","title":"File Adaptation.cu","text":"<p>File List &gt; src &gt; Adaptation.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Adaptation.h\"\n\n\n\ntemplate &lt;class T&gt; void Adaptation(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel)\n{\n    int oldnblk = 0;\n\n    int niteration = 0;\n\n    int maxiteration = XParam.adaptmaxiteration;\n    //fillHalo(XParam, XModel.blocks, XModel.evolv_o);\n    //fillCorners(XParam, XModel.blocks, XModel.evolv_o);\n    if (XParam.maxlevel != XParam.minlevel)\n    {\n        while (oldnblk != XParam.nblk &amp;&amp; niteration&lt; maxiteration)\n        {\n            niteration++;\n            log(\"\\t Iteration \" + std::to_string(niteration));\n            // Fill halo and corners\n            fillHalo(XParam, XModel.blocks, XModel.evolv_o);\n            fillCorners(XParam, XModel.blocks, XModel.evolv_o);\n\n\n            oldnblk = XParam.nblk;\n            //wetdrycriteria(XParam, refine, coarsen);\n            //inrangecriteria(XParam, (T)-5.2, (T)0.2, XModel.zb, XModel.blocks, XModel.adapt.refine, XModel.adapt.coarsen);\n            AdaptCriteria(XParam, XForcing, XModel);\n            refinesanitycheck(XParam, XModel.blocks, XModel.adapt.refine, XModel.adapt.coarsen);\n            //XParam = adapt(XParam);\n            Adapt(XParam, XForcing, XModel);\n\n\n            if (!checkBUQsanity(XParam,XModel.blocks))\n            {\n\n                XParam.outfile = \"Bad_mesh.nc\";\n                log(\"\\tERROR!!!  Bad BUQ mesh layout! See file: \"+ XParam.outfile);\n                copyID2var(XParam, XModel.blocks, XModel.flux.Fhu);\n                copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.LeftBot, XModel.grad.dhdx);\n                copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.LeftTop, XModel.grad.dhdy);\n                copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.TopLeft, XModel.grad.dzsdx);\n                copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.TopRight, XModel.grad.dzsdy);\n                copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.RightTop, XModel.grad.dudx);\n                copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.RightBot, XModel.grad.dudy);\n                copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.BotRight, XModel.grad.dvdx);\n                copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.BotLeft, XModel.grad.dvdy);\n\n                creatncfileBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, XModel.blocks.outZone[0]);\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"blockID\", 3, XModel.flux.Fhu, XModel.blocks.outZone[0]);\n\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"LeftBot\", 3, XModel.grad.dhdx, XModel.blocks.outZone[0]);\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"LeftTop\", 3, XModel.grad.dhdy, XModel.blocks.outZone[0]);\n\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"TopLeft\", 3, XModel.grad.dzsdx, XModel.blocks.outZone[0]);\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"TopRight\", 3, XModel.grad.dzsdy, XModel.blocks.outZone[0]);\n\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"RightTop\", 3, XModel.grad.dudx, XModel.blocks.outZone[0]);\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"RightBot\", 3, XModel.grad.dudy, XModel.blocks.outZone[0]);\n\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"BotLeft\", 3, XModel.grad.dvdx, XModel.blocks.outZone[0]);\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"BotRight\", 3, XModel.grad.dvdy, XModel.blocks.outZone[0]);\n                exit(2);\n                break;\n            }\n\n\n        }\n        //=====================================\n        // Initialise Friction map\n\n        if (!XForcing.cf.empty())\n        {\n            interp2BUQ(XParam, XModel.blocks, XForcing.cf, XModel.cf);\n        }\n        else\n        {\n            InitArrayBUQ(XParam, XModel.blocks, (T)XParam.cf, XModel.cf);\n        }\n        // Set edges of friction map\n        setedges(XParam, XModel.blocks, XModel.cf);\n\n        //=====================================\n        // Initialise the continuous losses map\n        if (XParam.infiltration)\n        {\n            if (!XForcing.il.inputfile.empty())\n            {\n                interp2BUQ(XParam, XModel.blocks, XForcing.il, XModel.il);\n            }\n            else\n            {\n                InitArrayBUQ(XParam, XModel.blocks, (T)XParam.il, XModel.il);\n            }\n            if (!XForcing.cl.inputfile.empty())\n            {\n                interp2BUQ(XParam, XModel.blocks, XForcing.cl, XModel.cl);\n            }\n            else\n            {\n                InitArrayBUQ(XParam, XModel.blocks, (T)XParam.cl, XModel.cl);\n            }\n            // Set edges of friction map\n            setedges(XParam, XModel.blocks, XModel.il);\n            setedges(XParam, XModel.blocks, XModel.cl);\n        }\n\n    }\n}\ntemplate void Adaptation&lt;float&gt;(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;float&gt;&amp; XModel);\ntemplate void Adaptation&lt;double&gt;(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;double&gt;&amp; XModel);\n\n//Initial adaptation also reruns initial conditions\ntemplate &lt;class T&gt; void InitialAdaptation(Param&amp; XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;T&gt;&amp; XModel)\n{\n    if (XParam.maxlevel != XParam.minlevel)\n    {\n        log(\"Adapting mesh\");\n        Adaptation(XParam, XForcing, XModel);\n\n\n        InitialConditions(XParam, XForcing, XModel);\n\n\n\n    }\n}\ntemplate void InitialAdaptation&lt;float&gt;(Param&amp; XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;float&gt;&amp; XModel);\ntemplate void InitialAdaptation&lt;double&gt;(Param&amp; XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;double&gt;&amp; XModel);\n\n\ntemplate &lt;class T&gt; bool refinesanitycheck(Param XParam, BlockP&lt;T&gt; XBlock,  bool*&amp; refine, bool*&amp; coarsen)\n{\n    // Can't actually refine if the level is the max level (i.e. finest)\n    // this may be over-ruled later on\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        if (refine[ib] == true &amp;&amp; XBlock.level[ib] == XParam.maxlevel)\n        {\n            refine[ib] = false;\n            //printf(\"ib=%d; level[ib]=%d\\n\", ib, level[ib]);\n        }\n        if (coarsen[ib] == true &amp;&amp; XBlock.level[ib] == XParam.minlevel)\n        {\n            coarsen[ib] = false;\n        }\n        // Warning, Here cancelling all coasening because of a bug\n        // This could become an option for optimising the refinment process ??\n        coarsen[ib] = false;\n    }\n\n\n    // Can't corasen if any of your direct neighbour refines\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        if (refine[ib] == true)\n        {\n            //Can probably get away with checking only the principal 4 ?\n            coarsen[XBlock.RightBot[ib]] = false;\n            coarsen[XBlock.RightTop[ib]] = false;\n            coarsen[XBlock.LeftBot[ib]] = false;\n            coarsen[XBlock.LeftTop[ib]] = false;\n            coarsen[XBlock.TopLeft[ib]] = false;\n            coarsen[XBlock.TopRight[ib]] = false;\n            coarsen[XBlock.BotLeft[ib]] = false;\n            coarsen[XBlock.BotRight[ib]] = false;\n        }\n    }\n\n    // Can't coarsen if any neighbours have a higher level\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        if (coarsen[ib] == true)\n        {\n            int levi = XBlock.level[ib];\n            //printf(\"ib=%d; leftblk[ib]=%d; rightblk[ib]=%d, topblk[ib]=%d, botblk[ib]=%d\\n\", ib, leftblk[ib], rightblk[ib], topblk[ib], botblk[ib]);\n            if (levi &lt; XBlock.level[XBlock.LeftBot[ib]] ||  levi &lt; XBlock.level[XBlock.RightBot[ib]] || levi &lt; XBlock.level[XBlock.TopLeft[ib]] || levi &lt; XBlock.level[XBlock.BotLeft[ib]])\n            {\n                coarsen[ib] = false;\n            }\n        }\n    }\n\n\n    //check whether neighbour need refinement because they are too coarse to allow one to refine\n    // This below could be cascading so need to iterate several time\n    int iter = 1;\n\n    while (iter &gt; 0)\n    {\n        iter = 0;\n\n\n\n        for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n        {\n            int ib = XBlock.active[ibl];\n\n\n            if (refine[ib] == true)\n            {\n                iter += checkneighbourrefine(XBlock.TopLeft[ib], XBlock.level[ib], XBlock.level[XBlock.TopLeft[ib]], refine, coarsen);\n                //iter += checkneighbourrefine(XBlock.TopRight[ib], XBlock.level[ib], XBlock.level[XBlock.TopRight[ib]], refine, coarsen);\n                iter += checkneighbourrefine(XBlock.BotLeft[ib], XBlock.level[ib], XBlock.level[XBlock.BotLeft[ib]], refine, coarsen);\n                //iter += checkneighbourrefine(XBlock.BotRight[ib], XBlock.level[ib], XBlock.level[XBlock.BotRight[ib]], refine, coarsen);\n                iter += checkneighbourrefine(XBlock.LeftBot[ib], XBlock.level[ib], XBlock.level[XBlock.LeftBot[ib]], refine, coarsen);\n                //iter += checkneighbourrefine(XBlock.LeftTop[ib], XBlock.level[ib], XBlock.level[XBlock.LeftTop[ib]], refine, coarsen);\n                iter += checkneighbourrefine(XBlock.RightBot[ib], XBlock.level[ib], XBlock.level[XBlock.RightBot[ib]], refine, coarsen);\n                //iter += checkneighbourrefine(XBlock.RightTop[ib], XBlock.level[ib], XBlock.level[XBlock.RightTop[ib]], refine, coarsen);\n\n            }\n\n        }\n    }\n\n\n\n\n    // Can't actually coarsen if top, right and topright block are not all corsen\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n\n        //printf(\"ib=%d\\n\", ib);\n        // if all the neighbour are not wet then coarsen if possible\n        double dxfac = calcres(XParam.dx, XBlock.level[ib]);\n        //printf(\"blockxo_d[ib]=%f, dxfac=%f, ((blx-xo)/dx)%2=%d\\n\", blockxo_d[ib], dxfac, (int((blockxo_d[ib] - XParam.xo) / dxfac / XParam.blkwidth) % 2));\n        //only check for coarsening if the block analysed is a lower left corner block of the lower level\n        //need to prevent coarsenning if the block is on the model edges...\n        //((int((blockxo_d[ib] - XParam.xo) / dxfac) % 2) == 0 &amp;&amp; (int((blockyo_d[ib] - XParam.yo) / dxfac) % 2) == 0) &amp;&amp; rightblk[ib] != ib &amp;&amp; topblk[ib] != ib &amp;&amp; rightblk[topblk[ib]] != topblk[ib]\n        if (coarsen[ib] == true)\n        {\n            //if this block is a lower left corner block of teh potentialy coarser block\n            if (((int((XBlock.xo[ib]) / dxfac / XParam.blkwidth) % 2) == 0 &amp;&amp; (int((XBlock.yo[ib]) / dxfac / XParam.blkwidth) % 2) == 0 &amp;&amp; XBlock.RightBot[ib] != ib &amp;&amp;  XBlock.TopLeft[ib] != ib &amp;&amp; XBlock.RightBot[XBlock.TopRight[ib]] != XBlock.TopRight[ib]))\n            {\n                //if all the neighbour blocks ar at the same level\n                if (XBlock.level[ib] == XBlock.level[XBlock.RightBot[ib]] &amp;&amp; XBlock.level[ib] == XBlock.level[XBlock.TopLeft[ib]] &amp;&amp; XBlock.level[ib] == XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]])\n                {\n                    //printf(\"Is it true?\\t\");\n                    //if right, top and topright block teh same level and can coarsen\n                    if (coarsen[XBlock.RightBot[ib]] == true &amp;&amp; coarsen[XBlock.TopLeft[ib]] == true &amp;&amp; coarsen[XBlock.RightBot[XBlock.TopRight[ib]]] == true)\n                    {\n                        //Yes\n                        //printf(\"Yes!\\n\");\n                        //coarsen[ib] = true;\n                    }\n                    else\n                    {\n                        coarsen[ib] = false;\n                    }\n                }\n                else\n                {\n                    coarsen[ib] = false;\n                }\n\n            }\n            else\n            {\n                coarsen[ib] = false;\n            }\n        }\n\n    }\n    return true;\n}\n\n\nint checkneighbourrefine(int neighbourib,int levelib, int levelneighbour, bool*&amp; refine, bool*&amp; coarsen)\n{\n    int iter = 0;\n    if (refine[neighbourib] == false &amp;&amp; (levelneighbour &lt; levelib))\n    {\n        refine[neighbourib] = true;\n        coarsen[neighbourib] = false;\n        iter++;\n    }\n    if (levelneighbour == levelib)\n    {\n        coarsen [neighbourib]= false;\n    }\n    return iter;\n}\n\ntemplate &lt;class T&gt; bool checkBUQsanity(Param XParam,BlockP&lt;T&gt; XBlock)\n{\n    bool check = true;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        int nib;\n        // check that levels are consistent\n        check = check &amp;&amp; checklevel(ib, XBlock.level[ib], XBlock.LeftBot[ib], XBlock.level[XBlock.LeftBot[ib]]);\n        check = check &amp;&amp; checklevel(ib, XBlock.level[ib], XBlock.LeftTop[ib], XBlock.level[XBlock.LeftTop[ib]]);\n\n        check = check &amp;&amp; checklevel(ib, XBlock.level[ib], XBlock.TopLeft[ib], XBlock.level[XBlock.TopLeft[ib]]);\n        check = check &amp;&amp; checklevel(ib, XBlock.level[ib], XBlock.TopRight[ib], XBlock.level[XBlock.TopRight[ib]]);\n\n        check = check &amp;&amp; checklevel(ib, XBlock.level[ib], XBlock.RightTop[ib], XBlock.level[XBlock.RightTop[ib]]);\n        check = check &amp;&amp; checklevel(ib, XBlock.level[ib], XBlock.RightBot[ib], XBlock.level[XBlock.RightBot[ib]]);\n\n        check = check &amp;&amp; checklevel(ib, XBlock.level[ib], XBlock.BotRight[ib], XBlock.level[XBlock.BotRight[ib]]);\n        check = check &amp;&amp; checklevel(ib, XBlock.level[ib], XBlock.BotLeft[ib], XBlock.level[XBlock.BotLeft[ib]]);\n\n        //check that neighbour distance makes sense with level\n        nib = XBlock.LeftBot[ib];\n        check = check &amp;&amp; checkneighbourdistance(XParam.dx, ib, XBlock.level[ib], XBlock.xo[ib], nib, XBlock.level[nib], XBlock.xo[nib], false);\n        nib = XBlock.LeftTop[ib];\n        check = check &amp;&amp; checkneighbourdistance(XParam.dx, ib, XBlock.level[ib], XBlock.xo[ib], nib, XBlock.level[nib], XBlock.xo[nib], false);\n\n        nib = XBlock.RightTop[ib];\n        check = check &amp;&amp; checkneighbourdistance(XParam.dx, ib, XBlock.level[ib], XBlock.xo[ib], nib, XBlock.level[nib], XBlock.xo[nib], true);\n        nib = XBlock.RightBot[ib];\n        check = check &amp;&amp; checkneighbourdistance(XParam.dx, ib, XBlock.level[ib], XBlock.xo[ib], nib, XBlock.level[nib], XBlock.xo[nib], true);\n\n        nib = XBlock.TopRight[ib];\n        check = check &amp;&amp; checkneighbourdistance(XParam.dx, ib, XBlock.level[ib], XBlock.yo[ib], nib, XBlock.level[nib], XBlock.yo[nib], true);\n        nib = XBlock.TopLeft[ib];\n        check = check &amp;&amp; checkneighbourdistance(XParam.dx, ib, XBlock.level[ib], XBlock.yo[ib], nib, XBlock.level[nib], XBlock.yo[nib], true);\n\n        nib = XBlock.BotLeft[ib];\n        check = check &amp;&amp; checkneighbourdistance(XParam.dx, ib, XBlock.level[ib], XBlock.yo[ib], nib, XBlock.level[nib], XBlock.yo[nib], false);\n        nib = XBlock.BotRight[ib];\n        check = check &amp;&amp; checkneighbourdistance(XParam.dx, ib, XBlock.level[ib], XBlock.yo[ib], nib, XBlock.level[nib], XBlock.yo[nib], false);\n    }\n\n    return check;\n\n}\ntemplate bool checkBUQsanity&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock);\ntemplate bool checkBUQsanity&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock);\n\nbool checklevel(int ib, int levelib, int neighbourib, int levelneighbour)\n{\n    bool check = true;\n    if (abs(levelneighbour - (levelib)) &gt; 1)\n    {\n        log(\"Warning! Bad Neighbour Level. ib=\"+std::to_string(ib)+\"; level[ib]=\"+ std::to_string(levelib)+\"; neighbour[ib]=\"+ std::to_string(neighbourib) +\"; level[neighbour[ib]]=\"+ std::to_string(levelneighbour));\n        check = false;\n    }\n    return check;\n}\n\ntemplate &lt;class T&gt; bool checkneighbourdistance(double dx, int ib, int levelib, T blocko, int neighbourib, int levelneighbour, T neighbourblocko, bool rightortop )\n{\n    T expecteddistance= blocko;\n    bool test;\n    if (neighbourib != ib)\n    {\n        if (rightortop)\n        {\n            expecteddistance = blocko + calcres(T(dx), levelib) * T(15.5) + T(0.5) * calcres(T(dx), levelneighbour);\n        }\n        else\n        {\n            expecteddistance = blocko - calcres(T(dx), levelib) * T(0.5) - T(15.5) * calcres(T(dx), levelneighbour);\n        }\n\n    }\n\n    test= abs(expecteddistance - neighbourblocko) &lt; (calcres(T(dx), levelib) * 0.01);\n    if (!test)\n    {\n        log(\"Warning! Bad Neighbour distance. ib=\" + std::to_string(ib) + \"; level[ib]=\" + std::to_string(levelib) + \"; neighbour[ib]=\" + std::to_string(neighbourib) + \"; level[neighbour[ib]]=\" + std::to_string(levelneighbour));\n    }\n\n    return test;\n\n}\n\n\n\ntemplate &lt;class T&gt; void Adapt(Param &amp;XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel)\n{\n    int nnewblk = CalcAvailblk(XParam, XModel.blocks, XModel.adapt);\n\n    // Check if there are enough available block to refin \n    if (nnewblk &gt; XParam.navailblk)\n    {\n        //Reallocate\n        int nblkmem=AddBlocks(nnewblk, XParam, XModel);\n\n        log(\"\\t\\tReallocation complete: \"+std::to_string(XParam.navailblk)+\" new blocks are available ( \"+std::to_string(nblkmem)+\" blocks in memory) \");\n    }\n    //===========================================================\n    //  Start coarsening and refinement\n    // First Initialise newlevel (Do this every time because new level is reused later)\n\n    for (int ibl = 0; ibl &lt; XParam.nblkmem; ibl++)\n    {\n        // Set newlevel\n        XModel.adapt.newlevel[ibl] = XModel.blocks.level[ibl];\n    }\n\n    //=========================================================\n    //  COARSEN\n    coarsen(XParam, XModel.blocks, XModel.adapt, XModel.evolv_o, XModel.evolv);\n\n    //=========================================================\n    //  REFINE\n    refine(XParam, XModel.blocks, XModel.adapt, XModel.evolv_o, XModel.evolv);\n\n    //=========================================================\n    // CLEAN-UP\n    Adaptationcleanup(XParam, XModel.blocks, XModel.adapt);\n\n    //____________________________________________________\n    //\n    //  Reinterpolate zb. \n    //\n    //  Isn't it better to do that only for newly refined blk?\n    //  Not necessary if no coarsening/refinement occur\n    interp2BUQ(XParam, XModel.blocks, XForcing.Bathy, XModel.zb);\n\n    // Set edges\n    setedges(XParam, XModel.blocks, XModel.zb);\n\n    //____________________________________________________\n    //\n    //  Update hh and or zb\n    //\n    //  Recalculate hh from zs for fully wet cells and zs from zb for dry cells\n    //\n\n    // Because zb cannot be conserved through the refinement or coarsening\n    // We have to decide whtether to conserve elevation (zs) or Volume (hh)\n    // \n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam,ix,iy,ib);\n\n                if (XModel.evolv.h[i] &gt; XParam.eps)\n                {\n                    XModel.evolv.h[i] = max((T)XParam.eps, XModel.evolv.zs[i] - XModel.zb[i]);\n                }\n                else\n                {\n                    // when refining dry area zs should be zb!\n                    XModel.evolv.zs[i] = XModel.zb[i];\n                }\n\n\n\n            }\n        }\n    }\n\n    //copy back hh and zs to hho and zso\n    CopyArrayBUQ(XParam, XModel.blocks, XModel.evolv, XModel.evolv_o);\n\n}\n\ntemplate &lt;class T&gt; int CalcAvailblk(Param &amp;XParam, BlockP&lt;T&gt; XBlock, AdaptP&amp; XAdapt)\n{\n    //\n\n    int csum = -3;\n    int nrefineblk = 0;\n    int ncoarsenlk = 0;\n    int nnewblk = 0;\n\n    for (int ibl = 0; ibl &lt; XParam.nblkmem; ibl++)\n    {\n        XAdapt.invactive[ibl] = -1;\n\n\n    }\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        XAdapt.invactive[ib] = ibl;\n\n        // When refining we need csum\n        if (XAdapt.refine[ib] == true)\n        {\n            nrefineblk++;\n            csum = csum + 3;\n\n        }\n        if (XAdapt.coarsen[ib] == true)\n        {\n            ncoarsenlk++;\n\n\n        }\n        XAdapt.csumblk[ib] = csum;\n    }\n\n    //=========================================\n    //  Reconstruct availblk\n    XParam.navailblk = 0;\n    for (int ibl = 0; ibl &lt; XParam.nblkmem; ibl++)\n    {\n        if (XAdapt.invactive[ibl] == -1)\n        {\n            XAdapt.availblk[XParam.navailblk] = ibl;\n            XParam.navailblk++;\n        }\n\n    }\n\n    // How many new block are needed\n    // This below would be ideal but I don't see how that could work.\n    // One issue is to make the newly coarsen blocks directly available in the section above but that would make the code even more confusingalthough we haven't taken them into account in the \n    //nnewblk = 3*nrefineblk - ncoarsenlk*3;\n    // Below is conservative and keeps the peice of code above a bit more simple\n    nnewblk = 3 * nrefineblk;\n\n    log(\"\\t\\tThere are \"+ std::to_string(XParam.nblk) +\" active blocks (\"+ std::to_string(XParam.nblkmem) +\" blocks allocated in memory), \"+std::to_string(nrefineblk)+\" blocks to be refined, \"+std::to_string(ncoarsenlk)+\" blocks to be coarsen (with neighbour); \"+std::to_string(XParam.nblk - nrefineblk - 4 * ncoarsenlk)+\" blocks untouched; \"+std::to_string(ncoarsenlk * 3)+\" blocks to be freed (\"+ std::to_string(XParam.navailblk) +\" are already available) \"+std::to_string(nnewblk)+\" new blocks will be created\");\n\n    return nnewblk;\n\n}\ntemplate int CalcAvailblk&lt;float&gt;(Param &amp;XParam, BlockP&lt;float&gt; XBlock, AdaptP&amp; XAdapt);\ntemplate int CalcAvailblk&lt;double&gt;(Param &amp;XParam, BlockP&lt;double&gt; XBlock, AdaptP&amp; XAdapt);\n\ntemplate &lt;class T&gt; int AddBlocks(int nnewblk, Param&amp; XParam, Model&lt;T&gt;&amp; XModel)\n{\n    //\n    int nblkmem, oldblkmem;\n    oldblkmem = XParam.nblkmem;\n    nblkmem = (int)ceil((XParam.nblk + nnewblk) * XParam.membuffer);\n    XParam.nblkmem = nblkmem;\n    ReallocArray(nblkmem, XParam.blksize, XParam, XModel);\n\n\n    // Reconstruct blk info\n    XParam.navailblk = 0;\n    for (int ibl = 0; ibl &lt; (XParam.nblkmem - XParam.nblk); ibl++)\n    {\n        XModel.blocks.active[XParam.nblk + ibl] = -1;\n    }\n    for (int ibl = 0; ibl &lt; (XParam.nblkmem - oldblkmem); ibl++)\n    {\n        XModel.adapt.invactive[oldblkmem + ibl] = -1;\n\n\n    }\n\n    for (int ibl = 0; ibl &lt; XParam.nblkmem; ibl++)\n    {\n        if (XModel.adapt.invactive[ibl] == -1)\n        {\n            XModel.adapt.availblk[XParam.navailblk] = ibl;\n            XParam.navailblk++;\n        }\n\n    }\n\n    //Because reallocation may be producing different pointers we need to update the output map array\n\n    Initmaparray(XModel);\n    return nblkmem;\n}\ntemplate int AddBlocks&lt;float&gt;(int nnewblk, Param&amp; XParam, Model&lt;float&gt;&amp; XModel);\ntemplate int AddBlocks&lt;double&gt;(int nnewblk, Param&amp; XParam, Model&lt;double&gt;&amp; XModel);\n\n\ntemplate &lt;class T&gt; void coarsen(Param XParam, BlockP&lt;T&gt;&amp; XBlock, AdaptP&amp; XAdapt,EvolvingP&lt;T&gt; XEvo, EvolvingP&lt;T&gt;&amp; XEv )\n{\n    //=========================================================\n    //  COARSEN\n    //=========================================================\n    // This is a 2 step process\n    // 1. First deal with the conserved variables (hh,uu,vv,zs,zb)\n    // 2. Deactivate the block\n    // 3. Fix neighbours\n\n    //____________________________________________________\n    //\n    // Step 1 &amp; 2: Average conserved variables and deactivate the blocks\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        int i, ii, ir, it, itr;\n        if (XAdapt.coarsen[ib] == true)\n        {\n            double dxfac = calcres(XParam.dx, XBlock.level[ib]);\n            //int xnode = int((XBlock.xo[ib]) / dxfac / XParam.blkwidth);\n            //int ynode = int((XBlock.yo[ib]) / dxfac / XParam.blkwidth);\n\n            int ibr = XBlock.RightBot[ib];\n            int ibtl = XBlock.TopLeft[ib];\n            int ibtr = XBlock.TopLeft[XBlock.RightBot[ib]];\n\n\n            int oldrightbot = XBlock.RightBot[ibr];\n            int oldrighttop = XBlock.RightBot[ibtr];\n            //int oldtopofright = topblk[oldright];\n            int oldtopleft = XBlock.TopLeft[ibtl];\n            int oldtopright = XBlock.TopLeft[ibtr];\n            //int oldrightoftop = rightblk[oldtop];\n            int oldleftbot = XBlock.LeftBot[ib];\n            int oldlefttop = XBlock.LeftBot[ibtl];\n            //int oldtopofleft = topblk[oldleft];\n            int oldbotleft = XBlock.BotLeft[ib];\n            int oldbotright = XBlock.BotLeft[ibr];\n            //int oldrightofbot = rightblk[oldbot];\n\n\n\n\n            for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n            {\n                for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n                {\n                    i = memloc(XParam, ix, iy, ib);\n\n                    if (ix &lt; (XParam.blkwidth / 2) &amp;&amp; iy &lt; (XParam.blkwidth /2))\n                    {\n                        ii = memloc(XParam, ix * 2, iy * 2, ib);// ix * 2 + (iy * 2) * 16 + ib * XParam.blksize;\n                        ir = memloc(XParam, (ix * 2 + 1), (iy * 2), ib); //(ix * 2 + 1) + (iy * 2) * 16 + ib * XParam.blksize;\n                        it = memloc(XParam, (ix * 2 ), (iy * 2 + 1), ib);// (ix) * 2 + (iy * 2 + 1) * 16 + ib * XParam.blksize;\n                        itr = memloc(XParam, (ix * 2 + 1), (iy * 2 + 1), ib); //(ix * 2 + 1) + (iy * 2 + 1) * 16 + ib * XParam.blksize;\n                    }\n                    if (ix &gt;= (XParam.blkwidth / 2) &amp;&amp; iy &lt; (XParam.blkwidth / 2))\n                    {\n                        ii = memloc(XParam, (ix - XParam.blkwidth / 2) * 2, iy * 2, ibr);//((ix - 8) * 2) + (iy * 2) * 16 + rightblk[ib] * XParam.blksize;\n                        ir = memloc(XParam, (ix - XParam.blkwidth / 2) * 2 + 1, iy * 2, ibr);// ((ix - 8) * 2 + 1) + (iy * 2) * 16 + rightblk[ib] * XParam.blksize;\n                        it = memloc(XParam, (ix - XParam.blkwidth / 2) * 2, iy * 2 + 1, ibr);// ((ix - 8)) * 2 + (iy * 2 + 1) * 16 + rightblk[ib] * XParam.blksize;\n                        itr = memloc(XParam, (ix - XParam.blkwidth / 2) * 2 + 1, (iy * 2 + 1), ibr);// ((ix - 8) * 2 + 1) + (iy * 2 + 1) * 16 + rightblk[ib] * XParam.blksize;\n                    }\n                    if (ix &lt; (XParam.blkwidth / 2) &amp;&amp; iy &gt;= (XParam.blkwidth / 2))\n                    {\n                        ii = memloc(XParam, ix * 2, (iy - XParam.blkwidth / 2) * 2, ibtl);// ix * 2 + ((iy - 8) * 2) * 16 + topblk[ib] * XParam.blksize;\n                        ir = memloc(XParam, ix * 2 + 1, (iy - XParam.blkwidth / 2) * 2, ibtl);//(ix * 2 + 1) + ((iy - 8) * 2) * 16 + topblk[ib] * XParam.blksize;\n                        it = memloc(XParam, ix * 2, (iy - XParam.blkwidth / 2) * 2 + 1, ibtl);//(ix) * 2 + ((iy - 8) * 2 + 1) * 16 + topblk[ib] * XParam.blksize;\n                        itr = memloc(XParam, ix * 2 + 1, (iy - XParam.blkwidth / 2) * 2 + 1, ibtl);//(ix * 2 + 1) + ((iy - 8) * 2 + 1) * 16 + topblk[ib] * XParam.blksize;\n                    }\n                    if (ix &gt;= (XParam.blkwidth / 2) &amp;&amp; iy &gt;= (XParam.blkwidth / 2))\n                    {\n                        ii = memloc(XParam, (ix - XParam.blkwidth / 2) * 2, (iy - XParam.blkwidth / 2) * 2, ibtr);// (ix - 8) * 2 + ((iy - 8) * 2) * 16 + rightblk[topblk[ib]] * XParam.blksize;\n                        ir = memloc(XParam, (ix - XParam.blkwidth / 2) * 2 + 1, (iy - XParam.blkwidth / 2) * 2, ibtr);//((ix - 8) * 2 + 1) + ((iy - 8) * 2) * 16 + rightblk[topblk[ib]] * XParam.blksize;\n                        it = memloc(XParam, (ix - XParam.blkwidth / 2) * 2, (iy - XParam.blkwidth / 2) * 2 + 1, ibtr);//(ix - 8) * 2 + ((iy - 8) * 2 + 1) * 16 + rightblk[topblk[ib]] * XParam.blksize;\n                        itr = memloc(XParam, (ix - XParam.blkwidth / 2) * 2 + 1, (iy - XParam.blkwidth / 2) * 2 + 1, ibtr);//((ix - 8) * 2 + 1) + ((iy - 8) * 2 + 1) * 16 + rightblk[topblk[ib]] * XParam.blksize;\n                    }\n\n\n                    // These are the only guys that need to be coarsen, other are recalculated on the fly or interpolated from forcing\n                    XEv.h[i] = T(0.25) * (XEvo.h[ii] + XEvo.h[ir] + XEvo.h[it] + XEvo.h[itr]);\n                    XEv.zs[i] = T(0.25) * (XEvo.zs[ii] + XEvo.zs[ir] + XEvo.zs[it] + XEvo.zs[itr]);\n                    XEv.u[i] = T(0.25) * (XEvo.u[ii] + XEvo.u[ir] + XEvo.u[it] + XEvo.u[itr]);\n                    XEv.v[i] =  T(0.25) * (XEvo.v[ii] + XEvo.v[ir] + XEvo.v[it] + XEvo.v[itr]);\n                    //zb will be interpolated from input grid later // I wonder is this makes the bilinear interpolation scheme crash at the refining step for zb?\n                    // No because zb is also interpolated later from the original mesh data\n                    //zb[i] = 0.25 * (zbo[ii] + zbo[ir] + zbo[it], zbo[itr]);\n\n\n                }\n            }\n\n            //Need more?\n\n            // Make right, top and top-right block available for refine step\n            XAdapt.availblk[XParam.navailblk] = ibr;\n            XAdapt.availblk[XParam.navailblk + 1] = ibtl;\n            XAdapt.availblk[XParam.navailblk + 2] = ibtr;\n\n            XAdapt.newlevel[ib] = XBlock.level[ib] - 1;\n\n            //Do not comment! While this 3 line below seem irrelevant in a first order they are needed for the neighbours below (next step down) but then is not afterward\n            XAdapt.newlevel[ibr] = XBlock.level[ib] - 1;\n            XAdapt.newlevel[ibtl] = XBlock.level[ib] - 1;\n            XAdapt.newlevel[ibtr] = XBlock.level[ib] - 1;\n\n\n\n            // increment available block count\n            XParam.navailblk = XParam.navailblk + 3;\n\n            // Make right, top and top-right block inactive\n            XBlock.active[XAdapt.invactive[ibr]] = -1;\n            XBlock.active[XAdapt.invactive[ibtl]] = -1;\n            XBlock.active[XAdapt.invactive[ibtr]] = -1;\n\n            //check neighbour's (Full neighbour happens in the next big loop below)\n            if (ibr == oldrightbot) // Surely that can never be true. if that was the case the coarsening would not have been allowed!\n            {\n                XBlock.RightBot[ib] = ib;\n                //XBlock.RightTop[ib] = ib;\n            }\n            else\n            {\n                XBlock.RightBot[ib] = oldrightbot;\n                //XBlock.RightTop[ib] = oldright;\n            }\n            if (ibtr == oldrighttop) // Surely that can never be true. if that was the case the coarsening would not have been allowed!\n            {\n                XBlock.RightTop[ib] = ib;\n                //XBlock.RightTop[ib] = ib;\n            }\n            else\n            {\n                XBlock.RightTop[ib] = oldrighttop;\n                //XBlock.RightTop[ib] = oldright;\n            }\n\n\n\n            if (ibtl == oldtopleft)//Ditto here\n            {\n                XBlock.TopLeft[ib] = ib;\n            }\n            else\n            {\n                XBlock.TopLeft[ib] = oldtopleft;\n            }\n            if (ibtr == oldtopright)//Ditto here\n            {\n                XBlock.TopRight[ib] = ib;\n            }\n            else\n            {\n                XBlock.TopRight[ib] = oldtopright;\n            }\n\n\n\n            XBlock.LeftBot[ib] = oldleftbot;// It is that already but it clearer to spell it out\n            XBlock.LeftTop[ib] = oldlefttop;\n            if (oldlefttop == ibtl)\n            {\n                XBlock.LeftTop[ib] = ib;\n            }\n\n            XBlock.BotLeft[ib] = oldbotleft;\n            XBlock.BotRight[ib] = oldbotright;\n            if (oldbotright == ibr)\n            {\n                XBlock.BotRight[ib] = ib;\n            }\n\n            //Also need to do lft and bottom!\n\n\n\n            // Bot and left blk should remain unchanged at this stage(they will change if the neighbour themselves change)\n\n            XBlock.xo[ib] = XBlock.xo[ib] + T(calcres(XParam.dx, XBlock.level[ib] + 1));\n            XBlock.yo[ib] = XBlock.yo[ib] + T(calcres(XParam.dx, XBlock.level[ib] + 1));\n\n\n\n        }\n\n    }\n\n    //____________________________________________________\n    //\n    // Step 3: deal with neighbour\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n\n        if (ib &gt;= 0) // ib can be -1 for newly inactive blocks\n        {\n\n            int oldrightbot = XBlock.RightBot[ib];\n\n            int oldtopleft = XBlock.TopLeft[ib];\n\n            int oldleftbot = XBlock.LeftBot[ib];\n\n            int oldbotleft = XBlock.BotLeft[ib];\n\n\n\n\n\n            if (XAdapt.newlevel[oldleftbot] &lt; XBlock.level[oldleftbot])\n            {\n                //left blk has coarsen\n                if (XAdapt.coarsen[XBlock.LeftBot[oldleftbot]])\n                {\n                    XBlock.LeftBot[ib] = XBlock.LeftBot[oldleftbot];\n                    XBlock.LeftTop[ib] = XBlock.LeftBot[oldleftbot];\n                }\n                else\n                {\n                    XBlock.LeftBot[ib] = XBlock.BotLeft[XBlock.LeftBot[oldleftbot]];\n                    XBlock.LeftTop[ib] = XBlock.BotLeft[XBlock.LeftBot[oldleftbot]];\n                }\n            }\n\n\n\n\n            if (XAdapt.newlevel[oldbotleft] &lt; XBlock.level[oldbotleft])\n            {\n                // botblk has coarsen\n                if (XAdapt.coarsen[XBlock.BotLeft[oldbotleft]])\n                {\n                    XBlock.BotLeft[ib] = XBlock.BotLeft[oldbotleft];\n                    XBlock.BotRight[ib] = XBlock.BotLeft[oldbotleft];\n                }\n                else\n                {\n                    XBlock.BotLeft[ib] = XBlock.LeftBot[XBlock.BotLeft[oldbotleft]];\n                    XBlock.BotRight[ib] = XBlock.LeftBot[XBlock.BotLeft[oldbotleft]];\n                }\n            }\n\n\n\n            if (XAdapt.newlevel[oldrightbot] &lt; XBlock.level[oldrightbot])\n            {\n                // right block has coarsen\n                if (!XAdapt.coarsen[oldrightbot])\n                {\n                    XBlock.RightBot[ib] = XBlock.BotLeft[oldrightbot];\n                    XBlock.RightTop[ib] = XBlock.BotLeft[oldrightbot];\n\n                }\n                // else do nothing because the right block is the reference one\n            }\n\n\n            if (XAdapt.newlevel[oldtopleft] &lt; XBlock.level[oldtopleft])\n            {\n                // top blk has coarsen\n                if (!XAdapt.coarsen[oldtopleft])\n                {\n                    XBlock.TopLeft[ib] = XBlock.LeftBot[oldtopleft];\n                    XBlock.TopRight[ib] = XBlock.LeftBot[oldtopleft];\n                }\n\n\n            }\n\n\n        }\n    }\n\n    //____________________________________________________\n    //\n    // Step 4: deal with other neighbour pair\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n\n        if (ib &gt;= 0 &amp;&amp; (XAdapt.newlevel[ib] &lt; XBlock.level[ib])) // ib can be -1 for newly inactive blocks\n        {\n            if (XAdapt.newlevel[XBlock.LeftBot[ib]] &lt;= XAdapt.newlevel[ib])\n            {\n                XBlock.LeftTop[ib] = XBlock.LeftBot[ib]; // this is fine even if this is a boundary edge\n            }\n            else //(XAdapt.newlevel[XBlock.LeftBot[ib]] &gt; XAdapt.newlevel[ib])\n            {\n                XBlock.LeftTop[ib] = XBlock.TopLeft[XBlock.LeftBot[ib]];\n            }\n\n            if (XAdapt.newlevel[XBlock.RightBot[ib]] &lt;= XAdapt.newlevel[ib])\n            {\n                XBlock.RightTop[ib] = XBlock.RightBot[ib]; // this is fine even if this is a boundary edge\n            }\n            else //(XAdapt.newlevel[XBlock.LeftBot[ib]] &gt; XAdapt.newlevel[ib])\n            {\n                XBlock.RightTop[ib] = XBlock.TopLeft[XBlock.RightBot[ib]];\n            }\n\n            if (XAdapt.newlevel[XBlock.BotLeft[ib]] &lt;= XAdapt.newlevel[ib])\n            {\n                XBlock.BotRight[ib] = XBlock.BotLeft[ib];\n            }\n            else //(XAdapt.newlevel[XBlock.LeftBot[ib]] &gt; XAdapt.newlevel[ib])\n            {\n                XBlock.BotRight[ib] = XBlock.RightBot[XBlock.BotLeft[ib]];\n            }\n\n\n            if (XAdapt.newlevel[XBlock.TopLeft[ib]] &lt;= XAdapt.newlevel[ib])\n            {\n                XBlock.TopRight[ib] = XBlock.TopLeft[ib];\n            }\n            else //(XAdapt.newlevel[XBlock.TopBot[ib]] &gt; XAdapt.newlevel[ib])\n            {\n                XBlock.TopRight[ib] = XBlock.RightBot[XBlock.TopLeft[ib]];\n            }\n\n\n        }\n    }\n}\n\ntemplate void coarsen&lt;float&gt;(Param XParam, BlockP&lt;float&gt;&amp; XBlock, AdaptP&amp; XAdapt, EvolvingP&lt;float&gt; XEvo, EvolvingP&lt;float&gt;&amp; XEv);\ntemplate void coarsen&lt;double&gt;(Param XParam, BlockP&lt;double&gt;&amp; XBlock, AdaptP&amp; XAdapt, EvolvingP&lt;double&gt; XEvo, EvolvingP&lt;double&gt;&amp; XEv);\n\ntemplate &lt;class T&gt; void refine(Param XParam, BlockP&lt;T&gt;&amp; XBlock, AdaptP&amp; XAdapt, EvolvingP&lt;T&gt; XEvo, EvolvingP&lt;T&gt;&amp; XEv)\n{\n    //==========================================================================\n    //  REFINE\n    //==========================================================================\n    // This is also a multi step process:\n    //  1. Interpolate conserved variables (although zb is done here it is overwritten later down the code)\n    //  2. Set direct neighbours blockxo/yo and levels\n    //  3. Set wider neighbourhood\n    //  4. Activate new blocks \n\n    //____________________________________________________\n    //\n    // Step 1. Interpolate conserved variables\n\n    int nblk = XParam.nblk;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //\n\n        int ib = XBlock.active[ibl];\n        int o;\n        int  ii, ir, it,itr;\n\n\n        if (ib &gt;= 0) // ib can be -1 for newly inactive blocks\n        {\n            if (XAdapt.refine[ib])\n            {\n\n                // Bilinear interpolation\n                for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n                {\n                    for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n                    {\n                        int kx[] = { 0, XParam.blkwidth/2, 0, XParam.blkwidth/2 };\n                        int ky[] = { 0, 0, XParam.blkwidth/2, XParam.blkwidth/2 };\n                        int kb[] = { ib, XAdapt.availblk[XAdapt.csumblk[ib]], XAdapt.availblk[XAdapt.csumblk[ib] + 1], XAdapt.availblk[XAdapt.csumblk[ib] + 2] };\n\n                        //double mx, my;\n\n                        for (int kk = 0; kk &lt; 4; kk++)\n                        {\n\n                            int cx, fx, cy, fy;\n\n                            T lx, ly, rx, ry;\n\n                            lx = ix * T(0.5) - T(0.25);\n                            ly = iy * T(0.5) - T(0.25);\n\n\n                            fx = (int)floor(lx) + kx[kk];\n                            cx = (int)ceil(lx) + kx[kk];\n                            fy = (int)floor(ly) + ky[kk];\n                            cy = (int)ceil(ly) + ky[kk];\n\n                            rx = (lx)+T(kx[kk]);\n                            ry = (ly)+T(ky[kk]);\n\n                            o = memloc(XParam,ix,iy, kb[kk]);//ix + iy * 16 + kb[kk] * XParam.blksize;\n\n                            ii = memloc(XParam, fx, fy, ib);\n                            ir = memloc(XParam, cx, fy, ib);\n                            it = memloc(XParam, fx, cy, ib);\n                            itr = memloc(XParam, cx, cy, ib);\n\n\n                            //printf(\"fx = %d; cx=%d; fy=%d; cy=%d; rx=%f; ry=%f\\n\", fx, cx, fy, cy,rx,ry);\n\n                            //printf(\"First blk %f\\n\",BilinearInterpolation(h11, h12, h21, h22, fx, cx, fy, cy, rx, ry));\n\n                            XEv.h[o] = BilinearInterpolation(XEvo.h[ii], XEvo.h[it], XEvo.h[ir], XEvo.h[itr], (T)fx, (T)cx, (T)fy, (T)cy, rx, ry);\n                            XEv.zs[o] = BilinearInterpolation(XEvo.zs[ii], XEvo.zs[it], XEvo.zs[ir], XEvo.zs[itr], (T)fx, (T)cx, (T)fy, (T)cy, rx, ry);\n                            XEv.u[o] = BilinearInterpolation(XEvo.u[ii], XEvo.u[it], XEvo.u[ir], XEvo.u[itr], (T)fx, (T)cx, (T)fy, (T)cy, rx, ry);\n                            XEv.v[o] = BilinearInterpolation(XEvo.v[ii], XEvo.v[it], XEvo.v[ir], XEvo.v[itr], (T)fx, (T)cx, (T)fy, (T)cy, rx, ry);\n\n\n                        }\n\n                    }\n                }\n            }\n        }\n    }\n\n    //____________________________________________________\n    //  \n    // Step 2. Set direct neighbours blockxo/yo and levels\n    //\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        if (ib &gt;= 0) // ib can be -1 for newly inactive blocks\n        {\n            if (XAdapt.refine[ib])\n            {\n                double delx = calcres(XParam.dx, XBlock.level[ib] + 1);\n                double xoblk = XBlock.xo[ib] - 0.5 * delx;\n                double yoblk = XBlock.yo[ib] - 0.5 * delx;\n\n                int oldtopleft, oldrightbot;\n                //int oldleftbot, oldbotleft;\n                int oldtopright, oldlefttop, oldrighttop, oldbotright;\n\n\n                oldtopleft = XBlock.TopLeft[ib];\n                oldtopright = XBlock.TopRight[ib];\n\n                //oldbotleft = XBlock.BotLeft[ib];\n                oldbotright = XBlock.BotRight[ib];\n\n                oldrightbot = XBlock.RightBot[ib];\n                oldrighttop = XBlock.RightTop[ib];\n\n                //oldleftbot = XBlock.LeftBot[ib];\n                oldlefttop = XBlock.LeftTop[ib];\n\n                // One block becomes 4 blocks:\n                // ib is the starting blk and new bottom left blk\n                // ibr is the new bottom right blk\n                // ibtl is the new top left blk\n                // ibtr is the new top right block\n\n                int ibr, ibtl, ibtr;\n                ibr = XAdapt.availblk[XAdapt.csumblk[ib]];\n                ibtl = XAdapt.availblk[XAdapt.csumblk[ib] + 1];\n                ibtr = XAdapt.availblk[XAdapt.csumblk[ib] + 2];\n\n                // sort out block info\n                XAdapt.newlevel[ib] = XBlock.level[ib] + 1;\n                XAdapt.newlevel[ibr] = XBlock.level[ib] + 1;\n                XAdapt.newlevel[ibtl] = XBlock.level[ib] + 1;\n                XAdapt.newlevel[ibtr] = XBlock.level[ib] + 1;\n\n                XBlock.xo[ib] = T(xoblk);\n                XBlock.yo[ib] = T(yoblk);\n                //bottom right blk\n                XBlock.xo[ibr] = T(xoblk + (XParam.blkwidth) * delx);\n                XBlock.yo[ibr] = T(yoblk);\n                //top left blk\n                XBlock.xo[ibtl] = T(xoblk);\n                XBlock.yo[ibtl] = T(yoblk + (XParam.blkwidth) * delx);\n                //top right blk\n                XBlock.xo[ibtr] = T(xoblk + (XParam.blkwidth) * delx);\n                XBlock.yo[ibtr] = T(yoblk + (XParam.blkwidth) * delx);\n\n\n                //sort out internal blocks neighbour\n                // external neighbours are dealt with in the following loop\n\n                //top neighbours\n                XBlock.TopLeft[ib] = ibtl;\n                XBlock.TopRight[ib] = ibtl;\n\n                XBlock.TopLeft[ibtl] = oldtopleft;\n                XBlock.TopRight[ibtl] = oldtopleft;\n\n                XBlock.TopLeft[ibr] = ibtr;\n                XBlock.TopRight[ibr] = ibtr;\n\n                XBlock.TopLeft[ibtr] = oldtopright;\n                XBlock.TopRight[ibtr] = oldtopright;\n\n                // Right neighbours\n                XBlock.RightBot[ib] = ibr;\n                XBlock.RightTop[ib] = ibr;\n\n                XBlock.RightBot[ibr] = oldrightbot;\n                XBlock.RightTop[ibr] = oldrightbot;\n\n                XBlock.RightBot[ibtl] = ibtr;\n                XBlock.RightTop[ibtl] = ibtr;\n\n                XBlock.RightBot[ibtr] = oldrighttop;\n                XBlock.RightTop[ibtr] = oldrighttop;\n\n                //Bottom Neighbours\n                XBlock.BotLeft[ibtl] = ib;\n                XBlock.BotRight[ibtl] = ib;\n\n                XBlock.BotLeft[ibtr] = ibr;\n                XBlock.BotRight[ibtr] = ibr;\n\n                XBlock.BotLeft[ibr] = oldbotright;\n                XBlock.BotRight[ibr] = oldbotright;\n\n                //Left neightbour\n                XBlock.LeftBot[ibr] = ib;\n                XBlock.LeftTop[ibr] = ib;\n\n                XBlock.LeftBot[ibtr] = ibtl;\n                XBlock.LeftTop[ibtr] = ibtl;\n\n                XBlock.LeftBot[ibtl] = oldlefttop;\n                XBlock.LeftTop[ibtl] = oldlefttop;\n\n\n\n                XParam.navailblk = XParam.navailblk - 3;\n            }\n        }\n\n    }\n\n\n    //____________________________________________________\n    //  \n    //  Step 3. Set wider neighbourhood\n    //\n    // set the external neighbours\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        if (ib &gt;= 0) // ib can be -1 for newly inactive blocks\n        {\n            if (XAdapt.refine[ib])\n            {\n                int oldtopleft, oldleftbot, oldrightbot, oldbotleft;\n                int oldtopright, oldlefttop, oldrighttop, oldbotright;\n\n                // One block becomes 4 blocks:\n                // ib is the starting blk and new bottom left blk\n                // ibr is the new bottom right blk\n                // ibtl is the new top left blk\n                // ibtr is the new top right block\n\n                int ibr, ibtl, ibtr;\n                ibr = XAdapt.availblk[XAdapt.csumblk[ib]];\n                ibtl = XAdapt.availblk[XAdapt.csumblk[ib] + 1];\n                ibtr = XAdapt.availblk[XAdapt.csumblk[ib] + 2];\n\n                oldtopleft = XBlock.TopLeft[ibtl];\n                oldtopright = XBlock.TopRight[ibtr];\n\n                oldbotleft = XBlock.BotLeft[ib];\n                oldbotright = XBlock.BotRight[ibr];\n\n                oldrightbot = XBlock.RightBot[ibr];\n                oldrighttop = XBlock.RightTop[ibtr];\n\n                oldleftbot = XBlock.LeftBot[ib];\n                oldlefttop = XBlock.LeftTop[ibtl];\n\n\n                // Deal with neighbours \n                // This is F@*%!ng tedious!\n\n                //_________________________________\n                // Left Neighbours\n                if (XAdapt.refine[oldleftbot])// is true and possibly the top left guy!!!\n                {\n                    if (XAdapt.newlevel[oldleftbot] &lt; XAdapt.newlevel[ib])\n                    {\n                        if (abs(XBlock.yo[ib] - XBlock.yo[oldleftbot]) &lt; calcres(XParam.dx, XAdapt.newlevel[ib]))//(XBlock.RightBot[XBlock.RightBot[oldleftbot]] == ib) // bottom side\n                        {\n                            XBlock.LeftBot[ib] = XAdapt.availblk[XAdapt.csumblk[oldleftbot]];\n                            XBlock.LeftTop[ib] = XAdapt.availblk[XAdapt.csumblk[oldleftbot]];\n\n                            XBlock.LeftBot[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldleftbot]];\n                            XBlock.LeftTop[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldleftbot]];\n                        }\n                        else //Top side\n                        {\n                            XBlock.LeftBot[ib] = XAdapt.availblk[XAdapt.csumblk[oldleftbot] + 2];\n                            XBlock.LeftTop[ib] = XAdapt.availblk[XAdapt.csumblk[oldleftbot] + 2];\n\n                            XBlock.LeftBot[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldleftbot] + 2];\n                            XBlock.LeftTop[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldleftbot] + 2];\n                        }\n                    }\n                    else\n                    {\n                        if (oldleftbot == ib)\n                        {\n                            XBlock.LeftBot[ib] = ib;\n                            XBlock.LeftTop[ib] = ib;\n\n                            if (oldlefttop == ib)\n                            {\n                                XBlock.LeftBot[ibtl] = ibtl;\n                                XBlock.LeftTop[ibtl] = ibtl;\n                            }\n                            else if(XAdapt.refine[oldlefttop])\n                            {\n                                XBlock.LeftBot[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldlefttop]];\n                                XBlock.LeftTop[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldlefttop] + 2];\n                            }\n                            else\n                            {\n                                XBlock.LeftBot[ibtl] = oldlefttop;\n                                XBlock.LeftTop[ibtl] = oldlefttop;\n                                XBlock.RightBot[oldlefttop] = ibtl;\n                                XBlock.RightTop[oldlefttop] = ibtl;\n                            }\n\n                        }\n                        else if (XAdapt.newlevel[oldleftbot] == XAdapt.newlevel[ib])\n                        {\n                            XBlock.LeftBot[ib] = XAdapt.availblk[XAdapt.csumblk[oldleftbot]];\n                            XBlock.LeftTop[ib] = XAdapt.availblk[XAdapt.csumblk[oldleftbot]];\n\n                            XBlock.LeftBot[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldleftbot] + 2];\n                            XBlock.LeftTop[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldleftbot] + 2];\n                        }\n                        else\n                        {\n                            XBlock.LeftBot[ib] = XAdapt.availblk[XAdapt.csumblk[oldleftbot]];\n                            XBlock.LeftTop[ib] = XAdapt.availblk[XAdapt.csumblk[oldleftbot] + 2];\n                            if (oldlefttop == ib)\n                            {\n                                XBlock.LeftBot[ibtl] = ibtl;\n                                XBlock.LeftTop[ibtl] = ibtl;\n                            }\n                            else if (XAdapt.refine[oldlefttop])\n                            {\n                                XBlock.LeftBot[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldlefttop] ];\n                                XBlock.LeftTop[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldlefttop] + 2];\n                            }\n                            else\n                            {\n                                XBlock.LeftBot[ibtl] = oldlefttop;\n                                XBlock.LeftTop[ibtl] = oldlefttop;\n                                XBlock.RightBot[oldlefttop] = ibtl;\n                                XBlock.RightTop[oldlefttop] = ibtl;\n                            }\n                        }\n                    }\n                }\n                else // oldleftbot did not refine (couldn't have corasen either)\n                {\n                    XBlock.LeftTop[ib] = oldleftbot;\n\n                    if (XAdapt.newlevel[oldleftbot] &lt; XAdapt.newlevel[ib])\n                    {\n                        //Don't  need to do this part (i.e. it is already the case)\n                        //XBlock.LeftBot[ib] = oldleftbot;\n                        //XBlock.LeftTop[ib] = oldleftbot;\n\n                        //XBlock.LeftBot[ibtl] = oldleftbot;\n                        //XBlock.LeftTop[ibtl] = oldleftbot;\n                        XBlock.RightBot[oldleftbot] = ib;\n                        XBlock.RightTop[oldleftbot] = ibtl;\n                    }\n                    else\n                    {\n                        XBlock.RightBot[oldleftbot] = ib;\n                        XBlock.RightTop[oldleftbot] = ib;\n                        if (oldlefttop != ib)\n                        {\n\n                            if (!XAdapt.refine[oldlefttop])\n                            {\n                                XBlock.RightBot[oldlefttop] = ibtl;\n                                XBlock.RightTop[oldlefttop] = ibtl;\n                            }\n                            else\n                            {\n                                XBlock.LeftBot[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldlefttop]];\n                                XBlock.LeftTop[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldlefttop] + 2];\n                            }\n                        }\n                        else\n                        {\n                            XBlock.LeftBot[ibtl] = ibtl;\n                            XBlock.LeftTop[ibtl] = ibtl;\n                        }\n                    }\n                }\n\n                //_________________________________\n                // Right Neighbours\n                if (XAdapt.refine[oldrightbot])// is true and possibly the top left guy!!!\n                {\n                    if (XAdapt.newlevel[oldrightbot] &lt; XAdapt.newlevel[ib])\n                    {\n                        if (abs(XBlock.yo[ib]-XBlock.yo[oldrightbot])&lt;calcres(XParam.dx, XAdapt.newlevel[ib])) //XBlock.LeftBot[oldrightbot] == ib// bottom side\n                        {\n                            XBlock.RightBot[ibr] = oldrightbot;\n                            XBlock.RightTop[ibr] = oldrightbot;\n\n                            XBlock.RightBot[ibtr] = oldrightbot;\n                            XBlock.RightTop[ibtr] = oldrightbot;\n                        }\n                        else //Top side\n                        {\n                            XBlock.RightBot[ibr] = XAdapt.availblk[XAdapt.csumblk[oldrightbot] + 1];\n                            XBlock.RightTop[ibr] = XAdapt.availblk[XAdapt.csumblk[oldrightbot] + 1];\n\n                            XBlock.RightBot[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldrightbot] + 1];\n                            XBlock.RightTop[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldrightbot] + 1];\n                        }\n                    }\n                    else\n                    {\n                        if (oldrightbot == ib)\n                        {\n                            XBlock.RightBot[ibr] = ibr;\n                            XBlock.RightTop[ibr] = ibr;\n\n                            if (oldrighttop == ib)\n                            {\n                                XBlock.RightBot[ibtr] = ibtr;\n                                XBlock.RightTop[ibtr] = ibtr;\n                            }\n                            else if (XAdapt.refine[oldrighttop])\n                            {\n                                XBlock.RightBot[ibtr] = oldrighttop;\n                                XBlock.RightTop[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldrighttop] + 1];\n                            }\n                            else\n                            {\n                                XBlock.RightBot[ibtr] = oldrighttop;\n                                XBlock.RightTop[ibtr] = oldrighttop;\n                                XBlock.LeftBot[oldrighttop] = ibtr;\n                                XBlock.LeftTop[oldrighttop] = ibtr;\n                            }\n\n                        }\n                        else if (XAdapt.newlevel[oldrightbot] == XAdapt.newlevel[ib])\n                        {\n                            XBlock.RightBot[ibr] = oldrightbot;\n                            XBlock.RightTop[ibr] = oldrightbot;\n\n                            XBlock.RightBot[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldrightbot] + 1];\n                            XBlock.RightTop[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldrightbot] + 1];\n                        }\n                        else\n                        {\n                            XBlock.RightBot[ibr] = oldrightbot;\n                            XBlock.RightTop[ibr] = XAdapt.availblk[XAdapt.csumblk[oldrightbot] + 1];\n                            if (oldrighttop == ib)\n                            {\n                                XBlock.RightBot[ibtr] = ibtr;\n                                XBlock.RightTop[ibtr] = ibtr;\n                            }\n                            else if (XAdapt.refine[oldrighttop])\n                            {\n                                XBlock.RightBot[ibtr] = oldrighttop;\n                                XBlock.RightTop[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldrighttop] + 1];\n                            }\n                            else\n                            {\n                                XBlock.RightBot[ibtr] = oldrighttop;\n                                XBlock.RightTop[ibtr] = oldrighttop;\n                                XBlock.LeftBot[oldrighttop] = ibtr;\n                                XBlock.LeftTop[oldrighttop] = ibtr;\n                            }\n                        }\n                    }\n                }\n                else // oldrightbot did not refine (couldn't have corasen either)\n                {\n                    //XBlock.RightTop[ib] = oldrightbot;\n                    if (XAdapt.newlevel[oldrightbot] &lt; XAdapt.newlevel[ib])\n                    {\n                        //Don't  need to do this part (i.e. it is already the case)\n                        //XBlock.LeftBot[ib] = oldleftbot;\n                        //XBlock.LeftTop[ib] = oldleftbot;\n\n                        //XBlock.LeftBot[ibtl] = oldleftbot;\n                        //XBlock.LeftTop[ibtl] = oldleftbot;\n                        XBlock.LeftBot[oldrightbot] = ibr;\n                        XBlock.LeftTop[oldrightbot] = ibtr;\n                    }\n                    else\n                    {\n                        XBlock.LeftBot[oldrightbot] = ibr;\n                        XBlock.LeftTop[oldrightbot] = ibr;\n                        if (oldrighttop != ib)\n                        {\n\n                            if (!XAdapt.refine[oldrighttop])\n                            {\n                                XBlock.LeftBot[oldrighttop] = ibtr;\n                                XBlock.LeftTop[oldrighttop] = ibtr;\n                            }\n                            else\n                            {\n                                XBlock.RightBot[ibtr] = oldrighttop;\n                                XBlock.RightTop[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldrighttop] + 1];\n                            }\n                        }\n                        else\n                        {\n                            XBlock.RightBot[ibtr] = ibtr;\n                            XBlock.RightTop[ibtr] = ibtr;\n                        }\n                    }\n                }\n\n\n                //_________________________________\n                // Bottom Neighbours\n                if (XAdapt.refine[oldbotleft])// is true and possibly the top left guy!!!\n                {\n                    if (XAdapt.newlevel[oldbotleft] &lt; XAdapt.newlevel[ib])\n                    {\n                        if (abs(XBlock.xo[ib] - XBlock.xo[oldbotleft]) &lt; calcres(XParam.dx, XAdapt.newlevel[ib]))//(XBlock.TopLeft[XBlock.TopLeft[oldbotleft]] == ib) // left side\n                        {\n                            XBlock.BotLeft[ib] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 1];\n                            XBlock.BotRight[ib] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 1];\n\n                            XBlock.BotLeft[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 1];\n                            XBlock.BotRight[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 1];\n                        }\n                        else //Right side\n                        {\n                            XBlock.BotLeft[ib] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 2];\n                            XBlock.BotRight[ib] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 2];\n\n                            XBlock.BotLeft[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 2];\n                            XBlock.BotRight[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 2];\n                        }\n                    }\n                    else\n                    {\n                        if (oldbotleft == ib)\n                        {\n                            XBlock.BotLeft[ib] = ib;\n                            XBlock.BotRight[ib] = ib;\n\n                            if (oldbotright == ib)\n                            {\n                                XBlock.BotLeft[ibr] = ibr;\n                                XBlock.BotRight[ibr] = ibr;\n                            }\n                            else if (XAdapt.refine[oldbotright])\n                            {\n                                XBlock.BotLeft[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotright] + 1];\n                                XBlock.BotRight[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotright] + 2];\n                            }\n                            else\n                            {\n                                XBlock.BotLeft[ibr] = oldbotright;\n                                XBlock.BotRight[ibr] = oldbotright;\n                                XBlock.TopLeft[oldbotright] = ibr;\n                                XBlock.TopRight[oldbotright] = ibr;\n                            }\n\n                        }\n                        else if (XAdapt.newlevel[oldbotleft] == XAdapt.newlevel[ib])\n                        {\n                            XBlock.BotLeft[ib] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 1];\n                            XBlock.BotRight[ib] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 1];\n\n                            XBlock.BotLeft[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 2];\n                            XBlock.BotRight[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 2];\n                        }\n                        else\n                        {\n                            XBlock.BotLeft[ib] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 1];\n                            XBlock.BotRight[ib] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 2];\n                            if (oldbotright == ib)\n                            {\n                                XBlock.BotLeft[ibr] = ibr;\n                                XBlock.BotRight[ibr] = ibr;\n                            }\n                            else if (XAdapt.refine[oldbotright])\n                            {\n                                XBlock.BotLeft[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotright] + 1];\n                                XBlock.BotRight[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotright] + 2];\n                            }\n                            else\n                            {\n                                XBlock.BotLeft[ibr] = oldbotright;\n                                XBlock.BotRight[ibr] = oldbotright;\n                                XBlock.TopLeft[oldbotright] = ibr;\n                                XBlock.TopRight[oldbotright] = ibr;\n                            }\n                        }\n                    }\n                }\n                else // oldbotleft did not refine (couldn't have corasen either)\n                {\n                    XBlock.BotRight[ib] = oldbotleft;\n\n                    if (XAdapt.newlevel[oldbotleft] &lt; XAdapt.newlevel[ib])\n                    {\n                        //Don't  need to do this part (i.e. it is already the case)\n                        //XBlock.LeftBot[ib] = oldleftbot;\n                        //XBlock.LeftTop[ib] = oldleftbot;\n\n                        //XBlock.LeftBot[ibtl] = oldleftbot;\n                        //XBlock.LeftTop[ibtl] = oldleftbot;\n                        XBlock.TopLeft[oldbotleft] = ib;\n                        XBlock.TopRight[oldbotleft] = ibr;\n                    }\n                    else\n                    {\n                        XBlock.TopLeft[oldbotleft] = ib;\n                        XBlock.TopRight[oldbotleft] = ib;\n\n                        if (oldbotright != ib)\n                        {\n\n                            if (!XAdapt.refine[oldbotright])\n                            {\n                                XBlock.TopLeft[oldbotright] = ibr;\n                                XBlock.TopRight[oldbotright] = ibr;\n                            }\n                            else\n                            {\n                                XBlock.BotLeft[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotright] + 1];\n                                XBlock.BotRight[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotright] + 2];\n                            }\n                        }\n                        else\n                        {\n                            XBlock.BotLeft[ibr] = ibr;\n                            XBlock.BotRight[ibr] = ibr;\n                        }\n                    }\n                }\n\n                //_________________________________\n                // Top Neighbours\n                if (XAdapt.refine[oldtopleft])// is true and possibly the top left guy!!!\n                {\n                    if (XAdapt.newlevel[oldtopleft] &lt; XAdapt.newlevel[ib])\n                    {\n                        if (abs(XBlock.xo[ib] - XBlock.xo[oldtopleft]) &lt; calcres(XParam.dx, XAdapt.newlevel[ib]))//(XBlock.BotLeft[oldtopleft] == ib) // left side\n                        {\n                            XBlock.TopLeft[ibtl] = oldtopleft;\n                            XBlock.TopRight[ibtl] = oldtopleft;\n\n                            XBlock.TopLeft[ibtr] = oldtopleft;\n                            XBlock.TopRight[ibtr] = oldtopleft;\n                        }\n                        else //Right side\n                        {\n                            XBlock.TopLeft[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldtopleft]];\n                            XBlock.TopRight[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldtopleft]];\n\n                            XBlock.TopLeft[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldtopleft]];\n                            XBlock.TopRight[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldtopleft]];\n                        }\n                    }\n                    else\n                    {\n                        if (oldtopleft == ib)\n                        {\n                            XBlock.TopLeft[ibtl] = ibtl;\n                            XBlock.TopRight[ibtl] = ibtl;\n\n                            if (oldtopright == ib)\n                            {\n                                XBlock.TopLeft[ibtr] = ibtr;\n                                XBlock.TopRight[ibtr] = ibtr;\n                            }\n                            else if (XAdapt.refine[oldtopright])\n                            {\n                                XBlock.TopLeft[ibtr] = oldtopright;\n                                XBlock.TopRight[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldtopright]];\n                            }\n                            else\n                            {\n                                XBlock.TopLeft[ibtr] = oldbotright;\n                                XBlock.TopRight[ibtr] = oldbotright;\n                                XBlock.BotLeft[oldtopright] = ibtr;\n                                XBlock.BotRight[oldtopright] = ibtr;\n                            }\n\n                        }\n                        else if (XAdapt.newlevel[oldtopleft] == XAdapt.newlevel[ib])\n                        {\n                            XBlock.TopLeft[ibtl] = oldtopleft;\n                            XBlock.TopRight[ibtl] = oldtopleft;\n\n                            XBlock.TopLeft[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldtopleft] ];\n                            XBlock.TopRight[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldtopleft] ];\n                        }\n                        else\n                        {\n                            XBlock.TopLeft[ibtl] = oldtopleft;\n                            XBlock.TopRight[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldtopleft]];\n                            if (oldtopright == ib)\n                            {\n                                XBlock.TopLeft[ibtr] = ibtr;\n                                XBlock.TopRight[ibtr] = ibtr;\n                            }\n                            else if (XAdapt.refine[oldtopright])\n                            {\n                                XBlock.TopLeft[ibtr] = oldtopright;\n                                XBlock.TopRight[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldtopright]];\n                            }\n                            else\n                            {\n                                XBlock.TopLeft[ibtr] = oldtopright;\n                                XBlock.TopRight[ibtr] = oldtopright;\n                                XBlock.BotLeft[oldtopright] = ibtr;\n                                XBlock.BotRight[oldtopright] = ibtr;\n                            }\n                        }\n                    }\n                }\n                else // oldleftbot did not refine (couldn't have corasen either)\n                {\n                    //XBlock.TopRight[ib] = oldtopleft;\n                    if (XAdapt.newlevel[oldtopleft] &lt; XAdapt.newlevel[ib])\n                    {\n                        //Don't  need to do this part (i.e. it is already the case)\n                        //XBlock.LeftBot[ib] = oldleftbot;\n                        //XBlock.LeftTop[ib] = oldleftbot;\n\n                        //XBlock.LeftBot[ibtl] = oldleftbot;\n                        //XBlock.LeftTop[ibtl] = oldleftbot;\n                        XBlock.BotLeft[oldtopleft] = ibtl;\n                        XBlock.BotRight[oldtopleft] = ibtr;\n                    }\n                    else\n                    {\n                        XBlock.BotLeft[oldtopleft] = ibtl;\n                        XBlock.BotRight[oldtopleft] = ibtl;\n                        if (oldtopright != ib)\n                        {\n\n                            if (!XAdapt.refine[oldtopright])\n                            {\n                                XBlock.BotLeft[oldtopright] = ibtr;\n                                XBlock.BotRight[oldtopright] = ibtr;\n                            }\n                            else\n                            {\n                                XBlock.TopLeft[ibtr] = oldtopright;\n                                XBlock.TopRight[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldtopright]];\n                            }\n                        }\n                        else\n                        {\n                            XBlock.TopLeft[ibtr] = ibtr;\n                            XBlock.TopRight[ibtr] = ibtr;\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n    //____________________________________________________\n    //  \n    //  Step 4. Activate new blocks \n    //\n\n    nblk = XParam.nblk;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //\n\n        int ib = XBlock.active[ibl];\n\n        if (ib &gt;= 0) // ib can be -1 for newly inactive blocks\n        {\n\n            if (XAdapt.refine[ib] == true)\n            {\n\n                //After that we are done so activate the new blocks\n                XBlock.active[nblk] = XAdapt.availblk[XAdapt.csumblk[ib]];\n                XBlock.active[nblk + 1] = XAdapt.availblk[XAdapt.csumblk[ib] + 1];\n                XBlock.active[nblk + 2] = XAdapt.availblk[XAdapt.csumblk[ib] + 2];\n\n\n\n                nblk = nblk + 3;\n            }\n        }\n    }\n\n    // Now clean up the mess\n}\ntemplate void refine&lt;float&gt;(Param XParam, BlockP&lt;float&gt;&amp; XBlock, AdaptP&amp; XAdapt, EvolvingP&lt;float&gt; XEvo, EvolvingP&lt;float&gt;&amp; XEv);\ntemplate void refine&lt;double&gt;(Param XParam, BlockP&lt;double&gt;&amp; XBlock, AdaptP&amp; XAdapt, EvolvingP&lt;double&gt; XEvo, EvolvingP&lt;double&gt;&amp; XEv);\n\n\ntemplate &lt;class T&gt; void Adaptationcleanup(Param &amp;XParam, BlockP&lt;T&gt;&amp; XBlock, AdaptP&amp; XAdapt)\n{\n    //===========================================================\n    // UPDATE all remaining variables and clean up\n\n    //____________________________________________________\n    //\n    //  Update level\n    //\n    for (int ibl = 0; ibl &lt; XParam.nblkmem; ibl++)\n    {\n        //\n\n        int ib = XBlock.active[ibl];\n\n\n        if (ib &gt;= 0) // ib can be -1 for newly inactive blocks\n        {\n\n\n            XBlock.level[ib] = XAdapt.newlevel[ib];\n\n\n        }\n    }\n\n    //____________________________________________________\n    //\n    //  Reorder activeblk\n    //\n    // \n    int nblk = XParam.nblk;\n    for (int ibl = 0; ibl &lt; XParam.nblkmem; ibl++)\n    {\n        //reuse newlevel as temporary storage for activeblk\n        XAdapt.newlevel[ibl] = XBlock.active[ibl];\n        XBlock.active[ibl] = -1;\n\n\n    }\n    // cleanup and Reorder active block list\n    int ib = 0;\n    for (int ibl = 0; ibl &lt; XParam.nblkmem; ibl++)\n    {\n\n        if (XAdapt.newlevel[ibl] != -1)//i.e. old activeblk\n        {\n            XBlock.active[ib] = XAdapt.newlevel[ibl];\n\n            ib++;\n        }\n    }\n\n    nblk = ib;\n\n    //____________________________________________________\n    //\n    //  Reset adaptive info\n    //\n    // \n    for (int ibl = 0; ibl &lt; XParam.nblkmem; ibl++)\n    {\n\n        XAdapt.newlevel[ibl] = 0;\n        XAdapt.refine[ibl] = false;\n        XAdapt.coarsen[ibl] = false;\n    }\n    XParam.nblk = nblk;\n\n}\n\ntemplate void Adaptationcleanup&lt;float&gt;(Param&amp; XParam, BlockP&lt;float&gt;&amp; XBlock, AdaptP&amp; XAdapt);\ntemplate void Adaptationcleanup&lt;double&gt;(Param&amp; XParam, BlockP&lt;double&gt;&amp; XBlock, AdaptP&amp; XAdapt);\n</code></pre>"},{"location":"BGFlood/Adaptation_8h/","title":"File Adaptation.h","text":""},{"location":"BGFlood/Adaptation_8h/#file-adaptationh","title":"File Adaptation.h","text":"<p>FileList &gt; src &gt; Adaptation.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Mesh.h\"</code></li> <li><code>#include \"AdaptCriteria.h\"</code></li> <li><code>#include \"Halo.h\"</code></li> <li><code>#include \"InitialConditions.h\"</code></li> <li><code>#include \"Testing.h\"</code></li> </ul>"},{"location":"BGFlood/Adaptation_8h/#public-functions","title":"Public Functions","text":"Type Name void Adapt (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; &amp; XModel)  void Adaptation (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; &amp; XModel)  void Adaptationcleanup (Param &amp; XParam, BlockP&lt; T &gt; &amp; XBlock, AdaptP &amp; XAdapt)  int AddBlocks (int nnewblk, Param &amp; XParam, Model&lt; T &gt; &amp; XModel)  int CalcAvailblk (Param &amp; XParam, BlockP&lt; T &gt; XBlock, AdaptP &amp; XAdapt)  void InitialAdaptation (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel)  bool checkBUQsanity (Param XParam, BlockP&lt; T &gt; XBlock)  bool checklevel (int ib, int levelib, int neighbourib, int levelneighbour)  bool checkneighbourdistance (double dx, int ib, int levelib, T blocko, int neighbourib, int levelneighbour, T neighbourblocko, bool rightortop)  int checkneighbourrefine (int neighbourib, int levelib, int levelneighbour, bool *&amp; refine, bool *&amp; coarsen)  void coarsen (Param XParam, BlockP&lt; T &gt; &amp; XBlock, AdaptP &amp; XAdapt, EvolvingP&lt; T &gt; XEvo, EvolvingP&lt; T &gt; &amp; XEv)  void refine (Param XParam, BlockP&lt; T &gt; &amp; XBlock, AdaptP &amp; XAdapt, EvolvingP&lt; T &gt; XEvo, EvolvingP&lt; T &gt; &amp; XEv)  bool refinesanitycheck (Param XParam, BlockP&lt; T &gt; XBlock, bool *&amp; refine, bool *&amp; coarsen)"},{"location":"BGFlood/Adaptation_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Adaptation_8h/#function-adapt","title":"function Adapt","text":"<pre><code>template&lt;class T&gt;\nvoid Adapt (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8h/#function-adaptation","title":"function Adaptation","text":"<pre><code>template&lt;class T&gt;\nvoid Adaptation (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8h/#function-adaptationcleanup","title":"function Adaptationcleanup","text":"<pre><code>template&lt;class T&gt;\nvoid Adaptationcleanup (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8h/#function-addblocks","title":"function AddBlocks","text":"<pre><code>template&lt;class T&gt;\nint AddBlocks (\n    int nnewblk,\n    Param &amp; XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8h/#function-calcavailblk","title":"function CalcAvailblk","text":"<pre><code>template&lt;class T&gt;\nint CalcAvailblk (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; XBlock,\n    AdaptP &amp; XAdapt\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8h/#function-initialadaptation","title":"function InitialAdaptation","text":"<pre><code>template&lt;class T&gt;\nvoid InitialAdaptation (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8h/#function-checkbuqsanity","title":"function checkBUQsanity","text":"<pre><code>template&lt;class T&gt;\nbool checkBUQsanity (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8h/#function-checklevel","title":"function checklevel","text":"<pre><code>bool checklevel (\n    int ib,\n    int levelib,\n    int neighbourib,\n    int levelneighbour\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8h/#function-checkneighbourdistance","title":"function checkneighbourdistance","text":"<pre><code>template&lt;class T&gt;\nbool checkneighbourdistance (\n    double dx,\n    int ib,\n    int levelib,\n    T blocko,\n    int neighbourib,\n    int levelneighbour,\n    T neighbourblocko,\n    bool rightortop\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8h/#function-checkneighbourrefine","title":"function checkneighbourrefine","text":"<pre><code>int checkneighbourrefine (\n    int neighbourib,\n    int levelib,\n    int levelneighbour,\n    bool *&amp; refine,\n    bool *&amp; coarsen\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8h/#function-coarsen","title":"function coarsen","text":"<pre><code>template&lt;class T&gt;\nvoid coarsen (\n    Param XParam,\n    BlockP &lt; T &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt,\n    EvolvingP &lt; T &gt; XEvo,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8h/#function-refine","title":"function refine","text":"<pre><code>template&lt;class T&gt;\nvoid refine (\n    Param XParam,\n    BlockP &lt; T &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt,\n    EvolvingP &lt; T &gt; XEvo,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/Adaptation_8h/#function-refinesanitycheck","title":"function refinesanitycheck","text":"<pre><code>template&lt;class T&gt;\nbool refinesanitycheck (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    bool *&amp; refine,\n    bool *&amp; coarsen\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Adaptation.h</code></p>"},{"location":"BGFlood/Adaptation_8h_source/","title":"File Adaptation.h","text":""},{"location":"BGFlood/Adaptation_8h_source/#file-adaptationh","title":"File Adaptation.h","text":"<p>File List &gt; src &gt; Adaptation.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ADAPTATION_H\n#define ADAPTATION_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"Mesh.h\"\n#include \"AdaptCriteria.h\"\n#include \"Halo.h\"\n#include \"InitialConditions.h\"\n#include \"Testing.h\"\n\n\ntemplate &lt;class T&gt; void Adaptation(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel);\ntemplate &lt;class T&gt; void InitialAdaptation(Param&amp; XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;T&gt;&amp; XModel);\ntemplate &lt;class T&gt; bool refinesanitycheck(Param XParam, BlockP&lt;T&gt; XBlock, bool*&amp; refine, bool*&amp; coarsen);\nint checkneighbourrefine(int neighbourib, int levelib, int levelneighbour, bool*&amp; refine, bool*&amp; coarsen);\n\ntemplate &lt;class T&gt; bool checkBUQsanity(Param XParam, BlockP&lt;T&gt; XBlock);\nbool checklevel(int ib, int levelib, int neighbourib, int levelneighbour);\n\ntemplate &lt;class T&gt; void Adapt(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel);\n\ntemplate &lt;class T&gt; int CalcAvailblk(Param&amp; XParam, BlockP&lt;T&gt; XBlock, AdaptP&amp; XAdapt);\ntemplate &lt;class T&gt; int AddBlocks(int nnewblk, Param&amp; XParam, Model&lt;T&gt;&amp; XModel);\ntemplate &lt;class T&gt; void coarsen(Param XParam, BlockP&lt;T&gt;&amp; XBlock, AdaptP&amp; XAdapt, EvolvingP&lt;T&gt; XEvo, EvolvingP&lt;T&gt;&amp; XEv);\ntemplate &lt;class T&gt; void refine(Param XParam, BlockP&lt;T&gt;&amp; XBlock, AdaptP&amp; XAdapt, EvolvingP&lt;T&gt; XEvo, EvolvingP&lt;T&gt;&amp; XEv);\ntemplate &lt;class T&gt; void Adaptationcleanup(Param&amp; XParam, BlockP&lt;T&gt;&amp; XBlock, AdaptP&amp; XAdapt);\n\n\ntemplate &lt;class T&gt; bool checkneighbourdistance(double dx, int ib, int levelib, T blocko, int neighbourib, int levelneighbour, T neighbourblocko, bool rightortop );\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Advection_8cu/","title":"File Advection.cu","text":""},{"location":"BGFlood/Advection_8cu/#file-advectioncu","title":"File Advection.cu","text":"<p>FileList &gt; src &gt; Advection.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Advection.h\"</code></li> </ul>"},{"location":"BGFlood/Advection_8cu/#classes","title":"Classes","text":"Type Name struct SharedMemory &lt;class T&gt; struct SharedMemory&lt; double &gt; &lt;&gt;"},{"location":"BGFlood/Advection_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ void AdvkernelCPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * zb, EvolvingP&lt; T &gt; XEv, AdvanceP&lt; T &gt; XAdv, EvolvingP&lt; T &gt; XEv_o)  template __host__ void AdvkernelCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, double * zb, EvolvingP&lt; double &gt; XEv, AdvanceP&lt; double &gt; XAdv, EvolvingP&lt; double &gt; XEv_o)  template __host__ void AdvkernelCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, float * zb, EvolvingP&lt; float &gt; XEv, AdvanceP&lt; float &gt; XAdv, EvolvingP&lt; float &gt; XEv_o)  __global__ void AdvkernelGPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * zb, EvolvingP&lt; T &gt; XEv, AdvanceP&lt; T &gt; XAdv, EvolvingP&lt; T &gt; XEv_o)  template __global__ void AdvkernelGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, double * zb, EvolvingP&lt; double &gt; XEv, AdvanceP&lt; double &gt; XAdv, EvolvingP&lt; double &gt; XEv_o)  template __global__ void AdvkernelGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, float * zb, EvolvingP&lt; float &gt; XEv, AdvanceP&lt; float &gt; XAdv, EvolvingP&lt; float &gt; XEv_o)  __host__ T CalctimestepCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, TimeP&lt; T &gt; XTime)  template __host__ double CalctimestepCPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, TimeP&lt; double &gt; XTime)  template __host__ float CalctimestepCPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, TimeP&lt; float &gt; XTime)  __host__ T CalctimestepGPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, TimeP&lt; T &gt; XTime)  template __host__ double CalctimestepGPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, TimeP&lt; double &gt; XTime)  template __host__ float CalctimestepGPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, TimeP&lt; float &gt; XTime)  __host__ void cleanupCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, EvolvingP&lt; T &gt; XEv_o)  template __host__ void cleanupCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, EvolvingP&lt; double &gt; XEv_o)  template __host__ void cleanupCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, EvolvingP&lt; float &gt; XEv_o)  __global__ void cleanupGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, EvolvingP&lt; T &gt; XEv_o)  template __global__ void cleanupGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, EvolvingP&lt; double &gt; XEv_o)  template __global__ void cleanupGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, EvolvingP&lt; float &gt; XEv_o)  __global__ void densify (Param XParam, BlockP&lt; T &gt; XBlock, T * g_idata, T * g_odata)  __global__ void reducemin3 (T * g_idata, T * g_odata, unsigned int n)  __host__ T timestepreductionCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, TimeP&lt; T &gt; XTime)  template __host__ float timestepreductionCPU (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, TimeP&lt; float &gt; XTime)  template __host__ double timestepreductionCPU (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, TimeP&lt; double &gt; XTime)  __host__ void updateEVCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, FluxP&lt; T &gt; XFlux, AdvanceP&lt; T &gt; XAdv)  template __host__ void updateEVCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, FluxP&lt; double &gt; XFlux, AdvanceP&lt; double &gt; XAdv)  template __host__ void updateEVCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, FluxP&lt; float &gt; XFlux, AdvanceP&lt; float &gt; XAdv)  __global__ void updateEVGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, FluxP&lt; T &gt; XFlux, AdvanceP&lt; T &gt; XAdv)  template __global__ void updateEVGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, FluxP&lt; double &gt; XFlux, AdvanceP&lt; double &gt; XAdv)  template __global__ void updateEVGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, FluxP&lt; float &gt; XFlux, AdvanceP&lt; float &gt; XAdv)"},{"location":"BGFlood/Advection_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Advection_8cu/#function-advkernelcpu","title":"function AdvkernelCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AdvkernelCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * zb,\n    EvolvingP &lt; T &gt; XEv,\n    AdvanceP &lt; T &gt; XAdv,\n    EvolvingP &lt; T &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-advkernelcpu-double","title":"function AdvkernelCPU&lt; double &gt;","text":"<pre><code>template __host__ void AdvkernelCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    double * zb,\n    EvolvingP &lt; double &gt; XEv,\n    AdvanceP &lt; double &gt; XAdv,\n    EvolvingP &lt; double &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-advkernelcpu-float","title":"function AdvkernelCPU&lt; float &gt;","text":"<pre><code>template __host__ void AdvkernelCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    float * zb,\n    EvolvingP &lt; float &gt; XEv,\n    AdvanceP &lt; float &gt; XAdv,\n    EvolvingP &lt; float &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-advkernelgpu","title":"function AdvkernelGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AdvkernelGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * zb,\n    EvolvingP &lt; T &gt; XEv,\n    AdvanceP &lt; T &gt; XAdv,\n    EvolvingP &lt; T &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-advkernelgpu-double","title":"function AdvkernelGPU&lt; double &gt;","text":"<pre><code>template __global__ void AdvkernelGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    double * zb,\n    EvolvingP &lt; double &gt; XEv,\n    AdvanceP &lt; double &gt; XAdv,\n    EvolvingP &lt; double &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-advkernelgpu-float","title":"function AdvkernelGPU&lt; float &gt;","text":"<pre><code>template __global__ void AdvkernelGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    float * zb,\n    EvolvingP &lt; float &gt; XEv,\n    AdvanceP &lt; float &gt; XAdv,\n    EvolvingP &lt; float &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-calctimestepcpu","title":"function CalctimestepCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ T CalctimestepCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    TimeP &lt; T &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-calctimestepcpu-double","title":"function CalctimestepCPU&lt; double &gt;","text":"<pre><code>template __host__ double CalctimestepCPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    TimeP &lt; double &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-calctimestepcpu-float","title":"function CalctimestepCPU&lt; float &gt;","text":"<pre><code>template __host__ float CalctimestepCPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    TimeP &lt; float &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-calctimestepgpu","title":"function CalctimestepGPU","text":"<pre><code>template&lt;class T&gt;\n__host__ T CalctimestepGPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    TimeP &lt; T &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-calctimestepgpu-double","title":"function CalctimestepGPU&lt; double &gt;","text":"<pre><code>template __host__ double CalctimestepGPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    TimeP &lt; double &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-calctimestepgpu-float","title":"function CalctimestepGPU&lt; float &gt;","text":"<pre><code>template __host__ float CalctimestepGPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    TimeP &lt; float &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-cleanupcpu","title":"function cleanupCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void cleanupCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    EvolvingP &lt; T &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-cleanupcpu-double","title":"function cleanupCPU&lt; double &gt;","text":"<pre><code>template __host__ void cleanupCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    EvolvingP &lt; double &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-cleanupcpu-float","title":"function cleanupCPU&lt; float &gt;","text":"<pre><code>template __host__ void cleanupCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    EvolvingP &lt; float &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-cleanupgpu","title":"function cleanupGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void cleanupGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    EvolvingP &lt; T &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-cleanupgpu-double","title":"function cleanupGPU&lt; double &gt;","text":"<pre><code>template __global__ void cleanupGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    EvolvingP &lt; double &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-cleanupgpu-float","title":"function cleanupGPU&lt; float &gt;","text":"<pre><code>template __global__ void cleanupGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    EvolvingP &lt; float &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-densify","title":"function densify","text":"<pre><code>template&lt;class T&gt;\n__global__ void densify (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * g_idata,\n    T * g_odata\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-reducemin3","title":"function reducemin3","text":"<pre><code>template&lt;class T&gt;\n__global__ void reducemin3 (\n    T * g_idata,\n    T * g_odata,\n    unsigned int n\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-timestepreductioncpu","title":"function timestepreductionCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ T timestepreductionCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    TimeP &lt; T &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-timestepreductioncpu_1","title":"function timestepreductionCPU","text":"<pre><code>template __host__ float timestepreductionCPU (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    TimeP &lt; float &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-timestepreductioncpu_2","title":"function timestepreductionCPU","text":"<pre><code>template __host__ double timestepreductionCPU (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    TimeP &lt; double &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-updateevcpu","title":"function updateEVCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void updateEVCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    FluxP &lt; T &gt; XFlux,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-updateevcpu-double","title":"function updateEVCPU&lt; double &gt;","text":"<pre><code>template __host__ void updateEVCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    FluxP &lt; double &gt; XFlux,\n    AdvanceP &lt; double &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-updateevcpu-float","title":"function updateEVCPU&lt; float &gt;","text":"<pre><code>template __host__ void updateEVCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    FluxP &lt; float &gt; XFlux,\n    AdvanceP &lt; float &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-updateevgpu","title":"function updateEVGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void updateEVGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    FluxP &lt; T &gt; XFlux,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-updateevgpu-double","title":"function updateEVGPU&lt; double &gt;","text":"<pre><code>template __global__ void updateEVGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    FluxP &lt; double &gt; XFlux,\n    AdvanceP &lt; double &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Advection_8cu/#function-updateevgpu-float","title":"function updateEVGPU&lt; float &gt;","text":"<pre><code>template __global__ void updateEVGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    FluxP &lt; float &gt; XFlux,\n    AdvanceP &lt; float &gt; XAdv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Advection.cu</code></p>"},{"location":"BGFlood/Advection_8cu_source/","title":"File Advection.cu","text":""},{"location":"BGFlood/Advection_8cu_source/#file-advectioncu","title":"File Advection.cu","text":"<p>File List &gt; src &gt; Advection.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Advection.h\"\n\ntemplate&lt;class T&gt;\nstruct SharedMemory\n{\n    __device__ inline operator T* ()\n    {\n        extern __shared__ int __smem[];\n        return (T*)__smem;\n    }\n\n    __device__ inline operator const T* () const\n    {\n        extern __shared__ int __smem[];\n        return (T*)__smem;\n    }\n};\n\n// specialize for double to avoid unaligned memory\n// access compile errors\ntemplate&lt;&gt;\nstruct SharedMemory&lt;double&gt;\n{\n    __device__ inline operator double* ()\n    {\n        extern __shared__ double __smem_d[];\n        return (double*)__smem_d;\n    }\n\n    __device__ inline operator const double* () const\n    {\n        extern __shared__ double __smem_d[];\n        return (double*)__smem_d;\n    }\n};\n\n\ntemplate &lt;class T&gt;__global__ void updateEVGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, FluxP&lt;T&gt; XFlux, AdvanceP&lt;T&gt; XAdv)\n{\n\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n    //T eps = T(XParam.eps);\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n\n    T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n\n    T fc = 0.0;// XParam.spherical ? sin((ybo + calcres(T(XParam.dx), lev) * iy) * pi / 180.0) * pi / T(21600.0) : sin(T(XParam.lat * pi / 180.0)) * pi / T(21600.0); // 2*(2*pi/24/3600)\n    // fc should be pi / T(21600.0) * sin(phi)\n\n\n    int iright, itop;\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    iright = memloc(halowidth, blkmemwidth, ix + 1, iy, ib);\n    itop = memloc(halowidth, blkmemwidth, ix, iy + 1, ib);\n\n    T yup = T(iy) + T(1.0);\n    T ydwn = T(iy);\n\n    if (iy == XParam.blkwidth - 1)\n    {\n        if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n        {\n            yup = iy + 0.75;\n        }\n        //if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib])\n        //{\n        //  yup = iy + 1.000;\n        //}\n    }\n\n    if (iy == 0)\n    {\n        if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n        {\n            ydwn = iy - 0.25 ;\n        }\n\n    }\n\n\n\n\n\n    T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T fmu = T(1.0);\n    T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, ydwn) : T(1.0);\n    T fmup = T(1.0);\n    T fmvp = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, yup) : T(1.0);\n\n\n\n    T hi = XEv.h[i];\n    T uui = XEv.u[i];\n    T vvi = XEv.v[i];\n\n\n    T cmdinv, ga;\n\n    cmdinv = T(1.0) / (cm * delta);\n    ga = T(0.5) * g;\n\n\n    XAdv.dh[i] = T(-1.0) * (XFlux.Fhu[iright] - XFlux.Fhu[i] + XFlux.Fhv[itop] - XFlux.Fhv[i]) * cmdinv;\n\n\n\n    //double dmdl = (fmu[xplus + iy*nx] - fmu[i]) / (cm * delta);\n    //double dmdt = (fmv[ix + yplus*nx] - fmv[i]) / (cm  * delta);\n    T dmdl = (fmup - fmu) * cmdinv;// absurd if not spherical!\n    T dmdt = (fmvp - fmv) * cmdinv;;\n    T fG = vvi * dmdl - uui * dmdt;\n    XAdv.dhu[i] = (XFlux.Fqux[i] + XFlux.Fquy[i] - XFlux.Su[iright] - XFlux.Fquy[itop]) * cmdinv + fc * hi * vvi;\n    XAdv.dhv[i] = (XFlux.Fqvy[i] + XFlux.Fqvx[i] - XFlux.Sv[itop] - XFlux.Fqvx[iright]) * cmdinv - fc * hi * uui;\n\n    XAdv.dhu[i] += hi * (ga * hi * dmdl + fG * vvi);// This term is == 0 so should be commented here\n    XAdv.dhv[i] += hi * (ga * hi * dmdt - fG * uui);// Need double checking before doing that\n\n\n\n}\ntemplate __global__ void updateEVGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, FluxP&lt;float&gt; XFlux, AdvanceP&lt;float&gt; XAdv);\ntemplate __global__ void updateEVGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, FluxP&lt;double&gt; XFlux, AdvanceP&lt;double&gt; XAdv);\n\n\ntemplate &lt;class T&gt;__host__ void updateEVCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, FluxP&lt;T&gt; XFlux, AdvanceP&lt;T&gt; XAdv)\n{\n\n    //T eps = T(XParam.eps);\n    T delta;\n    T g = T(XParam.g);\n\n    T ybo;\n\n\n    int ib,lev;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        lev = XBlock.level[ib];\n        delta = calcres(T(XParam.delta), lev);\n\n        ybo = (T)XParam.yo + XBlock.yo[ib];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                T fc = XParam.spherical ? sin((ybo + calcres(T(XParam.dx), lev) * iy) * pi / 180.0) * pi / T(21600.0) : sin(T(XParam.lat * pi / 180.0)) * pi / T(21600.0); // 2*(2*pi/24/3600)\n\n                int iright, itop;\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                iright = memloc(halowidth, blkmemwidth, ix + 1, iy, ib);\n                itop = memloc(halowidth, blkmemwidth, ix, iy + 1, ib);\n\n\n                T yup = T(iy) + T(1.0);\n                T ydwn = T(iy);\n\n                if (iy == XParam.blkwidth - 1)\n                {\n                    if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n                    {\n                        yup = iy + T(0.75);\n                    }\n\n                }\n                if (iy == 0)\n                {\n                    if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n                    {\n                        ydwn = iy - T(0.25);\n                    }\n\n                }\n\n\n\n                T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n                T fmu = T(1.0);\n                T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, ydwn) : T(1.0);\n                T fmup = T(1.0);\n                T fmvp = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, yup) : T(1.0);\n\n                T hi = XEv.h[i];\n                T uui = XEv.u[i];\n                T vvi = XEv.v[i];\n\n\n                T cmdinv, ga;\n\n                cmdinv = T(1.0) / (cm * delta);\n                ga = T(0.5) * g;\n\n\n                XAdv.dh[i] = T(-1.0) * (XFlux.Fhu[iright] - XFlux.Fhu[i] + XFlux.Fhv[itop] - XFlux.Fhv[i]) * cmdinv;\n\n\n\n                //double dmdl = (fmu[xplus + iy*nx] - fmu[i]) / (cm * delta);\n                //double dmdt = (fmv[ix + yplus*nx] - fmv[i]) / (cm  * delta);\n                T dmdl = (fmup - fmu) / (cm * delta);// absurd if not spherical!\n                T dmdt = (fmvp - fmv) / (cm * delta);\n                T fG = vvi * dmdl - uui * dmdt;\n                XAdv.dhu[i] = (XFlux.Fqux[i] + XFlux.Fquy[i] - XFlux.Su[iright] - XFlux.Fquy[itop]) * cmdinv + fc * hi * vvi;\n                XAdv.dhv[i] = (XFlux.Fqvy[i] + XFlux.Fqvx[i] - XFlux.Sv[itop] - XFlux.Fqvx[iright]) * cmdinv - fc * hi * uui;\n\n\n                XAdv.dhu[i] += hi * (ga * hi * dmdl + fG * vvi);// This term is == 0 so should be commented here\n                XAdv.dhv[i] += hi * (ga * hi * dmdt - fG * uui);// Need double checking before doing that\n            }\n        }\n    }\n}\ntemplate __host__ void updateEVCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, FluxP&lt;float&gt; XFlux, AdvanceP&lt;float&gt; XAdv);\ntemplate __host__ void updateEVCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, FluxP&lt;double&gt; XFlux, AdvanceP&lt;double&gt; XAdv);\n\n\ntemplate &lt;class T&gt; __global__ void AdvkernelGPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt ,T* zb, EvolvingP&lt;T&gt; XEv, AdvanceP&lt;T&gt; XAdv, EvolvingP&lt;T&gt; XEv_o)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    T eps = T(XParam.eps);\n    T hold = XEv.h[i];\n    T ho, uo, vo;\n    T dhi = XAdv.dh[i];\n\n    T edt = XParam.ForceMassConserve ? dt : dhi &gt;= T(0.0) ? dt : min(dt, max(hold, XParam.eps) / abs(dhi));\n\n    //ho = max(hold + edt * dhi,T(0.0));\n    ho = hold + edt * dhi;\n\n    if (ho &gt; eps) {\n        //\n        uo = (hold * XEv.u[i] + edt * XAdv.dhu[i]) / ho;\n        vo = (hold * XEv.v[i] + edt * XAdv.dhv[i]) / ho;\n\n    }\n    else\n    {// dry\n\n        uo = T(0.0);\n        vo = T(0.0);\n    }\n\n\n    XEv_o.zs[i] = zb[i] + ho;\n    XEv_o.h[i] = ho;\n    XEv_o.u[i] = uo;\n    XEv_o.v[i] = vo;\n\n\n}\ntemplate __global__ void AdvkernelGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float dt, float* zb, EvolvingP&lt;float&gt; XEv, AdvanceP&lt;float&gt; XAdv, EvolvingP&lt;float&gt; XEv_o);\ntemplate __global__ void AdvkernelGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double dt, double* zb, EvolvingP&lt;double&gt; XEv, AdvanceP&lt;double&gt; XAdv, EvolvingP&lt;double&gt; XEv_o);\n\n\ntemplate &lt;class T&gt; __host__ void AdvkernelCPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt, T* zb, EvolvingP&lt;T&gt; XEv, AdvanceP&lt;T&gt; XAdv, EvolvingP&lt;T&gt; XEv_o)\n{\n    T eps = T(XParam.eps);\n\n\n\n    int ib;\n    //int halowidth = XParam.halowidth;\n    //int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(XParam, ix, iy, ib);\n\n\n                T hold = XEv.h[i];\n                T ho, uo, vo, dhi;\n\n                dhi = XAdv.dh[i];\n\n                T edt = XParam.ForceMassConserve ? dt : dhi &gt;= T(0.0) ? dt : min(dt, max(hold, XParam.eps) / abs(dhi));\n\n                ho = hold + edt * dhi;\n\n\n                if (ho &gt; eps) {\n                    //\n                    uo = (hold * XEv.u[i] + edt * XAdv.dhu[i]) / ho;\n                    vo = (hold * XEv.v[i] + edt * XAdv.dhv[i]) / ho;\n\n                }\n                else\n                {// dry\n\n                    uo = T(0.0);\n                    vo = T(0.0);\n                }\n\n\n                XEv_o.zs[i] = zb[i] + ho;\n                XEv_o.h[i] = ho;\n                XEv_o.u[i] = uo;\n                XEv_o.v[i] = vo;\n            }\n        }\n    }\n\n}\ntemplate __host__ void AdvkernelCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float dt, float* zb, EvolvingP&lt;float&gt; XEv, AdvanceP&lt;float&gt; XAdv, EvolvingP&lt;float&gt; XEv_o);\ntemplate __host__ void AdvkernelCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double dt, double* zb, EvolvingP&lt;double&gt; XEv, AdvanceP&lt;double&gt; XAdv, EvolvingP&lt;double&gt; XEv_o);\n\n\n\ntemplate &lt;class T&gt; __global__ void cleanupGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, EvolvingP&lt;T&gt; XEv_o)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n\n    XEv_o.h[i] = XEv.h[i];\n    XEv_o.zs[i] = XEv.zs[i];\n    XEv_o.u[i] = XEv.u[i];\n    XEv_o.v[i] = XEv.v[i];\n\n}\ntemplate __global__ void cleanupGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, EvolvingP&lt;float&gt; XEv_o);\ntemplate __global__ void cleanupGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, EvolvingP&lt;double&gt; XEv_o);\n\n\n\ntemplate &lt;class T&gt; __host__ void cleanupCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, EvolvingP&lt;T&gt; XEv_o)\n{\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                XEv_o.h[i] = XEv.h[i];\n                XEv_o.zs[i] = XEv.zs[i];\n                XEv_o.u[i] = XEv.u[i];\n                XEv_o.v[i] = XEv.v[i];\n            }\n        }\n    }\n\n}\ntemplate __host__ void cleanupCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, EvolvingP&lt;float&gt; XEv_o);\ntemplate __host__ void cleanupCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, EvolvingP&lt;double&gt; XEv_o);\n\n\ntemplate &lt;class T&gt; __host__ T timestepreductionCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, TimeP&lt;T&gt; XTime)\n{\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n\n    T dt = T(1.0) / epsi;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                dt = utils::min(dt, XTime.dtmax[i]);\n\n            }\n        }\n    }\n\n    return dt;\n}\ntemplate __host__ float timestepreductionCPU(Param XParam, Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, TimeP&lt;float&gt; XTime);\ntemplate __host__ double timestepreductionCPU(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, TimeP&lt;double&gt; XTime);\n\ntemplate &lt;class T&gt; __host__ T CalctimestepCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, TimeP&lt;T&gt; XTime)\n{\n\n\n    T dt= timestepreductionCPU(XParam,XLoop,XBlock,XTime);\n\n\n\n    // also don't allow dt to be larger than 1.5*dtmax (usually the last time step or smallest delta/sqrt(gh) if the first step)\n    if (dt &gt; (1.5 * XLoop.dtmax))\n    {\n        dt = T(1.5 * XLoop.dtmax);\n    }\n\n    if (ceil((XLoop.nextoutputtime - XLoop.totaltime) / dt) &gt; 0.0)\n    {\n        dt = T((XLoop.nextoutputtime - XLoop.totaltime) / ceil((XLoop.nextoutputtime - XLoop.totaltime) / dt));\n    }\n\n\n\n    return dt;\n\n\n}\ntemplate __host__ float CalctimestepCPU&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, TimeP&lt;float&gt; XTime);\ntemplate __host__ double CalctimestepCPU&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, TimeP&lt;double&gt; XTime);\n\n\ntemplate &lt;class T&gt; __host__ T CalctimestepGPU(Param XParam,Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, TimeP&lt;T&gt; XTime)\n{\n    T* dummy;\n    AllocateCPU(32, 1, dummy);\n\n    // densify dtmax (i.e. remove empty block and halo that may sit in the middle of the memory structure)\n    int s = XParam.nblk * (XParam.blkwidth* XParam.blkwidth); // Not blksize wich includes Halo\n\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    densify &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt;(XParam, XBlock, XTime.dtmax, XTime.arrmin);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    CUDA_CHECK(cudaMemcpy(XTime.dtmax, XTime.arrmin, s * sizeof(T), cudaMemcpyDeviceToDevice));\n\n\n    //GPU Harris reduction #3. 8.3x reduction #0  Note #7 if a lot faster\n    // This was successfully tested with a range of grid size\n    //reducemax3 &lt;&lt;&lt;gridDimLine, blockDimLine, 64*sizeof(float) &gt;&gt;&gt;(dtmax_g, arrmax_g, nx*ny)\n\n    int maxThreads = 256;\n    int threads = (s &lt; maxThreads * 2) ? nextPow2((s + 1) / 2) : maxThreads;\n    int blocks = (s + (threads * 2 - 1)) / (threads * 2);\n    int smemSize = (threads &lt;= 32) ? 2 * threads * sizeof(T) : threads * sizeof(T);\n    dim3 blockDimLine(threads, 1, 1);\n    dim3 gridDimLine(blocks, 1, 1);\n\n\n    reducemin3 &lt;&lt;&lt;gridDimLine, blockDimLine, smemSize &gt;&gt;&gt; (XTime.dtmax, XTime.arrmin, s);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n\n    s = gridDimLine.x;\n    while (s &gt; 1)//cpuFinalThreshold\n    {\n        threads = (s &lt; maxThreads * 2) ? nextPow2((s + 1) / 2) : maxThreads;\n        blocks = (s + (threads * 2 - 1)) / (threads * 2);\n\n        smemSize = (threads &lt;= 32) ? 2 * threads * sizeof(T) : threads * sizeof(T);\n\n        dim3 blockDimLineS(threads, 1, 1);\n        dim3 gridDimLineS(blocks, 1, 1);\n\n        CUDA_CHECK(cudaMemcpy(XTime.dtmax, XTime.arrmin, s * sizeof(T), cudaMemcpyDeviceToDevice));\n\n        reducemin3 &lt;&lt;&lt;gridDimLineS, blockDimLineS, smemSize &gt;&gt;&gt; (XTime.dtmax, XTime.arrmin, s);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        s = (s + (threads * 2 - 1)) / (threads * 2);\n    }\n\n\n    CUDA_CHECK(cudaMemcpy(dummy, XTime.arrmin, 32 * sizeof(T), cudaMemcpyDeviceToHost)); // replace 32 by word here?\n\n    if (dummy[0] &gt; (1.5 * XLoop.dtmax))\n    {\n        dummy[0] = T(1.5 * XLoop.dtmax);\n    }\n\n    if (ceil((XLoop.nextoutputtime - XLoop.totaltime) / dummy[0]) &gt; 0.0)\n    {\n        dummy[0] = T((XLoop.nextoutputtime - XLoop.totaltime) / ceil((XLoop.nextoutputtime - XLoop.totaltime) / dummy[0]));\n    }\n\n\n    return dummy[0];\n\n    free(dummy);\n}\ntemplate __host__ float CalctimestepGPU&lt;float&gt;(Param XParam,Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, TimeP&lt;float&gt; XTime);\ntemplate __host__ double CalctimestepGPU&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, TimeP&lt;double&gt; XTime);\n\n\n\n\ntemplate &lt;class T&gt; __global__ void reducemin3(T* g_idata, T* g_odata, unsigned int n)\n{\n    //T *sdata = SharedMemory&lt;T&gt;();\n    T* sdata = SharedMemory&lt;T&gt;();\n    // perform first level of reduction,\n    // reading from global memory, writing to shared memory\n    unsigned int tid = threadIdx.x;\n    unsigned int i = blockIdx.x * (blockDim.x * 2) + threadIdx.x;\n\n    T myMin = (i &lt; n) ? g_idata[i] : T(1e30);\n\n    if (i + blockDim.x &lt; n)\n        myMin = min(myMin, g_idata[i + blockDim.x]);\n\n    sdata[tid] = myMin;\n    __syncthreads();\n\n\n    // do reduction in shared mem\n    for (unsigned int s = blockDim.x / 2; s &gt; 0; s &gt;&gt;= 1)\n    {\n        if (tid &lt; s)\n        {\n            sdata[tid] = myMin = min(myMin, sdata[tid + s]);\n        }\n\n        __syncthreads();\n    }\n\n    // write result for this block to global mem\n    if (tid == 0) g_odata[blockIdx.x] = myMin;\n}\n\n\ntemplate &lt;class T&gt; __global__ void densify(Param XParam, BlockP&lt;T&gt; XBlock, T* g_idata, T* g_odata)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int o = ix + iy * blockDim.x + ibl * (blockDim.x * blockDim.x);\n\n    g_odata[o] = g_idata[i];\n}\n</code></pre>"},{"location":"BGFlood/Advection_8h/","title":"File Advection.h","text":""},{"location":"BGFlood/Advection_8h/#file-advectionh","title":"File Advection.h","text":"<p>FileList &gt; src &gt; Advection.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Spherical.h\"</code></li> </ul>"},{"location":"BGFlood/Advection_8h/#public-functions","title":"Public Functions","text":"Type Name __host__ void AdvkernelCPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * zb, EvolvingP&lt; T &gt; XEv, AdvanceP&lt; T &gt; XAdv, EvolvingP&lt; T &gt; XEv_o)  __global__ void AdvkernelGPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * zb, EvolvingP&lt; T &gt; XEv, AdvanceP&lt; T &gt; XAdv, EvolvingP&lt; T &gt; XEv_o)  __host__ T CalctimestepCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, TimeP&lt; T &gt; XTime)  __host__ T CalctimestepGPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, TimeP&lt; T &gt; XTime)  __host__ void cleanupCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, EvolvingP&lt; T &gt; XEv_o)  __global__ void cleanupGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, EvolvingP&lt; T &gt; XEv_o)  __global__ void densify (Param XParam, BlockP&lt; T &gt; XBlock, T * g_idata, T * g_odata)  __global__ void reducemin3 (T * g_idata, T * g_odata, unsigned int n)  __host__ T timestepreductionCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, TimeP&lt; T &gt; XTime)  __host__ void updateEVCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, FluxP&lt; T &gt; XFlux, AdvanceP&lt; T &gt; XAdv)  __global__ void updateEVGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, FluxP&lt; T &gt; XFlux, AdvanceP&lt; T &gt; XAdv)"},{"location":"BGFlood/Advection_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Advection_8h/#function-advkernelcpu","title":"function AdvkernelCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AdvkernelCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * zb,\n    EvolvingP &lt; T &gt; XEv,\n    AdvanceP &lt; T &gt; XAdv,\n    EvolvingP &lt; T &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/Advection_8h/#function-advkernelgpu","title":"function AdvkernelGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AdvkernelGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * zb,\n    EvolvingP &lt; T &gt; XEv,\n    AdvanceP &lt; T &gt; XAdv,\n    EvolvingP &lt; T &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/Advection_8h/#function-calctimestepcpu","title":"function CalctimestepCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ T CalctimestepCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    TimeP &lt; T &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/Advection_8h/#function-calctimestepgpu","title":"function CalctimestepGPU","text":"<pre><code>template&lt;class T&gt;\n__host__ T CalctimestepGPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    TimeP &lt; T &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/Advection_8h/#function-cleanupcpu","title":"function cleanupCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void cleanupCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    EvolvingP &lt; T &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/Advection_8h/#function-cleanupgpu","title":"function cleanupGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void cleanupGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    EvolvingP &lt; T &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/Advection_8h/#function-densify","title":"function densify","text":"<pre><code>template&lt;class T&gt;\n__global__ void densify (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * g_idata,\n    T * g_odata\n) \n</code></pre>"},{"location":"BGFlood/Advection_8h/#function-reducemin3","title":"function reducemin3","text":"<pre><code>template&lt;class T&gt;\n__global__ void reducemin3 (\n    T * g_idata,\n    T * g_odata,\n    unsigned int n\n) \n</code></pre>"},{"location":"BGFlood/Advection_8h/#function-timestepreductioncpu","title":"function timestepreductionCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ T timestepreductionCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    TimeP &lt; T &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/Advection_8h/#function-updateevcpu","title":"function updateEVCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void updateEVCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    FluxP &lt; T &gt; XFlux,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Advection_8h/#function-updateevgpu","title":"function updateEVGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void updateEVGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    FluxP &lt; T &gt; XFlux,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Advection.h</code></p>"},{"location":"BGFlood/Advection_8h_source/","title":"File Advection.h","text":""},{"location":"BGFlood/Advection_8h_source/#file-advectionh","title":"File Advection.h","text":"<p>File List &gt; src &gt; Advection.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ADVECTION_H\n#define ADVECTION_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"Spherical.h\"\n\ntemplate &lt;class T&gt; __global__ void updateEVGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, FluxP&lt;T&gt; XFlux, AdvanceP&lt;T&gt; XAdv);\ntemplate &lt;class T&gt; __host__ void updateEVCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, FluxP&lt;T&gt; XFlux, AdvanceP&lt;T&gt; XAdv);\n\ntemplate &lt;class T&gt; __global__ void AdvkernelGPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt, T* zb, EvolvingP&lt;T&gt; XEv, AdvanceP&lt;T&gt; XAdv, EvolvingP&lt;T&gt; XEv_o);\ntemplate &lt;class T&gt; __host__ void AdvkernelCPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt, T* zb, EvolvingP&lt;T&gt; XEv, AdvanceP&lt;T&gt; XAdv, EvolvingP&lt;T&gt; XEv_o);\n\ntemplate &lt;class T&gt; __global__ void cleanupGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, EvolvingP&lt;T&gt; XEv_o);\ntemplate &lt;class T&gt; __host__ void cleanupCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, EvolvingP&lt;T&gt; XEv_o);\n\ntemplate &lt;class T&gt; __host__ T CalctimestepCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, TimeP&lt;T&gt; XTime);\ntemplate &lt;class T&gt; __host__ T CalctimestepGPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, TimeP&lt;T&gt; XTime);\n\ntemplate &lt;class T&gt; __host__ T timestepreductionCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, TimeP&lt;T&gt; XTime);\n\ntemplate &lt;class T&gt; __global__ void reducemin3(T* g_idata, T* g_odata, unsigned int n);\n\ntemplate &lt;class T&gt; __global__ void densify(Param XParam, BlockP&lt;T&gt; XBlock, T* g_idata, T* g_odata);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Arrays_8h/","title":"File Arrays.h","text":""},{"location":"BGFlood/Arrays_8h/#file-arraysh","title":"File Arrays.h","text":"<p>FileList &gt; src &gt; Arrays.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Input.h\"</code></li> </ul>"},{"location":"BGFlood/Arrays_8h/#classes","title":"Classes","text":"Type Name struct AdaptP struct AdvanceP &lt;class T&gt; struct BlockP &lt;class T&gt; struct BndblockP &lt;class T&gt; struct EvolvingMLP &lt;class T&gt; struct EvolvingP &lt;class T&gt; struct EvolvingP_M &lt;class T&gt; struct FluxMLP &lt;class T&gt; struct FluxP &lt;class T&gt; struct GradientsMLP &lt;class T&gt; struct GradientsP &lt;class T&gt; struct Loop &lt;class T&gt; struct Model &lt;class T&gt; struct RiverBlk struct RiverInfo &lt;class T&gt; struct TimeP &lt;class T&gt; struct maskinfo struct outP struct outzoneB <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/Arrays_8h_source/","title":"File Arrays.h","text":""},{"location":"BGFlood/Arrays_8h_source/#file-arraysh","title":"File Arrays.h","text":"<p>File List &gt; src &gt; Arrays.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ARRAYS_H\n#define ARRAYS_H\n\n#include \"General.h\"\n#include \"Input.h\"\n\n\ntemplate &lt;class T&gt;\nstruct GradientsP\n{\n    T* dzsdx;\n    T* dhdx;\n    T* dudx;\n    T* dvdx;\n\n    T* dzsdy;\n    T* dhdy;\n    T* dudy;\n    T* dvdy;\n\n    T* dzbdx;\n    T* dzbdy;\n};\n\ntemplate &lt;class T&gt;\nstruct GradientsMLP\n{\n\n    T* dhdx;\n    T* dudx;\n    T* dvdx;\n\n\n    T* dhdy;\n    T* dudy;\n    T* dvdy;\n};\n\n\ntemplate &lt;class T&gt;\nstruct EvolvingP\n{\n    T* zs;\n    T* h;\n    T* u;\n    T* v;\n};\n\ntemplate &lt;class T&gt;\nstruct EvolvingMLP\n{\n    T* h;\n    T* u;\n    T* v;\n};\n\n//subclass inheriting from EvolvingP for Mean/Max\ntemplate &lt;class T&gt;\nstruct EvolvingP_M : public EvolvingP&lt;T&gt;\n{\n    T* U;  //Norm of the velocity\n    T* hU; //h*sqrt(u^2+v^2)\n};\n\ntemplate &lt;class T&gt;\nstruct FluxP\n{\n    T* Su,* Sv;\n    T* Fqux, * Fquy;\n    T* Fqvx, * Fqvy;\n    T* Fhu, * Fhv;\n};\n\ntemplate &lt;class T&gt;\nstruct FluxMLP\n{\n    //\n    T* hu, * hv;\n    T* hfu, * hfv;\n    T* hau, * hav;\n    T* Fux, * Fvy;\n    T* Fuy, * Fvx;\n\n};\n\ntemplate &lt;class T&gt;\nstruct AdvanceP\n{\n    T* dh;\n    T* dhu;\n    T* dhv;\n};\n\n\nstruct outP\n{\n    float* z;\n    short* z_s;\n    int level;\n    double xmin, xmax, ymin, ymax;\n};\n\n\nstruct maskinfo \n{\n\n    int nblk = 0; //number of blocks where this bnd applies\n\n    int* blks; // array of block where bnd applies \n    // 8 digit binary where 1 is a mask and 0 is not a mask with the first digit represent the left bottom side the rest is clockwise (i.e.left-bot left-top, top-left, top-right, right-top, right-bot, bot-right, bot-left)\n    int* side; // e.g. 11000000 for the entire left side being a mask\n\n    int type = 0;\n\n\n};\n\ntemplate &lt;class T&gt;\nstruct RiverInfo\n{\n    int nbir;\n    int nburmax; // size of (max number of) unique block with rivers  \n    int nribmax; // size of (max number of) rivers in one block\n    int* Xbidir; // array of block id for each river size(nburmax,nribmax)\n    int* Xridib; // array of river id in each block size(nburmax,nribmax)\n    T* xstart;\n    T* xend;\n    T* ystart;\n    T *yend;\n    T* qnow; // qnow is a pin mapped and so both pointers are needed here\n    T* qnow_g; // this simplify the code later\n\n};\n\n\n// outzone info used to actually write the nc files (one nc file by zone, the default zone is the full domain)\nstruct outzoneB \n{\n    int nblk; //number of blocks concerned\n    int* blk; // one zone will spread across multiple blocks (entire blocks containing a part of the area will be output)\n    double xo, xmax, yo, ymax; // Real zone for output (because we output full blocks)(corner of cells, as Xparam.xo)\n    std::string outname; // name for the output file (one for each zone)\n    int maxlevel; // maximum level in the zone\n    int minlevel; //minimum level in the zone\n    std::vector&lt;double&gt; OutputT; //Next time for the output of this zone\n    int index_next_OutputT = 0; //Index of next time output\n};\n\n\ntemplate &lt;class T&gt;\nstruct BlockP\n{\n    T* xo, *yo;\n    int* BotLeft, *BotRight;\n    int* TopLeft, *TopRight;\n    int* LeftBot, *LeftTop;\n    int* RightBot, *RightTop;\n\n    int* level;\n    int* active; // active blocks\n    int* activeCell; //To apply forcings (rain) only on these\n\n    maskinfo mask;\n\n    std::vector&lt;outzoneB&gt; outZone;\n};\n\n\nstruct AdaptP\n{\n    int *newlevel;\n    int *availblk, * csumblk;\n    int *invactive;\n    bool * coarsen, *refine;\n\n};\n\n\n\ntemplate &lt;class T&gt;\nstruct BndblockP\n{\n    int nblkriver, nblkTs, nbndblkleft, nbndblkright, nbndblktop, nbndblkbot;\n    int* river;\n    int* Tsout;\n    //int * DrainSink;\n    //int * DrainSource;\n    //int * Bridges;\n\n    int* left;\n    int* right;\n    int* top;\n    int* bot;\n\n    RiverInfo&lt;T&gt; Riverinfo;\n\n\n};\n\nstruct RiverBlk\n{\n    std::vector&lt;int&gt; block;\n};\n\n\n\n\n\ntemplate &lt;class T&gt;\nstruct TimeP\n{\n    T totaltime;\n    T dt;\n    T* dtmax;\n    T* arrmax, *arrmin;\n};\n\ntemplate &lt;class T&gt;\nstruct Model\n{\n    EvolvingP&lt;T&gt; evolv;\n    EvolvingP&lt;T&gt; evolv_o;\n\n    GradientsP&lt;T&gt; grad;\n    FluxP&lt;T&gt; flux;\n    FluxMLP&lt;T&gt; fluxml;\n    AdvanceP&lt;T&gt; adv;\n\n    //external forcing\n    T* zb;\n    T* cf;\n    T* il;\n    T* cl;\n\n    //GroundWater elevation (due to the accumulation of water by infiltration during the simulation)\n    T* hgw;\n\n    // Used for external forcing too\n    // May need a better placeholder\n    T* Patm, *datmpdx, *datmpdy;\n\n    TimeP&lt;T&gt; time;\n\n\n\n    // \n    std::map&lt;std::string, T *&gt; OutputVarMap;\n    std::map&lt;std::string, std::string&gt; Outvarlongname;\n    std::map&lt;std::string, std::string&gt; Outvarstdname;\n    std::map&lt;std::string, std::string&gt; Outvarunits;\n    std::vector&lt;double&gt; OutputT;\n\n    //other output\n    //std::vector&lt; std::vector&lt; Pointout &gt; &gt; TSallout;\n    T* TSstore;//buffer for TS data so not to save to disk too often\n    //T* vort;\n    //T* U;\n    EvolvingP_M&lt;T&gt; evmean;\n    EvolvingP_M&lt;T&gt; evmax;\n    T* wettime; //Inundation duration (h &gt; 0.1)\n\n    //Block information\n    BlockP&lt;T&gt; blocks;\n\n    AdaptP adapt;\n\n    BndblockP&lt;T&gt; bndblk;\n\n\n\n\n};\n\n\n// structure of useful variable for runing the main loop\ntemplate &lt;class T&gt;\nstruct Loop\n{\n    double nextoutputtime;\n    double dt;\n    double dtmax;\n    double totaltime;\n\n\n    // Needed to average mean varable for output\n    int nstep = 0;\n    //useful for calculating avg timestep\n    int nstepout = 0;\n    // Needed to identify next output time\n    int indNextoutputtime = 0;\n\n    // usefull for Time series output\n    int nTSsteps = 0;\n    std::vector&lt; std::vector&lt; Pointout &gt; &gt; TSAllout;\n\n    int windstep = 1;\n    int atmpstep = 1;\n    int rainstep = 1;\n\n    bool winduniform;\n    bool rainuniform;\n    bool atmpuniform;\n\n    T uwinduni = T(0.0);\n    T vwinduni = T(0.0);\n    T atmpuni;\n    T rainuni = T(0.0);\n\n    // CUDA specific stuff\n\n    dim3 blockDim;// (16, 16, 1);\n    dim3 gridDim;\n\n    const int num_streams = 4;\n\n    cudaStream_t streams[4];\n\n    T epsilon;\n    T hugeposval;\n    T hugenegval;\n\n};\n\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/BG__Flood_8cu/","title":"File BG_Flood.cu","text":""},{"location":"BGFlood/BG__Flood_8cu/#file-bg_floodcu","title":"File BG_Flood.cu","text":"<p>FileList &gt; src &gt; BG_Flood.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"BG_Flood.h\"</code></li> </ul>"},{"location":"BGFlood/BG__Flood_8cu/#public-functions","title":"Public Functions","text":"Type Name int main (int argc, char * argv)  int mainwork (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)"},{"location":"BGFlood/BG__Flood_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/BG__Flood_8cu/#function-main","title":"function main","text":"<pre><code>int main (\n    int argc,\n    char * argv\n) \n</code></pre>"},{"location":"BGFlood/BG__Flood_8cu/#function-mainwork","title":"function mainwork","text":"<pre><code>template&lt;class T&gt;\nint mainwork (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/BG_Flood.cu</code></p>"},{"location":"BGFlood/BG__Flood_8cu_source/","title":"File BG_Flood.cu","text":""},{"location":"BGFlood/BG__Flood_8cu_source/#file-bg_floodcu","title":"File BG_Flood.cu","text":"<p>File List &gt; src &gt; BG_Flood.cu</p> <p>Go to the documentation of this file</p> <pre><code>// BG_Flood Main function                                                       //\n// Copyright (C) 2018 Bosserelle                                                //\n// This code contains an adaptation of the St Venant equation from Basilisk     //\n// See                                                                          //\n// http://basilisk.fr/src/saint-venant.h and                                    //\n// S. Popinet. Quadtree-adaptive tsunami modelling. Ocean Dynamics,             //\n// doi: 61(9) : 1261 - 1285, 2011                                               //\n//                                                                              //\n// This program is free software: you can redistribute it and/or modify         //\n// it under the terms of the GNU General Public License as published by         //\n// the Free Software Foundation.                                                //\n//                                                                              //\n// This program is distributed in the hope that it will be useful,              //\n// but WITHOUT ANY WARRANTY; without even the implied warranty of               //\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                //\n// GNU General Public License for more details.                                 //\n//                                                                              //\n// You should have received a copy of the GNU General Public License            //\n// along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.        //\n\n// includes, system\n\n#include \"BG_Flood.h\"\n\n\nint main(int argc, char* argv[])\n{\n    //===========================================\n    // Read model argument (filename). If one is not given use the default name\n    std::string ParamFile;\n\n    if (argc &gt; 1)\n    {\n        ParamFile = argv[1];\n    }\n    else\n    {\n        ParamFile = \"BG_param.txt\";\n    }\n\n    //std::cout &lt;&lt; ParamFile &lt;&lt; '\\n';\n\n    //===========================================\n    //  Define the main parameter controling the model (XModels class at produced later) \n    Param XParam;\n    Forcing&lt;float&gt; XForcing; // for reading and storing forcing data (CPU only) // by default we read only float precision!\n    // Start timer to keep track of time\n    XParam.startcputime = clock();\n\n\n    // Create/overwrite existing \n    create_logfile();\n\n    //============================================\n    // Read Operational file\n    // Also check XParam sanity\n\n    Readparamfile(XParam, XForcing, ParamFile);\n\n\n    //============================================\n    // Create external forcing and model pointers\n    // Before this is done we need to check\n    // if the model will be double or float precision\n\n    Model&lt;double&gt; XModel_d; // For CPU double pointers\n    Model&lt;double&gt; XModel_gd; // For GPU double pointers\n\n    Model&lt;float&gt; XModel_f; // For CPU float pointers\n    Model&lt;float&gt; XModel_gf; // For GPU float pointers\n\n    if (XParam.doubleprecision &lt; 1)\n    {\n        // Call the Float precision run\n        mainwork(XParam, XForcing, XModel_f, XModel_gf);\n    }\n    else\n    {\n        mainwork(XParam, XForcing, XModel_d, XModel_gd);\n    }\n\n}\n\ntemplate &lt; class T &gt; int mainwork(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    //============================================\n    // Read the forcing data (Including bathymetry)\n    readforcing(XParam, XForcing);\n\n    //=============================================\n    // Verify Compatibility of forcing and model Parameters\n    checkparamsanity(XParam, XForcing);\n\n    //============================================\n    // Prepare initial mesh layout\n    InitMesh(XParam, XForcing, XModel);\n\n    //============================================\n    // Prepare initial conditions on CPU\n    InitialConditions(XParam, XForcing, XModel);\n\n    //============================================\n    // Initial adaptation\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    //============================================\n    // Setup GPU (bypassed within the function if no suitable GPU is available)\n    SetupGPU(XParam, XModel,XForcing, XModel_g);\n\n\n    //\n    log(\"\\nModel setup complete\");\n    log(\"#################################\");\n    //===========================================\n    //   End of Initialisation time\n    //===========================================\n    XParam.setupcputime = clock();\n    bool isfailed = false;\n\n    if (XParam.test &lt; 0)\n    {\n        //============================================\n        // MainLoop\n        MainLoop(XParam, XForcing, XModel, XModel_g);\n    }\n    else\n    {\n        //============================================\n        // Testing\n        //Gaussianhump(XParam, XModel, XModel_g);\n        isfailed = Testing(XParam, XForcing, XModel, XModel_g);\n    }\n\n\n\n    //===========================================\n    //   End of Model\n    //===========================================\n    XParam.endcputime = clock();\n\n    //===========================================\n    //   Log the timer\n    //===========================================\n    log(\"#################################\");\n    log(\"End Computation\");\n    log(\"#################################\");\n    log(\"Total runtime= \" + std::to_string((XParam.endcputime - XParam.startcputime) / CLOCKS_PER_SEC) + \" seconds\");\n    log(\"Model Setup time= \" + std::to_string((XParam.setupcputime - XParam.startcputime) / CLOCKS_PER_SEC) + \" seconds\");\n    log(\"Model runtime= \" + std::to_string((XParam.endcputime - XParam.setupcputime) / CLOCKS_PER_SEC) + \" seconds\");\n\n\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        size_t free_byte;\n\n        size_t total_byte;\n\n        CUDA_CHECK(cudaMemGetInfo(&amp;free_byte, &amp;total_byte));\n\n        XParam.GPU_totalmem_byte = (total_byte - free_byte) - XParam.GPU_initmem_byte;\n        log(\"Model final memory usage= \" + std::to_string((XParam.GPU_totalmem_byte) / 1024.0 / 1024.0) + \" MB\");\n\n    }\n\n\n    //============================================\n    // Cleanup and free memory\n    //\n    if (XParam.test &lt; 0)\n    {\n        exit(0);\n    }\n    else \n    {\n        exit(isfailed);\n    }\n\n}\n</code></pre>"},{"location":"BGFlood/BG__Flood_8h/","title":"File BG_Flood.h","text":""},{"location":"BGFlood/BG__Flood_8h/#file-bg_floodh","title":"File BG_Flood.h","text":"<p>FileList &gt; src &gt; BG_Flood.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"ReadInput.h\"</code></li> <li><code>#include \"ReadForcing.h\"</code></li> <li><code>#include \"Setup_GPU.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Mesh.h\"</code></li> <li><code>#include \"InitialConditions.h\"</code></li> <li><code>#include \"Adaptation.h\"</code></li> <li><code>#include \"Mainloop.h\"</code></li> <li><code>#include \"Testing.h\"</code></li> </ul>"},{"location":"BGFlood/BG__Flood_8h/#public-functions","title":"Public Functions","text":"Type Name int mainwork (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)"},{"location":"BGFlood/BG__Flood_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/BG__Flood_8h/#function-mainwork","title":"function mainwork","text":"<pre><code>template&lt;class T&gt;\nint mainwork (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/BG_Flood.h</code></p>"},{"location":"BGFlood/BG__Flood_8h_source/","title":"File BG_Flood.h","text":""},{"location":"BGFlood/BG__Flood_8h_source/#file-bg_floodh","title":"File BG_Flood.h","text":"<p>File List &gt; src &gt; BG_Flood.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef BGFLOOD_H\n#define BGFLOOD_H\n// includes, system\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"ReadInput.h\"\n#include \"ReadForcing.h\"\n#include \"Setup_GPU.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"Mesh.h\"\n#include \"InitialConditions.h\"\n#include \"Adaptation.h\"\n#include \"Setup_GPU.h\"\n#include \"Mainloop.h\"\n\n#include \"Testing.h\"\n\n\ntemplate &lt; class T &gt; int mainwork(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Boundary_8cu/","title":"File Boundary.cu","text":""},{"location":"BGFlood/Boundary_8cu/#file-boundarycu","title":"File Boundary.cu","text":"<p>FileList &gt; src &gt; Boundary.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Boundary.h\"</code></li> </ul>"},{"location":"BGFlood/Boundary_8cu/#public-functions","title":"Public Functions","text":"Type Name __device__ __host__ void ABS1D (T g, T sign, T zsbnd, T zsinside, T hinside, T utbnd, T unbnd, T &amp; un, T &amp; ut, T &amp; zs, T &amp; h)  __device__ __host__ void ABS1DQ (T g, T sign, T factime, T facrel, T zs, T zsbnd, T zsinside, T h, T &amp; qmean, T &amp; q, T &amp; G, T &amp; S)  __device__ __host__ void Dirichlet1D (T g, T sign, T zsbnd, T zsinside, T hinside, T uninside, T &amp; un, T &amp; ut, T &amp; zs, T &amp; h)  __device__ __host__ void Dirichlet1Q (T g, T sign, T zsbnd, T zsinside, T hinside, T uninside, T &amp; q)  void Flowbnd (Param XParam, Loop&lt; T &gt; &amp; XLoop, BlockP&lt; T &gt; XBlock, bndparam side, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; T &gt; XEv)  template void Flowbnd&lt; double &gt; (Param XParam, Loop&lt; double &gt; &amp; XLoop, BlockP&lt; double &gt; XBlock, bndparam side, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; double &gt; XEv)  template void Flowbnd&lt; float &gt; (Param XParam, Loop&lt; float &gt; &amp; XLoop, BlockP&lt; float &gt; XBlock, bndparam side, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; float &gt; XEv)  void FlowbndFlux (Param XParam, double totaltime, BlockP&lt; T &gt; XBlock, bndsegment bndseg, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; T &gt; XEv, FluxP&lt; T &gt; XFlux)  template void FlowbndFlux&lt; double &gt; (Param XParam, double totaltime, BlockP&lt; double &gt; XBlock, bndsegment bndseg, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; double &gt; XEv, FluxP&lt; double &gt; XFlux)  template void FlowbndFlux&lt; float &gt; (Param XParam, double totaltime, BlockP&lt; float &gt; XBlock, bndsegment bndseg, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; float &gt; XEv, FluxP&lt; float &gt; XFlux)  void FlowbndFluxML (Param XParam, double totaltime, BlockP&lt; T &gt; XBlock, bndsegment bndseg, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; T &gt; XEv, FluxMLP&lt; T &gt; XFlux)  template void FlowbndFluxML&lt; double &gt; (Param XParam, double totaltime, BlockP&lt; double &gt; XBlock, bndsegment bndseg, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; double &gt; XEv, FluxMLP&lt; double &gt; XFlux)  template void FlowbndFluxML&lt; float &gt; (Param XParam, double totaltime, BlockP&lt; float &gt; XBlock, bndsegment bndseg, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; float &gt; XEv, FluxMLP&lt; float &gt; XFlux)  void FlowbndFluxold (Param XParam, double totaltime, BlockP&lt; T &gt; XBlock, bndparam side, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; T &gt; XEv, FluxP&lt; T &gt; XFlux)  template void FlowbndFluxold&lt; double &gt; (Param XParam, double totaltime, BlockP&lt; double &gt; XBlock, bndparam side, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; double &gt; XEv, FluxP&lt; double &gt; XFlux)  template void FlowbndFluxold&lt; float &gt; (Param XParam, double totaltime, BlockP&lt; float &gt; XBlock, bndparam side, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; float &gt; XEv, FluxP&lt; float &gt; XFlux)  __host__ __device__ int Inside (int halowidth, int blkmemwidth, int isright, int istop, int ix, int iy, int ib)  __host__ void bndCPU (Param XParam, bndparam side, BlockP&lt; T &gt; XBlock, std::vector&lt; double &gt; zsbndvec, std::vector&lt; double &gt; uubndvec, std::vector&lt; double &gt; vvbndvec, DynForcingP&lt; float &gt; Atmp, T * zs, T * h, T * un, T * ut)  template __host__ void bndCPU&lt; double &gt; (Param XParam, bndparam side, BlockP&lt; double &gt; XBlock, std::vector&lt; double &gt; zsbndvec, std::vector&lt; double &gt; uubndvec, std::vector&lt; double &gt; vvbndvec, DynForcingP&lt; float &gt; Atmp, double * zs, double * h, double * un, double * ut)  template __host__ void bndCPU&lt; float &gt; (Param XParam, bndparam side, BlockP&lt; float &gt; XBlock, std::vector&lt; double &gt; zsbndvec, std::vector&lt; double &gt; uubndvec, std::vector&lt; double &gt; vvbndvec, DynForcingP&lt; float &gt; Atmp, float * zs, float * h, float * un, float * ut)  __global__ void bndFluxGPUSide (Param XParam, bndsegmentside side, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Atmp, DynForcingP&lt; float &gt; Zsmap, bool uniform, int type, float zsbnd, T taper, T * zs, T * h, T * un, T * ut, T * Fh, T * Fq, T * Ss)  void bndFluxGPUSideCPU (Param XParam, bndsegmentside side, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Atmp, DynForcingP&lt; float &gt; Zsmap, bool uniform, int type, float zsbnd, T taper, T * zs, T * h, T * un, T * ut, T * Fh, T * Fq, T * Ss)  __global__ void bndGPU (Param XParam, bndparam side, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Atmp, float itime, T * zs, T * h, T * un, T * ut)  template __global__ void bndGPU&lt; double &gt; (Param XParam, bndparam side, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; Atmp, float itime, double * zs, double * h, double * un, double * ut)  template __global__ void bndGPU&lt; float &gt; (Param XParam, bndparam side, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; Atmp, float itime, float * zs, float * h, float * un, float * ut)  __device__ __host__ void findmaskside (int side, bool &amp; isleftbot, bool &amp; islefttop, bool &amp; istopleft, bool &amp; istopright, bool &amp; isrighttop, bool &amp; isrightbot, bool &amp; isbotright, bool &amp; isbotleft)  __device__ __host__ void halowall (T zsinside, T &amp; un, T &amp; ut, T &amp; zs, T &amp; h, T &amp; zb)  __host__ __device__ bool isbnd (int isright, int istop, int blkwidth, int ix, int iy)  __host__ void maskbnd (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  template __host__ void maskbnd&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template __host__ void maskbnd&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  __global__ void maskbndGPUFluxbot (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux)  template __global__ void maskbndGPUFluxbot&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, FluxP&lt; double &gt; Flux)  template __global__ void maskbndGPUFluxbot&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, FluxP&lt; float &gt; Flux)  __global__ void maskbndGPUFluxleft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, FluxP&lt; T &gt; Flux)  template __global__ void maskbndGPUFluxleft&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, FluxP&lt; double &gt; Flux)  template __global__ void maskbndGPUFluxleft&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, FluxP&lt; float &gt; Flux)  __global__ void maskbndGPUFluxright (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux)  template __global__ void maskbndGPUFluxright&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, FluxP&lt; double &gt; Flux)  template __global__ void maskbndGPUFluxright&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, FluxP&lt; float &gt; Flux)  __global__ void maskbndGPUFluxtop (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux)  template __global__ void maskbndGPUFluxtop&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, FluxP&lt; double &gt; Flux)  template __global__ void maskbndGPUFluxtop&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, FluxP&lt; float &gt; Flux)  __global__ void maskbndGPUbot (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  template __global__ void maskbndGPUbot&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template __global__ void maskbndGPUbot&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  __global__ void maskbndGPUleft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  template __global__ void maskbndGPUleft&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template __global__ void maskbndGPUleft&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  __global__ void maskbndGPUright (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  template __global__ void maskbndGPUright&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template __global__ void maskbndGPUright&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  __global__ void maskbndGPUtop (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  template __global__ void maskbndGPUtop&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template __global__ void maskbndGPUtop&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  __device__ __host__ void noslipbnd (T zsinside, T hinside, T &amp; un, T &amp; ut, T &amp; zs, T &amp; h)  __device__ __host__ void noslipbndQ (T &amp; F, T &amp; G, T &amp; S)"},{"location":"BGFlood/Boundary_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Boundary_8cu/#function-abs1d","title":"function ABS1D","text":"<pre><code>template&lt;class T&gt;\n__device__ __host__ void ABS1D (\n    T g,\n    T sign,\n    T zsbnd,\n    T zsinside,\n    T hinside,\n    T utbnd,\n    T unbnd,\n    T &amp; un,\n    T &amp; ut,\n    T &amp; zs,\n    T &amp; h\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-abs1dq","title":"function ABS1DQ","text":"<pre><code>template&lt;class T&gt;\n__device__ __host__ void ABS1DQ (\n    T g,\n    T sign,\n    T factime,\n    T facrel,\n    T zs,\n    T zsbnd,\n    T zsinside,\n    T h,\n    T &amp; qmean,\n    T &amp; q,\n    T &amp; G,\n    T &amp; S\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-dirichlet1d","title":"function Dirichlet1D","text":"<pre><code>template&lt;class T&gt;\n__device__ __host__ void Dirichlet1D (\n    T g,\n    T sign,\n    T zsbnd,\n    T zsinside,\n    T hinside,\n    T uninside,\n    T &amp; un,\n    T &amp; ut,\n    T &amp; zs,\n    T &amp; h\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-dirichlet1q","title":"function Dirichlet1Q","text":"<pre><code>template&lt;class T&gt;\n__device__ __host__ void Dirichlet1Q (\n    T g,\n    T sign,\n    T zsbnd,\n    T zsinside,\n    T hinside,\n    T uninside,\n    T &amp; q\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-flowbnd","title":"function Flowbnd","text":"<pre><code>template&lt;class T&gt;\nvoid Flowbnd (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    bndparam side,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; T &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-flowbnd-double","title":"function Flowbnd&lt; double &gt;","text":"<pre><code>template void Flowbnd&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; &amp; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    bndparam side,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; double &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-flowbnd-float","title":"function Flowbnd&lt; float &gt;","text":"<pre><code>template void Flowbnd&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; &amp; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    bndparam side,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; float &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-flowbndflux","title":"function FlowbndFlux","text":"<pre><code>template&lt;class T&gt;\nvoid FlowbndFlux (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; T &gt; XBlock,\n    bndsegment bndseg,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; T &gt; XEv,\n    FluxP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-flowbndflux-double","title":"function FlowbndFlux&lt; double &gt;","text":"<pre><code>template void FlowbndFlux&lt; double &gt; (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; double &gt; XBlock,\n    bndsegment bndseg,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; double &gt; XEv,\n    FluxP &lt; double &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-flowbndflux-float","title":"function FlowbndFlux&lt; float &gt;","text":"<pre><code>template void FlowbndFlux&lt; float &gt; (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; float &gt; XBlock,\n    bndsegment bndseg,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; float &gt; XEv,\n    FluxP &lt; float &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-flowbndfluxml","title":"function FlowbndFluxML","text":"<pre><code>template&lt;class T&gt;\nvoid FlowbndFluxML (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; T &gt; XBlock,\n    bndsegment bndseg,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; T &gt; XEv,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-flowbndfluxml-double","title":"function FlowbndFluxML&lt; double &gt;","text":"<pre><code>template void FlowbndFluxML&lt; double &gt; (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; double &gt; XBlock,\n    bndsegment bndseg,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; double &gt; XEv,\n    FluxMLP &lt; double &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-flowbndfluxml-float","title":"function FlowbndFluxML&lt; float &gt;","text":"<pre><code>template void FlowbndFluxML&lt; float &gt; (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; float &gt; XBlock,\n    bndsegment bndseg,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; float &gt; XEv,\n    FluxMLP &lt; float &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-flowbndfluxold","title":"function FlowbndFluxold","text":"<pre><code>template&lt;class T&gt;\nvoid FlowbndFluxold (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; T &gt; XBlock,\n    bndparam side,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; T &gt; XEv,\n    FluxP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-flowbndfluxold-double","title":"function FlowbndFluxold&lt; double &gt;","text":"<pre><code>template void FlowbndFluxold&lt; double &gt; (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; double &gt; XBlock,\n    bndparam side,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; double &gt; XEv,\n    FluxP &lt; double &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-flowbndfluxold-float","title":"function FlowbndFluxold&lt; float &gt;","text":"<pre><code>template void FlowbndFluxold&lt; float &gt; (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; float &gt; XBlock,\n    bndparam side,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; float &gt; XEv,\n    FluxP &lt; float &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-inside","title":"function Inside","text":"<pre><code>__host__ __device__ int Inside (\n    int halowidth,\n    int blkmemwidth,\n    int isright,\n    int istop,\n    int ix,\n    int iy,\n    int ib\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-bndcpu","title":"function bndCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void bndCPU (\n    Param XParam,\n    bndparam side,\n    BlockP &lt; T &gt; XBlock,\n    std::vector&lt; double &gt; zsbndvec,\n    std::vector&lt; double &gt; uubndvec,\n    std::vector&lt; double &gt; vvbndvec,\n    DynForcingP &lt; float &gt; Atmp,\n    T * zs,\n    T * h,\n    T * un,\n    T * ut\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-bndcpu-double","title":"function bndCPU&lt; double &gt;","text":"<pre><code>template __host__ void bndCPU&lt; double &gt; (\n    Param XParam,\n    bndparam side,\n    BlockP &lt; double &gt; XBlock,\n    std::vector&lt; double &gt; zsbndvec,\n    std::vector&lt; double &gt; uubndvec,\n    std::vector&lt; double &gt; vvbndvec,\n    DynForcingP &lt; float &gt; Atmp,\n    double * zs,\n    double * h,\n    double * un,\n    double * ut\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-bndcpu-float","title":"function bndCPU&lt; float &gt;","text":"<pre><code>template __host__ void bndCPU&lt; float &gt; (\n    Param XParam,\n    bndparam side,\n    BlockP &lt; float &gt; XBlock,\n    std::vector&lt; double &gt; zsbndvec,\n    std::vector&lt; double &gt; uubndvec,\n    std::vector&lt; double &gt; vvbndvec,\n    DynForcingP &lt; float &gt; Atmp,\n    float * zs,\n    float * h,\n    float * un,\n    float * ut\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-bndfluxgpuside","title":"function bndFluxGPUSide","text":"<pre><code>template&lt;class T&gt;\n__global__ void bndFluxGPUSide (\n    Param XParam,\n    bndsegmentside side,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Atmp,\n    DynForcingP &lt; float &gt; Zsmap,\n    bool uniform,\n    int type,\n    float zsbnd,\n    T taper,\n    T * zs,\n    T * h,\n    T * un,\n    T * ut,\n    T * Fh,\n    T * Fq,\n    T * Ss\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-bndfluxgpusidecpu","title":"function bndFluxGPUSideCPU","text":"<pre><code>template&lt;class T&gt;\nvoid bndFluxGPUSideCPU (\n    Param XParam,\n    bndsegmentside side,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Atmp,\n    DynForcingP &lt; float &gt; Zsmap,\n    bool uniform,\n    int type,\n    float zsbnd,\n    T taper,\n    T * zs,\n    T * h,\n    T * un,\n    T * ut,\n    T * Fh,\n    T * Fq,\n    T * Ss\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-bndgpu","title":"function bndGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void bndGPU (\n    Param XParam,\n    bndparam side,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Atmp,\n    float itime,\n    T * zs,\n    T * h,\n    T * un,\n    T * ut\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-bndgpu-double","title":"function bndGPU&lt; double &gt;","text":"<pre><code>template __global__ void bndGPU&lt; double &gt; (\n    Param XParam,\n    bndparam side,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; Atmp,\n    float itime,\n    double * zs,\n    double * h,\n    double * un,\n    double * ut\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-bndgpu-float","title":"function bndGPU&lt; float &gt;","text":"<pre><code>template __global__ void bndGPU&lt; float &gt; (\n    Param XParam,\n    bndparam side,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; Atmp,\n    float itime,\n    float * zs,\n    float * h,\n    float * un,\n    float * ut\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-findmaskside","title":"function findmaskside","text":"<pre><code>__device__ __host__ void findmaskside (\n    int side,\n    bool &amp; isleftbot,\n    bool &amp; islefttop,\n    bool &amp; istopleft,\n    bool &amp; istopright,\n    bool &amp; isrighttop,\n    bool &amp; isrightbot,\n    bool &amp; isbotright,\n    bool &amp; isbotleft\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-halowall","title":"function halowall","text":"<pre><code>template&lt;class T&gt;\n__device__ __host__ void halowall (\n    T zsinside,\n    T &amp; un,\n    T &amp; ut,\n    T &amp; zs,\n    T &amp; h,\n    T &amp; zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-isbnd","title":"function isbnd","text":"<pre><code>__host__ __device__ bool isbnd (\n    int isright,\n    int istop,\n    int blkwidth,\n    int ix,\n    int iy\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbnd","title":"function maskbnd","text":"<pre><code>template&lt;class T&gt;\n__host__ void maskbnd (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbnd-double","title":"function maskbnd&lt; double &gt;","text":"<pre><code>template __host__ void maskbnd&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbnd-float","title":"function maskbnd&lt; float &gt;","text":"<pre><code>template __host__ void maskbnd&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpufluxbot","title":"function maskbndGPUFluxbot","text":"<pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUFluxbot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpufluxbot-double","title":"function maskbndGPUFluxbot&lt; double &gt;","text":"<pre><code>template __global__ void maskbndGPUFluxbot&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    FluxP &lt; double &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpufluxbot-float","title":"function maskbndGPUFluxbot&lt; float &gt;","text":"<pre><code>template __global__ void maskbndGPUFluxbot&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    FluxP &lt; float &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpufluxleft","title":"function maskbndGPUFluxleft","text":"<pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUFluxleft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpufluxleft-double","title":"function maskbndGPUFluxleft&lt; double &gt;","text":"<pre><code>template __global__ void maskbndGPUFluxleft&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    FluxP &lt; double &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpufluxleft-float","title":"function maskbndGPUFluxleft&lt; float &gt;","text":"<pre><code>template __global__ void maskbndGPUFluxleft&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    FluxP &lt; float &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpufluxright","title":"function maskbndGPUFluxright","text":"<pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUFluxright (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpufluxright-double","title":"function maskbndGPUFluxright&lt; double &gt;","text":"<pre><code>template __global__ void maskbndGPUFluxright&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    FluxP &lt; double &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpufluxright-float","title":"function maskbndGPUFluxright&lt; float &gt;","text":"<pre><code>template __global__ void maskbndGPUFluxright&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    FluxP &lt; float &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpufluxtop","title":"function maskbndGPUFluxtop","text":"<pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUFluxtop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpufluxtop-double","title":"function maskbndGPUFluxtop&lt; double &gt;","text":"<pre><code>template __global__ void maskbndGPUFluxtop&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    FluxP &lt; double &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpufluxtop-float","title":"function maskbndGPUFluxtop&lt; float &gt;","text":"<pre><code>template __global__ void maskbndGPUFluxtop&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    FluxP &lt; float &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpubot","title":"function maskbndGPUbot","text":"<pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUbot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpubot-double","title":"function maskbndGPUbot&lt; double &gt;","text":"<pre><code>template __global__ void maskbndGPUbot&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpubot-float","title":"function maskbndGPUbot&lt; float &gt;","text":"<pre><code>template __global__ void maskbndGPUbot&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpuleft","title":"function maskbndGPUleft","text":"<pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUleft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpuleft-double","title":"function maskbndGPUleft&lt; double &gt;","text":"<pre><code>template __global__ void maskbndGPUleft&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpuleft-float","title":"function maskbndGPUleft&lt; float &gt;","text":"<pre><code>template __global__ void maskbndGPUleft&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpuright","title":"function maskbndGPUright","text":"<pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUright (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpuright-double","title":"function maskbndGPUright&lt; double &gt;","text":"<pre><code>template __global__ void maskbndGPUright&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgpuright-float","title":"function maskbndGPUright&lt; float &gt;","text":"<pre><code>template __global__ void maskbndGPUright&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgputop","title":"function maskbndGPUtop","text":"<pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUtop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgputop-double","title":"function maskbndGPUtop&lt; double &gt;","text":"<pre><code>template __global__ void maskbndGPUtop&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-maskbndgputop-float","title":"function maskbndGPUtop&lt; float &gt;","text":"<pre><code>template __global__ void maskbndGPUtop&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-noslipbnd","title":"function noslipbnd","text":"<pre><code>template&lt;class T&gt;\n__device__ __host__ void noslipbnd (\n    T zsinside,\n    T hinside,\n    T &amp; un,\n    T &amp; ut,\n    T &amp; zs,\n    T &amp; h\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8cu/#function-noslipbndq","title":"function noslipbndQ","text":"<pre><code>template&lt;class T&gt;\n__device__ __host__ void noslipbndQ (\n    T &amp; F,\n    T &amp; G,\n    T &amp; S\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Boundary.cu</code></p>"},{"location":"BGFlood/Boundary_8cu_source/","title":"File Boundary.cu","text":""},{"location":"BGFlood/Boundary_8cu_source/#file-boundarycu","title":"File Boundary.cu","text":"<p>File List &gt; src &gt; Boundary.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Boundary.h\"\n\n\ntemplate &lt;class T&gt; void Flowbnd(Param XParam, Loop&lt;T&gt; &amp;XLoop, BlockP&lt;T&gt; XBlock, bndparam side, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;T&gt; XEv)\n{\n    dim3 blockDim(XParam.blkwidth, 1, 1);\n    dim3 gridDimBBND(side.nblk, 1, 1);\n\n    T* un, * ut;\n\n    double itime=0.0;\n\n    std::vector&lt;double&gt; zsbndleft;\n    std::vector&lt;double&gt; uubndleft;\n    std::vector&lt;double&gt; vvbndleft;\n\n    if (side.isright == 0)\n    {\n        //top or bottom\n        un = XEv.v; //u normal to boundary\n        ut = XEv.u; //u tangent to boundary\n    }\n    else\n    {\n        un = XEv.u;\n        ut = XEv.v;\n    }\n\n    if (side.on)\n    {\n        int SLstepinbnd = 1;\n\n        double difft = side.data[SLstepinbnd].time - XLoop.totaltime;\n        while (difft &lt; 0.0)\n        {\n            SLstepinbnd++;\n            difft = side.data[SLstepinbnd].time - XLoop.totaltime;\n        }\n\n        itime = SLstepinbnd - 1.0 + (XLoop.totaltime - side.data[SLstepinbnd - 1].time) / (side.data[SLstepinbnd].time - side.data[SLstepinbnd - 1].time);\n\n\n        for (int n = 0; n &lt; side.data[SLstepinbnd].wlevs.size(); n++)\n        {\n            zsbndleft.push_back(interptime(side.data[SLstepinbnd].wlevs[n], side.data[SLstepinbnd - 1].wlevs[n], side.data[SLstepinbnd].time - side.data[SLstepinbnd - 1].time, XLoop.totaltime - side.data[SLstepinbnd - 1].time));\n\n        }\n        // Repeat for u and v only if needed (otherwise values may not exist!)\n        if (side.type == 4)\n        {\n            for (int n = 0; n &lt; side.data[SLstepinbnd].uuvel.size(); n++)\n            {\n                uubndleft.push_back(interptime(side.data[SLstepinbnd].uuvel[n], side.data[SLstepinbnd - 1].uuvel[n], side.data[SLstepinbnd].time - side.data[SLstepinbnd - 1].time, XLoop.totaltime - side.data[SLstepinbnd - 1].time));\n\n            }\n            for (int n = 0; n &lt; side.data[SLstepinbnd].vvvel.size(); n++)\n            {\n                vvbndleft.push_back(interptime(side.data[SLstepinbnd].vvvel[n], side.data[SLstepinbnd - 1].vvvel[n], side.data[SLstepinbnd].time - side.data[SLstepinbnd - 1].time, XLoop.totaltime - side.data[SLstepinbnd - 1].time));\n\n            }\n        }\n\n\n    }\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        bndGPU &lt;&lt;&lt; gridDimBBND, blockDim, 0 &gt;&gt;&gt; (XParam, side, XBlock, Atmp, T(itime), XEv.zs, XEv.h, un, ut);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else\n    {\n        bndCPU(XParam, side, XBlock, zsbndleft, uubndleft, vvbndleft, Atmp, XEv.zs, XEv.h, un, ut);\n    }\n\n\n\n}\ntemplate void Flowbnd&lt;float&gt;(Param XParam, Loop&lt;float&gt;&amp; XLoop, BlockP&lt;float&gt; XBlock, bndparam side, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;float&gt; XEv);\ntemplate void Flowbnd&lt;double&gt;(Param XParam, Loop&lt;double&gt;&amp; XLoop, BlockP&lt;double&gt; XBlock, bndparam side, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;double&gt; XEv);\n\ntemplate &lt;class T&gt; void FlowbndFlux(Param XParam, double totaltime, BlockP&lt;T&gt; XBlock, bndsegment bndseg, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;T&gt; XEv, FluxP&lt;T&gt; XFlux)\n{\n    dim3 blockDim(XParam.blkwidth, 1, 1);\n    dim3 gridDimBBNDLeft(bndseg.left.nblk, 1, 1);\n    dim3 gridDimBBNDRight(bndseg.right.nblk, 1, 1);\n    dim3 gridDimBBNDTop(bndseg.top.nblk, 1, 1);\n    dim3 gridDimBBNDBot(bndseg.bot.nblk, 1, 1);\n\n    double zsbnd = 0.0;\n    if (!std::isnan(XParam.zsinit)) // apply specified zsinit\n    {\n        zsbnd = XParam.zsinit;\n    }\n    // Warning this above is not ideal but sufficient for fail safe of testing if someone specifies initial conditions and no boundary for a type 3 they should be in trouble\n    T taper=T(1.0);\n    if (bndseg.on)\n    {\n        if (XParam.bndtaper &gt; 0.0)\n        {\n            taper = min((totaltime - XParam.inittime) / XParam.bndtaper, 1.0);\n        }\n\n        if (bndseg.uniform)\n        {\n            int SLstepinbnd = 1;\n\n            double difft = bndseg.data[SLstepinbnd].time - totaltime;\n            while (difft &lt; 0.0)\n            {\n                SLstepinbnd++;\n                difft = bndseg.data[SLstepinbnd].time - totaltime;\n            }\n\n            //itime = SLstepinbnd - 1.0 + (totaltime - bndseg.data[SLstepinbnd - 1].time) / (bndseg.data[SLstepinbnd].time - bndseg.data[SLstepinbnd - 1].time);\n            zsbnd = interptime(bndseg.data[SLstepinbnd].wspeed, bndseg.data[SLstepinbnd - 1].wspeed, bndseg.data[SLstepinbnd].time - bndseg.data[SLstepinbnd - 1].time, totaltime - bndseg.data[SLstepinbnd - 1].time);\n\n\n\n        }\n        else\n        {\n            // Nothing. it is already done in update forcing\n        }\n\n    }\n\n    if (bndseg.type != 1)\n    {\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            //if (bndseg.left.nblk &gt; 0)\n            {\n                //Left\n                //template &lt;class T&gt; __global__ void bndFluxGPUSide(Param XParam, bndsegmentside side, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Atmp, DynForcingP&lt;float&gt; Zsmap, bool uniform, float zsbnd, T * zs, T * h, T * un, T * ut, T * Fh, T * Fq, T * Ss)\n                //bndFluxGPUSide &lt;&lt;&lt; gridDimBBND, blockDim, 0 &gt;&gt;&gt; (XParam, bndseg.left, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), XEv.zs, XEv.h, un, ut, Fh, Fq, S);\n                bndFluxGPUSide &lt;&lt;&lt; gridDimBBNDLeft, blockDim, 0 &gt;&gt;&gt; (XParam, bndseg.left, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.u, XEv.v, XFlux.Fhu, XFlux.Fqux, XFlux.Su);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n            //if (bndseg.right.nblk &gt; 0)\n            {\n                //Right\n                bndFluxGPUSide &lt;&lt;&lt; gridDimBBNDRight, blockDim, 0 &gt;&gt;&gt; (XParam, bndseg.right, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.u, XEv.v, XFlux.Fhu, XFlux.Fqux, XFlux.Su);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n            //if (bndseg.top.nblk &gt; 0)\n            {\n                //top\n                bndFluxGPUSide &lt;&lt;&lt; gridDimBBNDTop, blockDim, 0 &gt;&gt;&gt; (XParam, bndseg.top, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.v, XEv.u, XFlux.Fhv, XFlux.Fqvy, XFlux.Sv);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n            //if (bndseg.bot.nblk &gt; 0)\n            {\n                //bot\n                bndFluxGPUSide &lt;&lt;&lt; gridDimBBNDBot, blockDim, 0 &gt;&gt;&gt; (XParam, bndseg.bot, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.v, XEv.u, XFlux.Fhv, XFlux.Fqvy, XFlux.Sv);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n        }\n        else\n        {\n            bndFluxGPUSideCPU(XParam, bndseg.left, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.u, XEv.v, XFlux.Fhu, XFlux.Fqux, XFlux.Su);\n            bndFluxGPUSideCPU(XParam, bndseg.right, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.u, XEv.v, XFlux.Fhu, XFlux.Fqux, XFlux.Su);\n            bndFluxGPUSideCPU(XParam, bndseg.top, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.v, XEv.u, XFlux.Fhv, XFlux.Fqvy, XFlux.Sv);\n            bndFluxGPUSideCPU(XParam, bndseg.bot, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.v, XEv.u, XFlux.Fhv, XFlux.Fqvy, XFlux.Sv);\n\n\n        }\n    }\n}\ntemplate void FlowbndFlux&lt;float&gt;(Param XParam,  double totaltime, BlockP&lt;float&gt; XBlock, bndsegment bndseg, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;float&gt; XEv, FluxP&lt;float&gt; XFlux);\ntemplate void FlowbndFlux&lt;double&gt;(Param XParam, double totaltime, BlockP&lt;double&gt; XBlock, bndsegment bndseg, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;double&gt; XEv, FluxP&lt;double&gt; XFlux);\n\ntemplate &lt;class T&gt; void FlowbndFluxML(Param XParam, double totaltime, BlockP&lt;T&gt; XBlock, bndsegment bndseg, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;T&gt; XEv, FluxMLP&lt;T&gt; XFlux)\n{\n    dim3 blockDim(XParam.blkwidth, 1, 1);\n    dim3 gridDimBBNDLeft(bndseg.left.nblk, 1, 1);\n    dim3 gridDimBBNDRight(bndseg.right.nblk, 1, 1);\n    dim3 gridDimBBNDTop(bndseg.top.nblk, 1, 1);\n    dim3 gridDimBBNDBot(bndseg.bot.nblk, 1, 1);\n\n    double zsbnd = 0.0;\n    if (!std::isnan(XParam.zsinit)) // apply specified zsinit\n    {\n        zsbnd = XParam.zsinit;\n    }\n    // Warning this above is not ideal but sufficient for fail safe of testing if someone specifies initial conditions and no boundary for a type 3 they should be in trouble\n    T taper = T(1.0);\n    if (bndseg.on)\n    {\n        if (bndseg.uniform)\n        {\n            int SLstepinbnd = 1;\n\n            double difft = bndseg.data[SLstepinbnd].time - totaltime;\n            while (difft &lt; 0.0)\n            {\n                SLstepinbnd++;\n                difft = bndseg.data[SLstepinbnd].time - totaltime;\n            }\n\n            //itime = SLstepinbnd - 1.0 + (totaltime - bndseg.data[SLstepinbnd - 1].time) / (bndseg.data[SLstepinbnd].time - bndseg.data[SLstepinbnd - 1].time);\n            zsbnd = interptime(bndseg.data[SLstepinbnd].wspeed, bndseg.data[SLstepinbnd - 1].wspeed, bndseg.data[SLstepinbnd].time - bndseg.data[SLstepinbnd - 1].time, totaltime - bndseg.data[SLstepinbnd - 1].time);\n\n\n            if (XParam.bndtaper &gt; 0.0)\n            {\n                taper = min(totaltime / XParam.bndtaper, 1.0);\n            }\n        }\n        else\n        {\n            // Nothing. it is already done in update forcing\n        }\n\n    }\n\n    if (bndseg.type != 1)\n    {\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            //if (bndseg.left.nblk &gt; 0)\n            {\n                //Left\n                bndFluxGPUSide &lt;&lt; &lt; gridDimBBNDLeft, blockDim, 0 &gt;&gt; &gt; (XParam, bndseg.left, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.u, XEv.v, XFlux.hu, XFlux.hfu, XFlux.hau);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n            //if (bndseg.right.nblk &gt; 0)\n            {\n                //Right\n                bndFluxGPUSide &lt;&lt; &lt; gridDimBBNDRight, blockDim, 0 &gt;&gt; &gt; (XParam, bndseg.right, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.u, XEv.v, XFlux.hu, XFlux.hfu, XFlux.hau);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n            //if (bndseg.top.nblk &gt; 0)\n            {\n                //top\n                bndFluxGPUSide &lt;&lt; &lt; gridDimBBNDTop, blockDim, 0 &gt;&gt; &gt; (XParam, bndseg.top, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.v, XEv.u, XFlux.hv, XFlux.hfv, XFlux.hav);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n            //if (bndseg.bot.nblk &gt; 0)\n            {\n                //bot\n                bndFluxGPUSide &lt;&lt; &lt; gridDimBBNDBot, blockDim, 0 &gt;&gt; &gt; (XParam, bndseg.bot, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.v, XEv.u, XFlux.hv, XFlux.hfv, XFlux.hfv);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n        }\n        else\n        {\n            //bndFluxGPUSideCPU(XParam, bndseg.left, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.u, XEv.v, XFlux.Fhu, XFlux.Fqux, XFlux.Su);\n            //bndFluxGPUSideCPU(XParam, bndseg.right, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.u, XEv.v, XFlux.Fhu, XFlux.Fqux, XFlux.Su);\n            //bndFluxGPUSideCPU(XParam, bndseg.top, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.v, XEv.u, XFlux.Fhv, XFlux.Fqvy, XFlux.Sv);\n            //bndFluxGPUSideCPU(XParam, bndseg.bot, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.v, XEv.u, XFlux.Fhv, XFlux.Fqvy, XFlux.Sv);\n\n\n        }\n    }\n}\ntemplate void FlowbndFluxML&lt;float&gt;(Param XParam, double totaltime, BlockP&lt;float&gt; XBlock, bndsegment bndseg, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;float&gt; XEv, FluxMLP&lt;float&gt; XFlux);\ntemplate void FlowbndFluxML&lt;double&gt;(Param XParam, double totaltime, BlockP&lt;double&gt; XBlock, bndsegment bndseg, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;double&gt; XEv, FluxMLP&lt;double&gt; XFlux);\n\ntemplate &lt;class T&gt; void FlowbndFluxold(Param XParam, double totaltime, BlockP&lt;T&gt; XBlock, bndparam side, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;T&gt; XEv, FluxP&lt;T&gt; XFlux)\n{\n    dim3 blockDim(XParam.blkwidth, 1, 1);\n    dim3 gridDimBBND(side.nblk, 1, 1);\n\n    T* un, * ut, * Fh, * Fq, * S;\n\n\n    double itime = 0.0;\n    if (side.on)\n    {\n        int SLstepinbnd = 1;\n\n        double difft = side.data[SLstepinbnd].time - totaltime;\n        while (difft &lt; 0.0)\n        {\n            SLstepinbnd++;\n            difft = side.data[SLstepinbnd].time - totaltime;\n        }\n\n        itime = SLstepinbnd - 1.0 + (totaltime - side.data[SLstepinbnd - 1].time) / (side.data[SLstepinbnd].time - side.data[SLstepinbnd - 1].time);\n\n    }\n\n\n    if (side.isright == 0)\n    {\n        //top or bottom\n        un = XEv.v; //u normal to boundary\n        ut = XEv.u; //u tangent to boundary\n    }\n    else\n    {\n        un = XEv.u;\n        ut = XEv.v;\n    }\n\n    if (side.isright == 0) // top or bottom\n    {\n        Fh = XFlux.Fhv;\n        Fq = XFlux.Fqvy;\n        S = XFlux.Sv;\n    }\n    else\n    {\n        Fh = XFlux.Fhu;\n        Fq = XFlux.Fqux;\n        S = XFlux.Su;\n    }\n\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        //bndFluxGPU &lt;&lt;&lt; gridDimBBND, blockDim, 0 &gt;&gt;&gt; (XParam, side, XBlock, Atmp, float(itime), XEv.zs, XEv.h, un, ut, Fh, Fq, S);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else\n    {\n        //bndFluxCPU(XParam, side, XBlock, zsbndleft, uubndleft, vvbndleft, Atmp, XEv.zs, XEv.h, un, ut);\n    }\n}\ntemplate void FlowbndFluxold&lt;float&gt;(Param XParam, double totaltime, BlockP&lt;float&gt; XBlock, bndparam side, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;float&gt; XEv, FluxP&lt;float&gt; XFlux);\ntemplate void FlowbndFluxold&lt;double&gt;(Param XParam, double totaltime, BlockP&lt;double&gt; XBlock, bndparam side, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;double&gt; XEv, FluxP&lt;double&gt; XFlux);\n\ntemplate &lt;class T&gt; __global__ void bndFluxGPUSide(Param XParam, bndsegmentside side, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Atmp, DynForcingP&lt;float&gt; Zsmap, bool uniform, int type, float zsbnd, T taper, T* zs, T* h, T* un, T* ut, T* Fh, T* Fq, T* Ss)\n{\n    //\n\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n\n    int ibl = blockIdx.x;\n    int ix, iy;\n\n\n    int iq = ibl * XParam.blkwidth + threadIdx.x;\n\n    int ib = side.blk_g[ibl];\n    int lev = XBlock.level[ib];\n\n\n    T delta = calcres(T(XParam.dx), lev);\n\n    if (side.isright == 0)\n    {\n        ix = threadIdx.x;\n        iy = side.istop &lt; 0 ? 0 : (blockDim.x);\n        //itx = (xx - XParam.xo) / (XParam.xmax - XParam.xo) * side.nbnd;\n    }\n    else\n    {\n        iy = threadIdx.x;\n        ix = side.isright &lt; 0 ? 0 : (blockDim.x);\n        //itx = (yy - XParam.yo) / (XParam.ymax - XParam.yo) * side.nbnd;\n    }\n\n    T sign = T(side.isright) + T(side.istop);\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n\n    T xx, yy;\n\n    xx = XBlock.xo[ib] + ix * delta;\n    yy = XBlock.yo[ib] + iy * delta;\n\n\n    T zsatm = T(0.0);\n\n    if (XParam.atmpforcing)\n    {\n        float atmpi;\n\n        atmpi = interpDyn2BUQ(XParam.xo + xx, XParam.yo + yy, Atmp.GPU);\n        zsatm = -1.0 * (atmpi - XParam.Paref) * XParam.Pa2m;\n    }\n    if (!uniform)\n    {\n\n\n        zsbnd = interpDyn2BUQ(XParam.xo + xx, XParam.yo + yy, Zsmap.GPU);\n    }\n\n\n\n    zsbnd = zsbnd + XParam.zsoffset;\n\n\n    int inside = Inside(halowidth, blkmemwidth, side.isright, side.istop, ix, iy, ib);\n\n    //T zsbnd;\n    T unbnd = T(0.0);\n    T utbnd = T(0.0);\n\n    T zsinside, hinside, uninside, utinside,zsi;\n    T F, G, S;\n    T qmean;\n\n    zsi = zs[i];\n    zsinside = zs[inside];\n    hinside = h[inside];\n    uninside = un[inside];\n    utinside = ut[inside];\n\n    T zsX = (zsbnd + zsatm - 0.5 * (zsi + zsinside)) * taper + 0.5 * (zsi + zsinside);\n\n    qmean = side.qmean_g[iq];\n\n\n    if (side.isright &lt; 0 || side.istop &lt; 0) //left or bottom\n    {\n        F = Fh[i];\n        G = Fq[i];\n        S = Ss[inside];\n    }\n    else\n    {\n        F = Fh[i];\n        G = Ss[i];\n        S = Fq[inside];\n    }\n\n    T factime = min(T(XParam.dt / XParam.bndfiltertime), T(1.0));\n    T facrel =  T(1.0) - min(T(XParam.dt / XParam.bndrelaxtime), T(1.0));\n\n\n\n\n    if (type == 0) // No Flux\n    {\n        //noslipbnd(zsinside, hinside, unnew, utnew, zsnew, hnew);\n        //noslipbndQ(F, G, S);\n\n\n        noslipbndQ(F, G, S);//noslipbndQ(T &amp; F, T &amp; G, T &amp; S) F = T(0.0); S = G;\n\n    }\n    else if (type == 2)\n    {\n        if (h[i] &gt; XParam.eps || zsX &gt; zsi)\n        {\n            //\n            Dirichlet1Q(T(XParam.g), sign, zsX, zsinside, hinside, uninside, F);\n        }\n        else\n        {\n            noslipbndQ(F, G, S);\n            qmean = T(0.0);\n        }\n    }\n    else if (type == 3)\n    {\n        if (h[i] &gt; XParam.eps || zsX &gt; zsi )\n        {\n            ABS1DQ(T(XParam.g), sign, factime, facrel, zsi, zsX, zsinside, h[i], qmean, F, G, S);\n            //qmean = T(0.0);\n        }\n        else\n        {\n            noslipbndQ(F, G, S);\n            qmean = T(0.0);\n        }\n        side.qmean_g[iq] = qmean;\n    }\n\n\n    // write the results\n\n    if (side.isright &lt; 0 || side.istop &lt; 0) // left or bottom\n    {\n        Fh[i]=F;\n        Fq[i]=G;\n        Ss[inside]=S;\n    }\n    else\n    {\n        Fh[i] = F;\n        Ss[i] = G;\n        Fq[inside] = S;\n    }\n\n\n\n\n\n\n\n}\n\n\ntemplate &lt;class T&gt; void bndFluxGPUSideCPU(Param XParam, bndsegmentside side, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Atmp, DynForcingP&lt;float&gt; Zsmap, bool uniform, int type, float zsbnd, T taper, T* zs, T* h, T* un, T* ut, T* Fh, T* Fq, T* Ss)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; side.nblk; ibl++)\n    {\n\n        int ib = side.blk[ibl];\n        int lev = XBlock.level[ib];\n\n        T delta = calcres(T(XParam.dx), lev);\n\n        for (int tx = 0; tx &lt; XParam.blkwidth; tx++)\n        {\n            int ix, iy;\n\n            T xx, yy;\n            if (side.isright == 0)\n            {\n                ix = tx;\n                iy = side.istop &lt; 0 ? 0 : (XParam.blkwidth);\n                //itx = (xx - XParam.xo) / (XParam.xmax - XParam.xo) * side.nbnd;\n            }\n            else\n            {\n                iy = tx;\n                ix = side.isright &lt; 0 ? 0 : (XParam.blkwidth);\n                //itx = (yy - XParam.yo) / (XParam.ymax - XParam.yo) * side.nbnd;\n            }\n            xx = XBlock.xo[ib] + ix * delta;\n            yy = XBlock.yo[ib] + iy * delta;\n\n            T sign = T(side.isright) + T(side.istop);\n            int iq = ibl * XParam.blkwidth + tx;\n\n\n            T zsatm = T(0.0);\n            T atmpi = T(0.0);\n\n            if (XParam.atmpforcing)\n            {\n                if (Atmp.uniform)\n                {\n                    atmpi = T(Atmp.nowvalue);\n                }\n                else\n                {\n                    atmpi = interp2BUQ(XParam.xo + xx, XParam.yo + yy, Atmp);\n                }\n                zsatm = -(atmpi - (T)XParam.Paref) * (T)XParam.Pa2m;\n            }\n            if (!uniform)\n            {\n\n\n                zsbnd = interp2BUQ(XParam.xo + xx, XParam.yo + yy, Zsmap);\n            }\n\n\n            zsbnd = zsbnd + XParam.zsoffset;\n\n\n            int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n            int inside = Inside(halowidth, blkmemwidth, side.isright, side.istop, ix, iy, ib);\n\n            //T zsbnd;\n            T unbnd = T(0.0);\n            T utbnd = T(0.0);\n\n            T zsinside, hinside, uninside, utinside, zsi;\n            T F, G, S;\n            T qmean;\n\n            zsi = zs[i];\n            zsinside = zs[inside];\n            hinside = h[inside];\n            uninside = un[inside];\n            utinside = ut[inside];\n\n            T zsX = (zsbnd + zsatm - 0.5 * (zsi + zsinside)) * taper + 0.5 * (zsi + zsinside);\n\n            qmean = side.qmean[iq];\n\n\n            if (side.isright &lt; 0 || side.istop &lt; 0) //left or bottom\n            {\n                F = Fh[i];\n                G = Fq[i];\n                S = Ss[inside];\n            }\n            else\n            {\n                F = Fh[i];\n                G = Ss[i];\n                S = Fq[inside];\n            }\n\n            T factime = min(T(XParam.dt / XParam.bndfiltertime), T(1.0));\n            T facrel = T(1.0) - min(T(XParam.dt / XParam.bndrelaxtime), T(1.0));\n            if (type == 0) // No Flux\n            {\n                //noslipbnd(zsinside, hinside, unnew, utnew, zsnew, hnew);\n                //noslipbndQ(F, G, S);\n\n\n                noslipbndQ(F, G, S);//noslipbndQ(T &amp; F, T &amp; G, T &amp; S) F = T(0.0); S = G;\n\n            }\n            else if (type == 3)\n            {\n                if (h[i] &gt; XParam.eps || zsX &gt; zsi)\n                {\n                    ABS1DQ(T(XParam.g), sign, factime, facrel, zsi, zsX, zsinside, h[i], qmean, F, G, S);\n                    //qmean = T(0.0);\n                }\n                else\n                {\n                    noslipbndQ(F, G, S);\n                    qmean = T(0.0);\n                }\n                side.qmean[iq] = qmean;\n            }\n            else if (type == 2)\n            {\n                if (h[i] &gt; XParam.eps || zsX &gt; zsi)\n                {\n                    //ABS1DQ(T(XParam.g), sign, factime, facrel, zsi, zsX, zsinside, h[i], qmean, F, G, S);\n                    //qmean = T(0.0);\n                    Dirichlet1Q(T(XParam.g), sign, zsX, zsinside, hinside, uninside, F);\n                }\n                else\n                {\n                    noslipbndQ(F, G, S);\n                    qmean = T(0.0);\n                }\n                side.qmean[iq] = qmean;\n            }\n\n\n            // write the results\n\n            if (side.isright &lt; 0 || side.istop &lt; 0) // left or bottom\n            {\n                Fh[i] = F;\n                Fq[i] = G;\n                Ss[inside] = S;\n            }\n            else\n            {\n                Fh[i] = F;\n                Ss[i] = G;\n                Fq[inside] = S;\n            }\n        }\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void bndGPU(Param XParam, bndparam side, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Atmp, float itime, T* zs, T* h, T* un, T* ut)\n{\n    //\n\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n\n    unsigned int ibl = blockIdx.x;\n    unsigned int ix, iy;\n    float itx;\n\n    int ib = side.blks_g[ibl];\n    int lev = XBlock.level[ib];\n\n\n    T delta = calcres(T(XParam.dx), lev);\n\n    if (side.isright == 0)\n    {\n        ix = threadIdx.x;\n        iy = side.istop &lt; 0 ? 0 : (blockDim.x - 1);\n        //itx = (xx - XParam.xo) / (XParam.xmax - XParam.xo) * side.nbnd;\n    }\n    else\n    {\n        iy = threadIdx.x;\n        ix = side.isright &lt; 0 ? 0 : (blockDim.x - 1);\n        //itx = (yy - XParam.yo) / (XParam.ymax - XParam.yo) * side.nbnd;\n    }\n\n    T sign = T(side.isright) + T(side.istop);\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n\n    T xx, yy;\n\n    xx = XBlock.xo[ib] + ix * delta;\n    yy = XBlock.yo[ib] + iy * delta;\n\n    if (side.isright == 0)\n    {\n        itx = (xx) / (XParam.xmax - XParam.xo) * side.nbnd;\n    }\n    else\n    {\n        itx = (yy) / (XParam.ymax - XParam.yo) * side.nbnd;\n    }\n\n    T zsatm = T(0.0);\n\n    if (XParam.atmpforcing)\n    {\n        float atmpi;\n\n        atmpi = interpDyn2BUQ(XParam.xo + xx, XParam.yo + yy, Atmp.GPU);\n        zsatm = -1.0 * (atmpi - XParam.Paref) * XParam.Pa2m;\n    }\n\n    int inside= Inside(halowidth, blkmemwidth, side.isright, side.istop, ix, iy, ib);\n\n    T unnew, utnew, hnew, zsnew;\n    T uninside, utinside, hinside, zsinside;\n    T zsbnd;\n    T unbnd = T(0.0);\n    T utbnd = T(0.0);\n\n    unnew = un[i];\n    utnew = ut[i];\n    hnew = h[i];\n    zsnew = zs[i];\n\n    zsinside = zs[inside];\n    hinside = h[inside];\n    uninside = un[inside];\n    utinside = ut[inside];\n\n    if (side.on)\n    {\n\n        zsbnd = tex2D&lt;float&gt;(side.GPU.WLS.tex, itime + 0.5f, itx + 0.5f) + zsatm;\n\n        if (side.type == 4)\n        {\n            //un is V (top or bot bnd) or U (left or right bnd) depending on which side it's dealing with (same for ut)\n            unbnd = side.isright == 0 ? tex2D&lt;float&gt;(side.GPU.Vvel.tex, itime + 0.5f, itx + 0.5f) : tex2D&lt;float&gt;(side.GPU.Uvel.tex, itime + 0.5f, itx + 0.5f);\n            utbnd = side.isright == 0 ? tex2D&lt;float&gt;(side.GPU.Uvel.tex, itime + 0.5f, itx + 0.5f) : tex2D&lt;float&gt;(side.GPU.Vvel.tex, itime + 0.5f, itx + 0.5f);\n\n        }\n\n    }\n\n    if (side.type == 0) // No slip == no friction wall\n    {\n        //noslipbnd(zsinside, hinside, unnew, utnew, zsnew, hnew);\n    }\n    else if (side.type == 1) // neumann type\n    {\n        // Nothing to do here?\n    }\n    else if (side.type == 2)\n    {\n        Dirichlet1D(T(XParam.g), sign, zsbnd, zsinside, hinside, uninside, unnew, utnew, zsnew, hnew);\n    }\n    else if (side.type == 3 )\n    {\n        if (hnew &gt; XParam.eps &amp;&amp; hinside &gt; XParam.eps)\n        {\n            //ABS1D(T(XParam.g), sign, zsbnd, zsinside, hinside, utinside, unbnd, unnew, utnew, zsnew, hnew);\n            //printf(\"No boundary!\\n\");\n        }\n    }\n    else if (side.type == 4)\n    {\n\n        ABS1D(T(XParam.g), sign, zsbnd, zsinside, hinside, utbnd, unbnd, unnew, utnew, zsnew, hnew);\n    }\n\n    un[i] = unnew;\n    ut[i] = utnew;\n    h[i] = hnew;\n    zs[i] = zsnew;\n}\ntemplate __global__ void bndGPU&lt;float&gt;(Param XParam, bndparam side, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; Atmp, float itime, float* zs, float* h, float* un, float* ut);\ntemplate __global__ void bndGPU&lt;double&gt;(Param XParam, bndparam side, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; Atmp, float itime, double* zs, double* h, double* un, double* ut);\n\ntemplate &lt;class T&gt; __host__ void bndCPU(Param XParam, bndparam side, BlockP&lt;T&gt; XBlock, std::vector&lt;double&gt; zsbndvec, std::vector&lt;double&gt; uubndvec, std::vector&lt;double&gt; vvbndvec, DynForcingP&lt;float&gt; Atmp, T* zs, T* h, T* un, T* ut)\n{\n    //\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; side.nblk; ibl++)\n    {\n\n        int ib = side.blks[ibl];\n        int lev = XBlock.level[ib];\n        int nbnd = side.nbnd;\n        T delta = calcres(T(XParam.dx), lev);\n\n        for (int tx = 0; tx &lt; XParam.blkwidth; tx++)\n        {\n            unsigned int ix, iy;\n            double itx;\n            T xx, yy;\n            if (side.isright == 0)\n            {\n                ix = tx;\n                iy = side.istop &lt; 0 ? 0 : (XParam.blkwidth - 1);\n                //itx = (xx - XParam.xo) / (XParam.xmax - XParam.xo) * side.nbnd;\n            }\n            else\n            {\n                iy = tx;\n                ix = side.isright &lt; 0 ? 0 : (XParam.blkwidth - 1);\n                //itx = (yy - XParam.yo) / (XParam.ymax - XParam.yo) * side.nbnd;\n            }\n            xx = XBlock.xo[ib] + ix * delta;\n            yy = XBlock.yo[ib] + iy * delta;\n\n            T sign = T(side.isright) + T(side.istop);\n\n            if (side.isright == 0)\n            {\n                itx = (xx) / (XParam.xmax - XParam.xo) * side.nbnd;\n            }\n            else\n            {\n                itx = (yy) / (XParam.ymax - XParam.yo) * side.nbnd;\n            }\n\n            T zsatm = T(0.0);\n            T atmpi = T(0.0);\n\n            if (XParam.atmpforcing)\n            {\n                if (Atmp.uniform)\n                {\n                    atmpi = T(Atmp.nowvalue);\n                }\n                else\n                {\n                    atmpi = interp2BUQ(XParam.xo + xx, XParam.yo + yy, Atmp);\n                }\n                zsatm = -(atmpi - (T)XParam.Paref) * (T)XParam.Pa2m;\n            }\n\n\n            int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n            int inside = Inside(halowidth, blkmemwidth, side.isright, side.istop, ix, iy, ib);\n\n            T unnew, utnew, hnew, zsnew;\n            T uninside, utinside, hinside, zsinside;\n            T zsbnd;\n            T unbnd = T(0.0);\n            T utbnd = T(0.0);\n\n            unnew = un[i];\n            utnew = ut[i];\n            hnew = h[i];\n            zsnew = zs[i];\n\n            zsinside = zs[inside];\n            hinside = h[inside];\n            uninside = un[inside];\n            utinside = ut[inside];\n\n            if (side.on)\n            {\n                int iprev = utils::max(int(floor(itx * (side.nbnd - 1))), 0);//min(max((int)ceil(itx / (1 / (side.nbnd - 1))), 0), (int)side.nbnd() - 2);\n                int inext = iprev + 1;\n\n                if (side.nbnd == 1)\n                {\n                    zsbnd = zsbndvec[0] + zsatm;\n                    if (side.type == 4)\n                    {\n                        unbnd = side.isright == 0 ? vvbndvec[0] : uubndvec[0];\n                        utbnd = side.isright == 0 ? uubndvec[0] : vvbndvec[0];\n                    }\n                }\n                else\n                {\n\n                    // here interp time is used to interpolate to the right node rather than in time...//\n                    zsbnd = T(interptime(zsbndvec[inext], zsbndvec[iprev], 1.0, itx * (nbnd - 1) - iprev)) + zsatm;\n\n                    if (side.type == 4)\n                    {\n                        unbnd = side.isright == 0 ? T(interptime(vvbndvec[inext], vvbndvec[iprev], 1.0, itx * (nbnd - 1) - iprev)) : T(interptime(uubndvec[inext], uubndvec[iprev], 1.0, itx * (nbnd - 1) - iprev));\n                        utbnd = side.isright == 0 ? T(interptime(uubndvec[inext], uubndvec[iprev], 1.0, itx * (nbnd - 1) - iprev)) : T(interptime(vvbndvec[inext], vvbndvec[iprev], 1.0, itx * (nbnd - 1) - iprev));\n                    }\n                }\n\n\n\n            }\n\n            if (side.type == 0) // No slip == no friction wall\n            {\n                noslipbnd(zsinside, hinside, unnew, utnew, zsnew, hnew);\n            }\n            else if (side.type == 1) // neumann type\n            {\n                // Nothing to do here?\n            }\n            else if (side.type == 2)\n            {\n                Dirichlet1D(T(XParam.g), sign, zsbnd, zsinside, hinside, uninside, unnew, utnew, zsnew, hnew);\n\n            }\n            else if (side.type == 3)\n            {\n                if (hnew &gt; XParam.eps &amp;&amp; hinside &gt; XParam.eps)\n                {\n                    ABS1D(T(XParam.g), sign, zsbnd, zsinside, hinside, utinside, unbnd, unnew, utnew, zsnew, hnew);\n                }\n            }\n            else if (side.type == 4)\n            {\n\n                ABS1D(T(XParam.g), sign, zsbnd, zsinside, hinside, utbnd, unbnd, unnew, utnew, zsnew, hnew);\n            }\n\n            un[i] = unnew;\n            ut[i] = utnew;\n            h[i] = hnew;\n            zs[i] = zsnew;\n        }\n    }\n}\ntemplate __host__ void bndCPU&lt;float&gt;(Param XParam, bndparam side, BlockP&lt;float&gt; XBlock, std::vector&lt;double&gt; zsbndvec, std::vector&lt;double&gt; uubndvec, std::vector&lt;double&gt; vvbndvec, DynForcingP&lt;float&gt; Atmp, float* zs, float* h, float* un, float* ut);\ntemplate __host__ void bndCPU&lt;double&gt;(Param XParam, bndparam side, BlockP&lt;double&gt; XBlock, std::vector&lt;double&gt; zsbndvec, std::vector&lt;double&gt; uubndvec, std::vector&lt;double&gt; vvbndvec, DynForcingP&lt;float&gt; Atmp, double* zs, double* h, double* un, double* ut);\n\n\n// function to apply bnd at the boundary with masked blocked\n// here a wall is applied in the halo \ntemplate &lt;class T&gt; __host__ void maskbnd(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T*zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int isright,istop;\n\n    T zsinside,zsnew,hnew,vnew,unew,zbnew;\n\n    bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n\n    for (int ibl = 0; ibl &lt;XBlock.mask.nblk ; ibl++)\n    {\n\n        int ib = XBlock.mask.blks[ibl];\n        int lev = XBlock.level[ib];\n        T delta = calcres(T(XParam.dx), lev);\n\n        // find where the mask applies\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        //leftside\n        if (isleftbot | islefttop )//?\n        {\n            isright = -1;\n            istop = 0;\n\n            int ix = -1;\n\n            int yst = isleftbot ? 0 : ftoi(XParam.blkwidth * 0.5);\n            int ynd = islefttop ? XParam.blkwidth : ftoi(XParam.blkwidth * 0.5);\n\n            for (int iy = yst; iy &lt; ynd; iy++)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n                zsinside = Xev.zs[inside];\n                unew = Xev.u[i];\n                vnew = Xev.v[i];\n                zsnew = Xev.zs[i];\n                hnew = Xev.h[i];\n                zbnew = zb[i];\n\n                halowall(zsinside, unew, vnew, zsnew, hnew, zbnew);\n\n                Xev.u[i]=unew;\n                Xev.v[i]=vnew;\n                Xev.zs[i]=zsnew;\n                Xev.h[i]=hnew;\n                zb[i]=zbnew;\n\n            }\n\n        }\n        //topside\n        if (istopleft | istopright)//?\n        {\n            isright = 0;\n            istop = 1;\n\n            int iy = XParam.blkwidth;\n\n            int xst = istopleft ? 0 : ftoi(XParam.blkwidth * 0.5);\n            int xnd = istopright ? XParam.blkwidth : ftoi(XParam.blkwidth * 0.5);\n\n            for (int ix = xst; ix &lt; xnd; ix++)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n                zsinside = Xev.zs[inside];\n                unew = Xev.u[i];\n                vnew = Xev.v[i];\n                zsnew = Xev.zs[i];\n                hnew = Xev.h[i];\n                zbnew = zb[i];\n\n                halowall(zsinside, unew, vnew, zsnew, hnew, zbnew);\n\n                Xev.u[i] = unew;\n                Xev.v[i] = vnew;\n                Xev.zs[i] = zsnew;\n                Xev.h[i] = hnew;\n                zb[i] = zbnew;\n\n            }\n\n        }\n        //rightside\n        if (isrighttop | isrightbot)//?\n        {\n            isright = 1;\n            istop = 0;\n\n            int ix = XParam.blkwidth;\n\n            int yst = isrightbot ? 0 : ftoi(XParam.blkwidth * 0.5);\n            int ynd = isrighttop ? XParam.blkwidth : ftoi(XParam.blkwidth * 0.5);\n\n            for (int iy = yst; iy &lt; ynd; iy++)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n                zsinside = Xev.zs[inside];\n                unew = Xev.u[i];\n                vnew = Xev.v[i];\n                zsnew = Xev.zs[i];\n                hnew = Xev.h[i];\n                zbnew = zb[i];\n\n                halowall(zsinside, unew, vnew, zsnew, hnew, zbnew);\n\n                Xev.u[i] = unew;\n                Xev.v[i] = vnew;\n                Xev.zs[i] = zsnew;\n                Xev.h[i] = hnew;\n                zb[i] = zbnew;\n\n            }\n\n        }\n\n        //botside\n        if (isbotright | isbotleft)//?\n        {\n            isright = 0;\n            istop = -1;\n\n            int iy = -1;\n\n            int xst = isbotleft ? 0 : ftoi(XParam.blkwidth * 0.5);\n            int xnd = isbotright ? XParam.blkwidth :ftoi( XParam.blkwidth * 0.5);\n\n            for (int ix = xst; ix &lt; xnd; ix++)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n                zsinside = Xev.zs[inside];\n                unew = Xev.u[i];\n                vnew = Xev.v[i];\n                zsnew = Xev.zs[i];\n                hnew = Xev.h[i];\n                zbnew = zb[i];\n\n                halowall(zsinside, unew, vnew, zsnew, hnew, zbnew);\n\n                Xev.u[i] = unew;\n                Xev.v[i] = vnew;\n                Xev.zs[i] = zsnew;\n                Xev.h[i] = hnew;\n                zb[i] = zbnew;\n\n            }\n\n        }\n\n\n\n    }\n}\ntemplate __host__ void maskbnd&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float* zb);\ntemplate __host__ void maskbnd&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, double* zb);\n\n//For the GPU version we apply 4 separate global function in the hope to increase occupancy\ntemplate &lt;class T&gt; __global__ void maskbndGPUleft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ibl = blockIdx.x;\n    if (ibl &lt; XBlock.mask.nblk)\n    {\n        int ix, iy;\n\n        int isright, istop;\n\n        T zsinside, zsnew, hnew, vnew, unew, zbnew;\n        T hinside;\n\n        bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n        int ib = XBlock.mask.blks[ibl];\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        //leftside\n        if (isleftbot | islefttop)//?\n        {\n            isright = -1;\n            istop = 0;\n\n            ix = -1;\n            iy = threadIdx.x;\n            int yst = isleftbot ? 0 : XParam.blkwidth * 0.5;\n            int ynd = islefttop ? XParam.blkwidth : XParam.blkwidth * 0.5;\n\n            if (iy &gt;= yst &amp;&amp; iy &lt; ynd)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n\n                zsinside = Xev.zs[inside];\n                hinside = Xev.h[inside];\n\n                unew = Xev.u[i];\n                vnew = Xev.v[i];\n                zsnew = Xev.zs[i];\n                hnew = Xev.h[i];\n                zbnew = zb[i];\n\n\n                //halowall(zsinside, unew, vnew, zsnew, hnew, zbnew);\n                //noslipbnd(zsinside, hinside, unew, vnew, zsnew, hnew);\n\n\n                Xev.u[i] = unew;\n                Xev.v[i] = vnew;\n                Xev.zs[i] = zsnew;\n                Xev.h[i] = hnew;\n                zb[i] = zbnew;\n\n\n            }\n\n        }\n    }\n\n}\ntemplate __global__ void maskbndGPUleft&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float* zb);\ntemplate __global__ void maskbndGPUleft&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, double* zb);\n\n\ntemplate &lt;class T&gt; __global__ void maskbndGPUFluxleft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, FluxP&lt;T&gt; Flux)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ibl = blockIdx.x;\n    if (ibl &lt; XBlock.mask.nblk)\n    {\n        int ix, iy;\n\n        int isright, istop;\n\n        //T zsinside, zsnew, hnew, vnew, unew, zbnew;\n        //T hinside;\n\n        bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n        int ib = XBlock.mask.blks[ibl];\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        //leftside\n        if (isleftbot | islefttop)//?\n        {\n            isright = -1;\n            istop = 0;\n\n            ix = -1;\n            iy = threadIdx.x;\n            int yst = isleftbot ? 0 : XParam.blkwidth * 0.5;\n            int ynd = islefttop ? XParam.blkwidth : XParam.blkwidth * 0.5;\n\n            if (iy &gt;= yst &amp;&amp; iy &lt; ynd)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n                T zsinside = Xev.zs[inside];\n                T zsi = Xev.zs[i];\n                T hinside = Xev.h[i];\n\n                T zsbnd = T(0.0);\n                T qmean = T(0.0);\n                T factime = min(T(XParam.dt / 60.0), T(1.0));\n                T facrel = T(1.0) - min(T(XParam.dt / 3600.0), T(1.0));\n                if (XParam.aoibnd == 0)\n                {\n                    noslipbndQ(Flux.Fhu[inside], Flux.Fqux[i], Flux.Su[inside]); //noslipbndQ(T &amp; F, T &amp; G, T &amp; S) F = T(0.0); S = G;\n                }\n                //ABS1DQ(T g, T sign, T factime, T facrel, T zs, T zsbnd, T zsinside, T h, T &amp; qmean, T &amp; q, T &amp; G, T &amp; S)\n                //ABS1DQ(T g, T sign, T factime, T facrel, T zs, T zsbnd, T zsinside, T h, T &amp; qmean, T &amp; q, T &amp; G, T &amp; S)\n                if (XParam.aoibnd == 3)\n                {\n                    if (hinside &gt; XParam.eps)\n                    {\n                        ABS1DQ(T(XParam.g), T(-1.0), factime, facrel, zsi, zsbnd, zsinside, hinside, qmean, Flux.Fhu[inside], Flux.Fqux[i], Flux.Su[inside]);\n                    }\n                    else\n                    {\n                        noslipbndQ(Flux.Fhu[inside], Flux.Fqux[i], Flux.Su[inside]);\n                    }\n                }\n\n\n\n            }\n\n        }\n    }\n\n}\ntemplate __global__ void maskbndGPUFluxleft&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, FluxP&lt;float&gt; Flux);\ntemplate __global__ void maskbndGPUFluxleft&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, FluxP&lt;double&gt; Flux);\n\n\ntemplate &lt;class T&gt; __global__ void maskbndGPUtop(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ibl = blockIdx.x;\n    if (ibl &lt; XBlock.mask.nblk)\n    {\n        int ix, iy;\n\n        int isright, istop;\n\n        T zsinside, zsnew, hnew, vnew, unew, zbnew;\n        T hinside;\n        bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n        int ib = XBlock.mask.blks[ibl];\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        if (istopleft | istopright)//?\n        {\n            isright = 0;\n            istop = 1;\n\n            iy = XParam.blkwidth;\n            ix = threadIdx.x;\n\n            int xst = istopleft ? 0 : XParam.blkwidth * 0.5;\n            int xnd = istopright ? XParam.blkwidth : XParam.blkwidth * 0.5;\n\n            if (ix &gt;= xst &amp;&amp; ix &lt; xnd)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n\n                zsinside = Xev.zs[inside];\n                hinside = Xev.h[inside];\n                unew = Xev.u[i];\n                vnew = Xev.v[i];\n                zsnew = Xev.zs[i];\n                hnew = Xev.h[i];\n                zbnew = zb[i];\n\n                //halowall(zsinside, unew, vnew, zsnew, hnew, zbnew);\n                //noslipbnd(zsinside, hinside, vnew, unew, zsnew, hnew);\n\n                Xev.u[i] = unew;\n                Xev.v[i] = vnew;\n                Xev.zs[i] = zsnew;\n                Xev.h[i] = hnew;\n                zb[i] = zbnew;\n\n\n            }\n        }\n    }\n}\ntemplate __global__ void maskbndGPUtop&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float* zb);\ntemplate __global__ void maskbndGPUtop&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, double* zb);\n\ntemplate &lt;class T&gt; __global__ void maskbndGPUFluxtop(Param XParam, BlockP&lt;T&gt; XBlock,  FluxP&lt;T&gt; Flux)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ibl = blockIdx.x;\n    if (ibl &lt; XBlock.mask.nblk)\n    {\n        int ix, iy;\n\n        int isright, istop;\n\n        T hinside;\n        bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n        int ib = XBlock.mask.blks[ibl];\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        if (istopleft | istopright)//?\n        {\n            isright = 0;\n            istop = 1;\n\n            iy = XParam.blkwidth;\n            ix = threadIdx.x;\n\n            int xst = istopleft ? 0 : XParam.blkwidth * 0.5;\n            int xnd = istopright ? XParam.blkwidth : XParam.blkwidth * 0.5;\n\n            if (ix &gt;= xst &amp;&amp; ix &lt; xnd)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n\n                noslipbndQ(Flux.Fhv[i], Flux.Sv[i], Flux.Fqvy[inside]); //noslipbndQ(T &amp; F, T &amp; G, T &amp; S) F = T(0.0); S = G;\n\n\n\n            }\n        }\n    }\n}\ntemplate __global__ void maskbndGPUFluxtop&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, FluxP&lt;float&gt; Flux);\ntemplate __global__ void maskbndGPUFluxtop&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, FluxP&lt;double&gt; Flux);\n\ntemplate &lt;class T&gt; __global__ void maskbndGPUright(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ibl = blockIdx.x;\n    if (ibl &lt; XBlock.mask.nblk)\n    {\n        int ix, iy;\n\n        int isright, istop;\n\n        T zsinside, zsnew, hnew, vnew, unew, zbnew;\n        T hinside;\n        bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n        int ib = XBlock.mask.blks[ibl];\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        if (isrighttop | isrightbot)//?\n        {\n            isright = 1;\n            istop = 0;\n\n            ix = XParam.blkwidth;\n\n            iy = threadIdx.x;\n\n            int yst = isrightbot ? 0 : XParam.blkwidth * 0.5;\n            int ynd = isrighttop ? XParam.blkwidth : XParam.blkwidth * 0.5;\n\n            if (iy &gt;= yst &amp;&amp; iy &lt; ynd)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n\n                zsinside = Xev.zs[inside];\n                hinside = Xev.h[inside];\n                unew = Xev.u[i];\n                vnew = Xev.v[i];\n                zsnew = Xev.zs[i];\n                hnew = Xev.h[i];\n                zbnew = zb[i];\n\n                //halowall(zsinside, unew, vnew, zsnew, hnew, zbnew);\n                //noslipbnd(zsinside, hinside, unew, vnew, zsnew, hnew);\n\n                Xev.u[i] = unew;\n                Xev.v[i] = vnew;\n                Xev.zs[i] = zsnew;\n                Xev.h[i] = hnew;\n                zb[i] = zbnew;\n\n\n            }\n        }\n    }\n}\ntemplate __global__ void maskbndGPUright&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float* zb);\ntemplate __global__ void maskbndGPUright&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, double* zb);\n\n\ntemplate &lt;class T&gt; __global__ void maskbndGPUFluxright(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ibl = blockIdx.x;\n    if (ibl &lt; XBlock.mask.nblk)\n    {\n        int ix, iy;\n\n        int isright, istop;\n\n        //T zsinside, zsnew, hnew, vnew, unew, zbnew;\n        //T hinside;\n        bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n        int ib = XBlock.mask.blks[ibl];\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        if (isrighttop | isrightbot)//?\n        {\n            isright = 1;\n            istop = 0;\n\n            ix = XParam.blkwidth;\n\n            iy = threadIdx.x;\n\n            int yst = isrightbot ? 0 : XParam.blkwidth * 0.5;\n            int ynd = isrighttop ? XParam.blkwidth : XParam.blkwidth * 0.5;\n\n            if (iy &gt;= yst &amp;&amp; iy &lt; ynd)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n\n                noslipbndQ(Flux.Fhu[i], Flux.Su[i], Flux.Fqux[inside]); //noslipbndQ(T &amp; F, T &amp; G, T &amp; S) F = T(0.0); S = G;\n\n\n\n            }\n        }\n    }\n}\ntemplate __global__ void maskbndGPUFluxright&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, FluxP&lt;float&gt; Flux);\ntemplate __global__ void maskbndGPUFluxright&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, FluxP&lt;double&gt; Flux);\n\ntemplate &lt;class T&gt; __global__ void maskbndGPUbot(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ibl = blockIdx.x;\n    if (ibl &lt; XBlock.mask.nblk)\n    {\n        int ix, iy;\n\n        int isright, istop;\n\n        T zsinside, zsnew, hnew, vnew, unew, zbnew;\n        T hinside;\n        bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n        int ib = XBlock.mask.blks[ibl];\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        if (isbotright | isbotleft)//?\n        {\n            isright = 0;\n            istop = -1;\n\n\n            iy = -1;\n            ix = threadIdx.x;\n            int xst = isbotleft ? 0 : XParam.blkwidth * 0.5;\n            int xnd = isbotright ? XParam.blkwidth : XParam.blkwidth * 0.5;\n\n\n            if (ix &gt;= xst &amp;&amp; ix &lt; xnd)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n\n                zsinside = Xev.zs[inside];\n                hinside = Xev.h[inside];\n\n                unew = Xev.u[i];\n                vnew = Xev.v[i];\n                zsnew = Xev.zs[i];\n                hnew = Xev.h[i];\n                zbnew = zb[i];\n\n                //halowall(zsinside, unew, vnew, zsnew, hnew, zbnew);\n                //noslipbnd(zsinside, hinside, vnew, unew, zsnew, hnew);\n\n                Xev.u[i] = unew;\n                Xev.v[i] = vnew;\n                Xev.zs[i] = zsnew;\n                Xev.h[i] = hnew;\n                zb[i] = zbnew;\n\n            }\n\n        }\n    }\n}\ntemplate __global__ void maskbndGPUbot&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float* zb);\ntemplate __global__ void maskbndGPUbot&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, double* zb);\n\ntemplate &lt;class T&gt; __global__ void maskbndGPUFluxbot(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ibl = blockIdx.x;\n    if (ibl &lt; XBlock.mask.nblk)\n    {\n        int ix, iy;\n\n        int isright, istop;\n\n        T zsinside, zsnew, hnew, vnew, unew, zbnew;\n        T hinside;\n        bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n        int ib = XBlock.mask.blks[ibl];\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        if (isbotright | isbotleft)//?\n        {\n            isright = 0;\n            istop = -1;\n\n\n            iy = 0;\n            ix = threadIdx.x;\n            int xst = isbotleft ? 0 : XParam.blkwidth * 0.5;\n            int xnd = isbotright ? XParam.blkwidth : XParam.blkwidth * 0.5;\n\n\n            if (ix &gt;= xst &amp;&amp; ix &lt; xnd)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n                noslipbndQ(Flux.Fhv[inside], Flux.Fqvy[i], Flux.Sv[inside]); //noslipbndQ(T &amp; F, T &amp; G, T &amp; S) F = T(0.0); S = G;\n\n            }\n\n        }\n    }\n}\ntemplate __global__ void maskbndGPUFluxbot&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, FluxP&lt;float&gt; Flux);\ntemplate __global__ void maskbndGPUFluxbot&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, FluxP&lt;double&gt; Flux);\n\n__device__ __host__ void findmaskside(int side, bool &amp;isleftbot, bool&amp; islefttop, bool&amp; istopleft, bool&amp; istopright, bool&amp; isrighttop, bool&amp; isrightbot, bool&amp; isbotright, bool&amp; isbotleft)\n{\n    int lb = 0b10000000;\n    int lt = 0b01000000;\n    int tl = 0b00100000;\n    int tr = 0b00010000;\n    int rt = 0b00001000;\n    int rb = 0b00000100;\n    int br = 0b00000010;\n    int bl = 0b00000001;\n\n    isleftbot = (side &amp; lb) == lb;\n    islefttop = (side &amp; lt) == lt;\n\n    istopleft = (side &amp; tl) == tl;\n    istopright = (side &amp; tr) == tr;\n\n    isrighttop = (side &amp; rt) == rt;\n    isrightbot = (side &amp; rb) == rb;\n\n    isbotright = (side &amp; br) == br;\n    isbotleft = (side &amp; bl) == bl;\n}\n\n\ntemplate &lt;class T&gt; __device__ __host__ void halowall(T zsinside, T&amp; un, T&amp; ut, T&amp; zs, T&amp; h,T&amp;zb)\n{\n    // This function is used to make a wall on the halo to act as a wall\n    // It may be more suitable/stable than the noslip as a wall boundary\n    un = T(0.0);\n    zs = zsinside;\n    ut = T(0.0);\n    h = T(0.0);\n    zb = zsinside;\n\n}\n\n\ntemplate &lt;class T&gt; __device__ __host__ void noslipbnd(T zsinside,T hinside,T &amp;un, T &amp;ut,T &amp;zs, T &amp;h)\n{\n    // Basic no slip bnd hs no normal velocity and leaves tanegtial velocity alone (maybe needs a wall friction added to it?)\n    // \n    un = T(0.0);\n    zs = zsinside;\n    //ut[i] = ut[inside];//=0.0?\n    h = hinside;//=0.0?\n\n}\n\ntemplate &lt;class T&gt; __device__ __host__ void noslipbndQ(T&amp; F, T&amp; G, T&amp; S)\n{\n    // Basic no slip bnd hs no normal velocity and leaves tanegtial velocity alone (maybe needs a wall friction added to it?)\n    // \n    F = T(0.0);\n    S = G;\n\n}\n\n\ntemplate &lt;class T&gt; __device__ __host__ void ABS1D(T g, T sign, T zsbnd, T zsinside, T hinside, T utbnd,T unbnd, T&amp; un, T&amp; ut, T&amp; zs, T&amp; h)\n{\n    //Absorbing 1D boundary\n    //When nesting unbnd is read from file. when unbnd is not known assume 0. or the mean of un over a certain time \n    // For utbnd use utinside if no utbnd are known \n    un= sign * sqrt(g / h) * (zsinside - zsbnd) + T(unbnd);\n    zs = zsinside;\n    ut = T(utbnd);//ut[inside];\n    h = hinside;\n}\n\ntemplate &lt;class T&gt; __device__ __host__ void ABS1DQ(T g, T sign, T factime,T facrel,T zs, T zsbnd, T zsinside, T h, T&amp; qmean, T&amp; q, T&amp; G, T&amp; S)\n{\n    //Absorbing 1D boundary\n    //When nesting unbnd is read from file. when unbnd is not known assume 0. or the mean of un over a certain time \n    // For utbnd use utinside if no utbnd are known \n\n\n\n    qmean = h &lt; T(0.01) ? T(0.0) : factime* q + facrel * (T(1.0) - factime) * qmean;\n    //qmean = factime * q + facrel * (T(1.0) - factime) * qmean;\n\n    T un;\n    T zn = max(zsbnd, (zs - h));\n\n    T hn = max(h, T(0.0001));\n\n\n    // Below should be hinside ? or h at Flux bnd?\n    // What if h is 0? then q and qmean should be 0\n    //un = sign * sqrt(g / h) * (T(2.0)*(zs - zsbnd) - (zsinside - zsbnd));\n    //un = sign* sqrt(g / h)* (T(2.0) * zs - zsinside - zsbnd);\n    un = sign * sqrt(g / hn) * (zs-zn);\n    //un = sign* sqrt(g / h)* (zs + zsinside - T(2.0) * zsbnd);\n    //zs = zsinside;\n    //zs = zsinside;\n    //ut = T(utbnd);//ut[inside];\n    //h = hinside;\n\n    q = un * hn + qmean;\n\n    //S = G;\n    //G = S-q;\n\n\n}\n\ntemplate &lt;class T&gt; __device__ __host__ void Dirichlet1D(T g, T sign, T zsbnd, T zsinside, T hinside,  T uninside, T&amp; un, T&amp; ut, T&amp; zs, T&amp; h)\n{\n    // Is this even the right formulation?.\n    // I don't really like this formulation. while a bit less dissipative then abs1D with 0 unbnd (but worse if forcing uniside with 0) it is very reflective an not stable  \n    T zbinside = zsinside - hinside;\n    un = sign * T(2.0) * (sqrt(g * max(hinside, T(0.0))) - sqrt(g * max(zsbnd - zbinside, T(0.0)))) + uninside;\n    ut = T(0.0);\n    zs = zsinside;\n    //ut[i] = ut[inside];\n    h = hinside;\n}\n\ntemplate &lt;class T&gt; __device__ __host__ void Dirichlet1Q(T g, T sign, T zsbnd, T zsinside, T hinside, T uninside, T&amp; q)\n{\n    // Is this even the right formulation?.\n    // I don't really like this formulation. while a bit less dissipative then abs1D with 0 unbnd (but worse if forcing uniside with 0) it is very reflective an not stable  \n    T zbinside = zsinside - hinside;\n    T un = sign * T(2.0) * (sqrt(g * max(hinside, T(0.0))) - sqrt(g * max(zsbnd - zbinside, T(0.0)))) + uninside;\n    T ut = T(0.0);\n    //zs = zsinside;\n    //ut[i] = ut[inside];\n    //h = hinside;\n\n    q = un * hinside;\n}\n\n\n\n/*\ntemplate &lt;class T&gt; __global__ void ABS1D(int halowidth,int isright, int istop, int nbnd, T g, T dx, T xo, T yo, T xmax, T ymax, T itime, cudaTextureObject_t texZsBND, int* bndblck, int* level, T* blockxo, T* blockyo, T* zs, T* zb, T* h, T* un, T* ut)\n{\n\n\n\n    T xx, yy;\n\n    T  sign, umean;\n    float itx;\n\n    sign = T(isright) + T(istop);\n\n\n\n\n    //int xplus;\n    //float hhi;\n    float zsbnd;\n    T zsinside;\n    T levdx= calcres(dx, level[ib]);\n    xx = blockxo[ib] + ix * levdx;\n    yy = blockyo[ib] + iy * levdx;\n\n\n    if (isright == 0) //leftside\n    {\n\n        itx = (xx - xo) / (xmax - xo) * (nbnd - 1);\n    }\n    else \n    {\n\n        itx = (yy - yo) / (ymax - yo) * (nbnd - 1);\n    }\n\n\n    umean = T(0.0);\n    zsbnd = tex2D(texZsBND, itime + 0.5f, itx + 0.5f);// textures use pixel registration so index of 0 is actually located at 0.5...\n\n    if (isbnd(isright, istop, blockDim.x, ix, iy) &amp;&amp; zsbnd &gt; zb[i])\n    {\n\n        zsinside = zs[inside];\n\n        un[i] = sign * sqrt(g / h[i]) * (zsinside - zsbnd) + umean;\n        zs[i] = zsinside;\n        ut[i] = ut[inside];\n        h[i] = h[inside];\n    }\n}\n\n\ntemplate &lt;class T&gt; __host__ void ABS1D(Param XParam, std::vector&lt;double&gt; zsbndvec, int isright, int istop, int nbnd, T itime, BlockP&lt;T&gt; XBlock, int * bndblk, T* zs, T* zb, T* h, T* un, T* ut)\n{\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = bndblk[ibl];\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n                int inside = Inside(XParam.halowidth, XParam.blkmemwidth, isright, istop, ix, iy, ib);\n\n                // left bnd: isrigit = -1; istop=0;\n                // right bnd: isright = 1; istop=0;\n                // bottom bnd: isright = 0; istop=-1;\n                // top bnd: isright = 0; istop=1;\n\n                T xx, yy;\n\n                T  sign, umean;\n                float itx;\n\n                sign = T(isright) + T(istop);\n\n\n\n\n                //int xplus;\n                //float hhi;\n                float zsbnd;\n                T zsinside;\n                T levdx = calcres(dx, XBlock.level[ib]);\n                xx = XBlock.xo[ib] + ix * levdx;\n                yy = XBlock.yo[ib] + iy * levdx;\n                int nbnd = zsbndvec.size();\n\n                if (isright == 0) //leftside\n                {\n\n                    itx = (xx - XParam.xo) / (XParam.xmax - XParam.xo) * (nbnd - 1);\n                }\n                else\n                {\n\n                    itx = (yy - XParam.yo) / (XParam.ymax - XParam.yo) * (nbnd - 1);\n                }\n\n\n                umean = T(0.0);\n\n                if (zsbndvec.size() == 1)\n                {\n                    zsbnd = zsbndvec[0];\n                }\n                else\n                {\n                    int iprev = utils::max(utils::min((int)floor(itx),nbnd-2),0);//utils::min(utils::max((int)ceil(itx / (1 / (zsbndvec.size() - 1))), 0), (int)zsbndvec.size() - 2);\n                    int inext = iprev + 1;\n                    // here interp time is used to interpolate to the right node rather than in time...\n                    zsbnd = interptime(zsbndvec[inext], zsbndvec[iprev], 1.0, (itx - iprev));\n                }\n\n                if (isbnd(isright, istop, blockDim.x, ix, iy) &amp;&amp; zsbnd &gt; zb[i])\n                {\n\n                    zsinside = zs[inside];\n\n                    un[i] = sign * sqrt(XParam.g / h[i]) * (zsinside - zsbnd) + umean;\n                    zs[i] = zsinside;\n                    ut[i] = ut[inside];\n                    h[i] = h[inside];\n                }\n            }\n        }\n    }\n}\n*/\n\n__host__ __device__ int Inside(int halowidth, int blkmemwidth, int isright, int istop,int ix,int iy, int ib)\n{\n    //int bnd, bnd_c;\n    int inside;\n\n    if (isright &lt; 0)\n    {\n        inside = memloc(halowidth, blkmemwidth, ix + 1, iy, ib);\n        //bnd_c = 0;\n        //bnd = ix;\n\n    }\n    else if (isright &gt; 0)\n    {\n        inside = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n        //bnd_c = blockDim.x - 1;\n        //bnd = ix;\n\n    }\n    else if (istop &lt; 0)//isright must be ==0!\n    {\n        inside = memloc(halowidth, blkmemwidth, ix, iy + 1, ib);\n        //bnd_c = 0;\n        //bnd = iy;\n\n    }\n    else // istop ==1 &amp;&amp; isright ==0\n    {\n        inside = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n        //bnd_c = blockDim.y - 1;\n        //bnd = iy;\n\n    }\n    return inside;\n}\n\n\n__host__ __device__ bool isbnd(int isright, int istop, int blkwidth, int ix, int iy)\n{\n    int bnd, bnd_c;\n    //int inside;\n\n    if (isright &lt; 0 || istop &lt; 0)\n    {\n        bnd_c = 0;\n    }\n    else\n    {\n        bnd_c = blkwidth - 1;\n    }\n\n    if (isright == 0)\n    {\n        bnd = iy;\n    }\n    else\n    {\n        bnd = ix;\n    }\n\n\n    return (bnd == bnd_c);\n}\n</code></pre>"},{"location":"BGFlood/Boundary_8h/","title":"File Boundary.h","text":""},{"location":"BGFlood/Boundary_8h/#file-boundaryh","title":"File Boundary.h","text":"<p>FileList &gt; src &gt; Boundary.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Updateforcing.h\"</code></li> </ul>"},{"location":"BGFlood/Boundary_8h/#public-functions","title":"Public Functions","text":"Type Name __device__ __host__ void ABS1D (T g, T sign, T zsbnd, T zsinside, T hinside, T utbnd, T unbnd, T &amp; un, T &amp; ut, T &amp; zs, T &amp; h)  __device__ __host__ void ABS1DQ (T g, T sign, T factime, T facrel, T zs, T zsbnd, T zsinside, T h, T &amp; qmean, T &amp; q, T &amp; G, T &amp; S)  __device__ __host__ void Dirichlet1D (T g, T sign, T zsbnd, T zsinside, T hinside, T uninside, T &amp; un, T &amp; ut, T &amp; zs, T &amp; h)  __device__ __host__ void Dirichlet1Q (T g, T sign, T zsbnd, T zsinside, T hinside, T uninside, T &amp; q)  void Flowbnd (Param XParam, Loop&lt; T &gt; &amp; XLoop, BlockP&lt; T &gt; XBlock, bndparam side, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; T &gt; XEv)  void FlowbndFlux (Param XParam, double totaltime, BlockP&lt; T &gt; XBlock, bndsegment bndseg, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; T &gt; XEv, FluxP&lt; T &gt; XFlux)  void FlowbndFlux (Param XParam, double totaltime, BlockP&lt; T &gt; XBlock, bndparam side, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; T &gt; XEv, FluxP&lt; T &gt; XFlux)  void FlowbndFluxML (Param XParam, double totaltime, BlockP&lt; T &gt; XBlock, bndsegment bndseg, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; T &gt; XEv, FluxMLP&lt; T &gt; XFlux)  __host__ __device__ int Inside (int halowidth, int blkmemwidth, int isright, int istop, int ix, int iy, int ib)  __host__ void bndCPU (Param XParam, bndparam side, BlockP&lt; T &gt; XBlock, std::vector&lt; double &gt; zsbndvec, std::vector&lt; double &gt; uubndvec, std::vector&lt; double &gt; vvbndvec, DynForcingP&lt; float &gt; Atmp, T * zs, T * h, T * un, T * ut)  __global__ void bndFluxGPUSide (Param XParam, bndsegmentside side, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Atmp, DynForcingP&lt; float &gt; Zsmap, bool uniform, int type, float zsbnd, T taper, T * zs, T * h, T * un, T * ut, T * Fh, T * Fq, T * Ss)  __global__ void bndGPU (Param XParam, bndparam side, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Atmp, float itime, T * zs, T * h, T * un, T * ut)  __device__ __host__ void findmaskside (int side, bool &amp; isleftbot, bool &amp; islefttop, bool &amp; istopleft, bool &amp; istopright, bool &amp; isrighttop, bool &amp; isrightbot, bool &amp; isbotright, bool &amp; isbotleft)  __device__ __host__ void halowall (T zsinside, T &amp; un, T &amp; ut, T &amp; zs, T &amp; h, T &amp; zb)  __host__ __device__ bool isbnd (int isright, int istop, int blkwidth, int ix, int iy)  __host__ void maskbnd (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  __global__ void maskbndGPUFluxbot (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux)  __global__ void maskbndGPUFluxleft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, FluxP&lt; T &gt; Flux)  __global__ void maskbndGPUFluxright (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux)  __global__ void maskbndGPUFluxtop (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux)  __global__ void maskbndGPUbot (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  __global__ void maskbndGPUleft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  __global__ void maskbndGPUright (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  __global__ void maskbndGPUtop (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  __device__ __host__ void noslipbnd (T zsinside, T hinside, T &amp; un, T &amp; ut, T &amp; zs, T &amp; h)  __device__ __host__ void noslipbndQ (T &amp; F, T &amp; G, T &amp; S)"},{"location":"BGFlood/Boundary_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Boundary_8h/#function-abs1d","title":"function ABS1D","text":"<pre><code>template&lt;class T&gt;\n__device__ __host__ void ABS1D (\n    T g,\n    T sign,\n    T zsbnd,\n    T zsinside,\n    T hinside,\n    T utbnd,\n    T unbnd,\n    T &amp; un,\n    T &amp; ut,\n    T &amp; zs,\n    T &amp; h\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-abs1dq","title":"function ABS1DQ","text":"<pre><code>template&lt;class T&gt;\n__device__ __host__ void ABS1DQ (\n    T g,\n    T sign,\n    T factime,\n    T facrel,\n    T zs,\n    T zsbnd,\n    T zsinside,\n    T h,\n    T &amp; qmean,\n    T &amp; q,\n    T &amp; G,\n    T &amp; S\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-dirichlet1d","title":"function Dirichlet1D","text":"<pre><code>template&lt;class T&gt;\n__device__ __host__ void Dirichlet1D (\n    T g,\n    T sign,\n    T zsbnd,\n    T zsinside,\n    T hinside,\n    T uninside,\n    T &amp; un,\n    T &amp; ut,\n    T &amp; zs,\n    T &amp; h\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-dirichlet1q","title":"function Dirichlet1Q","text":"<pre><code>template&lt;class T&gt;\n__device__ __host__ void Dirichlet1Q (\n    T g,\n    T sign,\n    T zsbnd,\n    T zsinside,\n    T hinside,\n    T uninside,\n    T &amp; q\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-flowbnd","title":"function Flowbnd","text":"<pre><code>template&lt;class T&gt;\nvoid Flowbnd (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    bndparam side,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; T &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-flowbndflux","title":"function FlowbndFlux","text":"<pre><code>template&lt;class T&gt;\nvoid FlowbndFlux (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; T &gt; XBlock,\n    bndsegment bndseg,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; T &gt; XEv,\n    FluxP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-flowbndflux_1","title":"function FlowbndFlux","text":"<pre><code>template&lt;class T&gt;\nvoid FlowbndFlux (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; T &gt; XBlock,\n    bndparam side,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; T &gt; XEv,\n    FluxP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-flowbndfluxml","title":"function FlowbndFluxML","text":"<pre><code>template&lt;class T&gt;\nvoid FlowbndFluxML (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; T &gt; XBlock,\n    bndsegment bndseg,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; T &gt; XEv,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-inside","title":"function Inside","text":"<pre><code>__host__ __device__ int Inside (\n    int halowidth,\n    int blkmemwidth,\n    int isright,\n    int istop,\n    int ix,\n    int iy,\n    int ib\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-bndcpu","title":"function bndCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void bndCPU (\n    Param XParam,\n    bndparam side,\n    BlockP &lt; T &gt; XBlock,\n    std::vector&lt; double &gt; zsbndvec,\n    std::vector&lt; double &gt; uubndvec,\n    std::vector&lt; double &gt; vvbndvec,\n    DynForcingP &lt; float &gt; Atmp,\n    T * zs,\n    T * h,\n    T * un,\n    T * ut\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-bndfluxgpuside","title":"function bndFluxGPUSide","text":"<pre><code>template&lt;class T&gt;\n__global__ void bndFluxGPUSide (\n    Param XParam,\n    bndsegmentside side,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Atmp,\n    DynForcingP &lt; float &gt; Zsmap,\n    bool uniform,\n    int type,\n    float zsbnd,\n    T taper,\n    T * zs,\n    T * h,\n    T * un,\n    T * ut,\n    T * Fh,\n    T * Fq,\n    T * Ss\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-bndgpu","title":"function bndGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void bndGPU (\n    Param XParam,\n    bndparam side,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Atmp,\n    float itime,\n    T * zs,\n    T * h,\n    T * un,\n    T * ut\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-findmaskside","title":"function findmaskside","text":"<pre><code>__device__ __host__ void findmaskside (\n    int side,\n    bool &amp; isleftbot,\n    bool &amp; islefttop,\n    bool &amp; istopleft,\n    bool &amp; istopright,\n    bool &amp; isrighttop,\n    bool &amp; isrightbot,\n    bool &amp; isbotright,\n    bool &amp; isbotleft\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-halowall","title":"function halowall","text":"<pre><code>template&lt;class T&gt;\n__device__ __host__ void halowall (\n    T zsinside,\n    T &amp; un,\n    T &amp; ut,\n    T &amp; zs,\n    T &amp; h,\n    T &amp; zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-isbnd","title":"function isbnd","text":"<pre><code>__host__ __device__ bool isbnd (\n    int isright,\n    int istop,\n    int blkwidth,\n    int ix,\n    int iy\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-maskbnd","title":"function maskbnd","text":"<pre><code>template&lt;class T&gt;\n__host__ void maskbnd (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-maskbndgpufluxbot","title":"function maskbndGPUFluxbot","text":"<pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUFluxbot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-maskbndgpufluxleft","title":"function maskbndGPUFluxleft","text":"<pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUFluxleft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-maskbndgpufluxright","title":"function maskbndGPUFluxright","text":"<pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUFluxright (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-maskbndgpufluxtop","title":"function maskbndGPUFluxtop","text":"<pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUFluxtop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-maskbndgpubot","title":"function maskbndGPUbot","text":"<pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUbot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-maskbndgpuleft","title":"function maskbndGPUleft","text":"<pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUleft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-maskbndgpuright","title":"function maskbndGPUright","text":"<pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUright (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-maskbndgputop","title":"function maskbndGPUtop","text":"<pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUtop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-noslipbnd","title":"function noslipbnd","text":"<pre><code>template&lt;class T&gt;\n__device__ __host__ void noslipbnd (\n    T zsinside,\n    T hinside,\n    T &amp; un,\n    T &amp; ut,\n    T &amp; zs,\n    T &amp; h\n) \n</code></pre>"},{"location":"BGFlood/Boundary_8h/#function-noslipbndq","title":"function noslipbndQ","text":"<pre><code>template&lt;class T&gt;\n__device__ __host__ void noslipbndQ (\n    T &amp; F,\n    T &amp; G,\n    T &amp; S\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Boundary.h</code></p>"},{"location":"BGFlood/Boundary_8h_source/","title":"File Boundary.h","text":""},{"location":"BGFlood/Boundary_8h_source/#file-boundaryh","title":"File Boundary.h","text":"<p>File List &gt; src &gt; Boundary.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef BOUNDARY_H\n#define BOUNDARY_H\n// includes, system\n\n#include \"General.h\"\n#include \"MemManagement.h\"\n#include \"Util_CPU.h\"\n#include \"Updateforcing.h\"\n\n\n\ntemplate &lt;class T&gt; void Flowbnd(Param XParam, Loop&lt;T&gt;&amp; XLoop, BlockP&lt;T&gt; XBlock, bndparam side, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;T&gt; XEv);\n__host__ __device__ int Inside(int halowidth, int blkmemwidth, int isright, int istop, int ix, int iy, int ib);\n__host__ __device__ bool isbnd(int isright, int istop, int blkwidth, int ix, int iy);\n\ntemplate &lt;class T&gt; __host__ void maskbnd(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\ntemplate &lt;class T&gt; __global__ void maskbndGPUleft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\ntemplate &lt;class T&gt; __global__ void maskbndGPUtop(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\ntemplate &lt;class T&gt; __global__ void maskbndGPUright(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\ntemplate &lt;class T&gt; __global__ void maskbndGPUbot(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\n\ntemplate &lt;class T&gt; __global__ void maskbndGPUFluxleft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, FluxP&lt;T&gt; Flux);\ntemplate &lt;class T&gt; __global__ void maskbndGPUFluxtop(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux);\ntemplate &lt;class T&gt; __global__ void maskbndGPUFluxright(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux);\ntemplate &lt;class T&gt; __global__ void maskbndGPUFluxbot(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux);\n\ntemplate &lt;class T&gt; void FlowbndFlux(Param XParam, double totaltime, BlockP&lt;T&gt; XBlock, bndsegment bndseg, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;T&gt; XEv, FluxP&lt;T&gt; XFlux);\ntemplate &lt;class T&gt; void FlowbndFlux(Param XParam,double totaltime, BlockP&lt;T&gt; XBlock, bndparam side, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;T&gt; XEv, FluxP&lt;T&gt; XFlux);\ntemplate &lt;class T&gt; void FlowbndFluxML(Param XParam, double totaltime, BlockP&lt;T&gt; XBlock, bndsegment bndseg, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;T&gt; XEv, FluxMLP&lt;T&gt; XFlux);\n\ntemplate &lt;class T&gt; __global__ void bndFluxGPUSide(Param XParam, bndsegmentside side, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Atmp, DynForcingP&lt;float&gt; Zsmap, bool uniform, int type, float zsbnd, T taper, T* zs, T* h, T* un, T* ut, T* Fh, T* Fq, T* Ss);\n\ntemplate &lt;class T&gt; __global__ void bndGPU(Param XParam, bndparam side, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Atmp, float itime, T* zs, T* h, T* un, T* ut);\ntemplate &lt;class T&gt; __host__ void bndCPU(Param XParam, bndparam side, BlockP&lt;T&gt; XBlock, std::vector&lt;double&gt; zsbndvec, std::vector&lt;double&gt; uubndvec, std::vector&lt;double&gt; vvbndvec, DynForcingP&lt;float&gt; Atmp, T* zs, T* h, T* un, T* ut);\n\n\n__device__ __host__ void findmaskside(int side, bool &amp;isleftbot, bool&amp; islefttop, bool&amp; istopleft, bool&amp; istopright, bool&amp; isrighttop, bool&amp; isrightbot, bool&amp; isbotright, bool&amp; isbotleft);\ntemplate &lt;class T&gt; __device__ __host__ void halowall(T zsinside, T&amp; un, T&amp; ut, T&amp; zs, T&amp; h,T&amp;zb);\ntemplate &lt;class T&gt; __device__ __host__ void noslipbnd(T zsinside,T hinside,T &amp;un, T &amp;ut,T &amp;zs, T &amp;h);\ntemplate &lt;class T&gt; __device__ __host__ void noslipbndQ(T&amp; F, T&amp; G, T&amp; S);\ntemplate &lt;class T&gt; __device__ __host__ void ABS1D(T g, T sign, T zsbnd, T zsinside, T hinside, T utbnd,T unbnd, T&amp; un, T&amp; ut, T&amp; zs, T&amp; h);\ntemplate &lt;class T&gt; __device__ __host__ void ABS1DQ(T g, T sign, T factime, T facrel, T zs, T zsbnd, T zsinside, T h, T&amp; qmean, T&amp; q, T&amp; G, T&amp; S);\ntemplate &lt;class T&gt; __device__ __host__ void Dirichlet1D(T g, T sign, T zsbnd, T zsinside, T hinside,  T uninside, T&amp; un, T&amp; ut, T&amp; zs, T&amp; h);\ntemplate &lt;class T&gt; __device__ __host__ void Dirichlet1Q(T g, T sign, T zsbnd, T zsinside, T hinside, T uninside, T&amp; q);\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/","title":"File ConserveElevation.cu","text":""},{"location":"BGFlood/ConserveElevation_8cu/#file-conserveelevationcu","title":"File ConserveElevation.cu","text":"<p>FileList &gt; src &gt; ConserveElevation.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ConserveElevation.h\"</code></li> </ul>"},{"location":"BGFlood/ConserveElevation_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ __device__ void ProlongationElevation (int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, T * h, T * zs, T * zb)  __host__ __device__ void ProlongationElevationGH (int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, T * h, T * dhdx, T * dzsdx)  __host__ __device__ void RevertProlongationElevation (int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, int level, T dx, T * h, T * zb, T * dzbdx, T * dzbdy)  void WetDryProlongation (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  template void WetDryProlongation&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, double * zb)  template void WetDryProlongation&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, float * zb)  void WetDryProlongationGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  template void WetDryProlongationGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, double * zb)  template void WetDryProlongationGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, float * zb)  __global__ void WetDryProlongationGPUBot (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryProlongationGPULeft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryProlongationGPURight (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryProlongationGPUTop (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void WetDryRestriction (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  template void WetDryRestriction&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, double * zb)  template void WetDryRestriction&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, float * zb)  void WetDryRestrictionGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  template void WetDryRestrictionGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, double * zb)  template void WetDryRestrictionGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, float * zb)  __global__ void WetDryRestrictionGPUBot (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryRestrictionGPULeft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryRestrictionGPURight (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryRestrictionGPUTop (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevation (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __host__ __device__ void conserveElevation (int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, T * h, T * zs, T * zb)  __host__ __device__ void conserveElevation (T zb, T &amp; zswet, T &amp; hwet)  template void conserveElevation&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, double * zb)  template __host__ __device__ void conserveElevation&lt; double &gt; (int halowidth, int blkmemwidth, double eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, double * h, double * zs, double * zb)  template void conserveElevation&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, float * zb)  template __host__ __device__ void conserveElevation&lt; float &gt; (int halowidth, int blkmemwidth, float eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, float * h, float * zs, float * zb)  void conserveElevationBot (Param XParam, int ib, int ibBL, int ibBR, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void conserveElevationBot (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevationGHBot (Param XParam, int ib, int ibBL, int ibBR, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  __global__ void conserveElevationGHBot (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGHLeft (Param XParam, int ib, int ibLB, int ibLT, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  __global__ void conserveElevationGHLeft (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGHRight (Param XParam, int ib, int ibRB, int ibRT, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  __global__ void conserveElevationGHRight (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGHTop (Param XParam, int ib, int ibTL, int ibTR, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  __global__ void conserveElevationGHTop (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  template void conserveElevationGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, double * zb)  template void conserveElevationGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, float * zb)  void conserveElevationGradHalo (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx, T * dhdy, T * dzsdy)  __host__ __device__ void conserveElevationGradHalo (int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, T * h, T * dhdx, T * dhdy)  template void conserveElevationGradHalo&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * h, double * zs, double * zb, double * dhdx, double * dzsdx, double * dhdy, double * dzsdy)  template void conserveElevationGradHalo&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * h, float * zs, float * zb, float * dhdx, float * dzsdx, float * dhdy, float * dzsdy)  __host__ __device__ void conserveElevationGradHaloA (int halowidth, int blkmemwidth, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, int iq, int jq, T theta, T delta, T * h, T * dhdx)  __host__ __device__ void conserveElevationGradHaloB (int halowidth, int blkmemwidth, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, int iq, int jq, T theta, T delta, T eps, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGradHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx, T * dhdy, T * dzsdy)  template void conserveElevationGradHaloGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * h, double * zs, double * zb, double * dhdx, double * dzsdx, double * dhdy, double * dzsdy)  template void conserveElevationGradHaloGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * h, float * zs, float * zb, float * dhdx, float * dzsdx, float * dhdy, float * dzsdy)  void conserveElevationLeft (Param XParam, int ib, int ibLB, int ibLT, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void conserveElevationLeft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevationRight (Param XParam, int ib, int ibRB, int ibRT, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void conserveElevationRight (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevationTop (Param XParam, int ib, int ibTL, int ibTR, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void conserveElevationTop (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __host__ __device__ void wetdryrestriction (int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, T * h, T * zs, T * zb)  template __host__ __device__ void wetdryrestriction&lt; double &gt; (int halowidth, int blkmemwidth, double eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, double * h, double * zs, double * zb)  template __host__ __device__ void wetdryrestriction&lt; float &gt; (int halowidth, int blkmemwidth, float eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, float * h, float * zs, float * zb)"},{"location":"BGFlood/ConserveElevation_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/ConserveElevation_8cu/#function-prolongationelevation","title":"function ProlongationElevation","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ void ProlongationElevation (\n    int halowidth,\n    int blkmemwidth,\n    T eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int ip,\n    int jp,\n    T * h,\n    T * zs,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-prolongationelevationgh","title":"function ProlongationElevationGH","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ void ProlongationElevationGH (\n    int halowidth,\n    int blkmemwidth,\n    T eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int ip,\n    int jp,\n    T * h,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-revertprolongationelevation","title":"function RevertProlongationElevation","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ void RevertProlongationElevation (\n    int halowidth,\n    int blkmemwidth,\n    T eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int ip,\n    int jp,\n    int level,\n    T dx,\n    T * h,\n    T * zb,\n    T * dzbdx,\n    T * dzbdy\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryprolongation","title":"function WetDryProlongation","text":"<pre><code>template&lt;class T&gt;\nvoid WetDryProlongation (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryprolongation-double","title":"function WetDryProlongation&lt; double &gt;","text":"<pre><code>template void WetDryProlongation&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryprolongation-float","title":"function WetDryProlongation&lt; float &gt;","text":"<pre><code>template void WetDryProlongation&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryprolongationgpu","title":"function WetDryProlongationGPU","text":"<pre><code>template&lt;class T&gt;\nvoid WetDryProlongationGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryprolongationgpu-double","title":"function WetDryProlongationGPU&lt; double &gt;","text":"<pre><code>template void WetDryProlongationGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryprolongationgpu-float","title":"function WetDryProlongationGPU&lt; float &gt;","text":"<pre><code>template void WetDryProlongationGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryprolongationgpubot","title":"function WetDryProlongationGPUBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryProlongationGPUBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryprolongationgpuleft","title":"function WetDryProlongationGPULeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryProlongationGPULeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryprolongationgpuright","title":"function WetDryProlongationGPURight","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryProlongationGPURight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryprolongationgputop","title":"function WetDryProlongationGPUTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryProlongationGPUTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryrestriction","title":"function WetDryRestriction","text":"<pre><code>template&lt;class T&gt;\nvoid WetDryRestriction (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryrestriction-double","title":"function WetDryRestriction&lt; double &gt;","text":"<pre><code>template void WetDryRestriction&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryrestriction-float","title":"function WetDryRestriction&lt; float &gt;","text":"<pre><code>template void WetDryRestriction&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryrestrictiongpu","title":"function WetDryRestrictionGPU","text":"<pre><code>template&lt;class T&gt;\nvoid WetDryRestrictionGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryrestrictiongpu-double","title":"function WetDryRestrictionGPU&lt; double &gt;","text":"<pre><code>template void WetDryRestrictionGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryrestrictiongpu-float","title":"function WetDryRestrictionGPU&lt; float &gt;","text":"<pre><code>template void WetDryRestrictionGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryrestrictiongpubot","title":"function WetDryRestrictionGPUBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryRestrictionGPUBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryrestrictiongpuleft","title":"function WetDryRestrictionGPULeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryRestrictionGPULeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryrestrictiongpuright","title":"function WetDryRestrictionGPURight","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryRestrictionGPURight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryrestrictiongputop","title":"function WetDryRestrictionGPUTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryRestrictionGPUTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevation","title":"function conserveElevation","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevation (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevation_1","title":"function conserveElevation","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ void conserveElevation (\n    int halowidth,\n    int blkmemwidth,\n    T eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int i,\n    int j,\n    T * h,\n    T * zs,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevation_2","title":"function conserveElevation","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ void conserveElevation (\n    T zb,\n    T &amp; zswet,\n    T &amp; hwet\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevation-double","title":"function conserveElevation&lt; double &gt;","text":"<pre><code>template void conserveElevation&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevation-double_1","title":"function conserveElevation&lt; double &gt;","text":"<pre><code>template __host__ __device__ void conserveElevation&lt; double &gt; (\n    int halowidth,\n    int blkmemwidth,\n    double eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int i,\n    int j,\n    double * h,\n    double * zs,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevation-float","title":"function conserveElevation&lt; float &gt;","text":"<pre><code>template void conserveElevation&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevation-float_1","title":"function conserveElevation&lt; float &gt;","text":"<pre><code>template __host__ __device__ void conserveElevation&lt; float &gt; (\n    int halowidth,\n    int blkmemwidth,\n    float eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int i,\n    int j,\n    float * h,\n    float * zs,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationbot","title":"function conserveElevationBot","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationBot (\n    Param XParam,\n    int ib,\n    int ibBL,\n    int ibBR,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationbot_1","title":"function conserveElevationBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationghbot","title":"function conserveElevationGHBot","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGHBot (\n    Param XParam,\n    int ib,\n    int ibBL,\n    int ibBR,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationghbot_1","title":"function conserveElevationGHBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationGHBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationghleft","title":"function conserveElevationGHLeft","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGHLeft (\n    Param XParam,\n    int ib,\n    int ibLB,\n    int ibLT,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationghleft_1","title":"function conserveElevationGHLeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationGHLeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationghright","title":"function conserveElevationGHRight","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGHRight (\n    Param XParam,\n    int ib,\n    int ibRB,\n    int ibRT,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationghright_1","title":"function conserveElevationGHRight","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationGHRight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationghtop","title":"function conserveElevationGHTop","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGHTop (\n    Param XParam,\n    int ib,\n    int ibTL,\n    int ibTR,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationghtop_1","title":"function conserveElevationGHTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationGHTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationgpu","title":"function conserveElevationGPU","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationgpu-double","title":"function conserveElevationGPU&lt; double &gt;","text":"<pre><code>template void conserveElevationGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationgpu-float","title":"function conserveElevationGPU&lt; float &gt;","text":"<pre><code>template void conserveElevationGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationgradhalo","title":"function conserveElevationGradHalo","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGradHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx,\n    T * dhdy,\n    T * dzsdy\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationgradhalo_1","title":"function conserveElevationGradHalo","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ void conserveElevationGradHalo (\n    int halowidth,\n    int blkmemwidth,\n    T eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int i,\n    int j,\n    T * h,\n    T * dhdx,\n    T * dhdy\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationgradhalo-double","title":"function conserveElevationGradHalo&lt; double &gt;","text":"<pre><code>template void conserveElevationGradHalo&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * h,\n    double * zs,\n    double * zb,\n    double * dhdx,\n    double * dzsdx,\n    double * dhdy,\n    double * dzsdy\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationgradhalo-float","title":"function conserveElevationGradHalo&lt; float &gt;","text":"<pre><code>template void conserveElevationGradHalo&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * h,\n    float * zs,\n    float * zb,\n    float * dhdx,\n    float * dzsdx,\n    float * dhdy,\n    float * dzsdy\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationgradhaloa","title":"function conserveElevationGradHaloA","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ void conserveElevationGradHaloA (\n    int halowidth,\n    int blkmemwidth,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int ip,\n    int jp,\n    int iq,\n    int jq,\n    T theta,\n    T delta,\n    T * h,\n    T * dhdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationgradhalob","title":"function conserveElevationGradHaloB","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ void conserveElevationGradHaloB (\n    int halowidth,\n    int blkmemwidth,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int ip,\n    int jp,\n    int iq,\n    int jq,\n    T theta,\n    T delta,\n    T eps,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationgradhalogpu","title":"function conserveElevationGradHaloGPU","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGradHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx,\n    T * dhdy,\n    T * dzsdy\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationgradhalogpu-double","title":"function conserveElevationGradHaloGPU&lt; double &gt;","text":"<pre><code>template void conserveElevationGradHaloGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * h,\n    double * zs,\n    double * zb,\n    double * dhdx,\n    double * dzsdx,\n    double * dhdy,\n    double * dzsdy\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationgradhalogpu-float","title":"function conserveElevationGradHaloGPU&lt; float &gt;","text":"<pre><code>template void conserveElevationGradHaloGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * h,\n    float * zs,\n    float * zb,\n    float * dhdx,\n    float * dzsdx,\n    float * dhdy,\n    float * dzsdy\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationleft","title":"function conserveElevationLeft","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationLeft (\n    Param XParam,\n    int ib,\n    int ibLB,\n    int ibLT,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationleft_1","title":"function conserveElevationLeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationLeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationright","title":"function conserveElevationRight","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationRight (\n    Param XParam,\n    int ib,\n    int ibRB,\n    int ibRT,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationright_1","title":"function conserveElevationRight","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationRight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationtop","title":"function conserveElevationTop","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationTop (\n    Param XParam,\n    int ib,\n    int ibTL,\n    int ibTR,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-conserveelevationtop_1","title":"function conserveElevationTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryrestriction_1","title":"function wetdryrestriction","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ void wetdryrestriction (\n    int halowidth,\n    int blkmemwidth,\n    T eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int i,\n    int j,\n    T * h,\n    T * zs,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryrestriction-double_1","title":"function wetdryrestriction&lt; double &gt;","text":"<pre><code>template __host__ __device__ void wetdryrestriction&lt; double &gt; (\n    int halowidth,\n    int blkmemwidth,\n    double eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int i,\n    int j,\n    double * h,\n    double * zs,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8cu/#function-wetdryrestriction-float_1","title":"function wetdryrestriction&lt; float &gt;","text":"<pre><code>template __host__ __device__ void wetdryrestriction&lt; float &gt; (\n    int halowidth,\n    int blkmemwidth,\n    float eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int i,\n    int j,\n    float * h,\n    float * zs,\n    float * zb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/ConserveElevation.cu</code></p>"},{"location":"BGFlood/ConserveElevation_8cu_source/","title":"File ConserveElevation.cu","text":""},{"location":"BGFlood/ConserveElevation_8cu_source/#file-conserveelevationcu","title":"File ConserveElevation.cu","text":"<p>File List &gt; src &gt; ConserveElevation.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"ConserveElevation.h\"\n\n\ntemplate &lt;class T&gt; void conserveElevation(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        //int ii = memloc(XParam, -1, 5, 46);\n\n\n        conserveElevationLeft(XParam, ib, XBlock.LeftBot[ib], XBlock.LeftTop[ib], XBlock, XEv, zb);\n\n        conserveElevationRight(XParam, ib, XBlock.RightBot[ib], XBlock.RightTop[ib], XBlock, XEv, zb);\n\n        conserveElevationTop(XParam, ib, XBlock.TopLeft[ib], XBlock.TopRight[ib], XBlock, XEv, zb);\n\n        conserveElevationBot(XParam, ib, XBlock.BotLeft[ib], XBlock.BotRight[ib], XBlock, XEv, zb);\n\n    }\n}\ntemplate void conserveElevation&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, float* zb);\ntemplate void conserveElevation&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, double* zb);\n\ntemplate &lt;class T&gt; void conserveElevationGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    dim3 blockDimHaloLR(1, 16, 1);\n    dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n\n    conserveElevationLeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    conserveElevationRight &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    conserveElevationTop &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    conserveElevationBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n}\ntemplate void conserveElevationGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, float* zb);\ntemplate void conserveElevationGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, double* zb);\n\ntemplate &lt;class T&gt; void WetDryProlongation(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int ib, ibLB, ibTL, ibBL, ibRB,ibn;\n    int ihalo, jhalo, ip, jp;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        ibLB = XBlock.LeftBot[ib];\n        ibRB = XBlock.RightBot[ib];\n\n        ibTL = XBlock.TopLeft[ib];\n        ibBL = XBlock.BotLeft[ib];\n\n        //Left side\n        if (XBlock.level[ib] &gt; XBlock.level[ibLB])\n        {\n            // Prolongation\n            for (int j = 0; j &lt; XParam.blkwidth; j++)\n            {\n\n                ihalo = -1;\n                //\n                jhalo = j;\n                ibn = ibLB;\n\n                //il = 0;\n                //jl = j;\n\n\n\n\n                ip = XParam.blkwidth - 1;\n                jp = XBlock.RightBot[ibLB] == ib ? ftoi(floor(j * T(0.5))) : ftoi(floor(j * T(0.5)) + XParam.blkwidth / 2);\n\n                //im = ip;\n                //jm = ceil(j * T(0.5)) * 2 &gt; j ? jp + 1 : jp - 1;\n\n                ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n            }\n        }\n\n        //Right side\n        if (XBlock.level[ib] &gt; XBlock.level[ibRB])\n        {\n            // Prolongation\n            for (int j = 0; j &lt; XParam.blkwidth; j++)\n            {\n\n                ihalo = XParam.blkwidth;\n                //\n                jhalo = j;\n                ibn = ibRB;\n\n                //il = 0;\n                //jl = j;\n\n\n\n\n                ip = 0;\n                jp = XBlock.LeftBot[ibn] == ib ? ftoi(floor(j * T(0.5))) : ftoi(floor(j * T(0.5)) + XParam.blkwidth / 2);\n\n                //im = ip;\n                //jm = ceil(j * T(0.5)) * 2 &gt; j ? jp + 1 : jp - 1;\n\n                ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n            }\n        }\n\n        // Top side\n        if (XBlock.level[ib] &gt; XBlock.level[ibTL])\n        {\n            //\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                jhalo = XParam.blkwidth;\n                //\n                ihalo = i;\n                ibn = ibTL;\n\n                //il = i;\n                //jl = XParam.blkwidth - 1;\n\n                jp = 0;\n                ip = XBlock.BotLeft[ibn] == ib ? ftoi(floor(i * T(0.5))) : ftoi(floor(i * T(0.5)) + XParam.blkwidth / 2);\n\n                //jm = jp;\n                //im = ceil(i * T(0.5)) * 2 &gt; i ? ip + 1 : ip - 1;\n\n                ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n            }\n\n        }\n\n        // Bot side\n        if (XBlock.level[ib] &gt; XBlock.level[ibBL])\n        {\n            //\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                //\n                jhalo = -1;\n                ihalo = i;\n                ibn = ibBL;\n\n                //il = i;\n                //jl = 0;\n\n                jp = XParam.blkwidth - 1;\n                ip = XBlock.TopLeft[ibn] == ib ? ftoi(floor(i * T(0.5))) : ftoi(floor(i * T(0.5)) + XParam.blkwidth / 2);\n\n                //jm = jp;\n                //im = ceil(i * T(0.5)) * 2 &gt; i ? ip + 1 : ip - 1;\n\n                ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n            }\n\n        }\n\n    }\n\n}\ntemplate void WetDryProlongation&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, double* zb);\ntemplate void WetDryProlongation&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, float* zb);\n\ntemplate &lt;class T&gt; void WetDryRestriction(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int ib, ibLB, ibTL, ibBL, ibRB, ibLT, ibRT, ibTR, ibBR, ibn;\n    int ihalo, jhalo, ir, jr, lev;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        ibLB = XBlock.LeftBot[ib];\n        ibLT = XBlock.LeftTop[ib];\n\n        ibRB = XBlock.RightBot[ib];\n        ibRT = XBlock.RightTop[ib];\n\n        ibTL = XBlock.TopLeft[ib];\n        ibTR = XBlock.TopRight[ib];\n\n        ibBL = XBlock.BotLeft[ib];\n        ibBR = XBlock.BotRight[ib];\n\n        lev = XBlock.level[ib];\n\n\n        //Left side\n        ir = XParam.blkwidth - 2;\n        ihalo = -1;\n\n\n        if (lev &lt; XBlock.level[ibLB])\n        {\n\n            for (int iy = 0; iy &lt; (XParam.blkwidth / 2); iy++)\n            {\n                jhalo = iy;\n\n                ibn = ibLB;\n\n\n                jr = iy * 2;\n\n                wetdryrestriction(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n            }\n        }\n        if (lev &lt; XBlock.level[ibLT])\n        {\n            for (int iy = (XParam.blkwidth / 2); iy &lt; XParam.blkwidth; iy++)\n            {\n                jhalo = iy;\n                ibn = ibLT;\n                jr = (iy - (XParam.blkwidth / 2)) * 2;\n\n                wetdryrestriction(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n            }\n        }\n\n\n        //Right side\n\n        ihalo = XParam.blkwidth;\n        ir = 0;\n\n        if (lev &lt; XBlock.level[ibRB] )\n        {\n\n            for (int iy = 0; iy &lt; (XParam.blkwidth / 2); iy++)\n            {\n                jhalo = iy;\n                ibn = ibRB;\n                jr = iy * 2;\n\n                wetdryrestriction(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n            }\n        }\n        if (lev &lt; XBlock.level[ibRT] )\n        {\n            for (int iy = (XParam.blkwidth / 2); iy &lt; XParam.blkwidth; iy++)\n            {\n                jhalo = iy;\n                ibn = ibRT;\n                jr = (iy - (XParam.blkwidth / 2)) * 2;\n\n                wetdryrestriction(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n            }\n        }\n\n        // Top side\n        jhalo = XParam.blkwidth;\n\n        jr = 0;\n\n        if (lev &lt; XBlock.level[ibTL] )\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth / 2); ix++)\n            {\n                ihalo = ix;\n                ibn = ibTL;\n\n                ir = ix * 2;\n\n                wetdryrestriction(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n            }\n        }\n        if (lev &lt; XBlock.level[ibTR] )\n        {\n            for (int ix = (XParam.blkwidth / 2); ix &lt; XParam.blkwidth; ix++)\n            {\n                ihalo = ix;\n                ibn = ibTR;\n                ir = (ix - (XParam.blkwidth / 2)) * 2;\n\n                wetdryrestriction(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n            }\n        }\n\n        // Bot side\n        jhalo = -1;\n\n        jr = XParam.blkwidth - 2;\n\n        if (lev &lt; XBlock.level[ibBL] )\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth / 2); ix++)\n            {\n                ihalo = ix;\n                ibn = ibBL;\n\n                ir = ix * 2;\n\n                wetdryrestriction(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n            }\n        }\n        if (lev &lt; XBlock.level[ibBR] )\n        {\n            for (int ix = (XParam.blkwidth / 2); ix &lt; XParam.blkwidth; ix++)\n            {\n                ihalo = ix;\n                ibn = ibBR;\n                ir = (ix - (XParam.blkwidth / 2)) * 2;\n\n                wetdryrestriction(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n            }\n        }\n\n    }\n\n}\ntemplate void WetDryRestriction&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, double* zb);\ntemplate void WetDryRestriction&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, float* zb);\n\ntemplate &lt;class T&gt; void WetDryProlongationGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    dim3 blockDimHaloLR(1, 16, 1);\n    dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    //WetDryProlongationGPUBot\n\n    WetDryProlongationGPULeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    WetDryProlongationGPURight &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    WetDryProlongationGPUTop &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    WetDryProlongationGPUBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n}\ntemplate void WetDryProlongationGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, double* zb);\ntemplate void WetDryProlongationGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, float* zb);\n\ntemplate &lt;class T&gt; void WetDryRestrictionGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    dim3 blockDimHaloLR(1, 16, 1);\n    dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    //WetDryProlongationGPUBot\n\n    WetDryRestrictionGPULeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    WetDryRestrictionGPURight &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    WetDryRestrictionGPUTop &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    WetDryRestrictionGPUBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n}\ntemplate void WetDryRestrictionGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, double* zb);\ntemplate void WetDryRestrictionGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, float* zb);\n\ntemplate &lt;class T&gt; __host__ __device__ void ProlongationElevation(int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo,  int ip, int jp, T* h, T* zs, T* zb)\n{\n    int  halo;\n    //pp = memloc(halowidth, blkmemwidth, ip, jp, ibn);\n    //ll = memloc(halowidth, blkmemwidth, il, jl, ib);\n    //mm = memloc(halowidth, blkmemwidth, im, jm, ibn);\n\n    halo = memloc(halowidth, blkmemwidth, ihalo, jhalo, ib);\n    //Check if parent is dry or any of close neighbour\n    int ii, left, right, top, bot;\n    ii = memloc(halowidth, blkmemwidth, ip, jp, ibn);\n    left = memloc(halowidth, blkmemwidth, ip - 1, jp, ibn);\n    right = memloc(halowidth, blkmemwidth, ip + 1, jp, ibn);\n    top = memloc(halowidth, blkmemwidth, ip, jp + 1, ibn);\n    bot = memloc(halowidth, blkmemwidth, ip, jp - 1, ibn);\n\n\n    //if (!(h[ll] &gt; eps &amp;&amp; h[halo]&gt;eps &amp;&amp; h[pp] &gt; eps &amp;&amp; h[mm] &gt; eps))\n    if (!(h[ii] &gt; eps &amp;&amp; h[left] &gt; eps &amp;&amp; h[right] &gt; eps &amp;&amp; h[top] &gt; eps &amp;&amp; h[bot] &gt; eps))\n    {\n\n        //h[halo] = utils::max(T(0.0), zs[pp] - zb[halo]);\n        //zs[halo] = h[halo] + zb[halo];\n        h[halo] = h[ii];\n        zb[halo] = zb[ii];\n        zs[halo] = zs[ii];\n\n    }\n\n\n\n}\n\n\ntemplate &lt;class T&gt; __host__ __device__ void RevertProlongationElevation(int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, int level, T dx, T* h, T* zb, T* dzbdx, T* dzbdy)\n{\n    int  halo;\n    //pp = memloc(halowidth, blkmemwidth, ip, jp, ibn);\n    //ll = memloc(halowidth, blkmemwidth, il, jl, ib);\n    //mm = memloc(halowidth, blkmemwidth, im, jm, ibn);\n\n    halo = memloc(halowidth, blkmemwidth, ihalo, jhalo, ib);\n    //Check if parent is dry or any of close neighbour\n    int ii, left, right, top, bot;\n    ii = memloc(halowidth, blkmemwidth, ip, jp, ibn);\n    left = memloc(halowidth, blkmemwidth, ip - 1, jp, ibn);\n    right = memloc(halowidth, blkmemwidth, ip + 1, jp, ibn);\n    top = memloc(halowidth, blkmemwidth, ip, jp + 1, ibn);\n    bot = memloc(halowidth, blkmemwidth, ip, jp - 1, ibn);\n\n    T ilevdx = calcres(dx, level) * T(0.5);\n\n    T facbt, faclr;\n\n    //if (!(h[ll] &gt; eps &amp;&amp; h[halo]&gt;eps &amp;&amp; h[pp] &gt; eps &amp;&amp; h[mm] &gt; eps))\n    if (!(h[ii] &gt; eps &amp;&amp; h[left] &gt; eps &amp;&amp; h[right] &gt; eps &amp;&amp; h[top] &gt; eps &amp;&amp; h[bot] &gt; eps))\n    {\n        if (ihalo == -1)\n        {\n            faclr = 1.0;\n            facbt = floor(jhalo * (T)0.5) * T(2.0) &lt; (jhalo - T(0.01)) ? 1.0 : -1.0;\n        }\n        else if (ihalo == 16)\n        {\n            faclr = -1.0;\n            facbt = floor(jhalo * (T)0.5) * T(2.0) &lt; (jhalo - T(0.01)) ? 1.0 : -1.0;\n        }\n        if (jhalo == -1)\n        {\n            facbt = 1.0;\n            facbt = floor(ihalo * (T)0.5) * T(2.0) &lt; (ihalo - T(0.01)) ? 1.0 : -1.0;\n        }\n        else if (jhalo == 16)\n        {\n            facbt = -1.0;\n            facbt = floor(ihalo * (T)0.5) * T(2.0) &lt; (ihalo - T(0.01)) ? 1.0 : -1.0;\n        }\n\n        //h[halo] = utils::max(T(0.0), zs[pp] - zb[halo]);\n        //zs[halo] = h[halo] + zb[halo];\n\n        zb[halo] = zb[ii] + (faclr * dzbdx[ii] + facbt * dzbdy[ii]) * ilevdx;\n\n\n    }\n\n\n\n}\n\ntemplate &lt;class T&gt; __host__ __device__ void ProlongationElevationGH(int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, T* h, T* dhdx, T* dzsdx)\n{\n    int halo;\n    //pp = memloc(halowidth, blkmemwidth, ip, jp, ibn);\n    //ll = memloc(halowidth, blkmemwidth, il, jl, ib);\n    //mm = memloc(halowidth, blkmemwidth, im, jm, ibn);\n\n    halo = memloc(halowidth, blkmemwidth, ihalo, jhalo, ib);\n    //Check if parent is dry or any of close neighbour\n\n    int ii, left, right, top, bot;\n    ii = memloc(halowidth, blkmemwidth, ip, jp, ibn);\n    left = memloc(halowidth, blkmemwidth, ip - 1, jp, ibn);\n    right = memloc(halowidth, blkmemwidth, ip + 1, jp, ibn);\n    top = memloc(halowidth, blkmemwidth, ip, jp + 1, ibn);\n    bot = memloc(halowidth, blkmemwidth, ip, jp - 1, ibn);\n\n    //if (!(h[ll] &gt; eps &amp;&amp; h[halo] &gt; eps &amp;&amp; h[pp] &gt; eps &amp;&amp; h[mm] &gt; eps))\n    if (!(h[ii] &gt; eps &amp;&amp; h[left] &gt; eps &amp;&amp; h[right] &gt; eps &amp;&amp; h[top] &gt; eps &amp;&amp; h[bot] &gt; eps))\n    {\n\n        dhdx[halo] = T(0.0);\n        dzsdx[halo] = T(0.0);\n    }\n\n\n\n}\n\ntemplate &lt;class T&gt; __host__ __device__ void conserveElevation(int halowidth,int blkmemwidth,T eps, int ib, int ibn,int ihalo, int jhalo ,int i,int j, T* h, T* zs, T * zb)\n{\n    int ii, ir, it, itr;\n    T iiwet, irwet, itwet, itrwet;\n    T zswet, hwet;\n\n    int write;\n\n    write = memloc(halowidth, blkmemwidth, ihalo, jhalo, ib);\n\n    ii = memloc(halowidth, blkmemwidth, i, j, ibn);\n    ir = memloc(halowidth, blkmemwidth, i + 1, j, ibn);\n    it = memloc(halowidth, blkmemwidth, i, j + 1, ibn);\n    itr = memloc(halowidth, blkmemwidth, i + 1, j + 1, ibn);\n\n    iiwet = h[ii] &gt; eps ? h[ii] : T(0.0);\n    irwet = h[ir] &gt; eps ? h[ir] : T(0.0);\n    itwet = h[it] &gt; eps ? h[it] : T(0.0);\n    itrwet = h[itr] &gt; eps ? h[itr] : T(0.0);\n\n    hwet = (iiwet + irwet + itwet + itrwet);\n    zswet = iiwet * (zb[ii] + h[ii]) + irwet * (zb[ir] + h[ir]) + itwet * (zb[it] + h[it]) + itrwet * (zb[itr] + h[itr]);\n\n    //conserveElevation(zb[write], zswet, hwet);\n    if (hwet &gt; T(0.0))\n    {\n        zswet = zswet / hwet;\n        hwet = utils::max(T(0.0), zswet - zb[write]);\n\n    }\n    else\n    {\n        hwet = T(0.0);\n\n    }\n\n    //zswet = hwet + zb;\n\n    h[write] = hwet;\n    zs[write] = hwet + zb[write];\n\n\n}\ntemplate __host__ __device__ void conserveElevation&lt;float&gt;(int halowidth, int blkmemwidth, float eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, float* h, float* zs, float* zb);\ntemplate __host__ __device__ void conserveElevation&lt;double&gt;(int halowidth, int blkmemwidth, double eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, double* h, double* zs, double* zb);\n\ntemplate &lt;class T&gt; __host__ __device__ void wetdryrestriction(int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, T* h, T* zs, T* zb)\n{\n    int ii, ir, it, itr;\n    T iiwet, irwet, itwet, itrwet;\n    T zswet, hwet, cwet, zbw;\n\n    int write;\n\n    write = memloc(halowidth, blkmemwidth, ihalo, jhalo, ib);\n\n    ii = memloc(halowidth, blkmemwidth, i, j, ibn);\n    ir = memloc(halowidth, blkmemwidth, i + 1, j, ibn);\n    it = memloc(halowidth, blkmemwidth, i, j + 1, ibn);\n    itr = memloc(halowidth, blkmemwidth, i + 1, j + 1, ibn);\n\n    T hii, hir, hit, hitr;\n\n    hii = h[ii];\n    hir = h[ir];\n    hit = h[it];\n    hitr = h[itr];\n\n    zbw = zb[write];\n\n    iiwet = hii &gt; eps ? T(1.0) : T(0.0);\n    irwet = hir &gt; eps ? T(1.0) : T(0.0);\n    itwet = hit &gt; eps ? T(1.0) : T(0.0);\n    itrwet = hitr &gt; eps ? T(1.0) : T(0.0);\n\n    cwet = (iiwet + irwet + itwet + itrwet);\n    hwet = (iiwet*hii + irwet*hir + itwet*hit + itrwet*hitr);\n    zswet = (iiwet*hii) * (zb[ii] + h[ii]) + (irwet*hir) * (zb[ir] + h[ir]) + (itwet*hit) * (zb[it] + h[it]) + (itrwet * hitr) * (zb[itr] + h[itr]);\n\n    //conserveElevation(zb[write], zswet, hwet);\n    if (cwet &gt; T(0.0) &amp;&amp; cwet &lt; T(4.0))\n    {\n        zswet = zswet / hwet;\n        hwet = utils::max(T(0.0), zswet - zbw);\n\n\n        h[write] = hwet;\n        //zs[write] = hwet + zbw;\n\n    }\n\n\n    //zswet = hwet + zb;\n\n\n\n}\ntemplate __host__ __device__ void wetdryrestriction&lt;float&gt;(int halowidth, int blkmemwidth, float eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, float* h, float* zs, float* zb);\ntemplate __host__ __device__ void wetdryrestriction&lt;double&gt;(int halowidth, int blkmemwidth, double eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, double* h, double* zs, double* zb);\n\n\n\n\ntemplate &lt;class T&gt; __host__ __device__ void conserveElevation(T zb, T&amp; zswet, T&amp; hwet)\n{\n\n    if (hwet &gt; 0.0)\n    {\n        zswet = zswet / hwet;\n        hwet = utils::max(T(0.0), zswet - zb);\n\n    }\n    else\n    {\n        hwet = T(0.0);\n\n    }\n\n    zswet = hwet + zb;\n}\n\ntemplate &lt;class T&gt; void conserveElevationGradHalo(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx, T* dhdy, T* dzsdy)\n{\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        conserveElevationGHLeft(XParam, ib, XBlock.LeftBot[ib], XBlock.LeftTop[ib], XBlock, h, zs, zb, dhdx, dzsdx);\n        conserveElevationGHRight(XParam, ib, XBlock.RightBot[ib], XBlock.RightTop[ib], XBlock, h, zs, zb, dhdx, dzsdx);\n        conserveElevationGHTop(XParam, ib, XBlock.TopLeft[ib], XBlock.TopRight[ib], XBlock, h, zs, zb, dhdy, dzsdy);\n        conserveElevationGHBot(XParam, ib, XBlock.BotLeft[ib], XBlock.BotRight[ib], XBlock, h, zs, zb, dhdy, dzsdy);\n    }\n}\ntemplate void conserveElevationGradHalo&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* h, float* zs, float* zb, float* dhdx, float* dzsdx, float* dhdy, float* dzsdy);\ntemplate void conserveElevationGradHalo&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* h, double* zs, double* zb, double* dhdx, double* dzsdx, double* dhdy, double* dzsdy);\n\ntemplate &lt;class T&gt; void conserveElevationGradHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx, T* dhdy, T* dzsdy)\n{\n    dim3 blockDimHaloLR(1, 16, 1);\n    dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    conserveElevationGHLeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, h, zs, zb, dhdx, dzsdx);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    conserveElevationGHRight &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, h, zs, zb, dhdx, dzsdx);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    conserveElevationGHTop &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, h, zs, zb, dhdy, dzsdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    conserveElevationGHBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, h, zs, zb, dhdy, dzsdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n}\ntemplate void conserveElevationGradHaloGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* h, float* zs, float* zb, float* dhdx, float* dzsdx, float* dhdy, float* dzsdy);\ntemplate void conserveElevationGradHaloGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* h, double* zs, double* zb, double* dhdx, double* dzsdx, double* dhdy, double* dzsdy);\n\ntemplate &lt;class T&gt; __host__ __device__ void conserveElevationGradHalo(int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo,int i, int j, T* h, T* dhdx, T* dhdy)\n{\n    int ii, ir, it, itr, jj;\n    int write;\n    write = memloc(halowidth, blkmemwidth, ihalo, jhalo, ib);\n\n    ii = memloc(halowidth, blkmemwidth, i, j, ibn);\n    ir = memloc(halowidth, blkmemwidth, i + 1, j, ibn);\n    it = memloc(halowidth, blkmemwidth, i, j + 1, ibn);\n    itr = memloc(halowidth, blkmemwidth, i + 1, j + 1, ibn);\n\n    if (h[write] &lt;= eps)\n    {\n        // Because of the slope limiter the average slope is not the slope of the averaged values\n        // It seems that it should be the closest to zero instead... With conserve elevation This will work but maybe all prolongation need to be applied this way (?)\n        dhdy[write] = utils::nearest(utils::nearest(utils::nearest(dhdy[ii], dhdy[ir]), dhdy[it]), dhdy[itr]);\n        dhdx[write] = utils::nearest(utils::nearest(utils::nearest(dhdx[ii], dhdx[ir]), dhdx[it]), dhdx[itr]);\n    }\n}\n\n\ntemplate &lt;class T&gt; __host__ __device__ void conserveElevationGradHaloA(int halowidth, int blkmemwidth, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, int iq, int jq, T theta, T delta, T* h, T* dhdx)\n{\n    //int pii, pir, pit, pitr;\n    int qii, qir, qit, qitr;\n\n    T p, q;\n    T s0, s1, s2;\n\n    int write, pii;\n    write = memloc(halowidth, blkmemwidth, ihalo, jhalo, ib);\n    pii = memloc(halowidth, blkmemwidth, ip, jp, ib);\n\n\n\n\n    //pii = memloc(halowidth, blkmemwidth, ip, jp, ibn);\n    //pir = memloc(halowidth, blkmemwidth, ip + 1, jp, ibn);\n    //pit = memloc(halowidth, blkmemwidth, ip, jp + 1, ibn);\n    //pitr = memloc(halowidth, blkmemwidth, ip + 1, jp + 1, ibn);\n\n    qii = memloc(halowidth, blkmemwidth, iq, jq, ibn);\n    qir = memloc(halowidth, blkmemwidth, iq + 1, jq, ibn);\n    qit = memloc(halowidth, blkmemwidth, iq, jq + 1, ibn);\n    qitr = memloc(halowidth, blkmemwidth, iq + 1, jq + 1, ibn);\n\n    s1 = h[write];\n    p = h[pii];\n    q = T(0.25) * (h[qii] + h[qir] + h[qit] + h[qitr]);\n\n\n\n    if (ip &gt; ihalo || jp &gt; jhalo)\n    {\n        s0 = q;\n        s2 = p;\n    }\n    else\n    {\n        s2 = q;\n        s0 = p;\n    }\n\n    dhdx[write] = minmod2(theta, s0, s1, s2) / delta;\n    //dhdx[write] = utils::nearest(utils::nearest(utils::nearest(dhdx[ii], dhdx[ir]), dhdx[it]), dhdx[itr]);\n\n}\n\ntemplate &lt;class T&gt; __host__ __device__ void conserveElevationGradHaloB(int halowidth, int blkmemwidth, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, int iq, int jq, T theta, T delta, T eps, T* h, T* zs, T* zb, T* dhdx, T* dzsdx)\n{\n    //int pii, pir, pit, pitr;\n    int qii, qir, qit, qitr;\n\n    T hp, hq,zsp,zsq, zbq;\n    T hs0, hs1, hs2,zss0, zss1, zss2;\n\n    T hwet, zswet;\n    int write, pii;\n    T iiwet, irwet, itwet, itrwet;\n    write = memloc(halowidth, blkmemwidth, ihalo, jhalo, ib);\n    pii = memloc(halowidth, blkmemwidth, ip, jp, ib);\n\n    //pii = memloc(halowidth, blkmemwidth, ip, jp, ibn);\n    //pir = memloc(halowidth, blkmemwidth, ip + 1, jp, ibn);\n    //pit = memloc(halowidth, blkmemwidth, ip, jp + 1, ibn);\n    //pitr = memloc(halowidth, blkmemwidth, ip + 1, jp + 1, ibn);\n\n    qii = memloc(halowidth, blkmemwidth, iq, jq, ibn);\n    qir = memloc(halowidth, blkmemwidth, iq + 1, jq, ibn);\n    qit = memloc(halowidth, blkmemwidth, iq, jq + 1, ibn);\n    qitr = memloc(halowidth, blkmemwidth, iq + 1, jq + 1, ibn);\n\n\n\n\n    zbq = T(0.25) * (zb[qii] + zb[qir] + zb[qit] + zb[qitr]);\n\n    iiwet = h[qii] &gt; eps ? h[qii] : T(0.0);\n    irwet = h[qir] &gt; eps ? h[qir] : T(0.0);\n    itwet = h[qit] &gt; eps ? h[qit] : T(0.0);\n    itrwet = h[qitr] &gt; eps ? h[qitr] : T(0.0);\n\n    hwet = T(iiwet + irwet + itwet + itrwet);\n    zswet = iiwet * (zb[qii] + h[qii]) + irwet * (zb[qir] + h[qir]) + itwet * (zb[qit] + h[qit]) + itrwet * (zb[qitr] + h[qitr]);\n\n    if (hwet &gt; T(0.0))\n    {\n        zswet = zswet / hwet;\n        hq = utils::max(T(0.0), zswet - zbq);\n\n    }\n    else\n    {\n        hq = T(0.0);\n    }\n\n    hs1 = h[write];\n    zss1= zs[write];\n    hp = h[pii];\n    zsp = zs[pii];\n    zsq = hq + zbq;\n\n    if (ip &gt; ihalo || jp &gt; jhalo )\n    {\n        hs0 = hq;\n        hs2 = hp;\n        zss0 = zsq;\n        zss2 = zsp;\n    }\n    else\n    {\n        hs2 = hq;\n        hs0 = hp;\n        zss2 = zsq;\n        zss0 = zsp;\n    }\n\n    dhdx[write] = minmod2(theta,hs0,hs1,hs2)/ delta;\n    dzsdx[write] = minmod2(theta, zss0, zss1, zss2) / delta;\n    //dhdx[write] = utils::nearest(utils::nearest(utils::nearest(dhdx[ii], dhdx[ir]), dhdx[it]), dhdx[itr]);\n\n}\n\ntemplate &lt;class T&gt; void conserveElevationGHLeft(Param XParam, int ib, int ibLB, int ibLT, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx)\n{\n    int ibn;\n    int ihalo, jhalo, ip, jp, iq, jq;\n    T delta = calcres(T(XParam.delta), XBlock.level[ib]);\n    ihalo = -1;\n    ip = 0;\n\n\n    if (XBlock.level[ib] &lt; XBlock.level[ibLB])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n            jhalo = j;\n            jp = j;\n            iq = XParam.blkwidth - 4;\n            jq = j * 2;\n            ibn = ibLB;\n            conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n            //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n            //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibLB,  -1, j, XParam.blkwidth - 2, j * 2, h, dhdx, dhdy);\n        }\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[ibLT])\n    {\n        for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n        {\n            jhalo = j;\n            jp = j;\n            iq = XParam.blkwidth - 4;\n            jq = (j - (XParam.blkwidth / 2)) * 2;\n            ibn = ibLT;\n\n            conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n            //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n\n            //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibLT, -1, j, XParam.blkwidth - 2, (j - (XParam.blkwidth / 2)) * 2, h, dhdx, dhdy);\n        }\n    }\n\n    // Prolongation part\n    //int il, jl, im, jm;\n    ihalo = -1;\n\n    if (XBlock.level[ib] &gt; XBlock.level[ibLB])\n    {\n        //\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n            jhalo = j;\n            ibn = ibLB;\n\n            //il = 0;\n            //jl = j;\n\n            ip = XParam.blkwidth - 1;\n            jp = XBlock.RightBot[ibLB] == ib ? ftoi(floor(j / 2)) : ftoi(floor(j / 2) + XParam.blkwidth / 2);\n\n            //im = ip;\n            //jm = ceil(j * T(0.5)) * 2 &gt; j ? jp + 1 : jp - 1;\n\n            ProlongationElevationGH(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, h, dhdx, dzsdx);\n        }\n\n    }\n\n\n\n}\n\ntemplate &lt;class T&gt; __global__ void conserveElevationGHLeft(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T*zs, T*zb, T* dhdx, T* dzsdx)\n{\n\n\n\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int LB = XBlock.LeftBot[ib];\n    int LT = XBlock.LeftTop[ib];\n\n    int ip, jp, iq, jq;\n\n    int ihalo, jhalo, ibn;\n    T delta = calcres(XParam.delta, lev);\n\n\n    ihalo = -1;\n    jhalo = iy;\n    iq = XParam.blkwidth - 4;\n    ip = 0;\n    jp = iy;\n    if (lev &lt; XBlock.level[LB] &amp;&amp; iy &lt; (blockDim.y / 2))\n    {\n        ibn = LB;\n        jq = iy * 2;\n        conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n        //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n\n        //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, h, dhdx, dhdy);\n    }\n    if (lev &lt; XBlock.level[LT] &amp;&amp; iy &gt;= (blockDim.y / 2))\n    {\n        ibn = LT;\n        jq = (iy - (blockDim.y / 2)) * 2;\n        conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n        //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, h, dhdx, dhdy);\n        //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n    }\n\n    // Prolongation part\n    //int il, jl, im, jm;\n\n\n    if (XBlock.level[ib] &gt; XBlock.level[LB])\n    {\n        //\n        //\n\n        ibn = LB;\n\n        //il = 0;\n        //jl = iy;\n\n        ip = blockDim.y - 1;\n        jp = XBlock.RightBot[LB] == ib ? int(floor(iy *T(0.5))) : int((floor(iy * T(0.5)) + blockDim.y / 2));\n        //im = ip;\n        //jm = ceil(iy * T(0.5)) * 2 &gt; iy ? jp + 1 : jp - 1;\n\n        ProlongationElevationGH(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, h, dhdx, dzsdx);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; void conserveElevationGHRight(Param XParam, int ib, int ibRB, int ibRT, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx)\n{\n    int ibn;\n    int ihalo, jhalo, ip, jp, iq, jq;\n    T delta = calcres(T(XParam.delta), XBlock.level[ib]);\n    ihalo = XParam.blkwidth;\n    ip = XParam.blkwidth-1;\n\n    if (XBlock.level[ib] &lt; XBlock.level[ibRB])\n    {\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n            jhalo = j;\n            jp = j;\n            iq = 2;\n            jq = j * 2;\n            ibn = ibRB;\n            conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n            //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n            //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibRB, XParam.blkwidth, j, 0, j * 2, h, dhdx, dhdy);\n        }\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[ibRT])\n    {\n        for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n        {\n            jhalo = j;\n            jp = j;\n            iq = 2;\n            jq = (j - (XParam.blkwidth / 2)) * 2;\n            ibn = ibRT;\n            conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n            //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n\n            //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibRT, XParam.blkwidth, j, 0, (j - (XParam.blkwidth / 2)) * 2, h, dhdx, dhdy);\n        }\n    }\n\n    // Prolongation part\n    //int il, jl, im, jm;\n\n\n    if (XBlock.level[ib] &gt; XBlock.level[ibRB])\n    {\n        //\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n            jhalo = j;\n            ibn = ibRB;\n\n            //il = XParam.blkwidth-2;\n            //jl = j;\n\n            ip = 0;\n            jp = XBlock.LeftBot[ibRB] == ib ? ftoi(floor(j / 2)) : ftoi(floor(j / 2) + XParam.blkwidth / 2);\n            //im = ip;\n            //jm = ceil(j * T(0.5)) * 2 &gt; j ? jp + 1 : jp - 1;\n\n            ProlongationElevationGH(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, h, dhdx, dzsdx);\n        }\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void conserveElevationGHRight(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T*zs, T*zb, T* dhdx, T* dzsdx)\n{\n\n\n\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int RB = XBlock.RightBot[ib];\n    int RT = XBlock.RightTop[ib];\n\n\n\n    int ihalo, jhalo, iq, jq, ip, jp, ibn;\n\n    T delta = calcres(XParam.delta, lev);\n\n    ihalo = blockDim.y;\n    jhalo = iy;\n    iq = blockDim.y - 4;\n    ip = blockDim.y-1;\n    jp = iy;\n\n    if (XBlock.level[ib] &lt; XBlock.level[RB] &amp;&amp; iy &lt; (blockDim.y / 2))\n    {\n        ibn = RB;\n        jq = iy * 2;\n        conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n        //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n\n        //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, h, dhdx, dhdy);\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[RT] &amp;&amp; iy &gt;= (blockDim.y / 2))\n    {\n        ibn = RT;\n        jq = (iy - (XParam.blkwidth / 2)) * 2;\n        conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n        //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n        //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, h, dhdx, dhdy);\n    }\n\n    // Prolongation part\n    //int il, jl, im, jm;\n\n\n    if (XBlock.level[ib] &gt; XBlock.level[RB])\n    {\n        //\n\n        //\n        jhalo = iy;\n        ibn = RB;\n\n        //il = blockDim.y - 2;\n        //jl = iy;\n\n        ip = 0;\n        jp = XBlock.LeftBot[RB] == ib ? int(floor(iy * T(0.5))) : int((floor(iy *T (0.5)) + blockDim.y / 2));\n\n        //im = ip;\n        //jm = ceil(iy * T(0.5)) * 2 &gt; iy ? jp + 1 : jp - 1;\n\n        ProlongationElevationGH(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, h, dhdx, dzsdx);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; void conserveElevationGHTop(Param XParam, int ib, int ibTL, int ibTR, BlockP&lt;T&gt; XBlock, T* h, T*zs, T*zb, T* dhdx, T* dzsdx)\n{\n    int ibn;\n    int ihalo, jhalo, ip, jp, iq, jq;\n    T delta = calcres(T(XParam.delta), XBlock.level[ib]);\n    jhalo = XParam.blkwidth;\n    jp = XParam.blkwidth - 1;\n\n    if (XBlock.level[ib] &lt; XBlock.level[ibTL])\n    {\n        for (int i = 0; i &lt; XParam.blkwidth / 2; i++)\n        {\n            ihalo = i;\n            ip = i;\n            jq = 2;\n            iq = i * 2;\n            ibn = ibTL;\n            conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n            //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibTL, i, XParam.blkwidth, i * 2, 0, h, dhdx, dhdy);\n        }\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[ibTR])\n    {\n        for (int i = (XParam.blkwidth / 2); i &lt; (XParam.blkwidth); i++)\n        {\n            ihalo = i;\n            ip = i;\n            jq = 2;\n            iq = (i - (XParam.blkwidth / 2)) * 2;\n            ibn = ibTR;\n            conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n            //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n\n            //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibTR, i, XParam.blkwidth, (i - (XParam.blkwidth / 2)) * 2, 0, h, dhdx, dhdy);\n        }\n    }\n\n    // Prolongation part\n    //int il, jl, im, jm;\n\n\n    if (XBlock.level[ib] &gt; XBlock.level[ibTL])\n    {\n        //\n        for (int i = 0; i &lt; XParam.blkwidth; i++)\n        {\n            //\n            ihalo = i;\n            ibn = ibTL;\n\n            //jl = XParam.blkwidth - 2;\n            //il = i;\n\n            jp = 0;\n            ip = XBlock.BotLeft[ibTL] == ib ? ftoi(floor(i / 2)) : ftoi(floor(i / 2) + XParam.blkwidth / 2);\n            //jm = jp;\n            //im = ceil(i * T(0.5)) * 2 &gt; i ? ip + 1 : ip - 1;\n\n            ProlongationElevationGH(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, h, dhdx, dzsdx);\n        }\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void conserveElevationGHTop(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T*zs, T*zb, T* dhdx, T* dzsdx)\n{\n\n\n    unsigned int iy = blockDim.x - 1;\n    unsigned int ix = threadIdx.x;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int TL = XBlock.TopLeft[ib];\n    int TR = XBlock.TopRight[ib];\n\n\n\n    int ihalo, jhalo, iq, jq, ip, jp, ibn;\n    T delta = calcres(XParam.delta, lev);\n\n    ihalo = ix;\n    jhalo = iy+1;\n    jp = iy;\n    ip = ix;\n    jq = 2;\n\n    if (XBlock.level[ib] &lt; XBlock.level[TL] &amp;&amp; ix &lt; (blockDim.x / 2))\n    {\n        ibn = TL;\n        iq = ix * 2;\n        conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n        //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n\n        //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, h, dhdx, dhdy);\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[TR] &amp;&amp; ix &gt;= (blockDim.x / 2))\n    {\n        ibn = TR;\n        iq = (ix - (blockDim.x / 2)) * 2;;\n        conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n        //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n        //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, h, dhdx, dhdy);\n    }\n\n    // Prolongation part\n    //int il, jl, im, jm;\n\n\n    if (XBlock.level[ib] &gt; XBlock.level[TL])\n    {\n        //\n        //\n        //ihalo = i;\n        ibn = TL;\n\n        //jl = blockDim.x - 2;\n        //il = ix;\n\n        jp = 0;\n        ip = XBlock.BotLeft[TL] == ib ? int(floor(ix *T(0.0))) : int((floor(ix * T(0.0)) + blockDim.x / 2));\n        //jm = jp;\n        //im = ceil(ix * T(0.5)) * 2 &gt; ix ? ip + 1 : ip - 1;\n\n        ProlongationElevationGH(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, h, dhdx, dzsdx);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; void conserveElevationGHBot(Param XParam, int ib, int ibBL, int ibBR, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx)\n{\n    int ibn;\n    int ihalo, jhalo, ip, jp, iq, jq;\n    T delta = calcres(T(XParam.delta), XBlock.level[ib]);\n    jhalo = -1;\n    jp = 0;\n\n    if (XBlock.level[ib] &lt; XBlock.level[ibBL])\n    {\n        for (int i = 0; i &lt; XParam.blkwidth / 2; i++)\n        {\n            ihalo = i;\n            ip = i;\n            iq = i * 2;\n            jq = XParam.blkwidth - 4;\n            ibn = ibBL;\n            conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n            //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n\n            //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibBL, i, -1, i * 2, XParam.blkwidth - 2, h, dhdx, dhdy);\n        }\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[ibBR])\n    {\n        for (int i = (XParam.blkwidth / 2); i &lt; (XParam.blkwidth); i++)\n        {\n            ihalo = i;\n            ip = i;\n            iq = (i - (XParam.blkwidth / 2)) * 2;;\n            jq = XParam.blkwidth - 4;\n            ibn = ibBR;\n            conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n            //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n\n            //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibBR, i, -1, (i - (XParam.blkwidth / 2)) * 2, XParam.blkwidth - 2, h, dhdx, dhdy);\n        }\n    }\n    // Prolongation part\n    //int il, jl, im, jm;\n\n\n    if (XBlock.level[ib] &gt; XBlock.level[ibBL])\n    {\n        //\n        for (int i = 0; i &lt; XParam.blkwidth; i++)\n        {\n            //\n            ihalo = i;\n            ibn = ibBL;\n\n            //jl = 0;\n            //il = i;\n\n            jp = XParam.blkwidth - 1;\n            ip = XBlock.TopLeft[ibBL] == ib ? ftoi(floor(i / 2)) : ftoi(floor(i / 2) + XParam.blkwidth / 2);\n            //jm = jp;\n            //im = ceil(i * T(0.5)) * 2 &gt; i ? ip + 1 : ip - 1;\n\n            ProlongationElevationGH(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, h, dhdx, dzsdx);\n        }\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void conserveElevationGHBot(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx)\n{\n\n\n\n    unsigned int ix = threadIdx.x;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int BL = XBlock.BotLeft[ib];\n    int BR = XBlock.BotRight[ib];\n\n    int ip, jp, iq, jq;\n\n    int ihalo, jhalo, ibn;\n    T delta = calcres(XParam.delta, lev);\n\n    ihalo = ix;\n    jhalo = -1;\n    jq = XParam.blkwidth - 4;\n    jp = 0;\n    ip = ix;\n\n    if (XBlock.level[ib] &lt; XBlock.level[BL] &amp;&amp; ix &lt; (blockDim.x / 2))\n    {\n        ibn = BL;\n        iq = ix * 2;\n        conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n        //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n        //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, h, dhdx, dhdy);\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[BR] &amp;&amp; ix &gt;= (blockDim.x / 2))\n    {\n        ibn = BR;\n        iq = (ix - (blockDim.x / 2)) * 2;\n        conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n        //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n        //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, h, dhdx, dhdy);\n    }\n\n    // Prolongation part\n    //int il, jl, im, jm;\n\n\n    if (XBlock.level[ib] &gt; XBlock.level[BL])\n    {\n        //\n\n        ihalo = ix;\n        ibn = BL;\n\n        //jl = 0;\n        //il = ix;\n\n        jp = blockDim.x - 1;\n        ip = XBlock.TopLeft[BL] == ib ? int(floor(ix * T(0.0))) : int((floor(ix * T(0.0)) + blockDim.x / 2));\n\n        //jm = jp;\n        //im = ceil(ix * T(0.5)) * 2 &gt; ix ? ip + 1 : ip - 1;\n\n        ProlongationElevationGH(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, h, dhdx, dzsdx);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; void conserveElevationLeft(Param XParam,int ib, int ibLB, int ibLT, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int ihalo,jhalo,ibn,ip, jp;\n\n    // Restriction\n    ihalo = -1;\n    ip = XParam.blkwidth - 2;\n\n    //int ii = memloc(XParam, -1, 5, 46);\n    if (XBlock.level[ib] &lt; XBlock.level[ibLB])\n    {\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n            jhalo = j;\n            jp = j * 2;\n            ibn = ibLB;\n            conserveElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n        }\n\n    }\n\n    if (XBlock.level[ib] &lt; XBlock.level[ibLT])\n    {\n        for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n        {\n            jhalo = j;\n            jp = (j - (XParam.blkwidth / 2)) * 2;\n            ibn = ibLT;\n            conserveElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n        }\n\n    }\n\n    // Prolongation\n\n    ihalo = -1;\n\n    if (XBlock.level[ib] &gt; XBlock.level[ibLB])\n    {\n        //\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n            jhalo = j;\n            ibn = ibLB;\n\n            //il = 0;\n            //jl = j;\n\n            ip = XParam.blkwidth - 1;\n            jp = XBlock.RightBot[ibLB] == ib ? ftoi(floor(j * T(0.5))) : ftoi(floor(j * T(0.5)) + XParam.blkwidth / 2);\n\n            //im = ip;\n            //jm = ceil(j * T(0.5)) * 2 &gt; j ? jp + 1 : jp - 1;\n\n            ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n        }\n\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void conserveElevationLeft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    unsigned int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n\n\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int LB = XBlock.LeftBot[ib];\n    int LT = XBlock.LeftTop[ib];\n\n\n\n    int ihalo , jhalo, i, j, ibn;\n\n    ihalo = -1;\n    jhalo = iy;\n    i = XParam.blkwidth - 2;\n\n    if (lev &lt; XBlock.level[LB] &amp;&amp; iy &lt; (blockDim.y / 2))\n    {\n        ibn = LB;\n        j = iy * 2;\n\n        conserveElevation(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, XEv.h, XEv.zs, zb);\n    }\n    if (lev &lt; XBlock.level[LT] &amp;&amp; iy &gt;= (blockDim.y / 2))\n    {\n        ibn = LT;\n        j = (iy - (blockDim.y / 2)) * 2;\n\n        conserveElevation(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, XEv.h, XEv.zs, zb);\n    }\n\n    // Prolongation\n    int ip, jp;\n    ihalo = -1;\n\n    if (XBlock.level[ib] &gt; XBlock.level[LB])\n    {\n        //\n\n        jhalo = iy;\n        ibn = LB;\n\n        //il = 0;\n        //jl = iy;\n\n        ip = XParam.blkwidth - 1;\n        jp = XBlock.RightBot[ibn] == ib ? floor(iy * T(0.5)) : (floor(iy * T(0.5)) + blockDim.y / 2);\n\n\n        //im = ip;\n        //jm = ceil(iy * T(0.5)) * 2 &gt; iy ? jp + 1 : jp - 1;\n\n        ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void WetDryProlongationGPULeft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    unsigned int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n\n\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int LB = XBlock.LeftBot[ib];\n    int LT = XBlock.LeftTop[ib];\n\n    int ip, jp, ihalo, jhalo, ibn;\n\n    jhalo = iy;\n    ihalo = -1;\n\n\n    if (lev &gt; XBlock.level[LB])\n    {\n        //\n\n        ibn = LB;\n\n\n        //il = 0;\n        //jl = iy;\n\n        ip = XParam.blkwidth - 1;\n        jp = XBlock.RightBot[ibn] == ib ? floor(iy * T(0.5)) : (floor(iy * T(0.5)) + blockDim.y / 2);\n\n\n        //im = ip;\n        //jm = ceil(iy * T(0.5)) * 2 &gt; iy ? jp + 1 : jp - 1;\n\n        ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void WetDryRestrictionGPULeft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    unsigned int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n\n\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int LB = XBlock.LeftBot[ib];\n    int LT = XBlock.LeftTop[ib];\n\n    int ihalo, jhalo, ibn, ir, jr;\n\n    jhalo = iy;\n    ihalo = -1;\n\n    ir = XParam.blkwidth - 2;\n\n    if (lev &lt; XBlock.level[LB] &amp;&amp; iy &lt; (blockDim.y / 2))\n    {\n        ibn = LB;\n        jr = iy * 2;\n\n        wetdryrestriction(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n    }\n    if (lev &lt; XBlock.level[LT] &amp;&amp; iy &gt;= (blockDim.y / 2))\n    {\n        ibn = LT;\n        jr = (iy - (blockDim.y / 2)) * 2;\n\n        wetdryrestriction(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n    }\n\n\n}\n\n\ntemplate &lt;class T&gt; void conserveElevationRight(Param XParam, int ib, int ibRB, int ibRT, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int ihalo, jhalo, ibn, ip, jp;\n\n    if (XBlock.level[ib] &lt; XBlock.level[ibRB])\n    {\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n            conserveElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibRB, XParam.blkwidth, j, 0, j*2, XEv.h, XEv.zs, zb);\n        }\n\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[ibRT])\n    {\n        for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n        {\n            conserveElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibRT, XParam.blkwidth, j, 0, (j - (XParam.blkwidth / 2)) * 2, XEv.h, XEv.zs, zb);\n        }\n\n    }\n\n    // Prolongation\n\n    ihalo = XParam.blkwidth;\n\n    if (XBlock.level[ib] &gt; XBlock.level[ibRB])\n    {\n        //\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n            jhalo = j;\n            ibn = ibRB;\n\n            //il = XParam.blkwidth-1;\n            //jl = j;\n\n            ip = 0;\n            jp = XBlock.LeftBot[ibn] == ib ? ftoi(floor(j * T(0.5))) : ftoi(floor(j * T(0.5)) + XParam.blkwidth / 2);\n            //im = ip;\n            //jm = ceil(j * T(0.5)) * 2 &gt; j ? jp + 1 : jp - 1;\n\n            ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo,  ip, jp, XEv.h, XEv.zs, zb);\n        }\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void conserveElevationRight(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    unsigned int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n\n\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int RB = XBlock.RightBot[ib];\n    int RT = XBlock.RightTop[ib];\n\n\n\n\n    int ihalo, jhalo, i, j, ibn;\n\n    ihalo = blockDim.y;\n    jhalo = iy;\n\n    i = 0;\n\n    if (lev &lt; XBlock.level[RB] &amp;&amp; iy &lt; (blockDim.y / 2))\n    {\n        ibn = RB;\n        j = iy * 2;\n\n        conserveElevation(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, XEv.h, XEv.zs, zb);\n    }\n    if (lev &lt; XBlock.level[RT] &amp;&amp; iy &gt;= (blockDim.y / 2))\n    {\n        ibn = RT;\n        j = (iy - (blockDim.y / 2)) * 2;\n\n        conserveElevation(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, XEv.h, XEv.zs, zb);\n    }\n\n    // Prolongation\n    int ip, jp;\n    //ihalo = -1;\n\n    if (lev &gt; XBlock.level[RB])\n    {\n        //\n\n        jhalo = iy;\n        ibn = RB;\n\n        //il = blockDim.y - 1;\n        //jl = iy;\n\n        ip = 0;\n        jp = XBlock.LeftBot[ibn] == ib ? floor(iy * T(0.5)) : (floor(iy * T(0.5)) + blockDim.y / 2);\n\n        //im = ip;\n        //jm = ceil(iy * T(0.5)) * 2 &gt; iy ? jp + 1 : jp - 1;\n\n        ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n\n\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void WetDryProlongationGPURight(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n\n\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int RB = XBlock.RightBot[ib];\n    int RT = XBlock.RightTop[ib];\n\n    int ip, jp, ihalo, jhalo, ibn;\n\n    ihalo = blockDim.y;\n    jhalo = iy;\n\n\n    if (lev &gt; XBlock.level[RB])\n    {\n        //\n\n\n        ibn = RB;\n\n        //il = blockDim.y - 1;\n        //jl = iy;\n\n        ip = 0;\n        jp = XBlock.LeftBot[ibn] == ib ? floor(iy * T(0.5)) : (floor(iy * T(0.5)) + blockDim.y / 2);\n\n        //im = ip;\n        //jm = ceil(iy * T(0.5)) * 2 &gt; iy ? jp + 1 : jp - 1;\n\n        ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n\n\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void WetDryRestrictionGPURight(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n\n\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int RB = XBlock.RightBot[ib];\n    int RT = XBlock.RightTop[ib];\n\n    int ihalo, jhalo, ibn, ir, jr;\n\n    ihalo = blockDim.y;\n    jhalo = iy;\n\n    ir = 0;\n\n    if (lev &lt; XBlock.level[RB] &amp;&amp; iy &lt; (blockDim.y / 2))\n    {\n        ibn = RB;\n        jr = iy * 2;\n\n        wetdryrestriction(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n    }\n    if (lev &lt; XBlock.level[RT] &amp;&amp; iy &gt;= (blockDim.y / 2))\n    {\n        ibn = RT;\n        jr = (iy - (blockDim.y / 2)) * 2;\n\n        wetdryrestriction(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n    }\n\n\n\n}\n\ntemplate &lt;class T&gt; void conserveElevationTop(Param XParam, int ib, int ibTL, int ibTR, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int ihalo, jhalo, ibn, ip, jp;\n\n\n\n    if (XBlock.level[ib] &lt; XBlock.level[ibTL])\n    {\n        for (int i = 0; i &lt; XParam.blkwidth / 2; i++)\n        {\n            conserveElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibTL, i, XParam.blkwidth, i*2, 0, XEv.h, XEv.zs, zb);\n        }\n\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[ibTR])\n    {\n        for (int i = (XParam.blkwidth / 2); i &lt; (XParam.blkwidth); i++)\n        {\n            conserveElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibTR, i, XParam.blkwidth, (i - (XParam.blkwidth / 2)) * 2, 0, XEv.h, XEv.zs, zb);\n        }\n\n    }\n\n    // Prolongation\n\n    jhalo = XParam.blkwidth;\n\n    if (XBlock.level[ib] &gt; XBlock.level[ibTL])\n    {\n        //\n        for (int i = 0; i &lt; XParam.blkwidth; i++)\n        {\n            //\n            ihalo = i;\n            ibn = ibTL;\n\n            //il = i;\n            //jl = XParam.blkwidth - 1;\n\n            jp = 0;\n            ip = XBlock.BotLeft[ibn] == ib ? ftoi(floor(i * T(0.5))) : ftoi(floor(i * T(0.5)) + XParam.blkwidth / 2);\n\n            //jm = jp;\n            //im = ceil(i * T(0.5)) * 2 &gt; i ? ip + 1 : ip - 1;\n\n            ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n        }\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void conserveElevationTop(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    unsigned int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n\n\n    unsigned int ix = threadIdx.x;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int TL = XBlock.TopLeft[ib];\n    int TR = XBlock.TopRight[ib];\n\n\n\n    int ihalo, jhalo, i, j, ibn;\n\n    ihalo = ix;\n    jhalo = blockDim.x;\n    j = 0;\n\n    if (lev &lt; XBlock.level[TL] &amp;&amp; ix &lt; (blockDim.x / 2))\n    {\n        ibn = TL;\n\n        i = ix * 2;\n\n        conserveElevation(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, XEv.h, XEv.zs, zb);\n    }\n    if (lev &lt; XBlock.level[TR] &amp;&amp; ix &gt;= (blockDim.x / 2))\n    {\n        ibn = TR;\n        i = (ix - (blockDim.x / 2)) * 2;\n\n        conserveElevation(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, XEv.h, XEv.zs, zb);\n    }\n\n    // Prolongation\n    int ip, jp;\n\n\n    if (lev &gt; XBlock.level[TL])\n    {\n        //\n\n        ihalo = ix;\n        ibn = TL;\n\n        //il = ix;\n        //jl = blockDim.x - 1;\n\n        jp = 0;\n        ip = XBlock.BotLeft[ibn] == ib ? floor(ix * T(0.5)) : (floor(ix * T(0.5)) + blockDim.x / 2);\n\n        //jm = jp;\n        //im = ceil(ix * T(0.5)) * 2 &gt; ix ? ip + 1 : ip - 1;\n\n        ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void WetDryProlongationGPUTop(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n\n\n    int ix = threadIdx.x;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int TL = XBlock.TopLeft[ib];\n    int TR = XBlock.TopRight[ib];\n    // Prolongation\n    int ip, jp,ihalo,jhalo,ibn;\n\n    jhalo = blockDim.x;\n    ihalo = ix;\n\n\n\n    if (lev &gt; XBlock.level[TL])\n    {\n        //\n\n        ibn = TL;\n\n        //il = ix;\n        //jl = blockDim.x - 1;\n\n        jp = 0;\n        ip = XBlock.BotLeft[ibn] == ib ? floor(ix * T(0.5)) : (floor(ix * T(0.5)) + blockDim.x / 2);\n\n        //jm = jp;\n        //im = ceil(ix * T(0.5)) * 2 &gt; ix ? ip + 1 : ip - 1;\n\n        ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void WetDryRestrictionGPUTop(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n\n\n    int ix = threadIdx.x;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int TL = XBlock.TopLeft[ib];\n    int TR = XBlock.TopRight[ib];\n    // Prolongation\n    int ihalo, jhalo, ibn, ir, jr;\n\n    jhalo = blockDim.x;\n    ihalo = ix;\n\n    jr = 0;\n\n    if (lev &lt; XBlock.level[TL] &amp;&amp; ix &lt; (blockDim.x / 2))\n    {\n        ibn = TL;\n\n        ir = ix * 2;\n\n        wetdryrestriction(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n    }\n    if (lev &lt; XBlock.level[TR] &amp;&amp; ix &gt;= (blockDim.x / 2))\n    {\n        ibn = TR;\n        ir = (ix - (blockDim.x / 2)) * 2;\n\n        wetdryrestriction(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n    }\n\n\n\n}\n\ntemplate &lt;class T&gt; void conserveElevationBot(Param XParam, int ib, int ibBL, int ibBR, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int ihalo, jhalo, ibn, ip, jp;\n\n\n\n    if (XBlock.level[ib] &lt; XBlock.level[ibBL])\n    {\n        for (int i = 0; i &lt; XParam.blkwidth / 2; i++)\n        {\n            conserveElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibBL, i,-1, i * 2, XParam.blkwidth-2, XEv.h, XEv.zs, zb);\n        }\n\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[ibBR])\n    {\n        for (int i = (XParam.blkwidth / 2); i &lt; (XParam.blkwidth); i++)\n        {\n            conserveElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibBR, i, -1, (i - (XParam.blkwidth / 2)) * 2, XParam.blkwidth-2, XEv.h, XEv.zs, zb);\n        }\n\n    }\n\n\n    // Prolongation\n\n    jhalo = -1;\n\n    if (XBlock.level[ib] &gt; XBlock.level[ibBL])\n    {\n        //\n        for (int i = 0; i &lt; XParam.blkwidth; i++)\n        {\n            //\n            ihalo = i;\n            ibn = ibBL;\n\n            //il = i;\n            //jl = 0;\n\n            jp = XParam.blkwidth - 1;\n            ip = XBlock.TopLeft[ibn] == ib ? ftoi(floor(i * T(0.5))) : ftoi(floor(i * T(0.5)) + XParam.blkwidth / 2);\n\n            //jm = jp;\n            //im = ceil(i * T(0.5)) * 2 &gt; i ? ip + 1 : ip - 1;\n\n            ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n        }\n\n    }\n}\n\n\ntemplate &lt;class T&gt; __global__ void conserveElevationBot(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    unsigned int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n\n\n    unsigned int ix = threadIdx.x;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int BL = XBlock.BotLeft[ib];\n    int BR = XBlock.BotRight[ib];\n\n\n\n\n    int ihalo, jhalo, ibn;\n    int i, j;\n\n    ihalo = ix;\n    jhalo = -1;\n    j = blockDim.x-2;\n\n    if (lev &lt; XBlock.level[BL] &amp;&amp; ix &lt; (blockDim.x / 2))\n    {\n        ibn = BL;\n\n        i = ix * 2;\n\n        conserveElevation(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, XEv.h, XEv.zs, zb);\n    }\n    if (lev &lt; XBlock.level[BR] &amp;&amp; ix &gt;= (blockDim.x / 2))\n    {\n        ibn = BR;\n        i = (ix - (blockDim.x / 2)) * 2;\n\n        conserveElevation(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, XEv.h, XEv.zs, zb);\n    }\n\n    // Prolongation\n    int ip, jp;\n    //int ip, jp, il, jl, im, jm;\n    //jhalo = -1;\n\n    if (lev &gt; XBlock.level[BL])\n    {\n        //\n\n        ihalo = ix;\n        ibn = BL;\n\n        //il = ix;\n        //jl = 0;\n\n        jp = blockDim.x - 1;\n        ip = XBlock.TopLeft[ibn] == ib ? floor(ix *T(0.5)) : (floor(ix*T(0.5)) + blockDim.x / 2);\n\n        //jm = jp;\n        //im = ceil(ix * T(0.5)) * 2 &gt; ix ? ip + 1 : ip - 1;\n\n        ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp,  XEv.h, XEv.zs, zb);\n\n\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void WetDryProlongationGPUBot(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n\n\n    int ix = threadIdx.x;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int BL = XBlock.BotLeft[ib];\n    int BR = XBlock.BotRight[ib];\n\n\n\n\n    int ihalo, jhalo, ibn;\n\n    // Prolongation\n    int ip, jp;\n    //int ip, jp, il, jl, im, jm;\n    //jhalo = -1;\n    jhalo = -1;\n    ihalo = ix;\n\n\n\n    if (lev &gt; XBlock.level[BL])\n    {\n        //\n\n        ibn = BL;\n\n        //il = ix;\n        //jl = 0;\n\n        jp = blockDim.x - 1;\n        ip = XBlock.TopLeft[ibn] == ib ? floor(ix * T(0.5)) : (floor(ix * T(0.5)) + blockDim.x / 2);\n\n        //jm = jp;\n        //im = ceil(ix * T(0.5)) * 2 &gt; ix ? ip + 1 : ip - 1;\n\n        ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n\n\n    }\n}\n\n\ntemplate &lt;class T&gt; __global__ void WetDryRestrictionGPUBot(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n\n\n    int ix = threadIdx.x;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int BL = XBlock.BotLeft[ib];\n    int BR = XBlock.BotRight[ib];\n\n\n\n\n    int ihalo, jhalo, ibn;\n\n    // Prolongation\n    int ir, jr;\n    //int ip, jp, il, jl, im, jm;\n    //jhalo = -1;\n    jhalo = -1;\n    ihalo = ix;\n    jr = blockDim.x - 2;\n\n    if (lev &lt; XBlock.level[BL] &amp;&amp; ix &lt; (blockDim.x / 2))\n    {\n        ibn = BL;\n\n        ir = ix * 2;\n\n        wetdryrestriction(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n    }\n    if (lev &lt; XBlock.level[BR] &amp;&amp; ix &gt;= (blockDim.x / 2))\n    {\n        ibn = BR;\n        ir = (ix - (blockDim.x / 2)) * 2;\n\n        wetdryrestriction(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n    }\n\n\n}\n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/","title":"File ConserveElevation.h","text":""},{"location":"BGFlood/ConserveElevation_8h/#file-conserveelevationh","title":"File ConserveElevation.h","text":"<p>FileList &gt; src &gt; ConserveElevation.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> </ul>"},{"location":"BGFlood/ConserveElevation_8h/#public-functions","title":"Public Functions","text":"Type Name __host__ __device__ void ProlongationElevation (int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, T * h, T * zs, T * zb)  void WetDryProlongation (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void WetDryProlongationGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryProlongationGPUBot (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryProlongationGPULeft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryProlongationGPURight (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryProlongationGPUTop (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void WetDryRestriction (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void WetDryRestrictionGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryRestrictionGPUBot (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryRestrictionGPULeft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryRestrictionGPURight (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryRestrictionGPUTop (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevation (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevationBot (Param XParam, int ib, int ibBL, int ibBR, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void conserveElevationBot (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevationGHBot (Param XParam, int ib, int ibBL, int ibBR, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  __global__ void conserveElevationGHBot (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGHLeft (Param XParam, int ib, int ibLB, int ibLT, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  __global__ void conserveElevationGHLeft (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGHRight (Param XParam, int ib, int ibRB, int ibRT, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  __global__ void conserveElevationGHRight (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGHTop (Param XParam, int ib, int ibTL, int ibTR, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  __global__ void conserveElevationGHTop (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevationGradHalo (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx, T * dhdy, T * dzsdy)  void conserveElevationGradHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx, T * dhdy, T * dzsdy)  void conserveElevationLeft (Param XParam, int ib, int ibLB, int ibLT, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void conserveElevationLeft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevationRight (Param XParam, int ib, int ibRB, int ibRT, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void conserveElevationRight (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevationTop (Param XParam, int ib, int ibTL, int ibTR, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void conserveElevationTop (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __host__ __device__ void wetdryrestriction (int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, T * h, T * zs, T * zb)"},{"location":"BGFlood/ConserveElevation_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/ConserveElevation_8h/#function-prolongationelevation","title":"function ProlongationElevation","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ void ProlongationElevation (\n    int halowidth,\n    int blkmemwidth,\n    T eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int ip,\n    int jp,\n    T * h,\n    T * zs,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-wetdryprolongation","title":"function WetDryProlongation","text":"<pre><code>template&lt;class T&gt;\nvoid WetDryProlongation (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-wetdryprolongationgpu","title":"function WetDryProlongationGPU","text":"<pre><code>template&lt;class T&gt;\nvoid WetDryProlongationGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-wetdryprolongationgpubot","title":"function WetDryProlongationGPUBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryProlongationGPUBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-wetdryprolongationgpuleft","title":"function WetDryProlongationGPULeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryProlongationGPULeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-wetdryprolongationgpuright","title":"function WetDryProlongationGPURight","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryProlongationGPURight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-wetdryprolongationgputop","title":"function WetDryProlongationGPUTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryProlongationGPUTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-wetdryrestriction","title":"function WetDryRestriction","text":"<pre><code>template&lt;class T&gt;\nvoid WetDryRestriction (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-wetdryrestrictiongpu","title":"function WetDryRestrictionGPU","text":"<pre><code>template&lt;class T&gt;\nvoid WetDryRestrictionGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-wetdryrestrictiongpubot","title":"function WetDryRestrictionGPUBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryRestrictionGPUBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-wetdryrestrictiongpuleft","title":"function WetDryRestrictionGPULeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryRestrictionGPULeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-wetdryrestrictiongpuright","title":"function WetDryRestrictionGPURight","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryRestrictionGPURight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-wetdryrestrictiongputop","title":"function WetDryRestrictionGPUTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryRestrictionGPUTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevation","title":"function conserveElevation","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevation (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationbot","title":"function conserveElevationBot","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationBot (\n    Param XParam,\n    int ib,\n    int ibBL,\n    int ibBR,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationbot_1","title":"function conserveElevationBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationghbot","title":"function conserveElevationGHBot","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGHBot (\n    Param XParam,\n    int ib,\n    int ibBL,\n    int ibBR,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationghbot_1","title":"function conserveElevationGHBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationGHBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationghleft","title":"function conserveElevationGHLeft","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGHLeft (\n    Param XParam,\n    int ib,\n    int ibLB,\n    int ibLT,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationghleft_1","title":"function conserveElevationGHLeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationGHLeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationghright","title":"function conserveElevationGHRight","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGHRight (\n    Param XParam,\n    int ib,\n    int ibRB,\n    int ibRT,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationghright_1","title":"function conserveElevationGHRight","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationGHRight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationghtop","title":"function conserveElevationGHTop","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGHTop (\n    Param XParam,\n    int ib,\n    int ibTL,\n    int ibTR,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationghtop_1","title":"function conserveElevationGHTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationGHTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationgpu","title":"function conserveElevationGPU","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationgradhalo","title":"function conserveElevationGradHalo","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGradHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx,\n    T * dhdy,\n    T * dzsdy\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationgradhalogpu","title":"function conserveElevationGradHaloGPU","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGradHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx,\n    T * dhdy,\n    T * dzsdy\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationleft","title":"function conserveElevationLeft","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationLeft (\n    Param XParam,\n    int ib,\n    int ibLB,\n    int ibLT,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationleft_1","title":"function conserveElevationLeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationLeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationright","title":"function conserveElevationRight","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationRight (\n    Param XParam,\n    int ib,\n    int ibRB,\n    int ibRT,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationright_1","title":"function conserveElevationRight","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationRight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationtop","title":"function conserveElevationTop","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationTop (\n    Param XParam,\n    int ib,\n    int ibTL,\n    int ibTR,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-conserveelevationtop_1","title":"function conserveElevationTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/ConserveElevation_8h/#function-wetdryrestriction_1","title":"function wetdryrestriction","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ void wetdryrestriction (\n    int halowidth,\n    int blkmemwidth,\n    T eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int i,\n    int j,\n    T * h,\n    T * zs,\n    T * zb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/ConserveElevation.h</code></p>"},{"location":"BGFlood/ConserveElevation_8h_source/","title":"File ConserveElevation.h","text":""},{"location":"BGFlood/ConserveElevation_8h_source/#file-conserveelevationh","title":"File ConserveElevation.h","text":"<p>File List &gt; src &gt; ConserveElevation.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef CONSERVEELEVATION_H\n#define CONSERVEELEVATION_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"MemManagement.h\"\n\ntemplate &lt;class T&gt; void conserveElevation(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; void conserveElevationGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\n\n//template &lt;class T&gt; void conserveElevationGradHalo(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* dhdx, T* dhdy);\ntemplate &lt;class T&gt; void conserveElevationGradHalo(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx, T* dhdy, T* dzsdy);\n//template &lt;class T&gt; void conserveElevationGradHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* dhdx, T* dhdy);\ntemplate &lt;class T&gt; void conserveElevationGradHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx, T* dhdy, T* dzsdy);\n\ntemplate &lt;class T&gt; void conserveElevationLeft(Param XParam, int ib, int ibLB, int ibLT, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void conserveElevationLeft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; void conserveElevationRight(Param XParam, int ib, int ibRB, int ibRT, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void conserveElevationRight(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; void conserveElevationTop(Param XParam, int ib, int ibTL, int ibTR, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void conserveElevationTop(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; void conserveElevationBot(Param XParam, int ib, int ibBL, int ibBR, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void conserveElevationBot(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; void conserveElevationGHLeft(Param XParam, int ib, int ibLB, int ibLT, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx);\ntemplate &lt;class T&gt; __global__ void conserveElevationGHLeft(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx);\n\ntemplate &lt;class T&gt; void conserveElevationGHRight(Param XParam, int ib, int ibRB, int ibRT, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx);\ntemplate &lt;class T&gt; __global__ void conserveElevationGHRight(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx);\n\ntemplate &lt;class T&gt; void conserveElevationGHTop(Param XParam, int ib, int ibTL, int ibTR, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx);\ntemplate &lt;class T&gt; __global__ void conserveElevationGHTop(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx);\n\ntemplate &lt;class T&gt; void conserveElevationGHBot(Param XParam, int ib, int ibBL, int ibBR, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx);\ntemplate &lt;class T&gt; __global__ void conserveElevationGHBot(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx);\n\ntemplate &lt;class T&gt; void WetDryProlongationGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; void WetDryProlongation(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; __global__ void WetDryProlongationGPURight(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void WetDryProlongationGPUTop(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void WetDryProlongationGPUBot(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void WetDryProlongationGPULeft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; void WetDryRestrictionGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; void WetDryRestriction(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; __global__ void WetDryRestrictionGPULeft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void WetDryRestrictionGPUTop(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void WetDryRestrictionGPUBot(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void WetDryRestrictionGPURight(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; __host__ __device__ void wetdryrestriction(int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, T* h, T* zs, T* zb);\ntemplate &lt;class T&gt; __host__ __device__ void ProlongationElevation(int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, T* h, T* zs, T* zb);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/FlowCPU_8cu/","title":"File FlowCPU.cu","text":""},{"location":"BGFlood/FlowCPU_8cu/#file-flowcpucu","title":"File FlowCPU.cu","text":"<p>FileList &gt; src &gt; FlowCPU.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"FlowCPU.h\"</code></li> </ul>"},{"location":"BGFlood/FlowCPU_8cu/#public-functions","title":"Public Functions","text":"Type Name void FlowCPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel)  template void FlowCPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; XModel)  template void FlowCPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; XModel)  void HalfStepCPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel)  template void HalfStepCPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; XModel)  template void HalfStepCPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; XModel)"},{"location":"BGFlood/FlowCPU_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/FlowCPU_8cu/#function-flowcpu","title":"function FlowCPU","text":"<pre><code>template&lt;class T&gt;\nvoid FlowCPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/FlowCPU_8cu/#function-flowcpu-double","title":"function FlowCPU&lt; double &gt;","text":"<pre><code>template void FlowCPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/FlowCPU_8cu/#function-flowcpu-float","title":"function FlowCPU&lt; float &gt;","text":"<pre><code>template void FlowCPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/FlowCPU_8cu/#function-halfstepcpu","title":"function HalfStepCPU","text":"<pre><code>template&lt;class T&gt;\nvoid HalfStepCPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Debugging flow step This function was crated to debug the main engine of the model </p>"},{"location":"BGFlood/FlowCPU_8cu/#function-halfstepcpu-double","title":"function HalfStepCPU&lt; double &gt;","text":"<pre><code>template void HalfStepCPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/FlowCPU_8cu/#function-halfstepcpu-float","title":"function HalfStepCPU&lt; float &gt;","text":"<pre><code>template void HalfStepCPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; XModel\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/FlowCPU.cu</code></p>"},{"location":"BGFlood/FlowCPU_8cu_source/","title":"File FlowCPU.cu","text":""},{"location":"BGFlood/FlowCPU_8cu_source/#file-flowcpucu","title":"File FlowCPU.cu","text":"<p>File List &gt; src &gt; FlowCPU.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"FlowCPU.h\"\n\n\ntemplate &lt;class T&gt; void FlowCPU(Param XParam, Loop&lt;T&gt;&amp; XLoop,Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel)\n{\n    //============================================\n    // Predictor step in reimann solver\n    //============================================\n\n\n    if (XParam.atmpforcing)\n    {\n        //Update atm press forcing\n        AddPatmforcingCPU(XParam, XModel.blocks, XForcing.Atmp, XModel);\n\n        //Fill atmp halo\n        fillHaloC(XParam, XModel.blocks, XModel.Patm);\n\n\n        //Calc dpdx and dpdy\n        gradientC(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        gradientHalo(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n        refine_linear(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        gradientHalo(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n\n\n\n    }\n\n    //============================================\n    //  Fill the halo for gradient reconstruction\n    fillHalo(XParam, XModel.blocks, XModel.evolv, XModel.zb);\n\n    //============================================\n    // Reset DTmax\n    InitArrayBUQ(XParam, XModel.blocks, XLoop.hugeposval, XModel.time.dtmax);\n\n    //============================================\n    // Calculate gradient for evolving parameters\n    gradientCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.zb);\n\n    //============================================\n    // Flux and Source term reconstruction\n    // X- direction\n    if (XParam.engine == 1)\n    {\n        // X- direction\n        UpdateButtingerXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n\n        // Y- direction\n        UpdateButtingerYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n    }\n    else if (XParam.engine == 2)\n    {\n        // X- direction\n        updateKurgXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //AddSlopeSourceXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n\n        // Y- direction\n        updateKurgYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //AddSlopeSourceYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n    }\n    else if (XParam.engine == 3)\n    {\n        // X- direction\n        updateKurgXATMCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdx);\n        //AddSlopeSourceXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n\n        // Y- direction\n\n        updateKurgYATMCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdy);\n        //AddSlopeSourceYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n    }\n\n\n    //============================================\n    // Fill Halo for flux from fine to coarse\n    fillHalo(XParam, XModel.blocks, XModel.flux);\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n        FlowbndFlux(XParam, XLoop.totaltime + XLoop.dt * 0.5, XModel.blocks, XForcing.bndseg[iseg], XForcing.Atmp, XModel.evolv, XModel.flux);\n    }\n\n\n    //bndmaskCPU(XParam, XModel.blocks, XModel.evolv, XModel.flux);\n\n    //============================================\n    // Reduce minimum timestep\n    XLoop.dt = double(CalctimestepCPU(XParam,XLoop, XModel.blocks, XModel.time));\n    XLoop.dtmax = XLoop.dt;\n    XModel.time.dt = T(XLoop.dt);\n\n\n    //============================================\n    // Update advection terms (dh dhu dhv) \n    updateEVCPU(XParam, XModel.blocks, XModel.evolv, XModel.flux, XModel.adv);\n\n    //============================================\n    // Add forcing (Rain, Wind)\n    //if (!XForcing.Rain.inputfile.empty())\n    //{\n    //  AddrainforcingCPU(XParam, XModel.blocks, XForcing.Rain, XModel.adv);\n    //}\n    if (!XForcing.UWind.inputfile.empty())//&amp;&amp; !XForcing.UWind.inputfile.empty()\n    {\n        AddwindforcingCPU(XParam, XModel.blocks, XForcing.UWind, XForcing.VWind, XModel.adv);\n    }\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        AddRiverForcing(XParam, XLoop, XForcing.rivers, XModel);\n    }\n\n    //============================================\n    //Update evolving variable by 1/2 time step\n    AdvkernelCPU(XParam, XModel.blocks, XModel.time.dt * T(0.5), XModel.zb, XModel.evolv, XModel.adv, XModel.evolv_o);\n\n\n    //============================================\n    // Corrector step in reimann solver\n    //============================================\n\n    //============================================\n    //  Fill the halo for gradient reconstruction\n    fillHalo(XParam, XModel.blocks, XModel.evolv_o,XModel.zb);\n\n    //============================================\n    // Calculate gradient for evolving parameters\n    gradientCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.zb);\n\n    //============================================\n    // Flux and Source term reconstruction\n    if (XParam.engine == 1)\n    {\n\n        // X- direction\n        UpdateButtingerXCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //updateKurgXCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //AddSlopeSourceXCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n\n        // Y- direction\n        UpdateButtingerYCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //updateKurgYCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //AddSlopeSourceYCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n    }\n    else if (XParam.engine == 2)\n    {\n        // X- direction\n        updateKurgXCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //AddSlopeSourceXCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n\n        // Y- direction\n        updateKurgYCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //AddSlopeSourceYCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n    }\n    else if (XParam.engine == 3)\n    {\n        // X- direction\n        //UpdateButtingerXCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        updateKurgXATMCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdx);\n        //AddSlopeSourceXCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n\n        // Y- direction\n        //UpdateButtingerYCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        updateKurgYATMCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdy);\n        //AddSlopeSourceYCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n    }\n\n    //============================================\n    // Fill Halo for flux from fine to coarse\n    fillHalo(XParam, XModel.blocks, XModel.flux);\n\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n        FlowbndFlux(XParam, XLoop.totaltime + XLoop.dt , XModel.blocks, XForcing.bndseg[iseg], XForcing.Atmp, XModel.evolv, XModel.flux);\n    }\n\n\n    //============================================\n    // Update advection terms (dh dhu dhv) \n    updateEVCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.flux, XModel.adv);\n\n    //============================================\n    // Add forcing (Rain, Wind)\n    //if (!XForcing.Rain.inputfile.empty())\n    //{\n    //  AddrainforcingCPU(XParam, XModel.blocks, XForcing.Rain, XModel.adv);\n    //}\n    if (!XForcing.UWind.inputfile.empty())//&amp;&amp; !XForcing.UWind.inputfile.empty()\n    {\n        AddwindforcingCPU(XParam, XModel.blocks, XForcing.UWind, XForcing.VWind, XModel.adv);\n    }\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        AddRiverForcing(XParam, XLoop, XForcing.rivers, XModel);\n    }\n\n    //============================================\n    //Update evolving variable by 1 full time step\n    AdvkernelCPU(XParam, XModel.blocks, XModel.time.dt, XModel.zb, XModel.evolv, XModel.adv, XModel.evolv_o);\n\n\n\n    //============================================\n    // Add bottom friction\n\n    bottomfrictionCPU(XParam, XModel.blocks, XModel.time.dt, XModel.cf, XModel.evolv_o);\n    //XiafrictionCPU(XParam, XModel.blocks, XModel.time.dt, XModel.cf, XModel.evolv, XModel.evolv_o);\n\n\n    //============================================\n    //Copy updated evolving variable back\n    cleanupCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.evolv);\n\n\n\n    if (!XForcing.Rain.inputfile.empty())\n    {\n        AddrainforcingImplicitCPU(XParam, XLoop, XModel.blocks, XForcing.Rain, XModel.evolv);\n    }\n\n    if (XParam.infiltration)\n    {\n        AddinfiltrationImplicitCPU(XParam, XLoop, XModel.blocks, XModel.il, XModel.cl, XModel.evolv, XModel.hgw);\n    }\n\n    if (XParam.VelThreshold &gt; 0.0)\n    {\n        TheresholdVelCPU(XParam, XModel.blocks, XModel.evolv);\n\n    }\n\n    //============================================\n    // Reset zb in halo from prolonggation injection\n    if (XParam.conserveElevation)\n    {\n        refine_linear(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    }\n\n\n}\ntemplate void FlowCPU&lt;float&gt;(Param XParam, Loop&lt;float&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;float&gt; XModel);\ntemplate void FlowCPU&lt;double&gt;(Param XParam, Loop&lt;double&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;double&gt; XModel);\n\n\n\n\ntemplate &lt;class T&gt; void HalfStepCPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel)\n{\n    if (XParam.atmpforcing)\n    {\n        //Update atm press forcing\n        AddPatmforcingCPU(XParam, XModel.blocks, XForcing.Atmp, XModel);\n\n        //Fill atmp halo\n        fillHaloC(XParam, XModel.blocks, XModel.Patm);\n\n\n        //Calc dpdx and dpdy\n        gradientC(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        gradientHalo(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n        refine_linear(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        gradientHalo(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n\n\n\n    }\n\n\n    //============================================\n    //  Fill the halo for gradient reconstruction\n    fillHalo(XParam, XModel.blocks, XModel.evolv, XModel.zb);\n\n    //============================================\n    // Reset DTmax\n    InitArrayBUQ(XParam, XModel.blocks, XLoop.hugeposval, XModel.time.dtmax);\n\n    //============================================\n    // Calculate gradient for evolving parameters\n    gradientCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.zb);\n\n    //============================================\n    // Flux and Source term reconstruction\n    // X- direction\n    if (XParam.engine == 1)\n    {\n        // X- direction\n        UpdateButtingerXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n\n        // Y- direction\n        UpdateButtingerYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n    }\n    else if (XParam.engine == 2)\n    {\n        // X- direction\n        updateKurgXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //AddSlopeSourceXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n\n        // Y- direction\n        updateKurgYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //AddSlopeSourceYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n    }\n    else if (XParam.engine == 3)\n    {\n        // X- direction\n        updateKurgXATMCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdx);\n        //AddSlopeSourceXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n\n        // Y- direction\n\n        updateKurgYATMCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdy);\n        //AddSlopeSourceYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n    }\n\n\n    //============================================\n    // Fill Halo for flux from fine to coarse\n    fillHalo(XParam, XModel.blocks, XModel.flux);\n\n    //============================================\n    // Reduce minimum timestep\n    XLoop.dt = double(CalctimestepCPU(XParam, XLoop, XModel.blocks, XModel.time));\n    XLoop.dtmax = XLoop.dt;\n    XModel.time.dt = T(XLoop.dt);\n\n\n    //============================================\n    // Update advection terms (dh dhu dhv) \n    updateEVCPU(XParam, XModel.blocks, XModel.evolv, XModel.flux, XModel.adv);\n\n    //============================================\n    // Add forcing (Rain, Wind)\n    //if (!XForcing.Rain.inputfile.empty())\n    //{\n    //  AddrainforcingCPU(XParam, XModel.blocks, XForcing.Rain, XModel.adv);\n    //}\n    if (!XForcing.UWind.inputfile.empty())//&amp;&amp; !XForcing.UWind.inputfile.empty()\n    {\n        AddwindforcingCPU(XParam, XModel.blocks, XForcing.UWind, XForcing.VWind, XModel.adv);\n    }\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        AddRiverForcing(XParam, XLoop, XForcing.rivers, XModel);\n    }\n\n    //============================================\n    //Update evolving variable by 1/2 time step\n    AdvkernelCPU(XParam, XModel.blocks, XModel.time.dt * T(0.5), XModel.zb, XModel.evolv, XModel.adv, XModel.evolv_o);\n\n    //============================================\n    // Add bottom friction\n\n    bottomfrictionCPU(XParam, XModel.blocks, XModel.time.dt, XModel.cf, XModel.evolv_o);\n    //XiafrictionCPU(XParam, XModel.blocks, XModel.time.dt, XModel.cf, XModel.evolv, XModel.evolv_o);\n\n\n    //============================================\n    //Copy updated evolving variable back\n    cleanupCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.evolv);\n\n    if (!XForcing.Rain.inputfile.empty())\n    {\n        AddrainforcingImplicitCPU(XParam, XLoop, XModel.blocks, XForcing.Rain, XModel.evolv);\n    }\n  if (XParam.infiltration)\n    {\n        AddinfiltrationImplicitCPU(XParam, XLoop, XModel.blocks, XModel.il, XModel.cl, XModel.evolv, XModel.hgw);\n    }\n\n\n    if (XParam.VelThreshold &gt; 0.0)\n    {\n        TheresholdVelCPU(XParam, XModel.blocks, XModel.evolv);\n\n    }\n\n    //============================================\n    // Reset zb in halo from prolonggation injection\n    if (XParam.conserveElevation)\n    {\n        refine_linear(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    }\n\n\n}\ntemplate void HalfStepCPU&lt;float&gt;(Param XParam, Loop&lt;float&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;float&gt; XModel);\ntemplate void HalfStepCPU&lt;double&gt;(Param XParam, Loop&lt;double&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;double&gt; XModel);\n</code></pre>"},{"location":"BGFlood/FlowCPU_8h/","title":"File FlowCPU.h","text":""},{"location":"BGFlood/FlowCPU_8h/#file-flowcpuh","title":"File FlowCPU.h","text":"<p>FileList &gt; src &gt; FlowCPU.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Halo.h\"</code></li> <li><code>#include \"GridManip.h\"</code></li> <li><code>#include \"Gradients.h\"</code></li> <li><code>#include \"Kurganov.h\"</code></li> <li><code>#include \"Advection.h\"</code></li> <li><code>#include \"Friction.h\"</code></li> <li><code>#include \"Updateforcing.h\"</code></li> <li><code>#include \"Reimann.h\"</code></li> </ul>"},{"location":"BGFlood/FlowCPU_8h/#public-functions","title":"Public Functions","text":"Type Name void FlowCPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel)  void HalfStepCPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel)"},{"location":"BGFlood/FlowCPU_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/FlowCPU_8h/#function-flowcpu","title":"function FlowCPU","text":"<pre><code>template&lt;class T&gt;\nvoid FlowCPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/FlowCPU_8h/#function-halfstepcpu","title":"function HalfStepCPU","text":"<pre><code>template&lt;class T&gt;\nvoid HalfStepCPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Debugging flow step This function was crated to debug the main engine of the model </p> <p>The documentation for this class was generated from the following file <code>src/FlowCPU.h</code></p>"},{"location":"BGFlood/FlowCPU_8h_source/","title":"File FlowCPU.h","text":""},{"location":"BGFlood/FlowCPU_8h_source/#file-flowcpuh","title":"File FlowCPU.h","text":"<p>File List &gt; src &gt; FlowCPU.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef FLOWCPU_H\n#define FLOWCPU_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"Util_CPU.h\"\n#include \"MemManagement.h\"\n#include \"Halo.h\"\n#include \"GridManip.h\"\n#include \"Gradients.h\"\n#include \"Kurganov.h\"\n#include \"Advection.h\"\n#include \"Friction.h\"\n#include \"Updateforcing.h\"\n#include \"Reimann.h\"\n\n// End of global definition\ntemplate &lt;class T&gt; void FlowCPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel);\ntemplate &lt;class T&gt; void HalfStepCPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel);\n\n\n#endif\n</code></pre>"},{"location":"BGFlood/FlowGPU_8cu/","title":"File FlowGPU.cu","text":""},{"location":"BGFlood/FlowGPU_8cu/#file-flowgpucu","title":"File FlowGPU.cu","text":"<p>FileList &gt; src &gt; FlowGPU.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"FlowGPU.h\"</code></li> </ul>"},{"location":"BGFlood/FlowGPU_8cu/#public-functions","title":"Public Functions","text":"Type Name void FlowGPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel)  template void FlowGPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; XModel)  template void FlowGPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; XModel)  void HalfStepGPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel)  template void HalfStepGPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; XModel)  template void HalfStepGPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; XModel)  __global__ void reset_var (int halowidth, int * active, T resetval, T * Var)  template __global__ void reset_var&lt; double &gt; (int halowidth, int * active, double resetval, double * Var)  template __global__ void reset_var&lt; float &gt; (int halowidth, int * active, float resetval, float * Var)"},{"location":"BGFlood/FlowGPU_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/FlowGPU_8cu/#function-flowgpu","title":"function FlowGPU","text":"<pre><code>template&lt;class T&gt;\nvoid FlowGPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/FlowGPU_8cu/#function-flowgpu-double","title":"function FlowGPU&lt; double &gt;","text":"<pre><code>template void FlowGPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/FlowGPU_8cu/#function-flowgpu-float","title":"function FlowGPU&lt; float &gt;","text":"<pre><code>template void FlowGPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/FlowGPU_8cu/#function-halfstepgpu","title":"function HalfStepGPU","text":"<pre><code>template&lt;class T&gt;\nvoid HalfStepGPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/FlowGPU_8cu/#function-halfstepgpu-double","title":"function HalfStepGPU&lt; double &gt;","text":"<pre><code>template void HalfStepGPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/FlowGPU_8cu/#function-halfstepgpu-float","title":"function HalfStepGPU&lt; float &gt;","text":"<pre><code>template void HalfStepGPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/FlowGPU_8cu/#function-reset_var","title":"function reset_var","text":"<pre><code>template&lt;class T&gt;\n__global__ void reset_var (\n    int halowidth,\n    int * active,\n    T resetval,\n    T * Var\n) \n</code></pre>"},{"location":"BGFlood/FlowGPU_8cu/#function-reset_var-double","title":"function reset_var&lt; double &gt;","text":"<pre><code>template __global__ void reset_var&lt; double &gt; (\n    int halowidth,\n    int * active,\n    double resetval,\n    double * Var\n) \n</code></pre>"},{"location":"BGFlood/FlowGPU_8cu/#function-reset_var-float","title":"function reset_var&lt; float &gt;","text":"<pre><code>template __global__ void reset_var&lt; float &gt; (\n    int halowidth,\n    int * active,\n    float resetval,\n    float * Var\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/FlowGPU.cu</code></p>"},{"location":"BGFlood/FlowGPU_8cu_source/","title":"File FlowGPU.cu","text":""},{"location":"BGFlood/FlowGPU_8cu_source/#file-flowgpucu","title":"File FlowGPU.cu","text":"<p>File List &gt; src &gt; FlowGPU.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"FlowGPU.h\"\n\ntemplate &lt;class T&gt; void FlowGPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel)\n{\n    //============================================\n    // construct threads abnd block parameters\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    // for flux reconstruction the loop overlap the right(or top for the y direction) halo\n    dim3 blockDimKX(XParam.blkwidth + XParam.halowidth, XParam.blkwidth, 1);\n    dim3 blockDimKY(XParam.blkwidth, XParam.blkwidth + XParam.halowidth, 1);\n\n    //dim3 blockDimHalo(XParam.blkwidth + XParam.halowidth*2, XParam.blkwidth + XParam.halowidth * 2, 1);\n\n    //============================================\n    // Build cuda threads for multitasking on the GPU\n    for (int i = 0; i &lt; XLoop.num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;XLoop.streams[i]));\n    }\n\n    if (XParam.atmpforcing)\n    {\n        //Update atm press forcing\n        AddPatmforcingGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XForcing.Atmp, XModel);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        //Fill atmp halo\n        cudaStream_t atmpstreams[1];\n        CUDA_CHECK(cudaStreamCreate(&amp;atmpstreams[0]));\n        fillHaloGPU(XParam, XModel.blocks, atmpstreams[0], XModel.Patm);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        cudaStreamDestroy(atmpstreams[0]);\n\n        //Calc dpdx and dpdy\n\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n\n        CUDA_CHECK(cudaDeviceSynchronize());\n        gradientHaloGPU(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        //\n\n\n        refine_linearGPU(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientHaloGPU(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n\n    }\n\n\n    //============================================\n    // Predictor step in reimann solver\n    //============================================\n\n    //============================================\n    //  Fill the halo for gradient reconstruction\n    fillHaloGPU(XParam, XModel.blocks, XModel.evolv, XModel.zb);\n\n\n    //============================================\n    // Reset DTmax\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth,XModel.blocks.active,XLoop.hugeposval,XModel.time.dtmax);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //============================================\n    // Calculate gradient for evolving parameters for predictor step\n    gradientGPUnew(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.zb);\n\n    //============================================\n    // Synchronise all ongoing streams\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n\n    //============================================\n    // Flux and Source term reconstruction\n    if (XParam.engine == 1)\n    {\n        // X- direction\n        UpdateButtingerXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //updateKurgXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        // Y- direction\n        UpdateButtingerYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //updateKurgYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0, XLoop.streams[1] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        // //updateKurgY &lt;&lt;&lt; XLoop.gridDim, XLoop.blockDim, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XLoop.epsilon, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax);\n\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else if (XParam.engine == 2)\n    {\n        // X- direction\n        updateKurgXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        // Y- direction\n        updateKurgYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0, XLoop.streams[1] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        // //updateKurgY &lt;&lt;&lt; XLoop.gridDim, XLoop.blockDim, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XLoop.epsilon, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax);\n\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else if (XParam.engine == 3)\n    {\n        // \n        updateKurgXATMGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdx);\n        // //AddSlopeSourceXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        // Y- direction\n        updateKurgYATMGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdy);\n        // //AddSlopeSourceYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0, XLoop.streams[1] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        // //updateKurgY &lt;&lt;&lt; XLoop.gridDim, XLoop.blockDim, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XLoop.epsilon, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax);\n\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    //============================================\n    // Fill Halo for flux from fine to coarse\n    fillHaloGPU(XParam, XModel.blocks, XModel.flux);\n\n    //============================================\n    // Reduce minimum timestep\n    XLoop.dt = double(CalctimestepGPU(XParam, XLoop, XModel.blocks, XModel.time));\n    XLoop.dtmax = XLoop.dt;\n\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n        FlowbndFlux(XParam, XLoop.totaltime + XLoop.dt * 0.5, XModel.blocks, XForcing.bndseg[iseg], XForcing.Atmp, XModel.evolv, XModel.flux);\n    }\n\n    //bndmaskGPU(XParam, XModel.blocks, XModel.evolv, XModel.flux);\n\n\n    XModel.time.dt = T(XLoop.dt);\n\n    //============================================\n    // Update advection terms (dh dhu dhv) \n    updateEVGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.flux, XModel.adv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //============================================\n    // Add forcing (Rain, Wind)\n    //if (!XForcing.Rain.inputfile.empty())\n    //{\n    //  AddrainforcingGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XForcing.Rain, XModel.adv);\n    //}\n    if (!XForcing.UWind.inputfile.empty())//&amp;&amp; !XForcing.UWind.inputfile.empty()\n    {\n        AddwindforcingGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XForcing.UWind, XForcing.VWind, XModel.adv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        AddRiverForcing(XParam, XLoop, XForcing.rivers, XModel);\n    }\n\n    //============================================\n    //Update evolving variable by 1/2 time step\n    AdvkernelGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.time.dt*T(0.5), XModel.zb, XModel.evolv, XModel.adv, XModel.evolv_o);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    //============================================\n    // Corrector step in reimann solver\n    //============================================\n\n    //============================================\n    //  Fill the halo for gradient reconstruction also wall boundary for masked block\n    fillHaloGPU(XParam, XModel.blocks, XModel.evolv_o, XModel.zb);\n\n    //============================================\n    // Calculate gradient for evolving parameters\n    gradientGPUnew(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //============================================\n    // Flux and Source term reconstruction\n    if (XParam.engine == 1)\n    {\n        // X- direction\n        UpdateButtingerXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //updateKurgXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        // Y- direction\n        UpdateButtingerYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //updateKurgYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else if (XParam.engine == 2)\n    {\n        // X- direction\n        updateKurgXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        // Y- direction\n        updateKurgYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else if (XParam.engine == 3)\n    {\n        //\n        //\n        updateKurgXATMGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdx);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        // Y- direction\n        updateKurgYATMGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    //============================================\n    // Fill Halo for flux from fine to coarse\n    fillHaloGPU(XParam, XModel.blocks, XModel.flux);\n\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n        FlowbndFlux(XParam, XLoop.totaltime + XLoop.dt , XModel.blocks, XForcing.bndseg[iseg], XForcing.Atmp, XModel.evolv, XModel.flux);\n    }\n\n    //bndmaskGPU(XParam, XModel.blocks, XModel.evolv, XModel.flux);\n\n    //============================================\n    // Update advection terms (dh dhu dhv) \n    updateEVGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.flux, XModel.adv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    //============================================\n    // Add forcing (Rain, Wind)\n    //if (!XForcing.Rain.inputfile.empty())\n    //{\n    //  AddrainforcingGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XForcing.Rain, XModel.adv);\n    //}\n    if (!XForcing.UWind.inputfile.empty())//&amp;&amp; !XForcing.UWind.inputfile.empty()\n    {\n        AddwindforcingGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XForcing.UWind, XForcing.VWind, XModel.adv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        AddRiverForcing(XParam, XLoop, XForcing.rivers, XModel);\n    }\n\n\n    //============================================\n    //Update evolving variable by 1 full time step\n    AdvkernelGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.time.dt, XModel.zb, XModel.evolv, XModel.adv, XModel.evolv_o);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    //============================================\n    // Add bottom friction\n\n    bottomfrictionGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.time.dt, XModel.cf, XModel.evolv_o);\n    //XiafrictionGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.time.dt, XModel.cf, XModel.evolv, XModel.evolv_o);\n\n\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //============================================\n    //Copy updated evolving variable back\n    cleanupGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.evolv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    if (!XForcing.Rain.inputfile.empty())\n    {\n        AddrainforcingImplicitGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam,XLoop, XModel.blocks, XForcing.Rain, XModel.evolv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    if (XParam.infiltration)\n    {\n        AddinfiltrationImplicitGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XLoop, XModel.blocks, XModel.il, XModel.cl, XModel.evolv, XModel.hgw);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    if (XParam.VelThreshold &gt; 0.0)\n    {\n        TheresholdVelGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    //============================================\n    // Reset zb in prolongation halo\n    if (XParam.conserveElevation)\n    {\n        refine_linearGPU(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    }\n\n    for (int i = 0; i &lt; XLoop.num_streams; i++)\n    {\n        cudaStreamDestroy(XLoop.streams[i]);\n    }\n\n}\ntemplate void FlowGPU&lt;float&gt;(Param XParam, Loop&lt;float&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;float&gt; XModel);\ntemplate void FlowGPU&lt;double&gt;(Param XParam, Loop&lt;double&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;double&gt; XModel);\n\ntemplate &lt;class T&gt; void HalfStepGPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel)\n{\n    //============================================\n    // construct threads abnd block parameters\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    // for flux reconstruction the loop overlap the right(or top for the y direction) halo\n    dim3 blockDimKX(XParam.blkwidth + XParam.halowidth, XParam.blkwidth, 1);\n    dim3 blockDimKY(XParam.blkwidth, XParam.blkwidth + XParam.halowidth, 1);\n\n    //dim3 blockDimHalo(XParam.blkwidth + XParam.halowidth*2, XParam.blkwidth + XParam.halowidth * 2, 1);\n\n    //============================================\n    // Build cuda threads for multitasking on the GPU\n    for (int i = 0; i &lt; XLoop.num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;XLoop.streams[i]));\n    }\n\n    if (XParam.atmpforcing)\n    {\n        //Update atm press forcing\n        AddPatmforcingGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XForcing.Atmp, XModel);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        //Fill atmp halo\n        cudaStream_t atmpstreams[1];\n        CUDA_CHECK(cudaStreamCreate(&amp;atmpstreams[0]));\n        fillHaloGPU(XParam, XModel.blocks, atmpstreams[0], XModel.Patm);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        cudaStreamDestroy(atmpstreams[0]);\n\n        //Calc dpdx and dpdy\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        gradientHaloGPU(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        //\n\n\n        refine_linearGPU(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientHaloGPU(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n\n    }\n\n\n    //============================================\n    // Predictor step in reimann solver\n    //============================================\n\n    //============================================\n    //  Fill the halo for gradient reconstruction\n    fillHaloGPU(XParam, XModel.blocks, XModel.evolv, XModel.zb);\n\n\n    //============================================\n    // Reset DTmax\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel.blocks.active, XLoop.hugeposval, XModel.time.dtmax);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //============================================\n    // Calculate gradient for evolving parameters for predictor step\n    gradientGPUnew(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.zb);\n\n    //============================================\n    // Synchronise all ongoing streams\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n\n    //============================================\n    // Flux and Source term reconstruction\n    if (XParam.engine == 1)\n    {\n        // X- direction\n        UpdateButtingerXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //updateKurgXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        // Y- direction\n        UpdateButtingerYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //updateKurgYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0, XLoop.streams[1] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        // //updateKurgY &lt;&lt;&lt; XLoop.gridDim, XLoop.blockDim, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XLoop.epsilon, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax);\n\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else if (XParam.engine == 2)\n    {\n        // X- direction\n        updateKurgXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        // Y- direction\n        updateKurgYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0, XLoop.streams[1] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        // //updateKurgY &lt;&lt;&lt; XLoop.gridDim, XLoop.blockDim, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XLoop.epsilon, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax);\n\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else if (XParam.engine == 3)\n    {\n        // \n        updateKurgXATMGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdx);\n        // //AddSlopeSourceXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        // Y- direction\n        updateKurgYATMGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdy);\n        // //AddSlopeSourceYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0, XLoop.streams[1] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        // //updateKurgY &lt;&lt;&lt; XLoop.gridDim, XLoop.blockDim, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XLoop.epsilon, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax);\n\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    //============================================\n    // Fill Halo for flux from fine to coarse\n    fillHaloGPU(XParam, XModel.blocks, XModel.flux);\n\n    //============================================\n    // Reduce minimum timestep\n    XLoop.dt = double(CalctimestepGPU(XParam, XLoop, XModel.blocks, XModel.time));\n    XLoop.dtmax = XLoop.dt;\n\n\n    XModel.time.dt = T(XLoop.dt);\n\n    //============================================\n    // Update advection terms (dh dhu dhv) \n    updateEVGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.flux, XModel.adv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //============================================\n    // Add forcing (Rain, Wind)\n    //if (!XForcing.Rain.inputfile.empty())\n    //{\n    //  AddrainforcingGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XForcing.Rain, XModel.adv);\n    //}\n    if (!XForcing.UWind.inputfile.empty())//&amp;&amp; !XForcing.UWind.inputfile.empty()\n    {\n        AddwindforcingGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XForcing.UWind, XForcing.VWind, XModel.adv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        AddRiverForcing(XParam, XLoop, XForcing.rivers, XModel);\n    }\n\n    //============================================\n    //Update evolving variable by 1/2 time step\n    AdvkernelGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.time.dt * T(0.5), XModel.zb, XModel.evolv, XModel.adv, XModel.evolv_o);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //============================================\n    // Add bottom friction\n\n    bottomfrictionGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.time.dt, XModel.cf, XModel.evolv_o);\n    //XiafrictionGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.time.dt, XModel.cf, XModel.evolv, XModel.evolv_o);\n\n\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //============================================\n    //Copy updated evolving variable back\n    cleanupGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.evolv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    if (!XForcing.Rain.inputfile.empty())\n    {\n        AddrainforcingImplicitGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XLoop, XModel.blocks, XForcing.Rain, XModel.evolv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    if (XParam.VelThreshold &gt; 0.0)\n    {\n        TheresholdVelGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    //============================================\n    // Reset zb in prolongation halo\n    if (XParam.conserveElevation)\n    {\n        refine_linearGPU(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    }\n\n    for (int i = 0; i &lt; XLoop.num_streams; i++)\n    {\n        cudaStreamDestroy(XLoop.streams[i]);\n    }\n\n}\ntemplate void HalfStepGPU&lt;float&gt;(Param XParam, Loop&lt;float&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;float&gt; XModel);\ntemplate void HalfStepGPU&lt;double&gt;(Param XParam, Loop&lt;double&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;double&gt; XModel);\n\n\ntemplate &lt;class T&gt; __global__ void reset_var(int halowidth, int* active, T resetval, T* Var)\n{\n\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = active[ibl];\n\n    int n = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    //int n= (ix + halowidth) + (iy + halowidth) * blkmemwidth + ib * blksize;\n    Var[n] = resetval;\n}\ntemplate __global__ void reset_var&lt;float&gt;(int halowidth, int* active, float resetval, float* Var);\ntemplate __global__ void reset_var&lt;double&gt;(int halowidth, int* active, double resetval, double* Var);\n</code></pre>"},{"location":"BGFlood/FlowGPU_8h/","title":"File FlowGPU.h","text":""},{"location":"BGFlood/FlowGPU_8h/#file-flowgpuh","title":"File FlowGPU.h","text":"<p>FileList &gt; src &gt; FlowGPU.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Gradients.h\"</code></li> <li><code>#include \"Kurganov.h\"</code></li> <li><code>#include \"Advection.h\"</code></li> <li><code>#include \"Friction.h\"</code></li> <li><code>#include \"Updateforcing.h\"</code></li> <li><code>#include \"Reimann.h\"</code></li> <li><code>#include \"Boundary.h\"</code></li> </ul>"},{"location":"BGFlood/FlowGPU_8h/#public-functions","title":"Public Functions","text":"Type Name void FlowGPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel)  void HalfStepGPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel)  __global__ void reset_var (int halowidth, int * active, T resetval, T * Var)"},{"location":"BGFlood/FlowGPU_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/FlowGPU_8h/#function-flowgpu","title":"function FlowGPU","text":"<pre><code>template&lt;class T&gt;\nvoid FlowGPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/FlowGPU_8h/#function-halfstepgpu","title":"function HalfStepGPU","text":"<pre><code>template&lt;class T&gt;\nvoid HalfStepGPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/FlowGPU_8h/#function-reset_var","title":"function reset_var","text":"<pre><code>template&lt;class T&gt;\n__global__ void reset_var (\n    int halowidth,\n    int * active,\n    T resetval,\n    T * Var\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/FlowGPU.h</code></p>"},{"location":"BGFlood/FlowGPU_8h_source/","title":"File FlowGPU.h","text":""},{"location":"BGFlood/FlowGPU_8h_source/#file-flowgpuh","title":"File FlowGPU.h","text":"<p>File List &gt; src &gt; FlowGPU.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef FLOWGPU_H\n#define FLOWGPU_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"Util_CPU.h\"\n#include \"MemManagement.h\"\n#include \"Gradients.h\"\n#include \"Kurganov.h\"\n#include \"Advection.h\"\n#include \"Friction.h\"\n#include \"Updateforcing.h\"\n#include \"Reimann.h\"\n#include \"Boundary.h\"\n\ntemplate &lt;class T&gt; void FlowGPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel);\n\ntemplate &lt;class T&gt; __global__ void reset_var(int halowidth, int* active, T resetval, T* Var);\n\ntemplate &lt;class T&gt; void HalfStepGPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/FlowMLGPU_8cu/","title":"File FlowMLGPU.cu","text":""},{"location":"BGFlood/FlowMLGPU_8cu/#file-flowmlgpucu","title":"File FlowMLGPU.cu","text":"<p>FileList &gt; src &gt; FlowMLGPU.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"FlowMLGPU.h\"</code></li> </ul>"},{"location":"BGFlood/FlowMLGPU_8cu/#public-functions","title":"Public Functions","text":"Type Name void FlowMLGPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel)  template void FlowMLGPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; XModel)  template void FlowMLGPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; XModel)"},{"location":"BGFlood/FlowMLGPU_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/FlowMLGPU_8cu/#function-flowmlgpu","title":"function FlowMLGPU","text":"<pre><code>template&lt;class T&gt;\nvoid FlowMLGPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/FlowMLGPU_8cu/#function-flowmlgpu-double","title":"function FlowMLGPU&lt; double &gt;","text":"<pre><code>template void FlowMLGPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/FlowMLGPU_8cu/#function-flowmlgpu-float","title":"function FlowMLGPU&lt; float &gt;","text":"<pre><code>template void FlowMLGPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; XModel\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/FlowMLGPU.cu</code></p>"},{"location":"BGFlood/FlowMLGPU_8cu_source/","title":"File FlowMLGPU.cu","text":""},{"location":"BGFlood/FlowMLGPU_8cu_source/#file-flowmlgpucu","title":"File FlowMLGPU.cu","text":"<p>File List &gt; src &gt; FlowMLGPU.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"FlowMLGPU.h\"\n\ntemplate &lt;class T&gt; void FlowMLGPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel)\n{\n    //============================================\n    // construct threads abnd block parameters\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n    // for flux reconstruction the loop overlap the right(or top for the y direction) halo\n    dim3 blockDimKX(XParam.blkwidth + XParam.halowidth, XParam.blkwidth, 1);\n    dim3 blockDimKY(XParam.blkwidth, XParam.blkwidth + XParam.halowidth, 1);\n\n    // For halo corners\n    dim3 blockDimHC(4, 1, 1);\n\n    // Fill halo for Fu and Fv\n    dim3 blockDimHaloLR(2, XParam.blkwidth, 1);\n    //dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDimHaloLR(ceil(XParam.nblk / 2), 1, 1);\n\n    dim3 blockDimHaloBT(XParam.blkwidth, 2, 1);\n    dim3 gridDimHaloBT(ceil(XParam.nblk / 2), 1, 1);\n\n\n    // fill halo for zs,h,u and v \n\n    //============================================\n    //  Fill the halo for gradient reconstruction &amp; Recalculate zs\n    fillHaloGPU(XParam, XModel.blocks, XModel.evolv, XModel.zb);\n\n    // calculate grad for dhdx dhdy only\n\n    //============================================\n    // Calculate gradient for evolving parameters for predictor step\n    gradientGPUnew(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.zb);\n    //gradientSMC &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.evolv.h, XModel.grad.dhdx, XModel.grad.dhdy);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    //============================================\n    // Synchronise all ongoing streams\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Set max timestep\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel.blocks.active, XLoop.hugeposval, XModel.time.dtmax);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Compute face value\n    CalcfaceValX &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (T(XLoop.dtmax), XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.fluxml, XModel.time.dtmax, XModel.zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    CalcfaceValY &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (T(XLoop.dtmax), XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.fluxml, XModel.time.dtmax, XModel.zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Timestep reduction\n    XLoop.dt = double(CalctimestepGPU(XParam, XLoop, XModel.blocks, XModel.time));\n    XLoop.dtmax = XLoop.dt;\n\n\n\n    //Fill flux Halo for ha and hf\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.hfu);\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.hfv);\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.hau);\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.hav);\n\n    HaloFluxGPULRnew &lt;&lt; &lt; gridDimHaloLR, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hfu);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    HaloFluxGPUBTnew &lt;&lt; &lt;gridDimHaloBT, blockDimHaloBT, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hfv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    HaloFluxGPULRnew &lt;&lt; &lt; gridDimHaloLR, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hau);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    HaloFluxGPUBTnew &lt;&lt; &lt;gridDimHaloBT, blockDimHaloBT, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hav);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Acceleration\n    // Pressure\n    pressureML &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XModel.blocks, T(XLoop.dt), XModel.evolv, XModel.grad, XModel.fluxml);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Check hu/hv\n    CheckadvecMLY &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XModel.blocks, T(XLoop.dt), XModel.evolv, XModel.grad, XModel.fluxml);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    CheckadvecMLX &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XModel.blocks, T(XLoop.dt), XModel.evolv, XModel.grad, XModel.fluxml);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Fill halo u and v calc grd for u and v and fill halo for hu and hv\n    // \n\n    fillHaloGPU(XParam, XModel.blocks, XModel.evolv.u);\n    fillHaloGPU(XParam, XModel.blocks, XModel.evolv.v);\n\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.hu);\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.hv);\n\n\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n        FlowbndFluxML(XParam, XLoop.totaltime + XLoop.dt, XModel.blocks, XForcing.bndseg[iseg], XForcing.Atmp, XModel.evolv, XModel.fluxml);\n    }\n    //HaloFluxGPULRnew &lt;&lt; &lt; gridDimHaloLR, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hu);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    //HaloFluxGPUBTnew &lt;&lt; &lt;gridDimHaloBT, blockDimHaloBT, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hv);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    //HaloFluxGPULRnew &lt;&lt; &lt; gridDimHaloLR, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hv);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    //HaloFluxGPUBTnew &lt;&lt; &lt;gridDimHaloBT, blockDimHaloBT, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hu);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradientSMC &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.evolv.u, XModel.grad.dudx, XModel.grad.dudy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradientSMC &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.evolv.v, XModel.grad.dvdx, XModel.grad.dvdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    fillHaloGPU(XParam, XModel.blocks, XModel.grad.dudx);\n    fillHaloGPU(XParam, XModel.blocks, XModel.grad.dudy);\n    fillHaloGPU(XParam, XModel.blocks, XModel.grad.dvdx);\n    fillHaloGPU(XParam, XModel.blocks, XModel.grad.dvdy);\n\n\n    fillCornersGPU &lt;&lt;&lt; gridDim, blockDimHC, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.fluxml.hu);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    fillCornersGPU &lt;&lt; &lt; gridDim, blockDimHC, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    fillCornersGPU &lt;&lt; &lt; gridDim, blockDimHC, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hfu);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    fillCornersGPU &lt;&lt; &lt; gridDim, blockDimHC, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hfv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    fillCornersGPU &lt;&lt; &lt; gridDim, blockDimHC, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.evolv.u);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    fillCornersGPU &lt;&lt; &lt; gridDim, blockDimHC, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.evolv.v);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //hv hfv u hu hfu v\n\n\n\n    // Advection\n    AdvecFluxML &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XModel.blocks, T(XLoop.dt), XModel.evolv, XModel.grad, XModel.fluxml);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.Fux);\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.Fvx);\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.Fuy);\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.Fvy);\n\n    //HaloFluxGPULRnew &lt;&lt; &lt; gridDimHaloLR, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.Fu);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    //HaloFluxGPUBTnew &lt;&lt; &lt;gridDimHaloBT, blockDimHaloBT, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.Fv);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n\n\n    AdvecEv &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XModel.blocks, T(XLoop.dt), XModel.evolv, XModel.grad, XModel.fluxml);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n\n\n\n    bottomfrictionGPU &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XModel.blocks, T(XLoop.dt), XModel.cf, XModel.evolv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        //Add River ML\n    }\n\n\n    if (!XForcing.Rain.inputfile.empty())\n    {\n        AddrainforcingImplicitGPU &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XLoop, XModel.blocks, XForcing.Rain, XModel.evolv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    if (XParam.infiltration)\n    {\n        AddinfiltrationImplicitGPU &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XLoop, XModel.blocks, XModel.il, XModel.cl, XModel.evolv, XModel.hgw);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    if (XParam.VelThreshold &gt; 0.0)\n    {\n        TheresholdVelGPU &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.evolv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    // Recalculate zs based on h and zb\n    CleanupML &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n}\ntemplate void FlowMLGPU&lt;float&gt;(Param XParam, Loop&lt;float&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;float&gt; XModel);\ntemplate void FlowMLGPU&lt;double&gt;(Param XParam, Loop&lt;double&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;double&gt; XModel);\n</code></pre>"},{"location":"BGFlood/FlowMLGPU_8h/","title":"File FlowMLGPU.h","text":""},{"location":"BGFlood/FlowMLGPU_8h/#file-flowmlgpuh","title":"File FlowMLGPU.h","text":"<p>FileList &gt; src &gt; FlowMLGPU.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Multilayer.h\"</code></li> <li><code>#include \"FlowGPU.h\"</code></li> <li><code>#include \"Advection.h\"</code></li> </ul>"},{"location":"BGFlood/FlowMLGPU_8h/#public-functions","title":"Public Functions","text":"Type Name void FlowMLGPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel)"},{"location":"BGFlood/FlowMLGPU_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/FlowMLGPU_8h/#function-flowmlgpu","title":"function FlowMLGPU","text":"<pre><code>template&lt;class T&gt;\nvoid FlowMLGPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/FlowMLGPU.h</code></p>"},{"location":"BGFlood/FlowMLGPU_8h_source/","title":"File FlowMLGPU.h","text":""},{"location":"BGFlood/FlowMLGPU_8h_source/#file-flowmlgpuh","title":"File FlowMLGPU.h","text":"<p>File List &gt; src &gt; FlowMLGPU.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef FLOWMLGPU_H\n#define FLOWMLGPU_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"Util_CPU.h\"\n#include \"MemManagement.h\"\n#include \"Multilayer.h\"\n#include \"FlowGPU.h\"\n#include \"Advection.h\"\n\ntemplate &lt;class T&gt; void FlowMLGPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel);\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Forcing_8h/","title":"File Forcing.h","text":""},{"location":"BGFlood/Forcing_8h/#file-forcingh","title":"File Forcing.h","text":"<p>FileList &gt; src &gt; Forcing.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Input.h\"</code></li> </ul>"},{"location":"BGFlood/Forcing_8h/#classes","title":"Classes","text":"Type Name class AOIinfo struct DynForcingP &lt;class T&gt; struct Forcing &lt;class T&gt; struct StaticForcingP &lt;class T&gt; struct TexSetP struct bndTexP class bndparam class bndsegment class bndsegmentside class deformmap &lt;class T&gt; class forcingmap <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/Forcing_8h_source/","title":"File Forcing.h","text":""},{"location":"BGFlood/Forcing_8h_source/#file-forcingh","title":"File Forcing.h","text":"<p>File List &gt; src &gt; Forcing.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef FORCING_H\n#define FORCING_H\n\n#include \"General.h\"\n#include \"Input.h\"\n\nstruct TexSetP\n{\n    float xo, yo, dx, dy; // used to calculate coordinates insode the device function\n    float nowvalue;\n    bool uniform;\n    cudaArray* CudArr;\n    cudaChannelFormatDesc channelDesc = cudaCreateChannelDesc(32, 0, 0, 0, cudaChannelFormatKindFloat);\n    //texture&lt;float, 2, cudaReadModeElementType&gt; tex;\n    struct cudaResourceDesc resDesc;\n    struct cudaTextureDesc texDesc;\n    cudaTextureObject_t tex = 0;\n};\n\nstruct bndTexP\n{\n    TexSetP WLS;\n    TexSetP Uvel;\n    TexSetP Vvel;\n};\n\nclass forcingmap : public inputmap {\npublic:\n\n    int nt;\n    bool uniform = false;\n    double to, tmax;\n    double dt;\n    int instep = 0; // last step that was read\n    std::string inputfile;\n    std::vector&lt;Windin&gt; unidata; // only used if uniform forcing\n    double nowvalue; // temporary storage for value at a given time\n    TexSetP GPU;\n\n};\n\ntemplate &lt;class T&gt;\nclass deformmap : public inputmap\n{\n    //Deform are maps to applie to both zs and zb; this is often co-seismic vertical deformation used to generate tsunami initial wave\n    // Here you can spread the deformation across a certain amount of time and apply it at any point in the model.\n    // To modify only zs, use the same structure with the key word \"cavity\"\npublic:\n    double startime = 0.0;\n    double duration = 0.0;\n    bool iscavity = false;\n    T* val;\n\n    T clampedge = 0.0;\n    TexSetP GPU;\n};\n\n\ntemplate &lt;class T&gt;\nstruct DynForcingP: public forcingmap\n{\n    T *now;\n    T *before, *after;\n    T* val; // useful for reading from file\n\n    // gpu version of these array\n    T* now_g;\n    T* before_g, * after_g;\n\n    T clampedge=0.0;\n\n};\n\n\n\n\n\ntemplate &lt;class T&gt;\nstruct StaticForcingP : public inputmap\n{\n    T *val;\n\n};\n\n//bnd\nclass bndparam {\npublic:\n    std::vector&lt;SLTS&gt; data;\n    bool on = false;\n    //If changing this default value, please change documentation later on the file\n    int type = 1; // 0:Wall (no slip); 1:neumann (zeros gradient) [Default]; 2:sealevel dirichlet; 3: Absorbing 1D 4: Absorbing 2D (not yet implemented)\n    std::string inputfile;\n    int nbnd; // number of forcing bnds along the side (&gt;=1 is side is on)\n    int nblk = 0; //number of blocks where this bnd applies\n    int side = 0; // 0: top bnd, 1: rightbnd, 2: bot bnd, 3, Left bnd\n    int isright = 0;\n    int istop = 0;\n    bndTexP GPU;\n    int* blks; // array of block where bnd applies \n    int* blks_g; // Also needed for GPU (because it should be a gpu allocated pointer) This is not pretty at all! In the future maybe using pagelocked memory or other new type may be beneficial \n    float* qmean;\n    float* qmean_g;\n};\n\nclass bndsegmentside {\npublic:\n    int nblk=0;\n    int* blk;\n    int* blk_g;\n    float* qmean;\n    float* qmean_g;\n    int isright = 0;\n    int istop = 0;\n    // 8 digit binary where 1 is a mask and 0 is not a mask with the first digit represent the left bottom side the rest is clockwise (i.e.left-bot left-top, top-left, top-right, right-top, right-bot, bot-right, bot-left)\n    //int* side; // e.g. 11000000 for the entire left side being a mask\n};\n\n\nclass bndsegment {\npublic:\n    std::vector&lt;Windin&gt; data;\n    std::string inputfile;\n    Polygon poly;\n    std::string polyfile;\n    bool on = false;\n    bool uniform = true;\n    //If changing this default value, please change documentation later on the file\n    int type = 1; // 0:Wall (no slip); 1:neumann (zeros gradient) [Default]; 2:sealevel dirichlet; 3: Absorbing 1D 4: Absorbing 2D (not yet implemented)\n\n    int nbnd; // number of forcing bnds along the side (&gt;=1 is side is on) \n    int nblk = 0; //number of blocks where this bnd applies\n\n\n\n\n    DynForcingP&lt;float&gt; WLmap;\n\n    bndsegmentside left;\n    bndsegmentside right;\n    bndsegmentside top;\n    bndsegmentside bot;\n\n};\n\n\nclass AOIinfo {\npublic:\n    std::string file;\n    Polygon poly;\n    bool active=false;\n};\n\n\ntemplate &lt;class T&gt;\nstruct Forcing\n{\n    DynForcingP&lt;T&gt; UWind;\n    DynForcingP&lt;T&gt; VWind;\n    //Forcing the Wind;\n    /*Spacially varying (.nc): 2 files are given, 1st file is U wind and second is V wind (no rotation of the data is performed)\n    Spacially uniform (.txt): 1 file is given then a 3 column file is expected, showing time, windspeed and direction.\n    Wind direction is rotated (later) to the grid direction (using grdalpha input parameter)\n    Ex: Wind = mywind.nc?uw,mywind.nc?vw\n    Ex: Wind = MyWind.txt\n    Default: None\n    */\n\n\n    DynForcingP&lt;T&gt; Rain;\n    /* This allow to force a time varying, space varying rain intensity on the model, in mm/h.\n    Spacially varrying (rain map), a netcdf file is expected (with the variable associated to the rain after \"?\").\n    Spacially uniform: the rain is forced using a time serie using a 2 column values table containing time (not necessary unformly distributed) and rain.\n    Ex: rain=rain_forcing.txt \n    Ex: rain=rain_forcing.nc?RainIntensity\n    Default: None\n    */\n\n    DynForcingP&lt;T&gt; Atmp;\n    /* Atmospheric forcing file. The forcing pressure is expected to be in Pa and the effect of the atmospheric pressure gradient is calculated as the difference to a reference pressure Paref, converted to a height using the Pa2m parameter.\n    Ex: Atmp=AtmosphericPressure.nc?p\n    Default: None\n    */\n\n\n    std::vector&lt;StaticForcingP&lt;T&gt;&gt; Bathy; //Should be a vector at some point\n    /* Bathymetry/Topography input, ONLY NECESSARY INPUT\n    Different format are accepted: .asc, .nc, .md. , the grid must be regular with growing coordinate.\n    This grid will define the extend of the model domain and model resolution (if not inform by the user).\n    The coordinate can be cartesian or spherical (still in development).\n    A list of file can also be use to provide a thiner resolution localy by using the key word each time on a different line.\n    The first file will be use to define the domain area and base resolution but the following file\n    will be used during the refinement process.\n    Ex: bathy=Westport_DEM_2020.nc?z\n    Ex: topo=Westport_DEM_2020.asc\n    Default: None but input NECESSARY\n    */\n\n\n    std::vector&lt;StaticForcingP&lt;T&gt;&gt; cf;\n    /*Bottom friction coefficient map (associated to the chosen bottom friction model: n, z0, ...)\n    A list of roughness map can be provide. At any grid point, the last one defined will be used.\n    Ex: cf=0.001;\n    Ex: cf=bottom_friction.nc?bfc;\n    Default: (see constant in parameters)\n    */\n\n    StaticForcingP&lt;T&gt; il;\n    /*Initial Rain loss coefficient map (in mm)\n    Ex: il=rain_loss.nc?initial_loss;\n    Default: (see constant in parameters)\n    */\n\n    StaticForcingP&lt;T&gt; cl;\n    /*Continuous Rain loss coefficient map (in mm/h)\n    Ex: cl=rain_loss.nc?continuous_loss;\n    Default: (see constant in parameters)\n    */\n\n    std::vector&lt;StaticForcingP&lt;int&gt;&gt; targetadapt;\n\n    std::vector&lt;deformmap&lt;T&gt;&gt; deform;\n    /*Deform are maps to apply to both zs and zb; this is often co-seismic vertical deformation used to generate tsunami initial wave\n    Here you can spread the deformation across a certain amount of time and apply it at any point in the model.\n    Ex: deform = myDeform.nc?z_def,3.0,10.0;\n    Ex: deform = *filename*, *time of initial rupture*, *rising time*;\n    Default: None\n    */\n\n\n    std::vector&lt;River&gt; rivers;\n    /*The river is added as a vertical discharge (m3/s) on a chosen area (the user input consists in a time serie and a rectangular area definition).\n    The whole cells containing the corners of the area will be included in the area, no horizontal velocity is applied.\n    To add multiple rivers, just add different lines in the input file (one by river).\n    Ex: river = Votualevu_R.txt,1867430,1867455,3914065,3914090;\n    Ex: river = *Fluxfile*, *xstart*, *xend*, *ystart*, *yend*;\n    Default: None\n    */\n\n    bndparam left;\n    /* 0:Wall (no slip); 1:neumann (zeros gradient) [Default]; 2:sealevel dirichlet; 3: Absorbing 1D 4: Absorbing 2D (not yet implemented)\n    For type 2 and 3 boundary, a file need to be added to determine the vaules at the boundary. This file will consist in a first column containing time (with possibly variable time steps) and forcing values in the following columns (1 column of values corresponding to a constant value along the boundary, 2 columns correspond to values at boundary edges with linear evolution in between, n columns correspond to n regularly spaced values applied along the boundary)\n    Ex: left = 0;\n    Ex: left = leftBnd.txt,2;\n    Default: 1\n    */\n\n    bndparam right;\n    /*Same as left boundary\n    Ex: right = 0;\n    Ex: right = rightBnd.txt,2;\n    Default: 1\n    */\n\n    bndparam top;\n    /*Same as left boundary\n    Ex: top = 0;\n    Ex: top = topBnd.txt,2;\n    Default: 1\n    */\n\n    bndparam bot;\n    /*Same as left boundary\n    Ex: bot = 0;\n    Ex: bot = botBnd.txt,2;\n    Default: 1\n    */\n\n\n    std::vector&lt;bndsegment&gt; bndseg;\n    /* boundary segment; Only applies to AOI bnds\n    Ex: bndseg=area.txt,waterlevelforcing,1;\n    Default: none\n    */\n\n    AOIinfo AOI;\n    /*Area of interest polygon\n    Ex: AOI=myarea.gmt;\n    the input file is a text file with 2 columns containing the coordinate of a closed polygon (last line==first line)\n    Default: N/A\n    */\n\n};\n\n\n\n\n\n\n\n\n\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Friction_8cu/","title":"File Friction.cu","text":""},{"location":"BGFlood/Friction_8cu/#file-frictioncu","title":"File Friction.cu","text":"<p>FileList &gt; src &gt; Friction.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Friction.h\"</code></li> </ul>"},{"location":"BGFlood/Friction_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ void TheresholdVelCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEvolv) Function Used to prevent crazy velocity on the CPU. template __host__ void TheresholdVelCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEvolv)  template __host__ void TheresholdVelCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEvolv)  __global__ void TheresholdVelGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEvolv) Function Used to prevent crazy velocity on the GPU. template __global__ void TheresholdVelGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEvolv)  template __global__ void TheresholdVelGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEvolv)  __host__ __device__ bool ThresholdVelocity (T Threshold, T &amp; u, T &amp; v) Function Used to prevent crazy velocity. __host__ void XiafrictionCPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * cf, EvolvingP&lt; T &gt; XEvolv, EvolvingP&lt; T &gt; XEvolv_o)  template __host__ void XiafrictionCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, double * cf, EvolvingP&lt; double &gt; XEvolv, EvolvingP&lt; double &gt; XEvolv_o)  template __host__ void XiafrictionCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, float * cf, EvolvingP&lt; float &gt; XEvolv, EvolvingP&lt; float &gt; XEvolv_o)  __global__ void XiafrictionGPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * cf, EvolvingP&lt; T &gt; XEvolv, EvolvingP&lt; T &gt; XEvolv_o)  template __global__ void XiafrictionGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, double * cf, EvolvingP&lt; double &gt; XEvolv, EvolvingP&lt; double &gt; XEvolv_o)  template __global__ void XiafrictionGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, float * cf, EvolvingP&lt; float &gt; XEvolv, EvolvingP&lt; float &gt; XEvolv_o)  __host__ void bottomfrictionCPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * cf, EvolvingP&lt; T &gt; XEvolv)  template __host__ void bottomfrictionCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, double * cf, EvolvingP&lt; double &gt; XEvolv)  template __host__ void bottomfrictionCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, float * cf, EvolvingP&lt; float &gt; XEvolv)  __global__ void bottomfrictionGPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * cf, EvolvingP&lt; T &gt; XEvolv)  template __global__ void bottomfrictionGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, double * cf, EvolvingP&lt; double &gt; XEvolv)  template __global__ void bottomfrictionGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, float * cf, EvolvingP&lt; float &gt; XEvolv)  __host__ __device__ T manningfriction (T g, T hi, T n)  __host__ __device__ T smartfriction (T hi, T zo)"},{"location":"BGFlood/Friction_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Friction_8cu/#function-theresholdvelcpu","title":"function TheresholdVelCPU","text":"<p>Function Used to prevent crazy velocity on the CPU. </p><pre><code>template&lt;class T&gt;\n__host__ void TheresholdVelCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEvolv\n) \n</code></pre> <p>The function wraps teh main functio for the CPU. </p>"},{"location":"BGFlood/Friction_8cu/#function-theresholdvelcpu-double","title":"function TheresholdVelCPU&lt; double &gt;","text":"<pre><code>template __host__ void TheresholdVelCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/Friction_8cu/#function-theresholdvelcpu-float","title":"function TheresholdVelCPU&lt; float &gt;","text":"<pre><code>template __host__ void TheresholdVelCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/Friction_8cu/#function-theresholdvelgpu","title":"function TheresholdVelGPU","text":"<p>Function Used to prevent crazy velocity on the GPU. </p><pre><code>template&lt;class T&gt;\n__global__ void TheresholdVelGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEvolv\n) \n</code></pre> <p>The function wraps the main function for the GPU. </p>"},{"location":"BGFlood/Friction_8cu/#function-theresholdvelgpu-double","title":"function TheresholdVelGPU&lt; double &gt;","text":"<pre><code>template __global__ void TheresholdVelGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/Friction_8cu/#function-theresholdvelgpu-float","title":"function TheresholdVelGPU&lt; float &gt;","text":"<pre><code>template __global__ void TheresholdVelGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/Friction_8cu/#function-thresholdvelocity","title":"function ThresholdVelocity","text":"<p>Function Used to prevent crazy velocity. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ bool ThresholdVelocity (\n    T Threshold,\n    T &amp; u,\n    T &amp; v\n) \n</code></pre> <p>The function scale velocities so it doesn't exceeds a given threshold. Default threshold is/should be 16.0m/s </p>"},{"location":"BGFlood/Friction_8cu/#function-xiafrictioncpu","title":"function XiafrictionCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void XiafrictionCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * cf,\n    EvolvingP &lt; T &gt; XEvolv,\n    EvolvingP &lt; T &gt; XEvolv_o\n) \n</code></pre>"},{"location":"BGFlood/Friction_8cu/#function-xiafrictioncpu-double","title":"function XiafrictionCPU&lt; double &gt;","text":"<pre><code>template __host__ void XiafrictionCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    double * cf,\n    EvolvingP &lt; double &gt; XEvolv,\n    EvolvingP &lt; double &gt; XEvolv_o\n) \n</code></pre>"},{"location":"BGFlood/Friction_8cu/#function-xiafrictioncpu-float","title":"function XiafrictionCPU&lt; float &gt;","text":"<pre><code>template __host__ void XiafrictionCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    float * cf,\n    EvolvingP &lt; float &gt; XEvolv,\n    EvolvingP &lt; float &gt; XEvolv_o\n) \n</code></pre>"},{"location":"BGFlood/Friction_8cu/#function-xiafrictiongpu","title":"function XiafrictionGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void XiafrictionGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * cf,\n    EvolvingP &lt; T &gt; XEvolv,\n    EvolvingP &lt; T &gt; XEvolv_o\n) \n</code></pre>"},{"location":"BGFlood/Friction_8cu/#function-xiafrictiongpu-double","title":"function XiafrictionGPU&lt; double &gt;","text":"<pre><code>template __global__ void XiafrictionGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    double * cf,\n    EvolvingP &lt; double &gt; XEvolv,\n    EvolvingP &lt; double &gt; XEvolv_o\n) \n</code></pre>"},{"location":"BGFlood/Friction_8cu/#function-xiafrictiongpu-float","title":"function XiafrictionGPU&lt; float &gt;","text":"<pre><code>template __global__ void XiafrictionGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    float * cf,\n    EvolvingP &lt; float &gt; XEvolv,\n    EvolvingP &lt; float &gt; XEvolv_o\n) \n</code></pre>"},{"location":"BGFlood/Friction_8cu/#function-bottomfrictioncpu","title":"function bottomfrictionCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void bottomfrictionCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * cf,\n    EvolvingP &lt; T &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/Friction_8cu/#function-bottomfrictioncpu-double","title":"function bottomfrictionCPU&lt; double &gt;","text":"<pre><code>template __host__ void bottomfrictionCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    double * cf,\n    EvolvingP &lt; double &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/Friction_8cu/#function-bottomfrictioncpu-float","title":"function bottomfrictionCPU&lt; float &gt;","text":"<pre><code>template __host__ void bottomfrictionCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    float * cf,\n    EvolvingP &lt; float &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/Friction_8cu/#function-bottomfrictiongpu","title":"function bottomfrictionGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void bottomfrictionGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * cf,\n    EvolvingP &lt; T &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/Friction_8cu/#function-bottomfrictiongpu-double","title":"function bottomfrictionGPU&lt; double &gt;","text":"<pre><code>template __global__ void bottomfrictionGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    double * cf,\n    EvolvingP &lt; double &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/Friction_8cu/#function-bottomfrictiongpu-float","title":"function bottomfrictionGPU&lt; float &gt;","text":"<pre><code>template __global__ void bottomfrictionGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    float * cf,\n    EvolvingP &lt; float &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/Friction_8cu/#function-manningfriction","title":"function manningfriction","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T manningfriction (\n    T g,\n    T hi,\n    T n\n) \n</code></pre>"},{"location":"BGFlood/Friction_8cu/#function-smartfriction","title":"function smartfriction","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T smartfriction (\n    T hi,\n    T zo\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Friction.cu</code></p>"},{"location":"BGFlood/Friction_8cu_source/","title":"File Friction.cu","text":""},{"location":"BGFlood/Friction_8cu_source/#file-frictioncu","title":"File Friction.cu","text":"<p>File List &gt; src &gt; Friction.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Friction.h\"\n\n\n\ntemplate &lt;class T&gt; __global__ void bottomfrictionGPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt, T* cf,EvolvingP&lt;T&gt; XEvolv)\n{\n    // Shear stress equation:\n    // Taub=cf*rho*U*sqrt(U^2+V^2)\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    T eps = T(XParam.eps);\n    T g = T(XParam.g);\n\n    int frictionmodel = XParam.frictionmodel;\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n\n    T normu, hi, ui, vi;\n\n\n\n    hi = XEvolv.h[i];\n    ui = XEvolv.u[i];\n    vi = XEvolv.v[i];\n    if (hi &gt; eps)\n    {\n        normu = sqrt(ui * ui + vi * vi);\n\n        T cfi;\n        if (frictionmodel == 0)\n        {\n            cfi = cf[i];\n        }\n        else if (frictionmodel == 1)//Smart friction formulation\n        {\n            cfi = smartfriction(hi, cf[i]);\n\n        }\n        else if (frictionmodel == -1)// Manning friction formulation\n        {\n            cfi = manningfriction(g, hi, cf[i]);\n\n        }\n\n        T tb = cfi * normu / hi * dt;\n        XEvolv.u[i] = ui / (T(1.0) + tb);\n        XEvolv.v[i] = vi / (T(1.0) + tb);\n    }\n\n\n\n}\ntemplate __global__ void bottomfrictionGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock,float dt, float* cf, EvolvingP&lt;float&gt; XEvolv);\ntemplate __global__ void bottomfrictionGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock,double dt, double* cf, EvolvingP&lt;double&gt; XEvolv);\n\n\n\ntemplate &lt;class T&gt; __host__ void bottomfrictionCPU(Param XParam, BlockP&lt;T&gt; XBlock,T dt, T* cf, EvolvingP&lt;T&gt; XEvolv)\n{\n    T eps = T(XParam.eps);\n    T g = T(XParam.g);\n\n\n\n    T hi, ui, vi,normu;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                hi = XEvolv.h[i];\n                ui = XEvolv.u[i];\n                vi = XEvolv.v[i];\n                if (hi &gt; eps)\n                {\n                    normu = sqrt(ui * ui + vi * vi);\n\n                    T cfi;\n                    if (XParam.frictionmodel == 0)\n                    {\n                        cfi = cf[i];\n                    }\n                    else if (XParam.frictionmodel == 1)//Smart friction formulation\n                    {\n\n                        cfi = smartfriction(hi, cf[i]);\n\n                    }\n                    else if (XParam.frictionmodel == -1)// Manning friction formulation\n                    {\n                        T n = cf[i];\n                        cfi = manningfriction(g, hi, n);\n\n\n                    }\n\n                    T tb = cfi * normu / hi * dt;\n                    XEvolv.u[i] = ui / (T(1.0) + tb);\n                    XEvolv.v[i] = vi / (T(1.0) + tb);\n                }\n            }\n        }\n    }\n\n\n}\ntemplate __host__ void bottomfrictionCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock,float dt, float* cf, EvolvingP&lt;float&gt; XEvolv);\ntemplate __host__ void bottomfrictionCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock,double dt, double* cf, EvolvingP&lt;double&gt; XEvolv);\n\ntemplate &lt;class T&gt; __host__ void XiafrictionCPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt, T* cf, EvolvingP&lt;T&gt; XEvolv, EvolvingP&lt;T&gt; XEvolv_o)\n{\n    T eps = T(XParam.eps);\n    T g = T(XParam.g);\n\n\n\n    T hi, ho, ui, vi, normu;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                ho = XEvolv.h[i];\n                hi = XEvolv_o.h[i];\n                ui = XEvolv_o.u[i];\n                vi = XEvolv_o.v[i];\n                if (hi &gt; eps)\n                {\n                    normu = sqrt(ui * ui + vi * vi);\n\n                    T cfi = cf[i]; //if (XParam.frictionmodel == 0)\n                    if (XParam.frictionmodel == 1)//Smart friction formulation\n                    {\n\n                        cfi = smartfriction(hi, cf[i]);\n\n                    }\n                    else if (XParam.frictionmodel == -1)// Manning friction formulation\n                    {\n                        T n = cf[i];\n                        cfi = manningfriction(g, hi, n);\n\n\n                    }\n\n                    T tb = cfi * normu * hi/(ho*ho) * dt;\n                    if (tb &gt;= T(1e-10))\n                    {\n                        XEvolv_o.u[i] = (ui - ui * sqrt(T(1.0) + T(4.0) * tb)) / (T(-2.0) * tb);\n                        XEvolv_o.v[i] = (vi - vi * sqrt(T(1.0) + T(4.0) * tb)) / (T(-2.0) * tb);\n                    }\n\n                }\n            }\n        }\n    }\n\n\n}\n\ntemplate __host__ void XiafrictionCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock,float dt, float* cf, EvolvingP&lt;float&gt; XEvolv, EvolvingP&lt;float&gt; XEvolv_o);\ntemplate __host__ void XiafrictionCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock,double dt, double* cf, EvolvingP&lt;double&gt; XEvolv, EvolvingP&lt;double&gt; XEvolv_o);\n\ntemplate &lt;class T&gt; __global__ void XiafrictionGPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt, T* cf, EvolvingP&lt;T&gt; XEvolv, EvolvingP&lt;T&gt; XEvolv_o)\n{\n    // Shear stress equation:\n    // Taub=cf*rho*U*sqrt(U^2+V^2)\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    T eps = T(XParam.eps);\n    T g = T(XParam.g);\n\n    //int frictionmodel = XParam.frictionmodel;\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n\n    T normu,ho, hi, ui, vi;\n\n\n\n\n    ho = XEvolv.h[i];\n    hi = XEvolv_o.h[i];\n    ui = XEvolv_o.u[i];\n    vi = XEvolv_o.v[i];\n    if (hi &gt; eps) //SHould this be both ho and hi &gt;eps ?\n    {\n        normu = sqrt(ui * ui + vi * vi);\n\n        T cfi = cf[i]; //if (XParam.frictionmodel == 0)\n        if (XParam.frictionmodel == 1)//Smart friction formulation\n        {\n\n            cfi = smartfriction(hi, cf[i]);\n\n        }\n        else if (XParam.frictionmodel == -1)// Manning friction formulation\n        {\n            T n = cf[i];\n            cfi = manningfriction(g, hi, n);\n\n\n        }\n\n        T tb = cfi * normu * hi / (ho * ho) * dt;\n        if (tb &gt;= T(1e-10))\n        {\n            XEvolv_o.u[i] = (ui - ui * sqrt(T(1.0) + T(4.0) * tb)) / (T(-2.0) * tb);\n            XEvolv_o.v[i] = (vi - vi * sqrt(T(1.0) + T(4.0) * tb)) / (T(-2.0) * tb);\n        }\n\n    }\n\n\n\n}\ntemplate __global__ void XiafrictionGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float dt, float* cf, EvolvingP&lt;float&gt; XEvolv, EvolvingP&lt;float&gt; XEvolv_o);\ntemplate __global__ void XiafrictionGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double dt, double* cf, EvolvingP&lt;double&gt; XEvolv, EvolvingP&lt;double&gt; XEvolv_o);\n\n\ntemplate &lt;class T&gt; __host__ __device__ T smartfriction(T hi,T zo)\n{\n    T cfi;\n    T ee = T(2.71828182845905);\n\n    T Hbar = hi / zo;\n    if (Hbar &lt;= ee)\n    {\n        cfi = T(1.0) / (T(0.46) * Hbar);\n    }\n    else\n    {\n        cfi = T(1.0) / (T(2.5) * (log(Hbar) - T(1.0) + T(1.359) / Hbar));\n    }\n    cfi = cfi * cfi; //\n\n    return cfi;\n}\n\ntemplate &lt;class T&gt; __host__ __device__ T manningfriction(T g, T hi, T n)\n{\n    T cfi= g * n * n / cbrt(hi);\n    return cfi;\n}\n\n\n\n\ntemplate &lt;class T&gt; __global__ void TheresholdVelGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEvolv)\n{\n\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    bool bustedThreshold = false;\n\n\n    T ui, vi;\n\n\n    ui = XEvolv.u[i];\n    vi = XEvolv.v[i];\n\n    bustedThreshold = ThresholdVelocity(T(XParam.VelThreshold), ui, vi);\n\n    if (bustedThreshold)\n    {\n        XEvolv.u[i] = ui;\n        XEvolv.v[i] = vi;\n    }\n\n\n\n\n}\ntemplate __global__ void TheresholdVelGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEvolv);\ntemplate __global__ void TheresholdVelGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEvolv);\n\ntemplate &lt;class T&gt; __host__ void TheresholdVelCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEvolv)\n{\n\n    T ui, vi;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                bool bustedThreshold = false;\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                ui = XEvolv.u[i];\n\n                vi = XEvolv.v[i];\n\n                bustedThreshold = ThresholdVelocity(T(XParam.VelThreshold), ui, vi);\n\n                if (bustedThreshold)\n                {\n                    log(\"Velocity Threshold exceeded!\");\n                }\n                XEvolv.u[i] = ui;\n\n                XEvolv.v[i] = vi;\n            }\n        }\n    }\n}\ntemplate __host__ void TheresholdVelCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEvolv);\ntemplate __host__ void TheresholdVelCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEvolv);\n\ntemplate &lt;class T&gt; __host__ __device__ bool ThresholdVelocity(T Threshold, T&amp; u, T&amp; v)\n{\n    T normvel = sqrt(u * u + v * v);\n\n    bool alert = normvel &gt; Threshold;\n\n    if (alert)\n    {\n        u /= normvel / Threshold;\n        v /= normvel / Threshold;\n    }\n    return alert;\n}\n</code></pre>"},{"location":"BGFlood/Friction_8h/","title":"File Friction.h","text":""},{"location":"BGFlood/Friction_8h/#file-frictionh","title":"File Friction.h","text":"<p>FileList &gt; src &gt; Friction.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> </ul>"},{"location":"BGFlood/Friction_8h/#public-functions","title":"Public Functions","text":"Type Name __host__ void TheresholdVelCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEvolv) Function Used to prevent crazy velocity on the CPU. __global__ void TheresholdVelGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEvolv) Function Used to prevent crazy velocity on the GPU. __host__ __device__ bool ThresholdVelocity (T Threshold, T &amp; u, T &amp; v) Function Used to prevent crazy velocity. __host__ void XiafrictionCPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * cf, EvolvingP&lt; T &gt; XEvolv, EvolvingP&lt; T &gt; XEvolv_o)  __global__ void XiafrictionGPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * cf, EvolvingP&lt; T &gt; XEvolv, EvolvingP&lt; T &gt; XEvolv_o)  __host__ void bottomfrictionCPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * cf, EvolvingP&lt; T &gt; XEvolv)  __global__ void bottomfrictionGPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * cf, EvolvingP&lt; T &gt; XEvolv)  __host__ __device__ T manningfriction (T g, T hi, T n)  __host__ __device__ T smartfriction (T hi, T zo)"},{"location":"BGFlood/Friction_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Friction_8h/#function-theresholdvelcpu","title":"function TheresholdVelCPU","text":"<p>Function Used to prevent crazy velocity on the CPU. </p><pre><code>template&lt;class T&gt;\n__host__ void TheresholdVelCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEvolv\n) \n</code></pre> <p>The function wraps teh main functio for the CPU. </p>"},{"location":"BGFlood/Friction_8h/#function-theresholdvelgpu","title":"function TheresholdVelGPU","text":"<p>Function Used to prevent crazy velocity on the GPU. </p><pre><code>template&lt;class T&gt;\n__global__ void TheresholdVelGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEvolv\n) \n</code></pre> <p>The function wraps the main function for the GPU. </p>"},{"location":"BGFlood/Friction_8h/#function-thresholdvelocity","title":"function ThresholdVelocity","text":"<p>Function Used to prevent crazy velocity. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ bool ThresholdVelocity (\n    T Threshold,\n    T &amp; u,\n    T &amp; v\n) \n</code></pre> <p>The function scale velocities so it doesn't exceeds a given threshold. Default threshold is/should be 16.0m/s </p>"},{"location":"BGFlood/Friction_8h/#function-xiafrictioncpu","title":"function XiafrictionCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void XiafrictionCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * cf,\n    EvolvingP &lt; T &gt; XEvolv,\n    EvolvingP &lt; T &gt; XEvolv_o\n) \n</code></pre>"},{"location":"BGFlood/Friction_8h/#function-xiafrictiongpu","title":"function XiafrictionGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void XiafrictionGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * cf,\n    EvolvingP &lt; T &gt; XEvolv,\n    EvolvingP &lt; T &gt; XEvolv_o\n) \n</code></pre>"},{"location":"BGFlood/Friction_8h/#function-bottomfrictioncpu","title":"function bottomfrictionCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void bottomfrictionCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * cf,\n    EvolvingP &lt; T &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/Friction_8h/#function-bottomfrictiongpu","title":"function bottomfrictionGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void bottomfrictionGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * cf,\n    EvolvingP &lt; T &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/Friction_8h/#function-manningfriction","title":"function manningfriction","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T manningfriction (\n    T g,\n    T hi,\n    T n\n) \n</code></pre>"},{"location":"BGFlood/Friction_8h/#function-smartfriction","title":"function smartfriction","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T smartfriction (\n    T hi,\n    T zo\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Friction.h</code></p>"},{"location":"BGFlood/Friction_8h_source/","title":"File Friction.h","text":""},{"location":"BGFlood/Friction_8h_source/#file-frictionh","title":"File Friction.h","text":"<p>File List &gt; src &gt; Friction.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef FRICTION_H\n#define FRICTION_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n\ntemplate &lt;class T&gt; __global__ void bottomfrictionGPU(Param XParam, BlockP&lt;T&gt; XBlock,T dt, T* cf, EvolvingP&lt;T&gt; XEvolv);\ntemplate &lt;class T&gt; __host__ void bottomfrictionCPU(Param XParam, BlockP&lt;T&gt; XBlock,T dt, T* cf, EvolvingP&lt;T&gt; XEvolv);\n\ntemplate &lt;class T&gt; __host__ void XiafrictionCPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt, T* cf, EvolvingP&lt;T&gt; XEvolv, EvolvingP&lt;T&gt; XEvolv_o);\ntemplate &lt;class T&gt; __global__ void XiafrictionGPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt, T* cf, EvolvingP&lt;T&gt; XEvolv, EvolvingP&lt;T&gt; XEvolv_o);\n\ntemplate &lt;class T&gt; __host__ __device__ T smartfriction(T hi,T zo);\ntemplate &lt;class T&gt; __host__ __device__ T manningfriction(T g, T hi, T n);\n\ntemplate &lt;class T&gt; __host__ __device__ bool ThresholdVelocity(T Threshold, T&amp; u, T&amp; v);\n\ntemplate &lt;class T&gt; __global__ void TheresholdVelGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEvolv);\ntemplate &lt;class T&gt; __host__ void TheresholdVelCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEvolv);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/General_8h/","title":"File General.h","text":""},{"location":"BGFlood/General_8h/#file-generalh","title":"File General.h","text":"<p>FileList &gt; src &gt; General.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"cuda_runtime.h\"</code></li> <li><code>#include \"device_launch_parameters.h\"</code></li> <li><code>#include &lt;stdio.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;math.h&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;netcdf.h&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;iomanip&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;limits&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"BGFlood/General_8h/#macros","title":"Macros","text":"Type Name define pi <code>3.14159265</code>"},{"location":"BGFlood/General_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"BGFlood/General_8h/#define-pi","title":"define pi","text":"<pre><code>#define pi `3.14159265`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/General.h</code></p>"},{"location":"BGFlood/General_8h_source/","title":"File General.h","text":""},{"location":"BGFlood/General_8h_source/#file-generalh","title":"File General.h","text":"<p>File List &gt; src &gt; General.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef GENERAL_H\n#define GENERAL_H\n// includes, system\n\n#define pi 3.14159265\n\n#include \"cuda_runtime.h\"\n#include \"device_launch_parameters.h\"\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n#include &lt;cmath&gt;\n#include &lt;chrono&gt;\n#include &lt;ctime&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;netcdf.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n#include &lt;limits&gt; \n#include &lt;thread&gt;\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Gradients_8cu/","title":"File Gradients.cu","text":""},{"location":"BGFlood/Gradients_8cu/#file-gradientscu","title":"File Gradients.cu","text":"<p>FileList &gt; src &gt; Gradients.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Gradients.h\"</code></li> </ul>"},{"location":"BGFlood/Gradients_8cu/#public-functions","title":"Public Functions","text":"Type Name void WetsloperesetCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  void WetsloperesetHaloBotCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  __global__ void WetsloperesetHaloBotGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  void WetsloperesetHaloLeftCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  __global__ void WetsloperesetHaloLeftGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  void WetsloperesetHaloRightCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  __global__ void WetsloperesetHaloRightGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  void WetsloperesetHaloTopCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  __global__ void WetsloperesetHaloTopGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  __global__ void WetsloperesetXGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  __global__ void WetsloperesetYGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  __global__ void gradient (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx, T * dady)  template __global__ void gradient&lt; double &gt; (int halowidth, int * active, int * level, double theta, double dx, double * a, double * dadx, double * dady)  template __global__ void gradient&lt; float &gt; (int halowidth, int * active, int * level, float theta, float dx, float * a, float * dadx, float * dady)  void gradientC (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  template void gradientC&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * a, double * dadx, double * dady)  template void gradientC&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * a, float * dadx, float * dady)  void gradientCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  template void gradientCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, double * zb)  template void gradientCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, float * zb)  void gradientGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  template void gradientGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, double * zb)  template void gradientGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, float * zb)  void gradientGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  template void gradientGPUnew&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, double * zb)  template void gradientGPUnew&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, float * zb)  void gradientHalo (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  void gradientHaloBot (Param XParam, BlockP&lt; T &gt; XBlock, int ib, int ix, T * a, T * dadx, T * dady)  __global__ void gradientHaloBotGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  __global__ void gradientHaloBotGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  void gradientHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  void gradientHaloGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  void gradientHaloLeft (Param XParam, BlockP&lt; T &gt; XBlock, int ib, int iy, T * a, T * dadx, T * dady)  __global__ void gradientHaloLeftGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  __global__ void gradientHaloLeftGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  void gradientHaloRight (Param XParam, BlockP&lt; T &gt; XBlock, int ib, int iy, T * a, T * dadx, T * dady)  __global__ void gradientHaloRightGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  __global__ void gradientHaloRightGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  void gradientHaloTop (Param XParam, BlockP&lt; T &gt; XBlock, int ib, int ix, T * a, T * dadx, T * dady)  __global__ void gradientHaloTopGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  __global__ void gradientHaloTopGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  __global__ void gradientSM (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx, T * dady)  template __global__ void gradientSM&lt; double &gt; (int halowidth, int * active, int * level, double theta, double dx, double * a, double * dadx, double * dady)  template __global__ void gradientSM&lt; float &gt; (int halowidth, int * active, int * level, float theta, float dx, float * a, float * dadx, float * dady)  __global__ void gradientSMB (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx, T * dady)  template __global__ void gradientSMB&lt; double &gt; (int halowidth, int * active, int * level, double theta, double dx, double * a, double * dadx, double * dady)  template __global__ void gradientSMB&lt; float &gt; (int halowidth, int * active, int * level, float theta, float dx, float * a, float * dadx, float * dady)  __global__ void gradientSMC (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx, T * dady)  template __global__ void gradientSMC&lt; double &gt; (int halowidth, int * active, int * level, double theta, double dx, double * a, double * dadx, double * dady)  template __global__ void gradientSMC&lt; float &gt; (int halowidth, int * active, int * level, float theta, float dx, float * a, float * dadx, float * dady)  __global__ void gradientedgeX (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx)  template __global__ void gradientedgeX&lt; double &gt; (int halowidth, int * active, int * level, double theta, double dx, double * a, double * dadx)  template __global__ void gradientedgeX&lt; float &gt; (int halowidth, int * active, int * level, float theta, float dx, float * a, float * dadx)  __global__ void gradientedgeY (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dady)  template __global__ void gradientedgeY&lt; double &gt; (int halowidth, int * active, int * level, double theta, double dx, double * a, double * dady)  template __global__ void gradientedgeY&lt; float &gt; (int halowidth, int * active, int * level, float theta, float dx, float * a, float * dady)"},{"location":"BGFlood/Gradients_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Gradients_8cu/#function-wetsloperesetcpu","title":"function WetsloperesetCPU","text":"<pre><code>template&lt;class T&gt;\nvoid WetsloperesetCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-wetsloperesethalobotcpu","title":"function WetsloperesetHaloBotCPU","text":"<pre><code>template&lt;class T&gt;\nvoid WetsloperesetHaloBotCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-wetsloperesethalobotgpu","title":"function WetsloperesetHaloBotGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetHaloBotGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-wetsloperesethaloleftcpu","title":"function WetsloperesetHaloLeftCPU","text":"<pre><code>template&lt;class T&gt;\nvoid WetsloperesetHaloLeftCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-wetsloperesethaloleftgpu","title":"function WetsloperesetHaloLeftGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetHaloLeftGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-wetsloperesethalorightcpu","title":"function WetsloperesetHaloRightCPU","text":"<pre><code>template&lt;class T&gt;\nvoid WetsloperesetHaloRightCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-wetsloperesethalorightgpu","title":"function WetsloperesetHaloRightGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetHaloRightGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-wetsloperesethalotopcpu","title":"function WetsloperesetHaloTopCPU","text":"<pre><code>template&lt;class T&gt;\nvoid WetsloperesetHaloTopCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-wetsloperesethalotopgpu","title":"function WetsloperesetHaloTopGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetHaloTopGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-wetsloperesetxgpu","title":"function WetsloperesetXGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetXGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-wetsloperesetygpu","title":"function WetsloperesetYGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetYGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradient","title":"function gradient","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradient (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Device kernel for calculating grdients for an evolving poarameter using the minmod limiter </p>"},{"location":"BGFlood/Gradients_8cu/#function-gradient-double","title":"function gradient&lt; double &gt;","text":"<pre><code>template __global__ void gradient&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    double theta,\n    double dx,\n    double * a,\n    double * dadx,\n    double * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradient-float","title":"function gradient&lt; float &gt;","text":"<pre><code>template __global__ void gradient&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    float theta,\n    float dx,\n    float * a,\n    float * dadx,\n    float * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientc","title":"function gradientC","text":"<pre><code>template&lt;class T&gt;\nvoid gradientC (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientc-double","title":"function gradientC&lt; double &gt;","text":"<pre><code>template void gradientC&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * a,\n    double * dadx,\n    double * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientc-float","title":"function gradientC&lt; float &gt;","text":"<pre><code>template void gradientC&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * a,\n    float * dadx,\n    float * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientcpu","title":"function gradientCPU","text":"<pre><code>template&lt;class T&gt;\nvoid gradientCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientcpu-double","title":"function gradientCPU&lt; double &gt;","text":"<pre><code>template void gradientCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientcpu-float","title":"function gradientCPU&lt; float &gt;","text":"<pre><code>template void gradientCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientgpu","title":"function gradientGPU","text":"<pre><code>template&lt;class T&gt;\nvoid gradientGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Wrapping function to calculate gradien of evolving variables on GPU This function is the entry point to the gradient functions on the GPU </p>"},{"location":"BGFlood/Gradients_8cu/#function-gradientgpu-double","title":"function gradientGPU&lt; double &gt;","text":"<pre><code>template void gradientGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientgpu-float","title":"function gradientGPU&lt; float &gt;","text":"<pre><code>template void gradientGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientgpunew","title":"function gradientGPUnew","text":"<pre><code>template&lt;class T&gt;\nvoid gradientGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientgpunew-double","title":"function gradientGPUnew&lt; double &gt;","text":"<pre><code>template void gradientGPUnew&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientgpunew-float","title":"function gradientGPUnew&lt; float &gt;","text":"<pre><code>template void gradientGPUnew&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradienthalo","title":"function gradientHalo","text":"<pre><code>template&lt;class T&gt;\nvoid gradientHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradienthalobot","title":"function gradientHaloBot","text":"<pre><code>template&lt;class T&gt;\nvoid gradientHaloBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    int ib,\n    int ix,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradienthalobotgpu","title":"function gradientHaloBotGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientHaloBotGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradienthalobotgpunew","title":"function gradientHaloBotGPUnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientHaloBotGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradienthalogpu","title":"function gradientHaloGPU","text":"<pre><code>template&lt;class T&gt;\nvoid gradientHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradienthalogpunew","title":"function gradientHaloGPUnew","text":"<pre><code>template&lt;class T&gt;\nvoid gradientHaloGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradienthaloleft","title":"function gradientHaloLeft","text":"<pre><code>template&lt;class T&gt;\nvoid gradientHaloLeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    int ib,\n    int iy,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradienthaloleftgpu","title":"function gradientHaloLeftGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientHaloLeftGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradienthaloleftgpunew","title":"function gradientHaloLeftGPUnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientHaloLeftGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradienthaloright","title":"function gradientHaloRight","text":"<pre><code>template&lt;class T&gt;\nvoid gradientHaloRight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    int ib,\n    int iy,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradienthalorightgpu","title":"function gradientHaloRightGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientHaloRightGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradienthalorightgpunew","title":"function gradientHaloRightGPUnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientHaloRightGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradienthalotop","title":"function gradientHaloTop","text":"<pre><code>template&lt;class T&gt;\nvoid gradientHaloTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    int ib,\n    int ix,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradienthalotopgpu","title":"function gradientHaloTopGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientHaloTopGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradienthalotopgpunew","title":"function gradientHaloTopGPUnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientHaloTopGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientsm","title":"function gradientSM","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientSM (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Depreciated shared memory version of Device kernel for calculating gradients Much slower than above </p>"},{"location":"BGFlood/Gradients_8cu/#function-gradientsm-double","title":"function gradientSM&lt; double &gt;","text":"<pre><code>template __global__ void gradientSM&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    double theta,\n    double dx,\n    double * a,\n    double * dadx,\n    double * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientsm-float","title":"function gradientSM&lt; float &gt;","text":"<pre><code>template __global__ void gradientSM&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    float theta,\n    float dx,\n    float * a,\n    float * dadx,\n    float * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientsmb","title":"function gradientSMB","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientSMB (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientsmb-double","title":"function gradientSMB&lt; double &gt;","text":"<pre><code>template __global__ void gradientSMB&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    double theta,\n    double dx,\n    double * a,\n    double * dadx,\n    double * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientsmb-float","title":"function gradientSMB&lt; float &gt;","text":"<pre><code>template __global__ void gradientSMB&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    float theta,\n    float dx,\n    float * a,\n    float * dadx,\n    float * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientsmc","title":"function gradientSMC","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientSMC (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientsmc-double","title":"function gradientSMC&lt; double &gt;","text":"<pre><code>template __global__ void gradientSMC&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    double theta,\n    double dx,\n    double * a,\n    double * dadx,\n    double * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientsmc-float","title":"function gradientSMC&lt; float &gt;","text":"<pre><code>template __global__ void gradientSMC&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    float theta,\n    float dx,\n    float * a,\n    float * dadx,\n    float * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientedgex","title":"function gradientedgeX","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientedgeX (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientedgex-double","title":"function gradientedgeX&lt; double &gt;","text":"<pre><code>template __global__ void gradientedgeX&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    double theta,\n    double dx,\n    double * a,\n    double * dadx\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientedgex-float","title":"function gradientedgeX&lt; float &gt;","text":"<pre><code>template __global__ void gradientedgeX&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    float theta,\n    float dx,\n    float * a,\n    float * dadx\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientedgey","title":"function gradientedgeY","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientedgeY (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientedgey-double","title":"function gradientedgeY&lt; double &gt;","text":"<pre><code>template __global__ void gradientedgeY&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    double theta,\n    double dx,\n    double * a,\n    double * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8cu/#function-gradientedgey-float","title":"function gradientedgeY&lt; float &gt;","text":"<pre><code>template __global__ void gradientedgeY&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    float theta,\n    float dx,\n    float * a,\n    float * dady\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Gradients.cu</code></p>"},{"location":"BGFlood/Gradients_8cu_source/","title":"File Gradients.cu","text":""},{"location":"BGFlood/Gradients_8cu_source/#file-gradientscu","title":"File Gradients.cu","text":"<p>File List &gt; src &gt; Gradients.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Gradients.h\"\n\n\ntemplate &lt;class T&gt; void gradientGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad,T* zb)\n{\n    //const int num_streams = 4;\n    /*\n    cudaStream_t streams[num_streams];\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n    }\n    */\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 blockDimLR(1, XParam.blkwidth, 1);\n    dim3 blockDimBT(XParam.blkwidth, 1, 1);\n    dim3 blockDimLR2(2, XParam.blkwidth, 1);\n    dim3 blockDimBT2(XParam.blkwidth, 2, 1);\n    dim3 blockDimfull(XParam.blkmemwidth, XParam.blkmemwidth, 1);\n\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[1] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[2] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[3] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudx, XGrad.dudy);\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.u, XGrad.dudx, XGrad.dudy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[0] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdx, XGrad.dvdy);\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.v, XGrad.dvdx, XGrad.dvdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    //CUDA_CHECK(cudaDeviceSynchronize());\n    /*\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamDestroy(streams[i]);\n    }\n    */\n\n\n    //fillHaloGPU(XParam, XBlock, XGrad);\n    gradientHaloGPU(XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    gradientHaloGPU(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    gradientHaloGPU(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    gradientHaloGPU(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n\n    if (XParam.conserveElevation)\n    {\n        conserveElevationGradHaloGPU(XParam, XBlock, XEv.h, XEv.zs, zb, XGrad.dhdx, XGrad.dzsdx, XGrad.dhdy, XGrad.dzsdy);\n    }\n\n    //else\n    {\n        if (XParam.maxlevel &gt; XParam.minlevel)\n        {\n            refine_linearGPU(XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n            //refine_linearGPU(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n            refine_linearGPU(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n            refine_linearGPU(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n            if (XParam.conserveElevation)\n            {\n                conserveElevationGPU(XParam, XBlock, XEv, zb);\n            }\n\n      RecalculateZsGPU &lt;&lt;&lt; gridDim, blockDimfull, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n            CUDA_CHECK(cudaDeviceSynchronize());\n\n\n\n        //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[1] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdx, XGrad.dhdy);\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.h, XGrad.dhdx, XGrad.dhdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[2] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[3] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudx, XGrad.dudy);\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.u, XGrad.dudx, XGrad.dudy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[0] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdx, XGrad.dvdy);\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.v, XGrad.dvdx, XGrad.dvdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n\n            /*\n            gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.h, XGrad.dhdx);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            //gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth-1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdx);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n\n            gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.h, XGrad.dhdy);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            //gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT, 0&gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth-1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdy);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n\n            gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.zs, XGrad.dzsdx);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            //gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdx);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n\n            gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.zs, XGrad.dzsdy);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            //gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdy);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n\n            gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.u, XGrad.dudx);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            //gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudx);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n\n            gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.u, XGrad.dudy);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            //gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudy);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n\n            gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.v, XGrad.dvdx);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            //gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdx);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n\n            gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.v, XGrad.dvdy);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            //gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdy);\n            CUDA_CHECK(cudaDeviceSynchronize());\n            */\n\n\n            gradientHaloGPU(XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n            gradientHaloGPU(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n            gradientHaloGPU(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n            gradientHaloGPU(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n            if (XParam.conserveElevation)\n            {\n                conserveElevationGradHaloGPU(XParam, XBlock, XEv.h, XEv.zs, zb, XGrad.dhdx, XGrad.dzsdx, XGrad.dhdy, XGrad.dzsdy);\n            }\n        }\n        if (XParam.engine == 1)\n        {\n            //  wet slope limiter\n            WetsloperesetXGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n            CUDA_CHECK(cudaDeviceSynchronize());\n\n            WetsloperesetYGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n            CUDA_CHECK(cudaDeviceSynchronize());\n\n            // ALso do the slope limiter on the halo\n            WetsloperesetHaloLeftGPU &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n            CUDA_CHECK(cudaDeviceSynchronize());\n\n            WetsloperesetHaloRightGPU &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n            CUDA_CHECK(cudaDeviceSynchronize());\n\n            WetsloperesetHaloBotGPU &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n            CUDA_CHECK(cudaDeviceSynchronize());\n\n            WetsloperesetHaloTopGPU &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n\n            CUDA_CHECK(cudaDeviceSynchronize());\n        }\n\n    }\n    //conserveElevationGradHaloGPU(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    //conserveElevationGradHaloGPU(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    //conserveElevationGradHaloGPU(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n}\ntemplate void gradientGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt;XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, float * zb);\ntemplate void gradientGPU&lt;double&gt;(Param XParam,  BlockP&lt;double&gt;XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, double * zb);\n\ntemplate &lt;class T&gt; void gradientGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 blockDimLR(1, XParam.blkwidth, 1);\n    dim3 blockDimBT(XParam.blkwidth, 1, 1);\n    dim3 blockDimLR2(2, XParam.blkwidth, 1);\n    dim3 blockDimBT2(XParam.blkwidth, 2, 1);\n    dim3 blockDimfull(XParam.blkmemwidth, XParam.blkmemwidth, 1);\n\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    const int num_streams = 4;\n\n    cudaStream_t streams[num_streams];\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n    }\n\n    //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[1] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    gradientSMC &lt;&lt;&lt; gridDim, blockDim, 0, streams[0] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[2] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    gradientSMC &lt;&lt;&lt; gridDim, blockDim, 0, streams[1] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[3] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudx, XGrad.dudy);\n    gradientSMC &lt;&lt;&lt; gridDim, blockDim, 0, streams[2] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.u, XGrad.dudx, XGrad.dudy);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[0] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdx, XGrad.dvdy);\n    gradientSMC &lt;&lt;&lt; gridDim, blockDim, 0, streams[3] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.v, XGrad.dvdx, XGrad.dvdy);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    //CUDA_CHECK(cudaDeviceSynchronize());\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamDestroy(streams[i]);\n    }\n\n\n\n    //fillHaloGPU(XParam, XBlock, XGrad);\n    gradientHaloGPUnew(XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    gradientHaloGPUnew(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    gradientHaloGPUnew(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    gradientHaloGPUnew(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n    if (XParam.maxlevel &gt; XParam.minlevel)\n    {\n\n        if (XParam.conserveElevation)\n        {\n            conserveElevationGradHaloGPU(XParam, XBlock, XEv.h, XEv.zs, zb, XGrad.dhdx, XGrad.dzsdx, XGrad.dhdy, XGrad.dzsdy);\n        }\n\n\n        refine_linearGPU(XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n        //refine_linearGPU(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n        refine_linearGPU(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n        refine_linearGPU(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n        if (XParam.conserveElevation)\n        {\n            conserveElevationGPU(XParam, XBlock, XEv, zb);\n        }\n        else if (XParam.wetdryfix)\n        {\n            WetDryProlongationGPU(XParam, XBlock, XEv, zb);\n        }\n\n        RecalculateZsGPU &lt;&lt;&lt; gridDim, blockDimfull, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        /*\n        //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[1] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdx, XGrad.dhdy);\n        gradientSM &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdx, XGrad.dhdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[2] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n        gradientSM &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[3] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudx, XGrad.dudy);\n        gradientSM &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudx, XGrad.dudy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[0] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdx, XGrad.dvdy);\n        gradientSM &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdx, XGrad.dvdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        */\n        /*\n        const int num_streams = 16;\n\n        cudaStream_t streams[num_streams];\n\n        for (int i = 0; i &lt; num_streams; i++)\n        {\n            CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n        }\n        */\n\n\n\n        gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.h, XGrad.dhdx);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n        //gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth-1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdx);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.h, XGrad.dhdy);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n        //gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT, 0&gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth-1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdy);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.zs, XGrad.dzsdx);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n        //gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdx);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.zs, XGrad.dzsdy);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n        //gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdy);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.u, XGrad.dudx);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n        //gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudx);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.u, XGrad.dudy);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n        //gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudy);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.v, XGrad.dvdx);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n        //gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdx);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.v, XGrad.dvdy);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n        //gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        /*\n        for (int i = 0; i &lt; num_streams; i++)\n        {\n            cudaStreamDestroy(streams[i]);\n        }\n        */\n        gradientHaloGPUnew(XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n        gradientHaloGPUnew(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n        gradientHaloGPUnew(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n        gradientHaloGPUnew(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n        if (XParam.conserveElevation)\n        {\n            conserveElevationGradHaloGPU(XParam, XBlock, XEv.h, XEv.zs, zb, XGrad.dhdx, XGrad.dzsdx, XGrad.dhdy, XGrad.dzsdy);\n        }\n    }\n    if (XParam.engine == 1)\n    {\n        //  wet slope limiter\n        WetsloperesetXGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        WetsloperesetYGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        // ALso do the slope limiter on the halo\n        WetsloperesetHaloLeftGPU &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        WetsloperesetHaloRightGPU &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        WetsloperesetHaloBotGPU &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        WetsloperesetHaloTopGPU &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n\n    //conserveElevationGradHaloGPU(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    //conserveElevationGradHaloGPU(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    //conserveElevationGradHaloGPU(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n}\ntemplate void gradientGPUnew&lt;float&gt;(Param XParam, BlockP&lt;float&gt;XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, float* zb);\ntemplate void gradientGPUnew&lt;double&gt;(Param XParam, BlockP&lt;double&gt;XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, double* zb);\n\n\ntemplate &lt;class T&gt; __global__ void gradient(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx, T* dady)\n{\n    //int *leftblk,int *rightblk,int* topblk, int * botblk,\n\n    //int ix = threadIdx.x+1;\n    //int iy = threadIdx.y+1;\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = active[ibl];\n\n    int lev = level[ib];\n\n    T delta = calcres(dx, lev);\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    //int iright, ileft, ibot;\n    // shared array index to make the code bit more readable\n    //unsigned int sx = ix + halowidth;\n    //unsigned int sy = iy + halowidth;\n\n\n    T a_l, a_t, a_r, a_b,a_i;\n\n    a_i = a[i];\n\n\n    a_l = a[memloc(halowidth, blkmemwidth, ix - 1, iy, ib)];\n    a_t = a[memloc(halowidth, blkmemwidth, ix , iy + 1, ib)];\n    a_r = a[memloc(halowidth, blkmemwidth, ix + 1, iy, ib)];\n    a_b = a[memloc(halowidth, blkmemwidth, ix, iy - 1, ib)];\n    //__shared__ T a_s[18][18];\n\n\n\n    //__syncthreads();\n    //__syncwarp;\n\n    dadx[i] = minmod2(theta, a_l, a_i, a_r) / delta;\n\n    dady[i] = minmod2(theta, a_b, a_i, a_t) / delta;\n\n\n}\ntemplate __global__ void gradient&lt;float&gt;(int halowidth, int* active, int* level, float theta, float dx, float* a, float* dadx, float* dady);\ntemplate __global__ void gradient&lt;double&gt;(int halowidth, int* active, int* level, double theta, double dx, double* a, double* dadx, double* dady);\n\n\n\ntemplate &lt;class T&gt; __global__ void gradientSM(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx, T* dady)\n{\n    //int *leftblk,int *rightblk,int* topblk, int * botblk,\n\n    //int ix = threadIdx.x+1;\n    //int iy = threadIdx.y+1;\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = active[ibl];\n\n    int lev = level[ib];\n\n    T delta = calcres(dx, lev);\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    int iright, ileft, itop, ibot;\n    // shared array index to make the code bit more readable\n    int sx = ix + halowidth;\n    int sy = iy + halowidth;\n\n\n\n    __shared__ T a_s[18][18];\n\n\n\n    a_s[sx][sy] = a[i];\n\n    //syncthread is needed here ?\n\n\n    // read the halo around the tile\n    if (threadIdx.x == blockDim.x - 1)\n    {\n        iright = memloc(halowidth, blkmemwidth, ix + 1, iy, ib);\n        a_s[sx + 1][sy] = a[iright];\n\n    }\n\n\n    if (threadIdx.x == 0)\n    {\n        ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);;\n        a_s[sx - 1][sy] = a[ileft];\n\n    }\n\n    if (threadIdx.y == blockDim.y - 1)\n    {\n        itop = memloc(halowidth, blkmemwidth, ix, iy + 1, ib);;\n        a_s[sx][sy + 1] = a[itop];\n\n    }\n\n    if (threadIdx.y == 0)\n    {\n        ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n        a_s[sx][sy - 1] = a[ibot];\n\n    }\n\n    __syncthreads();\n\n\n\n    dadx[i] = minmod2(theta, a_s[sx - 1][sy], a_s[sx][sy], a_s[sx + 1][sy]) / delta;\n\n    dady[i] = minmod2(theta, a_s[sx][sy - 1], a_s[sx][sy], a_s[sx][sy + 1]) / delta;\n\n\n}\ntemplate __global__ void gradientSM&lt;float&gt;(int halowidth, int* active, int* level, float theta, float dx, float* a, float* dadx, float* dady);\ntemplate __global__ void gradientSM&lt;double&gt;(int halowidth, int* active, int* level, double theta, double dx, double* a, double* dadx, double* dady);\n\ntemplate &lt;class T&gt; __global__ void gradientSMB(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx, T* dady)\n{\n    //int *leftblk,int *rightblk,int* topblk, int * botblk,\n\n    //int ix = threadIdx.x+1;\n    //int iy = threadIdx.y+1;\n    int blkmemwidth = 18;\n    int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x-1;\n    int iy = threadIdx.y-1;\n    int ibl = blockIdx.x;\n    int ib = active[ibl];\n\n    int lev = level[ib];\n\n    T delta = calcres(dx, lev);\n\n\n\n    int iright, ileft, itop, ibot;\n    // shared array index to make the code bit more readable\n    int sx = ix + 1;\n    int sy = iy + 1;\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    //int o = memloc(halowidth, blkmemwidth, sx, sy, ib);\n\n    __shared__ T a_s[18][18];\n\n\n\n\n    a_s[sx][sy] = a[i];\n    __syncthreads();\n    //syncthread is needed here ?\n\n    T aleft, aright, atop, abot;\n    aleft = a_s[sx - 1][sy];\n    aright = a_s[sx + 1][sy];\n    atop = a_s[sx][sy + 1];\n    abot = a_s[sx][sy - 1];\n\n\n    if (ix &gt;= 0 &amp;&amp; ix &lt; 16 &amp;&amp; iy &gt;=0 &amp;&amp; iy &lt; 16)\n    {\n\n        dadx[i] = minmod2(theta, aleft, a_s[sx][sy], aright) / delta;\n\n        dady[i] = minmod2(theta, abot, a_s[sx][sy], atop) / delta;\n    }\n\n}\ntemplate __global__ void gradientSMB&lt;float&gt;(int halowidth, int* active, int* level, float theta, float dx, float* a, float* dadx, float* dady);\ntemplate __global__ void gradientSMB&lt;double&gt;(int halowidth, int* active, int* level, double theta, double dx, double* a, double* dadx, double* dady);\n\ntemplate &lt;class T&gt; __global__ void gradientSMC(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx, T* dady)\n{\n    //int *leftblk,int *rightblk,int* topblk, int * botblk,\n\n    //int ix = threadIdx.x+1;\n    //int iy = threadIdx.y+1;\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    int flatenwidth = blockDim.x * blockDim.y;\n    int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = active[ibl];\n\n    int lev = level[ib];\n\n    T delta = calcres(dx, lev);\n\n    int ism =ix + iy * blockDim.x;\n\n    int istore = ism + ib * (blkmemwidth * blkmemwidth);\n    //(i + halowidth) + (j + halowidth) * blkmemwidth + ib * (blkmemwidth * blkmemwidth);\n    //memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n\n    int ileft, iright, itop, ibot, i, iwrite;\n\n\n    // shared array index to make the code bit more readable\n    int sx = ix + halowidth;\n    int sy = iy + halowidth;\n\n\n\n    __shared__ T a_s[324];\n    //__shared__ T dadx_out[18 * 18];\n    //__shared__ T dady_out[18 * 18];\n    //__shared__ T a_s[324];\n    //__shared__ T a_left[324];\n    //__shared__ T a_right[324];\n    //__shared__ T a_top[324];\n    //__shared__ T a_bot[324];\n\n\n\n    //(i + halowidth) + (j + halowidth) * blkmemwidth + ib * (blkmemwidth * blkmemwidth);\n    //memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n//\n    a_s[ism] = a[istore];\n\n    if (ism &lt; (324 - (flatenwidth)))\n    {\n        a_s[ism + flatenwidth] = a[istore + flatenwidth];\n    }\n\n\n    __syncthreads();\n    i = memloc(halowidth, blkmemwidth, ix, iy, 0);\n    ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, 0);\n    iright = memloc(halowidth, blkmemwidth, ix + 1, iy, 0);\n    itop = memloc(halowidth, blkmemwidth, ix, iy + 1, 0);\n    ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, 0);\n    iwrite = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    //a_left[i] = a_s[ileft];\n    //a_right[i] = a_s[iright];\n    //a_top[i] = a_s[itop];\n    //a_bot[i] = a_s[ibot];\n\n    //dadx[iwrite] = minmod2(theta, a_left[i], a_s[i], a_right[i]) / delta;\n    //dady[iwrite] = minmod2(theta, a_bot[i], a_s[i], a_top[i]) / delta;\n    dadx[iwrite] = minmod2(theta, a_s[ileft], a_s[i], a_s[iright]) / delta;\n\n    dady[iwrite] = minmod2(theta, a_s[ibot], a_s[i], a_s[itop]) / delta;\n\n    /*\n    dadx_out[i] = minmod2(theta, a_s[ileft], a_s[i], a_s[iright]) / delta;\n    dady_out[i] = minmod2(theta, a_s[ibot], a_s[i], a_s[itop]) / delta;\n\n\n    dadx[istore] = dadx_out[ism];// = a[istore];\n    dady[istore] = dady_out[ism];\n\n    if (ism &lt; (324 - (flatenwidth)))\n    {\n        dadx[istore + flatenwidth] = dadx_out[ism + flatenwidth];\n        dady[istore + flatenwidth] = dady_out[ism + flatenwidth];\n    }\n    */\n\n\n}\ntemplate __global__ void gradientSMC&lt;float&gt;(int halowidth, int* active, int* level, float theta, float dx, float* a, float* dadx, float* dady);\ntemplate __global__ void gradientSMC&lt;double&gt;(int halowidth, int* active, int* level, double theta, double dx, double* a, double* dadx, double* dady);\n\n\n\ntemplate &lt;class T&gt; __global__ void gradientedgeX(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx)\n{\n    //int *leftblk,int *rightblk,int* topblk, int * botblk,\n\n    //int ix = threadIdx.x+1;\n    //int iy = threadIdx.y+1;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = threadIdx.x;\n    int ix;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = active[ibl];\n\n    if (threadIdx.x == 0)\n    {\n        ix = 0;\n    }\n    else\n    {\n        ix = blockDim.y - 1;\n    }\n\n\n    int lev = level[ib];\n\n    T delta = calcres(dx, lev);\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    //int iright, ileft, ibot;\n    // shared array index to make the code bit more readable\n    //unsigned int sx = ix + halowidth;\n    //unsigned int sy = iy + halowidth;\n\n\n    T a_l, a_r, a_i;\n\n    a_i = a[i];\n\n\n    a_l = a[memloc(halowidth, blkmemwidth, ix - 1, iy, ib)];\n    //a_t = a[memloc(halowidth, blkmemwidth, ix, iy + 1, ib)];\n    a_r = a[memloc(halowidth, blkmemwidth, ix + 1, iy, ib)];\n    //a_b = a[memloc(halowidth, blkmemwidth, ix, iy - 1, ib)];\n    //__shared__ T a_s[18][18];\n\n\n\n    //__syncthreads();\n    //__syncwarp;\n\n    dadx[i] = minmod2(theta, a_l, a_i, a_r) / delta;\n\n\n\n\n}\ntemplate __global__ void gradientedgeX&lt;float&gt;(int halowidth,  int* active, int* level, float theta, float dx, float* a, float* dadx);\ntemplate __global__ void gradientedgeX&lt;double&gt;(int halowidth, int* active, int* level, double theta, double dx, double* a, double* dadx);\n\n\n\ntemplate &lt;class T&gt; __global__ void gradientedgeY(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dady)\n{\n    //int *leftblk,int *rightblk,int* topblk, int * botblk,\n\n    //int ix = threadIdx.x+1;\n    //int iy = threadIdx.y+1;\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy;\n    //unsigned int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = active[ibl];\n\n    int lev = level[ib];\n\n    T delta = calcres(dx, lev);\n\n    if (threadIdx.y == 0)\n    {\n        iy = 0;\n    }\n    else\n    {\n        iy = blockDim.x - 1;\n    }\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    //int iright, ileft, ibot;\n    // shared array index to make the code bit more readable\n    //unsigned int sx = ix + halowidth;\n    //unsigned int sy = iy + halowidth;\n\n\n    T  a_t, a_b, a_i;\n\n    a_i = a[i];\n\n\n    //a_l = a[memloc(halowidth, blkmemwidth, ix - 1, iy, ib)];\n    a_t = a[memloc(halowidth, blkmemwidth, ix, iy + 1, ib)];\n    //a_r = a[memloc(halowidth, blkmemwidth, ix + 1, iy, ib)];\n    a_b = a[memloc(halowidth, blkmemwidth, ix, iy - 1, ib)];\n    //__shared__ T a_s[18][18];\n\n\n\n    //__syncthreads();\n    //__syncwarp;\n\n    //dadx[i] = minmod2(theta, a_l, a_i, a_r) / delta;\n\n    dady[i] = minmod2(theta, a_b, a_i, a_t) / delta;\n\n\n}\ntemplate __global__ void gradientedgeY&lt;float&gt;(int halowidth, int* active, int* level, float theta, float dx, float* a, float* dady);\ntemplate __global__ void gradientedgeY&lt;double&gt;(int halowidth, int* active, int* level, double theta, double dx, double* a, double* dady);\n\n\n\n\ntemplate &lt;class T&gt; void gradientC(Param XParam, BlockP&lt;T&gt; XBlock, T* a, T* dadx, T* dady)\n{\n\n    int i,ib;\n    int xplus, xminus, yplus, yminus;\n\n    T delta;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        delta = calcres(T(XParam.delta), XBlock.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                i = memloc(XParam, ix,iy,ib);\n\n                //\n                xplus = memloc(XParam, ix+1, iy, ib);\n                xminus = memloc(XParam, ix-1, iy, ib);\n                yplus = memloc(XParam, ix, iy+1, ib);\n                yminus = memloc(XParam, ix, iy-1, ib);\n\n                dadx[i] = minmod2(T(XParam.theta), a[xminus], a[i], a[xplus]) / delta;\n                dady[i] = minmod2(T(XParam.theta), a[yminus], a[i], a[yplus]) / delta;\n            }\n\n\n        }\n\n\n    }\n\n\n\n}\ntemplate void gradientC&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* a, float* dadx, float* dady);\ntemplate void gradientC&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* a, double* dadx, double* dady);\n\ntemplate &lt;class T&gt; void gradientCPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n\n\n    std::thread t0(&amp;gradientC&lt;T&gt;, XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    std::thread t1(&amp;gradientC&lt;T&gt;, XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    std::thread t2(&amp;gradientC&lt;T&gt;, XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    std::thread t3(&amp;gradientC&lt;T&gt;, XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n    t0.join();\n    t1.join();\n    t2.join();\n    t3.join();\n\n    //fillHalo(XParam, XBlock, XGrad);\n\n    gradientHalo(XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    gradientHalo(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    gradientHalo(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    gradientHalo(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n    if (XParam.conserveElevation)\n    {\n        conserveElevationGradHalo(XParam, XBlock, XEv.h, XEv.zs, zb, XGrad.dhdx, XGrad.dzsdx, XGrad.dhdy, XGrad.dzsdy);\n\n    }\n\n\n    refine_linear(XParam,XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    refine_linear(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    refine_linear(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n    if (XParam.conserveElevation)\n    {\n        conserveElevation(XParam, XBlock, XEv, zb);\n    }\n    else if (XParam.wetdryfix)\n    {\n        WetDryProlongation(XParam, XBlock, XEv, zb);\n    }\n\n    RecalculateZs(XParam, XBlock, XEv, zb);\n\n    std::thread t4(&amp;gradientC&lt;T&gt;, XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    std::thread t5(&amp;gradientC&lt;T&gt;, XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    std::thread t6(&amp;gradientC&lt;T&gt;, XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    std::thread t7(&amp;gradientC&lt;T&gt;, XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n    t4.join();\n    t5.join();\n    t6.join();\n    t7.join();\n\n    gradientHalo(XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    gradientHalo(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    gradientHalo(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    gradientHalo(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n    if (XParam.conserveElevation)\n    {\n        conserveElevationGradHalo(XParam, XBlock, XEv.h, XEv.zs, zb, XGrad.dhdx, XGrad.dzsdx, XGrad.dhdy, XGrad.dzsdy);\n\n    }\n\n    if (XParam.engine == 1)\n    {\n        WetsloperesetCPU(XParam, XBlock, XEv, XGrad, zb);\n\n        WetsloperesetHaloLeftCPU(XParam, XBlock, XEv, XGrad, zb);\n        WetsloperesetHaloRightCPU(XParam, XBlock, XEv, XGrad, zb);\n        WetsloperesetHaloBotCPU(XParam, XBlock, XEv, XGrad, zb);\n        WetsloperesetHaloTopCPU(XParam, XBlock, XEv, XGrad, zb);\n    }\n\n\n\n\n\n    //conserveElevationGradHalo(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    //conserveElevationGradHalo(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    //conserveElevationGradHalo(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdyythhhhhhhhhg);\n\n\n}\ntemplate void gradientCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt;XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, float * zb);\ntemplate void gradientCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt;XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, double * zb);\n\ntemplate &lt;class T&gt; void WetsloperesetCPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    int i, ib;\n    int xplus, xminus, yminus;\n\n    T delta;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        delta = calcres(T(XParam.delta), XBlock.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                i = memloc(XParam, ix, iy, ib);\n\n                //\n                xplus = memloc(XParam, ix + 1, iy, ib);\n                xminus = memloc(XParam, ix - 1, iy, ib);\n                //yplus = memloc(XParam, ix, iy + 1, ib);\n                yminus = memloc(XParam, ix, iy - 1, ib);\n\n                T dzsdxi = XGrad.dzsdx[i];\n                T dzsdyi = XGrad.dzsdy[i];\n\n\n\n\n                //Do X axis\n                if (utils::sq(dzsdxi) &gt; utils::sq(XGrad.dzbdx[i]))\n                {\n                    T leftzs, rightzs;\n                    leftzs = XEv.zs[i] - XEv.h[i] - delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n                    rightzs = XEv.zs[i] - XEv.h[i] + delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n\n                    if (leftzs &gt; XEv.zs[xminus] || rightzs &gt; XEv.zs[xplus])\n                    {\n                        XGrad.dzsdx[i] = XGrad.dhdx[i] + XGrad.dzbdx[i];\n                    }\n\n                }\n\n                //Do Y axis\n                if (utils::sq(dzsdyi) &gt; utils::sq(XGrad.dzbdy[i]))\n                {\n                    T botzs, topzs;\n                    botzs = XEv.zs[i] - XEv.h[i] - delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n                    topzs = XEv.zs[i] - XEv.h[i] + delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n\n                    if (botzs &gt; XEv.zs[yminus] || topzs &gt; XEv.zs[yminus])\n                    {\n                        XGrad.dzsdy[i] = XGrad.dhdy[i] + XGrad.dzbdy[i];\n                    }\n\n                }\n\n\n            }\n        }\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void WetsloperesetXGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n    T delta = calcres(XParam.delta, lev);\n\n\n    int i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n    int iright, ileft;\n    iright = memloc(XParam.halowidth, blkmemwidth, ix + 1, iy, ib);\n    ileft = memloc(XParam.halowidth, blkmemwidth, ix - 1, iy, ib);\n\n    T dzsdxi = XGrad.dzsdx[i];\n\n\n    if (utils::sq(dzsdxi) &gt; utils::sq(XGrad.dzbdx[i]))\n    {\n        T leftzs, rightzs;\n        leftzs = XEv.zs[i] - XEv.h[i] - delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n        rightzs = XEv.zs[i] - XEv.h[i] + delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n\n        if (leftzs &gt; XEv.zs[ileft] || rightzs &gt; XEv.zs[iright])\n        {\n            XGrad.dzsdx[i] = XGrad.dhdx[i] + XGrad.dzbdx[i];\n        }\n\n    }\n\n\n}\n\ntemplate &lt;class T&gt; __global__ void WetsloperesetYGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n    T delta = calcres(XParam.delta, lev);\n\n\n    int i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n    int itop, ibot;\n    itop = memloc(XParam.halowidth, blkmemwidth, ix, iy + 1, ib);\n    ibot = memloc(XParam.halowidth, blkmemwidth, ix, iy - 1, ib);\n\n    T dzsdyi = XGrad.dzsdy[i];\n\n\n    if (utils::sq(dzsdyi) &gt; utils::sq(XGrad.dzbdy[i]))\n    {\n        T botzs, topzs;\n        botzs = XEv.zs[i] - XEv.h[i] - delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n        topzs = XEv.zs[i] - XEv.h[i] + delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n\n        if (botzs &gt; XEv.zs[ibot] || topzs &gt; XEv.zs[itop])\n        {\n            XGrad.dzsdy[i] = XGrad.dhdy[i] + XGrad.dzbdy[i];\n        }\n\n    }\n\n\n}\n\n\ntemplate &lt;class T&gt; __global__ void WetsloperesetHaloLeftGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int ix = -1;\n    int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n\n    T delta = calcres(XParam.delta, lev);\n\n    T zsi, zsright, zsleft;\n\n    int i, iright;\n    i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n    iright = memloc(XParam.halowidth, blkmemwidth, ix + 1, iy, ib);\n\n    zsi = XEv.zs[i];\n    zsright = XEv.zs[iright];\n\n    int read, jj, ii, ir, it, itr;\n\n    if (XBlock.LeftBot[ib] == ib)//The lower half is a boundary \n    {\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            zsleft = XEv.zs[read];\n        }\n\n        if (XBlock.LeftTop[ib] == ib) // boundary on the top half too\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);\n\n                zsleft = XEv.zs[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                zsleft = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.LeftBot[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), iy, XBlock.LeftBot[ib]);\n        zsleft = XEv.zs[read];\n\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = iy * 2;\n            int bb = XBlock.LeftBot[ib];\n\n            ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, bb);\n            ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, bb);\n            it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, bb);\n            itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, bb);\n\n            zsleft = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.LeftTop[ib] == ib)\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);\n\n                zsleft = XEv.zs[read];\n            }\n        }\n        else\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                zsleft = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + XParam.blkwidth / 2;\n        T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 1), jj, XBlock.LeftBot[ib]);\n        ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), jj, XBlock.LeftBot[ib]);\n        it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 1), jj - 1, XBlock.LeftBot[ib]);\n        itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), jj - 1, XBlock.LeftBot[ib]);\n\n        zsleft = BilinearInterpolation(XEv.zs[itr], XEv.zs[ir], XEv.zs[it], XEv.zs[ii], T(0.0), T(1.0), T(0.0), T(1.0), T(0.75), jr);\n    }\n\n\n    T dzsdxi = XGrad.dzsdx[i];\n\n\n    if (utils::sq(dzsdxi) &gt; utils::sq(XGrad.dzbdx[i]))\n    {\n        T leftzs, rightzs;\n        leftzs = zsi - XEv.h[i] - delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n        rightzs = zsi - XEv.h[i] + delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n\n        if (leftzs &gt; zsleft || rightzs &gt; zsright)\n        {\n            XGrad.dzsdx[i] = XGrad.dhdx[i] + XGrad.dzbdx[i];\n        }\n\n    }\n\n\n}\n\ntemplate &lt;class T&gt; void WetsloperesetHaloLeftCPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n\n\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int ix = -1;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n\n        unsigned int ib = XBlock.active[ibl];\n\n        int lev = XBlock.level[ib];\n\n\n        T delta = calcres(XParam.delta, lev);\n\n        T zsi, zsright, zsleft;\n\n        for (int iy = 0; iy &lt;= XParam.blkwidth; iy++)\n        {\n\n            int i, iright;\n            i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n            iright = memloc(XParam.halowidth, blkmemwidth, ix + 1, iy, ib);\n\n            zsi = XEv.zs[i];\n            zsright = XEv.zs[iright];\n\n            int read, jj, ii, ir, it, itr;\n\n            if (XBlock.LeftBot[ib] == ib)//The lower half is a boundary \n            {\n                if (iy &lt; (XParam.blkwidth / 2))\n                {\n\n                    read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n                    zsleft = XEv.zs[read];\n                }\n\n                if (XBlock.LeftTop[ib] == ib) // boundary on the top half too\n                {\n                    if (iy &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n\n                        read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);\n\n                        zsleft = XEv.zs[read];\n                    }\n                }\n                else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n                {\n\n                    if (iy &gt;= (XParam.blkwidth / 2))\n                    {\n\n                        jj = (iy - XParam.blkwidth / 2) * 2;\n                        ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                        ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                        it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                        itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                        zsleft = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n\n                    }\n                }\n            }\n            else if (XBlock.level[ib] == XBlock.level[XBlock.LeftBot[ib]]) // LeftTop block does not exist\n            {\n\n                read = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), iy, XBlock.LeftBot[ib]);\n                zsleft = XEv.zs[read];\n\n            }\n            else if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])\n            {\n\n                if (iy &lt; (XParam.blkwidth / 2))\n                {\n\n                    jj = iy * 2;\n                    int bb = XBlock.LeftBot[ib];\n\n                    ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, bb);\n                    ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, bb);\n                    it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, bb);\n                    itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, bb);\n\n                    zsleft = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n                }\n                //now find out aboy lefttop block\n                if (XBlock.LeftTop[ib] == ib)\n                {\n                    if (iy &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n\n                        read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);\n\n                        zsleft = XEv.zs[read];\n                    }\n                }\n                else\n                {\n                    if (iy &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n                        jj = (iy - XParam.blkwidth / 2) * 2;\n                        ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                        ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                        it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                        itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                        zsleft = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n                    }\n                }\n\n            }\n            else if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n            {\n                jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib ? ftoi(ceil(iy * (T)0.5)) : ftoi(ceil(iy * (T)0.5) + XParam.blkwidth / 2);\n                T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n                ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 1), jj, XBlock.LeftBot[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), jj, XBlock.LeftBot[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 1), jj - 1, XBlock.LeftBot[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), jj - 1, XBlock.LeftBot[ib]);\n\n                zsleft = BilinearInterpolation(XEv.zs[itr], XEv.zs[ir], XEv.zs[it], XEv.zs[ii], T(0.0), T(1.0), T(0.0), T(1.0), T(0.75), jr);\n            }\n\n\n            T dzsdxi = XGrad.dzsdx[i];\n\n\n            if (utils::sq(dzsdxi) &gt; utils::sq(XGrad.dzbdx[i]))\n            {\n                T leftzs, rightzs;\n                leftzs = zsi - XEv.h[i] - delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n                rightzs = zsi - XEv.h[i] + delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n\n                if (leftzs &gt; zsleft || rightzs &gt; zsright)\n                {\n                    XGrad.dzsdx[i] = XGrad.dhdx[i] + XGrad.dzbdx[i];\n                }\n\n            }\n        }\n\n    }\n}\n\n\ntemplate &lt;class T&gt; __global__ void WetsloperesetHaloRightGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int ix = XParam.blkwidth;\n    int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n    int i, jj, ii, ir, it, itr;\n    int read;\n\n    int lev = XBlock.level[ib];\n\n    T delta = calcres(XParam.delta, lev);\n\n\n    i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n    int ileft;\n\n    ileft = memloc(XParam.halowidth, blkmemwidth, ix - 1, iy, ib);\n\n    T zsi, zsleft, zsright;\n\n    zsi = XEv.zs[i];\n    zsleft = XEv.zs[ileft];\n\n    T dzsdxi = XGrad.dzsdx[i];\n\n\n    if (XBlock.RightBot[ib] == ib)//The lower half is a boundary \n    {\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            zsright = XEv.zs[read];;\n        }\n\n        if (XBlock.RightTop[ib] == ib) // boundary on the top half too\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);\n\n                zsright = XEv.zs[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, XBlock.RightTop[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, XBlock.RightTop[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, XBlock.RightTop[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, XBlock.RightTop[ib]);\n\n                zsright = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.RightBot[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam.halowidth, blkmemwidth, 1, iy, XBlock.RightBot[ib]);\n        zsright = XEv.zs[read];\n\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = iy * 2;\n            int bb = XBlock.RightBot[ib];\n\n            ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, bb);\n            ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, bb);\n            it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, bb);\n            itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, bb);\n\n            zsright = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.RightTop[ib] == ib)\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);\n\n                zsright = XEv.zs[read];\n            }\n        }\n        else\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, XBlock.RightTop[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, XBlock.RightTop[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, XBlock.RightTop[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, XBlock.RightTop[ib]);\n\n                zsright = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + XParam.blkwidth / 2;\n        T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightBot[ib]);\n        ir = memloc(XParam.halowidth, blkmemwidth, 1, jj, XBlock.RightBot[ib]);\n        it = memloc(XParam.halowidth, blkmemwidth, 0, jj - 1, XBlock.RightBot[ib]);\n        itr = memloc(XParam.halowidth, blkmemwidth, 1, jj - 1, XBlock.RightBot[ib]);\n\n        zsright = BilinearInterpolation(XEv.zs[it], XEv.zs[ii], XEv.zs[itr], XEv.zs[ir], T(0.0), T(1.0), T(0.0), T(1.0), T(0.25), jr);\n    }\n\n\n\n\n\n\n\n    if (utils::sq(dzsdxi) &gt; utils::sq(XGrad.dzbdx[i]))\n    {\n        T leftzs, rightzs;\n        leftzs = zsi - XEv.h[i] - delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n        rightzs = zsi - XEv.h[i] + delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n\n        if (leftzs &gt; zsleft || rightzs &gt; zsright)\n        {\n            XGrad.dzsdx[i] = XGrad.dhdx[i] + XGrad.dzbdx[i];\n        }\n\n    }\n\n\n}\n\ntemplate &lt;class T&gt; void WetsloperesetHaloRightCPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int ix = XParam.blkwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n\n\n\n            unsigned int ib = XBlock.active[ibl];\n            int i, jj, ii, ir, it, itr;\n            int read;\n\n            int lev = XBlock.level[ib];\n\n            T delta = calcres(XParam.delta, lev);\n\n\n            i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n            int  ileft;\n\n            ileft = memloc(XParam.halowidth, blkmemwidth, ix - 1, iy, ib);\n\n            T zsi, zsleft, zsright;\n\n            zsi = XEv.zs[i];\n            zsleft = XEv.zs[ileft];\n\n            T dzsdxi = XGrad.dzsdx[i];\n\n\n            if (XBlock.RightBot[ib] == ib)//The lower half is a boundary \n            {\n                if (iy &lt; (XParam.blkwidth / 2))\n                {\n\n                    read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n                    zsright = XEv.zs[read];;\n                }\n\n                if (XBlock.RightTop[ib] == ib) // boundary on the top half too\n                {\n                    if (iy &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n\n                        read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);\n\n                        zsright = XEv.zs[read];\n                    }\n                }\n                else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n                {\n\n                    if (iy &gt;= (XParam.blkwidth / 2))\n                    {\n\n                        jj = (iy - XParam.blkwidth / 2) * 2;\n                        ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, XBlock.RightTop[ib]);\n                        ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, XBlock.RightTop[ib]);\n                        it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, XBlock.RightTop[ib]);\n                        itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, XBlock.RightTop[ib]);\n\n                        zsright = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n\n                    }\n                }\n            }\n            else if (XBlock.level[ib] == XBlock.level[XBlock.RightBot[ib]]) // LeftTop block does not exist\n            {\n\n                read = memloc(XParam.halowidth, blkmemwidth, 1, iy, XBlock.RightBot[ib]);\n                zsright = XEv.zs[read];\n\n            }\n            else if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])\n            {\n\n                if (iy &lt; (XParam.blkwidth / 2))\n                {\n\n                    jj = iy * 2;\n                    int bb = XBlock.RightBot[ib];\n\n                    ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, bb);\n                    ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, bb);\n                    it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, bb);\n                    itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, bb);\n\n                    zsright = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n                }\n                //now find out aboy lefttop block\n                if (XBlock.RightTop[ib] == ib)\n                {\n                    if (iy &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n\n                        read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);\n\n                        zsright = XEv.zs[read];\n                    }\n                }\n                else\n                {\n                    if (iy &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n                        jj = (iy - XParam.blkwidth / 2) * 2;\n                        ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, XBlock.RightTop[ib]);\n                        ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, XBlock.RightTop[ib]);\n                        it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, XBlock.RightTop[ib]);\n                        itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, XBlock.RightTop[ib]);\n\n                        zsright = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n                    }\n                }\n\n            }\n            else if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n            {\n                jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? ftoi(ceil(iy * (T)0.5)) : ftoi(ceil(iy * (T)0.5) + XParam.blkwidth / 2);\n                T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n                ii = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightBot[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, 1, jj, XBlock.RightBot[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, 0, jj - 1, XBlock.RightBot[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, 1, jj - 1, XBlock.RightBot[ib]);\n\n                zsright = BilinearInterpolation(XEv.zs[it], XEv.zs[ii], XEv.zs[itr], XEv.zs[ir], T(0.0), T(1.0), T(0.0), T(1.0), T(0.25), jr);\n            }\n\n\n\n\n\n\n\n            if (utils::sq(dzsdxi) &gt; utils::sq(XGrad.dzbdx[i]))\n            {\n                T leftzs, rightzs;\n                leftzs = zsi - XEv.h[i] - delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n                rightzs = zsi - XEv.h[i] + delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n\n                if (leftzs &gt; zsleft || rightzs &gt; zsright)\n                {\n                    XGrad.dzsdx[i] = XGrad.dhdx[i] + XGrad.dzbdx[i];\n                }\n\n            }\n        }\n\n    }\n}\n\n\ntemplate &lt;class T&gt; __global__ void WetsloperesetHaloBotGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int iy = -1;\n    int ix = threadIdx.x;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i, jj, ii, ir, it, itr;\n\n    int lev = XBlock.level[ib];\n\n    T delta = calcres(XParam.delta, lev);\n\n\n    i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n    int itop,read;\n    itop = memloc(XParam.halowidth, blkmemwidth, ix, iy + 1, ib);\n\n    T zsi, zstop, zsbot;\n\n    T dzsdyi = XGrad.dzsdy[i];\n\n    zsi = XEv.zs[i];\n    zstop = XEv.zs[itop];\n\n\n    if (XBlock.BotLeft[ib] == ib)//The lower half is a boundary \n    {\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            zsbot = XEv.zs[read];\n\n        }\n\n        if (XBlock.BotRight[ib] == ib) // boundary on the top half too\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);\n\n                zsbot = XEv.zs[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                zsbot = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.BotLeft[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam.halowidth, blkmemwidth, ix, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n        zsbot = XEv.zs[read];\n\n\n\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = ix * 2;\n            int bb = XBlock.BotLeft[ib];\n\n            ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), bb);\n            ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), bb);\n            it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), bb);\n            itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), bb);\n\n            zsbot = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.BotRight[ib] == ib)\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);\n\n                zsbot = XEv.zs[read];\n            }\n        }\n        else\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                zsbot = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + XParam.blkwidth / 2;\n        T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n        ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n        it = memloc(XParam.halowidth, blkmemwidth, jj - 1, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n        itr = memloc(XParam.halowidth, blkmemwidth, jj - 1, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n\n        zsbot = BilinearInterpolation(XEv.zs[itr], XEv.zs[it], XEv.zs[ir], XEv.zs[ii], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.75));\n    }\n\n\n    if (utils::sq(dzsdyi) &gt; utils::sq(XGrad.dzbdy[i]))\n    {\n        T botzs, topzs;\n        botzs = zsi - XEv.h[i] - delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n        topzs = zsi - XEv.h[i] + delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n\n        if (botzs &gt; zsbot || topzs &gt; zstop)\n        {\n            XGrad.dzsdy[i] = XGrad.dhdy[i] + XGrad.dzbdy[i];\n        }\n\n    }\n\n\n}\n\ntemplate &lt;class T&gt; void WetsloperesetHaloBotCPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int iy = -1;\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n\n\n        unsigned int ib = XBlock.active[ibl];\n\n\n\n        int i, jj, ii, ir, it, itr;\n\n        int lev = XBlock.level[ib];\n\n        T delta = calcres(XParam.delta, lev);\n\n        for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n        {\n\n\n            i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n            int itop, read;\n            itop = memloc(XParam.halowidth, blkmemwidth, ix, iy + 1, ib);\n\n            T zsi, zstop, zsbot;\n\n            T dzsdyi = XGrad.dzsdy[i];\n\n            zsi = XEv.zs[i];\n            zstop = XEv.zs[itop];\n\n\n            if (XBlock.BotLeft[ib] == ib)//The lower half is a boundary \n            {\n                if (ix &lt; (XParam.blkwidth / 2))\n                {\n\n                    read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n                    zsbot = XEv.zs[read];\n\n                }\n\n                if (XBlock.BotRight[ib] == ib) // boundary on the top half too\n                {\n                    if (ix &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n\n                        read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);\n\n                        zsbot = XEv.zs[read];\n                    }\n                }\n                else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n                {\n\n                    if (ix &gt;= (XParam.blkwidth / 2))\n                    {\n\n                        jj = (ix - XParam.blkwidth / 2) * 2;\n                        ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                        ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                        it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                        itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                        zsbot = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n\n                    }\n                }\n            }\n            else if (XBlock.level[ib] == XBlock.level[XBlock.BotLeft[ib]]) // LeftTop block does not exist\n            {\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n                zsbot = XEv.zs[read];\n\n\n\n            }\n            else if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n            {\n\n                if (ix &lt; (XParam.blkwidth / 2))\n                {\n\n                    jj = ix * 2;\n                    int bb = XBlock.BotLeft[ib];\n\n                    ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), bb);\n                    ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), bb);\n                    it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), bb);\n                    itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), bb);\n\n                    zsbot = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n                }\n                //now find out aboy lefttop block\n                if (XBlock.BotRight[ib] == ib)\n                {\n                    if (ix &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n\n                        read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);\n\n                        zsbot = XEv.zs[read];\n                    }\n                }\n                else\n                {\n                    if (ix &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n                        jj = (ix - XParam.blkwidth / 2) * 2;\n                        ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                        ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                        it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                        itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                        zsbot = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n                    }\n                }\n\n            }\n            else if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n            {\n                jj = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? ftoi(ceil(ix * (T)0.5)) : ftoi(ceil(ix * (T)0.5) + XParam.blkwidth / 2);\n                T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj - 1, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj - 1, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n\n                zsbot = BilinearInterpolation(XEv.zs[itr], XEv.zs[it], XEv.zs[ir], XEv.zs[ii], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.75));\n            }\n\n\n            if (utils::sq(dzsdyi) &gt; utils::sq(XGrad.dzbdy[i]))\n            {\n                T botzs, topzs;\n                botzs = zsi - XEv.h[i] - delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n                topzs = zsi - XEv.h[i] + delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n\n                if (botzs &gt; zsbot || topzs &gt; zstop)\n                {\n                    XGrad.dzsdy[i] = XGrad.dhdy[i] + XGrad.dzbdy[i];\n                }\n\n            }\n        }\n\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void WetsloperesetHaloTopGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int iy = XParam.blkwidth;\n    int ix = threadIdx.x;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i, jj, ii, ir, it, itr;\n\n    int lev = XBlock.level[ib];\n\n    T delta = calcres(XParam.delta, lev);\n\n\n    i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n    int ibot, read;\n\n    ibot = memloc(XParam.halowidth, blkmemwidth, ix, iy - 1, ib);\n\n    T zsi, zstop, zsbot;\n\n    zsi = XEv.zs[i];\n    zsbot = XEv.zs[ibot];\n\n    T dzsdyi = XGrad.dzsdy[i];\n\n\n    if (XBlock.TopLeft[ib] == ib)//The lower half is a boundary \n    {\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            zstop = XEv.zs[read];\n\n        }\n\n        if (XBlock.TopRight[ib] == ib) // boundary on the top half too\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n                zstop = XEv.zs[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, XBlock.TopRight[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, XBlock.TopRight[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, XBlock.TopRight[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, XBlock.TopRight[ib]);\n\n                zstop = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.TopLeft[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam.halowidth, blkmemwidth, ix, 1, XBlock.TopLeft[ib]);\n        zstop = XEv.zs[read];\n\n\n\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = ix * 2;\n            int bb = XBlock.TopLeft[ib];;\n\n            ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, bb);\n            ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, bb);\n            it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, bb);\n            itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, bb);\n\n            zstop = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.TopRight[ib] == ib)\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n                zstop = XEv.zs[read];\n            }\n        }\n        else\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, XBlock.TopRight[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, XBlock.TopRight[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, XBlock.TopRight[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, XBlock.TopRight[ib]);\n\n                zstop = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + XParam.blkwidth / 2;\n        T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam.halowidth, blkmemwidth, jj, 0, XBlock.TopLeft[ib]);\n        ir = memloc(XParam.halowidth, blkmemwidth, jj, 1, XBlock.TopLeft[ib]);\n        it = memloc(XParam.halowidth, blkmemwidth, jj - 1, 0, XBlock.TopLeft[ib]);\n        itr = memloc(XParam.halowidth, blkmemwidth, jj - 1, 1, XBlock.TopLeft[ib]);\n\n        zstop = BilinearInterpolation(XEv.zs[it], XEv.zs[itr], XEv.zs[ii], XEv.zs[ir], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.25));\n    }\n\n\n    if (utils::sq(dzsdyi) &gt; utils::sq(XGrad.dzbdy[i]))\n    {\n        T botzs, topzs;\n        botzs = zsi - XEv.h[i] - delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n        topzs = zsi - XEv.h[i] + delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n\n        if (botzs &gt; zsbot || topzs &gt; zstop)\n        {\n            XGrad.dzsdy[i] = XGrad.dhdy[i] + XGrad.dzbdy[i];\n        }\n\n    }\n\n\n}\n\n\n\ntemplate &lt;class T&gt;  void WetsloperesetHaloTopCPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int iy = XParam.blkwidth;\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        unsigned int ib = XBlock.active[ibl];\n\n        int i, jj, ii, ir, it, itr;\n\n        int lev = XBlock.level[ib];\n\n        T delta = calcres(XParam.delta, lev);\n\n        for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n        {\n\n            i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n            int ibot, read;\n\n            ibot = memloc(XParam.halowidth, blkmemwidth, ix, iy - 1, ib);\n\n            T zsi, zstop, zsbot;\n\n            zsi = XEv.zs[i];\n            zsbot = XEv.zs[ibot];\n\n            T dzsdyi = XGrad.dzsdy[i];\n\n\n            if (XBlock.TopLeft[ib] == ib)//The lower half is a boundary \n            {\n                if (ix &lt; (XParam.blkwidth / 2))\n                {\n\n                    read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n                    zstop = XEv.zs[read];\n\n                }\n\n                if (XBlock.TopRight[ib] == ib) // boundary on the top half too\n                {\n                    if (ix &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n\n                        read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n                        zstop = XEv.zs[read];\n                    }\n                }\n                else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n                {\n\n                    if (ix &gt;= (XParam.blkwidth / 2))\n                    {\n\n                        jj = (ix - XParam.blkwidth / 2) * 2;\n                        ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, XBlock.TopRight[ib]);\n                        ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, XBlock.TopRight[ib]);\n                        it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, XBlock.TopRight[ib]);\n                        itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, XBlock.TopRight[ib]);\n\n                        zstop = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n\n                    }\n                }\n            }\n            else if (XBlock.level[ib] == XBlock.level[XBlock.TopLeft[ib]]) // LeftTop block does not exist\n            {\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, 1, XBlock.TopLeft[ib]);\n                zstop = XEv.zs[read];\n\n\n\n            }\n            else if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n            {\n\n                if (ix &lt; (XParam.blkwidth / 2))\n                {\n\n                    jj = ix * 2;\n                    int bb = XBlock.TopLeft[ib];;\n\n                    ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, bb);\n                    ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, bb);\n                    it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, bb);\n                    itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, bb);\n\n                    zstop = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n                }\n                //now find out aboy lefttop block\n                if (XBlock.TopRight[ib] == ib)\n                {\n                    if (ix &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n\n                        read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n                        zstop = XEv.zs[read];\n                    }\n                }\n                else\n                {\n                    if (ix &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n                        jj = (ix - XParam.blkwidth / 2) * 2;\n                        ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, XBlock.TopRight[ib]);\n                        ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, XBlock.TopRight[ib]);\n                        it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, XBlock.TopRight[ib]);\n                        itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, XBlock.TopRight[ib]);\n\n                        zstop = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n                    }\n                }\n\n            }\n            else if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n            {\n                jj = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? ftoi(ceil(ix * (T)0.5)) : ftoi(ceil(ix * (T)0.5) + XParam.blkwidth / 2);\n                T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, 0, XBlock.TopLeft[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, 1, XBlock.TopLeft[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj - 1, 0, XBlock.TopLeft[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj - 1, 1, XBlock.TopLeft[ib]);\n\n                zstop = BilinearInterpolation(XEv.zs[it], XEv.zs[itr], XEv.zs[ii], XEv.zs[ir], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.25));\n            }\n\n\n            if (utils::sq(dzsdyi) &gt; utils::sq(XGrad.dzbdy[i]))\n            {\n                T botzs, topzs;\n                botzs = zsi - XEv.h[i] - delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n                topzs = zsi - XEv.h[i] + delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n\n                if (botzs &gt; zsbot || topzs &gt; zstop)\n                {\n                    XGrad.dzsdy[i] = XGrad.dhdy[i] + XGrad.dzbdy[i];\n                }\n\n            }\n        }\n    }\n\n\n}\n\n\ntemplate &lt;class T&gt; void gradientHalo(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    int ib;\n    //int xplus;\n\n    //T delta;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            gradientHaloLeft(XParam, XBlock, ib, iy, a, dadx, dady);\n            gradientHaloRight(XParam, XBlock, ib, iy, a, dadx, dady);\n        }\n        for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n        {\n            gradientHaloBot(XParam, XBlock, ib, ix, a, dadx, dady);\n            gradientHaloTop(XParam, XBlock, ib, ix, a, dadx, dady);\n        }\n    }\n}\n\n\ntemplate &lt;class T&gt; void gradientHaloGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    dim3 blockDimL(1, XParam.blkwidth, 1);\n    dim3 blockDimB(XParam.blkwidth, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n\n    gradientHaloLeftGPU &lt;&lt;&lt; gridDim, blockDimL, 0 &gt;&gt;&gt; (XParam, XBlock, a, dadx, dady);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradientHaloRightGPU &lt;&lt;&lt; gridDim, blockDimL, 0 &gt;&gt;&gt; (XParam, XBlock, a, dadx, dady);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradientHaloBotGPU &lt;&lt;&lt; gridDim, blockDimB, 0 &gt;&gt;&gt; (XParam, XBlock, a, dadx, dady);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradientHaloTopGPU &lt;&lt;&lt; gridDim, blockDimB, 0 &gt;&gt;&gt; (XParam, XBlock, a, dadx, dady);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n}\n\ntemplate &lt;class T&gt; void gradientHaloGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    const int num_streams = 4;\n\n    cudaStream_t streams[num_streams];\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n    }\n\n    dim3 blockDimL(2, XParam.blkwidth, 1);\n    dim3 blockDimB(XParam.blkwidth, 2, 1);\n    dim3 gridDim(ceil(XParam.nblk/2), 1, 1);\n\n\n    gradientHaloLeftGPUnew &lt;&lt;&lt; gridDim, blockDimL, 0, streams[0] &gt;&gt;&gt; (XParam, XBlock, a, dadx, dady);\n\n\n    gradientHaloRightGPUnew &lt;&lt;&lt; gridDim, blockDimL, 0, streams[1] &gt;&gt;&gt; (XParam, XBlock, a, dadx, dady);\n\n\n    gradientHaloBotGPUnew &lt;&lt;&lt; gridDim, blockDimB, 0, streams[2] &gt;&gt;&gt; (XParam, XBlock, a, dadx, dady);\n\n\n    gradientHaloTopGPUnew &lt;&lt;&lt; gridDim, blockDimB, 0, streams[3] &gt;&gt;&gt; (XParam, XBlock, a, dadx, dady);\n\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamDestroy(streams[i]);\n    }\n\n\n}\n\n\ntemplate &lt;class T&gt; void gradientHaloLeft(Param XParam, BlockP&lt;T&gt;XBlock, int ib, int iy, T* a, T* dadx, T* dady)\n{\n    int i, ix, jj, ii, ir, it, itr;\n    int xplus, read;\n\n    T delta, aright, aleft;\n\n    ix = -1;\n\n    i = memloc(XParam, ix, iy, ib);\n    xplus = memloc(XParam, ix + 1, iy, ib);\n\n\n    aright = a[xplus];\n\n\n\n    delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n    if (XBlock.LeftBot[ib] == ib)//The lower half is a boundary \n    {\n        if ( iy &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam, 0, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            aleft = a[read];\n        }\n\n        if (XBlock.LeftTop[ib] == ib) // boundary on the top half too\n        {\n            if ( iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam, 0, iy, ib);\n\n                aleft = a[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                ir = memloc(XParam, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                it = memloc(XParam, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                itr = memloc(XParam, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.LeftBot[ib]]) // LeftTop block does not exist\n    {\n\n            read = memloc(XParam, (XParam.blkwidth - 2), iy, XBlock.LeftBot[ib]);\n            aleft = a[read];\n\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (iy &lt; (XParam.blkwidth / 2))\n        {   \n\n            jj = iy * 2;\n            int bb = XBlock.LeftBot[ib];\n\n            ii = memloc(XParam, (XParam.blkwidth - 3), jj, bb);\n            ir = memloc(XParam, (XParam.blkwidth - 4), jj, bb);\n            it = memloc(XParam, (XParam.blkwidth - 3), jj + 1, bb);\n            itr = memloc(XParam, (XParam.blkwidth - 4), jj + 1, bb);\n\n            aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.LeftTop[ib] == ib)\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam, 0, iy, ib);\n\n                aleft = a[read];\n            }\n        }\n        else\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                ir = memloc(XParam, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                it = memloc(XParam, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                itr = memloc(XParam, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib ? ftoi(ceil(iy * (T)0.5)) : ftoi(ceil(iy * (T)0.5) + XParam.blkwidth / 2);\n        //T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.75) : T(0.25);// This is the wrong way around\n        T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75); // This is right (e.g. at iy==0 use 0.75 at iy==1 use 0.25)\n\n        ii = memloc(XParam, (XParam.blkwidth - 1), jj, XBlock.LeftBot[ib]);\n        ir = memloc(XParam, (XParam.blkwidth - 2), jj, XBlock.LeftBot[ib]);\n        it = memloc(XParam, (XParam.blkwidth - 1), jj - 1, XBlock.LeftBot[ib]);\n        itr = memloc(XParam, (XParam.blkwidth - 2), jj - 1, XBlock.LeftBot[ib]);\n\n        aleft = BilinearInterpolation(a[itr], a[ir], a[it], a[ii], T(0.0), T(1.0), T(0.0), T(1.0), T(0.75), jr);\n    }\n\n\n\n\n\n    dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n    //dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n\n}\n\n\ntemplate &lt;class T&gt; void gradientHaloRight(Param XParam, BlockP&lt;T&gt;XBlock, int ib, int iy, T* a, T* dadx, T* dady)\n{\n    int i, ix, jj, ii, ir, it, itr;\n    int xminus, read;\n\n    T delta, aright, aleft;\n\n    ix = 16;\n\n    i = memloc(XParam, ix, iy, ib);\n    xminus = memloc(XParam, ix - 1, iy, ib);\n\n\n    aleft = a[xminus];\n\n\n\n    delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n    if (XBlock.RightBot[ib] == ib)//The lower half is a boundary \n    {\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam, XParam.blkwidth -1, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            aright = a[read];\n        }\n\n        if (XBlock.RightTop[ib] == ib) // boundary on the top half too\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam, XParam.blkwidth - 1, iy, ib);\n\n                aright = a[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of righttopib is levelib+1\n        {\n\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, 3, jj, XBlock.RightTop[ib]);\n                ir = memloc(XParam, 2, jj, XBlock.RightTop[ib]);\n                it = memloc(XParam, 3, jj + 1, XBlock.RightTop[ib]);\n                itr = memloc(XParam, 2, jj + 1, XBlock.RightTop[ib]);\n\n                aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.RightBot[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam, 1, iy, XBlock.RightBot[ib]);\n        aright = a[read];\n\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = iy * 2;\n            int bb = XBlock.RightBot[ib];\n\n            ii = memloc(XParam, 3, jj, bb);\n            ir = memloc(XParam, 2, jj, bb);\n            it = memloc(XParam, 3, jj + 1, bb);\n            itr = memloc(XParam, 2, jj + 1, bb);\n\n            aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.RightTop[ib] == ib)\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam, XParam.blkwidth - 1, iy, ib);\n\n                aright = a[read];\n            }\n        }\n        else\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, 3, jj, XBlock.RightTop[ib]);\n                ir = memloc(XParam, 2, jj, XBlock.RightTop[ib]);\n                it = memloc(XParam, 3, jj + 1, XBlock.RightTop[ib]);\n                itr = memloc(XParam, 2, jj + 1, XBlock.RightTop[ib]);\n\n                aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? ftoi(ceil(iy * (T)0.5)) : ftoi(ceil(iy * (T)0.5) + XParam.blkwidth / 2);\n        T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam, 0, jj, XBlock.RightBot[ib]);\n        ir = memloc(XParam, 1, jj, XBlock.RightBot[ib]);\n        it = memloc(XParam, 0, jj - 1, XBlock.RightBot[ib]);\n        itr = memloc(XParam, 1, jj - 1, XBlock.RightBot[ib]);\n\n        aright = BilinearInterpolation(a[it], a[ii], a[itr], a[ir], T(0.0), T(1.0), T(0.0), T(1.0), T(0.25), jr);\n    }\n\n\n\n\n\n    dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n    //dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n\n}\n\n\ntemplate &lt;class T&gt; void gradientHaloBot(Param XParam, BlockP&lt;T&gt;XBlock, int ib, int ix, T* a, T* dadx, T* dady)\n{\n    int i, iy, jj, ii, ir, it, itr;\n    int yplus, read;\n\n    T delta, atop, abot;\n\n    iy = -1;\n\n    i = memloc(XParam, ix, iy, ib);\n    yplus = memloc(XParam, ix , iy + 1, ib);\n\n\n\n\n    atop = a[yplus];\n\n\n\n    delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n    if (XBlock.BotLeft[ib] == ib)//The lower half is a boundary \n    {\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam, ix, 0, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            abot = a[read];\n\n        }\n\n        if (XBlock.BotRight[ib] == ib) // boundary on the top half too\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam, ix, 0, ib);\n\n                abot = a[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                ir = memloc(XParam, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                it = memloc(XParam, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                itr = memloc(XParam, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.BotLeft[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam, ix, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n        abot = a[read];\n\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = ix * 2;\n            int bb = XBlock.BotLeft[ib];\n\n            ii = memloc(XParam, jj, (XParam.blkwidth - 3), bb);\n            ir = memloc(XParam, jj, (XParam.blkwidth - 4), bb);\n            it = memloc(XParam, jj + 1, (XParam.blkwidth - 3), bb);\n            itr = memloc(XParam, jj + 1, (XParam.blkwidth - 4), bb);\n\n            abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.BotRight[ib] == ib)\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam, ix, 0, ib);\n\n                abot = a[read];\n            }\n        }\n        else\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                ir = memloc(XParam, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                it = memloc(XParam, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                itr = memloc(XParam, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? ftoi(ceil(ix * (T)0.5)) : ftoi(ceil(ix * (T)0.5) + XParam.blkwidth / 2);\n        T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam, jj, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n        ir = memloc(XParam, jj, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n        it = memloc(XParam, jj - 1, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n        itr = memloc(XParam, jj - 1, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n\n        abot = BilinearInterpolation(a[itr], a[it], a[ir], a[ii], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.75));\n    }\n\n\n\n\n\n    //dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n    dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n\n}\n\ntemplate &lt;class T&gt; void gradientHaloTop(Param XParam, BlockP&lt;T&gt;XBlock, int ib, int ix, T* a, T* dadx, T* dady)\n{\n    int i, iy, jj, ii, ir, it, itr;\n    int yminus, read;\n\n    T delta, atop, abot;\n\n    iy = XParam.blkwidth;\n\n    i = memloc(XParam, ix, iy, ib);\n    yminus = memloc(XParam, ix, XParam.blkwidth-1, ib);\n\n\n\n\n    abot = a[yminus];\n\n\n\n    delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n    if (XBlock.TopLeft[ib] == ib)//The lower half is a boundary \n    {\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam, ix, XParam.blkwidth - 1, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            atop = a[read];\n\n        }\n\n        if (XBlock.TopRight[ib] == ib) // boundary on the top half too\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam, ix, XParam.blkwidth - 1, ib);\n\n                atop = a[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, jj, 3, XBlock.TopRight[ib]);\n                ir = memloc(XParam, jj, 2, XBlock.TopRight[ib]);\n                it = memloc(XParam, jj + 1, 3, XBlock.TopRight[ib]);\n                itr = memloc(XParam, jj + 1, 2, XBlock.TopRight[ib]);\n\n                atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.TopLeft[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam, ix, 1, XBlock.TopLeft[ib]);\n        atop = a[read];\n\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = ix * 2;\n            int bb = XBlock.TopLeft[ib];\n\n            ii = memloc(XParam, jj, 3, bb);\n            ir = memloc(XParam, jj, 2, bb);\n            it = memloc(XParam, jj + 1, 3, bb);\n            itr = memloc(XParam, jj + 1, 2, bb);\n\n            atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.TopRight[ib] == ib)\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam, ix, XParam.blkwidth - 1, ib);\n\n                atop = a[read];\n            }\n        }\n        else\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, jj, 3, XBlock.TopRight[ib]);\n                ir = memloc(XParam, jj, 2, XBlock.TopRight[ib]);\n                it = memloc(XParam, jj + 1, 3, XBlock.TopRight[ib]);\n                itr = memloc(XParam, jj + 1, 2, XBlock.TopRight[ib]);\n\n                atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? ftoi(ceil(ix * (T)0.5)) : ftoi(ceil(ix * (T)0.5) + XParam.blkwidth / 2);\n        T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam, jj, 0, XBlock.TopLeft[ib]);\n        ir = memloc(XParam, jj, 1, XBlock.TopLeft[ib]);\n        it = memloc(XParam, jj - 1, 0, XBlock.TopLeft[ib]);\n        itr = memloc(XParam, jj - 1, 1, XBlock.TopLeft[ib]);\n\n        atop = BilinearInterpolation(a[it], a[itr], a[ii], a[ir], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.25));\n    }\n\n\n\n\n\n    //dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n    dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n\n}\n\n\n\ntemplate &lt;class T&gt; __global__ void gradientHaloLeftGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int ix = -1;\n    int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n    int i, jj, ii, ir, it, itr;\n    int xplus, read;\n\n    T delta, aright, aleft;\n\n\n\n    i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n    xplus = memloc(XParam.halowidth, blkmemwidth, ix + 1, iy, ib);\n\n\n    aright = a[xplus];\n\n\n\n    delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n    if (XBlock.LeftBot[ib] == ib)//The lower half is a boundary \n    {\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            aleft = a[read];\n        }\n\n        if (XBlock.LeftTop[ib] == ib) // boundary on the top half too\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);\n\n                aleft = a[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.LeftBot[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), iy, XBlock.LeftBot[ib]);\n        aleft = a[read];\n\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = iy * 2;\n            int bb = XBlock.LeftBot[ib];\n\n            ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, bb);\n            ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, bb);\n            it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, bb);\n            itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, bb);\n\n            aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.LeftTop[ib] == ib)\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);\n\n                aleft = a[read];\n            }\n        }\n        else\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + XParam.blkwidth / 2;\n        T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 1), jj, XBlock.LeftBot[ib]);\n        ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), jj, XBlock.LeftBot[ib]);\n        it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 1), jj - 1, XBlock.LeftBot[ib]);\n        itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), jj - 1, XBlock.LeftBot[ib]);\n\n        aleft = BilinearInterpolation(a[itr], a[ir], a[it], a[ii], T(0.0), T(1.0), T(0.0), T(1.0), T(0.75), jr);\n    }\n\n\n\n\n\n    dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n    //dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n\n}\n\ntemplate &lt;class T&gt; __global__ void gradientHaloLeftGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int ix = -1;\n    int iy = threadIdx.y;\n\n    int ibl = threadIdx.x + blockIdx.x * blockDim.x;;\n    if (ibl &lt; XParam.nblk)\n    {\n\n        int ib = XBlock.active[ibl];\n        int i, jj, ii, ir, it, itr;\n        int xplus, read;\n\n        T delta, aright, aleft;\n\n\n\n        i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n        xplus = memloc(XParam.halowidth, blkmemwidth, ix + 1, iy, ib);\n\n\n        aright = a[xplus];\n\n\n\n        delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n        if (XBlock.LeftBot[ib] == ib)//The lower half is a boundary \n        {\n            if (iy &lt; (XParam.blkwidth / 2))\n            {\n\n                read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n                aleft = a[read];\n            }\n\n            if (XBlock.LeftTop[ib] == ib) // boundary on the top half too\n            {\n                if (iy &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n\n                    read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);\n\n                    aleft = a[read];\n                }\n            }\n            else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n            {\n\n                if (iy &gt;= (XParam.blkwidth / 2))\n                {\n\n                    jj = (iy - XParam.blkwidth / 2) * 2;\n                    ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                    ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                    it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                    itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                    aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n                }\n            }\n        }\n        else if (XBlock.level[ib] == XBlock.level[XBlock.LeftBot[ib]]) // LeftTop block does not exist\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), iy, XBlock.LeftBot[ib]);\n            aleft = a[read];\n\n        }\n        else if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])\n        {\n\n            if (iy &lt; (XParam.blkwidth / 2))\n            {\n\n                jj = iy * 2;\n                int bb = XBlock.LeftBot[ib];\n\n                ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, bb);\n                ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, bb);\n                it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, bb);\n                itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, bb);\n\n                aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n            //now find out aboy lefttop block\n            if (XBlock.LeftTop[ib] == ib)\n            {\n                if (iy &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n\n                    read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);\n\n                    aleft = a[read];\n                }\n            }\n            else\n            {\n                if (iy &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n                    jj = (iy - XParam.blkwidth / 2) * 2;\n                    ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                    ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                    it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                    itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                    aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n\n        }\n        else if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n        {\n            jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + XParam.blkwidth / 2;\n            T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n            ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 1), jj, XBlock.LeftBot[ib]);\n            ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), jj, XBlock.LeftBot[ib]);\n            it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 1), jj - 1, XBlock.LeftBot[ib]);\n            itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), jj - 1, XBlock.LeftBot[ib]);\n\n            aleft = BilinearInterpolation(a[itr], a[ir], a[it], a[ii], T(0.0), T(1.0), T(0.0), T(1.0), T(0.75), jr);\n        }\n\n\n\n\n\n        dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n        //dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void gradientHaloRightGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int ix = XParam.blkwidth;\n    int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n    int i, jj, ii, ir, it, itr;\n    int xminus, read;\n\n    T delta, aright, aleft;\n\n\n\n    i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n    xminus = memloc(XParam.halowidth, blkmemwidth, ix - 1, iy, ib);\n\n\n    aleft = a[xminus];\n\n\n\n    delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n    if (XBlock.RightBot[ib] == ib)//The lower half is a boundary \n    {\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            aright = a[read];;\n        }\n\n        if (XBlock.RightTop[ib] == ib) // boundary on the top half too\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);\n\n                aright = a[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, XBlock.RightTop[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, XBlock.RightTop[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, XBlock.RightTop[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, XBlock.RightTop[ib]);\n\n                aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.RightBot[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam.halowidth, blkmemwidth, 1, iy, XBlock.RightBot[ib]);\n        aright = a[read];\n\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = iy * 2;\n            int bb = XBlock.RightBot[ib];\n\n            ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, bb);\n            ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, bb);\n            it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, bb);\n            itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, bb);\n\n            aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.RightTop[ib] == ib)\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);\n\n                aright = a[read];\n            }\n        }\n        else\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, XBlock.RightTop[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, XBlock.RightTop[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, XBlock.RightTop[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, XBlock.RightTop[ib]);\n\n                aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + XParam.blkwidth / 2;\n        T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightBot[ib]);\n        ir = memloc(XParam.halowidth, blkmemwidth, 1, jj, XBlock.RightBot[ib]);\n        it = memloc(XParam.halowidth, blkmemwidth, 0, jj - 1, XBlock.RightBot[ib]);\n        itr = memloc(XParam.halowidth, blkmemwidth, 1, jj - 1, XBlock.RightBot[ib]);\n\n        aright = BilinearInterpolation(a[it], a[ii], a[itr], a[ir], T(0.0), T(1.0), T(0.0), T(1.0), T(0.25), jr);\n    }\n\n\n\n\n\n    dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n    //dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n\n}\n\n\ntemplate &lt;class T&gt; __global__ void gradientHaloRightGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int ix = XParam.blkwidth;\n    int iy = threadIdx.y;\n    int ibl = threadIdx.x + blockIdx.x * blockDim.x;;\n    if (ibl &lt; XParam.nblk)\n    {\n        int ib = XBlock.active[ibl];\n        int i, jj, ii, ir, it, itr;\n        int xminus, read;\n\n        T delta, aright, aleft;\n\n\n\n        i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n        xminus = memloc(XParam.halowidth, blkmemwidth, ix - 1, iy, ib);\n\n\n        aleft = a[xminus];\n\n\n\n        delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n        if (XBlock.RightBot[ib] == ib)//The lower half is a boundary \n        {\n            if (iy &lt; (XParam.blkwidth / 2))\n            {\n\n                read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n                aright = a[read];;\n            }\n\n            if (XBlock.RightTop[ib] == ib) // boundary on the top half too\n            {\n                if (iy &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n\n                    read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);\n\n                    aright = a[read];\n                }\n            }\n            else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n            {\n\n                if (iy &gt;= (XParam.blkwidth / 2))\n                {\n\n                    jj = (iy - XParam.blkwidth / 2) * 2;\n                    ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, XBlock.RightTop[ib]);\n                    ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, XBlock.RightTop[ib]);\n                    it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, XBlock.RightTop[ib]);\n                    itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, XBlock.RightTop[ib]);\n\n                    aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n                }\n            }\n        }\n        else if (XBlock.level[ib] == XBlock.level[XBlock.RightBot[ib]]) // LeftTop block does not exist\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, 1, iy, XBlock.RightBot[ib]);\n            aright = a[read];\n\n        }\n        else if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])\n        {\n\n            if (iy &lt; (XParam.blkwidth / 2))\n            {\n\n                jj = iy * 2;\n                int bb = XBlock.RightBot[ib];\n\n                ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, bb);\n                ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, bb);\n                it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, bb);\n                itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, bb);\n\n                aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n            //now find out aboy lefttop block\n            if (XBlock.RightTop[ib] == ib)\n            {\n                if (iy &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n\n                    read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);\n\n                    aright = a[read];\n                }\n            }\n            else\n            {\n                if (iy &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n                    jj = (iy - XParam.blkwidth / 2) * 2;\n                    ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, XBlock.RightTop[ib]);\n                    ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, XBlock.RightTop[ib]);\n                    it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, XBlock.RightTop[ib]);\n                    itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, XBlock.RightTop[ib]);\n\n                    aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n\n        }\n        else if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n        {\n            jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + XParam.blkwidth / 2;\n            T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n            ii = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightBot[ib]);\n            ir = memloc(XParam.halowidth, blkmemwidth, 1, jj, XBlock.RightBot[ib]);\n            it = memloc(XParam.halowidth, blkmemwidth, 0, jj - 1, XBlock.RightBot[ib]);\n            itr = memloc(XParam.halowidth, blkmemwidth, 1, jj - 1, XBlock.RightBot[ib]);\n\n            aright = BilinearInterpolation(a[it], a[ii], a[itr], a[ir], T(0.0), T(1.0), T(0.0), T(1.0), T(0.25), jr);\n        }\n\n\n\n\n\n        dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n        //dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void gradientHaloBotGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int iy = -1;\n    int ix = threadIdx.x;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n\n    int i, jj, ii, ir, it, itr;\n    int yplus, read;\n\n    T delta, atop, abot;\n\n\n    i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n    yplus = memloc(XParam.halowidth, blkmemwidth, ix, iy + 1, ib);\n\n\n\n\n    atop = a[yplus];\n\n\n\n    delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n    if (XBlock.BotLeft[ib] == ib)//The lower half is a boundary \n    {\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            abot = a[read];\n\n        }\n\n        if (XBlock.BotRight[ib] == ib) // boundary on the top half too\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);\n\n                abot = a[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.BotLeft[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam.halowidth, blkmemwidth, ix, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n        abot = a[read];\n\n\n\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = ix * 2;\n            int bb = XBlock.BotLeft[ib];\n\n            ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), bb);\n            ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), bb);\n            it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), bb);\n            itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), bb);\n\n            abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.BotRight[ib] == ib)\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);\n\n                abot = a[read];\n            }\n        }\n        else\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + XParam.blkwidth / 2;\n        T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n        ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n        it = memloc(XParam.halowidth, blkmemwidth, jj - 1, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n        itr = memloc(XParam.halowidth, blkmemwidth, jj - 1, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n\n        abot = BilinearInterpolation(a[itr], a[it], a[ir], a[ii], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.75));\n    }\n\n\n\n\n\n    //dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n    dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n\n}\n\ntemplate &lt;class T&gt; __global__ void gradientHaloBotGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int iy = -1;\n    int ix = threadIdx.x;\n    int ibl = threadIdx.y + blockIdx.x * blockDim.y;\n    if (ibl &lt; XParam.nblk)\n    {\n        int ib = XBlock.active[ibl];\n\n\n        int i, jj, ii, ir, it, itr;\n        int yplus, read;\n\n        T delta, atop, abot;\n\n\n        i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n        yplus = memloc(XParam.halowidth, blkmemwidth, ix, iy + 1, ib);\n\n\n\n\n        atop = a[yplus];\n\n\n\n        delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n        if (XBlock.BotLeft[ib] == ib)//The lower half is a boundary \n        {\n            if (ix &lt; (XParam.blkwidth / 2))\n            {\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n                abot = a[read];\n\n            }\n\n            if (XBlock.BotRight[ib] == ib) // boundary on the top half too\n            {\n                if (ix &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n\n                    read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);\n\n                    abot = a[read];\n                }\n            }\n            else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n            {\n\n                if (ix &gt;= (XParam.blkwidth / 2))\n                {\n\n                    jj = (ix - XParam.blkwidth / 2) * 2;\n                    ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                    ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                    it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                    itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                    abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n                }\n            }\n        }\n        else if (XBlock.level[ib] == XBlock.level[XBlock.BotLeft[ib]]) // LeftTop block does not exist\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, ix, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n            abot = a[read];\n\n\n\n        }\n        else if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n        {\n\n            if (ix &lt; (XParam.blkwidth / 2))\n            {\n\n                jj = ix * 2;\n                int bb = XBlock.BotLeft[ib];\n\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), bb);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), bb);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), bb);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), bb);\n\n                abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n            //now find out aboy lefttop block\n            if (XBlock.BotRight[ib] == ib)\n            {\n                if (ix &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n\n                    read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);\n\n                    abot = a[read];\n                }\n            }\n            else\n            {\n                if (ix &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n                    jj = (ix - XParam.blkwidth / 2) * 2;\n                    ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                    ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                    it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                    itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                    abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n\n        }\n        else if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n        {\n            jj = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + XParam.blkwidth / 2;\n            T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n            ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n            ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n            it = memloc(XParam.halowidth, blkmemwidth, jj - 1, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n            itr = memloc(XParam.halowidth, blkmemwidth, jj - 1, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n\n            abot = BilinearInterpolation(a[itr], a[it], a[ir], a[ii], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.75));\n        }\n\n\n\n\n\n        //dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n        dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n    }\n}\n\n\ntemplate &lt;class T&gt; __global__ void gradientHaloTopGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int iy = XParam.blkwidth;\n    int ix = threadIdx.x;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n\n    int i, jj, ii, ir, it, itr;\n    int yminus, read;\n\n    T delta, atop, abot;\n\n\n    i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n    yminus = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n\n\n\n    abot = a[yminus];\n\n\n\n    delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n    if (XBlock.TopLeft[ib] == ib)//The lower half is a boundary \n    {\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            atop = a[read];\n\n        }\n\n        if (XBlock.TopRight[ib] == ib) // boundary on the top half too\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n                atop = a[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, XBlock.TopRight[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, XBlock.TopRight[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, XBlock.TopRight[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, XBlock.TopRight[ib]);\n\n                atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.TopLeft[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam.halowidth, blkmemwidth, ix, 1, XBlock.TopLeft[ib]);\n        atop = a[read];\n\n\n\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = ix * 2;\n            int bb = XBlock.TopLeft[ib];;\n\n            ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, bb);\n            ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, bb);\n            it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, bb);\n            itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, bb);\n\n            atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.TopRight[ib] == ib)\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n                atop = a[read];\n            }\n        }\n        else\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, XBlock.TopRight[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, XBlock.TopRight[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, XBlock.TopRight[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, XBlock.TopRight[ib]);\n\n                atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + XParam.blkwidth / 2;\n        T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam.halowidth, blkmemwidth, jj, 0, XBlock.TopLeft[ib]);\n        ir = memloc(XParam.halowidth, blkmemwidth, jj, 1, XBlock.TopLeft[ib]);\n        it = memloc(XParam.halowidth, blkmemwidth, jj - 1, 0, XBlock.TopLeft[ib]);\n        itr = memloc(XParam.halowidth, blkmemwidth, jj - 1, 1, XBlock.TopLeft[ib]);\n\n        atop = BilinearInterpolation(a[it], a[itr], a[ii], a[ir], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.25));\n    }\n\n\n\n\n\n    //dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n    dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n\n}\n\ntemplate &lt;class T&gt; __global__ void gradientHaloTopGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int iy = XParam.blkwidth;\n    int ix = threadIdx.x;\n\n\n    int ibl = threadIdx.y + blockIdx.x * blockDim.y;\n    if (ibl &lt; XParam.nblk)\n    {\n        int ib = XBlock.active[ibl];\n\n\n        int i, jj, ii, ir, it, itr;\n        int yminus, read;\n\n        T delta, atop, abot;\n\n\n        i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n        yminus = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n\n\n\n        abot = a[yminus];\n\n\n\n        delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n        if (XBlock.TopLeft[ib] == ib)//The lower half is a boundary \n        {\n            if (ix &lt; (XParam.blkwidth / 2))\n            {\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n                atop = a[read];\n\n            }\n\n            if (XBlock.TopRight[ib] == ib) // boundary on the top half too\n            {\n                if (ix &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n\n                    read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n                    atop = a[read];\n                }\n            }\n            else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n            {\n\n                if (ix &gt;= (XParam.blkwidth / 2))\n                {\n\n                    jj = (ix - XParam.blkwidth / 2) * 2;\n                    ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, XBlock.TopRight[ib]);\n                    ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, XBlock.TopRight[ib]);\n                    it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, XBlock.TopRight[ib]);\n                    itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, XBlock.TopRight[ib]);\n\n                    atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n                }\n            }\n        }\n        else if (XBlock.level[ib] == XBlock.level[XBlock.TopLeft[ib]]) // LeftTop block does not exist\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, ix, 1, XBlock.TopLeft[ib]);\n            atop = a[read];\n\n\n\n        }\n        else if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n        {\n\n            if (ix &lt; (XParam.blkwidth / 2))\n            {\n\n                jj = ix * 2;\n                int bb = XBlock.TopLeft[ib];;\n\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, bb);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, bb);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, bb);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, bb);\n\n                atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n            //now find out aboy lefttop block\n            if (XBlock.TopRight[ib] == ib)\n            {\n                if (ix &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n\n                    read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n                    atop = a[read];\n                }\n            }\n            else\n            {\n                if (ix &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n                    jj = (ix - XParam.blkwidth / 2) * 2;\n                    ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, XBlock.TopRight[ib]);\n                    ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, XBlock.TopRight[ib]);\n                    it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, XBlock.TopRight[ib]);\n                    itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, XBlock.TopRight[ib]);\n\n                    atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n\n        }\n        else if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n        {\n            jj = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + XParam.blkwidth / 2;\n            T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n            ii = memloc(XParam.halowidth, blkmemwidth, jj, 0, XBlock.TopLeft[ib]);\n            ir = memloc(XParam.halowidth, blkmemwidth, jj, 1, XBlock.TopLeft[ib]);\n            it = memloc(XParam.halowidth, blkmemwidth, jj - 1, 0, XBlock.TopLeft[ib]);\n            itr = memloc(XParam.halowidth, blkmemwidth, jj - 1, 1, XBlock.TopLeft[ib]);\n\n            atop = BilinearInterpolation(a[it], a[itr], a[ii], a[ir], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.25));\n        }\n\n\n\n\n\n        //dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n        dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n    }\n}\n</code></pre>"},{"location":"BGFlood/Gradients_8h/","title":"File Gradients.h","text":""},{"location":"BGFlood/Gradients_8h/#file-gradientsh","title":"File Gradients.h","text":"<p>FileList &gt; src &gt; Gradients.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Setup_GPU.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Halo.h\"</code></li> </ul>"},{"location":"BGFlood/Gradients_8h/#public-functions","title":"Public Functions","text":"Type Name __global__ void WetsloperesetHaloBotGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  __global__ void WetsloperesetHaloLeftGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  __global__ void WetsloperesetHaloRightGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  __global__ void WetsloperesetHaloTopGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  __global__ void WetsloperesetXGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  __global__ void WetsloperesetYGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  __global__ void gradient (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx, T * dady)  void gradientC (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  void gradientCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  void gradientGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  void gradientGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb)  void gradientHalo (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  __global__ void gradientHaloBotGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  __global__ void gradientHaloBotGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  void gradientHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  __global__ void gradientHaloLeftGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  __global__ void gradientHaloLeftGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  __global__ void gradientHaloRightGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  __global__ void gradientHaloRightGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  __global__ void gradientHaloTopGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  __global__ void gradientHaloTopGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady)  __global__ void gradientSM (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx, T * dady)  __global__ void gradientSMB (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx, T * dady)  __global__ void gradientSMC (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx, T * dady)  __global__ void gradientedgeX (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx)  __global__ void gradientedgeY (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dady)"},{"location":"BGFlood/Gradients_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Gradients_8h/#function-wetsloperesethalobotgpu","title":"function WetsloperesetHaloBotGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetHaloBotGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-wetsloperesethaloleftgpu","title":"function WetsloperesetHaloLeftGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetHaloLeftGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-wetsloperesethalorightgpu","title":"function WetsloperesetHaloRightGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetHaloRightGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-wetsloperesethalotopgpu","title":"function WetsloperesetHaloTopGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetHaloTopGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-wetsloperesetxgpu","title":"function WetsloperesetXGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetXGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-wetsloperesetygpu","title":"function WetsloperesetYGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetYGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-gradient","title":"function gradient","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradient (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Device kernel for calculating grdients for an evolving poarameter using the minmod limiter </p>"},{"location":"BGFlood/Gradients_8h/#function-gradientc","title":"function gradientC","text":"<pre><code>template&lt;class T&gt;\nvoid gradientC (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-gradientcpu","title":"function gradientCPU","text":"<pre><code>template&lt;class T&gt;\nvoid gradientCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-gradientgpu","title":"function gradientGPU","text":"<pre><code>template&lt;class T&gt;\nvoid gradientGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Wrapping function to calculate gradien of evolving variables on GPU This function is the entry point to the gradient functions on the GPU </p>"},{"location":"BGFlood/Gradients_8h/#function-gradientgpunew","title":"function gradientGPUnew","text":"<pre><code>template&lt;class T&gt;\nvoid gradientGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-gradienthalo","title":"function gradientHalo","text":"<pre><code>template&lt;class T&gt;\nvoid gradientHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-gradienthalobotgpu","title":"function gradientHaloBotGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientHaloBotGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-gradienthalobotgpunew","title":"function gradientHaloBotGPUnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientHaloBotGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-gradienthalogpu","title":"function gradientHaloGPU","text":"<pre><code>template&lt;class T&gt;\nvoid gradientHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-gradienthaloleftgpu","title":"function gradientHaloLeftGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientHaloLeftGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-gradienthaloleftgpunew","title":"function gradientHaloLeftGPUnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientHaloLeftGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-gradienthalorightgpu","title":"function gradientHaloRightGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientHaloRightGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-gradienthalorightgpunew","title":"function gradientHaloRightGPUnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientHaloRightGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-gradienthalotopgpu","title":"function gradientHaloTopGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientHaloTopGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-gradienthalotopgpunew","title":"function gradientHaloTopGPUnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientHaloTopGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-gradientsm","title":"function gradientSM","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientSM (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Depreciated shared memory version of Device kernel for calculating gradients Much slower than above </p>"},{"location":"BGFlood/Gradients_8h/#function-gradientsmb","title":"function gradientSMB","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientSMB (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-gradientsmc","title":"function gradientSMC","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientSMC (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-gradientedgex","title":"function gradientedgeX","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientedgeX (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx\n) \n</code></pre>"},{"location":"BGFlood/Gradients_8h/#function-gradientedgey","title":"function gradientedgeY","text":"<pre><code>template&lt;class T&gt;\n__global__ void gradientedgeY (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dady\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Gradients.h</code></p>"},{"location":"BGFlood/Gradients_8h_source/","title":"File Gradients.h","text":""},{"location":"BGFlood/Gradients_8h_source/#file-gradientsh","title":"File Gradients.h","text":"<p>File List &gt; src &gt; Gradients.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef GRADIENTS_H\n#define GRADIENTS_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"Util_CPU.h\"\n#include \"Setup_GPU.h\"\n#include \"MemManagement.h\"\n#include \"Halo.h\"\n\n// CPU specific functions\ntemplate &lt;class T&gt; void gradientCPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\ntemplate &lt;class T&gt; void gradientC(Param XParam, BlockP&lt;T&gt; XBlock, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; void gradientHalo(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\n\n// GPU specific functions\ntemplate &lt;class T&gt; void gradientGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\ntemplate &lt;class T&gt; void gradientGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\ntemplate &lt;class T&gt; __global__ void gradient(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientSM(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientSMB(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientSMC(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientedgeX(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx);\ntemplate &lt;class T&gt; __global__ void gradientedgeY(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dady);\ntemplate &lt;class T&gt; void gradientHaloGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\n\ntemplate &lt;class T&gt; __global__ void WetsloperesetXGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\ntemplate &lt;class T&gt; __global__ void WetsloperesetYGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\n\ntemplate &lt;class T&gt; __global__ void WetsloperesetHaloLeftGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\ntemplate &lt;class T&gt; __global__ void WetsloperesetHaloRightGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\ntemplate &lt;class T&gt; __global__ void WetsloperesetHaloBotGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\ntemplate &lt;class T&gt; __global__ void WetsloperesetHaloTopGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\n\n\ntemplate &lt;class T&gt; __global__ void gradientHaloLeftGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientHaloRightGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientHaloTopGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientHaloBotGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\n\ntemplate &lt;class T&gt; __global__ void gradientHaloLeftGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientHaloRightGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientHaloTopGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientHaloBotGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/GridManip_8cu/","title":"File GridManip.cu","text":""},{"location":"BGFlood/GridManip_8cu/#file-gridmanipcu","title":"File GridManip.cu","text":"<p>FileList &gt; src &gt; GridManip.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"GridManip.h\"</code></li> </ul>"},{"location":"BGFlood/GridManip_8cu/#public-functions","title":"Public Functions","text":"Type Name void Copy2CartCPU (int nx, int ny, T * dest, T * src)  template void Copy2CartCPU&lt; bool &gt; (int nx, int ny, bool * dest, bool * src)  template void Copy2CartCPU&lt; double &gt; (int nx, int ny, double * dest, double * src)  template void Copy2CartCPU&lt; float &gt; (int nx, int ny, float * dest, float * src)  template void Copy2CartCPU&lt; int &gt; (int nx, int ny, int * dest, int * src)  void CopyArrayBUQ (Param XParam, BlockP&lt; F &gt; XBlock, T * source, T *&amp; dest)  void CopyArrayBUQ (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; source, EvolvingP&lt; T &gt; &amp; dest)  void CopyArrayBUQ (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; source, EvolvingP_M&lt; T &gt; &amp; dest)  template void CopyArrayBUQ&lt; bool, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, bool * source, bool *&amp; dest)  template void CopyArrayBUQ&lt; bool, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, bool * source, bool *&amp; dest)  template void CopyArrayBUQ&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; source, EvolvingP&lt; double &gt; &amp; dest)  template void CopyArrayBUQ&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; source, EvolvingP_M&lt; double &gt; &amp; dest)  template void CopyArrayBUQ&lt; double, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * source, double *&amp; dest)  template void CopyArrayBUQ&lt; double, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, double * source, double *&amp; dest)  template void CopyArrayBUQ&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; source, EvolvingP&lt; float &gt; &amp; dest)  template void CopyArrayBUQ&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; source, EvolvingP_M&lt; float &gt; &amp; dest)  template void CopyArrayBUQ&lt; float, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, float * source, float *&amp; dest)  template void CopyArrayBUQ&lt; float, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * source, float *&amp; dest)  template void CopyArrayBUQ&lt; int, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, int * source, int *&amp; dest)  template void CopyArrayBUQ&lt; int, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, int * source, int *&amp; dest)  void InitArrayBUQ (Param XParam, BlockP&lt; F &gt; XBlock, T initval, T *&amp; Arr)  template void InitArrayBUQ&lt; bool, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, bool initval, bool *&amp; Arr)  template void InitArrayBUQ&lt; bool, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, bool initval, bool *&amp; Arr)  template void InitArrayBUQ&lt; double, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double initval, double *&amp; Arr)  template void InitArrayBUQ&lt; double, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, double initval, double *&amp; Arr)  template void InitArrayBUQ&lt; float, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, float initval, float *&amp; Arr)  template void InitArrayBUQ&lt; float, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float initval, float *&amp; Arr)  template void InitArrayBUQ&lt; int, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, int initval, int *&amp; Arr)  template void InitArrayBUQ&lt; int, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, int initval, int *&amp; Arr)  void InitBlkBUQ (Param XParam, BlockP&lt; F &gt; XBlock, T initval, T *&amp; Arr)  template void InitBlkBUQ&lt; bool, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, bool initval, bool *&amp; Arr)  template void InitBlkBUQ&lt; bool, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, bool initval, bool *&amp; Arr)  template void InitBlkBUQ&lt; double, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double initval, double *&amp; Arr)  template void InitBlkBUQ&lt; double, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, double initval, double *&amp; Arr)  template void InitBlkBUQ&lt; float, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, float initval, float *&amp; Arr)  template void InitBlkBUQ&lt; float, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float initval, float *&amp; Arr)  template void InitBlkBUQ&lt; int, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, int initval, int *&amp; Arr)  template void InitBlkBUQ&lt; int, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, int initval, int *&amp; Arr)  void InterpstepCPU (int nx, int ny, int hdstep, F totaltime, F hddt, T *&amp; Ux, T * Uo, T * Un)  template void InterpstepCPU&lt; double, double &gt; (int nx, int ny, int hdstep, double totaltime, double hddt, double *&amp; Ux, double * Uo, double * Un)  template void InterpstepCPU&lt; double, float &gt; (int nx, int ny, int hdstep, float totaltime, float hddt, double *&amp; Ux, double * Uo, double * Un)  template void InterpstepCPU&lt; float, double &gt; (int nx, int ny, int hdstep, double totaltime, double hddt, float *&amp; Ux, float * Uo, float * Un)  template void InterpstepCPU&lt; float, float &gt; (int nx, int ny, int hdstep, float totaltime, float hddt, float *&amp; Ux, float * Uo, float * Un)  template void InterpstepCPU&lt; int, double &gt; (int nx, int ny, int hdstep, double totaltime, double hddt, int *&amp; Ux, int * Uo, int * Un)  template void InterpstepCPU&lt; int, float &gt; (int nx, int ny, int hdstep, float totaltime, float hddt, int *&amp; Ux, int * Uo, int * Un)  __global__ void InterpstepGPU (int nx, int ny, T totaltime, T beforetime, T aftertime, T * Ux, T * Uo, T * Un)  template __global__ void InterpstepGPU&lt; double &gt; (int nx, int ny, double totaltime, double beforetime, double aftertime, double * Ux, double * Uo, double * Un)  template __global__ void InterpstepGPU&lt; float &gt; (int nx, int ny, float totaltime, float beforetime, float aftertime, float * Ux, float * Uo, float * Un)  T blockmean (T x, T y, T dx, F forcing)  void interp2BUQ (Param XParam, BlockP&lt; T &gt; XBlock, F forcing, T *&amp; z)  void interp2BUQ (Param XParam, BlockP&lt; T &gt; XBlock, std::vector&lt; StaticForcingP&lt; float &gt; &gt; forcing, T * z)  T interp2BUQ (T x, T y, T dx, F forcing)  T interp2BUQ (T x, T y, F forcing)  template void interp2BUQ&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, std::vector&lt; StaticForcingP&lt; float &gt; &gt; forcing, double * z)  template void interp2BUQ&lt; double, DynForcingP&lt; float &gt; &gt; (Param XParam, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; forcing, double *&amp; z)  template double interp2BUQ&lt; double, DynForcingP&lt; float &gt; &gt; (double x, double y, DynForcingP&lt; float &gt; forcing)  template void interp2BUQ&lt; double, StaticForcingP&lt; float &gt; &gt; (Param XParam, BlockP&lt; double &gt; XBlock, StaticForcingP&lt; float &gt; forcing, double *&amp; z)  template double interp2BUQ&lt; double, StaticForcingP&lt; float &gt; &gt; (double x, double y, StaticForcingP&lt; float &gt; forcing)  template double interp2BUQ&lt; double, StaticForcingP&lt; int &gt; &gt; (double x, double y, StaticForcingP&lt; int &gt; forcing)  template void interp2BUQ&lt; double, deformmap&lt; float &gt; &gt; (Param XParam, BlockP&lt; double &gt; XBlock, deformmap&lt; float &gt; forcing, double *&amp; z)  template double interp2BUQ&lt; double, deformmap&lt; float &gt; &gt; (double x, double y, deformmap&lt; float &gt; forcing)  template void interp2BUQ&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, std::vector&lt; StaticForcingP&lt; float &gt; &gt; forcing, float * z)  template void interp2BUQ&lt; float, DynForcingP&lt; float &gt; &gt; (Param XParam, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; forcing, float *&amp; z)  template float interp2BUQ&lt; float, DynForcingP&lt; float &gt; &gt; (float x, float y, DynForcingP&lt; float &gt; forcing)  template void interp2BUQ&lt; float, StaticForcingP&lt; float &gt; &gt; (Param XParam, BlockP&lt; float &gt; XBlock, StaticForcingP&lt; float &gt; forcing, float *&amp; z)  template float interp2BUQ&lt; float, StaticForcingP&lt; float &gt; &gt; (float x, float y, StaticForcingP&lt; float &gt; forcing)  template float interp2BUQ&lt; float, StaticForcingP&lt; int &gt; &gt; (float x, float y, StaticForcingP&lt; int &gt; forcing)  template void interp2BUQ&lt; float, deformmap&lt; float &gt; &gt; (Param XParam, BlockP&lt; float &gt; XBlock, deformmap&lt; float &gt; forcing, float *&amp; z)  template float interp2BUQ&lt; float, deformmap&lt; float &gt; &gt; (float x, float y, deformmap&lt; float &gt; forcing)  void setedges (Param XParam, BlockP&lt; T &gt; XBlock, T *&amp; zb)  template void setedges&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double *&amp; zb)  template void setedges&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float *&amp; zb)  void setedgessideBT (Param XParam, int ib, int blkA, int blkB, int jread, int jwrite, T *&amp; zb)  void setedgessideLR (Param XParam, int ib, int blkA, int blkB, int iread, int iwrite, T *&amp; zb)"},{"location":"BGFlood/GridManip_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/GridManip_8cu/#function-copy2cartcpu","title":"function Copy2CartCPU","text":"<pre><code>template&lt;class T&gt;\nvoid Copy2CartCPU (\n    int nx,\n    int ny,\n    T * dest,\n    T * src\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copy2cartcpu-bool","title":"function Copy2CartCPU&lt; bool &gt;","text":"<pre><code>template void Copy2CartCPU&lt; bool &gt; (\n    int nx,\n    int ny,\n    bool * dest,\n    bool * src\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copy2cartcpu-double","title":"function Copy2CartCPU&lt; double &gt;","text":"<pre><code>template void Copy2CartCPU&lt; double &gt; (\n    int nx,\n    int ny,\n    double * dest,\n    double * src\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copy2cartcpu-float","title":"function Copy2CartCPU&lt; float &gt;","text":"<pre><code>template void Copy2CartCPU&lt; float &gt; (\n    int nx,\n    int ny,\n    float * dest,\n    float * src\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copy2cartcpu-int","title":"function Copy2CartCPU&lt; int &gt;","text":"<pre><code>template void Copy2CartCPU&lt; int &gt; (\n    int nx,\n    int ny,\n    int * dest,\n    int * src\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copyarraybuq","title":"function CopyArrayBUQ","text":"<pre><code>template&lt;class T, class F&gt;\nvoid CopyArrayBUQ (\n    Param XParam,\n    BlockP &lt; F &gt; XBlock,\n    T * source,\n    T *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copyarraybuq_1","title":"function CopyArrayBUQ","text":"<pre><code>template&lt;class T&gt;\nvoid CopyArrayBUQ (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; source,\n    EvolvingP &lt; T &gt; &amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copyarraybuq_2","title":"function CopyArrayBUQ","text":"<pre><code>template&lt;class T&gt;\nvoid CopyArrayBUQ (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; source,\n    EvolvingP_M &lt; T &gt; &amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copyarraybuq-bool-double","title":"function CopyArrayBUQ&lt; bool, double &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; bool, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    bool * source,\n    bool *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copyarraybuq-bool-float","title":"function CopyArrayBUQ&lt; bool, float &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; bool, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    bool * source,\n    bool *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copyarraybuq-double","title":"function CopyArrayBUQ&lt; double &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; source,\n    EvolvingP &lt; double &gt; &amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copyarraybuq-double_1","title":"function CopyArrayBUQ&lt; double &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; source,\n    EvolvingP_M &lt; double &gt; &amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copyarraybuq-double-double","title":"function CopyArrayBUQ&lt; double, double &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; double, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * source,\n    double *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copyarraybuq-double-float","title":"function CopyArrayBUQ&lt; double, float &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; double, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    double * source,\n    double *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copyarraybuq-float","title":"function CopyArrayBUQ&lt; float &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; source,\n    EvolvingP &lt; float &gt; &amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copyarraybuq-float_1","title":"function CopyArrayBUQ&lt; float &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; source,\n    EvolvingP_M &lt; float &gt; &amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copyarraybuq-float-double","title":"function CopyArrayBUQ&lt; float, double &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; float, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    float * source,\n    float *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copyarraybuq-float-float","title":"function CopyArrayBUQ&lt; float, float &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; float, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * source,\n    float *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copyarraybuq-int-double","title":"function CopyArrayBUQ&lt; int, double &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; int, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    int * source,\n    int *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-copyarraybuq-int-float","title":"function CopyArrayBUQ&lt; int, float &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; int, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    int * source,\n    int *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initarraybuq","title":"function InitArrayBUQ","text":"<pre><code>template&lt;class T, class F&gt;\nvoid InitArrayBUQ (\n    Param XParam,\n    BlockP &lt; F &gt; XBlock,\n    T initval,\n    T *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initarraybuq-bool-double","title":"function InitArrayBUQ&lt; bool, double &gt;","text":"<pre><code>template void InitArrayBUQ&lt; bool, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    bool initval,\n    bool *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initarraybuq-bool-float","title":"function InitArrayBUQ&lt; bool, float &gt;","text":"<pre><code>template void InitArrayBUQ&lt; bool, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    bool initval,\n    bool *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initarraybuq-double-double","title":"function InitArrayBUQ&lt; double, double &gt;","text":"<pre><code>template void InitArrayBUQ&lt; double, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double initval,\n    double *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initarraybuq-double-float","title":"function InitArrayBUQ&lt; double, float &gt;","text":"<pre><code>template void InitArrayBUQ&lt; double, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    double initval,\n    double *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initarraybuq-float-double","title":"function InitArrayBUQ&lt; float, double &gt;","text":"<pre><code>template void InitArrayBUQ&lt; float, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    float initval,\n    float *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initarraybuq-float-float","title":"function InitArrayBUQ&lt; float, float &gt;","text":"<pre><code>template void InitArrayBUQ&lt; float, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float initval,\n    float *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initarraybuq-int-double","title":"function InitArrayBUQ&lt; int, double &gt;","text":"<pre><code>template void InitArrayBUQ&lt; int, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    int initval,\n    int *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initarraybuq-int-float","title":"function InitArrayBUQ&lt; int, float &gt;","text":"<pre><code>template void InitArrayBUQ&lt; int, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    int initval,\n    int *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initblkbuq","title":"function InitBlkBUQ","text":"<pre><code>template&lt;class T, class F&gt;\nvoid InitBlkBUQ (\n    Param XParam,\n    BlockP &lt; F &gt; XBlock,\n    T initval,\n    T *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initblkbuq-bool-double","title":"function InitBlkBUQ&lt; bool, double &gt;","text":"<pre><code>template void InitBlkBUQ&lt; bool, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    bool initval,\n    bool *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initblkbuq-bool-float","title":"function InitBlkBUQ&lt; bool, float &gt;","text":"<pre><code>template void InitBlkBUQ&lt; bool, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    bool initval,\n    bool *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initblkbuq-double-double","title":"function InitBlkBUQ&lt; double, double &gt;","text":"<pre><code>template void InitBlkBUQ&lt; double, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double initval,\n    double *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initblkbuq-double-float","title":"function InitBlkBUQ&lt; double, float &gt;","text":"<pre><code>template void InitBlkBUQ&lt; double, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    double initval,\n    double *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initblkbuq-float-double","title":"function InitBlkBUQ&lt; float, double &gt;","text":"<pre><code>template void InitBlkBUQ&lt; float, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    float initval,\n    float *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initblkbuq-float-float","title":"function InitBlkBUQ&lt; float, float &gt;","text":"<pre><code>template void InitBlkBUQ&lt; float, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float initval,\n    float *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initblkbuq-int-double","title":"function InitBlkBUQ&lt; int, double &gt;","text":"<pre><code>template void InitBlkBUQ&lt; int, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    int initval,\n    int *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-initblkbuq-int-float","title":"function InitBlkBUQ&lt; int, float &gt;","text":"<pre><code>template void InitBlkBUQ&lt; int, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    int initval,\n    int *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interpstepcpu","title":"function InterpstepCPU","text":"<pre><code>template&lt;class T, class F&gt;\nvoid InterpstepCPU (\n    int nx,\n    int ny,\n    int hdstep,\n    F totaltime,\n    F hddt,\n    T *&amp; Ux,\n    T * Uo,\n    T * Un\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interpstepcpu-double-double","title":"function InterpstepCPU&lt; double, double &gt;","text":"<pre><code>template void InterpstepCPU&lt; double, double &gt; (\n    int nx,\n    int ny,\n    int hdstep,\n    double totaltime,\n    double hddt,\n    double *&amp; Ux,\n    double * Uo,\n    double * Un\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interpstepcpu-double-float","title":"function InterpstepCPU&lt; double, float &gt;","text":"<pre><code>template void InterpstepCPU&lt; double, float &gt; (\n    int nx,\n    int ny,\n    int hdstep,\n    float totaltime,\n    float hddt,\n    double *&amp; Ux,\n    double * Uo,\n    double * Un\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interpstepcpu-float-double","title":"function InterpstepCPU&lt; float, double &gt;","text":"<pre><code>template void InterpstepCPU&lt; float, double &gt; (\n    int nx,\n    int ny,\n    int hdstep,\n    double totaltime,\n    double hddt,\n    float *&amp; Ux,\n    float * Uo,\n    float * Un\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interpstepcpu-float-float","title":"function InterpstepCPU&lt; float, float &gt;","text":"<pre><code>template void InterpstepCPU&lt; float, float &gt; (\n    int nx,\n    int ny,\n    int hdstep,\n    float totaltime,\n    float hddt,\n    float *&amp; Ux,\n    float * Uo,\n    float * Un\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interpstepcpu-int-double","title":"function InterpstepCPU&lt; int, double &gt;","text":"<pre><code>template void InterpstepCPU&lt; int, double &gt; (\n    int nx,\n    int ny,\n    int hdstep,\n    double totaltime,\n    double hddt,\n    int *&amp; Ux,\n    int * Uo,\n    int * Un\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interpstepcpu-int-float","title":"function InterpstepCPU&lt; int, float &gt;","text":"<pre><code>template void InterpstepCPU&lt; int, float &gt; (\n    int nx,\n    int ny,\n    int hdstep,\n    float totaltime,\n    float hddt,\n    int *&amp; Ux,\n    int * Uo,\n    int * Un\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interpstepgpu","title":"function InterpstepGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void InterpstepGPU (\n    int nx,\n    int ny,\n    T totaltime,\n    T beforetime,\n    T aftertime,\n    T * Ux,\n    T * Uo,\n    T * Un\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interpstepgpu-double","title":"function InterpstepGPU&lt; double &gt;","text":"<pre><code>template __global__ void InterpstepGPU&lt; double &gt; (\n    int nx,\n    int ny,\n    double totaltime,\n    double beforetime,\n    double aftertime,\n    double * Ux,\n    double * Uo,\n    double * Un\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interpstepgpu-float","title":"function InterpstepGPU&lt; float &gt;","text":"<pre><code>template __global__ void InterpstepGPU&lt; float &gt; (\n    int nx,\n    int ny,\n    float totaltime,\n    float beforetime,\n    float aftertime,\n    float * Ux,\n    float * Uo,\n    float * Un\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-blockmean","title":"function blockmean","text":"<pre><code>template&lt;class T, class F&gt;\nT blockmean (\n    T x,\n    T y,\n    T dx,\n    F forcing\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq","title":"function interp2BUQ","text":"<pre><code>template&lt;class T, class F&gt;\nvoid interp2BUQ (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    F forcing,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq_1","title":"function interp2BUQ","text":"<pre><code>template&lt;class T&gt;\nvoid interp2BUQ (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    std::vector&lt; StaticForcingP &lt; float &gt; &gt; forcing,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq_2","title":"function interp2BUQ","text":"<pre><code>template&lt;class T, class F&gt;\nT interp2BUQ (\n    T x,\n    T y,\n    T dx,\n    F forcing\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq_3","title":"function interp2BUQ","text":"<pre><code>template&lt;class T, class F&gt;\nT interp2BUQ (\n    T x,\n    T y,\n    F forcing\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq-double","title":"function interp2BUQ&lt; double &gt;","text":"<pre><code>template void interp2BUQ&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    std::vector&lt; StaticForcingP &lt; float &gt; &gt; forcing,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq-double-dynforcingp-float","title":"function interp2BUQ&lt; double, DynForcingP&lt; float &gt; &gt;","text":"<pre><code>template void interp2BUQ&lt; double, DynForcingP&lt; float &gt; &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; forcing,\n    double *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq-double-dynforcingp-float_1","title":"function interp2BUQ&lt; double, DynForcingP&lt; float &gt; &gt;","text":"<pre><code>template double interp2BUQ&lt; double, DynForcingP&lt; float &gt; &gt; (\n    double x,\n    double y,\n    DynForcingP &lt; float &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq-double-staticforcingp-float","title":"function interp2BUQ&lt; double, StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template void interp2BUQ&lt; double, StaticForcingP&lt; float &gt; &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    StaticForcingP &lt; float &gt; forcing,\n    double *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq-double-staticforcingp-float_1","title":"function interp2BUQ&lt; double, StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template double interp2BUQ&lt; double, StaticForcingP&lt; float &gt; &gt; (\n    double x,\n    double y,\n    StaticForcingP &lt; float &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq-double-staticforcingp-int","title":"function interp2BUQ&lt; double, StaticForcingP&lt; int &gt; &gt;","text":"<pre><code>template double interp2BUQ&lt; double, StaticForcingP&lt; int &gt; &gt; (\n    double x,\n    double y,\n    StaticForcingP &lt; int &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq-double-deformmap-float","title":"function interp2BUQ&lt; double, deformmap&lt; float &gt; &gt;","text":"<pre><code>template void interp2BUQ&lt; double, deformmap&lt; float &gt; &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    deformmap &lt; float &gt; forcing,\n    double *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq-double-deformmap-float_1","title":"function interp2BUQ&lt; double, deformmap&lt; float &gt; &gt;","text":"<pre><code>template double interp2BUQ&lt; double, deformmap&lt; float &gt; &gt; (\n    double x,\n    double y,\n    deformmap &lt; float &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq-float","title":"function interp2BUQ&lt; float &gt;","text":"<pre><code>template void interp2BUQ&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    std::vector&lt; StaticForcingP &lt; float &gt; &gt; forcing,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq-float-dynforcingp-float","title":"function interp2BUQ&lt; float, DynForcingP&lt; float &gt; &gt;","text":"<pre><code>template void interp2BUQ&lt; float, DynForcingP&lt; float &gt; &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; forcing,\n    float *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq-float-dynforcingp-float_1","title":"function interp2BUQ&lt; float, DynForcingP&lt; float &gt; &gt;","text":"<pre><code>template float interp2BUQ&lt; float, DynForcingP&lt; float &gt; &gt; (\n    float x,\n    float y,\n    DynForcingP &lt; float &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq-float-staticforcingp-float","title":"function interp2BUQ&lt; float, StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template void interp2BUQ&lt; float, StaticForcingP&lt; float &gt; &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    StaticForcingP &lt; float &gt; forcing,\n    float *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq-float-staticforcingp-float_1","title":"function interp2BUQ&lt; float, StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template float interp2BUQ&lt; float, StaticForcingP&lt; float &gt; &gt; (\n    float x,\n    float y,\n    StaticForcingP &lt; float &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq-float-staticforcingp-int","title":"function interp2BUQ&lt; float, StaticForcingP&lt; int &gt; &gt;","text":"<pre><code>template float interp2BUQ&lt; float, StaticForcingP&lt; int &gt; &gt; (\n    float x,\n    float y,\n    StaticForcingP &lt; int &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq-float-deformmap-float","title":"function interp2BUQ&lt; float, deformmap&lt; float &gt; &gt;","text":"<pre><code>template void interp2BUQ&lt; float, deformmap&lt; float &gt; &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    deformmap &lt; float &gt; forcing,\n    float *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-interp2buq-float-deformmap-float_1","title":"function interp2BUQ&lt; float, deformmap&lt; float &gt; &gt;","text":"<pre><code>template float interp2BUQ&lt; float, deformmap&lt; float &gt; &gt; (\n    float x,\n    float y,\n    deformmap &lt; float &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-setedges","title":"function setedges","text":"<pre><code>template&lt;class T&gt;\nvoid setedges (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-setedges-double","title":"function setedges&lt; double &gt;","text":"<pre><code>template void setedges&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-setedges-float","title":"function setedges&lt; float &gt;","text":"<pre><code>template void setedges&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-setedgessidebt","title":"function setedgessideBT","text":"<pre><code>template&lt;class T&gt;\nvoid setedgessideBT (\n    Param XParam,\n    int ib,\n    int blkA,\n    int blkB,\n    int jread,\n    int jwrite,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8cu/#function-setedgessidelr","title":"function setedgessideLR","text":"<pre><code>template&lt;class T&gt;\nvoid setedgessideLR (\n    Param XParam,\n    int ib,\n    int blkA,\n    int blkB,\n    int iread,\n    int iwrite,\n    T *&amp; zb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/GridManip.cu</code></p>"},{"location":"BGFlood/GridManip_8cu_source/","title":"File GridManip.cu","text":""},{"location":"BGFlood/GridManip_8cu_source/#file-gridmanipcu","title":"File GridManip.cu","text":"<p>File List &gt; src &gt; GridManip.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n// This code contains an adaptation of the St Venant equation from Basilisk     //\n// See                                                                          //\n// http://basilisk.fr/src/saint-venant.h and                                    //\n// S. Popinet. Quadtree-adaptive tsunami modelling. Ocean Dynamics,             //\n// doi: 61(9) : 1261 - 1285, 2011                                               //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //\n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n\n#include \"GridManip.h\"\n\n\n\n\ntemplate &lt;class T,class F&gt; void InitArrayBUQ(Param XParam, BlockP&lt;F&gt; XBlock,  T initval, T*&amp; Arr)\n{\n    int ib, n;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                //n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                n = memloc(XParam, i, j, ib);\n                Arr[n] = initval;\n            }\n        }\n    }\n}\n\ntemplate void InitArrayBUQ&lt;float,float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float initval, float*&amp; Arr);\ntemplate void InitArrayBUQ&lt;double, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, double initval, double*&amp; Arr);\ntemplate void InitArrayBUQ&lt;int, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, int initval, int*&amp; Arr);\ntemplate void InitArrayBUQ&lt;bool, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, bool initval, bool*&amp; Arr);\n\ntemplate void InitArrayBUQ&lt;float, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, float initval, float*&amp; Arr);\ntemplate void InitArrayBUQ&lt;double, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double initval, double*&amp; Arr);\ntemplate void InitArrayBUQ&lt;int, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, int initval, int*&amp; Arr);\ntemplate void InitArrayBUQ&lt;bool, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, bool initval, bool*&amp; Arr);\n\n\n\ntemplate &lt;class T, class F&gt; void InitBlkBUQ(Param XParam, BlockP&lt;F&gt; XBlock, T initval, T*&amp; Arr)\n{\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n\n                Arr[ib] = initval;\n\n    }\n}\n\ntemplate void InitBlkBUQ&lt;bool, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, bool initval, bool*&amp; Arr);\ntemplate void InitBlkBUQ&lt;int, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, int initval, int*&amp; Arr);\ntemplate void InitBlkBUQ&lt;float, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float initval, float*&amp; Arr);\ntemplate void InitBlkBUQ&lt;double, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, double initval, double*&amp; Arr);\n\ntemplate void InitBlkBUQ&lt;bool, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, bool initval, bool*&amp; Arr);\ntemplate void InitBlkBUQ&lt;int, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, int initval, int*&amp; Arr);\ntemplate void InitBlkBUQ&lt;float, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, float initval, float*&amp; Arr);\ntemplate void InitBlkBUQ&lt;double, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double initval, double*&amp; Arr);\n\n\ntemplate &lt;class T,class F&gt; void CopyArrayBUQ(Param XParam,BlockP&lt;F&gt; XBlock, T* source, T* &amp; dest)\n{\n    int ib,n;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n\n\n                dest[n] = source[n];\n            }\n        }\n    }\n}\ntemplate void CopyArrayBUQ&lt;bool, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, bool* source, bool*&amp; dest);\ntemplate void CopyArrayBUQ&lt;int, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, int* source, int*&amp; dest);\ntemplate void CopyArrayBUQ&lt;float, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* source, float*&amp; dest);\ntemplate void CopyArrayBUQ&lt;double, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, double* source, double*&amp; dest);\n\ntemplate void CopyArrayBUQ&lt;bool, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, bool* source, bool*&amp; dest);\ntemplate void CopyArrayBUQ&lt;int, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, int* source, int*&amp; dest);\ntemplate void CopyArrayBUQ&lt;float, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, float* source, float*&amp; dest);\ntemplate void CopyArrayBUQ&lt;double, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* source, double*&amp; dest);\n\n\ntemplate &lt;class T&gt; void CopyArrayBUQ(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; source, EvolvingP&lt;T&gt;&amp; dest)\n{\n    CopyArrayBUQ(XParam, XBlock, source.h, dest.h);\n    CopyArrayBUQ(XParam, XBlock, source.u, dest.u);\n    CopyArrayBUQ(XParam, XBlock, source.v, dest.v);\n    CopyArrayBUQ(XParam, XBlock, source.zs, dest.zs);\n}\ntemplate void CopyArrayBUQ&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; source, EvolvingP&lt;float&gt;&amp; dest);\ntemplate void CopyArrayBUQ&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; source, EvolvingP&lt;double&gt;&amp; dest);\n\ntemplate &lt;class T&gt; void CopyArrayBUQ(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; source, EvolvingP_M&lt;T&gt;&amp; dest)\n{\n    CopyArrayBUQ(XParam, XBlock, source.h, dest.h);\n    CopyArrayBUQ(XParam, XBlock, source.u, dest.u);\n    CopyArrayBUQ(XParam, XBlock, source.v, dest.v);\n    CopyArrayBUQ(XParam, XBlock, source.zs, dest.zs);\n    // For U and hU:\n    int ib, n;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                dest.U[n] = sqrt((source.u[n]*source.u[n]) + (source.v[n]*source.v[n]));\n                dest.hU[n] = source.h[n] * dest.U[n];\n            }\n        }\n    }\n\n}\ntemplate void CopyArrayBUQ&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; source, EvolvingP_M&lt;float&gt;&amp; dest);\ntemplate void CopyArrayBUQ&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; source, EvolvingP_M&lt;double&gt;&amp; dest);\n\n\ntemplate &lt;class T&gt;  void setedges(Param XParam, BlockP&lt;T&gt; XBlock, T *&amp;zb)\n{\n    // template &lt;class T&gt; void setedges(int nblk, int nx, int ny, double xo, double yo, double dx, int * leftblk, int *rightblk, int * topblk, int* botblk, double *blockxo, double * blockyo, T *&amp;zb)\n\n    // here the bathy of the outter most cells of the domain are \"set\" to the same value as the second outter most.\n    // this also applies to the blocks with no neighbour\n    for (int bl = 0; bl &lt; XParam.nblk; bl++)\n    {\n        int ib = XBlock.active[bl];\n        // Now check each corner of each block\n        //printf(\"bl=%i\\t ib=%i\\t,LB=%i\\t,LT=%i\\t,RB=%i\\t,RT=%i\\t,TL=%i\\t,TR=%i\\t,BL=%i\\t,BR=%i\\n \", bl, ib, XBlock.LeftBot[ib], XBlock.LeftTop[ib], XBlock.RightBot[ib], XBlock.RightTop[ib], XBlock.TopLeft[ib], XBlock.TopRight[ib], XBlock.BotLeft[ib], XBlock.BotRight[ib]);\n\n        // Left\n        setedgessideLR(XParam, ib, XBlock.LeftBot[ib], XBlock.LeftTop[ib], 1, 0, zb);\n\n        // Right\n        setedgessideLR(XParam, ib, XBlock.RightBot[ib], XBlock.RightTop[ib], XParam.blkwidth - 2, XParam.blkwidth - 1, zb);\n\n        // Top\n        setedgessideBT(XParam, ib, XBlock.TopLeft[ib], XBlock.TopRight[ib], XParam.blkwidth - 2, XParam.blkwidth - 1, zb);\n\n        // Bot\n        setedgessideBT(XParam, ib, XBlock.BotLeft[ib], XBlock.BotRight[ib], 1, 0, zb);\n\n\n    }\n}\ntemplate void setedges&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float*&amp; zb);\ntemplate void setedges&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double*&amp; zb);\n\ntemplate &lt;class T&gt;  void setedgessideLR(Param XParam, int ib,int blkA, int blkB, int iread, int iwrite, T*&amp; zb)\n{\n    if (blkA == ib || blkA == ib)\n    {\n        int n, k;\n        int jstart, jend;\n        jstart = (blkA == ib) ? 0 : XParam.blkwidth / 2;\n        jend = (blkB == ib) ? XParam.blkwidth : XParam.blkwidth / 2;\n\n        for (int j = jstart; j &lt; jend; j++)\n        {\n            // read value at n and write at k\n            n = (iread + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            k = (iwrite + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            zb[k] = zb[n];\n\n        }\n    }\n}\n\ntemplate &lt;class T&gt;  void setedgessideBT(Param XParam, int ib, int blkA, int blkB, int jread, int jwrite, T*&amp; zb)\n{\n    if (blkA == ib || blkB == ib)\n    {\n        int n, k;\n        int istart, iend;\n        istart = (blkA == ib) ? 0 : XParam.blkwidth / 2;\n        iend = (blkB == ib) ? XParam.blkwidth : XParam.blkwidth / 2;\n\n        for (int i = istart; i &lt; iend; i++)\n        {\n            // read value at n and write at k\n            n = (i + XParam.halowidth) + (jread + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            k = (i + XParam.halowidth) + (jwrite + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            zb[k] = zb[n];\n\n        }\n    }\n}\n\n\ntemplate &lt;class T, class F&gt; void interp2BUQ(Param XParam, BlockP&lt;T&gt; XBlock, F forcing, T*&amp; z)\n{\n    // This function interpolates the values in bathy maps or roughness map to cf using a bilinear interpolation\n\n    T x, y;\n    int n;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XBlock.active[ibl];\n\n        double blkdx = calcres(XParam.dx, XBlock.level[ib]);\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                n = (i+XParam.halowidth) + (j+XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                x = T(XParam.xo + XBlock.xo[ib] + i * blkdx);\n                y = T(XParam.yo + XBlock.yo[ib] + j * blkdx);\n\n                z[n] = interp2BUQ(x, y, T(blkdx), forcing);\n\n            }\n        }\n    }\n}\ntemplate void interp2BUQ&lt;float, StaticForcingP&lt;float&gt;&gt;(Param XParam, BlockP&lt;float&gt; XBlock, StaticForcingP&lt;float&gt; forcing, float*&amp; z);\ntemplate void interp2BUQ&lt;double, StaticForcingP&lt;float&gt;&gt;(Param XParam, BlockP&lt;double&gt; XBlock, StaticForcingP&lt;float&gt; forcing, double*&amp; z);\n//template void interp2BUQ&lt;float, StaticForcingP&lt;float&gt;&gt;(Param XParam, BlockP&lt;float&gt; XBlock, std::vector&lt;StaticForcingP&lt;float&gt;&gt; forcing, float*&amp; z);\n//template void interp2BUQ&lt;double, StaticForcingP&lt;float&gt;&gt;(Param XParam, BlockP&lt;double&gt; XBlock, StaticForcingP&lt;float&gt; forcing, double*&amp; z);\ntemplate void interp2BUQ&lt;float, deformmap&lt;float&gt;&gt;(Param XParam, BlockP&lt;float&gt; XBlock, deformmap&lt;float&gt; forcing, float*&amp; z);\ntemplate void interp2BUQ&lt;double, deformmap&lt;float&gt;&gt;(Param XParam, BlockP&lt;double&gt; XBlock, deformmap&lt;float&gt; forcing, double*&amp; z);\ntemplate void interp2BUQ&lt;float, DynForcingP&lt;float&gt;&gt;(Param XParam, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; forcing, float*&amp; z);\ntemplate void interp2BUQ&lt;double, DynForcingP&lt;float&gt;&gt;(Param XParam, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; forcing, double*&amp; z);\n\ntemplate &lt;class T&gt; void interp2BUQ(Param XParam, BlockP&lt;T&gt; XBlock, std::vector&lt;StaticForcingP&lt;float&gt;&gt; forcing, T* z)\n{\n    // This function interpolates the values in bathy maps or roughness map to cf using a bilinear interpolation\n\n    T x, y;\n    int n;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XBlock.active[ibl];\n\n        double blkdx = calcres(XParam.dx, XBlock.level[ib]);\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                x = T(XParam.xo + XBlock.xo[ib] + i * blkdx);\n                y = T(XParam.yo + XBlock.yo[ib] + j * blkdx);\n\n                // Interpolate to fill in values from the whole domain (even if the domain outspan the domain fo the bathy)\n                z[n] = interp2BUQ(x, y, T(blkdx), forcing[0]);\n\n                // now interpolat to other grids\n                if (forcing.size() &gt; 1)\n                {\n                    for (int nf = 1; nf &lt; forcing.size(); nf++)\n                    {\n                        if (x &gt;= forcing[nf].xo &amp;&amp; x &lt;= forcing[nf].xmax &amp;&amp; y &gt;= forcing[nf].yo &amp;&amp; y &lt;= forcing[nf].ymax)\n                        {\n                            T interpval= interp2BUQ(x, y, T(blkdx), forcing[nf]);\n\n                            //if (isnan(interpval))\n                            //{\n                            //  log(\"NAN detected\");\n                            //}\n\n                            if (!isnan(interpval))\n                            {\n                                z[n] = interp2BUQ(x, y, T(blkdx), forcing[nf]);\n                            }\n                            //else\n                            //{\n                            //  z[n] = -999.0;\n                            //}\n                            //{\n                            //  log(\"NAN detected: Z=\"+std::to_string(z[n]));\n                            //}\n\n                        }\n                    }\n                }\n\n\n            }\n        }\n    }\n}\ntemplate void interp2BUQ&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, std::vector&lt;StaticForcingP&lt;float&gt;&gt; forcing, float* z);\ntemplate void interp2BUQ&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, std::vector&lt;StaticForcingP&lt;float&gt;&gt; forcing, double* z);\n\n\ntemplate &lt;class T, class F&gt; T interp2BUQ(T x, T y, T dx, F forcing)\n{\n    T z;\n    if (dx &lt;= T(forcing.dx)) // bilinear interpolation\n    {\n        z = interp2BUQ(x, y, forcing);\n    }\n    else //blockmean interpolation\n    {\n        z = blockmean(x, y, dx, forcing);\n    }\n    return z;\n}\n\n\ntemplate &lt;class T, class F&gt; T blockmean(T x, T y,T dx, F forcing)\n{\n    double xmin, xmax, ymin, ymax;\n    T z;\n    int imin,imax,jmin,jmax,ni, nj,cfi,cfj;\n\n\n    xmin = x - dx * 0.5;\n    xmax = x + dx * 0.5;\n    ymin = y - dx * 0.5;\n    ymax = y + dx * 0.5;\n\n    imin = max(ftoi(floor((xmin - forcing.xo) / forcing.dx)), 0);\n    imax = min(ftoi(floor((xmax - forcing.xo) / forcing.dx)), forcing.nx - 1);\n\n    jmin = max(ftoi(floor((ymin - forcing.yo) / forcing.dy)), 0);\n    jmax = min(ftoi(floor((ymax - forcing.yo) / forcing.dy)), forcing.ny - 1);\n\n    //printf(\"imin=%d; imax=%d, jmin=%d, jmax=%d\\t\",imin, imax, jmin, jmax);\n\n    ni = max(imax - imin + 1, 1);\n    nj = max(jmax - jmin + 1, 1);\n\n\n    //printf(\"ni=%d; nj=%d\\n\", ni, nj);\n    z = 0.0;\n    for (int i = 0; i &lt; ni; i++)\n    {\n        for (int j = 0; j &lt; nj; j++)\n        {\n            cfi = min(imin + i, forcing.nx - 1);\n            cfj = min(jmin + j, forcing.ny - 1);\n            z = z + forcing.val[cfi + cfj * forcing.nx];\n        }\n\n    }\n\n    z = z / (ni * nj);\n\n\n    return z;\n\n}\n\ntemplate &lt;class T, class F&gt; T interp2BUQ(T x, T y, F forcing)\n{\n    //this is safer!\n\n    double xi, yi;\n\n    xi = utils::max(utils::min(double(x), forcing.xmax), forcing.xo);\n    yi = utils::max(utils::min(double(y), forcing.ymax), forcing.yo);\n    // cells that falls off this domain are assigned\n    double x1, x2, y1, y2;\n    double q11, q12, q21, q22;\n    int cfi, cfip, cfj, cfjp;\n\n\n\n    cfi = utils::min(utils::max((int)floor((xi - forcing.xo) / forcing.dx), 0), forcing.nx - 2);\n    cfip = cfi + 1;\n\n    x1 = forcing.xo + forcing.dx * cfi;\n    x2 = forcing.xo + forcing.dx * cfip;\n\n    cfj = utils::min(utils::max((int)floor((yi - forcing.yo) / forcing.dy), 0), forcing.ny - 2);\n    cfjp = cfj + 1;\n\n    y1 = forcing.yo + forcing.dy * cfj;\n    y2 = forcing.yo + forcing.dy * cfjp;\n\n    q11 = forcing.val[cfi + cfj * forcing.nx];\n    q12 = forcing.val[cfi + cfjp * forcing.nx];\n    q21 = forcing.val[cfip + cfj * forcing.nx];\n    q22 = forcing.val[cfip + cfjp * forcing.nx];\n\n    return T(BilinearInterpolation(q11, q12, q21, q22, x1, x2, y1, y2, xi, yi));\n\n\n}\ntemplate float interp2BUQ&lt;float, StaticForcingP&lt;float&gt;&gt;(float x, float y, StaticForcingP&lt;float&gt; forcing);\ntemplate double interp2BUQ&lt;double, StaticForcingP&lt;float&gt;&gt;(double x, double y, StaticForcingP&lt;float&gt; forcing);\ntemplate float interp2BUQ&lt;float, StaticForcingP&lt;int&gt;&gt;(float x, float y, StaticForcingP&lt;int&gt; forcing);\ntemplate double interp2BUQ&lt;double, StaticForcingP&lt;int&gt;&gt;(double x, double y, StaticForcingP&lt;int&gt; forcing);\ntemplate float interp2BUQ&lt;float, deformmap&lt;float&gt;&gt;(float x, float y, deformmap&lt;float&gt; forcing);\ntemplate double interp2BUQ&lt;double, deformmap&lt;float&gt;&gt;(double x, double y, deformmap&lt;float&gt; forcing);\ntemplate float interp2BUQ&lt;float, DynForcingP&lt;float&gt;&gt;(float x, float y, DynForcingP&lt;float&gt; forcing);\ntemplate double interp2BUQ&lt;double, DynForcingP&lt;float&gt;&gt;(double x, double y, DynForcingP&lt;float&gt; forcing);\n\n\ntemplate &lt;class T, class F&gt; void InterpstepCPU(int nx, int ny, int hdstep, F totaltime, F hddt, T *&amp;Ux, T *Uo, T *Un)\n{\n    //float fac = 1.0;\n    T Uxo, Uxn;\n\n    /*Ums[tx]=Umask[ix];*/\n\n\n\n\n    for (int i = 0; i &lt; nx; i++)\n    {\n        for (int j = 0; j &lt; ny; j++)\n        {\n            Uxo = Uo[i + nx*j];\n            Uxn = Un[i + nx*j];\n\n            Ux[i + nx*j] = T(Uxo + (totaltime - hddt*hdstep)*(Uxn - Uxo) / hddt);\n        }\n    }\n}\ntemplate void InterpstepCPU&lt;int,float&gt;(int nx, int ny, int hdstep, float totaltime, float hddt, int *&amp;Ux, int *Uo, int *Un);\ntemplate void InterpstepCPU&lt;float, float&gt;(int nx, int ny, int hdstep, float totaltime, float hddt, float *&amp;Ux, float *Uo, float *Un);\ntemplate void InterpstepCPU&lt;double, float&gt;(int nx, int ny, int hdstep, float totaltime, float hddt, double *&amp;Ux, double *Uo, double *Un);\ntemplate void InterpstepCPU&lt;int, double&gt;(int nx, int ny, int hdstep, double totaltime, double hddt, int*&amp; Ux, int* Uo, int* Un);\ntemplate void InterpstepCPU&lt;float, double&gt;(int nx, int ny, int hdstep, double totaltime, double hddt, float*&amp; Ux, float* Uo, float* Un);\ntemplate void InterpstepCPU&lt;double, double&gt;(int nx, int ny, int hdstep, double totaltime, double hddt, double*&amp; Ux, double* Uo, double* Un);\n\n\ntemplate &lt;class T&gt; __global__ void InterpstepGPU(int nx, int ny, T totaltime, T beforetime, T aftertime, T*Ux, T* Uo, T* Un)\n{\n    unsigned int ix = blockIdx.x * blockDim.x + threadIdx.x;\n    unsigned int iy = blockIdx.y * blockDim.y + threadIdx.y;\n    unsigned int tx = threadIdx.x;\n    unsigned int ty = threadIdx.y;\n\n    __shared__ T Uxo[16][16];\n    __shared__ T Uxn[16][16];\n    //  __shared__ float Ums[16];\n\n    T hddt = aftertime - beforetime;\n\n    if (ix &lt; nx &amp;&amp; iy &lt; ny)\n    {\n        Uxo[tx][ty] = Uo[ix + nx * iy];\n        Uxn[tx][ty] = Un[ix + nx * iy];\n\n        Ux[ix + nx * iy] = Uxo[tx][ty] + (totaltime - beforetime) * (Uxn[tx][ty] - Uxo[tx][ty]) / (hddt);\n    }\n}\n//template __global__ void InterpstepGPU&lt;int&gt;(int nx, int ny, int hdstp, T totaltime, T hddt, T* Ux, T* Uo, T* Un);\ntemplate __global__ void InterpstepGPU&lt;float&gt;(int nx, int ny, float totaltime, float beforetime, float aftertime, float* Ux, float* Uo, float* Un);\ntemplate __global__ void InterpstepGPU&lt;double&gt;(int nx, int ny, double totaltime, double beforetime, double aftertime, double* Ux, double* Uo, double* Un);\n\n\n\ntemplate &lt;class T&gt; void Copy2CartCPU(int nx, int ny, T* dest, T* src)\n{\n    for (int i = 0; i &lt; nx; i++)\n    {\n        for (int j = 0; j &lt; ny; j++)\n        {\n            dest[i + nx * j] = src[i + nx * j];\n        }\n    }\n}\ntemplate void Copy2CartCPU&lt;int&gt;(int nx, int ny, int* dest, int* src);\ntemplate void Copy2CartCPU&lt;bool&gt;(int nx, int ny, bool* dest, bool* src);\ntemplate void Copy2CartCPU&lt;float&gt;(int nx, int ny, float* dest, float* src);\ntemplate void Copy2CartCPU&lt;double&gt;(int nx, int ny, double* dest, double* src);\n</code></pre>"},{"location":"BGFlood/GridManip_8h/","title":"File GridManip.h","text":""},{"location":"BGFlood/GridManip_8h/#file-gridmaniph","title":"File GridManip.h","text":"<p>FileList &gt; src &gt; GridManip.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> </ul>"},{"location":"BGFlood/GridManip_8h/#public-functions","title":"Public Functions","text":"Type Name void Copy2CartCPU (int nx, int ny, T * dest, T * src)  void CopyArrayBUQ (Param XParam, BlockP&lt; F &gt; XBlock, T * source, T *&amp; dest)  void CopyArrayBUQ (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; source, EvolvingP&lt; T &gt; &amp; dest)  void CopyArrayBUQ (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; source, EvolvingP_M&lt; T &gt; &amp; dest)  void InitArrayBUQ (Param XParam, BlockP&lt; F &gt; XBlock, T initval, T *&amp; Arr)  void InitBlkBUQ (Param XParam, BlockP&lt; F &gt; XBlock, T initval, T *&amp; Arr)  void InterpstepCPU (int nx, int ny, int hdstep, F totaltime, F hddt, T *&amp; Ux, T * Uo, T * Un)  __global__ void InterpstepGPU (int nx, int ny, T totaltime, T beforetime, T aftertime, T * Ux, T * Uo, T * Un)  void interp2BUQ (Param XParam, BlockP&lt; T &gt; XBlock, std::vector&lt; StaticForcingP&lt; float &gt; &gt; forcing, T * z)  void interp2BUQ (Param XParam, BlockP&lt; T &gt; XBlock, F forcing, T *&amp; z)  T interp2BUQ (T x, T y, F forcing)  T interp2BUQ (T x, T y, T dx, F forcing)  void setedges (Param XParam, BlockP&lt; T &gt; XBlock, T *&amp; zb)"},{"location":"BGFlood/GridManip_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/GridManip_8h/#function-copy2cartcpu","title":"function Copy2CartCPU","text":"<pre><code>template&lt;class T&gt;\nvoid Copy2CartCPU (\n    int nx,\n    int ny,\n    T * dest,\n    T * src\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8h/#function-copyarraybuq","title":"function CopyArrayBUQ","text":"<pre><code>template&lt;class T, class F&gt;\nvoid CopyArrayBUQ (\n    Param XParam,\n    BlockP &lt; F &gt; XBlock,\n    T * source,\n    T *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8h/#function-copyarraybuq_1","title":"function CopyArrayBUQ","text":"<pre><code>template&lt;class T&gt;\nvoid CopyArrayBUQ (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; source,\n    EvolvingP &lt; T &gt; &amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8h/#function-copyarraybuq_2","title":"function CopyArrayBUQ","text":"<pre><code>template&lt;class T&gt;\nvoid CopyArrayBUQ (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; source,\n    EvolvingP_M &lt; T &gt; &amp; dest\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8h/#function-initarraybuq","title":"function InitArrayBUQ","text":"<pre><code>template&lt;class T, class F&gt;\nvoid InitArrayBUQ (\n    Param XParam,\n    BlockP &lt; F &gt; XBlock,\n    T initval,\n    T *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8h/#function-initblkbuq","title":"function InitBlkBUQ","text":"<pre><code>template&lt;class T, class F&gt;\nvoid InitBlkBUQ (\n    Param XParam,\n    BlockP &lt; F &gt; XBlock,\n    T initval,\n    T *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8h/#function-interpstepcpu","title":"function InterpstepCPU","text":"<pre><code>template&lt;class T, class F&gt;\nvoid InterpstepCPU (\n    int nx,\n    int ny,\n    int hdstep,\n    F totaltime,\n    F hddt,\n    T *&amp; Ux,\n    T * Uo,\n    T * Un\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8h/#function-interpstepgpu","title":"function InterpstepGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void InterpstepGPU (\n    int nx,\n    int ny,\n    T totaltime,\n    T beforetime,\n    T aftertime,\n    T * Ux,\n    T * Uo,\n    T * Un\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8h/#function-interp2buq","title":"function interp2BUQ","text":"<pre><code>template&lt;class T&gt;\nvoid interp2BUQ (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    std::vector&lt; StaticForcingP &lt; float &gt; &gt; forcing,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8h/#function-interp2buq_1","title":"function interp2BUQ","text":"<pre><code>template&lt;class T, class F&gt;\nvoid interp2BUQ (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    F forcing,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8h/#function-interp2buq_2","title":"function interp2BUQ","text":"<pre><code>template&lt;class T, class F&gt;\nT interp2BUQ (\n    T x,\n    T y,\n    F forcing\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8h/#function-interp2buq_3","title":"function interp2BUQ","text":"<pre><code>template&lt;class T, class F&gt;\nT interp2BUQ (\n    T x,\n    T y,\n    T dx,\n    F forcing\n) \n</code></pre>"},{"location":"BGFlood/GridManip_8h/#function-setedges","title":"function setedges","text":"<pre><code>template&lt;class T&gt;\nvoid setedges (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; zb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/GridManip.h</code></p>"},{"location":"BGFlood/GridManip_8h_source/","title":"File GridManip.h","text":""},{"location":"BGFlood/GridManip_8h_source/#file-gridmaniph","title":"File GridManip.h","text":"<p>File List &gt; src &gt; GridManip.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef GRIDMANIP_H\n#define GRIDMANIP_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Util_CPU.h\"\n#include \"Forcing.h\"\n#include \"Arrays.h\"\n#include \"MemManagement.h\"\n\ntemplate &lt;class T, class F&gt; void CopyArrayBUQ(Param XParam, BlockP&lt;F&gt; XBlock, T* source, T*&amp; dest);\ntemplate &lt;class T&gt; void CopyArrayBUQ(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; source, EvolvingP&lt;T&gt;&amp; dest);\ntemplate &lt;class T&gt; void CopyArrayBUQ(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; source, EvolvingP_M&lt;T&gt;&amp; dest);\ntemplate &lt;class T, class F&gt; void InitArrayBUQ(Param XParam, BlockP&lt;F&gt; XBlock, T initval, T*&amp; Arr);\ntemplate &lt;class T, class F&gt; void InitBlkBUQ(Param XParam, BlockP&lt;F&gt; XBlock, T initval, T*&amp; Arr);\ntemplate &lt;class T&gt;  void setedges(Param XParam, BlockP&lt;T&gt; XBlock, T*&amp; zb);\n\n\ntemplate &lt;class T&gt; void interp2BUQ(Param XParam, BlockP&lt;T&gt; XBlock, std::vector&lt;StaticForcingP&lt;float&gt;&gt; forcing, T* z);\ntemplate &lt;class T, class F&gt; void interp2BUQ(Param XParam, BlockP&lt;T&gt; XBlock, F forcing, T*&amp; z);\ntemplate &lt;class T, class F&gt; T interp2BUQ(T x, T y, F forcing);\ntemplate &lt;class T, class F&gt; T interp2BUQ(T x, T y, T dx, F forcing);\n\ntemplate &lt;class T, class F&gt; void InterpstepCPU(int nx, int ny, int hdstep, F totaltime, F hddt, T*&amp; Ux, T* Uo, T* Un);\n//template &lt;class T&gt; __global__ void InterpstepGPU(int nx, int ny, int hdstp, T totaltime, T hddt, T* Ux, T* Uo, T* Un);\ntemplate &lt;class T&gt; __global__ void InterpstepGPU(int nx, int ny, T totaltime, T beforetime, T aftertime, T* Ux, T* Uo, T* Un);\n\ntemplate &lt;class T&gt; void Copy2CartCPU(int nx, int ny, T* dest, T* src);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Halo_8cu/","title":"File Halo.cu","text":""},{"location":"BGFlood/Halo_8cu/#file-halocu","title":"File Halo.cu","text":"<p>FileList &gt; src &gt; Halo.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Halo.h\"</code></li> </ul>"},{"location":"BGFlood/Halo_8cu/#public-functions","title":"Public Functions","text":"Type Name void HaloFluxCPUBT (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z)  void HaloFluxCPULR (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z)  __global__ void HaloFluxGPUBT (Param XParam, BlockP&lt; T &gt; XBlock, T * z)  __global__ void HaloFluxGPUBTnew (Param XParam, BlockP&lt; T &gt; XBlock, T * z)  __global__ void HaloFluxGPULR (Param XParam, BlockP&lt; T &gt; XBlock, T * z)  __global__ void HaloFluxGPULRnew (Param XParam, BlockP&lt; T &gt; XBlock, T * z)  void RecalculateZs (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) Recalculate water surface after recalculating the values on the halo on the CPU. template void RecalculateZs&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template void RecalculateZs&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  __global__ void RecalculateZsGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  template __global__ void RecalculateZsGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template __global__ void RecalculateZsGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  void Recalculatehh (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  template void Recalculatehh&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template void Recalculatehh&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  void bndmaskGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, FluxP&lt; T &gt; Flux)  template void bndmaskGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, FluxP&lt; double &gt; Flux)  template void bndmaskGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, FluxP&lt; float &gt; Flux)  void fillBot (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z)  __global__ void fillBot (int halowidth, int * active, int * level, int * botleft, int * botright, int * topleft, int * lefttop, int * righttop, T * a)  template __global__ void fillBot&lt; double &gt; (int halowidth, int * active, int * level, int * botleft, int * botright, int * topleft, int * lefttop, int * righttop, double * a)  template __global__ void fillBot&lt; float &gt; (int halowidth, int * active, int * level, int * botleft, int * botright, int * topleft, int * lefttop, int * righttop, float * a)  void fillBotFlux (Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z)  __global__ void fillBotnew (int halowidth, int nblk, int * active, int * level, int * botleft, int * botright, int * topleft, int * lefttop, int * righttop, T * a)  template __global__ void fillBotnew&lt; double &gt; (int halowidth, int nblk, int * active, int * level, int * botleft, int * botright, int * topleft, int * lefttop, int * righttop, double * a)  template __global__ void fillBotnew&lt; float &gt; (int halowidth, int nblk, int * active, int * level, int * botleft, int * botright, int * topleft, int * lefttop, int * righttop, float * a)  void fillCorners (Param XParam, BlockP&lt; T &gt; XBlock, T *&amp; z)  void fillCorners (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; &amp; Xev)  void fillCorners (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z)  template void fillCorners&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double *&amp; z)  template void fillCorners&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; &amp; Xev)  template void fillCorners&lt; double &gt; (Param XParam, int ib, BlockP&lt; double &gt; XBlock, double *&amp; z)  template void fillCorners&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float *&amp; z)  template void fillCorners&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; &amp; Xev)  template void fillCorners&lt; float &gt; (Param XParam, int ib, BlockP&lt; float &gt; XBlock, float *&amp; z)  __global__ void fillCornersGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z)  template __global__ void fillCornersGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z)  template __global__ void fillCornersGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z)  void fillHalo (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  void fillHalo (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev)  void fillHalo (Param XParam, BlockP&lt; T &gt; XBlock, GradientsP&lt; T &gt; Grad)  void fillHalo (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux)  template void fillHalo&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template void fillHalo&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev)  template void fillHalo&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, GradientsP&lt; double &gt; Grad)  template void fillHalo&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, FluxP&lt; double &gt; Flux)  template void fillHalo&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  template void fillHalo&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev)  template void fillHalo&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, GradientsP&lt; float &gt; Grad)  template void fillHalo&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, FluxP&lt; float &gt; Flux)  void fillHaloBTFluxC (Param XParam, BlockP&lt; T &gt; XBlock, T * z)  template void fillHaloBTFluxC&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z)  template void fillHaloBTFluxC&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z)  void fillHaloBotTopGPU (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z)  template void fillHaloBotTopGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double * z)  template void fillHaloBotTopGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float * z)  void fillHaloBotTopGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z)  template void fillHaloBotTopGPUnew&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double * z)  template void fillHaloBotTopGPUnew&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float * z)  void fillHaloC (Param XParam, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating halos for each block of a single variable on CPU. template void fillHaloC&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z)  template void fillHaloC&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z)  void fillHaloD (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating halos on CPU on every side of a block of a single variable. template void fillHaloD&lt; double &gt; (Param XParam, int ib, BlockP&lt; double &gt; XBlock, double * z)  template void fillHaloD&lt; float &gt; (Param XParam, int ib, BlockP&lt; float &gt; XBlock, float * z)  void fillHaloF (Param XParam, bool doProlongation, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating flux in the halos for a block and a single variable on CPU. template void fillHaloF&lt; double &gt; (Param XParam, bool doProlongation, BlockP&lt; double &gt; XBlock, double * z)  template void fillHaloF&lt; float &gt; (Param XParam, bool doProlongation, BlockP&lt; float &gt; XBlock, float * z)  void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z) Wrapping function for calculating halos for each block of a single variable on GPU. void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z)  void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev)  void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, GradientsP&lt; T &gt; Grad)  void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux)  template void fillHaloGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double * z)  template void fillHaloGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z)  template void fillHaloGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev)  template void fillHaloGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template void fillHaloGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, GradientsP&lt; double &gt; Grad)  template void fillHaloGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, FluxP&lt; double &gt; Flux)  template void fillHaloGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float * z)  template void fillHaloGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z)  template void fillHaloGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev)  template void fillHaloGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  template void fillHaloGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, GradientsP&lt; float &gt; Grad)  template void fillHaloGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, FluxP&lt; float &gt; Flux)  void fillHaloGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z)  template void fillHaloGPUnew&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double * z)  template void fillHaloGPUnew&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float * z)  void fillHaloLRFluxC (Param XParam, BlockP&lt; T &gt; XBlock, T * z)  template void fillHaloLRFluxC&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z)  template void fillHaloLRFluxC&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z)  void fillHaloLeftRightGPU (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z)  template void fillHaloLeftRightGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double * z)  template void fillHaloLeftRightGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float * z)  void fillHaloLeftRightGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z)  template void fillHaloLeftRightGPUnew&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double * z)  template void fillHaloLeftRightGPUnew&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float * z)  void fillHaloTopRightC (Param XParam, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating flux for halos for each block of a single variable on GPU. template void fillHaloTopRightC&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z)  template void fillHaloTopRightC&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z)  void fillHaloTopRightGPU (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z)  template void fillHaloTopRightGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double * z)  template void fillHaloTopRightGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float * z)  void fillLeft (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z)  __global__ void fillLeft (int halowidth, int * active, int * level, int * leftbot, int * lefttop, int * rightbot, int * botright, int * topright, T * a)  template __global__ void fillLeft&lt; double &gt; (int halowidth, int * active, int * level, int * leftbot, int * lefttop, int * rightbot, int * botright, int * topright, double * a)  template __global__ void fillLeft&lt; float &gt; (int halowidth, int * active, int * level, int * leftbot, int * lefttop, int * rightbot, int * botright, int * topright, float * a)  void fillLeftFlux (Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z)  __global__ void fillLeftnew (int halowidth, int nblk, int * active, int * level, int * leftbot, int * lefttop, int * rightbot, int * botright, int * topright, T * a)  template __global__ void fillLeftnew&lt; double &gt; (int halowidth, int nblk, int * active, int * level, int * leftbot, int * lefttop, int * rightbot, int * botright, int * topright, double * a)  template __global__ void fillLeftnew&lt; float &gt; (int halowidth, int nblk, int * active, int * level, int * leftbot, int * lefttop, int * rightbot, int * botright, int * topright, float * a)  void fillRight (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z)  __global__ void fillRight (int halowidth, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, T * a)  template __global__ void fillRight&lt; double &gt; (int halowidth, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, double * a)  template __global__ void fillRight&lt; float &gt; (int halowidth, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, float * a)  void fillRightFlux (Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z)  __global__ void fillRightFlux (int halowidth, bool doProlongation, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, T * a)  template void fillRightFlux&lt; double &gt; (Param XParam, bool doProlongation, int ib, BlockP&lt; double &gt; XBlock, double *&amp; z)  template __global__ void fillRightFlux&lt; double &gt; (int halowidth, bool doProlongation, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, double * a)  template void fillRightFlux&lt; float &gt; (Param XParam, bool doProlongation, int ib, BlockP&lt; float &gt; XBlock, float *&amp; z)  template __global__ void fillRightFlux&lt; float &gt; (int halowidth, bool doProlongation, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, float * a)  __global__ void fillRightnew (int halowidth, int nblk, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, T * a)  template __global__ void fillRightnew&lt; double &gt; (int halowidth, int nblk, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, double * a)  template __global__ void fillRightnew&lt; float &gt; (int halowidth, int nblk, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, float * a)  void fillTop (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z)  __global__ void fillTop (int halowidth, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, T * a)  template __global__ void fillTop&lt; double &gt; (int halowidth, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, double * a)  template __global__ void fillTop&lt; float &gt; (int halowidth, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, float * a)  void fillTopFlux (Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z)  __global__ void fillTopFlux (int halowidth, bool doProlongation, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, T * a)  template void fillTopFlux&lt; double &gt; (Param XParam, bool doProlongation, int ib, BlockP&lt; double &gt; XBlock, double *&amp; z)  template __global__ void fillTopFlux&lt; double &gt; (int halowidth, bool doProlongation, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, double * a)  template void fillTopFlux&lt; float &gt; (Param XParam, bool doProlongation, int ib, BlockP&lt; float &gt; XBlock, float *&amp; z)  template __global__ void fillTopFlux&lt; float &gt; (int halowidth, bool doProlongation, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, float * a)  __global__ void fillTopnew (int halowidth, int nblk, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, T * a)  template __global__ void fillTopnew&lt; double &gt; (int halowidth, int nblk, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, double * a)  template __global__ void fillTopnew&lt; float &gt; (int halowidth, int nblk, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, float * a)  void refine_linear (Param XParam, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy)  template void refine_linear&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template void refine_linear&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  void refine_linearGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy)  template void refine_linearGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template void refine_linearGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  void refine_linear_Bot (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy)  template void refine_linear_Bot&lt; double &gt; (Param XParam, int ib, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template void refine_linear_Bot&lt; float &gt; (Param XParam, int ib, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  __global__ void refine_linear_BotGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy)  template __global__ void refine_linear_BotGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template __global__ void refine_linear_BotGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  void refine_linear_Left (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy)  template void refine_linear_Left&lt; double &gt; (Param XParam, int ib, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template void refine_linear_Left&lt; float &gt; (Param XParam, int ib, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  __global__ void refine_linear_LeftGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy)  template __global__ void refine_linear_LeftGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template __global__ void refine_linear_LeftGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  void refine_linear_Right (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy)  template void refine_linear_Right&lt; double &gt; (Param XParam, int ib, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template void refine_linear_Right&lt; float &gt; (Param XParam, int ib, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  __global__ void refine_linear_RightGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy)  template __global__ void refine_linear_RightGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template __global__ void refine_linear_RightGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  void refine_linear_Top (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy)  template void refine_linear_Top&lt; double &gt; (Param XParam, int ib, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template void refine_linear_Top&lt; float &gt; (Param XParam, int ib, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  __global__ void refine_linear_TopGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy)  template __global__ void refine_linear_TopGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template __global__ void refine_linear_TopGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)"},{"location":"BGFlood/Halo_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Halo_8cu/#function-halofluxcpubt","title":"function HaloFluxCPUBT","text":"<pre><code>template&lt;class T&gt;\nvoid HaloFluxCPUBT (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-halofluxcpulr","title":"function HaloFluxCPULR","text":"<pre><code>template&lt;class T&gt;\nvoid HaloFluxCPULR (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-halofluxgpubt","title":"function HaloFluxGPUBT","text":"<pre><code>template&lt;class T&gt;\n__global__ void HaloFluxGPUBT (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-halofluxgpubtnew","title":"function HaloFluxGPUBTnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void HaloFluxGPUBTnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-halofluxgpulr","title":"function HaloFluxGPULR","text":"<pre><code>template&lt;class T&gt;\n__global__ void HaloFluxGPULR (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-halofluxgpulrnew","title":"function HaloFluxGPULRnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void HaloFluxGPULRnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-recalculatezs","title":"function RecalculateZs","text":"<p>Recalculate water surface after recalculating the values on the halo on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid RecalculateZs (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre> <p>Recalculate water surface after recalculating the values on the halo on the GPU.</p>"},{"location":"BGFlood/Halo_8cu/#description","title":"Description","text":"<p>Recalculate water surface after recalculating the values on the halo on the CPU. zb (bottom elevation) on each halo is calculated at the start of the loop or as part of the initial condition. When conserve-elevation is not required, only h is recalculated on the halo at ever 1/2 steps.   zs then needs to be recalculated to obtain a mass-conservative solution (if zs is conserved then mass conservation is not garanteed)</p>"},{"location":"BGFlood/Halo_8cu/#warning","title":"Warning","text":"<p>This function calculate zs everywhere in the block... this is a bit unecessary. Instead it should recalculate only where there is a prolongation or a restiction</p>"},{"location":"BGFlood/Halo_8cu/#description_1","title":"Description","text":"<p>Recalculate water surface after recalculating the values on the halo on the CPU. zb (bottom elevation) on each halo is calculated at the start of the loop or as part of the initial condition. When conserve-elevation is not required, only h is recalculated on the halo at ever 1/2 steps. zs then needs to be recalculated to obtain a mass-conservative solution (if zs is conserved then mass conservation is not garanteed)</p>"},{"location":"BGFlood/Halo_8cu/#warning_1","title":"Warning","text":"<p>This function calculate zs everywhere in the block... this is a bit unecessary. Instead it should recalculate only where there is a prolongation or a restiction </p>"},{"location":"BGFlood/Halo_8cu/#function-recalculatezs-double","title":"function RecalculateZs&lt; double &gt;","text":"<pre><code>template void RecalculateZs&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-recalculatezs-float","title":"function RecalculateZs&lt; float &gt;","text":"<pre><code>template void RecalculateZs&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-recalculatezsgpu","title":"function RecalculateZsGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void RecalculateZsGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-recalculatezsgpu-double","title":"function RecalculateZsGPU&lt; double &gt;","text":"<pre><code>template __global__ void RecalculateZsGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-recalculatezsgpu-float","title":"function RecalculateZsGPU&lt; float &gt;","text":"<pre><code>template __global__ void RecalculateZsGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-recalculatehh","title":"function Recalculatehh","text":"<pre><code>template&lt;class T&gt;\nvoid Recalculatehh (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-recalculatehh-double","title":"function Recalculatehh&lt; double &gt;","text":"<pre><code>template void Recalculatehh&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-recalculatehh-float","title":"function Recalculatehh&lt; float &gt;","text":"<pre><code>template void Recalculatehh&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-bndmaskgpu","title":"function bndmaskGPU","text":"<pre><code>template&lt;class T&gt;\nvoid bndmaskGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-bndmaskgpu-double","title":"function bndmaskGPU&lt; double &gt;","text":"<pre><code>template void bndmaskGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    FluxP &lt; double &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-bndmaskgpu-float","title":"function bndmaskGPU&lt; float &gt;","text":"<pre><code>template void bndmaskGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    FluxP &lt; float &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillbot","title":"function fillBot","text":"<pre><code>template&lt;class T&gt;\nvoid fillBot (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillbot_1","title":"function fillBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillBot (\n    int halowidth,\n    int * active,\n    int * level,\n    int * botleft,\n    int * botright,\n    int * topleft,\n    int * lefttop,\n    int * righttop,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillbot-double","title":"function fillBot&lt; double &gt;","text":"<pre><code>template __global__ void fillBot&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    int * botleft,\n    int * botright,\n    int * topleft,\n    int * lefttop,\n    int * righttop,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillbot-float","title":"function fillBot&lt; float &gt;","text":"<pre><code>template __global__ void fillBot&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    int * botleft,\n    int * botright,\n    int * topleft,\n    int * lefttop,\n    int * righttop,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillbotflux","title":"function fillBotFlux","text":"<pre><code>template&lt;class T&gt;\nvoid fillBotFlux (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillbotnew","title":"function fillBotnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillBotnew (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * botleft,\n    int * botright,\n    int * topleft,\n    int * lefttop,\n    int * righttop,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillbotnew-double","title":"function fillBotnew&lt; double &gt;","text":"<pre><code>template __global__ void fillBotnew&lt; double &gt; (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * botleft,\n    int * botright,\n    int * topleft,\n    int * lefttop,\n    int * righttop,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillbotnew-float","title":"function fillBotnew&lt; float &gt;","text":"<pre><code>template __global__ void fillBotnew&lt; float &gt; (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * botleft,\n    int * botright,\n    int * topleft,\n    int * lefttop,\n    int * righttop,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillcorners","title":"function fillCorners","text":"<pre><code>template&lt;class T&gt;\nvoid fillCorners (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillcorners_1","title":"function fillCorners","text":"<pre><code>template&lt;class T&gt;\nvoid fillCorners (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; &amp; Xev\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillcorners_2","title":"function fillCorners","text":"<pre><code>template&lt;class T&gt;\nvoid fillCorners (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillcorners-double","title":"function fillCorners&lt; double &gt;","text":"<pre><code>template void fillCorners&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillcorners-double_1","title":"function fillCorners&lt; double &gt;","text":"<pre><code>template void fillCorners&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; &amp; Xev\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillcorners-double_2","title":"function fillCorners&lt; double &gt;","text":"<pre><code>template void fillCorners&lt; double &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; double &gt; XBlock,\n    double *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillcorners-float","title":"function fillCorners&lt; float &gt;","text":"<pre><code>template void fillCorners&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillcorners-float_1","title":"function fillCorners&lt; float &gt;","text":"<pre><code>template void fillCorners&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; &amp; Xev\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillcorners-float_2","title":"function fillCorners&lt; float &gt;","text":"<pre><code>template void fillCorners&lt; float &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; float &gt; XBlock,\n    float *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillcornersgpu","title":"function fillCornersGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillCornersGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillcornersgpu-double","title":"function fillCornersGPU&lt; double &gt;","text":"<pre><code>template __global__ void fillCornersGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillcornersgpu-float","title":"function fillCornersGPU&lt; float &gt;","text":"<pre><code>template __global__ void fillCornersGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalo","title":"function fillHalo","text":"<pre><code>template&lt;class T&gt;\nvoid fillHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalo_1","title":"function fillHalo","text":"<pre><code>template&lt;class T&gt;\nvoid fillHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalo_2","title":"function fillHalo","text":"<pre><code>template&lt;class T&gt;\nvoid fillHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    GradientsP &lt; T &gt; Grad\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalo_3","title":"function fillHalo","text":"<pre><code>template&lt;class T&gt;\nvoid fillHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalo-double","title":"function fillHalo&lt; double &gt;","text":"<pre><code>template void fillHalo&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalo-double_1","title":"function fillHalo&lt; double &gt;","text":"<pre><code>template void fillHalo&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalo-double_2","title":"function fillHalo&lt; double &gt;","text":"<pre><code>template void fillHalo&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    GradientsP &lt; double &gt; Grad\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalo-double_3","title":"function fillHalo&lt; double &gt;","text":"<pre><code>template void fillHalo&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    FluxP &lt; double &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalo-float","title":"function fillHalo&lt; float &gt;","text":"<pre><code>template void fillHalo&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalo-float_1","title":"function fillHalo&lt; float &gt;","text":"<pre><code>template void fillHalo&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalo-float_2","title":"function fillHalo&lt; float &gt;","text":"<pre><code>template void fillHalo&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    GradientsP &lt; float &gt; Grad\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalo-float_3","title":"function fillHalo&lt; float &gt;","text":"<pre><code>template void fillHalo&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    FluxP &lt; float &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalobtfluxc","title":"function fillHaloBTFluxC","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloBTFluxC (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalobtfluxc-double","title":"function fillHaloBTFluxC&lt; double &gt;","text":"<pre><code>template void fillHaloBTFluxC&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalobtfluxc-float","title":"function fillHaloBTFluxC&lt; float &gt;","text":"<pre><code>template void fillHaloBTFluxC&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalobottopgpu","title":"function fillHaloBotTopGPU","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloBotTopGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalobottopgpu-double","title":"function fillHaloBotTopGPU&lt; double &gt;","text":"<pre><code>template void fillHaloBotTopGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    cudaStream_t stream,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalobottopgpu-float","title":"function fillHaloBotTopGPU&lt; float &gt;","text":"<pre><code>template void fillHaloBotTopGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    cudaStream_t stream,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalobottopgpunew","title":"function fillHaloBotTopGPUnew","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloBotTopGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalobottopgpunew-double","title":"function fillHaloBotTopGPUnew&lt; double &gt;","text":"<pre><code>template void fillHaloBotTopGPUnew&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    cudaStream_t stream,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalobottopgpunew-float","title":"function fillHaloBotTopGPUnew&lt; float &gt;","text":"<pre><code>template void fillHaloBotTopGPUnew&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    cudaStream_t stream,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhaloc","title":"function fillHaloC","text":"<p>Wrapping function for calculating halos for each block of a single variable on CPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloC (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#description_2","title":"Description","text":"<p>This function is a wraping fuction of the halo functions on CPU. It is called from the main Halo CPU function. This is layer 2 of 3 wrap so the candy doesn't stick too much. </p>"},{"location":"BGFlood/Halo_8cu/#function-fillhaloc-double","title":"function fillHaloC&lt; double &gt;","text":"<pre><code>template void fillHaloC&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhaloc-float","title":"function fillHaloC&lt; float &gt;","text":"<pre><code>template void fillHaloC&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalod","title":"function fillHaloD","text":"<p>Wrapping function for calculating halos on CPU on every side of a block of a single variable. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloD (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#description_3","title":"Description","text":"<p>This fuction is a wraping fuction of the halo functions for CPU. It is called from another wraping function to keep things clean. In a sense this is the third (and last) layer of wrapping </p>"},{"location":"BGFlood/Halo_8cu/#function-fillhalod-double","title":"function fillHaloD&lt; double &gt;","text":"<pre><code>template void fillHaloD&lt; double &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalod-float","title":"function fillHaloD&lt; float &gt;","text":"<pre><code>template void fillHaloD&lt; float &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalof","title":"function fillHaloF","text":"<p>Wrapping function for calculating flux in the halos for a block and a single variable on CPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloF (\n    Param XParam,\n    bool doProlongation,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#depreciated","title":"Depreciated","text":"<p>This function is was never sucessful and will never be used. It is fundamentally flawed because is doesn't preserve the balance of fluxes on the restiction interface It should be deleted soon </p>"},{"location":"BGFlood/Halo_8cu/#description_4","title":"Description","text":""},{"location":"BGFlood/Halo_8cu/#function-fillhalof-double","title":"function fillHaloF&lt; double &gt;","text":"<pre><code>template void fillHaloF&lt; double &gt; (\n    Param XParam,\n    bool doProlongation,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalof-float","title":"function fillHaloF&lt; float &gt;","text":"<pre><code>template void fillHaloF&lt; float &gt; (\n    Param XParam,\n    bool doProlongation,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu","title":"function fillHaloGPU","text":"<p>Wrapping function for calculating halos for each block of a single variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#description_5","title":"Description","text":"<p>This function is a wraping fuction of the halo functions on GPU. It is called from the main Halo GPU function. The present imnplementation is naive and slow one that calls the rather complex fillLeft type functions </p>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu_1","title":"function fillHaloGPU","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu_2","title":"function fillHaloGPU","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu_3","title":"function fillHaloGPU","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu_4","title":"function fillHaloGPU","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    GradientsP &lt; T &gt; Grad\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu_5","title":"function fillHaloGPU","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu-double","title":"function fillHaloGPU&lt; double &gt;","text":"<pre><code>template void fillHaloGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    cudaStream_t stream,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu-double_1","title":"function fillHaloGPU&lt; double &gt;","text":"<pre><code>template void fillHaloGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu-double_2","title":"function fillHaloGPU&lt; double &gt;","text":"<pre><code>template void fillHaloGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu-double_3","title":"function fillHaloGPU&lt; double &gt;","text":"<pre><code>template void fillHaloGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu-double_4","title":"function fillHaloGPU&lt; double &gt;","text":"<pre><code>template void fillHaloGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    GradientsP &lt; double &gt; Grad\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu-double_5","title":"function fillHaloGPU&lt; double &gt;","text":"<pre><code>template void fillHaloGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    FluxP &lt; double &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu-float","title":"function fillHaloGPU&lt; float &gt;","text":"<pre><code>template void fillHaloGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    cudaStream_t stream,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu-float_1","title":"function fillHaloGPU&lt; float &gt;","text":"<pre><code>template void fillHaloGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu-float_2","title":"function fillHaloGPU&lt; float &gt;","text":"<pre><code>template void fillHaloGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu-float_3","title":"function fillHaloGPU&lt; float &gt;","text":"<pre><code>template void fillHaloGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu-float_4","title":"function fillHaloGPU&lt; float &gt;","text":"<pre><code>template void fillHaloGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    GradientsP &lt; float &gt; Grad\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpu-float_5","title":"function fillHaloGPU&lt; float &gt;","text":"<pre><code>template void fillHaloGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    FluxP &lt; float &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpunew","title":"function fillHaloGPUnew","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpunew-double","title":"function fillHaloGPUnew&lt; double &gt;","text":"<pre><code>template void fillHaloGPUnew&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    cudaStream_t stream,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalogpunew-float","title":"function fillHaloGPUnew&lt; float &gt;","text":"<pre><code>template void fillHaloGPUnew&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    cudaStream_t stream,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalolrfluxc","title":"function fillHaloLRFluxC","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloLRFluxC (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalolrfluxc-double","title":"function fillHaloLRFluxC&lt; double &gt;","text":"<pre><code>template void fillHaloLRFluxC&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalolrfluxc-float","title":"function fillHaloLRFluxC&lt; float &gt;","text":"<pre><code>template void fillHaloLRFluxC&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhaloleftrightgpu","title":"function fillHaloLeftRightGPU","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloLeftRightGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhaloleftrightgpu-double","title":"function fillHaloLeftRightGPU&lt; double &gt;","text":"<pre><code>template void fillHaloLeftRightGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    cudaStream_t stream,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhaloleftrightgpu-float","title":"function fillHaloLeftRightGPU&lt; float &gt;","text":"<pre><code>template void fillHaloLeftRightGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    cudaStream_t stream,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhaloleftrightgpunew","title":"function fillHaloLeftRightGPUnew","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloLeftRightGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhaloleftrightgpunew-double","title":"function fillHaloLeftRightGPUnew&lt; double &gt;","text":"<pre><code>template void fillHaloLeftRightGPUnew&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    cudaStream_t stream,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhaloleftrightgpunew-float","title":"function fillHaloLeftRightGPUnew&lt; float &gt;","text":"<pre><code>template void fillHaloLeftRightGPUnew&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    cudaStream_t stream,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalotoprightc","title":"function fillHaloTopRightC","text":"<p>Wrapping function for calculating flux for halos for each block of a single variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloTopRightC (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#description_6","title":"Description","text":"<p>This function is a wraping function of the halo flux functions on GPU. It is called from the main Halo GPU function. The present imnplementation is naive and slow one that calls the rather complex fillLeft type functions </p>"},{"location":"BGFlood/Halo_8cu/#function-fillhalotoprightc-double","title":"function fillHaloTopRightC&lt; double &gt;","text":"<pre><code>template void fillHaloTopRightC&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalotoprightc-float","title":"function fillHaloTopRightC&lt; float &gt;","text":"<pre><code>template void fillHaloTopRightC&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalotoprightgpu","title":"function fillHaloTopRightGPU","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloTopRightGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalotoprightgpu-double","title":"function fillHaloTopRightGPU&lt; double &gt;","text":"<pre><code>template void fillHaloTopRightGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    cudaStream_t stream,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillhalotoprightgpu-float","title":"function fillHaloTopRightGPU&lt; float &gt;","text":"<pre><code>template void fillHaloTopRightGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    cudaStream_t stream,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillleft","title":"function fillLeft","text":"<pre><code>template&lt;class T&gt;\nvoid fillLeft (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillleft_1","title":"function fillLeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillLeft (\n    int halowidth,\n    int * active,\n    int * level,\n    int * leftbot,\n    int * lefttop,\n    int * rightbot,\n    int * botright,\n    int * topright,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillleft-double","title":"function fillLeft&lt; double &gt;","text":"<pre><code>template __global__ void fillLeft&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    int * leftbot,\n    int * lefttop,\n    int * rightbot,\n    int * botright,\n    int * topright,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillleft-float","title":"function fillLeft&lt; float &gt;","text":"<pre><code>template __global__ void fillLeft&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    int * leftbot,\n    int * lefttop,\n    int * rightbot,\n    int * botright,\n    int * topright,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillleftflux","title":"function fillLeftFlux","text":"<pre><code>template&lt;class T&gt;\nvoid fillLeftFlux (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillleftnew","title":"function fillLeftnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillLeftnew (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * leftbot,\n    int * lefttop,\n    int * rightbot,\n    int * botright,\n    int * topright,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillleftnew-double","title":"function fillLeftnew&lt; double &gt;","text":"<pre><code>template __global__ void fillLeftnew&lt; double &gt; (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * leftbot,\n    int * lefttop,\n    int * rightbot,\n    int * botright,\n    int * topright,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillleftnew-float","title":"function fillLeftnew&lt; float &gt;","text":"<pre><code>template __global__ void fillLeftnew&lt; float &gt; (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * leftbot,\n    int * lefttop,\n    int * rightbot,\n    int * botright,\n    int * topright,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillright","title":"function fillRight","text":"<pre><code>template&lt;class T&gt;\nvoid fillRight (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillright_1","title":"function fillRight","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillRight (\n    int halowidth,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillright-double","title":"function fillRight&lt; double &gt;","text":"<pre><code>template __global__ void fillRight&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillright-float","title":"function fillRight&lt; float &gt;","text":"<pre><code>template __global__ void fillRight&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillrightflux","title":"function fillRightFlux","text":"<pre><code>template&lt;class T&gt;\nvoid fillRightFlux (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillrightflux_1","title":"function fillRightFlux","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillRightFlux (\n    int halowidth,\n    bool doProlongation,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillrightflux-double","title":"function fillRightFlux&lt; double &gt;","text":"<pre><code>template void fillRightFlux&lt; double &gt; (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; double &gt; XBlock,\n    double *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillrightflux-double_1","title":"function fillRightFlux&lt; double &gt;","text":"<pre><code>template __global__ void fillRightFlux&lt; double &gt; (\n    int halowidth,\n    bool doProlongation,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillrightflux-float","title":"function fillRightFlux&lt; float &gt;","text":"<pre><code>template void fillRightFlux&lt; float &gt; (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; float &gt; XBlock,\n    float *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillrightflux-float_1","title":"function fillRightFlux&lt; float &gt;","text":"<pre><code>template __global__ void fillRightFlux&lt; float &gt; (\n    int halowidth,\n    bool doProlongation,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillrightnew","title":"function fillRightnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillRightnew (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillrightnew-double","title":"function fillRightnew&lt; double &gt;","text":"<pre><code>template __global__ void fillRightnew&lt; double &gt; (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-fillrightnew-float","title":"function fillRightnew&lt; float &gt;","text":"<pre><code>template __global__ void fillRightnew&lt; float &gt; (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-filltop","title":"function fillTop","text":"<pre><code>template&lt;class T&gt;\nvoid fillTop (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-filltop_1","title":"function fillTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillTop (\n    int halowidth,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-filltop-double","title":"function fillTop&lt; double &gt;","text":"<pre><code>template __global__ void fillTop&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-filltop-float","title":"function fillTop&lt; float &gt;","text":"<pre><code>template __global__ void fillTop&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-filltopflux","title":"function fillTopFlux","text":"<pre><code>template&lt;class T&gt;\nvoid fillTopFlux (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-filltopflux_1","title":"function fillTopFlux","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillTopFlux (\n    int halowidth,\n    bool doProlongation,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-filltopflux-double","title":"function fillTopFlux&lt; double &gt;","text":"<pre><code>template void fillTopFlux&lt; double &gt; (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; double &gt; XBlock,\n    double *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-filltopflux-double_1","title":"function fillTopFlux&lt; double &gt;","text":"<pre><code>template __global__ void fillTopFlux&lt; double &gt; (\n    int halowidth,\n    bool doProlongation,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-filltopflux-float","title":"function fillTopFlux&lt; float &gt;","text":"<pre><code>template void fillTopFlux&lt; float &gt; (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; float &gt; XBlock,\n    float *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-filltopflux-float_1","title":"function fillTopFlux&lt; float &gt;","text":"<pre><code>template __global__ void fillTopFlux&lt; float &gt; (\n    int halowidth,\n    bool doProlongation,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-filltopnew","title":"function fillTopnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillTopnew (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-filltopnew-double","title":"function fillTopnew&lt; double &gt;","text":"<pre><code>template __global__ void fillTopnew&lt; double &gt; (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-filltopnew-float","title":"function fillTopnew&lt; float &gt;","text":"<pre><code>template __global__ void fillTopnew&lt; float &gt; (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear","title":"function refine_linear","text":"<pre><code>template&lt;class T&gt;\nvoid refine_linear (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear-double","title":"function refine_linear&lt; double &gt;","text":"<pre><code>template void refine_linear&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear-float","title":"function refine_linear&lt; float &gt;","text":"<pre><code>template void refine_linear&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_lineargpu","title":"function refine_linearGPU","text":"<pre><code>template&lt;class T&gt;\nvoid refine_linearGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_lineargpu-double","title":"function refine_linearGPU&lt; double &gt;","text":"<pre><code>template void refine_linearGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_lineargpu-float","title":"function refine_linearGPU&lt; float &gt;","text":"<pre><code>template void refine_linearGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_bot","title":"function refine_linear_Bot","text":"<pre><code>template&lt;class T&gt;\nvoid refine_linear_Bot (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_bot-double","title":"function refine_linear_Bot&lt; double &gt;","text":"<pre><code>template void refine_linear_Bot&lt; double &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_bot-float","title":"function refine_linear_Bot&lt; float &gt;","text":"<pre><code>template void refine_linear_Bot&lt; float &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_botgpu","title":"function refine_linear_BotGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void refine_linear_BotGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_botgpu-double","title":"function refine_linear_BotGPU&lt; double &gt;","text":"<pre><code>template __global__ void refine_linear_BotGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_botgpu-float","title":"function refine_linear_BotGPU&lt; float &gt;","text":"<pre><code>template __global__ void refine_linear_BotGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_left","title":"function refine_linear_Left","text":"<pre><code>template&lt;class T&gt;\nvoid refine_linear_Left (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_left-double","title":"function refine_linear_Left&lt; double &gt;","text":"<pre><code>template void refine_linear_Left&lt; double &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_left-float","title":"function refine_linear_Left&lt; float &gt;","text":"<pre><code>template void refine_linear_Left&lt; float &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_leftgpu","title":"function refine_linear_LeftGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void refine_linear_LeftGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_leftgpu-double","title":"function refine_linear_LeftGPU&lt; double &gt;","text":"<pre><code>template __global__ void refine_linear_LeftGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_leftgpu-float","title":"function refine_linear_LeftGPU&lt; float &gt;","text":"<pre><code>template __global__ void refine_linear_LeftGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_right","title":"function refine_linear_Right","text":"<pre><code>template&lt;class T&gt;\nvoid refine_linear_Right (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_right-double","title":"function refine_linear_Right&lt; double &gt;","text":"<pre><code>template void refine_linear_Right&lt; double &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_right-float","title":"function refine_linear_Right&lt; float &gt;","text":"<pre><code>template void refine_linear_Right&lt; float &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_rightgpu","title":"function refine_linear_RightGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void refine_linear_RightGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_rightgpu-double","title":"function refine_linear_RightGPU&lt; double &gt;","text":"<pre><code>template __global__ void refine_linear_RightGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_rightgpu-float","title":"function refine_linear_RightGPU&lt; float &gt;","text":"<pre><code>template __global__ void refine_linear_RightGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_top","title":"function refine_linear_Top","text":"<pre><code>template&lt;class T&gt;\nvoid refine_linear_Top (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_top-double","title":"function refine_linear_Top&lt; double &gt;","text":"<pre><code>template void refine_linear_Top&lt; double &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_top-float","title":"function refine_linear_Top&lt; float &gt;","text":"<pre><code>template void refine_linear_Top&lt; float &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_topgpu","title":"function refine_linear_TopGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void refine_linear_TopGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_topgpu-double","title":"function refine_linear_TopGPU&lt; double &gt;","text":"<pre><code>template __global__ void refine_linear_TopGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8cu/#function-refine_linear_topgpu-float","title":"function refine_linear_TopGPU&lt; float &gt;","text":"<pre><code>template __global__ void refine_linear_TopGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Halo.cu</code></p>"},{"location":"BGFlood/Halo_8cu_source/","title":"File Halo.cu","text":""},{"location":"BGFlood/Halo_8cu_source/#file-halocu","title":"File Halo.cu","text":"<p>File List &gt; src &gt; Halo.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Halo.h\"\n\n\ntemplate &lt;class T&gt; void fillHaloD(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z)\n{\n\n\n    fillLeft(XParam, ib, XBlock, z);\n    fillRight(XParam, ib, XBlock, z);\n    fillTop(XParam, ib, XBlock, z);\n    fillBot(XParam, ib, XBlock, z);\n    //fill bot\n    //fill top\n\n\n}\ntemplate void fillHaloD&lt;double&gt;(Param XParam, int ib, BlockP&lt;double&gt; XBlock, double* z);\ntemplate void fillHaloD&lt;float&gt;(Param XParam, int ib, BlockP&lt;float&gt; XBlock, float* z);\n\ntemplate &lt;class T&gt; void fillHaloC(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        fillHaloD(XParam, ib, XBlock, z);\n    }\n}\ntemplate void fillHaloC&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z);\ntemplate void fillHaloC&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z);\n\ntemplate &lt;class T&gt; void RecalculateZs(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb)\n{\n    int ib, n;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        /*\n        //We only need to recalculate zs on the halo side \n        for (int n = -1; n &lt;= (XParam.blkwidth); n++)\n        {\n            left = memloc(XParam.halowidth, XParam.blkmemwidth, -1, n, ib);\n            right = memloc(XParam.halowidth, XParam.blkmemwidth, XParam.blkwidth, n, ib);\n            top = memloc(XParam.halowidth, XParam.blkmemwidth, n, XParam.blkwidth, ib);\n            bot = memloc(XParam.halowidth, XParam.blkmemwidth, n, -1, ib);\n\n            Xev.zs[left] = zb[left] + Xev.h[left];\n            Xev.zs[right] = zb[right] + Xev.h[right];\n            Xev.zs[top] = zb[top] + Xev.h[top];\n            Xev.zs[bot] = zb[bot] + Xev.h[bot];\n\n            //printf(\"n=%d; zsold=%f; zsnew=%f (zb=%f + h=%f)\\n\",n, Xev.zs[n], zb[n] + Xev.h[n], zb[n] , Xev.h[n]);\n        }\n        */\n\n        // Recalculate zs everywhere maybe we only need to do that on the halo ?\n        for (int j = -1; j &lt; (XParam.blkwidth+1); j++)\n        {\n            for (int i = -1; i &lt; (XParam.blkwidth+1); i++)\n            {\n                n = memloc(XParam.halowidth,XParam.blkmemwidth, i, j, ib);\n                Xev.zs[n] = zb[n] + Xev.h[n];\n            }\n        }\n\n    }\n}\ntemplate void RecalculateZs&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float* zb);\ntemplate void RecalculateZs&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, double* zb);\n\ntemplate &lt;class T&gt; void Recalculatehh(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb)\n{\n    int ib, n;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        /*\n        //We only need to recalculate zs on the halo side\n        for (int n = -1; n &lt;= (XParam.blkwidth); n++)\n        {\n            left = memloc(XParam.halowidth, XParam.blkmemwidth, -1, n, ib);\n            right = memloc(XParam.halowidth, XParam.blkmemwidth, XParam.blkwidth, n, ib);\n            top = memloc(XParam.halowidth, XParam.blkmemwidth, n, XParam.blkwidth, ib);\n            bot = memloc(XParam.halowidth, XParam.blkmemwidth, n, -1, ib);\n\n            Xev.zs[left] = zb[left] + Xev.h[left];\n            Xev.zs[right] = zb[right] + Xev.h[right];\n            Xev.zs[top] = zb[top] + Xev.h[top];\n            Xev.zs[bot] = zb[bot] + Xev.h[bot];\n\n            //printf(\"n=%d; zsold=%f; zsnew=%f (zb=%f + h=%f)\\n\",n, Xev.zs[n], zb[n] + Xev.h[n], zb[n] , Xev.h[n]);\n        }\n        */\n\n        // Recalculate zs everywhere maybe we only need to do that on the halo ?\n        for (int j = -1; j &lt; (XParam.blkwidth + 1); j++)\n        {\n            for (int i = -1; i &lt; (XParam.blkwidth + 1); i++)\n            {\n                n = memloc(XParam.halowidth, XParam.blkmemwidth, i, j, ib);\n\n                Xev.h[n] = max(Xev.zs[n]- zb[n],(T)0.0) ;\n            }\n        }\n\n    }\n}\ntemplate void Recalculatehh&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float* zb);\ntemplate void Recalculatehh&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, double* zb);\n\n\ntemplate &lt;class T&gt; __global__ void RecalculateZsGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb)\n{\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n\n    int ix = threadIdx.x -1;\n    int iy = threadIdx.y -1;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int  n;\n\n    //ib = XBlock.active[ibl];\n\n    n = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n    Xev.zs[n] = zb[n] + Xev.h[n];\n    /*\n    if(zb[n] &lt; XParam.eps)\n    {\n        printf(\"ix=%d, iy=%d, ib=%d, n=%d; zsold=%f; zsnew=%f (zb=%f + h=%f)\\n\",ix,iy,ib, n, Xev.zs[n], zb[n] + Xev.h[n], zb[n], Xev.h[n]);\n    }\n    */\n\n}\ntemplate __global__ void RecalculateZsGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float* zb);\ntemplate __global__ void RecalculateZsGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, double* zb);\n\ntemplate &lt;class T&gt; void fillHaloF(Param XParam, bool doProlongation, BlockP&lt;T&gt; XBlock, T* z)\n{\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        fillLeftFlux(XParam, doProlongation, ib, XBlock, z);\n        fillBotFlux(XParam, doProlongation, ib, XBlock, z);\n        fillRightFlux(XParam, doProlongation, ib, XBlock, z);\n        fillTopFlux(XParam, doProlongation, ib, XBlock, z);\n\n    }\n}\ntemplate void fillHaloF&lt;float&gt;(Param XParam, bool doProlongation, BlockP&lt;float&gt; XBlock, float* z);\ntemplate void fillHaloF&lt;double&gt;(Param XParam, bool doProlongation, BlockP&lt;double&gt; XBlock, double* z);\n\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z)\n{\n\n    dim3 blockDimHaloLR(1, XParam.blkwidth, 1);\n    dim3 blockDimHaloBT(XParam.blkwidth, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    fillLeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, z);\n    //fillLeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    fillRight &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    //fillRight &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    fillBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, z);\n    //fillBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0&gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    fillTop &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    //fillTop &lt;&lt;&lt;gridDim, blockDimHaloBT, 0&gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    //CUDA_CHECK(cudaStreamSynchronize(stream));\n\n}\ntemplate void fillHaloGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, cudaStream_t stream, double* z);\ntemplate void fillHaloGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, cudaStream_t stream, float* z);\n\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock,  T* z)\n{\n\n    dim3 blockDimHaloLR(1, XParam.blkwidth, 1);\n    dim3 blockDimHaloBT(XParam.blkwidth, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    fillLeft &lt;&lt; &lt;gridDim, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, z);\n    //fillLeft &lt;&lt; &lt;gridDim, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    fillRight &lt;&lt; &lt;gridDim, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    //fillRight &lt;&lt; &lt;gridDim, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    fillBot &lt;&lt; &lt;gridDim, blockDimHaloBT, 0 &gt;&gt; &gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, z);\n    //fillBot &lt;&lt; &lt;gridDim, blockDimHaloBT, 0&gt;&gt; &gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    fillTop &lt;&lt; &lt;gridDim, blockDimHaloBT, 0 &gt;&gt; &gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    //fillTop &lt;&lt; &lt;gridDim, blockDimHaloBT, 0&gt;&gt; &gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    //CUDA_CHECK(cudaStreamSynchronize(stream));\n\n}\ntemplate void fillHaloGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock,double* z);\ntemplate void fillHaloGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z);\n\n\ntemplate &lt;class T&gt; void fillHaloGPUnew(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z)\n{\n    dim3 blockDimHaloLR(1, XParam.blkwidth, 1);\n    dim3 blockDimHaloBT(XParam.blkwidth, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    dim3 blockDimHaloLRx2(2, XParam.blkwidth, 1);\n    dim3 blockDimHaloBTx2(XParam.blkwidth, 2, 1);\n    dim3 gridDimx2(ceil(XParam.nblk/2), 1, 1);\n\n    //fillLeftnew &lt;&lt;&lt;gridDimx2, blockDimHaloLRx2, 0&gt;&gt;&gt; (XParam.halowidth, XParam.nblk, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, z);\n    fillLeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    //fillRightnew &lt;&lt;&lt;gridDimx2, blockDimHaloLRx2, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.nblk, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    fillRight &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    //fillBotnew &lt;&lt;&lt;gridDimx2, blockDimHaloBTx2, 0&gt;&gt;&gt; (XParam.halowidth, XParam.nblk, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, z);\n    fillBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0&gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    //fillTopnew &lt;&lt;&lt;gridDimx2, blockDimHaloBTx2, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.nblk, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    fillTop &lt;&lt;&lt;gridDim, blockDimHaloBT, 0&gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    //CUDA_CHECK(cudaStreamSynchronize(stream));\n\n}\ntemplate void fillHaloGPUnew&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, cudaStream_t stream, double* z);\ntemplate void fillHaloGPUnew&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, cudaStream_t stream, float* z);\n\n\ntemplate &lt;class T&gt; void fillHaloTopRightC(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    // for flux term and actually most terms, only top and right neighbours are needed!\n\n    //fillLeft(XParam, ib, XBlock, z);\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        HaloFluxCPULR(XParam, ib, XBlock, z);\n        HaloFluxCPUBT(XParam, ib, XBlock, z);\n\n        //fillRightFlux(XParam,true, ib, XBlock, z);\n        //fillTopFlux(XParam,true, ib, XBlock, z);\n\n    }\n\n\n\n}\ntemplate void fillHaloTopRightC&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z);\ntemplate void fillHaloTopRightC&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z);\n\ntemplate &lt;class T&gt; void fillHaloLRFluxC(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    // for flux term and actually most terms, only top and right neighbours are needed!\n\n    //fillLeft(XParam, ib, XBlock, z);\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        HaloFluxCPULR(XParam, ib, XBlock, z);\n        //HaloFluxCPUBT(XParam, ib, XBlock, z);\n\n        //fillRightFlux(XParam,true, ib, XBlock, z);\n        //fillTopFlux(XParam,true, ib, XBlock, z);\n\n    }\n\n\n\n}\ntemplate void fillHaloLRFluxC&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z);\ntemplate void fillHaloLRFluxC&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z);\n\ntemplate &lt;class T&gt; void fillHaloBTFluxC(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    // for flux term and actually most terms, only top and right neighbours are needed!\n\n    //fillLeft(XParam, ib, XBlock, z);\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        //HaloFluxCPULR(XParam, ib, XBlock, z);\n        HaloFluxCPUBT(XParam, ib, XBlock, z);\n\n        //fillRightFlux(XParam,true, ib, XBlock, z);\n        //fillTopFlux(XParam,true, ib, XBlock, z);\n\n    }\n\n\n\n}\ntemplate void fillHaloBTFluxC&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z);\ntemplate void fillHaloBTFluxC&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z);\n\n\n\ntemplate &lt;class T&gt; void fillHaloTopRightGPU(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z)\n{\n\n    dim3 blockDimHaloLR(1, 16, 1);\n    dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n\n    //fillLeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, a);\n    //fillRightFlux &lt;&lt;&lt;gridDim, blockDimHaloLR, 0, stream &gt;&gt;&gt; (XParam.halowidth,false, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    HaloFluxGPULR &lt;&lt;&lt;gridDim, blockDimHaloLR, 0, stream &gt;&gt;&gt; (XParam, XBlock, z);\n\n    //fillBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, a);\n    //fillTopFlux &lt;&lt;&lt;gridDim, blockDimHaloBT, 0, stream &gt;&gt;&gt; (XParam.halowidth,false, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    HaloFluxGPUBT &lt;&lt;&lt;gridDim, blockDimHaloBT, 0, stream &gt;&gt;&gt; (XParam, XBlock, z);\n    CUDA_CHECK(cudaStreamSynchronize(stream));\n\n}\ntemplate void fillHaloTopRightGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, cudaStream_t stream, double* z);\ntemplate void fillHaloTopRightGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, cudaStream_t stream, float* z);\n\ntemplate &lt;class T&gt; void fillHaloLeftRightGPU(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z)\n{\n\n    dim3 blockDimHaloLR(1, 16, 1);\n    //dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n\n    //fillLeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, a);\n    //fillRightFlux &lt;&lt;&lt;gridDim, blockDimHaloLR, 0, stream &gt;&gt;&gt; (XParam.halowidth,false, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    HaloFluxGPULR &lt;&lt;&lt;gridDim, blockDimHaloLR, 0, stream &gt;&gt;&gt; (XParam, XBlock, z);\n\n    //fillBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, a);\n    //fillTopFlux &lt;&lt;&lt;gridDim, blockDimHaloBT, 0, stream &gt;&gt;&gt; (XParam.halowidth,false, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    //HaloFluxGPUBT &lt;&lt;&lt;gridDim, blockDimHaloBT, 0, stream &gt;&gt;&gt; (XParam, XBlock, z);\n    //CUDA_CHECK(cudaStreamSynchronize(stream));\n\n}\ntemplate void fillHaloLeftRightGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, cudaStream_t stream, double* z);\ntemplate void fillHaloLeftRightGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, cudaStream_t stream, float* z);\n\ntemplate &lt;class T&gt; void fillHaloLeftRightGPUnew(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z)\n{\n\n    dim3 blockDimHaloLR(2, 16, 1);\n    //dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDim(ceil(XParam.nblk/2), 1, 1);\n\n    HaloFluxGPULRnew &lt;&lt;&lt;gridDim, blockDimHaloLR, 0, stream &gt;&gt;&gt; (XParam, XBlock, z);\n\n\n\n}\ntemplate void fillHaloLeftRightGPUnew&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, cudaStream_t stream, double* z);\ntemplate void fillHaloLeftRightGPUnew&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, cudaStream_t stream, float* z);\n\ntemplate &lt;class T&gt; void fillHaloBotTopGPU(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z)\n{\n\n    //dim3 blockDimHaloLR(1, 16, 1);\n    dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n\n    //fillLeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, a);\n    //fillRightFlux &lt;&lt;&lt;gridDim, blockDimHaloLR, 0, stream &gt;&gt;&gt; (XParam.halowidth,false, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    //HaloFluxGPULR &lt;&lt;&lt;gridDim, blockDimHaloLR, 0, stream &gt;&gt;&gt; (XParam, XBlock, z);\n\n    //fillBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, a);\n    //fillTopFlux &lt;&lt;&lt;gridDim, blockDimHaloBT, 0, stream &gt;&gt;&gt; (XParam.halowidth,false, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    HaloFluxGPUBT &lt;&lt;&lt;gridDim, blockDimHaloBT, 0, stream &gt;&gt;&gt; (XParam, XBlock, z);\n    //CUDA_CHECK(cudaStreamSynchronize(stream));\n\n}\ntemplate void fillHaloBotTopGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, cudaStream_t stream, double* z);\ntemplate void fillHaloBotTopGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, cudaStream_t stream, float* z);\n\ntemplate &lt;class T&gt; void fillHaloBotTopGPUnew(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z)\n{\n\n    //dim3 blockDimHaloLR(1, 16, 1);\n    dim3 blockDimHaloBT(16, 2, 1);\n    dim3 gridDim(ceil(XParam.nblk/2), 1, 1);\n\n\n    HaloFluxGPUBTnew &lt;&lt;&lt;gridDim, blockDimHaloBT, 0, stream &gt;&gt;&gt; (XParam, XBlock, z);\n\n\n}\ntemplate void fillHaloBotTopGPUnew&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, cudaStream_t stream, double* z);\ntemplate void fillHaloBotTopGPUnew&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, cudaStream_t stream, float* z);\n\n\ntemplate &lt;class T&gt; void fillHalo(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T*zb)\n{\n\n\n        std::thread t0(fillHaloC&lt;T&gt;,XParam, XBlock, Xev.h);\n        std::thread t1(fillHaloC&lt;T&gt;,XParam, XBlock, Xev.zs);\n        //std::thread t2(fillHaloF&lt;T&gt;,XParam,true, XBlock, Xev.u);\n        //std::thread t3(fillHaloF&lt;T&gt;,XParam,true, XBlock, Xev.v);\n\n        std::thread t2(fillHaloC&lt;T&gt;, XParam, XBlock, Xev.u);\n        std::thread t3(fillHaloC&lt;T&gt;, XParam, XBlock, Xev.v);\n\n        t0.join();\n        t1.join();\n        t2.join();\n        t3.join();\n\n        if (XParam.conserveElevation)\n        {\n            conserveElevation(XParam, XBlock, Xev, zb);\n        }\n        else if (XParam.wetdryfix)\n        {\n            WetDryRestriction(XParam, XBlock, Xev, zb);\n        }\n\n        RecalculateZs(XParam, XBlock, Xev, zb);\n\n        maskbnd(XParam, XBlock, Xev, zb);\n\n}\ntemplate void fillHalo&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float *zb);\ntemplate void fillHalo&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev,double * zb);\n\ntemplate &lt;class T&gt; void fillHalo(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev)\n{\n\n    std::thread t0(fillHaloC&lt;T&gt;, XParam, XBlock, Xev.h);\n    std::thread t1(fillHaloC&lt;T&gt;, XParam, XBlock, Xev.zs);\n    std::thread t2(fillHaloF&lt;T&gt;, XParam, true, XBlock, Xev.u);\n    std::thread t3(fillHaloF&lt;T&gt;, XParam, true, XBlock, Xev.v);\n\n    t0.join();\n    t1.join();\n    t2.join();\n    t3.join();\n\n\n    //maskbnd(XParam, XBlock, Xev, zb);\n\n}\ntemplate void fillHalo&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev);\ntemplate void fillHalo&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev);\n\n\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev)\n{\n    const int num_streams = 4;\n\n    cudaStream_t streams[num_streams];\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n    }\n\n\n    fillHaloGPU(XParam, XBlock, streams[0], Xev.h);\n    fillHaloGPU(XParam, XBlock, streams[1], Xev.zs);\n    fillHaloGPU(XParam, XBlock, streams[2], Xev.u);\n    fillHaloGPU(XParam, XBlock, streams[3], Xev.v);\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamDestroy(streams[i]);\n    }\n}\ntemplate void fillHaloGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev);\ntemplate void fillHaloGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev);\n\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev,T * zb)\n{\n    const int num_streams = 4;\n    dim3 blockDimHalo(XParam.blkwidth,1, 1);\n\n    dim3 gridDim(XBlock.mask.nblk, 1, 1);\n\n    dim3 blockDimfull(XParam.blkmemwidth, XParam.blkmemwidth, 1);\n    dim3 gridDimfull(XParam.nblk, 1, 1);\n\n    cudaStream_t streams[num_streams];\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n    }\n\n\n    fillHaloGPU(XParam, XBlock, streams[0], Xev.h);\n    fillHaloGPU(XParam, XBlock, streams[1], Xev.zs);\n    fillHaloGPU(XParam, XBlock, streams[2], Xev.u);\n    fillHaloGPU(XParam, XBlock, streams[3], Xev.v);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    if (XParam.conserveElevation)\n    {\n        conserveElevationGPU(XParam, XBlock, Xev, zb);\n    }\n    else if (XParam.wetdryfix)\n    {\n        WetDryRestrictionGPU(XParam, XBlock, Xev, zb);\n    }\n\n    RecalculateZsGPU &lt;&lt;&lt; gridDimfull, blockDimfull, 0 &gt;&gt;&gt; (XParam, XBlock, Xev, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //if (XBlock.mask.nblk &gt; 0)\n    //{\n    //  maskbndGPUleft &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[0] &gt;&gt;&gt; (XParam, XBlock, Xev, zb);\n    //  maskbndGPUtop &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[1] &gt;&gt;&gt; (XParam, XBlock, Xev, zb);\n    //  maskbndGPUright &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[2] &gt;&gt;&gt; (XParam, XBlock, Xev, zb);\n    //  maskbndGPUtop &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[3] &gt;&gt;&gt; (XParam, XBlock, Xev, zb);\n\n    //  //CUDA_CHECK(cudaDeviceSynchronize());\n    //}\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamDestroy(streams[i]);\n    }\n\n\n}\ntemplate void fillHaloGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev,float *zb);\ntemplate void fillHaloGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev,double* zb);\n\ntemplate &lt;class T&gt; void fillHalo(Param XParam, BlockP&lt;T&gt; XBlock, GradientsP&lt;T&gt; Grad)\n{\n\n    /*\n    std::thread t0(fillHaloF&lt;T&gt;,XParam, true, XBlock, Grad.dhdx);\n    std::thread t1(fillHaloF&lt;T&gt;,XParam, true, XBlock, Grad.dudx);\n    std::thread t2(fillHaloF&lt;T&gt;,XParam, true, XBlock, Grad.dvdx);\n    std::thread t3(fillHaloF&lt;T&gt;,XParam, true, XBlock, Grad.dzsdx);\n\n    std::thread t4(fillHaloF&lt;T&gt;,XParam, true, XBlock, Grad.dhdy);\n    std::thread t5(fillHaloF&lt;T&gt;,XParam, true, XBlock, Grad.dudy);\n    std::thread t6(fillHaloF&lt;T&gt;,XParam, true, XBlock, Grad.dvdy);\n    std::thread t7(fillHaloF&lt;T&gt;,XParam, true, XBlock, Grad.dzsdy);\n\n    */\n    std::thread t0(fillHaloC&lt;T&gt;, XParam, XBlock, Grad.dhdx);\n    std::thread t1(fillHaloC&lt;T&gt;, XParam, XBlock, Grad.dudx);\n    std::thread t2(fillHaloC&lt;T&gt;, XParam, XBlock, Grad.dvdx);\n    std::thread t3(fillHaloC&lt;T&gt;, XParam, XBlock, Grad.dzsdx);\n\n    std::thread t4(fillHaloC&lt;T&gt;, XParam, XBlock, Grad.dhdy);\n    std::thread t5(fillHaloC&lt;T&gt;, XParam, XBlock, Grad.dudy);\n    std::thread t6(fillHaloC&lt;T&gt;, XParam, XBlock, Grad.dvdy);\n    std::thread t7(fillHaloC&lt;T&gt;, XParam, XBlock, Grad.dzsdy);\n\n    t0.join();\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n    t5.join();\n    t6.join();\n    t7.join();\n\n\n}\ntemplate void fillHalo&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, GradientsP&lt;float&gt; Grad);\ntemplate void fillHalo&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, GradientsP&lt;double&gt; Grad);\n\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, GradientsP&lt;T&gt; Grad)\n{\n    const int num_streams = 8;\n\n    cudaStream_t streams[num_streams];\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n    }\n\n    fillHaloGPU(XParam, XBlock, streams[0], Grad.dhdx);\n    fillHaloGPU(XParam, XBlock, streams[2], Grad.dudx);\n    fillHaloGPU(XParam, XBlock, streams[3], Grad.dvdx);\n    fillHaloGPU(XParam, XBlock, streams[4], Grad.dzsdx);\n\n    fillHaloGPU(XParam, XBlock, streams[5], Grad.dhdy);\n    fillHaloGPU(XParam, XBlock, streams[6], Grad.dudy);\n    fillHaloGPU(XParam, XBlock, streams[7], Grad.dvdy);\n    fillHaloGPU(XParam, XBlock, streams[1], Grad.dzsdy);\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamDestroy(streams[i]);\n    }\n\n}\ntemplate void fillHaloGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, GradientsP&lt;float&gt; Grad);\ntemplate void fillHaloGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, GradientsP&lt;double&gt; Grad);\n\n\ntemplate &lt;class T&gt; void fillHalo(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux)\n{\n\n\n    //std::thread t0(fillHaloTopRightC&lt;T&gt;,XParam, XBlock, Flux.Fhu);\n    //std::thread t1(fillHaloTopRightC&lt;T&gt;,XParam, XBlock, Flux.Fhv);\n    //std::thread t2(fillHaloTopRightC&lt;T&gt;,XParam, XBlock, Flux.Fqux);\n    //std::thread t3(fillHaloTopRightC&lt;T&gt;, XParam, XBlock, Flux.Fquy);\n\n    //std::thread t4(fillHaloTopRightC&lt;T&gt;, XParam, XBlock, Flux.Fqvx);\n    //std::thread t5(fillHaloTopRightC&lt;T&gt;, XParam, XBlock, Flux.Fqvy);\n    //std::thread t6(fillHaloTopRightC&lt;T&gt;, XParam, XBlock, Flux.Su);\n    //std::thread t7(fillHaloTopRightC&lt;T&gt;, XParam, XBlock, Flux.Sv);\n\n    std::thread t0(fillHaloLRFluxC&lt;T&gt;, XParam, XBlock, Flux.Fhu);\n    std::thread t1(fillHaloLRFluxC&lt;T&gt;, XParam, XBlock, Flux.Fqux);\n    std::thread t2(fillHaloLRFluxC&lt;T&gt;, XParam, XBlock, Flux.Su);\n\n    std::thread t6(fillHaloLRFluxC&lt;T&gt;, XParam, XBlock, Flux.Fqvx);\n\n    std::thread t3(fillHaloBTFluxC&lt;T&gt;, XParam, XBlock, Flux.Fhv);\n    std::thread t4(fillHaloBTFluxC&lt;T&gt;, XParam, XBlock, Flux.Fqvy);\n    std::thread t5(fillHaloBTFluxC&lt;T&gt;, XParam, XBlock, Flux.Sv);\n\n    std::thread t7(fillHaloBTFluxC&lt;T&gt;, XParam, XBlock, Flux.Fquy);\n\n    t0.join();\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n    t5.join();\n    t6.join();\n    t7.join();\n\n}\ntemplate void fillHalo&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, FluxP&lt;float&gt; Flux);\ntemplate void fillHalo&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, FluxP&lt;double&gt; Flux);\n\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux)\n{\n    const int num_streams = 8;\n\n    cudaStream_t streams[num_streams];\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n    }\n\n    dim3 blockDimHalo(XParam.blkwidth, 1, 1);\n\n    dim3 gridDim(XBlock.mask.nblk, 1, 1);\n\n\n    fillHaloLeftRightGPUnew(XParam, XBlock, streams[0], Flux.Fhu);\n    fillHaloLeftRightGPUnew(XParam, XBlock, streams[1], Flux.Su);\n    fillHaloLeftRightGPUnew(XParam, XBlock, streams[2], Flux.Fqux);\n    fillHaloLeftRightGPUnew(XParam, XBlock, streams[3], Flux.Fqvx);\n\n\n\n    fillHaloBotTopGPUnew(XParam, XBlock, streams[4], Flux.Fquy);\n    fillHaloBotTopGPUnew(XParam, XBlock, streams[5], Flux.Fqvy);\n    fillHaloBotTopGPUnew(XParam, XBlock, streams[6], Flux.Fhv);\n    fillHaloBotTopGPUnew(XParam, XBlock, streams[7], Flux.Sv);\n\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamSynchronize(streams[i]);\n    }\n    // Below has now moved to its own function\n    //if (XBlock.mask.nblk &gt; 0)\n    //{\n    //  maskbndGPUFluxleft &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[0] &gt;&gt;&gt; (XParam, XBlock, Flux);\n    //  maskbndGPUFluxtop &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[1] &gt;&gt;&gt; (XParam, XBlock, Flux);\n    //  maskbndGPUFluxright &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[2] &gt;&gt;&gt; (XParam, XBlock, Flux);\n    //  maskbndGPUFluxbot &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[3] &gt;&gt;&gt; (XParam, XBlock, Flux);\n\n    //  //CUDA_CHECK(cudaDeviceSynchronize());\n    //}\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamDestroy(streams[i]);\n    }\n\n\n}\ntemplate void fillHaloGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, FluxP&lt;float&gt; Flux);\ntemplate void fillHaloGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, FluxP&lt;double&gt; Flux);\n\ntemplate &lt;class T&gt; void bndmaskGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, FluxP&lt;T&gt; Flux)\n{\n    const int num_streams = 8;\n\n    cudaStream_t streams[num_streams];\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n    }\n\n    dim3 blockDimHalo(XParam.blkwidth, 1, 1);\n\n    dim3 gridDim(XBlock.mask.nblk, 1, 1);\n    if (XBlock.mask.nblk &gt; 0)\n    {\n        maskbndGPUFluxleft &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[0] &gt;&gt;&gt; (XParam, XBlock, Xev, Flux);\n        maskbndGPUFluxtop &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[1] &gt;&gt;&gt; (XParam, XBlock,  Flux);\n        maskbndGPUFluxright &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[2] &gt;&gt;&gt; (XParam, XBlock,  Flux);\n        maskbndGPUFluxbot &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[3] &gt;&gt;&gt; (XParam, XBlock, Flux);\n\n        //CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamDestroy(streams[i]);\n    }\n\n}\ntemplate void bndmaskGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, FluxP&lt;float&gt; Flux);\ntemplate void bndmaskGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, FluxP&lt;double&gt; Flux);\n\n//template &lt;class T&gt; void refine_linearCPU(Param XParam, int ib, bool isLR, bool isoposit, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n//{\n//  int Neighblock, Mirrorblock;\n//\n//  int ir = isoposit ? 0 : XParam.blkwidth - 1;\n//  int iw = isoposit ? XParam.blkwidth : -1;\n//  if (isLR)\n//  {\n//      Neighblock = isoposit ? XBlock.RightBot[ib] : XBlock.LeftBot[ib];\n//      Mirrorblock = isoposit ? XBlock.LeftBot[Neighblock] : XBlock.RightBot[Neighblock]\n//  }\n//  else\n//  {\n//      Neighblock = isoposit ? XBlock.TopLeft[ib] : XBlock.BotLeft[ib];\n//      Mirrorblock = isoposit ? XBlock.BotLeft[Neighblock] : XBlock.TopLeft[Neighblock]\n//  }\n//\n//  if (XBlock.level[Neighblock] &lt; XBlock.level[ib])\n//  {\n//      double ilevdx = calcres(XParam.dx, XBlock.level[ib]) * T(0.25);\n//      for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n//      {\n//          int jj = Mirrorblock == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + XParam.blkwidth / 2;\n//          int il = isLR ? memloc(XParam, ir, jj, Neighblock) : memloc(XParam, jj, ir, Neighblock);\n//          int write = isLR ? memloc(XParam, iw, j, ib) : memloc(XParam, j, iw, ib);\n//          T faclr = T(-1.0);\n//          T facbt = floor(j * (T)0.5) * T(2.0) &gt; j ? 1.0 : -1.0;\n//\n//          T newz = z[il] + (faclr * dzdx[il] + facbt * dzdy[il]) * ilevdx;\n//\n//          z[write] = newz;\n//\n//\n//      }\n//  }\n//}\n//template void refine_linearCPU&lt;float&gt;(Param XParam, int ib, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\n//template void refine_linearCPU&lt;double&gt;(Param XParam, int ib, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\ntemplate &lt;class T&gt; void refine_linear_Left(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z, T * dzdx, T * dzdy)\n{\n    if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib])\n    {\n\n        double ilevdx = calcres(XParam.delta, XBlock.level[ib])*T(0.5);\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            int jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib ? ftoi(floor(j * (T)0.5)) : ftoi(floor(j * (T)0.5) + XParam.blkwidth / 2);\n            int il = memloc(XParam, XParam.blkwidth - 1, jj , XBlock.LeftBot[ib]);\n            int write = memloc(XParam, -1, j, ib);\n            T faclr = T(1.0);\n            T facbt = floor(j * (T)0.5) * T(2.0) &lt; (j-T(0.01)) ? 1.0 : -1.0;\n\n            T newz = z[il] + (faclr*dzdx[il]+facbt*dzdy[il]) * ilevdx;\n\n            z[write] = newz;\n\n\n        }\n    }\n}\ntemplate void refine_linear_Left&lt;float&gt;(Param XParam, int ib, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate void refine_linear_Left&lt;double&gt;(Param XParam, int ib, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\ntemplate &lt;class T&gt; __global__ void refine_linear_LeftGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z, T* dzdx,T*dzdy)\n{\n    int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = 0;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n\n\n\n    if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib])\n    {\n        int j = iy;\n\n        double ilevdx = calcres(XParam.delta, XBlock.level[ib]) * T(0.5);\n\n\n        int jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib ? floor(j * (T)0.5) : floor(j * (T)0.5) + XParam.blkwidth / 2;\n        int il = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, jj, XBlock.LeftBot[ib]);\n        int write = memloc(XParam.halowidth, blkmemwidth, -1, j, ib);\n        T faclr = T(1.0);\n        T facbt = floor(j * (T)0.5) * T(2.0) &lt; (j - T(0.01)) ? 1.0 : -1.0;\n\n        T newz = z[il] + (faclr * dzdx[il] + facbt * dzdy[il]) * ilevdx;\n\n        z[write] = newz;\n\n\n\n    }\n}\ntemplate __global__ void refine_linear_LeftGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate __global__ void refine_linear_LeftGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\n\ntemplate &lt;class T&gt; void refine_linear_Right(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n{\n    if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib])\n    {\n\n        T ilevdx = calcres(T(XParam.delta), XBlock.level[ib] ) * T(0.5);\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            int jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? ftoi(floor(j * (T)0.5)) : ftoi(floor(j * (T)0.5) + XParam.blkwidth / 2);\n            int il = memloc(XParam, 0, jj , XBlock.RightBot[ib]);\n            int write = memloc(XParam, XParam.blkwidth, j, ib);\n            T faclr = T(-1.0);\n            T facbt = floor(j * (T)0.5) * T(2.0) &lt; (j - T(0.01)) ? 1.0 : -1.0;\n\n            T newz = z[il] + (faclr * dzdx[il] + facbt * dzdy[il]) * ilevdx;\n\n            z[write] = newz;\n\n\n        }\n    }\n}\ntemplate void refine_linear_Right&lt;float&gt;(Param XParam, int ib, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate void refine_linear_Right&lt;double&gt;(Param XParam, int ib, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\ntemplate &lt;class T&gt; __global__ void refine_linear_RightGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n{\n    unsigned int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n\n\n    if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib])\n    {\n\n        double ilevdx = calcres(XParam.delta, XBlock.level[ib]) * T(0.5);\n\n        int j = iy;\n        int jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? floor(j * (T)0.5) : floor(j * (T)0.5) + XParam.blkwidth / 2;\n        int il = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightBot[ib]);\n        int write = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, j, ib);\n\n        T faclr = T(-1.0);\n        T facbt = floor(j * (T)0.5) * T(2.0) &lt; (j - T(0.01)) ? 1.0 : -1.0;\n\n        T newz = z[il] + (faclr * dzdx[il] + facbt * dzdy[il]) * ilevdx;\n\n        z[write] = newz;\n\n\n\n    }\n}\ntemplate __global__ void refine_linear_RightGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate __global__ void refine_linear_RightGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\ntemplate &lt;class T&gt; void refine_linear_Bot(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n{\n    if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib])\n    {\n\n        T ilevdx = calcres(T(XParam.delta), XBlock.level[ib]) * T(0.5);\n\n        for (int i = 0; i &lt; XParam.blkwidth; i++)\n        {\n            int ii = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? ftoi(floor(i * (T)0.5)) : ftoi(floor(i * (T)0.5) + XParam.blkwidth / 2);\n            int jl = memloc(XParam,  ii, XParam.blkwidth - 1, XBlock.BotLeft[ib]);\n            int write = memloc(XParam, i, -1, ib);\n\n            T facbt = T(1.0);\n            T faclr = floor(i * (T)0.5) * T(2.0) &lt; (i - T(0.01)) ? 1.0 : -1.0;\n\n            T newz = z[jl] + (faclr * dzdx[jl] + facbt * dzdy[jl]) * ilevdx;\n\n            z[write] = newz;\n\n\n        }\n    }\n}\ntemplate void refine_linear_Bot&lt;float&gt;(Param XParam, int ib, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate void refine_linear_Bot&lt;double&gt;(Param XParam, int ib, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\n\ntemplate &lt;class T&gt; __global__ void refine_linear_BotGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n{\n    int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n\n    int ix = threadIdx.x;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib])\n    {\n\n        double ilevdx = calcres(XParam.delta, XBlock.level[ib]) * T(0.5);\n\n        int i = ix;\n        int ii = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? floor(i * (T)0.5) : floor(i * (T)0.5) + XParam.blkwidth / 2;\n        int jl = memloc(XParam.halowidth, blkmemwidth, ii, XParam.blkwidth - 1, XBlock.BotLeft[ib]);\n        int write = memloc(XParam.halowidth, blkmemwidth, i, -1, ib);\n\n        T facbt = T(1.0);\n        T faclr = floor(i * (T)0.5) * T(2.0) &lt; (i - T(0.01)) ? 1.0 : -1.0;\n\n        T newz = z[jl] + (faclr * dzdx[jl] + facbt * dzdy[jl]) * ilevdx;\n\n        z[write] = newz;\n\n\n\n    }\n}\ntemplate __global__ void refine_linear_BotGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate __global__ void refine_linear_BotGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\ntemplate &lt;class T&gt; void refine_linear_Top(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n{\n    if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib])\n    {\n\n        double ilevdx = calcres(XParam.delta, XBlock.level[ib]) * T(0.5);\n\n        for (int i = 0; i &lt; XParam.blkwidth; i++)\n        {\n            int ii = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? ftoi(floor(i * (T)0.5)) : ftoi(floor(i * (T)0.5) + XParam.blkwidth / 2);\n            int jl = memloc(XParam, ii , 0, XBlock.TopLeft[ib]);\n            int write = memloc(XParam, i, XParam.blkwidth, ib);\n\n            T facbt = T(-1.0);\n            T faclr = floor(i * (T)0.5) * T(2.0) &lt; (i - T(0.01)) ? 1.0 : -1.0;\n\n            T newz = z[jl] + (faclr * dzdx[jl] + facbt * dzdy[jl]) * ilevdx;\n\n            z[write] = newz;\n\n\n        }\n    }\n}\ntemplate void refine_linear_Top&lt;float&gt;(Param XParam, int ib, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate void refine_linear_Top&lt;double&gt;(Param XParam, int ib, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\ntemplate &lt;class T&gt; __global__ void refine_linear_TopGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n{\n    int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n\n    int ix = threadIdx.x;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n    if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib])\n    {\n\n        double ilevdx = calcres(XParam.delta, XBlock.level[ib]) * T(0.5);\n\n    int i = ix;\n        int ii = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? floor(i * (T)0.5) : floor(i * (T)0.5) + XParam.blkwidth / 2;\n        int jl = memloc(XParam.halowidth, blkmemwidth, ii , 0, XBlock.TopLeft[ib]);\n        int write = memloc(XParam.halowidth, blkmemwidth, i, XParam.blkwidth, ib);\n\n        T facbt = T(-1.0);\n        T faclr = floor(i * (T)0.5) * T(2.0) &lt; (i - T(0.01)) ? 1.0 : -1.0;\n\n        T newz = z[jl] + (faclr * dzdx[jl] + facbt * dzdy[jl]) * ilevdx;\n\n        z[write] = newz;\n\n\n\n    }\n}\ntemplate __global__ void refine_linear_TopGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate __global__ void refine_linear_TopGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\ntemplate &lt;class T&gt; void refine_linear(Param XParam, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n{\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        refine_linear_Left(XParam, ib, XBlock, z, dzdx, dzdy);\n        refine_linear_Right(XParam, ib, XBlock, z, dzdx, dzdy);\n        refine_linear_Top(XParam, ib, XBlock, z, dzdx, dzdy);\n        refine_linear_Bot(XParam, ib, XBlock, z, dzdx, dzdy);\n    }\n}\ntemplate void refine_linear&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate void refine_linear&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\ntemplate &lt;class T&gt; void refine_linearGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n{\n    dim3 blockDimHaloLR(1, XParam.blkwidth, 1);\n    dim3 blockDimHaloBT(XParam.blkwidth, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    refine_linear_LeftGPU&lt;&lt;&lt;gridDim, blockDimHaloLR, 0&gt;&gt;&gt;(XParam, XBlock, z, dzdx, dzdy);\n    refine_linear_RightGPU &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, z, dzdx, dzdy);\n    refine_linear_TopGPU &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, z, dzdx, dzdy);\n    refine_linear_BotGPU &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, z, dzdx, dzdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n}\ntemplate void refine_linearGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate void refine_linearGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\n\ntemplate &lt;class T&gt; void HaloFluxCPULR(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T *z)\n{\n    int jj, i,il,itl;\n    if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n            //\n            i = memloc(XParam, 0, j, ib);\n\n\n            jj = j*2;\n            il = memloc(XParam, XParam.blkwidth, jj, XBlock.LeftBot[ib]);\n            itl = memloc(XParam, XParam.blkwidth, jj+1, XBlock.LeftBot[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.LeftTop[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n        {\n            //\n            i = memloc(XParam, 0, j, ib);\n\n\n            jj = (j - XParam.blkwidth / 2) * 2;\n            il = memloc(XParam, XParam.blkwidth, jj, XBlock.LeftTop[ib]);\n            itl = memloc(XParam, XParam.blkwidth, jj + 1, XBlock.LeftTop[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n            //\n            i = memloc(XParam, XParam.blkwidth, j, ib);\n\n\n            jj = j * 2;\n            il = memloc(XParam, 0, jj, XBlock.RightBot[ib]);\n            itl = memloc(XParam, 0, jj + 1, XBlock.RightBot[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.RightTop[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n        {\n\n            jj = (j - XParam.blkwidth / 2) * 2;\n            //\n            i = memloc(XParam, XParam.blkwidth, j, ib);\n\n\n            il = memloc(XParam, 0, jj, XBlock.RightTop[ib]);\n            itl = memloc(XParam, 0, jj + 1, XBlock.RightTop[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n}\n\ntemplate &lt;class T&gt; __global__  void HaloFluxGPULR(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    int jj, i, il, itl;\n    int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = 0;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n\n    int j = iy;\n\n\n    if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n\n        if (j&lt; (XParam.blkwidth / 2))\n        {\n            //\n            i = memloc(XParam.halowidth, blkmemwidth, 0, j, ib);\n\n\n            jj = j * 2;\n            il = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, jj, XBlock.LeftBot[ib]);\n            itl = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, jj + 1, XBlock.LeftBot[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.LeftTop[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n\n        if (j &gt;= (XParam.blkwidth / 2))\n        {\n            //\n            i = memloc(XParam.halowidth, blkmemwidth, 0, j, ib);\n\n\n            jj = (j - XParam.blkwidth / 2) * 2;\n            il = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, jj, XBlock.LeftTop[ib]);\n            itl = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, jj + 1, XBlock.LeftTop[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n\n        if (j &lt; (XParam.blkwidth / 2))\n        {\n            //\n            i = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, j, ib);\n\n\n            jj = j * 2;\n            il = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightBot[ib]);\n            itl = memloc(XParam.halowidth, blkmemwidth, 0, jj + 1, XBlock.RightBot[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.RightTop[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        if (j &gt;= (XParam.blkwidth / 2))\n        {\n\n            jj = (j - XParam.blkwidth / 2) * 2;\n            //\n            i = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, j, ib);\n\n\n            il = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightTop[ib]);\n            itl = memloc(XParam.halowidth, blkmemwidth, 0, jj + 1, XBlock.RightTop[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n}\n\ntemplate &lt;class T&gt; __global__  void HaloFluxGPULRnew(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    int jj, i, il, itl;\n    int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = 0;\n    int iy = threadIdx.y;\n    int ibl = threadIdx.x + blockIdx.x * blockDim.x;\n    if (ibl &lt; XParam.nblk)\n    {\n\n        int ib = XBlock.active[ibl];\n\n\n        int j = iy;\n\n\n        if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n        {\n\n            if (j &lt; (XParam.blkwidth / 2))\n            {\n                //\n                i = memloc(XParam.halowidth, blkmemwidth, 0, j, ib);\n\n\n                jj = j * 2;\n                il = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, jj, XBlock.LeftBot[ib]);\n                itl = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, jj + 1, XBlock.LeftBot[ib]);\n\n                z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n            }\n            //\n        }\n        if (XBlock.level[XBlock.LeftTop[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n        {\n\n            if (j &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                i = memloc(XParam.halowidth, blkmemwidth, 0, j, ib);\n\n\n                jj = (j - XParam.blkwidth / 2) * 2;\n                il = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, jj, XBlock.LeftTop[ib]);\n                itl = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, jj + 1, XBlock.LeftTop[ib]);\n\n                z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n            }\n            //\n        }\n        if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n        {\n\n            if (j &lt; (XParam.blkwidth / 2))\n            {\n                //\n                i = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, j, ib);\n\n\n                jj = j * 2;\n                il = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightBot[ib]);\n                itl = memloc(XParam.halowidth, blkmemwidth, 0, jj + 1, XBlock.RightBot[ib]);\n\n                z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n            }\n            //\n        }\n        if (XBlock.level[XBlock.RightTop[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n        {\n            if (j &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (j - XParam.blkwidth / 2) * 2;\n                //\n                i = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, j, ib);\n\n\n                il = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightTop[ib]);\n                itl = memloc(XParam.halowidth, blkmemwidth, 0, jj + 1, XBlock.RightTop[ib]);\n\n                z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n            }\n            //\n        }\n    }\n}\n\ntemplate &lt;class T&gt; void HaloFluxCPUBT(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z)\n{\n    int jj, i, il, itl;\n    if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n            //\n            i = memloc(XParam, j, 0, ib);\n\n\n            jj = j * 2;\n            il = memloc(XParam, jj, XParam.blkwidth,  XBlock.BotLeft[ib]);\n            itl = memloc(XParam, jj+1, XParam.blkwidth,  XBlock.BotLeft[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.BotRight[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n        {\n            //\n            i = memloc(XParam, j, 0, ib);\n\n\n            jj = (j - XParam.blkwidth / 2) * 2;\n            il = memloc(XParam,  jj, XParam.blkwidth, XBlock.BotRight[ib]);\n            itl = memloc(XParam,  jj + 1, XParam.blkwidth, XBlock.BotRight[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n            //\n            i = memloc(XParam, j, XParam.blkwidth, ib);\n\n\n            jj = j * 2;\n            il = memloc(XParam, jj, 0,  XBlock.TopLeft[ib]);\n            itl = memloc(XParam, jj + 1, 0, XBlock.TopLeft[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.TopRight[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n        {\n\n            jj = (j - XParam.blkwidth / 2) * 2;\n            //\n            i = memloc(XParam, j, XParam.blkwidth, ib);\n\n\n            il = memloc(XParam, jj, 0, XBlock.TopRight[ib]);\n            itl = memloc(XParam, jj + 1, 0, XBlock.TopRight[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void HaloFluxGPUBT(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    int jj, i, il, itl;\n    int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    //unsigned int iy = threadIdx.x;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int j = ix;\n\n    if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        if (j &lt; (XParam.blkwidth / 2))\n        {\n            //\n            i = memloc(XParam.halowidth, blkmemwidth, j, 0, ib);\n\n\n            jj = j * 2;\n            il = memloc(XParam.halowidth, blkmemwidth, jj, XParam.blkwidth, XBlock.BotLeft[ib]);\n            itl = memloc(XParam.halowidth, blkmemwidth, jj + 1, XParam.blkwidth, XBlock.BotLeft[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.BotRight[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        if (j &gt;= (XParam.blkwidth / 2))\n        {\n            //\n            i = memloc(XParam.halowidth, blkmemwidth, j, 0, ib);\n\n\n            jj = (j - XParam.blkwidth / 2) * 2;\n            il = memloc(XParam.halowidth, blkmemwidth, jj, XParam.blkwidth, XBlock.BotRight[ib]);\n            itl = memloc(XParam.halowidth, blkmemwidth, jj + 1, XParam.blkwidth, XBlock.BotRight[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        if (j &lt; (XParam.blkwidth / 2))\n        {\n            //\n            i = memloc(XParam.halowidth, blkmemwidth, j, XParam.blkwidth, ib);\n\n\n            jj = j * 2;\n            il = memloc(XParam.halowidth, blkmemwidth, jj, 0, XBlock.TopLeft[ib]);\n            itl = memloc(XParam.halowidth, blkmemwidth, jj + 1, 0, XBlock.TopLeft[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.TopRight[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        if (j &gt;= (XParam.blkwidth / 2))\n        {\n\n            jj = (j - XParam.blkwidth / 2) * 2;\n            //\n            i = memloc(XParam.halowidth, blkmemwidth, j, XParam.blkwidth, ib);\n\n\n            il = memloc(XParam.halowidth, blkmemwidth, jj, 0, XBlock.TopRight[ib]);\n            itl = memloc(XParam.halowidth, blkmemwidth, jj + 1, 0, XBlock.TopRight[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void HaloFluxGPUBTnew(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    int jj, i, il, itl;\n    int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    //unsigned int iy = threadIdx.x;\n    int ibl = threadIdx.y + blockIdx.x * blockDim.y;\n    if (ibl &lt; XParam.nblk)\n    {\n\n\n\n        int ib = XBlock.active[ibl];\n\n        int j = ix;\n\n        if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n        {\n            if (j &lt; (XParam.blkwidth / 2))\n            {\n                //\n                i = memloc(XParam.halowidth, blkmemwidth, j, 0, ib);\n\n\n                jj = j * 2;\n                il = memloc(XParam.halowidth, blkmemwidth, jj, XParam.blkwidth, XBlock.BotLeft[ib]);\n                itl = memloc(XParam.halowidth, blkmemwidth, jj + 1, XParam.blkwidth, XBlock.BotLeft[ib]);\n\n                z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n            }\n            //\n        }\n        if (XBlock.level[XBlock.BotRight[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n        {\n            if (j &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                i = memloc(XParam.halowidth, blkmemwidth, j, 0, ib);\n\n\n                jj = (j - XParam.blkwidth / 2) * 2;\n                il = memloc(XParam.halowidth, blkmemwidth, jj, XParam.blkwidth, XBlock.BotRight[ib]);\n                itl = memloc(XParam.halowidth, blkmemwidth, jj + 1, XParam.blkwidth, XBlock.BotRight[ib]);\n\n                z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n            }\n            //\n        }\n        if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n        {\n            if (j &lt; (XParam.blkwidth / 2))\n            {\n                //\n                i = memloc(XParam.halowidth, blkmemwidth, j, XParam.blkwidth, ib);\n\n\n                jj = j * 2;\n                il = memloc(XParam.halowidth, blkmemwidth, jj, 0, XBlock.TopLeft[ib]);\n                itl = memloc(XParam.halowidth, blkmemwidth, jj + 1, 0, XBlock.TopLeft[ib]);\n\n                z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n            }\n            //\n        }\n        if (XBlock.level[XBlock.TopRight[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n        {\n            if (j &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (j - XParam.blkwidth / 2) * 2;\n                //\n                i = memloc(XParam.halowidth, blkmemwidth, j, XParam.blkwidth, ib);\n\n\n                il = memloc(XParam.halowidth, blkmemwidth, jj, 0, XBlock.TopRight[ib]);\n                itl = memloc(XParam.halowidth, blkmemwidth, jj + 1, 0, XBlock.TopRight[ib]);\n\n                z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n            }\n            //\n        }\n    }\n}\n\n\n\ntemplate &lt;class T&gt; void fillLeft(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* &amp;z)\n{\n    int jj,bb;\n    int read, write;\n    int ii, ir, it, itr;\n\n\n    if (XBlock.LeftBot[ib] == ib)//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n\n            read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            write = memloc(XParam, -1, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            z[write] = z[read];\n        }\n\n        if (XBlock.LeftTop[ib] == ib) // boundary on the top half too\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, -1, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                write = memloc(XParam, -1, j, ib);\n                jj = (j - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, (XParam.blkwidth - 1), jj, XBlock.LeftTop[ib]);\n                ir = memloc(XParam, (XParam.blkwidth - 2), jj, XBlock.LeftTop[ib]);\n                it = memloc(XParam, (XParam.blkwidth - 1), jj + 1, XBlock.LeftTop[ib]);\n                itr = memloc(XParam, (XParam.blkwidth - 2), jj + 1, XBlock.LeftTop[ib]);\n\n                z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[ XBlock.LeftBot[ib] ]) // LeftTop block does not exist\n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n\n            write = memloc(XParam, -1, j, ib);\n            read = memloc(XParam, (XParam.blkwidth - 1), j, XBlock.LeftBot[ib]);\n            z[write] = z[read];\n        }\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib] ]&gt; XBlock.level[ib])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n\n            write = memloc(XParam, -1, j, ib);\n\n            jj = j * 2;\n            bb = XBlock.LeftBot[ib];\n\n            ii = memloc(XParam, (XParam.blkwidth - 1), jj, bb);\n            ir = memloc(XParam, (XParam.blkwidth - 2), jj, bb);\n            it = memloc(XParam, (XParam.blkwidth - 1), jj + 1, bb);\n            itr = memloc(XParam, (XParam.blkwidth - 2), jj + 1, bb);\n\n            z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.LeftTop[ib] == ib)\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, -1, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n                jj = (j - (XParam.blkwidth / 2)) * 2;\n                bb = XBlock.LeftTop[ib];\n\n                //read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, -1, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                //z[write] = z[read];\n                ii = memloc(XParam, (XParam.blkwidth - 1), jj, bb);\n                ir = memloc(XParam, (XParam.blkwidth - 2), jj, bb);\n                it = memloc(XParam, (XParam.blkwidth - 1), jj + 1, bb);\n                itr = memloc(XParam, (XParam.blkwidth - 2), jj + 1, bb);\n\n                z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            write = memloc(XParam, -1, j, ib);\n\n            T w1, w2, w3;\n\n\n            int jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib? ftoi(ceil(j * (T)0.5)): ftoi(ceil(j * (T)0.5)+ XParam.blkwidth/2);\n            w1 = T(1.0 / 3.0);\n            w2 = ceil(j * (T)0.5) * 2 &gt; j ? T(1.0 / 6.0) : T(0.5);\n            w3 = ceil(j * (T)0.5) * 2 &gt; j ? T(0.5) : T(1.0 / 6.0);\n\n            ii= memloc(XParam, 0, j, ib);\n            ir= memloc(XParam, XParam.blkwidth-1, jj, XBlock.LeftBot[ib]);\n            it = memloc(XParam, XParam.blkwidth-1, jj - 1, XBlock.LeftBot[ib]);\n            //2 scenarios here ib is the rightbot neighbour of the leftbot block or ib is the righttop neighbour\n            if (XBlock.RightBot[XBlock.LeftBot[ib]] == ib)\n            {\n                if (j == 0)\n                {\n                    if (XBlock.BotRight[XBlock.LeftBot[ib]] == XBlock.LeftBot[ib]) // no botom of leftbot block\n                    {\n                        w3 = T(0.5) * (T(1.0) - w1);\n                        w2 = w3;\n                        it = ir;\n\n                    }\n                    else if (XBlock.level[XBlock.BotRight[XBlock.LeftBot[ib]]] &lt; XBlock.level[XBlock.LeftBot[ib]]) // exists but is coarser\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(5.0 / 10.0);\n                        w3 = T(1.0 / 10.0);\n                        it = memloc(XParam, XParam.blkwidth-1, XParam.blkwidth - 1, XBlock.BotRight[XBlock.LeftBot[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.BotRight[XBlock.LeftBot[ib]]] == XBlock.level[XBlock.LeftBot[ib]]) // exists with same level\n                    {\n                        it = memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 1, XBlock.BotRight[XBlock.LeftBot[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.BotRight[XBlock.LeftBot[ib]]] &gt; XBlock.level[XBlock.LeftBot[ib]]) // exists with higher level\n                    {\n                        w1 = T(1.0 / 4.0);\n                        w2 = T(1.0 / 2.0);\n                        w3 = T(1.0 / 4.0);\n                        it = memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 1, XBlock.BotRight[XBlock.LeftBot[ib]]);\n                    }\n\n\n                }\n\n\n            }\n            else//righttopleftif == ib\n            {\n                if (j == (XParam.blkwidth - 1))\n                {\n                    if (XBlock.TopRight[XBlock.LeftTop[ib]] == XBlock.LeftTop[ib]) // no botom of leftbot block\n                    {\n                        w3 = T(0.5*(1.0-w1));\n                        w2 = w3;\n                        ir = it;\n\n                    }\n                    else if (XBlock.level[XBlock.TopRight[XBlock.LeftTop[ib]]] &lt; XBlock.level[XBlock.LeftTop[ib]]) // exists but is coarser\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(1.0 / 10.0);\n                        w3 = T(5.0 / 10.0);\n                        ir = memloc(XParam, XParam.blkwidth - 1,0, XBlock.TopRight[XBlock.LeftTop[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.TopRight[XBlock.LeftTop[ib]]] == XBlock.level[XBlock.LeftTop[ib]]) // exists with same level\n                    {\n                        ir = memloc(XParam, XParam.blkwidth - 1, 0, XBlock.TopRight[XBlock.LeftTop[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.TopRight[XBlock.LeftTop[ib]]] &gt; XBlock.level[XBlock.LeftTop[ib]]) // exists with higher level\n                    {\n                        w1 = T(1.0 / 4.0);\n                        w2 = T(1.0 / 2.0);\n                        w3 = T(1.0 / 4.0);\n                        ir = memloc(XParam, XParam.blkwidth - 1, 0, XBlock.TopRight[XBlock.LeftTop[ib]]);\n                    }\n                }\n                //\n            }\n\n\n            z[write] = w1 * z[ii] + w2 * z[ir] + w3 * z[it];\n\n\n\n        }\n    }\n\n\n\n}\n\n\n\ntemplate &lt;class T&gt; __global__ void fillLeft(int halowidth, int* active, int * level, int* leftbot, int * lefttop, int * rightbot, int* botright,int * topright, T * a)\n{\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = 0;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = active[ibl];\n\n    int lev = level[ib];\n    int LB = leftbot[ib];\n    int LT = lefttop[ib];\n\n    int RBLB = rightbot[LB];\n    int BRLB = botright[LB];\n    int TRLT = topright[LT];\n\n    int levBRLB = level[BRLB];\n    int levTRLT = level[TRLT];\n    int levLB = level[LB];\n    int levLT = level[LT];\n    int write = memloc(halowidth, blkmemwidth, -1, iy, ib);\n    int read;\n    int jj, ii, ir, it, itr;\n    T a_read;\n    T w1, w2, w3;\n\n    if (LB == ib)\n    {\n        if (iy &lt; (blockDim.y / 2))\n        {\n            read = memloc(halowidth, blkmemwidth, 0, iy, ib);\n            a_read = a[read];\n        }\n        else\n        {\n            if (LT == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, 0, iy, ib);\n                a_read = a[read];\n\n            }\n            else\n            {\n\n                jj = (iy - (blockDim.y / 2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj, LT);\n                ir = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj, LT);\n                it = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj + 1, LT);\n                itr = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj + 1, LT);\n\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (levLB == lev )\n    {\n        read = memloc(halowidth, blkmemwidth, (blockDim.y - 1), iy, LB);\n        a_read = a[read];\n    }\n    else if (levLB &gt; lev)\n    {\n        if (iy &lt; (blockDim.y / 2))\n        {\n            jj = iy * 2;\n            ii = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj, LB);\n            ir = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj, LB);\n            it = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj + 1, LB);\n            itr = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj + 1, LB);\n            a_read= T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        else\n        {\n            if (LT == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, 0, iy, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (iy - (blockDim.y / 2)) * 2;\n\n                ii = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj, LT);\n                ir = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj, LT);\n                it = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj + 1, LT);\n                itr = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj + 1, LT);\n\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n    }\n    else if (levLB &lt; lev)\n    {\n        jj = RBLB==ib? ceil(iy * (T)0.5): ceil(iy * (T)0.5) + blockDim.y / 2;\n        w1 = (T)1.0 / (T)3.0;\n        w2 = ceil(iy * (T)0.5) * 2 &gt; iy ? T(1.0 / 6.0) : T(0.5);\n        w3 = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.5) : T(1.0 / 6.0);\n\n        ii = memloc(halowidth, blkmemwidth, 0, iy, ib);\n        ir = memloc(halowidth, blkmemwidth, blockDim.y - 1, jj, LB);\n        it = memloc(halowidth, blkmemwidth, blockDim.y - 1, jj - 1, LB);\n        if (RBLB == ib)\n        {\n            if (iy == 0)\n            {\n                if (BRLB == LB)\n                {\n                    w3 = (T)0.5 * (1.0 - w1);\n                    w2 = w3;\n                    it = ir;\n                }\n                else if (levBRLB &lt; levLB)\n                {\n                    w1 = T(4.0 / 10.0);\n                    w2 = T(5.0 / 10.0);\n                    w3 = T(1.0 / 10.0);\n                    it = memloc(halowidth, blkmemwidth, blockDim.y - 1, blockDim.y - 1, BRLB);\n\n                }\n                else if (levBRLB == levLB)\n                {\n                    it = memloc(halowidth, blkmemwidth, blockDim.y - 1, blockDim.y - 1, BRLB);\n                }\n                else if (levBRLB &gt; levLB)\n                {\n                    w1 = T(1.0 / 4.0);\n                    w2 = T(1.0 / 2.0);\n                    w3 = T(1.0 / 4.0);\n                    it = memloc(halowidth, blkmemwidth, blockDim.y - 1, blockDim.y - 1, BRLB);\n                }\n            }\n        }\n        else\n        {\n            if (iy == (blockDim.y - 1))\n            {\n                if (TRLT == LT)\n                {\n                    w3 = 0.5 * (1.0 - w1);\n                    w2 = w3;\n                    ir = it;\n                }\n                else if (levTRLT &lt; levLT)\n                {\n                    w1 = 4.0 / 10.0;\n                    w2 = 1.0 / 10.0;\n                    w3 = 5.0 / 10.0;\n                    ir = memloc(halowidth, blkmemwidth, blockDim.y - 1, 0, TRLT);\n                }\n                else if (levTRLT == levLT)\n                {\n                    ir = memloc(halowidth, blkmemwidth, blockDim.y - 1, 0, TRLT);\n                }\n                else if (levTRLT &gt; levLT)\n                {\n                    w1 = 1.0 / 4.0;\n                    w2 = 1.0 / 2.0;\n                    w3 = 1.0 / 4.0;\n                    ir = memloc(halowidth, blkmemwidth, blockDim.y - 1, 0, TRLT);\n\n                }\n            }\n        }\n        a_read = w1 * a[ii] + w2 * a[ir] + w3 * a[it];\n    }\n\n    a[write] = a_read;\n}\ntemplate __global__ void fillLeft&lt;float&gt;(int halowidth, int* active, int* level, int* leftbot, int* lefttop, int* rightbot, int* botright, int* topright, float* a);\ntemplate __global__ void fillLeft&lt;double&gt;(int halowidth, int* active, int* level, int* leftbot, int* lefttop, int* rightbot, int* botright, int* topright, double* a);\n\ntemplate &lt;class T&gt; __global__ void fillLeftnew(int halowidth, int nblk, int* active, int* level, int* leftbot, int* lefttop, int* rightbot, int* botright, int* topright, T* a)\n{\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = 0;\n    int iy = threadIdx.y;\n    //need to take min of ibl or total number of blks in case nblk is not dividable by 2\n    int ibl = threadIdx.x + blockIdx.x * blockDim.x;;\n    if (ibl &lt; nblk)\n    {\n\n\n        int ib = active[ibl];\n\n        int lev = level[ib];\n        int LB = leftbot[ib];\n        int LT = lefttop[ib];\n\n        int RBLB = rightbot[LB];\n        int BRLB = botright[LB];\n        int TRLT = topright[LT];\n\n        int levBRLB = level[BRLB];\n        int levTRLT = level[TRLT];\n        int levLB = level[LB];\n        int levLT = level[LT];\n        int write = memloc(halowidth, blkmemwidth, -1, iy, ib);\n        int read;\n        int jj, ii, ir, it, itr;\n        T a_read;\n        T w1, w2, w3;\n\n        if (LB == ib)\n        {\n            if (iy &lt; (blockDim.y / 2))\n            {\n                read = memloc(halowidth, blkmemwidth, 0, iy, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                if (LT == ib)\n                {\n                    read = memloc(halowidth, blkmemwidth, 0, iy, ib);\n                    a_read = a[read];\n\n                }\n                else\n                {\n\n                    jj = (iy - (blockDim.y / 2)) * 2;\n                    ii = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj, LT);\n                    ir = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj, LT);\n                    it = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj + 1, LT);\n                    itr = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj + 1, LT);\n\n                    a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n\n        }\n        else if (levLB == lev)\n        {\n            read = memloc(halowidth, blkmemwidth, (blockDim.y - 1), iy, LB);\n            a_read = a[read];\n        }\n        else if (levLB &gt; lev)\n        {\n            if (iy &lt; (blockDim.y / 2))\n            {\n                jj = iy * 2;\n                ii = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj, LB);\n                ir = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj, LB);\n                it = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj + 1, LB);\n                itr = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj + 1, LB);\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n            else\n            {\n                if (LT == ib)\n                {\n                    read = memloc(halowidth, blkmemwidth, 0, iy, ib);\n                    a_read = a[read];\n                }\n                else\n                {\n                    jj = (iy - (blockDim.y / 2)) * 2;\n\n                    ii = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj, LT);\n                    ir = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj, LT);\n                    it = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj + 1, LT);\n                    itr = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj + 1, LT);\n\n                    a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n        }\n        else if (levLB &lt; lev)\n        {\n            jj = RBLB == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + blockDim.y / 2;\n            w1 = (T)1.0 / (T)3.0;\n            w2 = ceil(iy * (T)0.5) * 2 &gt; iy ? T(1.0 / 6.0) : T(0.5);\n            w3 = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.5) : T(1.0 / 6.0);\n\n            ii = memloc(halowidth, blkmemwidth, 0, iy, ib);\n            ir = memloc(halowidth, blkmemwidth, blockDim.y - 1, jj, LB);\n            it = memloc(halowidth, blkmemwidth, blockDim.y - 1, jj - 1, LB);\n            if (RBLB == ib)\n            {\n                if (iy == 0)\n                {\n                    if (BRLB == LB)\n                    {\n                        w3 = (T)0.5 * (1.0 - w1);\n                        w2 = w3;\n                        it = ir;\n                    }\n                    else if (levBRLB &lt; levLB)\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(5.0 / 10.0);\n                        w3 = T(1.0 / 10.0);\n                        it = memloc(halowidth, blkmemwidth, blockDim.y - 1, blockDim.y - 1, BRLB);\n\n                    }\n                    else if (levBRLB == levLB)\n                    {\n                        it = memloc(halowidth, blkmemwidth, blockDim.y - 1, blockDim.y - 1, BRLB);\n                    }\n                    else if (levBRLB &gt; levLB)\n                    {\n                        w1 = T(1.0 / 4.0);\n                        w2 = T(1.0 / 2.0);\n                        w3 = T(1.0 / 4.0);\n                        it = memloc(halowidth, blkmemwidth, blockDim.y - 1, blockDim.y - 1, BRLB);\n                    }\n                }\n            }\n            else\n            {\n                if (iy == (blockDim.y - 1))\n                {\n                    if (TRLT == LT)\n                    {\n                        w3 = 0.5 * (1.0 - w1);\n                        w2 = w3;\n                        ir = it;\n                    }\n                    else if (levTRLT &lt; levLT)\n                    {\n                        w1 = 4.0 / 10.0;\n                        w2 = 1.0 / 10.0;\n                        w3 = 5.0 / 10.0;\n                        ir = memloc(halowidth, blkmemwidth, blockDim.y - 1, 0, TRLT);\n                    }\n                    else if (levTRLT == levLT)\n                    {\n                        ir = memloc(halowidth, blkmemwidth, blockDim.y - 1, 0, TRLT);\n                    }\n                    else if (levTRLT &gt; levLT)\n                    {\n                        w1 = 1.0 / 4.0;\n                        w2 = 1.0 / 2.0;\n                        w3 = 1.0 / 4.0;\n                        ir = memloc(halowidth, blkmemwidth, blockDim.y - 1, 0, TRLT);\n\n                    }\n                }\n            }\n            a_read = w1 * a[ii] + w2 * a[ir] + w3 * a[it];\n        }\n\n        a[write] = a_read;\n    }\n}\ntemplate __global__ void fillLeftnew&lt;float&gt;(int halowidth, int nblk, int* active, int* level, int* leftbot, int* lefttop, int* rightbot, int* botright, int* topright, float* a);\ntemplate __global__ void fillLeftnew&lt;double&gt;(int halowidth, int nblk, int* active, int* level, int* leftbot, int* lefttop, int* rightbot, int* botright, int* topright, double* a);\n\n\ntemplate &lt;class T&gt; void fillLeftFlux(Param XParam, bool doProlongation, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    int jj, bb;\n    int read, write;\n    int ii,  it;\n\n\n    if (XBlock.LeftBot[ib] == ib)//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n\n            read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            write = memloc(XParam, -1, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            z[write] = z[read];\n        }\n\n        if (XBlock.LeftTop[ib] == ib) // boundary on the top half too\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, -1, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                write = memloc(XParam, -1, j, ib);\n                jj = (j - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, (XParam.blkwidth - 1), jj, XBlock.LeftTop[ib]);\n                //ir = memloc(XParam, (XParam.blkwidth - 2), jj, XBlock.LeftTop[ib]);\n                it = memloc(XParam, (XParam.blkwidth - 1), jj + 1, XBlock.LeftTop[ib]);\n                //itr = memloc(XParam, (XParam.blkwidth - 2), jj + 1, XBlock.LeftTop[ib]);\n\n                z[write] = T(0.5) * (z[ii]  + z[it]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.LeftBot[ib]]) // LeftTop block does not exist\n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n\n            write = memloc(XParam, -1, j, ib);\n            read = memloc(XParam, (XParam.blkwidth - 1), j, XBlock.LeftBot[ib]);\n            z[write] = z[read];\n        }\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n\n            write = memloc(XParam, -1, j, ib);\n\n            jj = j * 2;\n            bb = XBlock.LeftBot[ib];\n\n            ii = memloc(XParam, (XParam.blkwidth - 1), jj, bb);\n            //ir = memloc(XParam, (XParam.blkwidth - 2), jj, bb);\n            it = memloc(XParam, (XParam.blkwidth - 1), jj + 1, bb);\n            //itr = memloc(XParam, (XParam.blkwidth - 2), jj + 1, bb);\n\n            z[write] = T(0.5) * (z[ii] + z[it]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.LeftTop[ib] == ib)\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, -1, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n                jj = (j - 8) * 2;\n                bb = XBlock.LeftTop[ib];\n\n                //read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, -1, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                //z[write] = z[read];\n                ii = memloc(XParam, (XParam.blkwidth - 1), jj, bb);\n                //ir = memloc(XParam, (XParam.blkwidth - 2), jj, bb);\n                it = memloc(XParam, (XParam.blkwidth - 1), jj + 1, bb);\n                //itr = memloc(XParam, (XParam.blkwidth - 2), jj + 1, bb);\n\n                z[write] = T(0.5) * (z[ii] + z[it]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            write = memloc(XParam, -1, j, ib);\n\n            //T w1, w2, w3;\n\n\n            int jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib ? ftoi(ceil(j * (T)0.5)) : ftoi(ceil(j * (T)0.5) + XParam.blkwidth / 2);\n\n\n            ii = memloc(XParam, XParam.blkwidth - 1, jj, XBlock.LeftBot[ib]);\n            if (doProlongation)\n                z[write] = z[ii];\n\n\n\n        }\n    }\n\n\n\n}\n\n\n\ntemplate &lt;class T&gt; void fillRight(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    int jj, bb;\n    int read, write;\n    int ii, ir, it, itr;\n\n\n    if (XBlock.RightBot[ib] == ib)//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n\n            read = memloc(XParam, XParam.blkwidth-1, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            write = memloc(XParam, XParam.blkwidth, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            z[write] = z[read];\n        }\n\n        if (XBlock.RightTop[ib] == ib) // boundary on the top half too\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, XParam.blkwidth - 1, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, XParam.blkwidth, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n\n\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                write = memloc(XParam, XParam.blkwidth, j, ib);\n                jj = (j - (XParam.blkwidth / 2)) * 2;\n                ii = memloc(XParam, 0, jj, XBlock.RightTop[ib]);\n                ir = memloc(XParam, 1, jj, XBlock.RightTop[ib]);\n                it = memloc(XParam, 0, jj + 1, XBlock.RightTop[ib]);\n                itr = memloc(XParam, 1, jj + 1, XBlock.RightTop[ib]);\n\n                z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.RightBot[ib]]) // LeftTop block does not exist\n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n\n            write = memloc(XParam, XParam.blkwidth, j, ib);\n            read = memloc(XParam, 0, j, XBlock.RightBot[ib]);\n            z[write] = z[read];\n        }\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n\n            write = memloc(XParam, XParam.blkwidth, j, ib);\n\n            jj = j * 2;\n            bb = XBlock.RightBot[ib];\n\n            ii = memloc(XParam, 0, jj, bb);\n            ir = memloc(XParam, 1, jj, bb);\n            it = memloc(XParam, 0, jj + 1, bb);\n            itr = memloc(XParam, 1, jj + 1, bb);\n\n            z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.RightTop[ib] == ib)\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, XParam.blkwidth-1, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, XParam.blkwidth, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n                jj = (j - (XParam.blkwidth / 2)) * 2;\n                bb = XBlock.RightTop[ib];\n\n                //read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, XParam.blkwidth, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                //z[write] = z[read];\n                ii = memloc(XParam, 0, jj, bb);\n                ir = memloc(XParam, 1, jj, bb);\n                it = memloc(XParam, 0, jj + 1, bb);\n                itr = memloc(XParam, 1, jj + 1, bb);\n\n                z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            write = memloc(XParam, XParam.blkwidth, j, ib);\n\n            T w1, w2, w3;\n\n\n            int jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? ftoi(ceil(j * (T)0.5)) : ftoi(ceil(j * (T)0.5) + XParam.blkwidth / 2);\n            w1 = T(1.0 / 3.0);\n            w2 = ceil(j * (T)0.5) * 2 &gt; j ? T(1.0 / 6.0) : T(0.5);\n            w3 = ceil(j * (T)0.5) * 2 &gt; j ? T(0.5) : T(1.0 / 6.0);\n\n            ii = memloc(XParam, XParam.blkwidth-1, j, ib);\n            ir = memloc(XParam, 0, jj, XBlock.RightBot[ib]);\n            it = memloc(XParam, 0, jj - 1, XBlock.RightBot[ib]);\n            //2 scenarios here ib is the leftbot neighbour of the rightbot block or ib is the lefttop neighbour\n            if (XBlock.LeftBot[XBlock.RightBot[ib]] == ib)\n            {\n                if (j == 0)\n                {\n                    if (XBlock.BotLeft[XBlock.RightBot[ib]] == XBlock.RightBot[ib]) // no botom of leftbot block\n                    {\n                        w3 = T(0.5 * (1.0 - w1));\n                        w2 = w3;\n                        it = ir;\n\n                    }\n                    else if (XBlock.level[XBlock.BotLeft[XBlock.RightBot[ib]]] &lt; XBlock.level[XBlock.RightBot[ib]]) // exists but is coarser\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(5.0 / 10.0);\n                        w3 = T(1.0 / 10.0);\n                        it = memloc(XParam, 0, XParam.blkwidth - 1, XBlock.BotLeft[XBlock.RightBot[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.BotLeft[XBlock.RightBot[ib]]] == XBlock.level[XBlock.RightBot[ib]]) // exists with same level\n                    {\n                        it = memloc(XParam, 0, XParam.blkwidth - 1, XBlock.BotLeft[XBlock.RightBot[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.BotLeft[XBlock.RightBot[ib]]] &gt; XBlock.level[XBlock.RightBot[ib]]) // exists with higher level\n                    {\n                        w1 = T(1.0 / 4.0);\n                        w2 = T(1.0 / 2.0);\n                        w3 = T(1.0 / 4.0);\n                        it = memloc(XParam, 0, XParam.blkwidth - 1, XBlock.BotLeft[XBlock.RightBot[ib]]);\n                    }\n\n\n                }\n\n\n            }\n            else//\n            {\n                if (j == (XParam.blkwidth - 1))\n                {\n                    if (XBlock.TopLeft[XBlock.RightTop[ib]] == XBlock.RightTop[ib]) // no botom of leftbot block\n                    {\n                        w3 = T(0.5 * (1.0 - w1));\n                        w2 = w3;\n                        ir = it;\n\n                    }\n                    else if (XBlock.level[XBlock.TopLeft[XBlock.RightTop[ib]]] &lt; XBlock.level[XBlock.RightTop[ib]]) // exists but is coarser\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(1.0 / 10.0);\n                        w3 = T(5.0 / 10.0);\n                        ir = memloc(XParam, 0, 0, XBlock.TopLeft[XBlock.RightTop[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.TopLeft[XBlock.RightTop[ib]]] == XBlock.level[XBlock.RightTop[ib]]) // exists with same level\n                    {\n                        ir = memloc(XParam, 0, 0, XBlock.TopLeft[XBlock.RightTop[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.TopLeft[XBlock.RightTop[ib]]] &gt; XBlock.level[XBlock.RightTop[ib]]) // exists with higher level\n                    {\n                        w1 = 1.0 / 4.0;\n                        w2 = 1.0 / 2.0;\n                        w3 = 1.0 / 4.0;\n                        ir = memloc(XParam, 0, 0, XBlock.TopLeft[XBlock.RightTop[ib]]);\n                    }\n                }\n                //\n            }\n\n\n            z[write] = w1 * z[ii] + w2 * z[ir] + w3 * z[it];\n        }\n    }\n\n\n\n}\n\n\n\ntemplate &lt;class T&gt; __global__ void fillRight(int halowidth, int* active, int* level, int * rightbot,int* righttop,int * leftbot,int*botleft,int* topleft, T* a)\n{\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = blockDim.y - 1;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = active[ibl];\n\n    int RB = rightbot[ib];\n    int RT = righttop[ib];\n    //int LB = leftbot[ib];\n    //int BL = botleft[ib];\n    int LBRB = leftbot[RB];\n    int TLRT = topleft[RT];\n    int BLRB = botleft[RB];\n\n\n    int lev = level[ib];\n    int levRB = level[RB];\n    int levRT = level[RT];\n    int levBLRB = level[BLRB];\n    int levTLRT = level[TLRT];\n\n    int write = memloc(halowidth, blkmemwidth, blockDim.y, iy, ib);\n    int read;\n    int jj, ii, ir, it, itr;\n    T a_read;\n    T w1, w2, w3;\n\n\n    if (RB == ib)\n    {\n        if (iy &lt; (blockDim.y / 2))\n        {\n            read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n            a_read = a[read];\n        }\n        else\n        {\n            if (RT == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (iy - (blockDim.y / 2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, 0, jj, RT);\n                ir = memloc(halowidth, blkmemwidth, 1, jj, RT);\n                it = memloc(halowidth, blkmemwidth, 0, jj + 1, RT);\n                itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RT);\n\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n    }\n    else if (levRB == lev)\n    {\n        read = memloc(halowidth, blkmemwidth, 0, iy, RB);\n        a_read = a[read];\n    }\n    else if (levRB &gt; lev)\n    {\n        if (iy &lt; (blockDim.y / 2))\n        {\n            jj = iy * 2;\n\n\n            ii = memloc(halowidth, blkmemwidth, 0, jj, RB);\n            ir = memloc(halowidth, blkmemwidth, 1, jj, RB);\n            it = memloc(halowidth, blkmemwidth, 0, jj + 1, RB);\n            itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RB);\n\n            a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        else\n        {\n            if (RT == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (iy - (blockDim.y / 2)) * 2;\n\n                ii = memloc(halowidth, blkmemwidth, 0, jj, RT);\n                ir = memloc(halowidth, blkmemwidth, 1, jj, RT);\n                it = memloc(halowidth, blkmemwidth, 0, jj + 1, RT);\n                itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RT);\n\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n    }\n    else if (levRB &lt; lev)\n    {\n        //\n        jj = LBRB == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + blockDim.y / 2;\n        w1 = 1.0 / 3.0;\n        w2 = ceil(iy * (T)0.5) * 2 &gt; iy ? T(1.0 / 6.0) : T(0.5);\n        w3 = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.5) : T(1.0 / 6.0);\n        ii = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n        ir = memloc(halowidth, blkmemwidth, 0, jj, RB);\n        it = memloc(halowidth, blkmemwidth, 0, jj - 1, RB);\n        if (LBRB == ib)\n        {\n            if (iy == 0)\n            {\n                if (BLRB == RB)\n                {\n                    w3 = 0.5 * (1.0 - w1);\n                    w2 = w3;\n                    it = ir;\n                }\n                else if (levBLRB &lt; levRB)\n                {\n                    w1 = 4.0 / 10.0;\n                    w2 = 5.0 / 10.0;\n                    w3 = 1.0 / 10.0;\n                    it = memloc(halowidth, blkmemwidth, 0, blockDim.y - 1, BLRB);\n                }\n                else if (levBLRB == levRB)\n                {\n                    it = memloc(halowidth, blkmemwidth, 0, blockDim.y - 1, BLRB);\n                }\n                else if (levBLRB &gt; levRB)\n                {\n                    w1 = 1.0 / 4.0;\n                    w2 = 1.0 / 2.0;\n                    w3 = 1.0 / 4.0;\n                    it = memloc(halowidth, blkmemwidth, 0, blockDim.y - 1, BLRB);\n                }\n            }\n        }\n        else\n        {\n            if (iy == (blockDim.y - 1))\n            {\n                if (TLRT == RT)\n                {\n                    w3 = 0.5 * (1.0 - w1);\n                    w2 = w3;\n                    ir = it;\n                }\n                else if (levTLRT &lt; levRT)\n                {\n                    w1 = 4.0 / 10.0;\n                    w2 = 1.0 / 10.0;\n                    w3 = 5.0 / 10.0;\n                    ir = memloc(halowidth, blkmemwidth, 0, 0, TLRT);\n                }\n                else if (levTLRT == levRT)\n                {\n                    ir = memloc(halowidth, blkmemwidth, 0, 0, TLRT);\n                }\n                else if (levTLRT &gt; levRT)\n                {\n                    w1 = 1.0 / 4.0;\n                    w2 = 1.0 / 2.0;\n                    w3 = 1.0 / 4.0;\n                    ir = memloc(halowidth, blkmemwidth, 0, 0, TLRT);\n                }\n            }\n        }\n\n        a_read= w1 * a[ii] + w2 * a[ir] + w3 * a[it];\n    }\n    a[write] = a_read;\n}\n\ntemplate __global__ void fillRight&lt;float&gt;(int halowidth, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, float* a);\ntemplate __global__ void fillRight&lt;double&gt;(int halowidth, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, double* a);\n\ntemplate &lt;class T&gt; __global__ void fillRightnew(int halowidth,int nblk, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, T* a)\n{\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = blockDim.y - 1;\n    int iy = threadIdx.y;\n    int ibl = threadIdx.x + blockIdx.x * blockDim.x;\n    if (ibl &lt; nblk)\n    {\n        int ib = active[ibl];\n\n        int RB = rightbot[ib];\n        int RT = righttop[ib];\n        //int LB = leftbot[ib];\n        //int BL = botleft[ib];\n        int LBRB = leftbot[RB];\n        int TLRT = topleft[RT];\n        int BLRB = botleft[RB];\n\n\n        int lev = level[ib];\n        int levRB = level[RB];\n        int levRT = level[RT];\n        int levBLRB = level[BLRB];\n        int levTLRT = level[TLRT];\n\n        int write = memloc(halowidth, blkmemwidth, blockDim.y, iy, ib);\n        int read;\n        int jj, ii, ir, it, itr;\n        T a_read;\n        T w1, w2, w3;\n\n\n        if (RB == ib)\n        {\n            if (iy &lt; (blockDim.y / 2))\n            {\n                read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                if (RT == ib)\n                {\n                    read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n                    a_read = a[read];\n                }\n                else\n                {\n                    jj = (iy - (blockDim.y / 2)) * 2;\n                    ii = memloc(halowidth, blkmemwidth, 0, jj, RT);\n                    ir = memloc(halowidth, blkmemwidth, 1, jj, RT);\n                    it = memloc(halowidth, blkmemwidth, 0, jj + 1, RT);\n                    itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RT);\n\n                    a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n        }\n        else if (levRB == lev)\n        {\n            read = memloc(halowidth, blkmemwidth, 0, iy, RB);\n            a_read = a[read];\n        }\n        else if (levRB &gt; lev)\n        {\n            if (iy &lt; (blockDim.y / 2))\n            {\n                jj = iy * 2;\n\n\n                ii = memloc(halowidth, blkmemwidth, 0, jj, RB);\n                ir = memloc(halowidth, blkmemwidth, 1, jj, RB);\n                it = memloc(halowidth, blkmemwidth, 0, jj + 1, RB);\n                itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RB);\n\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n            else\n            {\n                if (RT == ib)\n                {\n                    read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n                    a_read = a[read];\n                }\n                else\n                {\n                    jj = (iy - (blockDim.y / 2)) * 2;\n\n                    ii = memloc(halowidth, blkmemwidth, 0, jj, RT);\n                    ir = memloc(halowidth, blkmemwidth, 1, jj, RT);\n                    it = memloc(halowidth, blkmemwidth, 0, jj + 1, RT);\n                    itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RT);\n\n                    a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n        }\n        else if (levRB &lt; lev)\n        {\n            //\n            jj = LBRB == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + blockDim.y / 2;\n            w1 = 1.0 / 3.0;\n            w2 = ceil(iy * (T)0.5) * 2 &gt; iy ? T(1.0 / 6.0) : T(0.5);\n            w3 = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.5) : T(1.0 / 6.0);\n            ii = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n            ir = memloc(halowidth, blkmemwidth, 0, jj, RB);\n            it = memloc(halowidth, blkmemwidth, 0, jj - 1, RB);\n            if (LBRB == ib)\n            {\n                if (iy == 0)\n                {\n                    if (BLRB == RB)\n                    {\n                        w3 = 0.5 * (1.0 - w1);\n                        w2 = w3;\n                        it = ir;\n                    }\n                    else if (levBLRB &lt; levRB)\n                    {\n                        w1 = 4.0 / 10.0;\n                        w2 = 5.0 / 10.0;\n                        w3 = 1.0 / 10.0;\n                        it = memloc(halowidth, blkmemwidth, 0, blockDim.y - 1, BLRB);\n                    }\n                    else if (levBLRB == levRB)\n                    {\n                        it = memloc(halowidth, blkmemwidth, 0, blockDim.y - 1, BLRB);\n                    }\n                    else if (levBLRB &gt; levRB)\n                    {\n                        w1 = 1.0 / 4.0;\n                        w2 = 1.0 / 2.0;\n                        w3 = 1.0 / 4.0;\n                        it = memloc(halowidth, blkmemwidth, 0, blockDim.y - 1, BLRB);\n                    }\n                }\n            }\n            else\n            {\n                if (iy == (blockDim.y - 1))\n                {\n                    if (TLRT == RT)\n                    {\n                        w3 = 0.5 * (1.0 - w1);\n                        w2 = w3;\n                        ir = it;\n                    }\n                    else if (levTLRT &lt; levRT)\n                    {\n                        w1 = 4.0 / 10.0;\n                        w2 = 1.0 / 10.0;\n                        w3 = 5.0 / 10.0;\n                        ir = memloc(halowidth, blkmemwidth, 0, 0, TLRT);\n                    }\n                    else if (levTLRT == levRT)\n                    {\n                        ir = memloc(halowidth, blkmemwidth, 0, 0, TLRT);\n                    }\n                    else if (levTLRT &gt; levRT)\n                    {\n                        w1 = 1.0 / 4.0;\n                        w2 = 1.0 / 2.0;\n                        w3 = 1.0 / 4.0;\n                        ir = memloc(halowidth, blkmemwidth, 0, 0, TLRT);\n                    }\n                }\n            }\n\n            a_read = w1 * a[ii] + w2 * a[ir] + w3 * a[it];\n        }\n        a[write] = a_read;\n    }\n}\n\ntemplate __global__ void fillRightnew&lt;float&gt;(int halowidth, int nblk, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, float* a);\ntemplate __global__ void fillRightnew&lt;double&gt;(int halowidth, int nblk, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, double* a);\n\n\n\ntemplate &lt;class T&gt; void fillRightFlux(Param XParam, bool doProlongation, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    int jj, bb;\n    int read, write;\n    int ii, it;\n\n\n    if (XBlock.RightBot[ib] == ib)//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n\n            read = memloc(XParam, XParam.blkwidth - 1, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            write = memloc(XParam, XParam.blkwidth, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            z[write] = z[read];\n        }\n\n        if (XBlock.RightTop[ib] == ib) // boundary on the top half too\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, XParam.blkwidth - 1, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, XParam.blkwidth, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                write = memloc(XParam, XParam.blkwidth, j, ib);\n                jj = (j - 8) * 2;\n                ii = memloc(XParam, 0, jj, XBlock.RightTop[ib]);\n                //ir = memloc(XParam, 1, jj, XBlock.RightTop[ib]);\n                it = memloc(XParam, 0, jj + 1, XBlock.RightTop[ib]);\n                //itr = memloc(XParam, 1, jj + 1, XBlock.RightTop[ib]);\n\n                z[write] = T(0.5) * (z[ii] + z[it]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.RightBot[ib]]) // LeftTop block does not exist\n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n\n            write = memloc(XParam, XParam.blkwidth, j, ib);\n            read = memloc(XParam, 0, j, XBlock.RightBot[ib]);\n            z[write] = z[read];\n        }\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n\n            write = memloc(XParam, XParam.blkwidth, j, ib);\n\n            jj = j * 2;\n            bb = XBlock.RightBot[ib];\n\n            ii = memloc(XParam, 0, jj, bb);\n            //ir = memloc(XParam, 1, jj, bb);\n            it = memloc(XParam, 0, jj + 1, bb);\n            //itr = memloc(XParam, 1, jj + 1, bb);\n\n            //z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n            z[write] = T(0.5) * (z[ii] + z[it]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.RightTop[ib] == ib)\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, XParam.blkwidth - 1, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, XParam.blkwidth, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n                jj = (j - 8) * 2;\n                bb = XBlock.RightTop[ib];\n\n                //read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, XParam.blkwidth, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                //z[write] = z[read];\n                ii = memloc(XParam, 0, jj, bb);\n                //ir = memloc(XParam, 1, jj, bb);\n                it = memloc(XParam, 0, jj + 1, bb);\n                //itr = memloc(XParam, 1, jj + 1, bb);\n                z[write] = T(0.5) * (z[ii] + z[it]);\n                //z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            write = memloc(XParam, XParam.blkwidth, j, ib);\n\n\n            int jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? ftoi(floor(j * (T)0.5)) : ftoi(floor(j * (T)0.5) + XParam.blkwidth / 2);\n\n            ii = memloc(XParam, 0, jj, XBlock.RightBot[ib]);\n            if (doProlongation)\n                z[write] = z[ii];\n        }\n    }\n\n\n\n}\n\ntemplate void fillRightFlux&lt;float&gt;(Param XParam, bool doProlongation, int ib, BlockP&lt;float&gt; XBlock, float*&amp; z);\ntemplate void fillRightFlux&lt;double&gt;(Param XParam, bool doProlongation, int ib, BlockP&lt;double&gt; XBlock, double*&amp; z);\n\n\n\ntemplate &lt;class T&gt; __global__ void fillRightFlux(int halowidth, bool doProlongation, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, T* a)\n{\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = blockDim.y - 1;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = active[ibl];\n\n    int RB = rightbot[ib];\n    int RT = righttop[ib];\n    //int LB = leftbot[ib];\n    //int BL = botleft[ib];\n    int LBRB = leftbot[RB];\n    //int TLRT = topleft[RT];\n    //int BLRB = botleft[RB];\n\n\n    int lev = level[ib];\n    int levRB = level[RB];\n    //int levRT = level[RT];\n    //int levBLRB = level[BLRB];\n    //int levTLRT = level[TLRT];\n\n    int write = memloc(halowidth, blkmemwidth, blockDim.y, iy, ib);\n    int read;\n    int jj, ii, ir, it;\n    T a_read;\n    //T w1, w2;\n\n\n    if (RB == ib)\n    {\n        if (iy &lt; (blockDim.y / 2))\n        {\n            read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n            a_read = a[read];\n        }\n        else\n        {\n            if (RT == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (iy - (blockDim.y / 2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, 0, jj, RT);\n                //ir = memloc(halowidth, blkmemwidth, 1, jj, RT);\n                it = memloc(halowidth, blkmemwidth, 0, jj + 1, RT);\n                //itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RT);\n\n                a_read = T(0.5) * (a[ii] + a[it]);\n            }\n        }\n    }\n    else if (levRB == lev)\n    {\n        read = memloc(halowidth, blkmemwidth, 0, iy, RB);\n        a_read = a[read];\n    }\n    else if (levRB &gt; lev)\n    {\n        if (iy &lt; (blockDim.y / 2))\n        {\n            jj = iy * 2;\n\n\n            ii = memloc(halowidth, blkmemwidth, 0, jj, RB);\n            //ir = memloc(halowidth, blkmemwidth, 1, jj, RB);\n            it = memloc(halowidth, blkmemwidth, 0, jj + 1, RB);\n            //itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RB);\n\n            a_read = T(0.5) * (a[ii] + a[it]);\n        }\n        else\n        {\n            if (RT == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (iy - (blockDim.y / 2)) * 2;\n\n                ii = memloc(halowidth, blkmemwidth, 0, jj, RT);\n                //ir = memloc(halowidth, blkmemwidth, 1, jj, RT);\n                it = memloc(halowidth, blkmemwidth, 0, jj + 1, RT);\n                //itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RT);\n\n                a_read = T(0.5) * (a[ii] + a[it] );\n            }\n        }\n    }\n    else if (levRB &lt; lev)\n    {\n        //\n        jj = LBRB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n\n\n        ir = memloc(halowidth, blkmemwidth, 0, jj, RB);\n\n        if (doProlongation)\n            a_read = a[ir];\n\n        else\n            a_read = a[write];\n    }\n    a[write] = a_read;\n}\ntemplate __global__ void fillRightFlux&lt;float&gt;(int halowidth, bool doProlongation, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, float* a);\ntemplate __global__ void fillRightFlux&lt;double&gt;(int halowidth, bool doProlongation, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, double* a);\n\n\n\ntemplate &lt;class T&gt; void fillBot(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    int jj, bb;\n    int read, write;\n    int ii, ir, it, itr;\n\n\n    if (XBlock.BotLeft[ib] == ib)//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n\n            read = memloc(XParam, j, 0, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            write = memloc(XParam, j, -1, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            z[write] = z[read];\n        }\n\n        if (XBlock.BotRight[ib] == ib) // boundary on the top half too\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, j, 0, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, -1, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                write = memloc(XParam,j, -1, ib);\n                jj = (j - 8) * 2;\n                ii = memloc(XParam,jj, (XParam.blkwidth - 1), XBlock.BotRight[ib]);\n                ir = memloc(XParam,jj, (XParam.blkwidth - 2), XBlock.BotRight[ib]);\n                it = memloc(XParam,jj+1, (XParam.blkwidth - 1), XBlock.BotRight[ib]);\n                itr = memloc(XParam,jj+1, (XParam.blkwidth - 2), XBlock.BotRight[ib]);\n\n                z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.BotLeft[ib]]) // LeftTop block does not exist\n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n\n            write = memloc(XParam,j, -1, ib);\n            read = memloc(XParam, j, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n            z[write] = z[read];\n        }\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n\n            write = memloc(XParam, j, -1, ib);\n\n            jj = j * 2;\n            bb = XBlock.BotLeft[ib];\n\n            ii = memloc(XParam, jj, (XParam.blkwidth - 1), bb);\n            ir = memloc(XParam, jj, (XParam.blkwidth - 2), bb);\n            it = memloc(XParam, jj + 1, (XParam.blkwidth - 1), bb);\n            itr = memloc(XParam, jj + 1, (XParam.blkwidth - 2), bb);\n\n            z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n        }\n        //now find out aboy botright block\n        if (XBlock.BotRight[ib] == ib)\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, j, 0, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, -1, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n                jj = (j - 8) * 2;\n                bb = XBlock.BotRight[ib];\n\n                //read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, -1, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                //z[write] = z[read];\n                ii = memloc(XParam, jj, (XParam.blkwidth - 1), bb);\n                ir = memloc(XParam, jj, (XParam.blkwidth - 2), bb);\n                it = memloc(XParam, jj + 1, (XParam.blkwidth - 1), bb);\n                itr = memloc(XParam, jj + 1, (XParam.blkwidth - 2), bb);\n\n                z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            write = memloc(XParam, j, -1, ib);\n\n            T w1, w2, w3;\n\n\n            int jj = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? ftoi(ceil(j * (T)0.5)) : ftoi(ceil(j * (T)0.5) + XParam.blkwidth / 2);\n            w1 = T(1.0 / 3.0);\n            w2 = ceil(j * (T)0.5) * 2 &gt; j ? T(1.0 / 6.0) : T(0.5);\n            w3 = ceil(j * (T)0.5) * 2 &gt; j ? T(0.5) : T(1.0 / 6.0);\n\n            ii = memloc(XParam, j, 0, ib);\n            ir = memloc(XParam, jj, XParam.blkwidth - 1, XBlock.BotLeft[ib]);\n            it = memloc(XParam, jj -1, XParam.blkwidth - 1, XBlock.BotLeft[ib]);\n            //2 scenarios here ib is the rightbot neighbour of the leftbot block or ib is the righttop neighbour\n            if (XBlock.TopLeft[XBlock.BotLeft[ib]] == ib)\n            {\n                if (j == 0)\n                {\n                    if (XBlock.LeftTop[XBlock.BotLeft[ib]] == XBlock.BotLeft[ib]) // no botom of leftbot block\n                    {\n                        w3 = T(0.5 * (1.0 - w1));\n                        w2 = w3;\n                        it = ir;\n\n                    }\n                    else if (XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]] &lt; XBlock.level[XBlock.BotLeft[ib]]) // exists but is coarser\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(5.0 / 10.0);\n                        w3 = T(1.0 / 10.0);\n                        it = memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 1, XBlock.LeftTop[XBlock.BotLeft[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]] == XBlock.level[XBlock.BotLeft[ib]]) // exists with same level\n                    {\n                        it = memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 1, XBlock.LeftTop[XBlock.BotLeft[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]] &gt; XBlock.level[XBlock.BotLeft[ib]]) // exists with higher level\n                    {\n                        w1 = T(1.0 / 4.0);\n                        w2 = T(1.0 / 2.0);\n                        w3 = T(1.0 / 4.0);\n                        it = memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 1, XBlock.LeftTop[XBlock.BotLeft[ib]]);\n                    }\n\n\n                }\n\n\n            }\n            else//righttopleftif == ib\n            {\n                if (j == (XParam.blkwidth - 1))\n                {\n                    if (XBlock.RightTop[XBlock.BotRight[ib]] == XBlock.BotRight[ib]) // no botom of leftbot block\n                    {\n                        w3 = T(0.5 * (1.0 - w1));\n                        w2 = w3;\n                        ir = it;\n\n                    }\n                    else if (XBlock.level[XBlock.RightTop[XBlock.BotRight[ib]]] &lt; XBlock.level[XBlock.BotRight[ib]]) // exists but is coarser\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(1.0 / 10.0);\n                        w3 = T(5.0 / 10.0);\n                        ir = memloc(XParam, 0,XParam.blkwidth - 1, XBlock.RightTop[XBlock.BotRight[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.RightTop[XBlock.BotRight[ib]]] == XBlock.level[XBlock.BotRight[ib]]) // exists with same level\n                    {\n                        ir = memloc(XParam,0, XParam.blkwidth - 1, XBlock.RightTop[XBlock.BotRight[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.RightTop[XBlock.BotRight[ib]]] &gt; XBlock.level[XBlock.BotRight[ib]]) // exists with higher level\n                    {\n                        w1 = T(1.0 / 4.0);\n                        w2 = T(1.0 / 2.0);\n                        w3 = T(1.0 / 4.0);\n                        ir = memloc(XParam,0,XParam.blkwidth - 1, XBlock.RightTop[XBlock.BotRight[ib]]);\n                    }\n                }\n                //\n            }\n\n\n            z[write] = w1 * z[ii] + w2 * z[ir] + w3 * z[it];\n        }\n    }\n\n\n\n}\n\n\ntemplate &lt;class T&gt; __global__ void fillBot(int halowidth, int* active, int* level, int* botleft, int* botright, int* topleft, int* lefttop, int* righttop, T* a)\n{\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    //unsigned int iy = 0;\n    int ibl = blockIdx.x;\n\n    int ib = active[ibl];\n\n    int BL = botleft[ib];\n    int BR = botright[ib];\n    int TLBL = topleft[BL];\n    int LTBL = lefttop[BL];\n    int RTBR = righttop[BR];\n\n    int lev = level[ib];\n    int levBL = level[BL];\n    int levBR = level[BR];\n    int levLTBL = level[LTBL];\n    int levRTBR = level[RTBR];\n\n    int write = memloc(halowidth, blkmemwidth, ix, -1, ib);\n    int read;\n    int jj, ii, ir, it, itr;\n    T a_read;\n    T w1, w2, w3;\n    if (BL == ib)\n    {\n        if (ix &lt; (blockDim.x / 2))\n        {\n            read = memloc(halowidth, blkmemwidth, ix, 0, ib);\n            a_read = a[read];\n        }\n        else\n        {\n            if (BR == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, ix, 0, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (ix - (blockDim.x/2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 1), BR);\n                ir = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 2), BR);\n                it = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 1), BR);\n                itr = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 2), BR);\n                a_read = T(0.25)* (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n    }\n    else if (levBL == lev)\n    {\n        read = memloc(halowidth, blkmemwidth, ix, (blockDim.x - 1), BL);\n        a_read = a[read];\n    }\n    else if (levBL &gt; lev)\n    {\n        if (ix &lt; (blockDim.x / 2))\n        {\n            jj = ix * 2;\n            ii = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 1), BL);\n            ir = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 2), BL);\n            it = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 1), BL);\n            itr = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 2), BL);\n            a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        else\n        {\n            if (BR == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, ix, 0, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (ix - (blockDim.x/2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 1), BR);\n                ir = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 2), BR);\n                it = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 1), BR);\n                itr = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 2), BR);\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n    }\n    else if (levBL &lt; lev)\n    {\n        jj = TLBL == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + blockDim.x / 2;\n        w1 = 1.0 / 3.0;\n        w2 = ceil(ix * (T)0.5) * 2 &gt; ix ? T(1.0 / 6.0) : T(0.5);\n        w3 = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.5) : T(1.0 / 6.0);\n\n        ii = memloc(halowidth, blkmemwidth, ix, 0, ib);\n        ir = memloc(halowidth, blkmemwidth, jj, blockDim.x - 1, BL);\n        it = memloc(halowidth, blkmemwidth, jj - 1, blockDim.x - 1, BL);\n\n        if (TLBL == ib)\n        {\n            if (ix == 0)\n            {\n                if (LTBL == BL)\n                {\n                    w3 = 0.5 * (1.0 - w1);\n                    w2 = w3;\n                    it = ir;\n                }\n                else if (levLTBL &lt; levBL)\n                {\n                    w1 = 4.0 / 10.0;\n                    w2 = 5.0 / 10.0;\n                    w3 = 1.0 / 10.0;\n                    it = memloc(halowidth, blkmemwidth, blockDim.x - 1, blockDim.x - 1, LTBL);\n                }\n                else if (levLTBL == levBL)\n                {\n                    it = memloc(halowidth, blkmemwidth, blockDim.x - 1, blockDim.x - 1, LTBL);\n                }\n                else if (levLTBL &gt; levBL)\n                {\n                    w1 = 1.0 / 4.0;\n                    w2 = 1.0 / 2.0;\n                    w3 = 1.0 / 4.0;\n                    it = memloc(halowidth, blkmemwidth, blockDim.x - 1, blockDim.x - 1, LTBL);\n                }\n            }\n        }\n        else\n        {\n            if (ix == (blockDim.x - 1))\n            {\n                if (RTBR == BR)\n                {\n                    w3 = 0.5 * (1.0 - w1);\n                    w2 = w3;\n                    ir = it;\n                }\n                else if (levRTBR &lt; levBR)\n                {\n                    w1 = 4.0 / 10.0;\n                    w2 = 1.0 / 10.0;\n                    w3 = 5.0 / 10.0;\n                    ir = memloc(halowidth, blkmemwidth,0, blockDim.x - 1, RTBR);\n                }\n                else if (levRTBR == levBR)\n                {\n                    ir = memloc(halowidth, blkmemwidth,0, blockDim.x - 1, RTBR);\n                }\n                else if (levRTBR &gt; levBR)\n                {\n                    w1 = 1.0 / 4.0;\n                    w2 = 1.0 / 2.0;\n                    w3 = 1.0 / 4.0;\n                    ir = memloc(halowidth, blkmemwidth, 0, blockDim.x - 1, RTBR);\n                }\n            }\n        }\n        a_read = w1 * a[ii] + w2 * a[ir] + w3 * a[it];\n    }\n    a[write] = a_read;\n\n}\ntemplate __global__ void fillBot&lt;float&gt;(int halowidth, int* active, int* level, int* botleft, int* botright, int* topleft, int* lefttop, int* righttop, float* a);\ntemplate __global__ void fillBot&lt;double&gt;(int halowidth, int* active, int* level, int* botleft, int* botright, int* topleft, int* lefttop, int* righttop, double* a);\n\ntemplate &lt;class T&gt; __global__ void fillBotnew(int halowidth, int nblk, int* active, int* level, int* botleft, int* botright, int* topleft, int* lefttop, int* righttop, T* a)\n{\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    //unsigned int iy = 0;\n    int ibl = threadIdx.y + blockIdx.x * blockDim.y;\n    if (ibl &lt; nblk)\n    {\n        int ib = active[ibl];\n\n        int BL = botleft[ib];\n        int BR = botright[ib];\n        int TLBL = topleft[BL];\n        int LTBL = lefttop[BL];\n        int RTBR = righttop[BR];\n\n        int lev = level[ib];\n        int levBL = level[BL];\n        int levBR = level[BR];\n        int levLTBL = level[LTBL];\n        int levRTBR = level[RTBR];\n\n        int write = memloc(halowidth, blkmemwidth, ix, -1, ib);\n        int read;\n        int jj, ii, ir, it, itr;\n        T a_read;\n        T w1, w2, w3;\n        if (BL == ib)\n        {\n            if (ix &lt; (blockDim.x / 2))\n            {\n                read = memloc(halowidth, blkmemwidth, ix, 0, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                if (BR == ib)\n                {\n                    read = memloc(halowidth, blkmemwidth, ix, 0, ib);\n                    a_read = a[read];\n                }\n                else\n                {\n                    jj = (ix - (blockDim.x / 2)) * 2;\n                    ii = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 1), BR);\n                    ir = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 2), BR);\n                    it = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 1), BR);\n                    itr = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 2), BR);\n                    a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n        }\n        else if (levBL == lev)\n        {\n            read = memloc(halowidth, blkmemwidth, ix, (blockDim.x - 1), BL);\n            a_read = a[read];\n        }\n        else if (levBL &gt; lev)\n        {\n            if (ix &lt; (blockDim.x / 2))\n            {\n                jj = ix * 2;\n                ii = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 1), BL);\n                ir = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 2), BL);\n                it = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 1), BL);\n                itr = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 2), BL);\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n            else\n            {\n                if (BR == ib)\n                {\n                    read = memloc(halowidth, blkmemwidth, ix, 0, ib);\n                    a_read = a[read];\n                }\n                else\n                {\n                    jj = (ix - (blockDim.x / 2)) * 2;\n                    ii = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 1), BR);\n                    ir = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 2), BR);\n                    it = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 1), BR);\n                    itr = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 2), BR);\n                    a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n        }\n        else if (levBL &lt; lev)\n        {\n            jj = TLBL == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + blockDim.x / 2;\n            w1 = 1.0 / 3.0;\n            w2 = ceil(ix * (T)0.5) * 2 &gt; ix ? T(1.0 / 6.0) : T(0.5);\n            w3 = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.5) : T(1.0 / 6.0);\n\n            ii = memloc(halowidth, blkmemwidth, ix, 0, ib);\n            ir = memloc(halowidth, blkmemwidth, jj, blockDim.x - 1, BL);\n            it = memloc(halowidth, blkmemwidth, jj - 1, blockDim.x - 1, BL);\n\n            if (TLBL == ib)\n            {\n                if (ix == 0)\n                {\n                    if (LTBL == BL)\n                    {\n                        w3 = 0.5 * (1.0 - w1);\n                        w2 = w3;\n                        it = ir;\n                    }\n                    else if (levLTBL &lt; levBL)\n                    {\n                        w1 = 4.0 / 10.0;\n                        w2 = 5.0 / 10.0;\n                        w3 = 1.0 / 10.0;\n                        it = memloc(halowidth, blkmemwidth, blockDim.x - 1, blockDim.x - 1, LTBL);\n                    }\n                    else if (levLTBL == levBL)\n                    {\n                        it = memloc(halowidth, blkmemwidth, blockDim.x - 1, blockDim.x - 1, LTBL);\n                    }\n                    else if (levLTBL &gt; levBL)\n                    {\n                        w1 = 1.0 / 4.0;\n                        w2 = 1.0 / 2.0;\n                        w3 = 1.0 / 4.0;\n                        it = memloc(halowidth, blkmemwidth, blockDim.x - 1, blockDim.x - 1, LTBL);\n                    }\n                }\n            }\n            else\n            {\n                if (ix == (blockDim.x - 1))\n                {\n                    if (RTBR == BR)\n                    {\n                        w3 = 0.5 * (1.0 - w1);\n                        w2 = w3;\n                        ir = it;\n                    }\n                    else if (levRTBR &lt; levBR)\n                    {\n                        w1 = 4.0 / 10.0;\n                        w2 = 1.0 / 10.0;\n                        w3 = 5.0 / 10.0;\n                        ir = memloc(halowidth, blkmemwidth, 0, blockDim.x - 1, RTBR);\n                    }\n                    else if (levRTBR == levBR)\n                    {\n                        ir = memloc(halowidth, blkmemwidth, 0, blockDim.x - 1, RTBR);\n                    }\n                    else if (levRTBR &gt; levBR)\n                    {\n                        w1 = 1.0 / 4.0;\n                        w2 = 1.0 / 2.0;\n                        w3 = 1.0 / 4.0;\n                        ir = memloc(halowidth, blkmemwidth, 0, blockDim.x - 1, RTBR);\n                    }\n                }\n            }\n            a_read = w1 * a[ii] + w2 * a[ir] + w3 * a[it];\n        }\n        a[write] = a_read;\n    }\n\n}\ntemplate __global__ void fillBotnew&lt;float&gt;(int halowidth, int nblk, int* active, int* level, int* botleft, int* botright, int* topleft, int* lefttop, int* righttop, float* a);\ntemplate __global__ void fillBotnew&lt;double&gt;(int halowidth, int nblk, int* active, int* level, int* botleft, int* botright, int* topleft, int* lefttop, int* righttop, double* a);\n\ntemplate &lt;class T&gt; void fillBotFlux(Param XParam, bool doProlongation, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    int jj, bb;\n    int read, write;\n    int ii, ir, it;\n\n\n    if (XBlock.BotLeft[ib] == ib)//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n\n            read = memloc(XParam, j, 0, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            write = memloc(XParam, j, -1, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            z[write] = z[read];\n        }\n\n        if (XBlock.BotRight[ib] == ib) // boundary on the top half too\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, j, 0, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, -1, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                write = memloc(XParam, j, -1, ib);\n                jj = (j - 8) * 2;\n                ii = memloc(XParam, jj, (XParam.blkwidth - 1), XBlock.BotRight[ib]);\n                //ir = memloc(XParam, jj, (XParam.blkwidth - 2), XBlock.BotRight[ib]);\n                it = memloc(XParam, jj + 1, (XParam.blkwidth - 1), XBlock.BotRight[ib]);\n                //itr = memloc(XParam, jj + 1, (XParam.blkwidth - 2), XBlock.BotRight[ib]);\n\n                z[write] = T(0.5) * (z[ii] + z[it] );\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.BotLeft[ib]]) // LeftTop block does not exist\n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n\n            write = memloc(XParam, j, -1, ib);\n            read = memloc(XParam, j, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n            z[write] = z[read];\n        }\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n\n            write = memloc(XParam, j, -1, ib);\n\n            jj = j * 2;\n            bb = XBlock.BotLeft[ib];\n\n            ii = memloc(XParam, jj, (XParam.blkwidth - 1), bb);\n            //ir = memloc(XParam, jj, (XParam.blkwidth - 2), bb);\n            it = memloc(XParam, jj + 1, (XParam.blkwidth - 1), bb);\n            //itr = memloc(XParam, jj + 1, (XParam.blkwidth - 2), bb);\n\n            z[write] = T(0.5) * (z[ii] + z[it]);\n        }\n        //now find out aboy botright block\n        if (XBlock.BotRight[ib] == ib)\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, j, 0, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, -1, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n                jj = (j - 8) * 2;\n                bb = XBlock.BotRight[ib];\n\n                //read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, -1, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                //z[write] = z[read];\n                ii = memloc(XParam, jj, (XParam.blkwidth - 1), bb);\n                //ir = memloc(XParam, jj, (XParam.blkwidth - 2), bb);\n                it = memloc(XParam, jj + 1, (XParam.blkwidth - 1), bb);\n                //itr = memloc(XParam, jj + 1, (XParam.blkwidth - 2), bb);\n\n                z[write] = T(0.5) * (z[ii]  + z[it] );\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            write = memloc(XParam, j, -1, ib);\n\n            //T w1, w2, w3;\n\n\n            int jj = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? ftoi(ceil(j * (T)0.5)) : ftoi(ceil(j * (T)0.5) + XParam.blkwidth / 2);\n\n\n            //ii = memloc(XParam, j, 0, ib);\n            ir = memloc(XParam, jj, XParam.blkwidth - 1, XBlock.BotLeft[ib]);\n            if(doProlongation)\n                z[write] = z[ir];\n        }\n    }\n\n\n\n}\n\ntemplate &lt;class T&gt; void fillTop(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    int jj, bb;\n    int read, write;\n    int ii, ir, it, itr;\n\n\n    if (XBlock.TopLeft[ib] == ib)//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n\n            read = memloc(XParam,j, XParam.blkwidth - 1, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            write = memloc(XParam,j, XParam.blkwidth, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            z[write] = z[read];\n        }\n\n        if (XBlock.TopRight[ib] == ib) // boundary on the top half too\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, j, XParam.blkwidth - 1, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, XParam.blkwidth, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                write = memloc(XParam, j, XParam.blkwidth, ib);\n                jj = (j - (XParam.blkwidth / 2)) * 2;\n                ii = memloc(XParam, jj, 0, XBlock.TopRight[ib]);\n                ir = memloc(XParam, jj, 1, XBlock.TopRight[ib]);\n                it = memloc(XParam, jj + 1, 0, XBlock.TopRight[ib]);\n                itr = memloc(XParam, jj + 1, 1, XBlock.TopRight[ib]);\n\n                z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.TopLeft[ib]]) // LeftTop block does not exist\n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n\n            write = memloc(XParam, j, XParam.blkwidth, ib);\n            read = memloc(XParam, j, 0, XBlock.TopLeft[ib]);\n            z[write] = z[read];\n        }\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n\n            write = memloc(XParam, j, XParam.blkwidth, ib);\n\n            jj = j * 2;\n            bb = XBlock.TopLeft[ib];\n\n            ii = memloc(XParam,jj, 0, bb);\n            ir = memloc(XParam,jj, 1, bb);\n            it = memloc(XParam,jj + 1, 0, bb);\n            itr = memloc(XParam,jj + 1, 1, bb);\n\n            z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.TopRight[ib] == ib)\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam,j, XParam.blkwidth - 1, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, XParam.blkwidth, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n                jj = (j - (XParam.blkwidth / 2)) * 2;\n                bb = XBlock.TopRight[ib];\n\n                //read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j , XParam.blkwidth, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                //z[write] = z[read];\n                ii = memloc(XParam,jj, 0, bb);\n                ir = memloc(XParam,jj, 1, bb);\n                it = memloc(XParam,jj + 1, 0, bb);\n                itr = memloc(XParam,jj + 1, 1, bb);\n\n                z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            write = memloc(XParam,j, XParam.blkwidth, ib);\n\n            T w1, w2, w3;\n\n\n            int jj = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? ftoi(ceil(j * (T)0.5)) : ftoi(ceil(j * (T)0.5) + XParam.blkwidth / 2);\n            w1 = T(1.0 / 3.0);\n            w2 = ceil(j * (T)0.5) * 2 &gt; j ? T(1.0 / 6.0) : T(0.5);\n            w3 = ceil(j * (T)0.5) * 2 &gt; j ? T(0.5) : T(1.0 / 6.0);\n\n            ii = memloc(XParam,j, XParam.blkwidth - 1, ib);\n            ir = memloc(XParam,jj, 0,  XBlock.TopLeft[ib]);\n            it = memloc(XParam,jj-1, 0, XBlock.TopLeft[ib]);\n            //2 scenarios here ib is the leftbot neighbour of the rightbot block or ib is the lefttop neighbour\n            if (XBlock.BotLeft[XBlock.TopLeft[ib]] == ib)\n            {\n                if (j == 0)\n                {\n                    if (XBlock.LeftBot[XBlock.TopLeft[ib]] == XBlock.TopLeft[ib]) // no botom of leftbot block\n                    {\n                        w3 = T(0.5 * (1.0 - w1));\n                        w2 = w3;\n                        it = ir;\n\n                    }\n                    else if (XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]] &lt; XBlock.level[XBlock.TopLeft[ib]]) // exists but is coarser\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(5.0 / 10.0);\n                        w3 = T(1.0 / 10.0);\n                        it = memloc(XParam, XParam.blkwidth - 1,0, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]] == XBlock.level[XBlock.TopLeft[ib]]) // exists with same level\n                    {\n                        it = memloc(XParam,  XParam.blkwidth - 1,0, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]] &gt; XBlock.level[XBlock.TopLeft[ib]]) // exists with higher level\n                    {\n                        w1 = T(1.0 / 4.0);\n                        w2 = T(1.0 / 2.0);\n                        w3 = T(1.0 / 4.0);\n                        it = memloc(XParam, XParam.blkwidth - 1, 0, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n                    }\n\n\n                }\n\n\n            }\n            else//\n            {\n                if (j == (XParam.blkwidth - 1))\n                {\n                    if (XBlock.RightBot[XBlock.TopRight[ib]] == XBlock.TopRight[ib]) // no botom of leftbot block\n                    {\n                        w3 = T(0.5 * (1.0 - w1));\n                        w2 = w3;\n                        ir = it;\n\n                    }\n                    else if (XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]] &lt; XBlock.level[XBlock.TopRight[ib]]) // exists but is coarser\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(1.0 / 10.0);\n                        w3 = T(5.0 / 10.0);\n                        ir = memloc(XParam, 0, 0, XBlock.RightBot[XBlock.TopRight[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]] == XBlock.level[XBlock.TopRight[ib]]) // exists with same level\n                    {\n                        ir = memloc(XParam, 0, 0, XBlock.RightBot[XBlock.TopRight[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]] &gt; XBlock.level[XBlock.TopRight[ib]]) // exists with higher level\n                    {\n                        w1 = T(1.0 / 4.0);\n                        w2 = T(1.0 / 2.0);\n                        w3 = T(1.0 / 4.0);\n                        ir = memloc(XParam, 0,0, XBlock.RightBot[XBlock.TopRight[ib]]);\n                    }\n                }\n                //\n            }\n\n\n            z[write] = w1 * z[ii] + w2 * z[ir] + w3 * z[it];\n        }\n    }\n\n\n\n}\n\ntemplate &lt;class T&gt; __global__ void fillTop(int halowidth, int* active, int* level,int * topleft, int * topright,int * botleft, int* leftbot, int* rightbot,  T* a)\n{\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    //unsigned int iy = blockDim.x-1;\n    int ibl = blockIdx.x;\n    int ib = active[ibl];\n\n    int TL = topleft[ib];\n    int TR = topright[ib];\n    int LBTL = leftbot[TL];\n    int BLTL = botleft[TL];\n    int RBTR = rightbot[TR];\n\n\n    int lev = level[ib];\n    int levTL = level[TL];\n    int levTR = level[TR];\n    int levLBTL = level[LBTL];\n    int levRBTR = level[RBTR];\n\n    int write = memloc(halowidth, blkmemwidth, ix, blockDim.x, ib);\n    int read;\n    int jj, ii, ir, it, itr;\n    T a_read;\n    T w1, w2, w3;\n\n    if (TL == ib)\n    {\n        if (ix &lt; (blockDim.x / 2))\n        {\n            read = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n            a_read = a[read];\n        }\n        else\n        {\n            if (TR == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (ix - (blockDim.x / 2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, jj, 0, TR);\n                ir = memloc(halowidth, blkmemwidth, jj, 1, TR);\n                it = memloc(halowidth, blkmemwidth, jj + 1, 0, TR);\n                itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TR);\n\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n    }\n    else if (levTL == lev)\n    {\n        read = memloc(halowidth, blkmemwidth, ix, 0, TL);\n        a_read = a[read];\n    }\n    else if (levTL &gt; lev)\n    {\n        if (ix &lt; (blockDim.x / 2))\n        {\n            jj = ix * 2;\n\n\n            ii = memloc(halowidth, blkmemwidth, jj, 0, TL);\n            ir = memloc(halowidth, blkmemwidth, jj, 1, TL);\n            it = memloc(halowidth, blkmemwidth, jj + 1, 0, TL);\n            itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TL);\n            a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        else\n        {\n            if (TR == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, ix, blockDim.x-1, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (ix - (blockDim.x / 2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, jj, 0, TR);\n                ir = memloc(halowidth, blkmemwidth, jj, 1, TR);\n                it = memloc(halowidth, blkmemwidth, jj + 1, 0, TR);\n                itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TR);\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n    }\n    else if (levTL &lt; lev)\n    {\n        jj = BLTL == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + blockDim.x / 2;\n        w1 = 1.0 / 3.0;\n        w2 = ceil(ix * (T)0.5) * 2 &gt; ix ? T(1.0 / 6.0) : T(0.5);\n        w3 = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.5) : T(1.0 / 6.0);\n        ii = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n        ir = memloc(halowidth, blkmemwidth, jj, 0, TL);\n        it = memloc(halowidth, blkmemwidth, jj - 1, 0, TL);\n        if (BLTL == ib)\n        {\n            if (ix == 0)\n            {\n                if (LBTL == TL)\n                {\n                    w3 = 0.5 * (1.0 - w1);\n                    w2 = w3;\n                    it = ir;\n                }\n                else if (levLBTL &lt; levTL)\n                {\n                    w1 = 4.0 / 10.0;\n                    w2 = 5.0 / 10.0;\n                    w3 = 1.0 / 10.0;\n                    it = memloc(halowidth, blkmemwidth, blockDim.x - 1, 0, LBTL);\n                }\n                else if (levLBTL == levTL)\n                {\n                    it = memloc(halowidth, blkmemwidth, blockDim.x - 1, 0, LBTL);\n                }\n                else if (levLBTL &gt; levTL)\n                {\n                    w1 = 1.0 / 4.0;\n                    w2 = 1.0 / 2.0;\n                    w3 = 1.0 / 4.0;\n                    it = memloc(halowidth, blkmemwidth, blockDim.x - 1, 0, LBTL);\n                }\n            }\n        }\n        else\n        {\n            if (ix == blockDim.x - 1)\n            {\n                if (RBTR == TR)\n                {\n                    w3 = 0.5 * (1.0 - w1);\n                    w2 = w3;\n                    ir = it;\n                }\n                else if (levRBTR &lt; levTR)\n                {\n                    w1 = 4.0 / 10.0;\n                    w2 = 1.0 / 10.0;\n                    w3 = 5.0 / 10.0;\n                    ir = memloc(halowidth, blkmemwidth, 0, 0, RBTR);\n                }\n                else if (levRBTR == levTR)\n                {\n                    ir = memloc(halowidth, blkmemwidth, 0, 0, RBTR);\n                }\n                else if (levRBTR &gt; levTR)\n                {\n                    w1 = 1.0 / 4.0;\n                    w2 = 1.0 / 2.0;\n                    w3 = 1.0 / 4.0;\n                    ir = memloc(halowidth, blkmemwidth,0, 0, RBTR);\n                }\n            }\n        }\n        a_read= w1 * a[ii] + w2 * a[ir] + w3 * a[it];\n    }\n    a[write] = a_read;\n}\n\ntemplate __global__ void fillTop&lt;float&gt;(int halowidth, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, float* a);\ntemplate __global__ void fillTop&lt;double&gt;(int halowidth, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, double* a);\n\ntemplate &lt;class T&gt; __global__ void fillTopnew(int halowidth, int nblk, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, T* a)\n{\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    //unsigned int iy = blockDim.x-1;\n    int ibl = threadIdx.y + blockIdx.x * blockDim.y;\n    if (ibl &lt; nblk)\n    {\n        int ib = active[ibl];\n\n        int TL = topleft[ib];\n        int TR = topright[ib];\n        int LBTL = leftbot[TL];\n        int BLTL = botleft[TL];\n        int RBTR = rightbot[TR];\n\n\n        int lev = level[ib];\n        int levTL = level[TL];\n        int levTR = level[TR];\n        int levLBTL = level[LBTL];\n        int levRBTR = level[RBTR];\n\n        int write = memloc(halowidth, blkmemwidth, ix, blockDim.x, ib);\n        int read;\n        int jj, ii, ir, it, itr;\n        T a_read;\n        T w1, w2, w3;\n\n        if (TL == ib)\n        {\n            if (ix &lt; (blockDim.x / 2))\n            {\n                read = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                if (TR == ib)\n                {\n                    read = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n                    a_read = a[read];\n                }\n                else\n                {\n                    jj = (ix - (blockDim.x / 2)) * 2;\n                    ii = memloc(halowidth, blkmemwidth, jj, 0, TR);\n                    ir = memloc(halowidth, blkmemwidth, jj, 1, TR);\n                    it = memloc(halowidth, blkmemwidth, jj + 1, 0, TR);\n                    itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TR);\n\n                    a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n        }\n        else if (levTL == lev)\n        {\n            read = memloc(halowidth, blkmemwidth, ix, 0, TL);\n            a_read = a[read];\n        }\n        else if (levTL &gt; lev)\n        {\n            if (ix &lt; (blockDim.x / 2))\n            {\n                jj = ix * 2;\n\n\n                ii = memloc(halowidth, blkmemwidth, jj, 0, TL);\n                ir = memloc(halowidth, blkmemwidth, jj, 1, TL);\n                it = memloc(halowidth, blkmemwidth, jj + 1, 0, TL);\n                itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TL);\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n            else\n            {\n                if (TR == ib)\n                {\n                    read = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n                    a_read = a[read];\n                }\n                else\n                {\n                    jj = (ix - (blockDim.x / 2)) * 2;\n                    ii = memloc(halowidth, blkmemwidth, jj, 0, TR);\n                    ir = memloc(halowidth, blkmemwidth, jj, 1, TR);\n                    it = memloc(halowidth, blkmemwidth, jj + 1, 0, TR);\n                    itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TR);\n                    a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n        }\n        else if (levTL &lt; lev)\n        {\n            jj = BLTL == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + blockDim.x / 2;\n            w1 = 1.0 / 3.0;\n            w2 = ceil(ix * (T)0.5) * 2 &gt; ix ? T(1.0 / 6.0) : T(0.5);\n            w3 = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.5) : T(1.0 / 6.0);\n            ii = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n            ir = memloc(halowidth, blkmemwidth, jj, 0, TL);\n            it = memloc(halowidth, blkmemwidth, jj - 1, 0, TL);\n            if (BLTL == ib)\n            {\n                if (ix == 0)\n                {\n                    if (LBTL == TL)\n                    {\n                        w3 = 0.5 * (1.0 - w1);\n                        w2 = w3;\n                        it = ir;\n                    }\n                    else if (levLBTL &lt; levTL)\n                    {\n                        w1 = 4.0 / 10.0;\n                        w2 = 5.0 / 10.0;\n                        w3 = 1.0 / 10.0;\n                        it = memloc(halowidth, blkmemwidth, blockDim.x - 1, 0, LBTL);\n                    }\n                    else if (levLBTL == levTL)\n                    {\n                        it = memloc(halowidth, blkmemwidth, blockDim.x - 1, 0, LBTL);\n                    }\n                    else if (levLBTL &gt; levTL)\n                    {\n                        w1 = 1.0 / 4.0;\n                        w2 = 1.0 / 2.0;\n                        w3 = 1.0 / 4.0;\n                        it = memloc(halowidth, blkmemwidth, blockDim.x - 1, 0, LBTL);\n                    }\n                }\n            }\n            else\n            {\n                if (ix == blockDim.x - 1)\n                {\n                    if (RBTR == TR)\n                    {\n                        w3 = 0.5 * (1.0 - w1);\n                        w2 = w3;\n                        ir = it;\n                    }\n                    else if (levRBTR &lt; levTR)\n                    {\n                        w1 = 4.0 / 10.0;\n                        w2 = 1.0 / 10.0;\n                        w3 = 5.0 / 10.0;\n                        ir = memloc(halowidth, blkmemwidth, 0, 0, RBTR);\n                    }\n                    else if (levRBTR == levTR)\n                    {\n                        ir = memloc(halowidth, blkmemwidth, 0, 0, RBTR);\n                    }\n                    else if (levRBTR &gt; levTR)\n                    {\n                        w1 = 1.0 / 4.0;\n                        w2 = 1.0 / 2.0;\n                        w3 = 1.0 / 4.0;\n                        ir = memloc(halowidth, blkmemwidth, 0, 0, RBTR);\n                    }\n                }\n            }\n            a_read = w1 * a[ii] + w2 * a[ir] + w3 * a[it];\n        }\n        a[write] = a_read;\n    }\n}\n\ntemplate __global__ void fillTopnew&lt;float&gt;(int halowidth, int nblk, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, float* a);\ntemplate __global__ void fillTopnew&lt;double&gt;(int halowidth, int nblk, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, double* a);\n\n\ntemplate &lt;class T&gt; void fillTopFlux(Param XParam, bool doProlongation, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    int jj, bb;\n    int read, write;\n    int ii, ir, it;\n\n\n    if (XBlock.TopLeft[ib] == ib)//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n\n            read = memloc(XParam, j, XParam.blkwidth - 1, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            write = memloc(XParam, j, XParam.blkwidth, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            z[write] = z[read];\n        }\n\n        if (XBlock.TopRight[ib] == ib) // boundary on the top half too\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, j, XParam.blkwidth - 1, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, XParam.blkwidth, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                write = memloc(XParam, j, XParam.blkwidth, ib);\n                jj = (j - (XParam.blkwidth / 2)) * 2;\n                ii = memloc(XParam, jj, 0, XBlock.TopRight[ib]);\n                //ir = memloc(XParam, jj, 1, XBlock.TopRight[ib]);\n                it = memloc(XParam, jj + 1, 0, XBlock.TopRight[ib]);\n                //itr = memloc(XParam, jj + 1, 1, XBlock.TopRight[ib]);\n\n                z[write] = T(0.5) * (z[ii] + z[it] );\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.TopLeft[ib]]) // LeftTop block does not exist\n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n\n            write = memloc(XParam, j, XParam.blkwidth, ib);\n            read = memloc(XParam, j, 0, XBlock.TopLeft[ib]);\n            z[write] = z[read];\n        }\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n\n            write = memloc(XParam, j, XParam.blkwidth, ib);\n\n            jj = j * 2;\n            bb = XBlock.TopLeft[ib];\n\n            ii = memloc(XParam, jj, 0, bb);\n            //ir = memloc(XParam, jj, 1, bb);\n            it = memloc(XParam, jj + 1, 0, bb);\n            //itr = memloc(XParam, jj + 1, 1, bb);\n\n            z[write] = T(0.5) * (z[ii]  + z[it]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.TopRight[ib] == ib)\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, j, XParam.blkwidth - 1, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, XParam.blkwidth, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n                jj = (j - (XParam.blkwidth / 2)) * 2;\n                bb = XBlock.TopRight[ib];\n\n                //read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, XParam.blkwidth, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                //z[write] = z[read];\n                ii = memloc(XParam, jj, 0, bb);\n                //ir = memloc(XParam, jj, 1, bb);\n                it = memloc(XParam, jj + 1, 0, bb);\n                //itr = memloc(XParam, jj + 1, 1, bb);\n\n                z[write] = T(0.5) * (z[ii]  + z[it]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            write = memloc(XParam, j, XParam.blkwidth, ib);\n            int jj = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? ftoi(floor(j * (T)0.5)) : ftoi(floor(j * (T)0.5) + XParam.blkwidth / 2);\n\n            ir = memloc(XParam, jj, 0, XBlock.TopLeft[ib]);\n\n            if (doProlongation)\n                z[write] = z[ir];\n\n        }\n    }\n\n\n\n}\ntemplate void fillTopFlux&lt;float&gt;(Param XParam, bool doProlongation, int ib, BlockP&lt;float&gt; XBlock, float*&amp; z);\ntemplate void fillTopFlux&lt;double&gt;(Param XParam, bool doProlongation, int ib, BlockP&lt;double&gt; XBlock, double*&amp; z);\n\ntemplate &lt;class T&gt; __global__ void fillTopFlux(int halowidth, bool doProlongation, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, T* a)\n{\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    //unsigned int iy = blockDim.x - 1;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = active[ibl];\n\n    int TL = topleft[ib];\n    int TR = topright[ib];\n    //int LBTL = leftbot[TL];\n    int BLTL = botleft[TL];\n    //int RBTR = rightbot[TR];\n\n\n    int lev = level[ib];\n    int levTL = level[TL];\n    //int levTR = level[TR];\n    //int levLBTL = level[LBTL];\n    //int levRBTR = level[RBTR];\n\n    int write = memloc(halowidth, blkmemwidth, ix, blockDim.x, ib);\n    int read;\n    int jj, ii, ir, it;\n    T a_read;\n    //T w1, w2, w3;\n\n    if (TL == ib)\n    {\n        if (ix &lt; (blockDim.x / 2))\n        {\n            read = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n            a_read = a[read];\n        }\n        else\n        {\n            if (TR == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (ix - (blockDim.x / 2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, jj, 0, TR);\n                //ir = memloc(halowidth, blkmemwidth, jj, 1, TR);\n                it = memloc(halowidth, blkmemwidth, jj + 1, 0, TR);\n                //itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TR);\n\n                a_read = T(0.5) * (a[ii]  + a[it] );\n            }\n        }\n    }\n    else if (levTL == lev)\n    {\n        read = memloc(halowidth, blkmemwidth, ix, 0, TL);\n        a_read = a[read];\n    }\n    else if (levTL &gt; lev)\n    {\n        if (ix &lt; (blockDim.x / 2))\n        {\n            jj = ix * 2;\n\n\n            ii = memloc(halowidth, blkmemwidth, jj, 0, TL);\n            //ir = memloc(halowidth, blkmemwidth, jj, 1, TL);\n            it = memloc(halowidth, blkmemwidth, jj + 1, 0, TL);\n            //itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TL);\n            a_read = T(0.5) * (a[ii] + a[it]);\n        }\n        else\n        {\n            if (TR == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (ix - (blockDim.x / 2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, jj, 0, TR);\n                //ir = memloc(halowidth, blkmemwidth, jj, 1, TR);\n                it = memloc(halowidth, blkmemwidth, jj + 1, 0, TR);\n                //itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TR);\n                a_read = T(0.5) * (a[ii] + a[it]);\n            }\n        }\n    }\n    else if (levTL &lt; lev)\n    {\n        jj = BLTL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n\n        ir = memloc(halowidth, blkmemwidth, jj, 0, TL);\n        if (doProlongation)\n            a_read = a[ir];\n        else\n            a_read =  a[write];\n    }\n    a[write] = a_read;\n}\n\ntemplate __global__ void fillTopFlux&lt;float&gt;(int halowidth, bool doProlongation, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, float* a);\ntemplate __global__ void fillTopFlux&lt;double&gt;(int halowidth, bool doProlongation, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, double* a);\n\n\n\ntemplate &lt;class T&gt; void fillCorners(Param XParam, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    int ib;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        fillCorners(XParam, ib, XBlock, z);\n\n    }\n\n}\ntemplate void fillCorners&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float*&amp; z);\ntemplate void fillCorners&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double*&amp; z);\n\n\ntemplate &lt;class T&gt; void fillCorners(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt;&amp; Xev)\n{\n    int ib;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        fillCorners(XParam, ib, XBlock, Xev.h);\n        fillCorners(XParam, ib, XBlock, Xev.zs);\n        fillCorners(XParam, ib, XBlock, Xev.u);\n        fillCorners(XParam, ib, XBlock, Xev.v);\n    }\n\n}\ntemplate void fillCorners&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt;&amp; Xev);\ntemplate void fillCorners&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt;&amp; Xev);\n\n\n\ntemplate &lt;class T&gt; void fillCorners(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    // Run only this function after the filling the other bit of halo (i.e. fctn fillleft...)\n    // Most of the time the cormers are not needed. they are when refining a cell! \n\n\n    T zz;\n    int write;\n    int ii, ir, it, itr;\n\n\n    // Bottom left corner\n    write = memloc(XParam, -1, -1, ib);\n    //check that there is a block there and if there is calculate the value depending on the level of that block\n    if (XBlock.LeftTop[XBlock.BotLeft[ib]] == XBlock.BotLeft[ib]) // There is no block\n    {\n        zz = T(0.5) * (z[memloc(XParam, -1, 0, ib)] + z[memloc(XParam, 0, -1, ib)]);\n    }\n    else if (XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]] == XBlock.level[ib])\n    {\n        zz = z[memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 1, XBlock.LeftTop[XBlock.BotLeft[ib]])];\n    }\n    else if (XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]] &gt; XBlock.level[ib])\n    {\n        ii = memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 1, XBlock.LeftTop[XBlock.BotLeft[ib]]);\n        ir = memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 2, XBlock.LeftTop[XBlock.BotLeft[ib]]);\n        it = memloc(XParam, XParam.blkwidth - 2, XParam.blkwidth - 1, XBlock.LeftTop[XBlock.BotLeft[ib]]);\n        itr = memloc(XParam, XParam.blkwidth - 2, XParam.blkwidth - 2, XBlock.LeftTop[XBlock.BotLeft[ib]]);\n\n        zz = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n    }\n    else if (XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]] &lt; XBlock.level[ib])\n    {\n        ii = memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 1, XBlock.LeftTop[XBlock.BotLeft[ib]]);\n        ir = memloc(XParam, - 1, 0, ib);\n        it = memloc(XParam,0, - 1, ib);\n        zz = T(0.5) * z[ii] + T(0.25) * (z[ir] + z[it]);\n    }\n\n    z[write] = zz;\n\n    // Top Left corner\n    write = memloc(XParam, -1, XParam.blkwidth, ib);\n    //check that there is a block there and if there is calculate the value depending on the level of that block\n    if (XBlock.LeftBot[XBlock.TopLeft[ib]] == XBlock.TopLeft[ib]) // There is no block\n    {\n        zz = T(0.5) * (z[memloc(XParam, -1, XParam.blkwidth-1, ib)] + z[memloc(XParam, 0, XParam.blkwidth, ib)]);\n    }\n    else if (XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]] == XBlock.level[ib])\n    {\n        zz = z[memloc(XParam, XParam.blkwidth - 1, 0, XBlock.LeftBot[XBlock.TopLeft[ib]])];\n    }\n    else if (XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]] &gt; XBlock.level[ib])\n    {\n        ii = memloc(XParam, XParam.blkwidth - 1, 0, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n        ir = memloc(XParam, XParam.blkwidth - 1, 1, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n        it = memloc(XParam, XParam.blkwidth - 2, 0, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n        itr = memloc(XParam, XParam.blkwidth - 2, 1, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n\n        zz = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n    }\n    else if (XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]] &lt; XBlock.level[ib])\n    {\n        ii = memloc(XParam, XParam.blkwidth - 1, 0, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n        ir = memloc(XParam, -1, XParam.blkwidth - 1, ib);\n        it = memloc(XParam, 0, XParam.blkwidth, ib);\n        zz = T(0.5) * z[ii] + T(0.25) * (z[ir] + z[it]);\n    }\n\n    z[write] = zz;\n\n    //Top Right corner\n    write = memloc(XParam, XParam.blkwidth, XParam.blkwidth, ib);\n    //check that there is a block there and if there is calculate the value depending on the level of that block\n    if (XBlock.RightBot[XBlock.TopRight[ib]] == XBlock.TopRight[ib]) // There is no block\n    {\n        zz = T(0.5) * (z[memloc(XParam, XParam.blkwidth, XParam.blkwidth - 1, ib)] + z[memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth, ib)]);\n    }\n    else if (XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]] == XBlock.level[ib])\n    {\n        zz = z[memloc(XParam, 0, 0, XBlock.RightBot[XBlock.TopRight[ib]])];\n    }\n    else if (XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]] &gt; XBlock.level[ib])\n    {\n        ii = memloc(XParam, 0, 0, XBlock.RightBot[XBlock.TopRight[ib]]);\n        ir = memloc(XParam, 0, 1, XBlock.RightBot[XBlock.TopRight[ib]]);\n        it = memloc(XParam, 1, 0, XBlock.RightBot[XBlock.TopRight[ib]]);\n        itr = memloc(XParam, 1, 1, XBlock.RightBot[XBlock.TopRight[ib]]);\n\n        zz = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n    }\n    else if (XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]] &lt; XBlock.level[ib])\n    {\n        ii = memloc(XParam, 0, 0, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n        ir = memloc(XParam, XParam.blkwidth, XParam.blkwidth - 1, ib);\n        it = memloc(XParam, XParam.blkwidth-1, XParam.blkwidth, ib);\n        zz = T(0.5) * z[ii] + T(0.25) * ( z[ir] +  z[it]);\n    }\n\n    z[write] = zz;\n\n    //Bot Right corner\n    write = memloc(XParam, XParam.blkwidth, -1, ib);\n    //check that there is a block there and if there is calculate the value depending on the level of that block\n    if (XBlock.RightBot[XBlock.BotRight[ib]] == XBlock.BotRight[ib]) // There is no block\n    {\n        zz = T(0.5) * (z[memloc(XParam, XParam.blkwidth-1, - 1, ib)] + z[memloc(XParam, XParam.blkwidth , 0, ib)]);\n    }\n    else if (XBlock.level[XBlock.RightBot[XBlock.BotRight[ib]]] == XBlock.level[ib])\n    {\n        zz = z[memloc(XParam, 0, XParam.blkwidth - 1, XBlock.RightBot[XBlock.BotRight[ib]])];\n    }\n    else if (XBlock.level[XBlock.RightBot[XBlock.BotRight[ib]]] &gt; XBlock.level[ib])\n    {\n        ii = memloc(XParam, 0, XParam.blkwidth - 1, XBlock.RightBot[XBlock.BotRight[ib]]);\n        ir = memloc(XParam, 0, XParam.blkwidth - 2, XBlock.RightBot[XBlock.BotRight[ib]]);\n        it = memloc(XParam, 1, XParam.blkwidth - 1, XBlock.RightBot[XBlock.BotRight[ib]]);\n        itr = memloc(XParam, 1, XParam.blkwidth - 2, XBlock.RightBot[XBlock.BotRight[ib]]);\n\n        zz = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n    }\n    else if (XBlock.level[XBlock.RightBot[XBlock.BotRight[ib]]] &lt; XBlock.level[ib])\n    {\n        ii = memloc(XParam, 0, XParam.blkwidth - 1, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n        ir = memloc(XParam, XParam.blkwidth - 1, -1, ib);\n        it = memloc(XParam, XParam.blkwidth, 0, ib);\n        zz = T(0.5) * z[ii] + T(0.25) * (z[ir] + z[it]);\n    }\n\n    z[write] = zz;\n\n}\ntemplate void fillCorners&lt;float&gt;(Param XParam, int ib, BlockP&lt;float&gt; XBlock, float*&amp; z);\ntemplate void fillCorners&lt;double&gt;(Param XParam, int ib, BlockP&lt;double&gt; XBlock, double*&amp; z);\n\n\ntemplate &lt;class T&gt; __global__ void fillCornersGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    int halowidth = XParam.halowidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    //int iy = threadIdx.y;\n    //unsigned int iy = blockDim.x-1;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int TL = XBlock.TopLeft[ib];\n    int TR = XBlock.TopRight[ib];\n    int LB = XBlock.LeftBot[ib];\n    int LT = XBlock.LeftTop[ib];\n    int BL = XBlock.BotLeft[ib];\n    int BR = XBlock.BotRight[ib];\n    int RB = XBlock.RightBot[ib];\n    int RT = XBlock.RightTop[ib];\n\n    //int LBTL = XBlock.leftbot[TL];\n    //int BLTL = XBlock.botleft[TL];\n    //int RBTR = XBlock.rightbot[TR];\n\n    int iout, ii;\n\n\n    if (ix == 0)\n    {\n        // Bot left corner\n\n        iout = memloc(halowidth, blkmemwidth, -1, -1, ib);\n\n\n        if (BL == ib &amp;&amp; LB == ib)//\n        {\n            ii = memloc(halowidth, blkmemwidth, 0, 0, ib);\n        }\n        else\n        {\n            if (BL != ib)\n            {\n                ii = memloc(halowidth, blkmemwidth, -1, XParam.blkwidth - 1, BL);\n            }\n            else\n            {\n                ii = memloc(halowidth, blkmemwidth, XParam.blkwidth - 1, -1, LB);\n            }\n\n        }\n        z[iout] = z[ii];\n    }\n    if (ix == 1)\n    {\n\n        // Top left corner\n        iout = memloc(halowidth, blkmemwidth, -1, XParam.blkwidth, ib);\n        if (TL == ib &amp;&amp; LT == ib)//\n        {\n            ii = memloc(halowidth, blkmemwidth, 0, XParam.blkwidth - 1, ib);\n        }\n        else\n        {\n            if (TL != ib)\n            {\n                ii = memloc(halowidth, blkmemwidth, -1, 0, TL);\n            }\n            else\n            {\n                ii = memloc(halowidth, blkmemwidth, XParam.blkwidth, XParam.blkwidth - 1, LT);\n            }\n\n        }\n        z[iout] = z[ii];\n\n    }\n    if (ix == 2)\n    {\n        // Top right corner\n        iout = memloc(halowidth, blkmemwidth, XParam.blkwidth, XParam.blkwidth, ib);\n        if (TR == ib &amp;&amp; RT == ib)//\n        {\n            ii = memloc(halowidth, blkmemwidth, XParam.blkwidth - 1, XParam.blkwidth - 1, ib);\n        }\n        else\n        {\n            if (TR != ib)\n            {\n                ii = memloc(halowidth, blkmemwidth, XParam.blkwidth, 0, TR);\n            }\n            else\n            {\n                ii = memloc(halowidth, blkmemwidth, 0, XParam.blkwidth, RT);\n            }\n\n        }\n        z[iout] = z[ii];\n\n    }\n    if (ix == 3)\n    {\n        // Bot right corner\n        iout = memloc(halowidth, blkmemwidth, XParam.blkwidth, -1, ib);\n        if (BR == ib &amp;&amp; RB == ib)//\n        {\n            ii = memloc(halowidth, blkmemwidth, XParam.blkwidth - 1, 0, ib);\n        }\n        else\n        {\n            if (BR != ib)\n            {\n                ii = memloc(halowidth, blkmemwidth, XParam.blkwidth, XParam.blkwidth - 1, BR);\n            }\n            else\n            {\n                ii = memloc(halowidth, blkmemwidth, 0, -1, RB);\n            }\n\n        }\n        z[iout] = z[ii];\n    }\n\n}\ntemplate __global__ void fillCornersGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z);\ntemplate __global__ void fillCornersGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z);\n</code></pre>"},{"location":"BGFlood/Halo_8h/","title":"File Halo.h","text":""},{"location":"BGFlood/Halo_8h/#file-haloh","title":"File Halo.h","text":"<p>FileList &gt; src &gt; Halo.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Mesh.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Boundary.h\"</code></li> <li><code>#include \"ConserveElevation.h\"</code></li> </ul>"},{"location":"BGFlood/Halo_8h/#public-functions","title":"Public Functions","text":"Type Name __global__ void HaloFluxGPUBT (Param XParam, BlockP&lt; T &gt; XBlock, T * z)  __global__ void HaloFluxGPUBTnew (Param XParam, BlockP&lt; T &gt; XBlock, T * z)  __global__ void HaloFluxGPULR (Param XParam, BlockP&lt; T &gt; XBlock, T * z)  __global__ void HaloFluxGPULRnew (Param XParam, BlockP&lt; T &gt; XBlock, T * z)  void RecalculateZs (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) Recalculate water surface after recalculating the values on the halo on the CPU. __global__ void RecalculateZsGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  void Recalculatehh (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  void bndmaskGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, FluxP&lt; T &gt; Flux)  void fillBot (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z)  __global__ void fillBot (int halowidth, int * active, int * level, int * botleft, int * botright, int * topleft, int * lefttop, int * righttop, T * a)  __global__ void fillBotnew (int halowidth, int nblk, int * active, int * level, int * botleft, int * botright, int * topleft, int * lefttop, int * righttop, T * a)  void fillCorners (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z)  void fillCorners (Param XParam, BlockP&lt; T &gt; XBlock, T *&amp; z)  void fillCorners (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; &amp; Xev)  __global__ void fillCornersGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z)  void fillHalo (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  void fillHalo (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev)  void fillHalo (Param XParam, BlockP&lt; T &gt; XBlock, GradientsP&lt; T &gt; Grad)  void fillHalo (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux)  void fillHaloC (Param XParam, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating halos for each block of a single variable on CPU. void fillHaloF (Param XParam, bool doProlongation, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating flux in the halos for a block and a single variable on CPU. void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z) Wrapping function for calculating halos for each block of a single variable on GPU. void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z)  void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev)  void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, GradientsP&lt; T &gt; Grad)  void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux)  void fillHaloGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z)  void fillHaloTopRightC (Param XParam, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating flux for halos for each block of a single variable on GPU. void fillHaloTopRightGPU (Param XParam, bool doprolong, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z)  void fillLeft (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z)  __global__ void fillLeft (int halowidth, int * active, int * level, int * leftbot, int * lefttop, int * rightbot, int * botright, int * topright, T * a)  __global__ void fillLeftnew (int halowidth, int nblk, int * active, int * level, int * leftbot, int * lefttop, int * rightbot, int * botright, int * topright, T * a)  void fillRight (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z)  __global__ void fillRight (int halowidth, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, T * a)  void fillRightFlux (Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z)  __global__ void fillRightFlux (int halowidth, bool doProlongation, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, T * a)  __global__ void fillRightnew (int halowidth, int nblk, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, T * a)  void fillTop (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z)  __global__ void fillTop (int halowidth, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, T * a)  void fillTopFlux (Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z)  __global__ void fillTopFlux (int halowidth, bool doProlongation, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, T * a)  __global__ void fillTopnew (int halowidth, int nblk, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, T * a)  void refine_linear (Param XParam, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy)  void refine_linearGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy)  void refine_linear_Bot (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z, T * dzdy)  void refine_linear_Left (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy)  void refine_linear_Right (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z, T * dzdx)  void refine_linear_Top (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z, T * dzdy)"},{"location":"BGFlood/Halo_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Halo_8h/#function-halofluxgpubt","title":"function HaloFluxGPUBT","text":"<pre><code>template&lt;class T&gt;\n__global__ void HaloFluxGPUBT (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-halofluxgpubtnew","title":"function HaloFluxGPUBTnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void HaloFluxGPUBTnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-halofluxgpulr","title":"function HaloFluxGPULR","text":"<pre><code>template&lt;class T&gt;\n__global__ void HaloFluxGPULR (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-halofluxgpulrnew","title":"function HaloFluxGPULRnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void HaloFluxGPULRnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-recalculatezs","title":"function RecalculateZs","text":"<p>Recalculate water surface after recalculating the values on the halo on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid RecalculateZs (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre> <p>Recalculate water surface after recalculating the values on the halo on the GPU.</p>"},{"location":"BGFlood/Halo_8h/#description","title":"Description","text":"<p>Recalculate water surface after recalculating the values on the halo on the CPU. zb (bottom elevation) on each halo is calculated at the start of the loop or as part of the initial condition. When conserve-elevation is not required, only h is recalculated on the halo at ever 1/2 steps.   zs then needs to be recalculated to obtain a mass-conservative solution (if zs is conserved then mass conservation is not garanteed)</p>"},{"location":"BGFlood/Halo_8h/#warning","title":"Warning","text":"<p>This function calculate zs everywhere in the block... this is a bit unecessary. Instead it should recalculate only where there is a prolongation or a restiction</p>"},{"location":"BGFlood/Halo_8h/#description_1","title":"Description","text":"<p>Recalculate water surface after recalculating the values on the halo on the CPU. zb (bottom elevation) on each halo is calculated at the start of the loop or as part of the initial condition. When conserve-elevation is not required, only h is recalculated on the halo at ever 1/2 steps. zs then needs to be recalculated to obtain a mass-conservative solution (if zs is conserved then mass conservation is not garanteed)</p>"},{"location":"BGFlood/Halo_8h/#warning_1","title":"Warning","text":"<p>This function calculate zs everywhere in the block... this is a bit unecessary. Instead it should recalculate only where there is a prolongation or a restiction </p>"},{"location":"BGFlood/Halo_8h/#function-recalculatezsgpu","title":"function RecalculateZsGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void RecalculateZsGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-recalculatehh","title":"function Recalculatehh","text":"<pre><code>template&lt;class T&gt;\nvoid Recalculatehh (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-bndmaskgpu","title":"function bndmaskGPU","text":"<pre><code>template&lt;class T&gt;\nvoid bndmaskGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillbot","title":"function fillBot","text":"<pre><code>template&lt;class T&gt;\nvoid fillBot (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillbot_1","title":"function fillBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillBot (\n    int halowidth,\n    int * active,\n    int * level,\n    int * botleft,\n    int * botright,\n    int * topleft,\n    int * lefttop,\n    int * righttop,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillbotnew","title":"function fillBotnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillBotnew (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * botleft,\n    int * botright,\n    int * topleft,\n    int * lefttop,\n    int * righttop,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillcorners","title":"function fillCorners","text":"<pre><code>template&lt;class T&gt;\nvoid fillCorners (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillcorners_1","title":"function fillCorners","text":"<pre><code>template&lt;class T&gt;\nvoid fillCorners (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillcorners_2","title":"function fillCorners","text":"<pre><code>template&lt;class T&gt;\nvoid fillCorners (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; &amp; Xev\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillcornersgpu","title":"function fillCornersGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillCornersGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillhalo","title":"function fillHalo","text":"<pre><code>template&lt;class T&gt;\nvoid fillHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillhalo_1","title":"function fillHalo","text":"<pre><code>template&lt;class T&gt;\nvoid fillHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillhalo_2","title":"function fillHalo","text":"<pre><code>template&lt;class T&gt;\nvoid fillHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    GradientsP &lt; T &gt; Grad\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillhalo_3","title":"function fillHalo","text":"<pre><code>template&lt;class T&gt;\nvoid fillHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillhaloc","title":"function fillHaloC","text":"<p>Wrapping function for calculating halos for each block of a single variable on CPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloC (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#description_2","title":"Description","text":"<p>This function is a wraping fuction of the halo functions on CPU. It is called from the main Halo CPU function. This is layer 2 of 3 wrap so the candy doesn't stick too much. </p>"},{"location":"BGFlood/Halo_8h/#function-fillhalof","title":"function fillHaloF","text":"<p>Wrapping function for calculating flux in the halos for a block and a single variable on CPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloF (\n    Param XParam,\n    bool doProlongation,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#depreciated","title":"Depreciated","text":"<p>This function is was never sucessful and will never be used. It is fundamentally flawed because is doesn't preserve the balance of fluxes on the restiction interface It should be deleted soon </p>"},{"location":"BGFlood/Halo_8h/#description_3","title":"Description","text":""},{"location":"BGFlood/Halo_8h/#function-fillhalogpu","title":"function fillHaloGPU","text":"<p>Wrapping function for calculating halos for each block of a single variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#description_4","title":"Description","text":"<p>This function is a wraping fuction of the halo functions on GPU. It is called from the main Halo GPU function. The present imnplementation is naive and slow one that calls the rather complex fillLeft type functions </p>"},{"location":"BGFlood/Halo_8h/#function-fillhalogpu_1","title":"function fillHaloGPU","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillhalogpu_2","title":"function fillHaloGPU","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillhalogpu_3","title":"function fillHaloGPU","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillhalogpu_4","title":"function fillHaloGPU","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    GradientsP &lt; T &gt; Grad\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillhalogpu_5","title":"function fillHaloGPU","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillhalogpunew","title":"function fillHaloGPUnew","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillhalotoprightc","title":"function fillHaloTopRightC","text":"<p>Wrapping function for calculating flux for halos for each block of a single variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloTopRightC (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#description_5","title":"Description","text":"<p>This function is a wraping function of the halo flux functions on GPU. It is called from the main Halo GPU function. The present imnplementation is naive and slow one that calls the rather complex fillLeft type functions </p>"},{"location":"BGFlood/Halo_8h/#function-fillhalotoprightgpu","title":"function fillHaloTopRightGPU","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloTopRightGPU (\n    Param XParam,\n    bool doprolong,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillleft","title":"function fillLeft","text":"<pre><code>template&lt;class T&gt;\nvoid fillLeft (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillleft_1","title":"function fillLeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillLeft (\n    int halowidth,\n    int * active,\n    int * level,\n    int * leftbot,\n    int * lefttop,\n    int * rightbot,\n    int * botright,\n    int * topright,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillleftnew","title":"function fillLeftnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillLeftnew (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * leftbot,\n    int * lefttop,\n    int * rightbot,\n    int * botright,\n    int * topright,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillright","title":"function fillRight","text":"<pre><code>template&lt;class T&gt;\nvoid fillRight (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillright_1","title":"function fillRight","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillRight (\n    int halowidth,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillrightflux","title":"function fillRightFlux","text":"<pre><code>template&lt;class T&gt;\nvoid fillRightFlux (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillrightflux_1","title":"function fillRightFlux","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillRightFlux (\n    int halowidth,\n    bool doProlongation,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-fillrightnew","title":"function fillRightnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillRightnew (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-filltop","title":"function fillTop","text":"<pre><code>template&lt;class T&gt;\nvoid fillTop (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-filltop_1","title":"function fillTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillTop (\n    int halowidth,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-filltopflux","title":"function fillTopFlux","text":"<pre><code>template&lt;class T&gt;\nvoid fillTopFlux (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-filltopflux_1","title":"function fillTopFlux","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillTopFlux (\n    int halowidth,\n    bool doProlongation,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-filltopnew","title":"function fillTopnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillTopnew (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-refine_linear","title":"function refine_linear","text":"<pre><code>template&lt;class T&gt;\nvoid refine_linear (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-refine_lineargpu","title":"function refine_linearGPU","text":"<pre><code>template&lt;class T&gt;\nvoid refine_linearGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-refine_linear_bot","title":"function refine_linear_Bot","text":"<pre><code>template&lt;class T&gt;\nvoid refine_linear_Bot (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-refine_linear_left","title":"function refine_linear_Left","text":"<pre><code>template&lt;class T&gt;\nvoid refine_linear_Left (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-refine_linear_right","title":"function refine_linear_Right","text":"<pre><code>template&lt;class T&gt;\nvoid refine_linear_Right (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx\n) \n</code></pre>"},{"location":"BGFlood/Halo_8h/#function-refine_linear_top","title":"function refine_linear_Top","text":"<pre><code>template&lt;class T&gt;\nvoid refine_linear_Top (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdy\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Halo.h</code></p>"},{"location":"BGFlood/Halo_8h_source/","title":"File Halo.h","text":""},{"location":"BGFlood/Halo_8h_source/#file-haloh","title":"File Halo.h","text":"<p>File List &gt; src &gt; Halo.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef HALO_H\n#define HALO_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"Mesh.h\"\n#include \"MemManagement.h\"\n#include \"Boundary.h\"\n#include \"ConserveElevation.h\"\n\ntemplate &lt;class T&gt; void fillHaloC(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\ntemplate &lt;class T&gt; void fillHaloF(Param XParam, bool doProlongation, BlockP&lt;T&gt; XBlock, T* z);\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z);\ntemplate &lt;class T&gt; void fillHaloGPUnew(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z);\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\n\ntemplate &lt;class T&gt; void fillHalo(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev,T*zb);\ntemplate &lt;class T&gt; void fillHalo(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev);\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev);\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\n\ntemplate &lt;class T&gt; void fillHalo(Param XParam, BlockP&lt;T&gt; XBlock, GradientsP&lt;T&gt; Grad);\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, GradientsP&lt;T&gt; Grad);\n\ntemplate &lt;class T&gt; void fillHalo(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux);\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux);\n\ntemplate &lt;class T&gt; void fillHaloTopRightC(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\ntemplate &lt;class T&gt; void fillHaloTopRightGPU(Param XParam, bool doprolong, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z);\n\ntemplate &lt;class T&gt; void bndmaskGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, FluxP&lt;T&gt; Flux);\n\ntemplate &lt;class T&gt; void fillLeft(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z);\ntemplate &lt;class T&gt; void fillRight(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z);\ntemplate &lt;class T&gt; void fillBot(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z);\ntemplate &lt;class T&gt; void fillTop(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z);\n\ntemplate &lt;class T&gt; void fillTopFlux(Param XParam, bool doProlongation, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z);\ntemplate &lt;class T&gt; void fillRightFlux(Param XParam, bool doProlongation, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z);\n\ntemplate &lt;class T&gt; void fillCorners(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z);\n\ntemplate &lt;class T&gt; void fillCorners(Param XParam, BlockP&lt;T&gt; XBlock, T*&amp; z);\ntemplate &lt;class T&gt; void fillCorners(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt;&amp; Xev);\n\ntemplate &lt;class T&gt; void RecalculateZs(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\ntemplate &lt;class T&gt; __global__ void RecalculateZsGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\n\ntemplate &lt;class T&gt; void Recalculatehh(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\n\ntemplate &lt;class T&gt; void refine_linear(Param XParam, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy);\ntemplate &lt;class T&gt; void refine_linearGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy);\n\ntemplate &lt;class T&gt; void refine_linear_Left(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy);\ntemplate &lt;class T&gt; void refine_linear_Top(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z, T* dzdy);\ntemplate &lt;class T&gt; void refine_linear_Bot(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z, T* dzdy);\ntemplate &lt;class T&gt; void refine_linear_Right(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z, T* dzdx);\n\n// GPU versions\ntemplate &lt;class T&gt; __global__ void fillLeft(int halowidth, int* active, int* level, int* leftbot, int* lefttop, int* rightbot, int* botright, int* topright, T* a);\ntemplate &lt;class T&gt; __global__ void fillRight(int halowidth, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, T* a);\ntemplate &lt;class T&gt; __global__ void fillBot(int halowidth, int* active, int* level, int* botleft, int* botright, int* topleft, int* lefttop, int* righttop, T* a);\ntemplate &lt;class T&gt; __global__ void fillTop(int halowidth, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, T* a);\n\ntemplate &lt;class T&gt; __global__ void fillLeftnew(int halowidth, int nblk, int* active, int* level, int* leftbot, int* lefttop, int* rightbot, int* botright, int* topright, T* a);\ntemplate &lt;class T&gt; __global__ void fillRightnew(int halowidth, int nblk, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, T* a);\ntemplate &lt;class T&gt; __global__ void fillBotnew(int halowidth, int nblk, int* active, int* level, int* botleft, int* botright, int* topleft, int* lefttop, int* righttop, T* a);\ntemplate &lt;class T&gt; __global__ void fillTopnew(int halowidth, int nblk, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, T* a);\n\ntemplate &lt;class T&gt; __global__ void fillTopFlux(int halowidth, bool doProlongation, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, T* a);\ntemplate &lt;class T&gt; __global__ void fillRightFlux(int halowidth, bool doProlongation, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, T* a);\n\n\ntemplate &lt;class T&gt; __global__  void HaloFluxGPULR(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\ntemplate &lt;class T&gt; __global__ void HaloFluxGPUBT(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\n\ntemplate &lt;class T&gt; __global__  void HaloFluxGPULRnew(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\ntemplate &lt;class T&gt; __global__ void HaloFluxGPUBTnew(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\n\ntemplate &lt;class T&gt; __global__ void fillCornersGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/InitEvolv_8cu/","title":"File InitEvolv.cu","text":""},{"location":"BGFlood/InitEvolv_8cu/#file-initevolvcu","title":"File InitEvolv.cu","text":"<p>FileList &gt; src &gt; InitEvolv.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"InitEvolv.h\"</code></li> </ul>"},{"location":"BGFlood/InitEvolv_8cu/#public-functions","title":"Public Functions","text":"Type Name int AddZSoffset (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; &amp; XEv, T * zb)  int coldstart (Param XParam, BlockP&lt; T &gt; XBlock, T * zb, EvolvingP&lt; T &gt; &amp; XEv)  void initevolv (Param XParam, BlockP&lt; T &gt; XBlock, Forcing&lt; float &gt; XForcing, EvolvingP&lt; T &gt; &amp; XEv, T *&amp; zb)  template void initevolv&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, Forcing&lt; float &gt; XForcing, EvolvingP&lt; double &gt; &amp; XEv, double *&amp; zb)  template void initevolv&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, Forcing&lt; float &gt; XForcing, EvolvingP&lt; float &gt; &amp; XEv, float *&amp; zb)  int readhotstartfile (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; &amp; XEv, T *&amp; zb)  template int readhotstartfile&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; &amp; XEv, double *&amp; zb)  template int readhotstartfile&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; &amp; XEv, float *&amp; zb)  int readhotstartfileBG (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; &amp; XEv, T *&amp; zb)  void warmstart (Param XParam, Forcing&lt; float &gt; XForcing, BlockP&lt; T &gt; XBlock, T * zb, EvolvingP&lt; T &gt; &amp; XEv)  void warmstartold (Param XParam, Forcing&lt; float &gt; XForcing, BlockP&lt; T &gt; XBlock, T * zb, EvolvingP&lt; T &gt; &amp; XEv)"},{"location":"BGFlood/InitEvolv_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/InitEvolv_8cu/#function-addzsoffset","title":"function AddZSoffset","text":"<pre><code>template&lt;class T&gt;\nint AddZSoffset (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; &amp; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/InitEvolv_8cu/#function-coldstart","title":"function coldstart","text":"<pre><code>template&lt;class T&gt;\nint coldstart (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * zb,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/InitEvolv_8cu/#function-initevolv","title":"function initevolv","text":"<pre><code>template&lt;class T&gt;\nvoid initevolv (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    Forcing &lt; float &gt; XForcing,\n    EvolvingP &lt; T &gt; &amp; XEv,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/InitEvolv_8cu/#function-initevolv-double","title":"function initevolv&lt; double &gt;","text":"<pre><code>template void initevolv&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    Forcing &lt; float &gt; XForcing,\n    EvolvingP &lt; double &gt; &amp; XEv,\n    double *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/InitEvolv_8cu/#function-initevolv-float","title":"function initevolv&lt; float &gt;","text":"<pre><code>template void initevolv&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    Forcing &lt; float &gt; XForcing,\n    EvolvingP &lt; float &gt; &amp; XEv,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/InitEvolv_8cu/#function-readhotstartfile","title":"function readhotstartfile","text":"<pre><code>template&lt;class T&gt;\nint readhotstartfile (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; &amp; XEv,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/InitEvolv_8cu/#function-readhotstartfile-double","title":"function readhotstartfile&lt; double &gt;","text":"<pre><code>template int readhotstartfile&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; &amp; XEv,\n    double *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/InitEvolv_8cu/#function-readhotstartfile-float","title":"function readhotstartfile&lt; float &gt;","text":"<pre><code>template int readhotstartfile&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; &amp; XEv,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/InitEvolv_8cu/#function-readhotstartfilebg","title":"function readhotstartfileBG","text":"<pre><code>template&lt;class T&gt;\nint readhotstartfileBG (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; &amp; XEv,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/InitEvolv_8cu/#function-warmstart","title":"function warmstart","text":"<pre><code>template&lt;class T&gt;\nvoid warmstart (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    BlockP &lt; T &gt; XBlock,\n    T * zb,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/InitEvolv_8cu/#function-warmstartold","title":"function warmstartold","text":"<pre><code>template&lt;class T&gt;\nvoid warmstartold (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    BlockP &lt; T &gt; XBlock,\n    T * zb,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/InitEvolv.cu</code></p>"},{"location":"BGFlood/InitEvolv_8cu_source/","title":"File InitEvolv.cu","text":""},{"location":"BGFlood/InitEvolv_8cu_source/#file-initevolvcu","title":"File InitEvolv.cu","text":"<p>File List &gt; src &gt; InitEvolv.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //    \n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n\n#include \"InitEvolv.h\"\n\ntemplate &lt;class T&gt; void initevolv(Param XParam, BlockP&lt;T&gt; XBlock,Forcing&lt;float&gt; XForcing, EvolvingP&lt;T&gt; &amp;XEv,T* &amp;zb)\n{\n    //move this to a subroutine\n    int hotstartsucess = 0;\n    if (!XParam.hotstartfile.empty())\n    {\n        // hotstart\n        log(\"\\tHotstart file used : \" + XParam.hotstartfile);\n\n        hotstartsucess = readhotstartfile(XParam, XBlock, XEv, zb);\n\n        //add offset if present\n        if (T(XParam.zsoffset) != T(0.0)) // apply specified zsoffset\n        {\n            printf(\"\\t\\tadd offset to zs and hh... \");\n            //\n            AddZSoffset(XParam, XBlock, XEv, zb);\n\n        }\n\n\n        if (hotstartsucess == 0)\n        {\n            printf(\"\\t\\tFailed...  \");\n            write_text_to_log_file(\"\\tHotstart failed switching to cold start\");\n        }\n    }\n\n\n\n    if (XParam.hotstartfile.empty() || hotstartsucess == 0)\n    {\n        //printf(\"Cold start  \");\n        //log(\"Cold start\");\n        //Cold start\n        // 2 options:\n        //      (1) if zsinit is set, then apply zsinit everywhere\n        //      (2) zsinit is not set so interpolate from boundaries. (if no boundaries were specified set zsinit to zeros and apply case (1))\n\n        //Param defaultParam;\n\n        //case 0 (i.e. zsinint not specified by user and no boundaries were specified)\n        bool bndison = false;\n        for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n        {\n            if (XForcing.bndseg[iseg].on)\n            {\n                bndison = true;\n            }\n        }\n\n\n\n        if (std::isnan(XParam.zsinit) &amp;&amp; (!bndison)) //zsinit is default\n        {\n            XParam.zsinit = 0.0; // better default value than nan\n        }\n\n        //case 1 cold start\n\n        if (!std::isnan(XParam.zsinit)) // apply specified zsinit\n        {\n            log(\"\\tCold start\");\n            int coldstartsucess = 0;\n            coldstartsucess = coldstart(XParam, XBlock, zb, XEv);\n\n        }\n        // case 2 warm start\n        else // lukewarm start i.e. inv. dist interpolation of zs at bnds // Argggh!\n        {\n            log(\"\\tWarm start\");\n            warmstart(XParam, XForcing, XBlock, zb, XEv);\n\n        }// end else\n\n    }\n}\ntemplate void initevolv&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, Forcing&lt;float&gt; XForcing, EvolvingP&lt;float&gt; &amp;XEv, float* &amp;zb);\ntemplate void initevolv&lt;double&gt;(Param XParam, BlockP&lt; double &gt; XBlock, Forcing&lt;float&gt; XForcing, EvolvingP&lt; double &gt; &amp;XEv, double* &amp;zb);\n\n\ntemplate &lt;class T&gt;\nint coldstart(Param XParam, BlockP&lt;T&gt; XBlock, T* zb, EvolvingP&lt;T&gt; &amp; XEv)\n{\n    T zzini = std::isnan(XParam.zsinit)? T(0.0): T(XParam.zsinit);\n    T zzoffset = T(XParam.zsoffset);\n\n\n\n    int coldstartsucess = 0;\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n\n                XEv.u[n] = T(0.0);\n                XEv.v[n] = T(0.0);\n                //zb[n] = 0.0f;\n                XEv.zs[n] = utils::max(zzini + zzoffset, zb[n]);\n\n                //if (i &gt;= 64 &amp;&amp; i &lt; 82)\n                //{\n                //  zs[n] = max(zsbnd+0.2f, zb[i + j*nx]);\n                //}\n                XEv.h[n] = utils::max(XEv.zs[n] - zb[n], T(0.0));//0.0 or XParam.eps ??\n            }\n        }\n    }\n\n    coldstartsucess = 1;\n    return coldstartsucess;\n}\n\ntemplate &lt;class T&gt;\nvoid warmstart(Param XParam, Forcing&lt;float&gt; XForcing, BlockP&lt;T&gt; XBlock, T* zb, EvolvingP&lt;T&gt;&amp; XEv)\n{\n    int nuni=0;\n    int ndyn=0;\n\n    T zsbnduni=T(0.0);\n    T zsbnd;\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n        if (XForcing.bndseg[iseg].on)\n        {\n            if (XForcing.bndseg[iseg].uniform)\n            {\n                nuni++;\n\n                int SLstepinbnd = 1;\n\n                double difft = XForcing.bndseg[iseg].data[SLstepinbnd].time - XParam.totaltime;\n                while (difft &lt; 0.0)\n                {\n                    SLstepinbnd++;\n                    difft = XForcing.bndseg[iseg].data[SLstepinbnd].time - XParam.totaltime;\n                }\n\n                //itime = SLstepinbnd - 1.0 + (totaltime - bndseg.data[SLstepinbnd - 1].time) / (bndseg.data[SLstepinbnd].time - bndseg.data[SLstepinbnd - 1].time);\n                zsbnduni = zsbnduni + interptime(XForcing.bndseg[iseg].data[SLstepinbnd].wspeed, XForcing.bndseg[iseg].data[SLstepinbnd - 1].wspeed, XForcing.bndseg[iseg].data[SLstepinbnd].time - XForcing.bndseg[iseg].data[SLstepinbnd - 1].time, XParam.totaltime - XForcing.bndseg[iseg].data[SLstepinbnd - 1].time);\n\n            }\n            else\n            {\n                ndyn++;\n                Forcingthisstep(XParam, XParam.totaltime, XForcing.bndseg[iseg].WLmap);\n            }\n        }\n    }\n    if (nuni &gt; 0)\n    {\n        zsbnduni = zsbnduni / nuni;\n    }\n\n    int ib;\n    double xi, yi;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n\n                double levdx = calcres(XParam.dx, XBlock.level[ib]);\n                xi = XParam.xo + XBlock.xo[ib] + i * levdx;\n                yi = XParam.yo + XBlock.yo[ib] + j * levdx;\n\n                zsbnd = zsbnduni;\n\n                if (ndyn &gt; 0)\n                {\n                    zsbnd = zsbnduni * nuni;\n\n                    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n                    {\n                        if (XForcing.bndseg[iseg].on &amp;&amp; !XForcing.bndseg[iseg].uniform)\n                        {\n                            //\n                            zsbnd = zsbnd + float(interp2BUQ(xi, yi, XForcing.bndseg[iseg].WLmap));\n                        }\n                    }\n\n                    zsbnd = zsbnd / (nuni + ndyn);\n                }\n\n                if (XParam.atmpforcing)\n                {\n                    float atmpi;\n\n                    if (XForcing.Atmp.uniform)\n                    {\n                        atmpi = float(XForcing.Atmp.nowvalue);\n                    }\n                    else\n                    {\n                        atmpi = float(interp2BUQ(xi, yi, XForcing.Atmp));\n                    }\n                    zsbnd = zsbnd - (atmpi - (T)XParam.Paref) * (T)XParam.Pa2m;\n                }\n\n                XEv.zs[n] = utils::max(zsbnd, zb[n]);\n                XEv.h[n] = utils::max(XEv.zs[n] - zb[n], T(0.0));\n                XEv.u[n] = T(0.0);\n                XEv.v[n] = T(0.0);\n            }\n        }\n    }\n\n}\n\n\ntemplate &lt;class T&gt;\nvoid warmstartold(Param XParam,Forcing&lt;float&gt; XForcing, BlockP&lt;T&gt; XBlock, T* zb, EvolvingP&lt;T&gt;&amp; XEv)\n{\n    // This function read water level boundary if they have been setup and calculate the distance to the boundary \n    // toward the end the water level value is calculated as an inverse distance to the available boundaries.\n    // While this may look convoluted its working quite simply.\n    // look for each boundary side and calculate the closest water level value and the distance to that value\n\n    double zsleft = 0.0;\n    double zsright = 0.0;\n    double zstop = 0.0;\n    double zsbot = 0.0;\n    T zsbnd = 0.0;\n\n    double distleft, distright, disttop, distbot;\n\n    double lefthere = 0.0;\n    double righthere = 0.0;\n    double tophere = 0.0;\n    double bothere = 0.0;\n\n    double xi, yi, jj, ii;\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n\n                double levdx = calcres(XParam.dx, XBlock.level[ib]);\n                xi = XParam.xo + XBlock.xo[ib] + i * levdx;\n                yi = XParam.yo + XBlock.yo[ib] + j * levdx;\n\n                disttop = max((XParam.ymax - yi) / levdx, 0.1);//max((double)(ny - 1) - j, 0.1);// WTF is that 0.1? // distleft cannot be 0 //theoretical minumun is 0.5?\n                distbot = max((yi - XParam.yo) / levdx, 0.1);\n                distleft = max((xi - XParam.xo) / levdx, 0.1);//max((double)i, 0.1);\n                distright = max((XParam.xmax - xi) / levdx, 0.1);//max((double)(nx - 1) - i, 0.1);\n\n                jj = (yi - XParam.yo) / (XParam.ymax - XParam.yo);\n                ii = (xi - XParam.xo) / (XParam.xmax - XParam.xo);\n\n                if (XForcing.left.on)\n                {\n                    lefthere = 1.0;\n                    int SLstepinbnd = 1;\n\n\n\n                    // Do this for all the corners\n                    //Needs limiter in case WLbnd is empty\n                    double difft = XForcing.left.data[SLstepinbnd].time - XParam.totaltime;\n\n                    while (difft &lt; 0.0)\n                    {\n                        SLstepinbnd++;\n                        difft = XForcing.left.data[SLstepinbnd].time - XParam.totaltime;\n                    }\n                    std::vector&lt;double&gt; zsbndvec;\n                    for (int k = 0; k &lt; XForcing.left.data[SLstepinbnd].wlevs.size(); k++)\n                    {\n                        zsbndvec.push_back(interptime(XForcing.left.data[SLstepinbnd].wlevs[k], XForcing.left.data[SLstepinbnd - 1].wlevs[k], XForcing.left.data[SLstepinbnd].time - XForcing.left.data[SLstepinbnd - 1].time, XParam.totaltime - XForcing.left.data[SLstepinbnd - 1].time));\n\n                    }\n                    if (zsbndvec.size() == 1)\n                    {\n                        zsleft = zsbndvec[0];\n                    }\n                    else\n                    {\n                        int iprev = utils::min(utils::max((int)floor(jj * (zsbndvec.size() - 1)), 0), (int)zsbndvec.size() - 2);\n                        int inext = iprev + 1;\n                        // here interp time is used to interpolate to the right node rather than in time...\n                        zsleft = interptime(zsbndvec[inext], zsbndvec[iprev], 1.0, (double)(jj * (zsbndvec.size() - 1) - iprev));\n                    }\n\n                }\n\n                if (XForcing.right.on)\n                {\n                    int SLstepinbnd = 1;\n                    righthere = 1.0;\n\n\n                    // Do this for all the corners\n                    //Needs limiter in case WLbnd is empty\n                    double difft = XForcing.right.data[SLstepinbnd].time - XParam.totaltime;\n\n                    while (difft &lt; 0.0)\n                    {\n                        SLstepinbnd++;\n                        difft = XForcing.right.data[SLstepinbnd].time - XParam.totaltime;\n                    }\n                    std::vector&lt;double&gt; zsbndvec;\n                    for (int k = 0; k &lt; XForcing.right.data[SLstepinbnd].wlevs.size(); k++)\n                    {\n                        zsbndvec.push_back(interptime(XForcing.right.data[SLstepinbnd].wlevs[k], XForcing.right.data[SLstepinbnd - 1].wlevs[k], XForcing.right.data[SLstepinbnd].time - XForcing.right.data[SLstepinbnd - 1].time, XParam.totaltime - XForcing.right.data[SLstepinbnd - 1].time));\n\n                    }\n                    if (zsbndvec.size() == 1)\n                    {\n                        zsright = zsbndvec[0];\n                    }\n                    else\n                    {\n                        int iprev = utils::min(utils::max((int)floor(jj * (zsbndvec.size() - 1)), 0), (int)zsbndvec.size() - 2);\n                        int inext = iprev + 1;\n                        // here interp time is used to interpolate to the right node rather than in time...\n                        zsright = interptime(zsbndvec[inext], zsbndvec[iprev], 1.0, (double)(jj * (zsbndvec.size() - 1) - iprev));\n                    }\n\n\n                }\n                if (XForcing.bot.on)\n                {\n                    int SLstepinbnd = 1;\n                    bothere = 1.0;\n\n\n\n\n                    // Do this for all the corners\n                    //Needs limiter in case WLbnd is empty\n                    double difft = XForcing.bot.data[SLstepinbnd].time - XParam.totaltime;\n\n                    while (difft &lt; 0.0)\n                    {\n                        SLstepinbnd++;\n                        difft = XForcing.bot.data[SLstepinbnd].time - XParam.totaltime;\n                    }\n                    std::vector&lt;double&gt; zsbndvec;\n                    for (int k = 0; k &lt; XForcing.bot.data[SLstepinbnd].wlevs.size(); k++)\n                    {\n                        zsbndvec.push_back(interptime(XForcing.bot.data[SLstepinbnd].wlevs[k], XForcing.bot.data[SLstepinbnd - 1].wlevs[k], XForcing.bot.data[SLstepinbnd].time - XForcing.bot.data[SLstepinbnd - 1].time, XParam.totaltime - XForcing.bot.data[SLstepinbnd - 1].time));\n\n                    }\n                    if (zsbndvec.size() == 1)\n                    {\n                        zsbot = zsbndvec[0];\n                    }\n                    else\n                    {\n                        int iprev = utils::min(utils::max((int)floor(ii * (zsbndvec.size() - 1)), 0), (int)zsbndvec.size() - 2);\n                        int inext = iprev + 1;\n                        // here interp time is used to interpolate to the right node rather than in time...\n                        zsbot = interptime(zsbndvec[inext], zsbndvec[iprev], 1.0, (double)(ii * (zsbndvec.size() - 1) - iprev));\n                    }\n\n                }\n                if (XForcing.top.on)\n                {\n                    int SLstepinbnd = 1;\n                    tophere = 1.0;\n\n\n\n\n                    // Do this for all the corners\n                    //Needs limiter in case WLbnd is empty\n                    double difft = XForcing.top.data[SLstepinbnd].time - XParam.totaltime;\n\n                    while (difft &lt; 0.0)\n                    {\n                        SLstepinbnd++;\n                        difft = XForcing.top.data[SLstepinbnd].time - XParam.totaltime;\n                    }\n                    std::vector&lt;double&gt; zsbndvec;\n                    for (int k= 0; k &lt; XForcing.top.data[SLstepinbnd].wlevs.size(); k++)\n                    {\n                        zsbndvec.push_back(interptime(XForcing.top.data[SLstepinbnd].wlevs[k], XForcing.top.data[SLstepinbnd - 1].wlevs[k], XForcing.top.data[SLstepinbnd].time - XForcing.top.data[SLstepinbnd - 1].time, XParam.totaltime - XForcing.top.data[SLstepinbnd - 1].time));\n\n                    }\n                    if (zsbndvec.size() == 1)\n                    {\n                        zstop = zsbndvec[0];\n                    }\n                    else\n                    {\n                        int iprev = utils::min(utils::max((int)floor(ii * (zsbndvec.size() - 1)), 0), (int)zsbndvec.size() - 2);\n                        int inext = iprev + 1;\n                        // here interp time is used to interpolate to the right node rather than in time...\n                        zstop = interptime(zsbndvec[inext], zsbndvec[iprev], 1.0, (double)(ii * (zsbndvec.size() - 1) - iprev));\n                    }\n\n                }\n\n\n                zsbnd = T(((zsleft / distleft) * lefthere + (zsright / distright) * righthere + (zstop / disttop) * tophere + (zsbot / distbot) * bothere) / ((1.0 / distleft) * lefthere + (1.0 / distright) * righthere + (1.0 / disttop) * tophere + (1.0 / distbot) * bothere));\n\n                if (XParam.atmpforcing)\n                {\n                    float atmpi;\n\n                    if (XForcing.Atmp.uniform)\n                    {\n                        atmpi = float(XForcing.Atmp.nowvalue);\n                    }\n                    else\n                    {\n                        atmpi = float(interp2BUQ(xi, yi, XForcing.Atmp));\n                    }\n                    zsbnd = zsbnd - (atmpi- (T)XParam.Paref) * (T)XParam.Pa2m;\n                }\n\n                XEv.zs[n] = utils::max(zsbnd, zb[n]);\n                XEv.h[n] = utils::max(XEv.zs[n] - zb[n], T(0.0));\n                XEv.u[n] = T(0.0);\n                XEv.v[n] = T(0.0);\n\n\n\n            }\n        }\n    }\n}\n\n\ntemplate &lt;class T&gt;\nint AddZSoffset(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; &amp;XEv, T*zb)\n{\n    int success = 1;\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = memloc(XParam, i, j, ib);\n\n                if (XEv.h[n] &gt; XParam.eps)\n                {\n\n                    XEv.zs[n] = max(XEv.zs[n] + T(XParam.zsoffset), zb[n]);\n\n                    XEv.h[n] = utils::max(XEv.zs[n] - zb[n], T(0.0));\n                }\n            }\n\n        }\n    }\n\n    return success;\n}\n\n\ntemplate &lt;class T&gt;\nint readhotstartfileBG(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt;&amp; XEv, T*&amp; zb)\n{\n    int status;\n    int ncid;\n    //int dimids[NC_MAX_VAR_DIMS];   // dimension IDs \n    int ib;\n    //double scalefac = 1.0;\n    //double offset = 0.0;\n\n    std::string zbname, zsname, hname, uname, vname, xname, yname;\n    // Open the file for read access\n    //netCDF::NcFile dataFile(XParam.hotstartfile, NcFile::read);\n\n    bool isBG_Flood = false;\n\n    int BG_vers = -999;\n\n    // read ncfile attribute and see if BG_flood global attribute exists.\n    //Open NC file\n    printf(\"Open file...\");\n    status = nc_open(XParam.hotstartfile.c_str(), NC_NOWRITE, &amp;ncid);\n\n    status = nc_get_att_int(ncid, NC_GLOBAL, \"BG_Flood\", &amp;BG_vers);\n\n    //isBG_Flood = BG_vers &gt;= 0)\n\n    status = nc_close(ncid);\n\n\n\n}\n\ntemplate &lt;class T&gt;\nint readhotstartfile(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt;&amp; XEv, T*&amp; zb)\n{\n    int status;\n    int ncid;\n    //int dimids[NC_MAX_VAR_DIMS];   // dimension IDs \n    int ib;\n    //double scalefac = 1.0;\n    //double offset = 0.0;\n\n    std::string zbname, zsname, hname, uname, vname, xname, yname;\n    // Open the file for read access\n    //netCDF::NcFile dataFile(XParam.hotstartfile, NcFile::read);\n\n\n    //Open NC file\n    printf(\"Open file...\");\n    status = nc_open(XParam.hotstartfile.c_str(), NC_NOWRITE, &amp;ncid);\n\n\n    //bool isBG_Flood = false;\n\n    // read ncfile attribute and see if BG_flood global attribute exists.\n\n    //if it exist read each level separatly otherwise look for the following variables \n\n    if (status != NC_NOERR) handle_ncerror(status);\n    zbname = checkncvarname(ncid, \"zb\", \"z\", \"ZB\", \"Z\", \"zb_P0\");\n    zsname = checkncvarname(ncid, \"zs\", \"eta\", \"ZS\", \"ETA\", \"zs_P0\");\n    hname = checkncvarname(ncid, \"h\", \"hh\", \"hhh\", \"hhhh\", \"h_P0\");\n    uname = checkncvarname(ncid, \"u\", \"uu\", \"uvel\", \"UVEL\", \"u_P0\");\n    vname = checkncvarname(ncid, \"v\", \"vv\", \"vvel\", \"VVEL\", \"v_P0\");\n\n    //by default we assume that the x axis is called \"xx\" but that is not sure \"x\" shoudl be accepted and so does \"lon\" for spherical grid\n    // The folowing section figure out which one is in the file and if none exits with the netcdf error\n    // default name is \"xx\"\n    //xname = checkncvarname(ncid, \"x\", \"xx\",\"lon\",\"Lon\");\n    //yname = checkncvarname(ncid, \"y\", \"yy\", \"lat\", \"Lat\");\n\n    status = nc_close(ncid);\n\n\n    // First we should read x and y coordinates\n    // Just as with other variables we expect the file follow the output naming convention of \"xx\" and \"yy\" both as a dimension and a variable\n    StaticForcingP&lt;float&gt; zbhotstart, zshotstart, hhotstart, uhotstart, vhotstart;\n\n    // Read hotstart block info if it exist\n    // By default reuse mesh-layout\n    // for now we pretend hotstart are just unifomr maesh layout\n\n\n\n    //if hotstart has zb variable overright the previous ne\n    //printf(\"Found variables: \");\n    if (!zbname.empty())\n    {\n        //zb is set\n        zbhotstart = readfileinfo(XParam.hotstartfile + \"?\" + zbname, zbhotstart);\n\n        readstaticforcing(XParam.hotstep, zbhotstart);\n        interp2BUQ(XParam, XBlock, zbhotstart, zb);\n\n        //because we set the edges around empty blocks we need the set the edges for zs too\n        // otherwise we create some gitantic waves at the edges of empty blocks\n        setedges(XParam, XBlock, zb);\n\n\n\n    }\n    // second check if zs or hh are in the file\n\n\n    //zs Section\n    if (!zsname.empty())\n    {\n        log(\" zs... \");\n\n        zshotstart = readfileinfo(XParam.hotstartfile + \"?\" + zsname, zshotstart);\n        //readforcingmaphead(zshotstart);\n        readstaticforcing(XParam.hotstep, zshotstart);\n\n        interp2BUQ(XParam, XBlock, zshotstart, XEv.zs);\n\n        setedges(XParam, XBlock, XEv.zs);\n\n        //setedges(XParam.nblk, leftblk, rightblk, topblk, botblk, zs);\n\n        //check sanity\n        for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n        {\n            ib = XBlock.active[ibl];\n            for (int j = 0; j &lt; XParam.blkwidth; j++)\n            {\n                for (int i = 0; i &lt; XParam.blkwidth; i++)\n                {\n                    int n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                    XEv.zs[n] = utils::max(XEv.zs[n], zb[n]);\n                    //unpacked_value = packed_value * scale_factor + add_offset\n                }\n            }\n        }\n\n\n    }\n    else\n    {\n        //Variable not found\n        //It's ok if hh is specified\n        log(\"zs not found in hotstart file. Looking for hh... \");\n\n    }\n\n    //hh section\n    if (!hname.empty())\n    {\n        log(\"h... \");\n        hhotstart = readfileinfo(XParam.hotstartfile + \"?\" + hname, hhotstart);\n        //readforcingmaphead(zshotstart);\n        readstaticforcing(XParam.hotstep, hhotstart);\n\n        interp2BUQ(XParam, XBlock, hhotstart, XEv.h);\n\n        setedges(XParam, XBlock, XEv.h);\n\n        //if zs was not specified\n        if (zsname.empty())\n        {\n            for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n            {\n                ib = XBlock.active[ibl];\n                for (int j = 0; j &lt; XParam.blkwidth; j++)\n                {\n                    for (int i = 0; i &lt; XParam.blkwidth; i++)\n                    {\n                        int n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                        XEv.zs[n] = zb[n] + XEv.h[n];\n                        //unpacked_value = packed_value * scale_factor + add_offset\n                    }\n                }\n            }\n\n        }\n\n\n\n    }\n    else\n    {\n        //if both zs and h were not specified\n        if (zsname.empty() &amp;&amp; hname.empty())\n        {\n            //Variable not found\n            //It's ok if hh is specified\n            log(\"neither zs nor hh were found in hotstart file. this is not a valid hotstart file. using a cold start instead\");\n            return 0;\n        }\n        else\n        {\n            //zs was specified but not h\n            for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n            {\n                ib = XBlock.active[ibl];\n                for (int j = 0; j &lt; XParam.blkwidth; j++)\n                {\n                    for (int i = 0; i &lt; XParam.blkwidth; i++)\n                    {\n                        int n = memloc(XParam, i, j, ib);\n\n\n                        XEv.h[n] = utils::max(XEv.zs[n] - zb[n], T(0.0));\n                    }\n\n                }\n            }\n\n        }\n    }\n\n    //u Section\n\n    if (!uname.empty())\n    {\n        log(\"u... \");\n        uhotstart = readfileinfo(XParam.hotstartfile + \"?\" + uname, uhotstart);\n        //readforcingmaphead(zshotstart);\n        readstaticforcing(XParam.hotstep, uhotstart);\n\n        interp2BUQ(XParam, XBlock, uhotstart, XEv.u);\n\n        setedges(XParam, XBlock, XEv.u);\n\n    }\n    else\n    {\n        InitArrayBUQ(XParam, XBlock, (T)0.0, XEv.u);\n    }\n\n    //vv section\n\n    if (!vname.empty())\n    {\n        log(\"v... \");\n        vhotstart = readfileinfo(XParam.hotstartfile + \"?\" + vname, vhotstart);\n        //readforcingmaphead(zshotstart);\n        readstaticforcing(XParam.hotstep, vhotstart);\n\n        interp2BUQ(XParam, XBlock, vhotstart, XEv.v);\n\n        setedges(XParam, XBlock, XEv.v);\n\n\n    }\n    else\n    {\n        InitArrayBUQ(XParam,XBlock, (T)0.0, XEv.v);\n    }\n    //status = nc_get_var_float(ncid, hh_id, zb);\n    status = nc_close(ncid);\n\n\n\n    return 1;\n\n}\ntemplate int readhotstartfile&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt;&amp; XEv, float*&amp; zb);\ntemplate int readhotstartfile&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt;&amp; XEv, double*&amp; zb);\n//template int readhotstartfile&lt;float&gt;(Param XParam, int * leftblk, int *rightblk, int * topblk, int* botblk, double * blockxo, double * blockyo, float * &amp;zs, float * &amp;zb, float * &amp;hh, float *&amp;uu, float * &amp;vv);\n\n//template int readhotstartfile&lt;double&gt;(Param XParam, int * leftblk, int *rightblk, int * topblk, int* botblk, double * blockxo, double * blockyo, double * &amp;zs, double * &amp;zb, double * &amp;hh, double *&amp;uu, double * &amp;vv);\n</code></pre>"},{"location":"BGFlood/InitEvolv_8h/","title":"File InitEvolv.h","text":""},{"location":"BGFlood/InitEvolv_8h/#file-initevolvh","title":"File InitEvolv.h","text":"<p>FileList &gt; src &gt; InitEvolv.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"GridManip.h\"</code></li> <li><code>#include \"Read_netcdf.h\"</code></li> <li><code>#include \"ReadForcing.h\"</code></li> <li><code>#include \"Updateforcing.h\"</code></li> </ul>"},{"location":"BGFlood/InitEvolv_8h/#public-functions","title":"Public Functions","text":"Type Name int AddZSoffset (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; &amp; XEv, T * zb)  int coldstart (Param XParam, BlockP&lt; T &gt; XBlock, T * zb, EvolvingP&lt; T &gt; &amp; XEv)  void initevolv (Param XParam, BlockP&lt; T &gt; XBlock, Forcing&lt; float &gt; XForcing, EvolvingP&lt; T &gt; &amp; XEv, T *&amp; zb)  int readhotstartfile (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; &amp; XEv, T *&amp; zb)  void warmstart (Param XParam, Forcing&lt; float &gt; XForcing, BlockP&lt; T &gt; XBlock, T * zb, EvolvingP&lt; T &gt; &amp; XEv)"},{"location":"BGFlood/InitEvolv_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/InitEvolv_8h/#function-addzsoffset","title":"function AddZSoffset","text":"<pre><code>template&lt;class T&gt;\nint AddZSoffset (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; &amp; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/InitEvolv_8h/#function-coldstart","title":"function coldstart","text":"<pre><code>template&lt;class T&gt;\nint coldstart (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * zb,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/InitEvolv_8h/#function-initevolv","title":"function initevolv","text":"<pre><code>template&lt;class T&gt;\nvoid initevolv (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    Forcing &lt; float &gt; XForcing,\n    EvolvingP &lt; T &gt; &amp; XEv,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/InitEvolv_8h/#function-readhotstartfile","title":"function readhotstartfile","text":"<pre><code>template&lt;class T&gt;\nint readhotstartfile (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; &amp; XEv,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/InitEvolv_8h/#function-warmstart","title":"function warmstart","text":"<pre><code>template&lt;class T&gt;\nvoid warmstart (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    BlockP &lt; T &gt; XBlock,\n    T * zb,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/InitEvolv.h</code></p>"},{"location":"BGFlood/InitEvolv_8h_source/","title":"File InitEvolv.h","text":""},{"location":"BGFlood/InitEvolv_8h_source/#file-initevolvh","title":"File InitEvolv.h","text":"<p>File List &gt; src &gt; InitEvolv.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef INITEVOLV_H\n#define INITEVOLV_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"Write_txtlog.h\"\n#include \"GridManip.h\"\n#include \"Read_netcdf.h\"\n#include \"ReadForcing.h\"\n#include \"Updateforcing.h\"\n\n\ntemplate &lt;class T&gt; void initevolv(Param XParam, BlockP&lt;T&gt; XBlock, Forcing&lt;float&gt; XForcing, EvolvingP&lt;T&gt;&amp; XEv, T*&amp; zb);\ntemplate &lt;class T&gt; int coldstart(Param XParam, BlockP&lt;T&gt; XBlock, T* zb, EvolvingP&lt;T&gt;&amp; XEv);\ntemplate &lt;class T&gt; void warmstart(Param XParam, Forcing&lt;float&gt; XForcing, BlockP&lt;T&gt; XBlock, T* zb, EvolvingP&lt;T&gt;&amp; XEv);\ntemplate &lt;class T&gt; int AddZSoffset(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt;&amp; XEv, T* zb);\n\ntemplate &lt;class T&gt; int readhotstartfile(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt;&amp; XEv, T*&amp; zb);\n\n// End of global definition;\n#endif\n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/","title":"File InitialConditions.cu","text":""},{"location":"BGFlood/InitialConditions_8cu/#file-initialconditionscu","title":"File InitialConditions.cu","text":"<p>FileList &gt; src &gt; InitialConditions.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"InitialConditions.h\"</code></li> <li><code>#include \"Input.h\"</code></li> </ul>"},{"location":"BGFlood/InitialConditions_8cu/#public-functions","title":"Public Functions","text":"Type Name void Calcbndblks (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; T &gt; XBlock)  void FindTSoutNodes (Param &amp; XParam, BlockP&lt; T &gt; XBlock, BndblockP&lt; T &gt; &amp; bnd)  template void FindTSoutNodes&lt; double &gt; (Param &amp; XParam, BlockP&lt; double &gt; XBlock, BndblockP&lt; double &gt; &amp; bnd)  template void FindTSoutNodes&lt; float &gt; (Param &amp; XParam, BlockP&lt; float &gt; XBlock, BndblockP&lt; float &gt; &amp; bnd)  void Findbndblks (Param XParam, Model&lt; T &gt; XModel, Forcing&lt; float &gt; &amp; XForcing)  void Findoutzoneblks (Param &amp; XParam, BlockP&lt; T &gt; &amp; XBlock)  template void Findoutzoneblks&lt; double &gt; (Param &amp; XParam, BlockP&lt; double &gt; &amp; XBlock)  template void Findoutzoneblks&lt; float &gt; (Param &amp; XParam, BlockP&lt; float &gt; &amp; XBlock)  std::vector&lt; double &gt; GetTimeOutput (T_output time_info)  void InitRivers (Param XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel)  template void InitRivers&lt; double &gt; (Param XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; double &gt; &amp; XModel)  template void InitRivers&lt; float &gt; (Param XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; float &gt; &amp; XModel)  void InitTSOutput (Param XParam)  void Initbndblks (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; T &gt; XBlock)  void InitialConditions (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel)  template void InitialConditions&lt; double &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; double &gt; &amp; XModel)  template void InitialConditions&lt; float &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; float &gt; &amp; XModel)  void Initmaparray (Model&lt; T &gt; &amp; XModel)  template void Initmaparray&lt; double &gt; (Model&lt; double &gt; &amp; XModel)  template void Initmaparray&lt; float &gt; (Model&lt; float &gt; &amp; XModel)  void Initoutzone (Param &amp; XParam, BlockP&lt; T &gt; &amp; XBlock)  template void Initoutzone&lt; double &gt; (Param &amp; XParam, BlockP&lt; double &gt; &amp; XBlock)  template void Initoutzone&lt; float &gt; (Param &amp; XParam, BlockP&lt; float &gt; &amp; XBlock)  void InitzbgradientCPU (Param XParam, Model&lt; T &gt; XModel)  template void InitzbgradientCPU&lt; double &gt; (Param XParam, Model&lt; double &gt; XModel)  template void InitzbgradientCPU&lt; float &gt; (Param XParam, Model&lt; float &gt; XModel)  void InitzbgradientGPU (Param XParam, Model&lt; T &gt; XModel)  template void InitzbgradientGPU&lt; double &gt; (Param XParam, Model&lt; double &gt; XModel)  template void InitzbgradientGPU&lt; float &gt; (Param XParam, Model&lt; float &gt; XModel)  void RectCornerBlk (Param &amp; XParam, BlockP&lt; T &gt; &amp; XBlock, double xo, double yo, double xmax, double ymax, bool isEps, std::vector&lt; int &gt; &amp; cornerblk)  void calcactiveCellCPU (Param XParam, BlockP&lt; T &gt; XBlock, Forcing&lt; float &gt; &amp; XForcing, T * zb)  __global__ void calcactiveCellGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * zb)  void initOutputTimes (Param XParam, std::vector&lt; double &gt; &amp; OutputT, BlockP&lt; T &gt; &amp; XBlock)  void initinfiltration (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * initLoss, T * hgw)  void initoutput (Param &amp; XParam, Model&lt; T &gt; &amp; XModel)"},{"location":"BGFlood/InitialConditions_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/InitialConditions_8cu/#function-calcbndblks","title":"function Calcbndblks","text":"<pre><code>template&lt;class T&gt;\nvoid Calcbndblks (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; T &gt; XBlock\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-findtsoutnodes","title":"function FindTSoutNodes","text":"<pre><code>template&lt;class T&gt;\nvoid FindTSoutNodes (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; XBlock,\n    BndblockP &lt; T &gt; &amp; bnd\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-findtsoutnodes-double","title":"function FindTSoutNodes&lt; double &gt;","text":"<pre><code>template void FindTSoutNodes&lt; double &gt; (\n    Param &amp; XParam,\n    BlockP &lt; double &gt; XBlock,\n    BndblockP &lt; double &gt; &amp; bnd\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-findtsoutnodes-float","title":"function FindTSoutNodes&lt; float &gt;","text":"<pre><code>template void FindTSoutNodes&lt; float &gt; (\n    Param &amp; XParam,\n    BlockP &lt; float &gt; XBlock,\n    BndblockP &lt; float &gt; &amp; bnd\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-findbndblks","title":"function Findbndblks","text":"<pre><code>template&lt;class T&gt;\nvoid Findbndblks (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre> <p>Find which block on the model edge belongs to a \"side boundary\" </p>"},{"location":"BGFlood/InitialConditions_8cu/#function-findoutzoneblks","title":"function Findoutzoneblks","text":"<pre><code>template&lt;class T&gt;\nvoid Findoutzoneblks (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-findoutzoneblks-double","title":"function Findoutzoneblks&lt; double &gt;","text":"<pre><code>template void Findoutzoneblks&lt; double &gt; (\n    Param &amp; XParam,\n    BlockP &lt; double &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-findoutzoneblks-float","title":"function Findoutzoneblks&lt; float &gt;","text":"<pre><code>template void Findoutzoneblks&lt; float &gt; (\n    Param &amp; XParam,\n    BlockP &lt; float &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-gettimeoutput","title":"function GetTimeOutput","text":"<pre><code>std::vector&lt; double &gt; GetTimeOutput (\n    T_output time_info\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initrivers","title":"function InitRivers","text":"<pre><code>template&lt;class T&gt;\nvoid InitRivers (\n    Param XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initrivers-double","title":"function InitRivers&lt; double &gt;","text":"<pre><code>template void InitRivers&lt; double &gt; (\n    Param XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initrivers-float","title":"function InitRivers&lt; float &gt;","text":"<pre><code>template void InitRivers&lt; float &gt; (\n    Param XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-inittsoutput","title":"function InitTSOutput","text":"<pre><code>void InitTSOutput (\n    Param XParam\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initbndblks","title":"function Initbndblks","text":"<pre><code>template&lt;class T&gt;\nvoid Initbndblks (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; T &gt; XBlock\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initialconditions","title":"function InitialConditions","text":"<pre><code>template&lt;class T&gt;\nvoid InitialConditions (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initialconditions-double","title":"function InitialConditions&lt; double &gt;","text":"<pre><code>template void InitialConditions&lt; double &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initialconditions-float","title":"function InitialConditions&lt; float &gt;","text":"<pre><code>template void InitialConditions&lt; float &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initmaparray","title":"function Initmaparray","text":"<pre><code>template&lt;class T&gt;\nvoid Initmaparray (\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initmaparray-double","title":"function Initmaparray&lt; double &gt;","text":"<pre><code>template void Initmaparray&lt; double &gt; (\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initmaparray-float","title":"function Initmaparray&lt; float &gt;","text":"<pre><code>template void Initmaparray&lt; float &gt; (\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initoutzone","title":"function Initoutzone","text":"<pre><code>template&lt;class T&gt;\nvoid Initoutzone (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initoutzone-double","title":"function Initoutzone&lt; double &gt;","text":"<pre><code>template void Initoutzone&lt; double &gt; (\n    Param &amp; XParam,\n    BlockP &lt; double &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initoutzone-float","title":"function Initoutzone&lt; float &gt;","text":"<pre><code>template void Initoutzone&lt; float &gt; (\n    Param &amp; XParam,\n    BlockP &lt; float &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initzbgradientcpu","title":"function InitzbgradientCPU","text":"<pre><code>template&lt;class T&gt;\nvoid InitzbgradientCPU (\n    Param XParam,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initzbgradientcpu-double","title":"function InitzbgradientCPU&lt; double &gt;","text":"<pre><code>template void InitzbgradientCPU&lt; double &gt; (\n    Param XParam,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initzbgradientcpu-float","title":"function InitzbgradientCPU&lt; float &gt;","text":"<pre><code>template void InitzbgradientCPU&lt; float &gt; (\n    Param XParam,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initzbgradientgpu","title":"function InitzbgradientGPU","text":"<pre><code>template&lt;class T&gt;\nvoid InitzbgradientGPU (\n    Param XParam,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initzbgradientgpu-double","title":"function InitzbgradientGPU&lt; double &gt;","text":"<pre><code>template void InitzbgradientGPU&lt; double &gt; (\n    Param XParam,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initzbgradientgpu-float","title":"function InitzbgradientGPU&lt; float &gt;","text":"<pre><code>template void InitzbgradientGPU&lt; float &gt; (\n    Param XParam,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-rectcornerblk","title":"function RectCornerBlk","text":"<pre><code>template&lt;class T&gt;\nvoid RectCornerBlk (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; &amp; XBlock,\n    double xo,\n    double yo,\n    double xmax,\n    double ymax,\n    bool isEps,\n    std::vector&lt; int &gt; &amp; cornerblk\n) \n</code></pre> <p>Find the block containing the border of a rectangular box (used for the defining the output zones) The indice of the blocks are returned through \"cornerblk\" from bottom left turning in the clockwise direction </p>"},{"location":"BGFlood/InitialConditions_8cu/#function-calcactivecellcpu","title":"function calcactiveCellCPU","text":"<pre><code>template&lt;class T&gt;\nvoid calcactiveCellCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    Forcing &lt; float &gt; &amp; XForcing,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-calcactivecellgpu","title":"function calcactiveCellGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void calcactiveCellGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initoutputtimes","title":"function initOutputTimes","text":"<pre><code>template&lt;class T&gt;\nvoid initOutputTimes (\n    Param XParam,\n    std::vector&lt; double &gt; &amp; OutputT,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initinfiltration","title":"function initinfiltration","text":"<pre><code>template&lt;class T&gt;\nvoid initinfiltration (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * initLoss,\n    T * hgw\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8cu/#function-initoutput","title":"function initoutput","text":"<pre><code>template&lt;class T&gt;\nvoid initoutput (\n    Param &amp; XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/InitialConditions.cu</code></p>"},{"location":"BGFlood/InitialConditions_8cu_source/","title":"File InitialConditions.cu","text":""},{"location":"BGFlood/InitialConditions_8cu_source/#file-initialconditionscu","title":"File InitialConditions.cu","text":"<p>File List &gt; src &gt; InitialConditions.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //    \n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n\n#include \"InitialConditions.h\"\n#include \"Input.h\"\n\ntemplate &lt;class T&gt; void InitialConditions(Param &amp;XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;T&gt; &amp;XModel)\n{\n    //=====================================\n    // Initialise Bathy data\n\n    interp2BUQ(XParam, XModel.blocks, XForcing.Bathy, XModel.zb);\n\n    // Set edges\n    setedges(XParam, XModel.blocks, XModel.zb);\n\n\n    //=====================================\n    // Initialise Friction map\n\n    if (!XForcing.cf.empty())\n    {\n        interp2BUQ(XParam, XModel.blocks, XForcing.cf, XModel.cf);\n    }\n    else\n    {\n        InitArrayBUQ(XParam, XModel.blocks, (T)XParam.cf, XModel.cf);\n    }\n    // Set edges of friction map\n    setedges(XParam, XModel.blocks, XModel.cf);\n\n\n\n\n    //=====================================\n    // Initial Condition\n\n    log(\"\\nInitial condition:\");\n    // First calculate the initial values for Evolving parameters (i.e. zs, h, u and v)\n    initevolv(XParam, XModel.blocks,XForcing, XModel.evolv, XModel.zb);\n    CopyArrayBUQ(XParam, XModel.blocks, XModel.evolv, XModel.evolv_o);\n\n    // Initialise the topography slope and halo\n    InitzbgradientCPU(XParam, XModel);\n\n    //=====================================\n    // Initial forcing\n    InitRivers(XParam, XForcing, XModel);\n\n    //=====================================\n    // Initial bndinfo\n    //Calcbndblks(XParam, XForcing, XModel.blocks);\n    //Findbndblks(XParam, XModel, XForcing);\n    Initbndblks(XParam, XForcing, XModel.blocks);\n\n\n    //=====================================\n    // Calculate Active cells\n    calcactiveCellCPU(XParam, XModel.blocks, XForcing, XModel.zb);\n\n    //=====================================\n    // Initialise the rain losses map\n\n    if (XParam.infiltration)\n    {\n        if (!XForcing.il.inputfile.empty())\n        {\n            interp2BUQ(XParam, XModel.blocks, XForcing.il, XModel.il);\n        }\n        else\n        {\n            InitArrayBUQ(XParam, XModel.blocks, (T)XParam.il, XModel.il);\n        }\n        if (!XForcing.cl.inputfile.empty())\n        {\n            interp2BUQ(XParam, XModel.blocks, XForcing.cl, XModel.cl);\n        }\n        else\n        {\n            InitArrayBUQ(XParam, XModel.blocks, (T)XParam.cl, XModel.cl);\n        }\n        // Set edges of friction map\n        setedges(XParam, XModel.blocks, XModel.il);\n        setedges(XParam, XModel.blocks, XModel.cl);\n        InitArrayBUQ(XParam, XModel.blocks, T(0.0), XModel.hgw);\n\n        // Initialise infiltration to IL where h is already wet\n        initinfiltration(XParam, XModel.blocks, XModel.evolv.h, XModel.il, XModel.hgw);\n    }\n\n    //=====================================\n    // Initialize output variables\n    initoutput(XParam, XModel);\n\n    // Initialise Output times' vector\n    initOutputTimes(XParam, XModel.OutputT, XModel.blocks);\n}\ntemplate void InitialConditions&lt;float&gt;(Param &amp;XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;float&gt; &amp;XModel);\ntemplate void InitialConditions&lt;double&gt;(Param &amp;XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;double&gt; &amp;XModel);\n\ntemplate &lt;class T&gt; void InitzbgradientCPU(Param XParam, Model&lt;T&gt; XModel)\n{\n\n\n    fillHaloC(XParam, XModel.blocks, XModel.zb);\n    gradientC(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    gradientHalo(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n\n    refine_linear(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    gradientHalo(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n\n\n}\ntemplate void InitzbgradientCPU&lt;double&gt;(Param XParam, Model&lt;double&gt; XModel);\ntemplate void InitzbgradientCPU&lt;float&gt;(Param XParam, Model&lt;float&gt; XModel);\n\ntemplate &lt;class T&gt; void InitzbgradientGPU(Param XParam, Model&lt;T&gt; XModel)\n{\n    const int num_streams = 4;\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n\n    cudaStream_t streams[num_streams];\n\n\n    CUDA_CHECK(cudaStreamCreate(&amp;streams[0]));\n\n    fillHaloGPU(XParam, XModel.blocks, streams[0], XModel.zb);\n\n    cudaStreamDestroy(streams[0]);\n\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradientHaloGPU(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n\n    refine_linearGPU(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradientHaloGPU(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n}\ntemplate void InitzbgradientGPU&lt;double&gt;(Param XParam, Model&lt;double&gt; XModel);\ntemplate void InitzbgradientGPU&lt;float&gt;(Param XParam, Model&lt;float&gt; XModel);\n\ntemplate &lt;class T&gt; void initoutput(Param &amp;XParam, Model&lt;T&gt; &amp;XModel)\n{\n\n\n    //FILE* fsSLTS;\n    // Initialise all storage involving parameters\n    //CopyArrayBUQ(XParam, XModel.blocks, XModel.evolv, XModel.evolv_o);\n    if (XParam.outmax)\n    {\n        CopyArrayBUQ(XParam, XModel.blocks, XModel.evolv, XModel.evmax);\n    }\n    if (XParam.outmean)\n    {\n        CopyArrayBUQ(XParam, XModel.blocks, XModel.evolv, XModel.evmean);\n    }\n    if (XParam.outtwet)\n    {\n        InitArrayBUQ(XParam, XModel.blocks, T(0.0), XModel.wettime);\n    }\n\n    if (XParam.TSnodesout.size() &gt; 0)\n    {\n        FindTSoutNodes(XParam, XModel.blocks, XModel.bndblk);\n    }\n\n\n    //==============================\n    // Init. map array\n    Initmaparray(XModel);\n    // Init. zones for output\n    Initoutzone(XParam, XModel.blocks);\n\n    //==============================\n    // Setup output netcdf file\n    //XParam = creatncfileBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo);\n\n\n}\n\nvoid InitTSOutput(Param XParam)\n{\n    for (int o = 0; o &lt; XParam.TSnodesout.size(); o++)\n    {\n        FILE* fsSLTS;\n\n        //Overwrite existing files\n        fsSLTS = fopen(XParam.TSnodesout[o].outname.c_str(), \"w\");\n        fprintf(fsSLTS, \"# x=%f\\ty=%f\\ti=%d\\tj=%d\\tblock=%d\\t%s\\n\", XParam.TSnodesout[o].x, XParam.TSnodesout[o].y, XParam.TSnodesout[o].i, XParam.TSnodesout[o].j, XParam.TSnodesout[o].block, XParam.TSnodesout[o].outname.c_str());\n\n        fprintf(fsSLTS, \"# time[s]\\tzs[m]\\th[m]\\tu[m/s]\\tv[m/s]\\n\");\n\n        fclose(fsSLTS);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; void FindTSoutNodes(Param&amp; XParam, BlockP&lt;T&gt; XBlock, BndblockP&lt;T&gt; &amp; bnd)\n{\n    int ib;\n    T levdx,x,y,blkxmin,blkxmax,blkymin,blkymax,dxblk;\n    bnd.nblkTs = int(XParam.TSnodesout.size());\n\n    AllocateCPU(bnd.nblkTs, 1, bnd.Tsout);\n\n    // Initialise all storage involving parameters\n\n\n    for (int o = 0; o &lt; XParam.TSnodesout.size(); o++)\n    {\n\n\n        //find the block where point belongs\n        for (int blk = 0; blk &lt; XParam.nblk; blk++)\n        {\n\n            ib = XBlock.active[blk];\n            levdx = T(calcres(XParam.dx,XBlock.level[ib]));\n\n            x = (T)XParam.TSnodesout[o].x;\n            y = (T)XParam.TSnodesout[o].y;\n\n            dxblk = (T)(XParam.blkwidth) * levdx;\n\n            blkxmin = ((T)XParam.xo + XBlock.xo[ib] - T(0.5) * levdx);\n            blkymin = ((T)XParam.yo + XBlock.yo[ib] - T(0.5) * levdx);\n\n            blkxmax = (blkxmin + dxblk);\n            blkymax = (blkymin + dxblk);\n\n\n            if (x &gt; blkxmin &amp;&amp; x &lt;= blkxmax &amp;&amp; y &gt; blkymin &amp;&amp; y &lt;= blkymax)\n            {\n                XParam.TSnodesout[o].block = ib;\n                XParam.TSnodesout[o].i = min(max((int)round((XParam.TSnodesout[o].x - (XParam.xo + XBlock.xo[ib])) / levdx), 0), XParam.blkwidth - 1);\n                XParam.TSnodesout[o].j = min(max((int)round((XParam.TSnodesout[o].y - (XParam.yo + XBlock.yo[ib])) / levdx), 0), XParam.blkwidth - 1);\n                break;\n            }\n        }\n        bnd.Tsout[o] = ib;\n    }\n\n\n}\ntemplate void FindTSoutNodes&lt;float&gt;(Param&amp; XParam, BlockP&lt;float&gt; XBlock, BndblockP&lt;float&gt;&amp; bnd);\ntemplate void FindTSoutNodes&lt;double&gt;(Param&amp; XParam, BlockP&lt;double&gt; XBlock, BndblockP&lt;double&gt;&amp; bnd);\n\n\n\ntemplate &lt;class T&gt; void InitRivers(Param XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;T&gt; &amp;XModel)\n{\n    //========================\n    // River discharge\n\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        //\n        double xl, yb, xr, yt, xi,yi ;\n        int ib;\n        double levdx, levdelta;\n        double dischargeArea;\n        log(\"\\tInitializing rivers\");\n        //For each rivers\n        for (int Rin = 0; Rin &lt; XForcing.rivers.size(); Rin++)\n        {\n            dischargeArea = 0.0;\n            // find the cells where the river discharge will be applied\n            std::vector&lt;int&gt; idis, jdis, blockdis;\n            for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n            {\n                ib = XModel.blocks.active[ibl];\n                levdx = calcres(XParam.dx, XModel.blocks.level[ib]);\n                levdelta = calcres(XParam.delta, XModel.blocks.level[ib]);\n                for (int j = 0; j &lt; XParam.blkwidth; j++)\n                {\n                    for (int i = 0; i &lt; XParam.blkwidth; i++)\n                    {\n                        //int n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                        xi = XParam.xo + XModel.blocks.xo[ib] + i * levdx;\n                        yi = XParam.yo + XModel.blocks.yo[ib] + j * levdx;\n\n\n\n                        xl = xi - 0.5 * levdx;\n                        yb = yi - 0.5 * levdx;\n\n                        xr = xi + 0.5 * levdx;\n                        yt = yi + 0.5 * levdx;\n                        // the conditions are that the discharge area as defined by the user have to include at least a model grid node\n                        // This could be really annoying and there should be a better way to deal wiith this like polygon intersection\n                        //if (xx &gt;= XForcing.rivers[Rin].xstart &amp;&amp; xx &lt;= XForcing.rivers[Rin].xend &amp;&amp; yy &gt;= XForcing.rivers[Rin].ystart &amp;&amp; yy &lt;= XForcing.rivers[Rin].yend)\n                        if (OBBdetect(xl, xr, yb, yt, XForcing.rivers[Rin].xstart, XForcing.rivers[Rin].xend, XForcing.rivers[Rin].ystart, XForcing.rivers[Rin].yend))\n                        {\n\n                            // This cell belongs to the river discharge area\n                            idis.push_back(i);\n                            jdis.push_back(j);\n                            blockdis.push_back(ib);\n                            if (XParam.spherical)\n                            {\n                                dischargeArea = dischargeArea + spharea(XParam.Radius, xi, yi, levdx);\n                            }\n                            else\n                            {\n                                dischargeArea = dischargeArea + levdelta * levdelta;\n                            }\n                        }\n                    }\n                }\n\n            }\n\n\n\n                XForcing.rivers[Rin].i = idis;\n                XForcing.rivers[Rin].j = jdis;\n                XForcing.rivers[Rin].block = blockdis;\n                XForcing.rivers[Rin].disarea = dischargeArea; // That is valid for spherical grids\n\n\n\n        }\n\n        for (auto it = XForcing.rivers.begin(); it != XForcing.rivers.end(); it++)\n        {\n\n            if (it-&gt;disarea == 0.0)\n            {\n                log(\"Warning river outside active model domain found. This river has been removed!\\n\");\n                XForcing.rivers.erase(it--);\n            }\n        }\n\n\n        //Now identify sort and unique blocks where rivers are being inserted\n        std::vector&lt;int&gt; activeRiverBlk;\n\n        for (int Rin = 0; Rin &lt; XForcing.rivers.size(); Rin++)\n        {\n\n            activeRiverBlk.insert(std::end(activeRiverBlk), std::begin(XForcing.rivers[Rin].block), std::end(XForcing.rivers[Rin].block));\n        }\n        std::sort(activeRiverBlk.begin(), activeRiverBlk.end());\n        activeRiverBlk.erase(std::unique(activeRiverBlk.begin(), activeRiverBlk.end()), activeRiverBlk.end());\n        if (activeRiverBlk.size() &gt; size_t(XModel.bndblk.nblkriver))\n        {\n            ReallocArray(activeRiverBlk.size(), 1, XModel.bndblk.river);\n            XModel.bndblk.nblkriver = int(activeRiverBlk.size());\n        }\n\n\n\n        for (int b = 0; b &lt; activeRiverBlk.size(); b++)\n        {\n            XModel.bndblk.river[b] = activeRiverBlk[b];\n        }\n\n        // Setup the river info\n\n        int nburmax = activeRiverBlk.size();\n        int nribmax = 0;\n        for (int b = 0; b &lt; activeRiverBlk.size(); b++)\n        {\n            int bur = activeRiverBlk[b];\n            int nriverinblock = 0;\n            for (int Rin = 0; Rin &lt; XForcing.rivers.size(); Rin++)\n            {\n                std::vector&lt;int&gt; uniqblockforriver = XForcing.rivers[Rin].block;\n\n                std::sort(uniqblockforriver.begin(), uniqblockforriver.end());\n                uniqblockforriver.erase(std::unique(uniqblockforriver.begin(), uniqblockforriver.end()), uniqblockforriver.end());\n\n                for (int bir = 0; bir &lt; uniqblockforriver.size(); bir++)\n                {\n                    if (uniqblockforriver[bir] == bur)\n                    {\n                        nriverinblock = nriverinblock + 1;\n                    }\n                }\n\n            }\n            nribmax = max(nribmax, nriverinblock);\n        }\n\n        // Allocate Qnow as pinned memory\n        AllocateMappedMemCPU(XForcing.rivers.size(), 1, XParam.GPUDEVICE,XModel.bndblk.Riverinfo.qnow);\n        AllocateCPU(nribmax, nburmax, XModel.bndblk.Riverinfo.xstart, XModel.bndblk.Riverinfo.xend, XModel.bndblk.Riverinfo.ystart, XModel.bndblk.Riverinfo.yend);\n        FillCPU(nribmax, nburmax, T(-1.0), XModel.bndblk.Riverinfo.xstart);\n        FillCPU(nribmax, nburmax, T(-1.0), XModel.bndblk.Riverinfo.xend);\n        FillCPU(nribmax, nburmax, T(-1.0), XModel.bndblk.Riverinfo.ystart);\n        FillCPU(nribmax, nburmax, T(-1.0), XModel.bndblk.Riverinfo.yend);\n\n\n\n        // Allocate XXbidir and Xridib\n        ReallocArray(nribmax, nburmax, XModel.bndblk.Riverinfo.Xbidir);\n        ReallocArray(nribmax, nburmax, XModel.bndblk.Riverinfo.Xridib);\n\n        // Fill them with a flag value \n        FillCPU(nribmax, nburmax, -1, XModel.bndblk.Riverinfo.Xbidir);\n        FillCPU(nribmax, nburmax, -1, XModel.bndblk.Riverinfo.Xridib);\n\n        //Xbidir is an array that stores block id where n rivers apply\n        //along the row of Xbidir block id is unique. meaning that a block id ith two river injection will appear on two seperate row of Xbidir\n        //The number of column (size of row 1) in xbidir is nburmax = length(uniq(blockwith river injected))\n        //\n\n        //Xridib is an array that stores River id that a river is injected for the corresponding block id in Xbidir\n\n\n        XModel.bndblk.Riverinfo.nribmax = nribmax;\n        XModel.bndblk.Riverinfo.nburmax = nburmax;\n\n        std::vector&lt;RiverBlk&gt; blocksalreadyin;\n        RiverBlk emptyvec;\n        for (int iblk = 0; iblk &lt; nribmax; iblk++)\n        {\n\n            blocksalreadyin.push_back(emptyvec);\n\n        }\n\n        //(n, 10)\n        // \n        std::vector&lt;int&gt; iriv(nribmax,0);\n        for (int Rin = 0; Rin &lt; XForcing.rivers.size(); Rin++)\n        {\n            std::vector&lt;int&gt; uniqblockforriver = XForcing.rivers[Rin].block;\n\n            std::sort(uniqblockforriver.begin(), uniqblockforriver.end());\n            uniqblockforriver.erase(std::unique(uniqblockforriver.begin(), uniqblockforriver.end()), uniqblockforriver.end());\n\n\n\n            for (int bir = 0; bir &lt; uniqblockforriver.size(); bir++)\n            {\n\n                for (int iribm = 0; iribm &lt; nribmax; iribm++)\n                {\n\n                    if (std::find(blocksalreadyin[iribm].block.begin(), blocksalreadyin[iribm].block.end(), uniqblockforriver[bir]) != blocksalreadyin[iribm].block.end())\n                    {\n                        //block found already listed in that line;\n\n                        continue;\n                    }\n                    else\n                    {\n                        //not found;\n                        // write to the array\n                        XModel.bndblk.Riverinfo.Xbidir[iriv[iribm] + iribm * nburmax] = uniqblockforriver[bir];\n                        XModel.bndblk.Riverinfo.Xridib[iriv[iribm] + iribm * nburmax] = Rin;\n\n                        iriv[iribm] = iriv[iribm] + 1;\n\n                        // add it to the list \n                        blocksalreadyin[iribm].block.push_back(uniqblockforriver[bir]);\n\n\n\n                        break;\n                    }\n                }\n\n            }\n\n        }\n        for (int iribm = 0; iribm &lt; nribmax; iribm++)\n        {\n            for (int ibur = 0; ibur &lt; nburmax; ibur++)\n            {\n                int indx = ibur + iribm * nburmax;\n                int Rin = XModel.bndblk.Riverinfo.Xridib[indx];\n                if (Rin &gt; -1)\n                {\n                    XModel.bndblk.Riverinfo.xstart[indx] = XForcing.rivers[Rin].xstart;\n                    XModel.bndblk.Riverinfo.xend[indx] = XForcing.rivers[Rin].xend;\n                    XModel.bndblk.Riverinfo.ystart[indx] = XForcing.rivers[Rin].ystart;\n                    XModel.bndblk.Riverinfo.yend[indx] = XForcing.rivers[Rin].yend;\n                }\n            }\n        }\n\n\n\n\n    }\n\n\n}\n\ntemplate void InitRivers&lt;float&gt;(Param XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;float&gt; &amp;XModel);\ntemplate void InitRivers&lt;double&gt;(Param XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;double&gt; &amp;XModel);\n\n\ntemplate&lt;class T&gt; void Initmaparray(Model&lt;T&gt;&amp; XModel)\n{\n    //Main Parameters\n    XModel.OutputVarMap[\"zb\"] = XModel.zb;\n    XModel.Outvarlongname[\"zb\"] = \"Ground elevation above datum\";\n    XModel.Outvarstdname[\"zb\"] = \"ground_elevation_above_datum\";\n    XModel.Outvarunits[\"zb\"] = \"m\";\n\n\n    XModel.OutputVarMap[\"u\"] = XModel.evolv.u;\n    XModel.Outvarlongname[\"u\"] = \"Water velocity in x-direction\";// zonal\n    XModel.Outvarstdname[\"u\"] = \"u_velocity\";\n    XModel.Outvarunits[\"u\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"v\"] = XModel.evolv.v;\n    XModel.Outvarlongname[\"v\"] = \"Velocity in y-direction\";// meridional\n    XModel.Outvarstdname[\"v\"] = \"v_velocity\";\n    XModel.Outvarunits[\"v\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"zs\"] = XModel.evolv.zs;\n    XModel.Outvarlongname[\"zs\"] = \"Water surface elevation above datum\";\n    XModel.Outvarstdname[\"zs\"] = \"water_surface_elevation\";\n    XModel.Outvarunits[\"zs\"] = \"m\";\n\n    XModel.OutputVarMap[\"h\"] = XModel.evolv.h;\n    XModel.Outvarlongname[\"h\"] = \"Water depth\";\n    XModel.Outvarstdname[\"h\"] = \"water_depth\";\n    XModel.Outvarunits[\"h\"] = \"m\";\n\n    //Mean Max parameters\n    XModel.OutputVarMap[\"hmean\"] = XModel.evmean.h;\n    XModel.Outvarlongname[\"hmean\"] = \"Mean water depth since last output\";\n    XModel.Outvarstdname[\"hmean\"] = \"mean_water_depth\";\n    XModel.Outvarunits[\"hmean\"] = \"m\";\n\n    XModel.OutputVarMap[\"hmax\"] = XModel.evmax.h;\n    XModel.Outvarlongname[\"hmax\"] = \"Maximum water depth since simulation start\";\n    XModel.Outvarstdname[\"hmax\"] = \"maximum_water_depth\";\n    XModel.Outvarunits[\"hmax\"] = \"m\";\n\n    XModel.OutputVarMap[\"zsmean\"] = XModel.evmean.zs;\n    XModel.Outvarlongname[\"zsmean\"] = \"Mean water elevation above datum since last output\";\n    XModel.Outvarstdname[\"zsmean\"] = \"mean_water_elevation\";\n    XModel.Outvarunits[\"zsmean\"] = \"m\";\n\n    XModel.OutputVarMap[\"zsmax\"] = XModel.evmax.zs;\n    XModel.Outvarlongname[\"zsmax\"] = \"Maximum water elevation above datum since simulation start\";\n    XModel.Outvarstdname[\"zsmax\"] = \"maximum_water_elevation\";\n    XModel.Outvarunits[\"zsmax\"] = \"m\";\n\n    XModel.OutputVarMap[\"umean\"] = XModel.evmean.u;\n    XModel.Outvarlongname[\"umean\"] = \"Mean velocity in x-direction since last output\";\n    XModel.Outvarstdname[\"umean\"] = \"mean_u_velocity\";\n    XModel.Outvarunits[\"umean\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"umax\"] = XModel.evmax.u;\n    XModel.Outvarlongname[\"umax\"] = \"Maximum velocity in x-direction since simulation start\";\n    XModel.Outvarstdname[\"umax\"] = \"maximum_u_velocity\";\n    XModel.Outvarunits[\"umax\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"vmean\"] = XModel.evmean.v;\n    XModel.Outvarlongname[\"vmean\"] = \"Mean velocity in y-direction since last output\";\n    XModel.Outvarstdname[\"vmean\"] = \"mean_v_velocity\";\n    XModel.Outvarunits[\"vmean\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"vmax\"] = XModel.evmax.v;\n    XModel.Outvarlongname[\"vmax\"] = \"Maximum velocity in y-direction since simulation start\";\n    XModel.Outvarstdname[\"vmax\"] = \"maximum_v_velocity\";\n    XModel.Outvarunits[\"vmax\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"Umean\"] = XModel.evmean.U;\n    XModel.Outvarlongname[\"Umean\"] = \"Mean velocity magnitude since last output\";\n    XModel.Outvarstdname[\"Umean\"] = \"mean_velocity\";\n    XModel.Outvarunits[\"Umean\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"Umax\"] = XModel.evmax.U;\n    XModel.Outvarlongname[\"Umax\"] = \"Maximum velocity magnitude since simulation start\";\n    XModel.Outvarstdname[\"Umax\"] = \"maximum_velocity\";\n    XModel.Outvarunits[\"Umax\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"hUmean\"] = XModel.evmean.hU;\n    XModel.Outvarlongname[\"hUmean\"] = \"Mean depth times velocity since last output\";\n    XModel.Outvarstdname[\"hUmean\"] = \"mean_depth_velocity\";\n    XModel.Outvarunits[\"hUmean\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"hUmax\"] = XModel.evmax.hU;\n    XModel.Outvarlongname[\"hUmax\"] = \"Maximum depth times velocity since simulation start\";\n    XModel.Outvarstdname[\"hUmax\"] = \"maximum_depth_velocity\";\n    XModel.Outvarunits[\"hUmax\"] = \"m2 s-1\";\n\n    //others\n\n    XModel.OutputVarMap[\"uo\"] = XModel.evolv_o.u;\n    XModel.Outvarlongname[\"uo\"] = \"Velocity in x-direction from previous half-step\";\n    XModel.Outvarstdname[\"uo\"] = \"previous_u_velocity\";\n    XModel.Outvarunits[\"uo\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"vo\"] = XModel.evolv_o.v;\n    XModel.Outvarlongname[\"vo\"] = \"Velocity in y-direction from previous half-step\";\n    XModel.Outvarstdname[\"vo\"] = \"previous_v_velocity\";\n    XModel.Outvarunits[\"vo\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"zso\"] = XModel.evolv_o.zs;\n    XModel.Outvarlongname[\"zso\"] = \"Water elevation above datum from previous half-step\";\n    XModel.Outvarstdname[\"zso\"] = \"previous_water_elevation\";\n    XModel.Outvarunits[\"zso\"] = \"m\";\n\n    XModel.OutputVarMap[\"ho\"] = XModel.evolv_o.h;\n    XModel.Outvarlongname[\"ho\"] = \"Water depth from previous half-step\";\n    XModel.Outvarstdname[\"ho\"] = \"previous_water_depth\";\n    XModel.Outvarunits[\"ho\"] = \"m\";\n\n    // Gradients\n\n    XModel.OutputVarMap[\"dhdx\"] = XModel.grad.dhdx;\n    XModel.Outvarlongname[\"dhdx\"] = \"Water depth gradient in x-direction\";\n    XModel.Outvarstdname[\"dhdx\"] = \"water_depth_gradient_x_direction\";\n    XModel.Outvarunits[\"dhdx\"] = \"m/m\";\n\n    XModel.OutputVarMap[\"dhdy\"] = XModel.grad.dhdy;\n    XModel.Outvarlongname[\"dhdy\"] = \"Water depth gradient in y-direction\";\n    XModel.Outvarstdname[\"dhdy\"] = \"water_depth_gradient_y_direction\";\n    XModel.Outvarunits[\"dhdy\"] = \"m/m\";\n\n    XModel.OutputVarMap[\"dudx\"] = XModel.grad.dudx;\n    XModel.Outvarlongname[\"dudx\"] = \"u-velocity gradient in x-direction\";\n    XModel.Outvarstdname[\"dudx\"] = \"u_velocity_gradient_x_direction\";\n    XModel.Outvarunits[\"dudx\"] = \"m s-1/m\";\n\n    XModel.OutputVarMap[\"dudy\"] = XModel.grad.dudy;\n    XModel.Outvarlongname[\"dudy\"] = \"u-velocity gradient in y-direction\";\n    XModel.Outvarstdname[\"dudy\"] = \"u_velocity_gradient_y_direction\";\n    XModel.Outvarunits[\"dudy\"] = \"m s-1/m\";\n\n    XModel.OutputVarMap[\"dvdx\"] = XModel.grad.dvdx;\n    XModel.Outvarlongname[\"dvdx\"] = \"v-velocity gradient in x-direction\";\n    XModel.Outvarstdname[\"dvdx\"] = \"v_velocity_gradient_x_direction\";\n    XModel.Outvarunits[\"dvdx\"] = \"m s-1/m\";\n\n    XModel.OutputVarMap[\"dvdy\"] = XModel.grad.dvdy;\n    XModel.Outvarlongname[\"dvdy\"] = \"v-velocity gradient in y-direction\";\n    XModel.Outvarstdname[\"dvdy\"] = \"v_velocity_gradient_y_direction\";\n    XModel.Outvarunits[\"dvdy\"] = \"m s-1/m\";\n\n    XModel.OutputVarMap[\"dzsdx\"] = XModel.grad.dzsdx;\n    XModel.Outvarlongname[\"dzsdx\"] = \"Water surface gradient in x-direction\";\n    XModel.Outvarstdname[\"dzsdx\"] = \"water_surface_gradient_x_direction\";\n    XModel.Outvarunits[\"dzsdx\"] = \"m/m\";\n\n    XModel.OutputVarMap[\"dzsdy\"] = XModel.grad.dzsdy;\n    XModel.Outvarlongname[\"dzsdy\"] = \"Water surface gradient in y-direction\";\n    XModel.Outvarstdname[\"dzsdy\"] = \"water_surface_gradient_y_direction\";\n    XModel.Outvarunits[\"dzsdy\"] = \"m/m\";\n\n    XModel.OutputVarMap[\"dzbdx\"] = XModel.grad.dzbdx;\n    XModel.Outvarlongname[\"dzbdx\"] = \"ground elevation gradient in x-direction\";\n    XModel.Outvarstdname[\"dzbdx\"] = \"ground_surface_gradient_x_direction\";\n    XModel.Outvarunits[\"dzbdx\"] = \"m/m\";\n\n    XModel.OutputVarMap[\"dzbdy\"] = XModel.grad.dzbdy;\n    XModel.Outvarlongname[\"dzbdy\"] = \"ground slope in y-direction\";\n    XModel.Outvarstdname[\"dzbdy\"] = \"ground_surface_gradient_y_direction\";\n    XModel.Outvarunits[\"dzbdy\"] = \"m/m\";\n\n    //Flux\n    XModel.OutputVarMap[\"Fhu\"] = XModel.flux.Fhu;\n    XModel.Outvarlongname[\"Fhu\"] = \"Fhu flux term in x-direction\";\n    XModel.Outvarstdname[\"Fhu\"] = \"Fh_x_direction\";\n    XModel.Outvarunits[\"Fhu\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"Fhv\"] = XModel.flux.Fhv;\n    XModel.Outvarlongname[\"Fhv\"] = \"Fhv flux term in y-direction\";\n    XModel.Outvarstdname[\"Fhv\"] = \"Fh_y_direction\";\n    XModel.Outvarunits[\"Fhv\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"Fqux\"] = XModel.flux.Fqux;\n    XModel.Outvarlongname[\"Fqux\"] = \"Fqux flux term in x-direction\";\n    XModel.Outvarstdname[\"Fqux\"] = \"Fqu_x_direction\";\n    XModel.Outvarunits[\"Fqux\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"Fqvy\"] = XModel.flux.Fqvy;\n    XModel.Outvarlongname[\"Fqvy\"] = \"Fqvy flux term in y-direction\";\n    XModel.Outvarstdname[\"Fqvy\"] = \"Fqv_y_direction\";\n    XModel.Outvarunits[\"Fqvy\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"Fquy\"] = XModel.flux.Fquy;\n    XModel.Outvarlongname[\"Fquy\"] = \"Fquy flux term in y-direction\";\n    XModel.Outvarstdname[\"Fquy\"] = \"Fqu_y_direction\";\n    XModel.Outvarunits[\"Fquy\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"Fqvx\"] = XModel.flux.Fqvx;\n    XModel.Outvarlongname[\"Fqvx\"] = \"Fqvx flux term in x-direction\";\n    XModel.Outvarstdname[\"Fqvx\"] = \"Fqv_x_direction\";\n    XModel.Outvarunits[\"Fqvx\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"Su\"] = XModel.flux.Su;\n    XModel.Outvarlongname[\"Su\"] = \"Topography source term un x-direction\";\n    XModel.Outvarstdname[\"Su\"] = \"Topo_source_x_direction\";\n    XModel.Outvarunits[\"Su\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"Sv\"] = XModel.flux.Sv;\n    XModel.Outvarlongname[\"Sv\"] = \"Topography source term un y-direction\";\n    XModel.Outvarstdname[\"Sv\"] = \"Topo_source_y_direction\";\n    XModel.Outvarunits[\"Sv\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"Fux\"] = XModel.fluxml.Fux;\n    XModel.Outvarlongname[\"Fux\"] = \"Flux term Fu x-direction\";\n    XModel.Outvarstdname[\"Fux\"] = \"Flux_term_Fu_x_direction\";\n    XModel.Outvarunits[\"Fux\"] = \"m3 s-1\";\n\n    XModel.OutputVarMap[\"Fuy\"] = XModel.fluxml.Fuy;\n    XModel.Outvarlongname[\"Fuy\"] = \"Flux term Fu y-direction\";\n    XModel.Outvarstdname[\"Fuy\"] = \"Flux_term_Fu_y_direction\";\n    XModel.Outvarunits[\"Fuy\"] = \"m3 s-1\";\n\n    XModel.OutputVarMap[\"Fvx\"] = XModel.fluxml.Fvx;\n    XModel.Outvarlongname[\"Fvx\"] = \"Flux term Fv x-direction\";\n    XModel.Outvarstdname[\"Fvx\"] = \"Flux_term_Fv_x_direction\";\n    XModel.Outvarunits[\"Fvx\"] = \"m3 s-1\";\n\n    XModel.OutputVarMap[\"Fvy\"] = XModel.fluxml.Fvy;\n    XModel.Outvarlongname[\"Fvy\"] = \"Flux term Fv y-direction\";\n    XModel.Outvarstdname[\"Fvy\"] = \"Flux_term_Fv_y_direction\";\n    XModel.Outvarunits[\"Fvy\"] = \"m3 s-1\";\n\n    XModel.OutputVarMap[\"hau\"] = XModel.fluxml.hau;\n    XModel.Outvarlongname[\"hau\"] = \"Acceleration term hau x-direction\";\n    XModel.Outvarstdname[\"hau\"] = \"Acceleration_term_hau_x_direction\";\n    XModel.Outvarunits[\"hau\"] = \"m2 s-2\";\n\n    XModel.OutputVarMap[\"hav\"] = XModel.fluxml.hav;\n    XModel.Outvarlongname[\"hav\"] = \"Acceleration term hav y-direction\";\n    XModel.Outvarstdname[\"hav\"] = \"Acceleration_term_hav_y_direction\";\n    XModel.Outvarunits[\"hav\"] = \"m2 s-2\";\n\n    XModel.OutputVarMap[\"hfu\"] = XModel.fluxml.hfu;\n    XModel.Outvarlongname[\"hfu\"] = \"Flux term hfu x-direction\";\n    XModel.Outvarstdname[\"hfu\"] = \"Flux_term_hfu_x_direction\";\n    XModel.Outvarunits[\"hfu\"] = \"m3 s-1\";\n\n    XModel.OutputVarMap[\"hfv\"] = XModel.fluxml.hfv;\n    XModel.Outvarlongname[\"hfv\"] = \"Flux term hfv y-direction\";\n    XModel.Outvarstdname[\"hfv\"] = \"Flux_term_hfv_y_direction\";\n    XModel.Outvarunits[\"hfv\"] = \"m3 s-1\";\n\n    XModel.OutputVarMap[\"hu\"] = XModel.fluxml.hu;\n    XModel.Outvarlongname[\"hu\"] = \"Flux term hu x-direction\";\n    XModel.Outvarstdname[\"hu\"] = \"Flux_term_hu_x_direction\";\n    XModel.Outvarunits[\"hu\"] = \"m3 s-1\";\n\n    XModel.OutputVarMap[\"hv\"] = XModel.fluxml.hv;\n    XModel.Outvarlongname[\"hv\"] = \"Flux term hv y-direction\";\n    XModel.Outvarstdname[\"hv\"] = \"Flux_term_hv_y_direction\";\n    XModel.Outvarunits[\"hv\"] = \"m3 s-1\";\n\n    //Advance\n    XModel.OutputVarMap[\"dh\"] = XModel.adv.dh;\n    XModel.Outvarlongname[\"dh\"] = \"rate of change in water depth\";\n    XModel.Outvarstdname[\"dh\"] = \"rate_change_water_depth\";\n    XModel.Outvarunits[\"dh\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"dhu\"] = XModel.adv.dhu;\n    XModel.Outvarlongname[\"dhu\"] = \"changes in flux n x-direction\";\n    XModel.Outvarstdname[\"dhu\"] = \"rate_change_flux_x_direction\";\n    XModel.Outvarunits[\"dhu\"] = \"m3 s-1/s\";\n\n    XModel.OutputVarMap[\"dhv\"] = XModel.adv.dhv;\n    XModel.Outvarlongname[\"dhv\"] = \"changes in flux n y-direction\";\n    XModel.Outvarstdname[\"dhv\"] = \"rate_change_flux_y_direction\";\n    XModel.Outvarunits[\"dhv\"] = \"m3 s-1/s\";\n\n    XModel.OutputVarMap[\"cf\"] = XModel.cf;\n    XModel.Outvarlongname[\"cf\"] = \"Roughness\";\n    XModel.Outvarunits[\"cf\"] = \"m\";\n\n    XModel.OutputVarMap[\"il\"] = XModel.il;\n    XModel.Outvarlongname[\"il\"] = \"Initial loss water from inflitration\";\n    XModel.Outvarunits[\"il\"] = \"mm\";\n\n    XModel.OutputVarMap[\"cl\"] = XModel.cl;\n    XModel.Outvarlongname[\"cl\"] = \"Continung loss water from inflitration\";\n    XModel.Outvarunits[\"cl\"] = \"mm h-1\";\n\n    XModel.OutputVarMap[\"hgw\"] = XModel.hgw;\n    XModel.Outvarlongname[\"hgw\"] = \"Groundwater height\";\n    XModel.Outvarunits[\"hgw\"] = \"m\";\n\n    XModel.OutputVarMap[\"Patm\"] = XModel.Patm;\n    XModel.Outvarlongname[\"Patm\"] = \"Atmospheric pressure\";\n    XModel.Outvarunits[\"Patm\"] = \"m\";\n\n    XModel.OutputVarMap[\"datmpdx\"] = XModel.datmpdx;\n    XModel.Outvarlongname[\"datmpdx\"] = \"Atmospheric pressure gradient in x-direction\";\n    XModel.Outvarunits[\"datmpdx\"] = \"m/m\";\n\n    XModel.OutputVarMap[\"datmpdy\"] = XModel.datmpdy;\n    XModel.Outvarlongname[\"datmpdy\"] = \"Atmospheric pressure gradient in y-direction\";\n    XModel.Outvarunits[\"datmpdy\"] = \"m/m\";\n\n    //XModel.OutputVarMap[\"U\"] = XModel.U;\n\n    XModel.OutputVarMap[\"twet\"] = XModel.wettime;\n    XModel.Outvarlongname[\"twet\"] = \"time since the cell has been wet\";\n    XModel.Outvarunits[\"twet\"] = \"s\";\n    //XModel.OutputVarMap[\"vort\"] = XModel.vort;\n}\n\ntemplate void Initmaparray&lt;float&gt;(Model&lt;float&gt;&amp; XModel);\ntemplate void Initmaparray&lt;double&gt;(Model&lt;double&gt;&amp; XModel);\n\n\n// Initialise all storage involving parameters of the outzone objects\ntemplate &lt;class T&gt; void Findoutzoneblks(Param&amp; XParam, BlockP&lt;T&gt;&amp; XBlock)\n{\n    int ib, i;\n    T levdx;\n    std::vector&lt;int&gt; cornerblk; //index of the blocks at the corner of the zone \n    outzoneP Xzone; //info on outzone given by the user\n    outzoneB XzoneB; //info on outzone computed and used actually for writing nc files\n    //double eps;\n\n    // Find the blocks to output and the corners of this area for each zone\n    for (int o = 0; o &lt; XParam.outzone.size(); o++)\n    {\n\n        Xzone = XParam.outzone[o];\n\n        XzoneB.xo = Xzone.xstart;\n        XzoneB.yo = Xzone.ystart;\n        XzoneB.xmax = Xzone.xend;\n        XzoneB.ymax = Xzone.yend;\n\n        std::vector&lt;int&gt; blkzone;\n        double xl, xr, yb, yt;\n\n        int nblk = 0;\n        /*\n        cornerblk = { 0, 0, 0, 0 };\n        // Find the blocks to output for each zone (and the corner of this area) \n        //\n        //We want the samller rectangular area, composed of full blocks, \n        //containing the area defined by the user. \n        //- If all the blocks have the same resolution, at least a part of the block\n        //must be inside the user defined rectangular\n        // -If there is blocks of different resolutions in the area, the corners of the area\n        // must be defined first to have a rectangular zone. Then, a new pass through all blocks\n        // identify the blocks inside this new defined zone.\n\n\n        //Getting the new area's corners\n\n        //Initialisation of the corners blocks on the domain boundaries\n        //in case of the border given by user being out of the domain\n        RectCornerBlk(XParam, XBlock, XParam.xo, XParam.yo, XParam.xmax, XParam.ymax, true, cornerblk);\n\n        //Getting the corners blocks of the rectangle given by the user\n        RectCornerBlk(XParam, XBlock, XParam.outzone[o].xstart, XParam.outzone[o].ystart, XParam.outzone[o].xend, XParam.outzone[o].yend, false, cornerblk);\n\n\n        //left edge border\n        int il = (XBlock.level[cornerblk[0]] &lt; XBlock.level[cornerblk[1]]) ? cornerblk[0] : cornerblk[1];\n        levdx = calcres(XParam.dx, XBlock.level[il]);\n        XzoneB.xo = XParam.xo + XBlock.xo[il] - levdx / 2;\n        //bottom edge border\n        int ib = (XBlock.level[cornerblk[0]] &lt; XBlock.level[cornerblk[3]]) ? cornerblk[0] : cornerblk[3];\n        levdx = calcres(XParam.dx, XBlock.level[ib]);\n        XzoneB.yo = XParam.yo + XBlock.yo[ib] - levdx / 2;\n        //right edge border\n        int ir = (XBlock.level[cornerblk[2]] &lt; XBlock.level[cornerblk[3]]) ? cornerblk[2] : cornerblk[3];\n        levdx = calcres(XParam.dx, XBlock.level[ir]);\n        XzoneB.xmax = XParam.xo + XBlock.xo[ir] + (XParam.blkwidth - 1) * levdx + levdx/2;\n        //top edge border\n        int it = (XBlock.level[cornerblk[1]] &lt; XBlock.level[cornerblk[2]]) ? cornerblk[1] : cornerblk[2];\n        levdx = calcres(XParam.dx, XBlock.level[it]);\n        XzoneB.ymax = XParam.yo + XBlock.yo[it] + (XParam.blkwidth - 1) * levdx + levdx/2;\n\n\n        if (XParam.maxlevel != XParam.minlevel) //if adapatation\n        {\n\n            //This minimal rectangular can include only part of blocks depending of resolution.\n            //the blocks containing the corners are found and the larger block impose its border on each side\n\n            //In order of avoiding rounding error, a slightly smaller rectangular is used\n            RectCornerBlk(XParam, XBlock, XzoneB.xo, XzoneB.yo, XzoneB.xmax, XzoneB.ymax, true, cornerblk);\n\n\n            // for each side, the border is imposed by the larger block (the \"further out\" one) if adaptative,\n            // if the grid is.\n\n            //left edge border\n            int il = (XBlock.level[cornerblk[0]] &lt; XBlock.level[cornerblk[1]]) ? cornerblk[0] : cornerblk[1];\n            levdx = calcres(XParam.dx, XBlock.level[il]);\n            XzoneB.xo = XParam.xo + XBlock.xo[il] - levdx/2;\n            //bottom edge border\n            int ib = (XBlock.level[cornerblk[0]] &lt; XBlock.level[cornerblk[3]]) ? cornerblk[0] : cornerblk[3];\n            levdx = calcres(XParam.dx, XBlock.level[ib]);\n            XzoneB.yo = XParam.yo + XBlock.yo[ib] - levdx/2;\n            //right edge border\n            int ir = (XBlock.level[cornerblk[2]] &lt; XBlock.level[cornerblk[3]]) ? cornerblk[2] : cornerblk[3];\n            levdx = calcres(XParam.dx, XBlock.level[ir]);\n            XzoneB.xmax = XParam.xo + XBlock.xo[ir] + (XParam.blkwidth - 1) * levdx + levdx/2;\n            //top edge border\n            int it = (XBlock.level[cornerblk[1]] &lt; XBlock.level[cornerblk[2]]) ? cornerblk[1] : cornerblk[2];\n            levdx = calcres(XParam.dx, XBlock.level[it]);\n            XzoneB.ymax = XParam.yo + XBlock.yo[it] + (XParam.blkwidth - 1) * levdx + levdx/2;\n        }\n        */\n        // Get the list of all blocks in the zone and the maximum and minimum level of refinement\n        int maxlevel = XParam.minlevel;\n        int minlevel = XParam.maxlevel;\n\n        for (i = 0; i &lt; XParam.nblk; i++)\n        {\n            ib = XBlock.active[i];\n            levdx = calcres(XParam.dx, XBlock.level[ib]);\n\n            // get the corners' locations of the block (center of the corner cell)\n            xl = XParam.xo + XBlock.xo[ib];\n            yb = XParam.yo + XBlock.yo[ib];\n            xr = XParam.xo + XBlock.xo[ib] + (XParam.blkwidth - 1) * levdx;\n            yt = XParam.yo + XBlock.yo[ib] + (XParam.blkwidth - 1) * levdx;\n\n            // Checking if at least one part of the a cell of the block is \n            // inside the area defined by the user.\n            if (OBBdetect(xl, xr, yb, yt, Xzone.xstart, Xzone.xend, Xzone.ystart, Xzone.yend))\n            {\n                // This block belongs to the output zone defined by the user\n                blkzone.push_back(ib);\n                nblk++;\n\n                XzoneB.xo = min(XzoneB.xo,XParam.xo + XBlock.xo[ib] - levdx / 2);\n                XzoneB.xmax = max(XzoneB.xmax, XParam.xo + XBlock.xo[ib] + (XParam.blkwidth - 1) * levdx + levdx / 2);\n                XzoneB.yo = min(XzoneB.yo, XParam.yo + XBlock.yo[ib] - levdx / 2);\n                XzoneB.ymax = max(XzoneB.ymax, XParam.yo + XBlock.yo[ib] + (XParam.blkwidth - 1) * levdx + levdx / 2);\n\n                //min/max levels\n                if (XBlock.level[ib] &gt; maxlevel) { maxlevel = XBlock.level[ib]; }\n                if (XBlock.level[ib] &lt; minlevel) { minlevel = XBlock.level[ib]; }\n            }\n\n\n        }\n        XzoneB.nblk = nblk;\n        XzoneB.maxlevel = maxlevel;\n        XzoneB.minlevel = minlevel;\n\n\n        AllocateCPU(blkzone.size(), 1, XzoneB.blk);\n        for (int b = 0; b &lt; blkzone.size(); b++)\n        {\n            XzoneB.blk[b] = blkzone[b];\n        }\n        XzoneB.outname = XParam.outzone[o].outname;\n\n        //All the zone informatin has been integrated in a outzoneB structure,\n        // and pushed back to the initial variable.\n        // If this variable has already be constructed and adjusted here (after adaptation for example),\n        // just modify the variable\n\n        if (XBlock.outZone.size() &lt; XParam.outzone.size())\n        {\n            XBlock.outZone.push_back(XzoneB);\n        }\n        else\n        {\n            XBlock.outZone[o] = XzoneB;\n        }\n    }\n\n}\ntemplate void Findoutzoneblks&lt;float&gt;(Param&amp; XParam, BlockP&lt;float&gt;&amp; XBlock);\ntemplate void Findoutzoneblks&lt;double&gt;(Param&amp; XParam, BlockP&lt;double&gt;&amp; XBlock);\n\ntemplate &lt;class T&gt; void Initoutzone(Param&amp; XParam, BlockP&lt;T&gt;&amp; XBlock)\n{\n    //The domain full domain is defined as the output zone by default \n    //(and the blocks have been initialised by default)\n    // If a zone for the output has been requested by the user, the blocks in the \n    // zone and the corners are computed here:\n\n    if (XParam.outzone.size() &gt; 0)\n    {\n        XBlock.outZone.reserve(XParam.outzone.size()); //to avoid a change of location of memory if not enought space\n        Findoutzoneblks(XParam, XBlock);\n    }\n    else\n    {\n        outzoneB XzoneB;\n        std::vector&lt;int&gt; blksall;\n        //Define the full domain as a zone\n        XzoneB.outname = XParam.outfile; //.assign(XParam.outfile);\n        XzoneB.xo = XParam.xo;\n        XzoneB.yo = XParam.yo;\n        XzoneB.xmax = XParam.xmax;\n        XzoneB.ymax = XParam.ymax;\n        XzoneB.nblk = XParam.nblk;\n        XzoneB.maxlevel = XParam.maxlevel;\n        XzoneB.minlevel = XParam.minlevel;\n        XzoneB.OutputT = { XParam.totaltime, XParam.endtime };\n        AllocateCPU(XParam.nblk, 1, XzoneB.blk);\n        int I = 0;\n        for (int ib = 0; ib &lt; XParam.nblk; ib++)\n        {\n            XzoneB.blk[ib] = XBlock.active[ib];\n        }\n\n        if (XBlock.outZone.size() &gt; 0) //If adaptative, the zone need to be written over\n        {\n            XBlock.outZone[0] = XzoneB;\n        }\n        else\n        {\n            XBlock.outZone.push_back(XzoneB);\n        }\n\n    }\n}\ntemplate void Initoutzone&lt;float&gt;(Param&amp; XParam, BlockP&lt;float&gt;&amp; XBlock);\ntemplate void Initoutzone&lt;double&gt;(Param&amp; XParam, BlockP&lt;double&gt;&amp; XBlock);\n\n/*\n*  Initialise bnd blk assign block to their relevant segment allocate memory...\n* 1. Find all the boundary blocks(block with themselves as neighbours)\n*\n* 2. make an array to store which segemnt they belong to\n*\n* If any bnd segment was specified\n* 3. scan each block and find which (if any) segment they belong to\n*    For each segment\n*        Calculate bbox\n*        if inbbox calc inpoly\n*       if inpoly overwrite assingned segment with new one\n*\n*\n* 4. Calculate nblk per segment &amp; allocate (do for each segment)\n*\n* 5. fill segmnent and side arrays for each segments\n*/\ntemplate &lt;class T&gt; void Initbndblks(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing, BlockP&lt;T&gt; XBlock)\n{\n    //if(XForcing.bndseg.size()&gt;0)\n\n    std::vector&lt;int&gt; bndblks;\n    std::vector&lt;int&gt; bndsegment;\n    // 1. Find all the boundary blocks (block with themselves as neighbours)\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n\n        bool testbot = (XBlock.BotLeft[ib] == ib) || (XBlock.BotRight[ib] == ib) || (XBlock.TopLeft[ib] == ib) || (XBlock.TopRight[ib] == ib) || (XBlock.LeftTop[ib] == ib) || (XBlock.LeftBot[ib] == ib) || (XBlock.RightTop[ib] == ib) || (XBlock.RightBot[ib] == ib);\n        if (testbot)\n        {\n            T dxlev = calcres(XParam.dx, XBlock.level[ib]);\n\n            bndblks.push_back(ib);\n            bndsegment.push_back(XForcing.bndseg.size()-1); // i.e. by default the block doesn't belong to a segment so it belongs to collector (last) segemnt\n            //loop through all but the last bnd seg which is meant for block that are not in any segments\n            for (int s = 0; s &lt; XForcing.bndseg.size()-1; s++)\n            {\n                bool inpoly=blockinpoly(T(XParam.xo + XBlock.xo[ib]), T(XParam.yo + XBlock.yo[ib]), dxlev, XParam.blkwidth, XForcing.bndseg[s].poly);\n\n                if (inpoly)\n                {\n                    bndsegment.back() = s;\n                }\n\n            }\n\n\n\n        }\n\n\n    }\n\n\n    for (int s = 0; s &lt; XForcing.bndseg.size(); s++)\n    {\n        int segcount = 0;\n        int leftcount = 0;\n        int rightcount = 0;\n        int topcount = 0;\n        int botcount = 0;\n\n        for (int ibl = 0; ibl &lt; bndblks.size(); ibl++)\n        {\n            int ib = bndblks[ibl];\n            if (bndsegment[ibl] == s)\n            {\n                segcount++;\n\n                if ((XBlock.BotLeft[ib] == ib) || (XBlock.BotRight[ib] == ib))\n                {\n                    botcount++;\n                }\n                if ((XBlock.TopLeft[ib] == ib) || (XBlock.TopRight[ib] == ib))\n                {\n                    topcount++;\n                }\n                if ((XBlock.LeftBot[ib] == ib) || (XBlock.LeftTop[ib] == ib))\n                {\n                    leftcount++;\n                }\n                if ((XBlock.RightBot[ib] == ib) || (XBlock.RightTop[ib] == ib))\n                {\n                    rightcount++;\n                }\n            }\n        }\n        XForcing.bndseg[s].nblk = segcount;\n\n        log(\"\\nBoundary Segment \" + std::to_string(s) + \" : \" + XForcing.bndseg[s].inputfile + \" has \" + std::to_string(segcount) + \" blocks \");\n\n        XForcing.bndseg[s].left.nblk = leftcount;\n        XForcing.bndseg[s].right.nblk = rightcount;\n        XForcing.bndseg[s].top.nblk = topcount;\n        XForcing.bndseg[s].bot.nblk = botcount;\n\n        //allocate array\n        //ReallocArray(int nblk, int blksize, T * &amp;zb)\n        ReallocArray(leftcount, 1, XForcing.bndseg[s].left.blk);\n        ReallocArray(rightcount, 1, XForcing.bndseg[s].right.blk);\n        ReallocArray(topcount, 1, XForcing.bndseg[s].top.blk);\n        ReallocArray(botcount, 1, XForcing.bndseg[s].bot.blk);\n\n        ReallocArray(leftcount, XParam.blkwidth, XForcing.bndseg[s].left.qmean);\n        ReallocArray(rightcount, XParam.blkwidth, XForcing.bndseg[s].right.qmean);\n        ReallocArray(topcount, XParam.blkwidth, XForcing.bndseg[s].top.qmean);\n        ReallocArray(botcount, XParam.blkwidth, XForcing.bndseg[s].bot.qmean);\n\n        FillCPU(leftcount, XParam.blkwidth, 0.0f, XForcing.bndseg[s].left.qmean);\n        FillCPU(rightcount, XParam.blkwidth, 0.0f, XForcing.bndseg[s].right.qmean);\n        FillCPU(topcount, XParam.blkwidth, 0.0f, XForcing.bndseg[s].top.qmean);\n        FillCPU(botcount, XParam.blkwidth, 0.0f, XForcing.bndseg[s].bot.qmean);\n\n        leftcount = 0;\n        rightcount = 0;\n        topcount = 0;\n        botcount = 0;\n\n        for (int ibl = 0; ibl &lt; bndblks.size(); ibl++)\n        {\n            int ib = bndblks[ibl];\n\n            if (bndsegment[ibl] == s)\n            {\n                if ((XBlock.BotLeft[ib] == ib) || (XBlock.BotRight[ib] == ib))\n                {\n                    XForcing.bndseg[s].bot.blk[botcount] = ib;\n                    botcount++;\n                }\n                if ((XBlock.TopLeft[ib] == ib) || (XBlock.TopRight[ib] == ib))\n                {\n                    XForcing.bndseg[s].top.blk[topcount] = ib;\n                    topcount++;\n                }\n                if ((XBlock.LeftBot[ib] == ib) || (XBlock.LeftTop[ib] == ib))\n                {\n                    XForcing.bndseg[s].left.blk[leftcount] = ib;\n                    leftcount++;\n                }\n                if ((XBlock.RightBot[ib] == ib) || (XBlock.RightTop[ib] == ib))\n                {\n                    XForcing.bndseg[s].right.blk[rightcount] = ib;\n                    rightcount++;\n                }\n\n            }\n\n        }\n\n\n\n    }\n\n\n}\n\ntemplate &lt;class T&gt; void Calcbndblks(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing, BlockP&lt;T&gt; XBlock)\n{\n    //=====================================\n    // Find how many blocks are on each bnds\n    int blbr = 0, blbb = 0, blbl = 0, blbt = 0;\n    T leftxo, rightxo, topyo, botyo;\n\n    T initlevdx = calcres(XParam.dx, XParam.initlevel);\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //double espdist = 0.00000001;///WARMING\n\n        int ib = XBlock.active[ibl];\n\n        T levdx = calcres(XParam.dx, XBlock.level[ib]);\n\n        leftxo = XBlock.xo[ib]; // in adaptive this shoulbe be a range \n\n        //leftyo =XBlock.yo[ib];\n        rightxo = XBlock.xo[ib] + (XParam.blkwidth - 1) * levdx;\n        //rightyo = XBlock.yo[ib];\n        //topxo = XBlock.xo[ib];\n        topyo = XBlock.yo[ib] + (XParam.blkwidth - 1) * levdx;\n        //botxo = XBlock.xo[ib];\n        botyo = XBlock.yo[ib];\n\n        if ((rightxo - (XParam.xmax-XParam.xo)) &gt; (-1.0 * levdx))\n        {\n            //\n            blbr++;\n            //bndrightblk[blbr] = bl;\n\n        }\n\n        if ((topyo - (XParam.ymax - XParam.yo)) &gt; (-1.0 * levdx))\n        {\n            //\n            blbt++;\n            //bndtopblk[blbt] = bl;\n\n        }\n        if (botyo &lt; levdx)\n        {\n            //\n            blbb++;\n            //bndbotblk[blbb] = bl;\n\n        }\n        if (leftxo &lt; levdx)\n        {\n            //\n            blbl++;\n            //bndleftblk[blbl] = bl;\n\n        }\n    }\n\n    // fill\n    XForcing.left.nblk = blbl;\n    XForcing.right.nblk = blbr;\n    XForcing.top.nblk = blbt;\n    XForcing.bot.nblk = blbb;\n\n\n    XParam.nbndblkleft = blbl;\n    XParam.nbndblkright = blbr;\n    XParam.nbndblktop = blbt;\n    XParam.nbndblkbot = blbb;\n\n\n}\n\n\ntemplate &lt;class T&gt; void Findbndblks(Param XParam, Model&lt;T&gt; XModel,Forcing&lt;float&gt; &amp;XForcing)\n{\n    //=====================================\n    // Find how many blocks are on each bnds\n    int blbr = 0, blbb = 0, blbl = 0, blbt = 0;\n    BlockP&lt;T&gt; XBlock = XModel.blocks;\n    T initlevdx = calcres(XParam.dx, XParam.initlevel);\n    T leftxo, rightxo, topyo, botyo;\n\n\n    // Reallocate array if necessary\n    ReallocArray(XParam.nbndblkleft, 1, XForcing.left.blks);\n    ReallocArray(XParam.nbndblkright, 1, XForcing.right.blks);\n    ReallocArray(XParam.nbndblktop, 1, XForcing.top.blks);\n    ReallocArray(XParam.nbndblkbot, 1, XForcing.bot.blks);\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //double espdist = 0.00000001;///WARMING\n\n        int ib = XBlock.active[ibl];\n        T levdx = calcres(XParam.dx, XModel.blocks.level[ib]);\n\n\n        leftxo = XBlock.xo[ib]; // in adaptive this shoulbe be a range \n\n        //leftyo = XBlock.yo[ib];\n        rightxo = XBlock.xo[ib] + (XParam.blkwidth - 1) * levdx;\n        //rightyo = XBlock.yo[ib];\n        //topxo = XBlock.xo[ib];\n        topyo = XBlock.yo[ib] + (XParam.blkwidth - 1) * levdx;\n        //botxo = XBlock.xo[ib];\n        botyo = XBlock.yo[ib];\n\n        if ((rightxo - (XParam.xmax-XParam.xo)) &gt; (-1.0 * levdx))\n        {\n            //\n            XForcing.right.blks[blbr] = ib;\n            blbr++;\n\n        }\n\n        if ((topyo - (XParam.ymax-XParam.yo)) &gt; (-1.0 * levdx))\n        {\n            //\n            XForcing.top.blks[blbt] = ib;\n            blbt++;\n\n        }\n        if (botyo &lt; levdx)\n        {\n            //\n            XForcing.bot.blks[blbb] = ib;\n            blbb++;\n\n        }\n        if (leftxo &lt; levdx)\n        {\n            //\n            XForcing.left.blks[blbl] = ib;\n            blbl++;\n\n        }\n    }\n\n\n\n\n}\n\ntemplate &lt;class T&gt; void RectCornerBlk(Param&amp; XParam, BlockP&lt;T&gt;&amp; XBlock, double xo, double yo, double xmax, double ymax, bool isEps, std::vector&lt;int&gt;&amp; cornerblk)\n{\n\n    int ib;\n    T levdx;\n    double xl, yb, xr, yt;\n    double eps = 0.0;\n\n    for (int i = 0; i &lt; XParam.nblk; i++)\n    {\n        ib = XBlock.active[i];\n        levdx = calcres(XParam.dx, XBlock.level[ib]);\n\n        // margin to search for block boundaries, to avoid machine error if rectangle corner are supposed to\n        // be on blocks edges\n\n        if (isEps == true)\n        {\n            eps = levdx/3;\n        }\n\n        // get the corners' locations of the block (edge of the corner cell)\n        xl = XParam.xo + XBlock.xo[ib] - levdx/2;\n        yb = XParam.yo + XBlock.yo[ib] - levdx/2;\n        xr = XParam.xo + XBlock.xo[ib] + (XParam.blkwidth - 1) * levdx + levdx/2;\n        yt = XParam.yo + XBlock.yo[ib] + (XParam.blkwidth - 1) * levdx + levdx/2;\n\n        // Getting the bottom left corner coordinate of the output area\n        if (xo + eps &gt;= xl &amp;&amp; xo + eps &lt;= xr &amp;&amp; yo + eps &gt;= yb &amp;&amp; yo + eps &lt;= yt)\n        {\n            cornerblk[0] = ib;\n        }\n        // Getting the top left corner coordinate of the output area\n        if (xo + eps &gt;= xl &amp;&amp; xo + eps &lt;= xr &amp;&amp; ymax - eps &gt;= yb &amp;&amp; ymax - eps &lt;= yt)\n        {\n            cornerblk[1] = ib;\n        }\n        // Getting the top right corner coordinate of the output area\n        if (xmax - eps &gt;= xl &amp;&amp; xmax - eps &lt;= xr &amp;&amp; ymax - eps &gt;= yb &amp;&amp; ymax - eps &lt;= yt)\n        {\n            cornerblk[2] = ib;\n        }\n        // Getting the bottom right corner coordinate of the output area\n        if (xmax - eps &gt;= xl &amp;&amp; xmax - eps &lt;= xr &amp;&amp; yo + eps &gt;= yb &amp;&amp; yo + eps &lt;= yt)\n        {\n            cornerblk[3] = ib;\n        }\n\n    }\n\n}\n\ntemplate &lt;class T&gt; void calcactiveCellCPU(Param XParam, BlockP&lt;T&gt; XBlock, Forcing&lt;float&gt;&amp; XForcing, T* zb)\n{\n    int ib,n,wn;\n\n    // Remove rain from area above mask elevatio\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                double levdx = calcres(XParam.dx, XBlock.level[ib]);\n                double x = XParam.xo + XBlock.xo[ib] + i * levdx;\n                double y = XParam.yo + XBlock.yo[ib] + j * levdx;\n                wn = 1;\n                if (XForcing.AOI.active)\n                {\n                    wn = wn_PnPoly(x, y, XForcing.AOI.poly);\n                }\n                n = memloc(XParam, i, j, ib);\n                if (zb[n] &lt; XParam.mask &amp;&amp; wn != 0)\n                {\n                    XBlock.activeCell[n] = 1;\n                }\n                else\n                {\n                    XBlock.activeCell[n] = 0;\n                }\n            }\n        }\n    }\n\n    //bool Modif = false;\n    if (XParam.rainbnd== false) {\n        // Remove rain from boundary cells\n        for (int ibl = 0; ibl &lt; XParam.nbndblkleft; ibl++)\n        {\n            ib = XForcing.left.blks[ibl];\n            for (int j = 0; j &lt; XParam.blkwidth; j++)\n            {\n                n = memloc(XParam, 0, j, ib);\n                XBlock.activeCell[n] = 0;\n\n                n = memloc(XParam, 1, j, ib);\n                XBlock.activeCell[n] = 0;\n            }\n        }\n        for (int ibl = 0; ibl &lt; XParam.nbndblkright; ibl++)\n        {\n            ib = XForcing.right.blks[ibl];\n            for (int j = 0; j &lt; XParam.blkwidth; j++)\n            {\n                n = memloc(XParam, XParam.blkwidth - 1, j, ib);\n                XBlock.activeCell[n] = 0;\n\n                n = memloc(XParam, XParam.blkwidth - 2, j, ib);\n                XBlock.activeCell[n] = 0;\n            }\n        }\n        for (int ibl = 0; ibl &lt; XParam.nbndblkbot; ibl++)\n        {\n            ib = XForcing.bot.blks[ibl];\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                n = memloc(XParam, i, 0, ib);\n                XBlock.activeCell[n] = 0;\n\n                n = memloc(XParam, i, 1, ib);\n                XBlock.activeCell[n] = 0;\n            }\n        }\n        for (int ibl = 0; ibl &lt; XParam.nbndblktop; ibl++)\n        {\n            ib = XForcing.top.blks[ibl];\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                n = memloc(XParam, i, XParam.blkwidth - 1, ib);\n                XBlock.activeCell[n] = 0;\n\n                n = memloc(XParam, i, XParam.blkwidth - 2, ib);\n                XBlock.activeCell[n] = 0;\n            }\n        }\n    }\n\n}\n\n\ntemplate &lt;class T&gt; __global__ void calcactiveCellGPU(Param XParam, BlockP&lt;T&gt; XBlock, T *zb)\n{\n    unsigned int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n    unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int n = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n    if (zb[n] &lt; XParam.mask)\n    {\n        XBlock.activeCell[n] = 1;\n    }\n    else\n    {\n        XBlock.activeCell[n] = 0;\n    }\n}\n\ntemplate &lt;class T&gt; void initinfiltration(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* initLoss ,T* hgw)\n{\n//Initialisation to 0 (cold or hot start)\n\n\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n\n                if (h[n] &gt; XParam.eps)\n                {\n                    initLoss[n]=T(0.0);\n                }\n\n            }\n        }\n    }\n}\n\n// Create a vector of times steps from the input structure Toutput\nstd::vector&lt;double&gt; GetTimeOutput(T_output time_info)\n{\n    //std::vector&lt;double&gt; time_vect;\n    //double time;\n\n    //Add independant values\n    //if (!time_info.val.empty())\n    //{\n    //  time_vect = time_info.val;\n    //}\n\n    //Add timesteps from the vector \n    //time = time_info.init;\n    //while (time &lt; time_info.end)\n    //{\n    //  time_vect.push_back(time);\n    //  time += time_info.tstep;\n    //}\n\n    //Add last timesteps from the vector definition\n    //time_vect.push_back(time_info.end);\n\n    return(time_info.val);\n}\n\n\n\n// Creation of a vector for times requiering a map output\n// Compilations of vectors and independent times from the general input\n// and the different zones outputs\ntemplate &lt;class T&gt; void initOutputTimes(Param XParam, std::vector&lt;double&gt;&amp; OutputT, BlockP&lt;T&gt;&amp; XBlock)\n{\n    std::vector&lt;double&gt; times;\n    std::vector&lt;double&gt; times_partial;\n\n    times_partial = GetTimeOutput(XParam.Toutput);\n    //printf(\"Time partial:\\n\");\n    //for (int k = 0; k &lt; times_partial.size(); k++)\n    //{\n    //  printf(\"%f, \", times_partial[k]);\n    //}\n    //printf(\"\\n\");\n\n    times.insert(times.end(), times_partial.begin(), times_partial.end());\n\n    // if zoneOutputs, add their contribution\n    if (XParam.outzone.size() &gt; 0)\n    {\n        for (int ii = 0; ii &lt; XParam.outzone.size(); ii++)\n        {\n            times_partial = GetTimeOutput(XParam.outzone[ii].Toutput);\n\n            //Add to main vector\n            times.insert(times.end(), times_partial.begin(), times_partial.end());\n            //Sort and remove duplicate before saving in outZone struct\n            std::sort(times_partial.begin(), times_partial.end());\n            times_partial.erase(unique(times_partial.begin(), times_partial.end()), times_partial.end());\n\n            XBlock.outZone[ii].OutputT = times_partial;\n        }\n    }\n    else //If not zoneoutput, output zone saved in zoneoutput structure\n    {\n        std::sort(times_partial.begin(), times_partial.end());\n        times_partial.erase(unique(times_partial.begin(), times_partial.end()), times_partial.end());\n\n        XBlock.outZone[0].OutputT = times_partial;\n    }\n\n    // Sort the times for output\n    std::sort(times.begin(), times.end());\n    times.erase(unique(times.begin(), times.end()), times.end());\n\n    printf(\"Output Times:\\n\");\n    for (int k = 0; k &lt; times.size(); k++)\n    {\n        printf(\"%e, \", times[k]);\n    }\n    printf(\"\\n\");\n\n\n\n    OutputT = times;\n}\n</code></pre>"},{"location":"BGFlood/InitialConditions_8h/","title":"File InitialConditions.h","text":""},{"location":"BGFlood/InitialConditions_8h/#file-initialconditionsh","title":"File InitialConditions.h","text":"<p>FileList &gt; src &gt; InitialConditions.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"GridManip.h\"</code></li> <li><code>#include \"InitEvolv.h\"</code></li> <li><code>#include \"Gradients.h\"</code></li> <li><code>#include \"Spherical.h\"</code></li> </ul>"},{"location":"BGFlood/InitialConditions_8h/#public-functions","title":"Public Functions","text":"Type Name void Calcbndblks (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; T &gt; XBlock)  void FindTSoutNodes (Param &amp; XParam, BlockP&lt; T &gt; XBlock, BndblockP&lt; T &gt; &amp; bnd)  void Findbndblks (Param XParam, Model&lt; T &gt; XModel, Forcing&lt; float &gt; &amp; XForcing)  void InitRivers (Param XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel)  void InitTSOutput (Param XParam)  void InitialConditions (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel)  void Initmaparray (Model&lt; T &gt; &amp; XModel)  void Initoutzone (Param &amp; XParam, BlockP&lt; T &gt; &amp; XBlock)  void InitzbgradientCPU (Param XParam, Model&lt; T &gt; XModel)  void InitzbgradientGPU (Param XParam, Model&lt; T &gt; XModel)  void calcactiveCellCPU (Param XParam, BlockP&lt; T &gt; XBlock, Forcing&lt; float &gt; &amp; XForcing, T * zb)  void initOutputTimes (Param XParam, std::vector&lt; double &gt; &amp; OutputT, BlockP&lt; T &gt; &amp; XBlock)  void initoutput (Param &amp; XParam, Model&lt; T &gt; &amp; XModel)"},{"location":"BGFlood/InitialConditions_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/InitialConditions_8h/#function-calcbndblks","title":"function Calcbndblks","text":"<pre><code>template&lt;class T&gt;\nvoid Calcbndblks (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; T &gt; XBlock\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8h/#function-findtsoutnodes","title":"function FindTSoutNodes","text":"<pre><code>template&lt;class T&gt;\nvoid FindTSoutNodes (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; XBlock,\n    BndblockP &lt; T &gt; &amp; bnd\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8h/#function-findbndblks","title":"function Findbndblks","text":"<pre><code>template&lt;class T&gt;\nvoid Findbndblks (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre> <p>Find which block on the model edge belongs to a \"side boundary\" </p>"},{"location":"BGFlood/InitialConditions_8h/#function-initrivers","title":"function InitRivers","text":"<pre><code>template&lt;class T&gt;\nvoid InitRivers (\n    Param XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8h/#function-inittsoutput","title":"function InitTSOutput","text":"<pre><code>void InitTSOutput (\n    Param XParam\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8h/#function-initialconditions","title":"function InitialConditions","text":"<pre><code>template&lt;class T&gt;\nvoid InitialConditions (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8h/#function-initmaparray","title":"function Initmaparray","text":"<pre><code>template&lt;class T&gt;\nvoid Initmaparray (\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8h/#function-initoutzone","title":"function Initoutzone","text":"<pre><code>template&lt;class T&gt;\nvoid Initoutzone (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8h/#function-initzbgradientcpu","title":"function InitzbgradientCPU","text":"<pre><code>template&lt;class T&gt;\nvoid InitzbgradientCPU (\n    Param XParam,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8h/#function-initzbgradientgpu","title":"function InitzbgradientGPU","text":"<pre><code>template&lt;class T&gt;\nvoid InitzbgradientGPU (\n    Param XParam,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8h/#function-calcactivecellcpu","title":"function calcactiveCellCPU","text":"<pre><code>template&lt;class T&gt;\nvoid calcactiveCellCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    Forcing &lt; float &gt; &amp; XForcing,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8h/#function-initoutputtimes","title":"function initOutputTimes","text":"<pre><code>template&lt;class T&gt;\nvoid initOutputTimes (\n    Param XParam,\n    std::vector&lt; double &gt; &amp; OutputT,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/InitialConditions_8h/#function-initoutput","title":"function initoutput","text":"<pre><code>template&lt;class T&gt;\nvoid initoutput (\n    Param &amp; XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/InitialConditions.h</code></p>"},{"location":"BGFlood/InitialConditions_8h_source/","title":"File InitialConditions.h","text":""},{"location":"BGFlood/InitialConditions_8h_source/#file-initialconditionsh","title":"File InitialConditions.h","text":"<p>File List &gt; src &gt; InitialConditions.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef INITIALCONDITION_H\n#define INITIALCONDITION_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"Write_txtlog.h\"\n#include \"GridManip.h\"\n#include \"InitEvolv.h\"\n#include \"Gradients.h\"\n#include \"Spherical.h\"\n\n\ntemplate &lt;class T&gt; void InitialConditions(Param &amp;XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;T&gt; &amp;XModel);\n\ntemplate &lt;class T&gt; void InitRivers(Param XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;T&gt; &amp;XModel);\ntemplate&lt;class T&gt; void Initmaparray(Model&lt;T&gt; &amp;XModel);\ntemplate &lt;class T&gt; void initoutput(Param &amp;XParam, Model&lt;T&gt;&amp; XModel);\nvoid InitTSOutput(Param XParam);\n//template &lt;class T&gt; void Initbnds(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel);\n\ntemplate &lt;class T&gt; void FindTSoutNodes(Param&amp; XParam, BlockP&lt;T&gt; XBlock, BndblockP&lt;T&gt;&amp; bnd);\ntemplate &lt;class T&gt; void Calcbndblks(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing, BlockP&lt;T&gt; XBlock);\ntemplate &lt;class T&gt; void Findbndblks(Param XParam, Model&lt;T&gt; XModel, Forcing&lt;float&gt;&amp; XForcing);\ntemplate &lt;class T&gt; void Initoutzone(Param&amp; XParam, BlockP&lt;T&gt;&amp; XBlock);\n\ntemplate &lt;class T&gt; void InitzbgradientCPU(Param XParam, Model&lt;T&gt; XModel);\ntemplate &lt;class T&gt; void InitzbgradientGPU(Param XParam, Model&lt;T&gt; XModel);\n\ntemplate &lt;class T&gt; void calcactiveCellCPU(Param XParam, BlockP&lt;T&gt; XBlock, Forcing&lt;float&gt;&amp; XForcing, T* zb);\n\ntemplate &lt;class T&gt; void initOutputTimes(Param XParam, std::vector&lt;double&gt;&amp; OutputT, BlockP&lt;T&gt;&amp; XBlock);\n// End of global definition;\n#endif\n</code></pre>"},{"location":"BGFlood/Input_8h/","title":"File Input.h","text":""},{"location":"BGFlood/Input_8h/#file-inputh","title":"File Input.h","text":"<p>FileList &gt; src &gt; Input.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> </ul>"},{"location":"BGFlood/Input_8h/#classes","title":"Classes","text":"Type Name class Flowin class Mapparam class Pointout class Polygon class River class SLTS class TSoutnode class T_output class Vertex class Windin class inputmap class outzoneP <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/Input_8h_source/","title":"File Input.h","text":""},{"location":"BGFlood/Input_8h_source/#file-inputh","title":"File Input.h","text":"<p>File List &gt; src &gt; Input.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef INPUT_H\n#define INPUT_H\n\n#include \"General.h\"\n\n// Timeseries output\nclass TSoutnode {\npublic:\n    int i, j, block;\n    double x, y;\n    std::string outname;\n};\n\n// Flexible definition of time outputs\nclass T_output {\npublic: \n    double init = NAN;\n    double tstep = NAN;\n    double end = NAN;\n    std::vector&lt;std::string&gt; inputstr;\n    std::vector&lt;double&gt; val;\n};\n\n// Special output zones for nc files, informatin given by the user\nclass outzoneP {\npublic:\n    //std::vector&lt;int&gt; blocks; // one zone will spread across multiple blocks (entire blocks containing a part of the area will be output)\n    double xstart, xend, ystart, yend; // definition of the zone needed for special nc output (rectangular zone) by the user\n    //double xo, xmax, yo, ymax; // Real zone for output (because we output full blocks)\n    std::string outname; // name for the output file (one for each zone)\n    T_output Toutput; // time for outputs for the zone\n};\n\nclass Flowin {\npublic:\n    double time, q;\n};\n\nclass Mapparam {\npublic:\n\n};\n\nclass River {\npublic:\n    std::vector&lt;int&gt; i, j, block; // one river can spring across multiple cells\n    double disarea; // discharge area\n    double xstart,xend, ystart,yend; // location of the discharge as a rectangle\n    double to, tmax;\n    std::string Riverflowfile; // river flow input time[s] flow in m3/s\n    std::vector&lt;Flowin&gt; flowinput; // vector to store the data of the river flow input file\n\n};\n\nclass inputmap {\npublic:\n    int nx = 0;\n    int ny= 0;\n    double xo = 0.0;\n    double yo = 0.0;\n    double xmax = 0.0;\n    double ymax = 0.0;\n    double dx = 0.0;\n    double dy = 0.0;\n    double grdalpha=0.0;\n    double denanval = NAN;\n    bool flipxx = false;\n    bool flipyy = false;\n    std::string inputfile;\n    std::string extension;\n    std::string varname;\n};\n\nclass SLTS {\npublic:\n    double time;\n    std::vector&lt;double&gt; wlevs;\n    std::vector&lt;double&gt; uuvel;\n    std::vector&lt;double&gt; vvvel;\n\n};\n\nclass Windin {\npublic:\n    double time;\n    double wspeed;\n    double wdirection;\n    double uwind;\n    double vwind;\n\n\n};\n\n\n// used as vector class to store Time series outputs\nclass Pointout {\npublic:\n    double time, zs, h, u,v;\n};\n\nclass Vertex {\npublic:\n    double x, y;\n};\n\nclass Polygon {\npublic:\n    double xmin, xmax, ymin, ymax;\n    std::vector&lt;Vertex&gt; vertices;\n};\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/","title":"File Kurganov.cu","text":""},{"location":"BGFlood/Kurganov_8cu/#file-kurganovcu","title":"File Kurganov.cu","text":"<p>FileList &gt; src &gt; Kurganov.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Kurganov.h\"</code></li> </ul>"},{"location":"BGFlood/Kurganov_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ void AddSlopeSourceXCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * zb)  template __host__ void AddSlopeSourceXCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * zb)  template __host__ void AddSlopeSourceXCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * zb)  __global__ void AddSlopeSourceXGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * zb)  template __global__ void AddSlopeSourceXGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * zb)  template __global__ void AddSlopeSourceXGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * zb)  __host__ void AddSlopeSourceYCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * zb)  template __host__ void AddSlopeSourceYCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * zb)  template __host__ void AddSlopeSourceYCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * zb)  __global__ void AddSlopeSourceYGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * zb)  template __global__ void AddSlopeSourceYGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * zb)  template __global__ void AddSlopeSourceYGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * zb)  __host__ __device__ T KurgSolver (T g, T delta, T epsi, T CFL, T cm, T fm, T hp, T hm, T up, T um, T &amp; fh, T &amp; fu)  __host__ void updateKurgXATMCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb, T * Patm, T * dPdx)  template __host__ void updateKurgXATMCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb, double * Patm, double * dPdx)  template __host__ void updateKurgXATMCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb, float * Patm, float * dPdx)  __global__ void updateKurgXATMGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb, T * Patm, T * dPdx)  template __global__ void updateKurgXATMGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb, double * Patm, double * dPdx)  template __global__ void updateKurgXATMGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb, float * Patm, float * dPdx)  __host__ void updateKurgXCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb)  template __host__ void updateKurgXCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb)  template __host__ void updateKurgXCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb)  __global__ void updateKurgXGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb)  template __global__ void updateKurgXGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb)  template __global__ void updateKurgXGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb)  __host__ void updateKurgYATMCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb, T * Patm, T * dPdy)  template __host__ void updateKurgYATMCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb, double * Patm, double * dPdy)  template __host__ void updateKurgYATMCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb, float * Patm, float * dPdy)  __global__ void updateKurgYATMGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb, T * Patm, T * dPdy)  template __global__ void updateKurgYATMGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb, double * Patm, double * dPdy)  template __global__ void updateKurgYATMGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb, float * Patm, float * dPdy)  __host__ void updateKurgYCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb)  template __host__ void updateKurgYCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb)  template __host__ void updateKurgYCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb)  __global__ void updateKurgYGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb)  template __global__ void updateKurgYGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb)  template __global__ void updateKurgYGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb)"},{"location":"BGFlood/Kurganov_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Kurganov_8cu/#function-addslopesourcexcpu","title":"function AddSlopeSourceXCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AddSlopeSourceXCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-addslopesourcexcpu-double","title":"function AddSlopeSourceXCPU&lt; double &gt;","text":"<pre><code>template __host__ void AddSlopeSourceXCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-addslopesourcexcpu-float","title":"function AddSlopeSourceXCPU&lt; float &gt;","text":"<pre><code>template __host__ void AddSlopeSourceXCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-addslopesourcexgpu","title":"function AddSlopeSourceXGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AddSlopeSourceXGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-addslopesourcexgpu-double","title":"function AddSlopeSourceXGPU&lt; double &gt;","text":"<pre><code>template __global__ void AddSlopeSourceXGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-addslopesourcexgpu-float","title":"function AddSlopeSourceXGPU&lt; float &gt;","text":"<pre><code>template __global__ void AddSlopeSourceXGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-addslopesourceycpu","title":"function AddSlopeSourceYCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AddSlopeSourceYCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-addslopesourceycpu-double","title":"function AddSlopeSourceYCPU&lt; double &gt;","text":"<pre><code>template __host__ void AddSlopeSourceYCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-addslopesourceycpu-float","title":"function AddSlopeSourceYCPU&lt; float &gt;","text":"<pre><code>template __host__ void AddSlopeSourceYCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-addslopesourceygpu","title":"function AddSlopeSourceYGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AddSlopeSourceYGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-addslopesourceygpu-double","title":"function AddSlopeSourceYGPU&lt; double &gt;","text":"<pre><code>template __global__ void AddSlopeSourceYGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-addslopesourceygpu-float","title":"function AddSlopeSourceYGPU&lt; float &gt;","text":"<pre><code>template __global__ void AddSlopeSourceYGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-kurgsolver","title":"function KurgSolver","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T KurgSolver (\n    T g,\n    T delta,\n    T epsi,\n    T CFL,\n    T cm,\n    T fm,\n    T hp,\n    T hm,\n    T up,\n    T um,\n    T &amp; fh,\n    T &amp; fu\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgxatmcpu","title":"function updateKurgXATMCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void updateKurgXATMCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb,\n    T * Patm,\n    T * dPdx\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgxatmcpu-double","title":"function updateKurgXATMCPU&lt; double &gt;","text":"<pre><code>template __host__ void updateKurgXATMCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb,\n    double * Patm,\n    double * dPdx\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgxatmcpu-float","title":"function updateKurgXATMCPU&lt; float &gt;","text":"<pre><code>template __host__ void updateKurgXATMCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb,\n    float * Patm,\n    float * dPdx\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgxatmgpu","title":"function updateKurgXATMGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void updateKurgXATMGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb,\n    T * Patm,\n    T * dPdx\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgxatmgpu-double","title":"function updateKurgXATMGPU&lt; double &gt;","text":"<pre><code>template __global__ void updateKurgXATMGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb,\n    double * Patm,\n    double * dPdx\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgxatmgpu-float","title":"function updateKurgXATMGPU&lt; float &gt;","text":"<pre><code>template __global__ void updateKurgXATMGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb,\n    float * Patm,\n    float * dPdx\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgxcpu","title":"function updateKurgXCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void updateKurgXCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgxcpu-double","title":"function updateKurgXCPU&lt; double &gt;","text":"<pre><code>template __host__ void updateKurgXCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgxcpu-float","title":"function updateKurgXCPU&lt; float &gt;","text":"<pre><code>template __host__ void updateKurgXCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgxgpu","title":"function updateKurgXGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void updateKurgXGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgxgpu-double","title":"function updateKurgXGPU&lt; double &gt;","text":"<pre><code>template __global__ void updateKurgXGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgxgpu-float","title":"function updateKurgXGPU&lt; float &gt;","text":"<pre><code>template __global__ void updateKurgXGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgyatmcpu","title":"function updateKurgYATMCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void updateKurgYATMCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb,\n    T * Patm,\n    T * dPdy\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgyatmcpu-double","title":"function updateKurgYATMCPU&lt; double &gt;","text":"<pre><code>template __host__ void updateKurgYATMCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb,\n    double * Patm,\n    double * dPdy\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgyatmcpu-float","title":"function updateKurgYATMCPU&lt; float &gt;","text":"<pre><code>template __host__ void updateKurgYATMCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb,\n    float * Patm,\n    float * dPdy\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgyatmgpu","title":"function updateKurgYATMGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void updateKurgYATMGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb,\n    T * Patm,\n    T * dPdy\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgyatmgpu-double","title":"function updateKurgYATMGPU&lt; double &gt;","text":"<pre><code>template __global__ void updateKurgYATMGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb,\n    double * Patm,\n    double * dPdy\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgyatmgpu-float","title":"function updateKurgYATMGPU&lt; float &gt;","text":"<pre><code>template __global__ void updateKurgYATMGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb,\n    float * Patm,\n    float * dPdy\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgycpu","title":"function updateKurgYCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void updateKurgYCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgycpu-double","title":"function updateKurgYCPU&lt; double &gt;","text":"<pre><code>template __host__ void updateKurgYCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgycpu-float","title":"function updateKurgYCPU&lt; float &gt;","text":"<pre><code>template __host__ void updateKurgYCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgygpu","title":"function updateKurgYGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void updateKurgYGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgygpu-double","title":"function updateKurgYGPU&lt; double &gt;","text":"<pre><code>template __global__ void updateKurgYGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8cu/#function-updatekurgygpu-float","title":"function updateKurgYGPU&lt; float &gt;","text":"<pre><code>template __global__ void updateKurgYGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Kurganov.cu</code></p>"},{"location":"BGFlood/Kurganov_8cu_source/","title":"File Kurganov.cu","text":""},{"location":"BGFlood/Kurganov_8cu_source/#file-kurganovcu","title":"File Kurganov.cu","text":"<p>File List &gt; src &gt; Kurganov.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Kurganov.h\"\n\n\ntemplate &lt;class T&gt; __global__ void updateKurgXGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T*zb)\n{\n\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int RB, LBRB, LB, RBLB, levRB, levLB;\n    RB = XBlock.RightBot[ib];\n    levRB = XBlock.level[RB];\n    LBRB = XBlock.LeftBot[RB];\n\n    LB = XBlock.LeftBot[ib];\n    levLB = XBlock.level[LB];\n    RBLB = XBlock.RightBot[LB];\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps)+epsi;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n    // This is based on kurganov and Petrova 2007\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix-1, iy, ib);\n\n    T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n    T dhdxi = XGrad.dhdx[i];\n    T dhdxmin = XGrad.dhdx[ileft];\n    T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T fmu = T(1.0);\n\n    T hi = XEv.h[i];\n\n    T hn = XEv.h[ileft];\n\n\n    if (hi &gt; eps || hn &gt; eps)\n    {\n        T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm, sl, sr,ga;\n\n        // along X\n        dx = delta * T(0.5);\n        zi = XEv.zs[i] - hi;\n\n        //printf(\"%f\\n\", zi);\n\n\n        //zl = zi - dx*(dzsdx[i] - dhdx[i]);\n        zl = zi - dx * (XGrad.dzsdx[i] - dhdxi);\n        //printf(\"%f\\n\", zl);\n\n        zn = XEv.zs[ileft] - hn;\n\n        //printf(\"%f\\n\", zn);\n        zr = zn + dx * (XGrad.dzsdx[ileft] - dhdxmin);\n\n\n        zlr = max(zl, zr);\n\n        //hl = hi - dx*dhdx[i];\n        hl = hi - dx * dhdxi;\n        up = XEv.u[i] - dx * XGrad.dudx[i];\n        hp = max(T(0.0), hl + zl - zlr);\n\n        hr = hn + dx * dhdxmin;\n        um = XEv.u[ileft] + dx * XGrad.dudx[ileft];\n        hm = max(T(0.0), hr + zr - zlr);\n\n        ga = g * T(0.5);\n\n        T fh, fu, fv, dt;\n\n\n        //solver below also modifies fh and fu\n        dt = KurgSolver(g, delta, epsi, CFL, cm, fmu, hp, hm, up, um, fh, fu);\n\n        if (dt &lt; dtmax[i])\n        {\n            dtmax[i] = dt;\n        }\n\n\n\n\n        if (fh &gt; T(0.0))\n        {\n            fv = (XEv.v[ileft] + dx * XGrad.dvdx[ileft]) * fh;// Eq 3.7 third term? (X direction)\n        }\n        else\n        {\n            fv = (XEv.v[i] - dx * XGrad.dvdx[i]) * fh;\n        }\n        //fv = (fh &gt; 0.f ? vv[xminus + iy*nx] + dx*dvdx[xminus + iy*nx] : vv[i] - dx*dvdx[i])*fh;\n        //dtmax needs to be stored in an array and reduced at the end\n        //dtmax = dtmaxf;\n        //dtmaxtmp = min(dtmax, dtmaxtmp);\n        /*if (ix == 11 &amp;&amp; iy == 0)\n        {\n            printf(\"a=%f\\t b=%f\\t c=%f\\t d=%f\\n\", ap*(qm*um + ga*hm2), -am*(qp*up + ga*hp2),( ap*(qm*um + g*sq(hm) / 2.0f) - am*(qp*up + g*sq(hp) / 2.0f) + ap*am*(qp - qm) ) *ad/100.0f, ad);\n        }\n        */\n        /*\n        #### Topographic source term\n\n        In the case of adaptive refinement, care must be taken to ensure\n        well-balancing at coarse/fine faces (see [notes/balanced.tm]()). */\n        if ((ix == blockDim.y) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = LBRB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n            int iright = memloc(halowidth, blkmemwidth, 0, jj, RB);;\n            hi = XEv.h[iright];\n            zi = zb[iright];\n        }\n        if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = RBLB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n            int ilc = memloc(halowidth, blkmemwidth, blockDim.y - 1, jj, LB);\n            hn = XEv.h[ilc];\n            zn = zb[ilc];\n        }\n\n        sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n        sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n        XFlux.Fhu[i] = fmu * fh;\n        XFlux.Fqux[i] = fmu * (fu - sl);\n        XFlux.Su[i] = fmu * (fu - sr);\n        XFlux.Fqvx[i] = fmu * fv;\n    }\n    else\n    {\n        dtmax[i] = T(1.0) / epsi;\n        XFlux.Fhu[i] = T(0.0);\n        XFlux.Fqux[i] = T(0.0);\n        XFlux.Su[i] = T(0.0);\n        XFlux.Fqvx[i] = T(0.0);\n    }\n\n\n\n\n}\ntemplate __global__ void updateKurgXGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb);\ntemplate __global__ void updateKurgXGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double *zb);\n\ntemplate &lt;class T&gt; __global__ void updateKurgXATMGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb, T* Patm, T*dPdx)\n{\n\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int RB, LBRB, LB, RBLB, levRB, levLB;\n    RB = XBlock.RightBot[ib];\n    levRB = XBlock.level[RB];\n    LBRB = XBlock.LeftBot[RB];\n\n    LB = XBlock.LeftBot[ib];\n    levLB = XBlock.level[LB];\n    RBLB = XBlock.RightBot[LB];\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n    // This is based on kurganov and Petrova 2007\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n    T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n\n    T dhdxi = XGrad.dhdx[i];\n    T dhdxmin = XGrad.dhdx[ileft];\n    T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T fmu = T(1.0);\n\n    T hi = XEv.h[i];\n\n    T hn = XEv.h[ileft];\n\n\n    if (hi &gt; eps || hn &gt; eps)\n    {\n        T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm, sl, sr, ga;\n\n        // along X\n        dx = delta * T(0.5);\n        zi = XEv.zs[i] - hi + XParam.Pa2m * Patm[i];\n\n        //printf(\"%f\\n\", zi);\n\n\n        //zl = zi - dx*(dzsdx[i] - dhdx[i]);\n        zl = zi - dx * (XGrad.dzsdx[i] - dhdxi + XParam.Pa2m * dPdx[i]);\n        //printf(\"%f\\n\", zl);\n\n        zn = XEv.zs[ileft] - hn + XParam.Pa2m * Patm[ileft];\n\n        //printf(\"%f\\n\", zn);\n        zr = zn + dx * (XGrad.dzsdx[ileft] - dhdxmin + XParam.Pa2m * dPdx[ileft]);\n\n\n        zlr = max(zl, zr);\n\n        //hl = hi - dx*dhdx[i];\n        hl = hi - dx * dhdxi;\n        up = XEv.u[i] - dx * XGrad.dudx[i];\n        hp = max(T(0.0), hl + zl - zlr);\n\n        hr = hn + dx * dhdxmin;\n        um = XEv.u[ileft] + dx * XGrad.dudx[ileft];\n        hm = max(T(0.0), hr + zr - zlr);\n\n        ga = g * T(0.5);\n\n        T fh, fu, fv, dt;\n\n\n        //solver below also modifies fh and fu\n        dt = KurgSolver(g, delta, epsi, CFL, cm, fmu, hp, hm, up, um, fh, fu);\n\n        if (dt &lt; dtmax[i])\n        {\n            dtmax[i] = dt;\n        }\n\n\n\n\n        if (fh &gt; T(0.0))\n        {\n            fv = (XEv.v[ileft] + dx * XGrad.dvdx[ileft]) * fh;// Eq 3.7 third term? (X direction)\n        }\n        else\n        {\n            fv = (XEv.v[i] - dx * XGrad.dvdx[i]) * fh;\n        }\n        //fv = (fh &gt; 0.f ? vv[xminus + iy*nx] + dx*dvdx[xminus + iy*nx] : vv[i] - dx*dvdx[i])*fh;\n        //dtmax needs to be stored in an array and reduced at the end\n        //dtmax = dtmaxf;\n        //dtmaxtmp = min(dtmax, dtmaxtmp);\n        /*if (ix == 11 &amp;&amp; iy == 0)\n        {\n            printf(\"a=%f\\t b=%f\\t c=%f\\t d=%f\\n\", ap*(qm*um + ga*hm2), -am*(qp*up + ga*hp2),( ap*(qm*um + g*sq(hm) / 2.0f) - am*(qp*up + g*sq(hp) / 2.0f) + ap*am*(qp - qm) ) *ad/100.0f, ad);\n        }\n        */\n        /*\n        #### Topographic source term\n\n        In the case of adaptive refinement, care must be taken to ensure\n        well-balancing at coarse/fine faces (see [notes/balanced.tm]()). */\n        if ((ix == blockDim.y) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = LBRB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n            int iright = memloc(halowidth, blkmemwidth, 0, jj, RB);;\n            hi = XEv.h[iright];\n            zi = zb[iright] + XParam.Pa2m * Patm[iright];\n        }\n        if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = RBLB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n            int ilc = memloc(halowidth, blkmemwidth, blockDim.y - 1, jj, LB);\n            hn = XEv.h[ilc];\n            zn = zb[ilc] + XParam.Pa2m * Patm[ilc];\n        }\n\n        sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n        sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n        XFlux.Fhu[i] = fmu * fh;\n        XFlux.Fqux[i] = fmu * (fu - sl);\n        XFlux.Su[i] = fmu * (fu - sr);\n        XFlux.Fqvx[i] = fmu * fv;\n    }\n    else\n    {\n        dtmax[i] = T(1.0) / epsi;\n        XFlux.Fhu[i] = T(0.0);\n        XFlux.Fqux[i] = T(0.0);\n        XFlux.Su[i] = T(0.0);\n        XFlux.Fqvx[i] = T(0.0);\n    }\n\n\n\n\n}\ntemplate __global__ void updateKurgXATMGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb, float* Patm, float* dPdx);\ntemplate __global__ void updateKurgXATMGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double* zb, double* Patm, double* dPdx);\n\n\ntemplate &lt;class T&gt; __global__ void AddSlopeSourceXGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T * zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n    // neighbours for source term\n    int RB, LBRB, LB, RBLB, levRB, levLB;\n    RB = XBlock.RightBot[ib];\n    levRB = XBlock.level[RB];\n    LBRB = XBlock.LeftBot[RB];\n\n    LB = XBlock.LeftBot[ib];\n    levLB = XBlock.level[LB];\n    RBLB = XBlock.RightBot[LB];\n\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n\n    T ga = T(0.5) * g;\n\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n\n    T dhdxi = XGrad.dhdx[i];\n    T dhdxmin = XGrad.dhdx[ileft];\n    //T cm = T(1.0);\n    T fmu = T(1.0);\n\n    T dx, zi, zl, zn, zr, zlr, hl, hp, hr, hm;\n\n    T hi = XEv.h[i];\n\n    T hn = XEv.h[ileft];\n\n    if (hi &gt; eps || hn &gt; eps)\n    {\n\n        // along X these are same as in Kurgannov\n        dx = delta * T(0.5);\n        zi = XEv.zs[i] - hi;\n\n        zl = zi - dx * (XGrad.dzsdx[i] - dhdxi);\n\n        zn = XEv.zs[ileft] - hn;\n\n        zr = zn + dx * (XGrad.dzsdx[ileft] - dhdxmin);\n\n        zlr = max(zl, zr);\n\n        hl = hi - dx * dhdxi;\n        hp = max(T(0.0), hl + zl - zlr);\n\n        hr = hn + dx * dhdxmin;\n        hm = max(T(0.0), hr + zr - zlr);\n\n\n        //#### Topographic source term\n        //In the case of adaptive refinement, care must be taken to ensure\n        //  well - balancing at coarse / fine faces(see[notes / balanced.tm]()). * /\n\n        if ((ix == blockDim.y) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = LBRB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n            int iright = memloc(halowidth, blkmemwidth, 0, jj, RB);;\n            hi = XEv.h[iright];\n            zi = zb[iright];\n        }\n        if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = RBLB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n            int ilc = memloc(halowidth, blkmemwidth, blockDim.y - 1, jj, LB);\n            hn = XEv.h[ilc];\n            zn = zb[ilc];\n        }\n\n        T sl, sr;\n        sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n        sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n        XFlux.Fqux[i] = XFlux.Fqux[i] - fmu * sl;\n        XFlux.Su[i] = XFlux.Su[i] - fmu * sr;\n    }\n}\ntemplate __global__ void AddSlopeSourceXGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* zb);\ntemplate __global__ void AddSlopeSourceXGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* zb);\n\ntemplate &lt;class T&gt; __host__ void updateKurgXCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T*zb)\n{\n\n\n    T delta;\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps)+epsi;\n    T ybo;\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    int RB, LBRB, LB, RBLB, levRB, levLB;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        int lev = XBlock.level[ib];\n        delta = calcres(T(XParam.delta), lev);\n\n        ybo = T(XParam.yo + XBlock.yo[ib]);\n\n        // neighbours for source term\n\n        RB = XBlock.RightBot[ib];\n        levRB = XBlock.level[RB];\n        LBRB = XBlock.LeftBot[RB];\n\n        LB = XBlock.LeftBot[ib];\n        levLB = XBlock.level[LB];\n        RBLB = XBlock.RightBot[LB];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth + XParam.halowidth); ix++)\n            {\n\n\n\n\n                // This is based on kurganov and Petrova 2007\n\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n\n                T dhdxi = XGrad.dhdx[i];\n                T dhdxmin = XGrad.dhdx[ileft];\n                T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);;\n                T fmu = T(1.0);\n\n                T hi = XEv.h[i];\n\n                T hn = XEv.h[ileft];\n\n\n                if (hi &gt; eps || hn &gt; eps)\n                {\n                    T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm,ga;\n\n                    // along X\n                    dx = delta * T(0.5);\n                    zi = XEv.zs[i] - hi;\n\n                    //printf(\"%f\\n\", zi);\n\n\n                    //zl = zi - dx*(dzsdx[i] - dhdx[i]);\n                    zl = zi - dx * (XGrad.dzsdx[i] - dhdxi);\n                    //printf(\"%f\\n\", zl);\n\n                    zn = XEv.zs[ileft] - hn;\n\n                    //printf(\"%f\\n\", zn);\n                    zr = zn + dx * (XGrad.dzsdx[ileft] - dhdxmin);\n\n\n                    zlr = max(zl, zr);\n\n                    //hl = hi - dx*dhdx[i];\n                    hl = hi - dx * dhdxi;\n                    up = XEv.u[i] - dx * XGrad.dudx[i];\n                    hp = max(T(0.0), hl + zl - zlr);\n\n                    hr = hn + dx * dhdxmin;\n                    um = XEv.u[ileft] + dx * XGrad.dudx[ileft];\n                    hm = max(T(0.0), hr + zr - zlr);\n\n                    ga = g * T(0.5);\n                    T fh, fu, fv, sl, sr, dt;\n\n                    //solver below also modifies fh and fu\n                    dt = KurgSolver(g, delta, epsi, CFL, cm, fmu, hp, hm, up, um, fh, fu);\n\n                    if (dt &lt; dtmax[i])\n                    {\n                        dtmax[i] = dt;\n                    }\n\n\n\n\n                    if (fh &gt; T(0.0))\n                    {\n                        fv = (XEv.v[ileft] + dx * XGrad.dvdx[ileft]) * fh;// Eq 3.7 third term? (X direction)\n                    }\n                    else\n                    {\n                        fv = (XEv.v[i] - dx * XGrad.dvdx[i]) * fh;\n                    }\n                    //fv = (fh &gt; 0.f ? vv[xminus + iy*nx] + dx*dvdx[xminus + iy*nx] : vv[i] - dx*dvdx[i])*fh;\n                    //dtmax needs to be stored in an array and reduced at the end\n                    //dtmax = dtmaxf;\n                    //dtmaxtmp = min(dtmax, dtmaxtmp);\n                    /*if (ix == 11 &amp;&amp; iy == 0)\n                    {\n                        printf(\"a=%f\\t b=%f\\t c=%f\\t d=%f\\n\", ap*(qm*um + ga*hm2), -am*(qp*up + ga*hp2),( ap*(qm*um + g*sq(hm) / 2.0f) - am*(qp*up + g*sq(hp) / 2.0f) + ap*am*(qp - qm) ) *ad/100.0f, ad);\n                    }\n                    */\n                    /*\n                    #### Topographic source term\n\n                    In the case of adaptive refinement, care must be taken to ensure\n                    well-balancing at coarse/fine faces (see [notes/balanced.tm]()). */\n\n                    if ((ix == XParam.blkwidth) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n                    {\n                        int jj = LBRB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n                        int iright = memloc(halowidth, blkmemwidth, 0, jj, RB);;\n                        hi = XEv.h[iright];\n                        zi = zb[iright];\n                    }\n                    if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo if you \n                    {\n                        int jj = RBLB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n                        int ilc = memloc(halowidth, blkmemwidth, XParam.blkwidth - 1, jj, LB);\n                        //int ilc = memloc(halowidth, blkmemwidth, -1, iy, ib);\n                        hn = XEv.h[ilc];\n                        zn = zb[ilc];\n                    }\n\n                    sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n                    sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n                    XFlux.Fhu[i] = fmu * fh;\n                    XFlux.Fqux[i] = fmu * (fu - sl);\n                    XFlux.Su[i] = fmu * (fu - sr);\n                    XFlux.Fqvx[i] = fmu * fv;\n                }\n                else\n                {\n                    dtmax[i] = T(1.0) / epsi;\n                    XFlux.Fhu[i] = T(0.0);\n                    XFlux.Fqux[i] = T(0.0);\n                    XFlux.Su[i] = T(0.0);\n                    XFlux.Fqvx[i] = T(0.0);\n                }\n\n            }\n        }\n    }\n\n\n}\ntemplate __host__ void updateKurgXCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float *zb);\ntemplate __host__ void updateKurgXCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double *zb);\n\ntemplate &lt;class T&gt; __host__ void updateKurgXATMCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb,T* Patm,T*dPdx)\n{\n\n\n    T delta;\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n\n    T ybo;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    int RB, LBRB, LB, RBLB, levRB, levLB;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        int lev = XBlock.level[ib];\n        delta = calcres(T(XParam.delta), lev);\n\n        // neighbours for source term\n\n        RB = XBlock.RightBot[ib];\n        levRB = XBlock.level[RB];\n        LBRB = XBlock.LeftBot[RB];\n\n        LB = XBlock.LeftBot[ib];\n        levLB = XBlock.level[LB];\n        RBLB = XBlock.RightBot[LB];\n\n        ybo = T(XParam.yo + XBlock.yo[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth + XParam.halowidth); ix++)\n            {\n\n\n\n\n                // This is based on kurganov and Petrova 2007\n\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n\n                T dhdxi = XGrad.dhdx[i];\n                T dhdxmin = XGrad.dhdx[ileft];\n                T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);;\n                T fmu = T(1.0);\n\n                T hi = XEv.h[i];\n\n                T hn = XEv.h[ileft];\n\n\n                if (hi &gt; eps || hn &gt; eps)\n                {\n                    T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm, ga;\n\n                    // along X\n                    dx = delta * T(0.5);\n                    zi = XEv.zs[i] - hi + T(XParam.Pa2m) * Patm[i];\n\n                    //printf(\"%f\\n\", zi);\n\n\n                    //zl = zi - dx*(dzsdx[i] - dhdx[i]);\n                    zl = zi - dx * (XGrad.dzsdx[i] - dhdxi + T(XParam.Pa2m) * dPdx[i]);\n                    //printf(\"%f\\n\", zl);\n\n                    zn = XEv.zs[ileft] - hn + T(XParam.Pa2m) * Patm[ileft];\n\n                    //printf(\"%f\\n\", zn);\n                    zr = zn + dx * (XGrad.dzsdx[ileft] - dhdxmin + T(XParam.Pa2m) * dPdx[ileft]);\n\n\n                    zlr = max(zl, zr);\n\n                    //hl = hi - dx*dhdx[i];\n                    hl = hi - dx * dhdxi;\n                    up = XEv.u[i] - dx * XGrad.dudx[i];\n                    hp = max(T(0.0), hl + zl - zlr);\n\n                    hr = hn + dx * dhdxmin;\n                    um = XEv.u[ileft] + dx * XGrad.dudx[ileft];\n                    hm = max(T(0.0), hr + zr - zlr);\n\n                    ga = g * T(0.5);\n                    T fh, fu, fv, sl, sr, dt;\n\n                    //solver below also modifies fh and fu\n                    dt = KurgSolver(g, delta, epsi, CFL, cm, fmu, hp, hm, up, um, fh, fu);\n\n                    if (dt &lt; dtmax[i])\n                    {\n                        dtmax[i] = dt;\n                    }\n\n\n\n\n                    if (fh &gt; T(0.0))\n                    {\n                        fv = (XEv.v[ileft] + dx * XGrad.dvdx[ileft]) * fh;// Eq 3.7 third term? (X direction)\n                    }\n                    else\n                    {\n                        fv = (XEv.v[i] - dx * XGrad.dvdx[i]) * fh;\n                    }\n                    //fv = (fh &gt; 0.f ? vv[xminus + iy*nx] + dx*dvdx[xminus + iy*nx] : vv[i] - dx*dvdx[i])*fh;\n                    //dtmax needs to be stored in an array and reduced at the end\n                    //dtmax = dtmaxf;\n                    //dtmaxtmp = min(dtmax, dtmaxtmp);\n                    /*if (ix == 11 &amp;&amp; iy == 0)\n                    {\n                        printf(\"a=%f\\t b=%f\\t c=%f\\t d=%f\\n\", ap*(qm*um + ga*hm2), -am*(qp*up + ga*hp2),( ap*(qm*um + g*sq(hm) / 2.0f) - am*(qp*up + g*sq(hp) / 2.0f) + ap*am*(qp - qm) ) *ad/100.0f, ad);\n                    }\n                    */\n                    /*\n                    #### Topographic source term\n\n                    In the case of adaptive refinement, care must be taken to ensure\n                    well-balancing at coarse/fine faces (see [notes/balanced.tm]()). */\n\n                    if ((ix == XParam.blkwidth) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n                    {\n                        int jj = LBRB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n                        int iright = memloc(halowidth, blkmemwidth, 0, jj, RB);;\n                        hi = XEv.h[iright];\n                        zi = zb[iright] + T(XParam.Pa2m) * Patm[iright];\n                    }\n                    if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo if you \n                    {\n                        int jj = RBLB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n                        int ilc = memloc(halowidth, blkmemwidth, XParam.blkwidth - 1, jj, LB);\n                        //int ilc = memloc(halowidth, blkmemwidth, -1, iy, ib);\n                        hn = XEv.h[ilc];\n                        zn = zb[ilc] + T(XParam.Pa2m) * Patm[ilc];\n                    }\n\n                    sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n                    sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n                    XFlux.Fhu[i] = fmu * fh;\n                    XFlux.Fqux[i] = fmu * (fu - sl);\n                    XFlux.Su[i] = fmu * (fu - sr);\n                    XFlux.Fqvx[i] = fmu * fv;\n                }\n                else\n                {\n                    dtmax[i] = T(1.0) / epsi;\n                    XFlux.Fhu[i] = T(0.0);\n                    XFlux.Fqux[i] = T(0.0);\n                    XFlux.Su[i] = T(0.0);\n                    XFlux.Fqvx[i] = T(0.0);\n                }\n\n            }\n        }\n    }\n\n\n}\ntemplate __host__ void updateKurgXATMCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb, float* Patm, float* dPdx);\ntemplate __host__ void updateKurgXATMCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double* zb, double* Patm, double* dPdx);\n\n\ntemplate &lt;class T&gt; __host__ void AddSlopeSourceXCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* zb)\n{\n    T delta;\n    //T g = T(XParam.g);\n    //T CFL = T(XParam.CFL);\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        int lev = XBlock.level[ib];\n        delta = T(calcres(XParam.delta, lev));\n\n        // neighbours for source term\n        int RB, LBRB, LB, RBLB, levRB, levLB;\n        RB = XBlock.RightBot[ib];\n        levRB = XBlock.level[RB];\n        LBRB = XBlock.LeftBot[RB];\n\n        LB = XBlock.LeftBot[ib];\n        levLB = XBlock.level[LB];\n        RBLB = XBlock.RightBot[LB];\n\n\n\n        //T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n        //T eps = T(XParam.eps) + epsi;\n\n        T g = T(XParam.g);\n        T ga = T(0.5) * g;\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth + XParam.halowidth); ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n\n                T dhdxi = XGrad.dhdx[i];\n                T dhdxmin = XGrad.dhdx[ileft];\n                //T cm = T(1.0);\n                T fmu = T(1.0);\n\n                T dx, zi, zl, zn, zr, zlr, hl, hp, hr, hm;\n\n                T hi = XEv.h[i];\n\n                T hn = XEv.h[ileft];\n\n                if (hi &gt; eps || hn &gt; eps)\n                {\n\n                    // along X these are same as in Kurgannov\n                    dx = delta * T(0.5);\n                    zi = XEv.zs[i] - hi;\n\n                    zl = zi - dx * (XGrad.dzsdx[i] - dhdxi);\n\n                    zn = XEv.zs[ileft] - hn;\n\n                    zr = zn + dx * (XGrad.dzsdx[ileft] - dhdxmin);\n\n                    zlr = max(zl, zr);\n\n                    hl = hi - dx * dhdxi;\n                    hp = max(T(0.0), hl + zl - zlr);\n\n                    hr = hn + dx * dhdxmin;\n                    hm = max(T(0.0), hr + zr - zlr);\n\n\n                    //#### Topographic source term\n                    //In the case of adaptive refinement, care must be taken to ensure\n                    //  well - balancing at coarse / fine faces(see[notes / balanced.tm]()). * /\n\n                    if ((ix == XParam.blkwidth) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n                    {\n                        int jj = LBRB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n                        int iright = memloc(halowidth, blkmemwidth, 0, jj, RB);;\n                        hi = XEv.h[iright];\n                        zi = zb[iright];\n                    }\n                    if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo if you \n                    {\n                        int jj = RBLB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n                        int ilc = memloc(halowidth, blkmemwidth, XParam.blkwidth - 1, jj, LB);\n                        hn = XEv.h[ilc];\n                        zn = zb[ilc];\n                    }\n\n                    T sl, sr;\n                    sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n                    sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n                    XFlux.Fqux[i] = XFlux.Fqux[i] - fmu * sl;\n                    XFlux.Su[i] = XFlux.Su[i] - fmu * sr;\n                }\n            }\n        }\n    }\n}\ntemplate __host__ void AddSlopeSourceXCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* zb);\ntemplate __host__ void AddSlopeSourceXCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* zb);\n\n\n\n\ntemplate &lt;class T&gt; __global__ void updateKurgYGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n    int TL, BLTL, BL, TLBL, levTL, levBL;\n    TL = XBlock.TopLeft[ib];\n    levTL = XBlock.level[TL];\n    BLTL = XBlock.BotLeft[TL];\n\n    BL = XBlock.BotLeft[ib];\n    levBL = XBlock.level[BL];\n    TLBL = XBlock.TopLeft[BL];\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps)+epsi;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ibot = memloc(halowidth, blkmemwidth, ix , iy-1, ib);\n\n    T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, T(iy)) : T(1.0);\n\n    T dhdyi = XGrad.dhdy[i];\n    T dhdymin = XGrad.dhdy[ibot];\n    T hi = XEv.h[i];\n    T hn = XEv.h[ibot];\n    T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm,ga;\n\n\n\n    if (hi &gt; eps || hn &gt; eps)\n    {\n        hn = XEv.h[ibot];\n        dx = delta * T(0.5);\n        zi = XEv.zs[i] - hi;\n        zl = zi - dx * (XGrad.dzsdy[i] - dhdyi);\n        zn = XEv.zs[ibot] - hn;\n        zr = zn + dx * (XGrad.dzsdy[ibot] - dhdymin);\n        zlr = max(zl, zr);\n\n        hl = hi - dx * dhdyi;\n        up = XEv.v[i] - dx * XGrad.dvdy[i];\n        hp = max(T(0.0), hl + zl - zlr);\n\n        hr = hn + dx * dhdymin;\n        um = XEv.v[ibot] + dx * XGrad.dvdy[ibot];\n        hm = max(T(0.0), hr + zr - zlr);\n\n\n        ga = g * T(0.5);\n\n        T fh, fu, fv, sl, sr, dt;\n\n        //solver below also modifies fh and fu\n        dt = KurgSolver(g, delta, epsi, CFL, cm, fmv, hp, hm, up, um, fh, fu);\n\n        if (dt &lt; dtmax[i])\n        {\n            dtmax[i] = dt;\n        }\n\n\n\n        if (fh &gt; T(0.0))\n        {\n            fv = (XEv.u[ibot] + dx * XGrad.dudy[ibot]) * fh;\n        }\n        else\n        {\n            fv = (XEv.u[i] - dx * XGrad.dudy[i]) * fh;\n        }\n        //fv = (fh &gt; 0.f ? uu[ix + yminus*nx] + dx*dudy[ix + yminus*nx] : uu[i] - dx*dudy[i])*fh;\n        //sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n        //sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n        //#### Topographic source term\n        //In the case of adaptive refinement, care must be taken to ensure\n        //  well - balancing at coarse / fine faces(see[notes / balanced.tm]()). * /\n\n        if ((iy == blockDim.x) &amp;&amp; levTL &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = BLTL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n            int itop = memloc(halowidth, blkmemwidth, jj, 0, TL);;\n            hi = XEv.h[itop];\n            zi = zb[itop];\n        }\n        if ((iy == 0) &amp;&amp; levBL &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = TLBL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n            int ibc = memloc(halowidth, blkmemwidth, jj, blockDim.x - 1, BL);\n            hn = XEv.h[ibc];\n            zn = zb[ibc];\n        }\n\n        sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n        sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n        XFlux.Fhv[i] = fmv * fh;\n        XFlux.Fqvy[i] = fmv * (fu - sl);\n        XFlux.Sv[i] = fmv * (fu - sr);\n        XFlux.Fquy[i] = fmv * fv;\n    }\n    else\n    {\n        dtmax[i] = T(1.0) / epsi;\n        XFlux.Fhv[i] = T(0.0);\n        XFlux.Fqvy[i] = T(0.0);\n        XFlux.Sv[i] = T(0.0);\n        XFlux.Fquy[i] = T(0.0);\n    }\n\n}\ntemplate __global__ void updateKurgYGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb);\ntemplate __global__ void updateKurgYGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double *zb);\n\n\ntemplate &lt;class T&gt; __global__ void updateKurgYATMGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb, T* Patm,T* dPdy)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n    int TL, BLTL, BL, TLBL, levTL, levBL;\n    TL = XBlock.TopLeft[ib];\n    levTL = XBlock.level[TL];\n    BLTL = XBlock.BotLeft[TL];\n\n    BL = XBlock.BotLeft[ib];\n    levBL = XBlock.level[BL];\n    TLBL = XBlock.TopLeft[BL];\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n\n    T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, T(iy)) : T(1.0);\n\n    T dhdyi = XGrad.dhdy[i];\n    T dhdymin = XGrad.dhdy[ibot];\n    T hi = XEv.h[i];\n    T hn = XEv.h[ibot];\n    T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm, ga;\n\n\n\n    if (hi &gt; eps || hn &gt; eps)\n    {\n        hn = XEv.h[ibot];\n        dx = delta * T(0.5);\n\n        //zi = XEv.zs[i] - hi;\n        //zl = zi - dx * (XGrad.dzsdy[i] - dhdyi);\n        //zn = XEv.zs[ibot] - hn;\n        //zr = zn + dx * (XGrad.dzsdy[ibot] - dhdymin);\n\n        zi = XEv.zs[i] - hi + XParam.Pa2m * Patm[i];\n        zl = zi - dx * (XGrad.dzsdy[i] - dhdyi + XParam.Pa2m * dPdy[i]);\n        zn = XEv.zs[ibot] - hn + XParam.Pa2m * Patm[ibot];\n        zr = zn + dx * (XGrad.dzsdy[ibot] - dhdymin + XParam.Pa2m * dPdy[ibot]);\n\n        zlr = max(zl, zr);\n\n        hl = hi - dx * dhdyi;\n        up = XEv.v[i] - dx * XGrad.dvdy[i];\n        hp = max(T(0.0), hl + zl - zlr);\n\n        hr = hn + dx * dhdymin;\n        um = XEv.v[ibot] + dx * XGrad.dvdy[ibot];\n        hm = max(T(0.0), hr + zr - zlr);\n\n\n        ga = g * T(0.5);\n\n        T fh, fu, fv, sl, sr, dt;\n\n        //solver below also modifies fh and fu\n        dt = KurgSolver(g, delta, epsi, CFL, cm, fmv, hp, hm, up, um, fh, fu);\n\n        if (dt &lt; dtmax[i])\n        {\n            dtmax[i] = dt;\n        }\n\n\n\n        if (fh &gt; T(0.0))\n        {\n            fv = (XEv.u[ibot] + dx * XGrad.dudy[ibot]) * fh;\n        }\n        else\n        {\n            fv = (XEv.u[i] - dx * XGrad.dudy[i]) * fh;\n        }\n        //fv = (fh &gt; 0.f ? uu[ix + yminus*nx] + dx*dudy[ix + yminus*nx] : uu[i] - dx*dudy[i])*fh;\n        //sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n        //sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n        //#### Topographic source term\n        //In the case of adaptive refinement, care must be taken to ensure\n        //  well - balancing at coarse / fine faces(see[notes / balanced.tm]()). * /\n\n        if ((iy == blockDim.x) &amp;&amp; levTL &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = BLTL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n            int itop = memloc(halowidth, blkmemwidth, jj, 0, TL);;\n            hi = XEv.h[itop];\n            zi = zb[itop] + XParam.Pa2m * Patm[itop];\n        }\n        if ((iy == 0) &amp;&amp; levBL &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = TLBL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n            int ibc = memloc(halowidth, blkmemwidth, jj, blockDim.x - 1, BL);\n            hn = XEv.h[ibc];\n            zn = zb[ibc] + +XParam.Pa2m * Patm[ibc];\n        }\n\n        sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n        sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n        XFlux.Fhv[i] = fmv * fh;\n        XFlux.Fqvy[i] = fmv * (fu - sl);\n        XFlux.Sv[i] = fmv * (fu - sr);\n        XFlux.Fquy[i] = fmv * fv;\n    }\n    else\n    {\n        dtmax[i] = T(1.0) / epsi;\n        XFlux.Fhv[i] = T(0.0);\n        XFlux.Fqvy[i] = T(0.0);\n        XFlux.Sv[i] = T(0.0);\n        XFlux.Fquy[i] = T(0.0);\n    }\n\n}\ntemplate __global__ void updateKurgYATMGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb, float* Patm, float* dPdy);\ntemplate __global__ void updateKurgYATMGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double* zb, double* Patm, double* dPdy);\n\n\n\ntemplate &lt;class T&gt; __global__ void AddSlopeSourceYGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n    // neighbours for source term\n    int TL, BLTL, BL, TLBL, levTL, levBL;\n    TL = XBlock.TopLeft[ib];\n    levTL = XBlock.level[TL];\n    BLTL = XBlock.BotLeft[TL];\n\n    BL = XBlock.BotLeft[ib];\n    levBL = XBlock.level[BL];\n    TLBL = XBlock.TopLeft[BL];\n\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T ga = T(0.5) * g;\n\n    T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n\n\n\n    //T cm = T(1.0);\n    T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, T(iy)) : T(1.0);\n\n    T dx, zi, zl, zn, zr, zlr, hl, hp, hr, hm;\n\n    T dhdyi = XGrad.dhdy[i];\n    T dhdymin = XGrad.dhdy[ibot];\n    T hi = XEv.h[i];\n    T hn = XEv.h[ibot];\n\n\n    if (hi &gt; eps || hn &gt; eps)\n    {\n\n        // along X these are same as in Kurgannov\n        dx = delta * T(0.5);\n        zi = XEv.zs[i] - hi;\n\n        zl = zi - dx * (XGrad.dzsdy[i] - dhdyi);\n        zn = XEv.zs[ibot] - hn;\n        zr = zn + dx * (XGrad.dzsdy[ibot] - dhdymin);\n        zlr = max(zl, zr);\n\n        hl = hi - dx * dhdyi;\n        hp = max(T(0.0), hl + zl - zlr);\n\n        hr = hn + dx * dhdymin;\n        hm = max(T(0.0), hr + zr - zlr);\n\n\n        //#### Topographic source term\n        //In the case of adaptive refinement, care must be taken to ensure\n        //  well - balancing at coarse / fine faces(see[notes / balanced.tm]()). * /\n\n        if ((iy == blockDim.x) &amp;&amp; levTL &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = BLTL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n            int itop = memloc(halowidth, blkmemwidth, jj, 0, TL);;\n            hi = XEv.h[itop];\n            zi = zb[itop];\n        }\n        if ((iy == 0) &amp;&amp; levBL &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = TLBL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n            int ibc = memloc(halowidth, blkmemwidth, jj, blockDim.x - 1, BL);\n            hn = XEv.h[ibc];\n            zn = zb[ibc];\n        }\n\n        T sl, sr;\n        sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n        sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n        XFlux.Fqvy[i] = XFlux.Fqvy[i] - fmv * sl;\n        XFlux.Sv[i] = XFlux.Sv[i] - fmv * sr;\n    }\n}\ntemplate __global__ void AddSlopeSourceYGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* zb);\ntemplate __global__ void AddSlopeSourceYGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* zb);\n\n\n\n\ntemplate &lt;class T&gt; __host__ void updateKurgYCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax,T*zb)\n{\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps)+epsi;\n    T delta;\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T ybo;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    int TL, BLTL, BL, TLBL, levTL, levBL, lev;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n\n\n\n        TL = XBlock.TopLeft[ib];\n        levTL = XBlock.level[TL];\n        BLTL = XBlock.BotLeft[TL];\n\n        BL = XBlock.BotLeft[ib];\n        levBL = XBlock.level[BL];\n        TLBL = XBlock.TopLeft[BL];\n\n        lev = XBlock.level[ib];\n\n        delta = T(calcres(XParam.delta, lev));\n\n        ybo = T(XParam.yo + XBlock.yo[ib]);\n\n        for (int iy = 0; iy &lt; (XParam.blkwidth + XParam.halowidth); iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n\n                T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n                T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, T(iy)) : T(1.0);\n\n                T dhdyi = XGrad.dhdy[i];\n                T dhdymin = XGrad.dhdy[ibot];\n                T hi = XEv.h[i];\n                T hn = XEv.h[ibot];\n                T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm, ga;\n\n\n\n\n                if (hi &gt; eps || hn &gt; eps)\n                {\n                    hn = XEv.h[ibot];\n                    dx = delta * T(0.5);\n                    zi = XEv.zs[i] - hi;\n                    zl = zi - dx * (XGrad.dzsdy[i] - dhdyi);\n                    zn = XEv.zs[ibot] - hn;\n                    zr = zn + dx * (XGrad.dzsdy[ibot] - dhdymin);\n                    zlr = max(zl, zr);\n\n                    hl = hi - dx * dhdyi;\n                    up = XEv.v[i] - dx * XGrad.dvdy[i];\n                    hp = max(T(0.0), hl + zl - zlr);\n\n                    hr = hn + dx * dhdymin;\n                    um = XEv.v[ibot] + dx * XGrad.dvdy[ibot];\n                    hm = max(T(0.0), hr + zr - zlr);\n\n\n                    ga = g * T(0.5);\n\n                    T fh, fu, fv, sl, sr, dt;\n\n                    //solver below also modifies fh and fu\n                    dt = KurgSolver(g, delta, epsi, CFL, cm, fmv, hp, hm, up, um, fh, fu);\n\n                    if (dt &lt; dtmax[i])\n                    {\n                        dtmax[i] = dt;\n                    }\n\n\n\n                    if (fh &gt; T(0.0))\n                    {\n                        fv = (XEv.u[ibot] + dx * XGrad.dudy[ibot]) * fh;\n                    }\n                    else\n                    {\n                        fv = (XEv.u[i] - dx * XGrad.dudy[i]) * fh;\n                    }\n                    //fv = (fh &gt; 0.f ? uu[ix + yminus*nx] + dx*dudy[ix + yminus*nx] : uu[i] - dx*dudy[i])*fh;\n                    if ((iy == XParam.blkwidth) &amp;&amp; levTL &lt; lev)//(ix==16) i.e. in the top halo\n                    {\n                        int jj = BLTL == ib ? ftoi(floor(ix * (T)0.5)) : ftoi(floor(ix * (T)0.5) + XParam.blkwidth / 2);\n                        int itop = memloc(halowidth, blkmemwidth, jj, 0, TL);\n                        hi = XEv.h[itop];\n                        zi = zb[itop];\n                    }\n                    if ((iy == 0) &amp;&amp; levBL &lt; lev)//(ix==16) i.e. in the bot halo\n                    {\n                        int jj = TLBL == ib ? ftoi(floor(ix * (T)0.5)) : ftoi(floor(ix * (T)0.5) + XParam.blkwidth / 2);\n                        int ibc = memloc(halowidth, blkmemwidth, jj, XParam.blkwidth - 1, BL);\n                        hn = XEv.h[ibc];\n                        zn = zb[ibc];\n                    }\n\n                    sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n                    sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n                    XFlux.Fhv[i] = fmv * fh;\n                    XFlux.Fqvy[i] = fmv *  (fu - sl);\n                    XFlux.Sv[i] = fmv * (fu - sr);\n                    XFlux.Fquy[i] = fmv * fv;\n                }\n                else\n                {\n                    dtmax[i] = T(1.0) / epsi;\n                    XFlux.Fhv[i] = T(0.0);\n                    XFlux.Fqvy[i] = T(0.0);\n                    XFlux.Sv[i] = T(0.0);\n                    XFlux.Fquy[i] = T(0.0);\n                }\n            }\n        }\n    }\n}\ntemplate __host__ void updateKurgYCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float *zb);\ntemplate __host__ void updateKurgYCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double *zb);\n\ntemplate &lt;class T&gt; __host__ void updateKurgYATMCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb, T* Patm, T* dPdy)\n{\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n    T delta;\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T ybo;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    int TL, BLTL, BL, TLBL, levTL, levBL, lev;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n\n\n\n        TL = XBlock.TopLeft[ib];\n        levTL = XBlock.level[TL];\n        BLTL = XBlock.BotLeft[TL];\n\n        BL = XBlock.BotLeft[ib];\n        levBL = XBlock.level[BL];\n        TLBL = XBlock.TopLeft[BL];\n\n        lev = XBlock.level[ib];\n\n        delta = T(calcres(XParam.delta, lev));\n\n        ybo = T(XParam.yo + XBlock.yo[ib]);\n\n        for (int iy = 0; iy &lt; (XParam.blkwidth + XParam.halowidth); iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n\n                T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n                T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, T(iy)) : T(1.0);\n\n                T dhdyi = XGrad.dhdy[i];\n                T dhdymin = XGrad.dhdy[ibot];\n                T hi = XEv.h[i];\n                T hn = XEv.h[ibot];\n                T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm, ga;\n\n\n\n\n                if (hi &gt; eps || hn &gt; eps)\n                {\n                    hn = XEv.h[ibot];\n                    dx = delta * T(0.5);\n\n\n                    //zi = XEv.zs[i] - hi;\n                    //zl = zi - dx * (XGrad.dzsdy[i] - dhdyi);\n                    //zn = XEv.zs[ibot] - hn;\n                    //zr = zn + dx * (XGrad.dzsdy[ibot] - dhdymin);\n\n                    zi = XEv.zs[i] - hi + T(XParam.Pa2m) * Patm[i];\n                    zl = zi - dx * (XGrad.dzsdy[i] - dhdyi + T(XParam.Pa2m) * dPdy[i]);\n                    zn = XEv.zs[ibot] - hn + T(XParam.Pa2m) * Patm[ibot];\n                    zr = zn + dx * (XGrad.dzsdy[ibot] - dhdymin + T(XParam.Pa2m) * dPdy[ibot]);\n\n                    zlr = max(zl, zr);\n\n                    hl = hi - dx * dhdyi;\n                    up = XEv.v[i] - dx * XGrad.dvdy[i];\n                    hp = max(T(0.0), hl + zl - zlr);\n\n                    hr = hn + dx * dhdymin;\n                    um = XEv.v[ibot] + dx * XGrad.dvdy[ibot];\n                    hm = max(T(0.0), hr + zr - zlr);\n\n\n                    ga = g * T(0.5);\n\n                    T fh, fu, fv, sl, sr, dt;\n\n                    //solver below also modifies fh and fu\n                    dt = KurgSolver(g, delta, epsi, CFL, cm, fmv, hp, hm, up, um, fh, fu);\n\n                    if (dt &lt; dtmax[i])\n                    {\n                        dtmax[i] = dt;\n                    }\n\n\n\n                    if (fh &gt; T(0.0))\n                    {\n                        fv = (XEv.u[ibot] + dx * XGrad.dudy[ibot]) * fh;\n                    }\n                    else\n                    {\n                        fv = (XEv.u[i] - dx * XGrad.dudy[i]) * fh;\n                    }\n                    //fv = (fh &gt; 0.f ? uu[ix + yminus*nx] + dx*dudy[ix + yminus*nx] : uu[i] - dx*dudy[i])*fh;\n                    if ((iy == XParam.blkwidth) &amp;&amp; levTL &lt; lev)//(ix==16) i.e. in the top halo\n                    {\n                        int jj = BLTL == ib ? ftoi(floor(ix * (T)0.5)) : ftoi(floor(ix * (T)0.5) + XParam.blkwidth / 2);\n                        int itop = memloc(halowidth, blkmemwidth, jj, 0, TL);\n                        hi = XEv.h[itop];\n                        zi = zb[itop] + T(XParam.Pa2m) * Patm[itop];\n                    }\n                    if ((iy == 0) &amp;&amp; levBL &lt; lev)//(ix==16) i.e. in the bot halo\n                    {\n                        int jj = TLBL == ib ? ftoi(floor(ix * (T)0.5)) : ftoi(floor(ix * (T)0.5) + XParam.blkwidth / 2);\n                        int ibc = memloc(halowidth, blkmemwidth, jj, XParam.blkwidth - 1, BL);\n                        hn = XEv.h[ibc];\n                        zn = zb[ibc] + T(XParam.Pa2m) * Patm[ibc];\n                    }\n\n                    sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n                    sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n                    XFlux.Fhv[i] = fmv * fh;\n                    XFlux.Fqvy[i] = fmv * (fu - sl);\n                    XFlux.Sv[i] = fmv * (fu - sr);\n                    XFlux.Fquy[i] = fmv * fv;\n                }\n                else\n                {\n                    dtmax[i] = T(1.0) / epsi;\n                    XFlux.Fhv[i] = T(0.0);\n                    XFlux.Fqvy[i] = T(0.0);\n                    XFlux.Sv[i] = T(0.0);\n                    XFlux.Fquy[i] = T(0.0);\n                }\n            }\n        }\n    }\n}\ntemplate __host__ void updateKurgYATMCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb, float* Patm, float* dPdy);\ntemplate __host__ void updateKurgYATMCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double* zb, double* Patm, double* dPdy);\n\n\ntemplate &lt;class T&gt; __host__ void AddSlopeSourceYCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* zb)\n{\n    T delta;\n    T g = T(XParam.g);\n    T ga = T(0.5) * g;\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n\n    T ybo;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n\n        int lev = XBlock.level[ib];\n        delta = T(calcres(XParam.delta, lev));\n        // neighbours for source term\n        int TL, BLTL, BL, TLBL, levTL, levBL;\n        TL = XBlock.TopLeft[ib];\n        levTL = XBlock.level[TL];\n        BLTL = XBlock.BotLeft[TL];\n\n        BL = XBlock.BotLeft[ib];\n        levBL = XBlock.level[BL];\n        TLBL = XBlock.TopLeft[BL];\n\n        ybo = T(XParam.yo + XBlock.yo[ib]);\n\n\n\n        for (int iy = 0; iy &lt; (XParam.blkwidth + XParam.halowidth); iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n\n\n\n                //T cm = T(1.0);\n                T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, T(iy)) : T(1.0);\n\n                T dx, zi, zl, zn, zr, zlr, hl, hp, hr, hm;\n\n                T dhdyi = XGrad.dhdy[i];\n                T dhdymin = XGrad.dhdy[ibot];\n                T hi = XEv.h[i];\n                T hn = XEv.h[ibot];\n\n\n                if (hi &gt; eps || hn &gt; eps)\n                {\n\n                    // along X these are same as in Kurgannov\n                    dx = delta * T(0.5);\n                    zi = XEv.zs[i] - hi;\n\n                    zl = zi - dx * (XGrad.dzsdy[i] - dhdyi);\n                    zn = XEv.zs[ibot] - hn;\n                    zr = zn + dx * (XGrad.dzsdy[ibot] - dhdymin);\n                    zlr = max(zl, zr);\n\n                    hl = hi - dx * dhdyi;\n                    hp = max(T(0.0), hl + zl - zlr);\n\n                    hr = hn + dx * dhdymin;\n                    hm = max(T(0.0), hr + zr - zlr);\n\n\n                    //#### Topographic source term\n                    //In the case of adaptive refinement, care must be taken to ensure\n                    //  well - balancing at coarse / fine faces(see[notes / balanced.tm]()). * /\n\n                    if ((iy == XParam.blkwidth) &amp;&amp; levTL &lt; lev)//(ix==16) i.e. in the right halo\n                    {\n                        int jj = BLTL == ib ? ftoi(floor(ix * (T)0.5)) : ftoi(floor(ix * (T)0.5) + XParam.blkwidth / 2);\n                        int itop = memloc(halowidth, blkmemwidth, jj, 0, TL);;\n                        hi = XEv.h[itop];\n                        zi = zb[itop];\n                    }\n                    if ((iy == 0) &amp;&amp; levBL &lt; lev)//(ix==16) i.e. in the right halo\n                    {\n                        int jj = TLBL == ib ? ftoi(floor(ix * (T)0.5)) : ftoi(floor(ix * (T)0.5) + XParam.blkwidth / 2);\n                        int ibc = memloc(halowidth, blkmemwidth, jj, XParam.blkwidth - 1, BL);\n                        hn = XEv.h[ibc];\n                        zn = zb[ibc];\n                    }\n\n                    T sl, sr;\n                    sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n                    sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n                    XFlux.Fqvy[i] = XFlux.Fqvy[i] - fmv * sl;\n                    XFlux.Sv[i] = XFlux.Sv[i] - fmv * sr;\n                }\n            }\n        }\n    }\n}\ntemplate __host__ void AddSlopeSourceYCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* zb);\ntemplate __host__ void AddSlopeSourceYCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* zb);\n\n\n\ntemplate &lt;class T&gt; __host__ __device__ T KurgSolver(T g, T delta,T epsi, T CFL, T cm, T fm,  T hp, T hm, T up,T um, T &amp;fh, T &amp;fu)\n{\n    T dt;\n\n    //We can now call one of the approximate Riemann solvers to get the fluxes.\n    T cp, cmo, ap, am, qm, qp, a, dlt, ad, hm2, hp2, ga, apm;\n\n\n    cp = sqrt(g * hp);\n    cmo = sqrt(g * hm);\n\n    ap = max(max(up + cp, um + cmo), T(0.0));\n    //ap = max(ap, 0.0f);\n\n    am = min(min(up - cp, um - cmo), T(0.0));\n    //am = min(am, 0.0f);\n    ad = T(1.0) / (ap - am);\n    //Correct for spurious currents in really shallow depth\n    qm = hm * um;\n    qp = hp * up;\n    //qm = hm*um*(sqrtf(2.0f) / sqrtf(1.0f + max(1.0f, powf(epsc / hm, 4.0f))));\n    //qp = hp*up*(sqrtf(2.0f) / sqrtf(1.0f + max(1.0f, powf(epsc / hp, 4.0f))));\n\n    hm2 = hm * hm;\n    hp2 = hp * hp;\n    a = max(ap, -am);\n    ga = g * T(0.5);\n    apm = ap * am;\n    dlt = delta * cm / fm;\n\n    if (a &gt; epsi)\n    {\n        fh = (ap * qm - am * qp + apm * (hp - hm)) * ad;// H  in eq. 2.24 or eq 3.7 for F(h)\n        fu = (ap * (qm * um + ga * hm2) - am * (qp * up + ga * hp2) + apm * (qp - qm)) * ad;// Eq 3.7 second term (Y direction)\n        dt = CFL * dlt / a;\n\n\n    }\n    else\n    {\n        fh = T(0.0);\n        fu = T(0.0);\n        dt = T(1.0) / epsi;\n    }\n    return dt;\n}\n</code></pre>"},{"location":"BGFlood/Kurganov_8h/","title":"File Kurganov.h","text":""},{"location":"BGFlood/Kurganov_8h/#file-kurganovh","title":"File Kurganov.h","text":"<p>FileList &gt; src &gt; Kurganov.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Spherical.h\"</code></li> </ul>"},{"location":"BGFlood/Kurganov_8h/#public-functions","title":"Public Functions","text":"Type Name __host__ void AddSlopeSourceXCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * zb)  __global__ void AddSlopeSourceXGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * zb)  __host__ void AddSlopeSourceYCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * zb)  __global__ void AddSlopeSourceYGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * zb)  __host__ __device__ T KurgSolver (T g, T delta, T epsi, T CFL, T cm, T fm, T hp, T hm, T up, T um, T &amp; fh, T &amp; fu)  __host__ void updateKurgXATMCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb, T * Patm, T * dPdx)  __global__ void updateKurgXATMGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb, T * Patm, T * dPdx)  __host__ void updateKurgXCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb)  __global__ void updateKurgXGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb)  __host__ void updateKurgYATMCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb, T * Patm, T * dPdy)  __global__ void updateKurgYATMGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb, T * Patm, T * dPdy)  __host__ void updateKurgYCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb)  __global__ void updateKurgYGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb)"},{"location":"BGFlood/Kurganov_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Kurganov_8h/#function-addslopesourcexcpu","title":"function AddSlopeSourceXCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AddSlopeSourceXCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8h/#function-addslopesourcexgpu","title":"function AddSlopeSourceXGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AddSlopeSourceXGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8h/#function-addslopesourceycpu","title":"function AddSlopeSourceYCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AddSlopeSourceYCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8h/#function-addslopesourceygpu","title":"function AddSlopeSourceYGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AddSlopeSourceYGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8h/#function-kurgsolver","title":"function KurgSolver","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T KurgSolver (\n    T g,\n    T delta,\n    T epsi,\n    T CFL,\n    T cm,\n    T fm,\n    T hp,\n    T hm,\n    T up,\n    T um,\n    T &amp; fh,\n    T &amp; fu\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8h/#function-updatekurgxatmcpu","title":"function updateKurgXATMCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void updateKurgXATMCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb,\n    T * Patm,\n    T * dPdx\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8h/#function-updatekurgxatmgpu","title":"function updateKurgXATMGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void updateKurgXATMGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb,\n    T * Patm,\n    T * dPdx\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8h/#function-updatekurgxcpu","title":"function updateKurgXCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void updateKurgXCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8h/#function-updatekurgxgpu","title":"function updateKurgXGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void updateKurgXGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8h/#function-updatekurgyatmcpu","title":"function updateKurgYATMCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void updateKurgYATMCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb,\n    T * Patm,\n    T * dPdy\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8h/#function-updatekurgyatmgpu","title":"function updateKurgYATMGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void updateKurgYATMGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb,\n    T * Patm,\n    T * dPdy\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8h/#function-updatekurgycpu","title":"function updateKurgYCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void updateKurgYCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Kurganov_8h/#function-updatekurgygpu","title":"function updateKurgYGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void updateKurgYGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Kurganov.h</code></p>"},{"location":"BGFlood/Kurganov_8h_source/","title":"File Kurganov.h","text":""},{"location":"BGFlood/Kurganov_8h_source/#file-kurganovh","title":"File Kurganov.h","text":"<p>File List &gt; src &gt; Kurganov.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef KURGANOV_H\n#define KURGANOV_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"Util_CPU.h\"\n#include \"Spherical.h\"\n\ntemplate &lt;class T&gt; __global__ void updateKurgXGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __global__ void AddSlopeSourceXGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* zb);\n\ntemplate &lt;class T&gt; __host__ void updateKurgXCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __host__ void AddSlopeSourceXCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* zb);\n\n\ntemplate &lt;class T&gt; __global__ void updateKurgYGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __global__ void AddSlopeSourceYGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* zb);\n\ntemplate &lt;class T&gt; __host__ void updateKurgYCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __host__ void AddSlopeSourceYCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* zb);\n\ntemplate &lt;class T&gt; __global__ void updateKurgXATMGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb, T* Patm, T* dPdx);\ntemplate &lt;class T&gt; __host__ void updateKurgXATMCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb, T* Patm, T* dPdx);\n\ntemplate &lt;class T&gt; __global__ void updateKurgYATMGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb, T* Patm, T* dPdy);\ntemplate &lt;class T&gt; __host__ void updateKurgYATMCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb, T* Patm, T* dPdy);\n\n\ntemplate &lt;class T&gt; __host__ __device__ T KurgSolver(T g, T delta, T epsi, T CFL, T cm, T fm, T hp, T hm, T up, T um, T&amp; fh, T&amp; fu);\n\n#endif\n</code></pre>"},{"location":"BGFlood/Mainloop_8cu/","title":"File Mainloop.cu","text":""},{"location":"BGFlood/Mainloop_8cu/#file-mainloopcu","title":"File Mainloop.cu","text":"<p>FileList &gt; src &gt; Mainloop.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Mainloop.h\"</code></li> </ul>"},{"location":"BGFlood/Mainloop_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ void CalcInitdtCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEvolv, T * dtmax)  __global__ void CalcInitdtGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEvolv, T * dtmax)  void CrashDetection (Param &amp; XParam, Loop&lt; T &gt; XLoop, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  void DebugLoop (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; &amp; XModel, Model&lt; T &gt; &amp; XModel_g)  template void DebugLoop&lt; double &gt; (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; &amp; XModel, Model&lt; double &gt; &amp; XModel_g)  template void DebugLoop&lt; float &gt; (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; &amp; XModel, Model&lt; float &gt; &amp; XModel_g)  Loop&lt; T &gt; InitLoop (Param &amp; XParam, Model&lt; T &gt; &amp; XModel)  void MainLoop (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; &amp; XModel, Model&lt; T &gt; &amp; XModel_g)  template void MainLoop&lt; double &gt; (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; &amp; XModel, Model&lt; double &gt; &amp; XModel_g)  template void MainLoop&lt; float &gt; (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; &amp; XModel, Model&lt; float &gt; &amp; XModel_g)  __host__ double initdt (Param XParam, Loop&lt; T &gt; XLoop, Model&lt; T &gt; XModel)  template __host__ double initdt&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, Model&lt; double &gt; XModel)  template __host__ double initdt&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, Model&lt; float &gt; XModel)  void mapoutput (Param XParam, Loop&lt; T &gt; &amp; XLoop, Model&lt; T &gt; &amp; XModel, Model&lt; T &gt; XModel_g)  void pointoutputstep (Param XParam, Loop&lt; T &gt; &amp; XLoop, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  void printstatus (T totaltime, T dt)  __global__ void storeTSout (Param XParam, int noutnodes, int outnode, int istep, int blknode, int inode, int jnode, int * blkTS, EvolvingP&lt; T &gt; XEv, T * store)  void updateBnd (Param XParam, Loop&lt; T &gt; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)"},{"location":"BGFlood/Mainloop_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Mainloop_8cu/#function-calcinitdtcpu","title":"function CalcInitdtCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void CalcInitdtCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEvolv,\n    T * dtmax\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8cu/#function-calcinitdtgpu","title":"function CalcInitdtGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void CalcInitdtGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEvolv,\n    T * dtmax\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8cu/#function-crashdetection","title":"function CrashDetection","text":"<pre><code>template&lt;class T&gt;\nvoid CrashDetection (\n    Param &amp; XParam,\n    Loop &lt; T &gt; XLoop,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8cu/#function-debugloop","title":"function DebugLoop","text":"<pre><code>template&lt;class T&gt;\nvoid DebugLoop (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; &amp; XModel,\n    Model &lt; T &gt; &amp; XModel_g\n) \n</code></pre> <p>Debugging loop This function was crated to debug to properly wrap the debug flow engine of the model </p>"},{"location":"BGFlood/Mainloop_8cu/#function-debugloop-double","title":"function DebugLoop&lt; double &gt;","text":"<pre><code>template void DebugLoop&lt; double &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; &amp; XModel,\n    Model &lt; double &gt; &amp; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8cu/#function-debugloop-float","title":"function DebugLoop&lt; float &gt;","text":"<pre><code>template void DebugLoop&lt; float &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; &amp; XModel,\n    Model &lt; float &gt; &amp; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8cu/#function-initloop","title":"function InitLoop","text":"<pre><code>template&lt;class T&gt;\nLoop &lt; T &gt; InitLoop (\n    Param &amp; XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8cu/#function-mainloop","title":"function MainLoop","text":"<pre><code>template&lt;class T&gt;\nvoid MainLoop (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; &amp; XModel,\n    Model &lt; T &gt; &amp; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8cu/#function-mainloop-double","title":"function MainLoop&lt; double &gt;","text":"<pre><code>template void MainLoop&lt; double &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; &amp; XModel,\n    Model &lt; double &gt; &amp; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8cu/#function-mainloop-float","title":"function MainLoop&lt; float &gt;","text":"<pre><code>template void MainLoop&lt; float &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; &amp; XModel,\n    Model &lt; float &gt; &amp; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8cu/#function-initdt","title":"function initdt","text":"<pre><code>template&lt;class T&gt;\n__host__ double initdt (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8cu/#function-initdt-double","title":"function initdt&lt; double &gt;","text":"<pre><code>template __host__ double initdt&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8cu/#function-initdt-float","title":"function initdt&lt; float &gt;","text":"<pre><code>template __host__ double initdt&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8cu/#function-mapoutput","title":"function mapoutput","text":"<pre><code>template&lt;class T&gt;\nvoid mapoutput (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Model &lt; T &gt; &amp; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8cu/#function-pointoutputstep","title":"function pointoutputstep","text":"<pre><code>template&lt;class T&gt;\nvoid pointoutputstep (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8cu/#function-printstatus","title":"function printstatus","text":"<pre><code>template&lt;class T&gt;\nvoid printstatus (\n    T totaltime,\n    T dt\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8cu/#function-storetsout","title":"function storeTSout","text":"<pre><code>template&lt;class T&gt;\n__global__ void storeTSout (\n    Param XParam,\n    int noutnodes,\n    int outnode,\n    int istep,\n    int blknode,\n    int inode,\n    int jnode,\n    int * blkTS,\n    EvolvingP &lt; T &gt; XEv,\n    T * store\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8cu/#function-updatebnd","title":"function updateBnd","text":"<pre><code>template&lt;class T&gt;\nvoid updateBnd (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Mainloop.cu</code></p>"},{"location":"BGFlood/Mainloop_8cu_source/","title":"File Mainloop.cu","text":""},{"location":"BGFlood/Mainloop_8cu_source/#file-mainloopcu","title":"File Mainloop.cu","text":"<p>File List &gt; src &gt; Mainloop.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Mainloop.h\"\n\n\n\ntemplate &lt;class T&gt; void MainLoop(Param &amp;XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel, Model&lt;T&gt; &amp;XModel_g)\n{\n\n    log(\"Initialising model main loop\");\n\n    Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n\n    //Define some useful variables \n    Initmeanmax(XParam, XLoop, XModel, XModel_g);\n\n    // Check for map output (output initialisation if needed)\n    mapoutput(XParam, XLoop, XModel, XModel_g);\n\n    log(\"\\t\\tCompleted\");\n    log(\"Model Running...\");\n\n    while (XLoop.totaltime &lt; XParam.endtime)\n    {\n        // Bnd stuff here\n        //updateBnd(XParam, XLoop, XForcing, XModel, XModel_g);\n\n\n        // Calculate dynamic forcing at this step\n        updateforcing(XParam, XLoop, XForcing);\n\n        // Core engine\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            if (XParam.engine == 5)\n            {\n                FlowMLGPU(XParam, XLoop, XForcing, XModel_g);\n            }\n            else\n            {\n                FlowGPU(XParam, XLoop, XForcing, XModel_g);\n            }\n        }\n        else\n        {\n            FlowCPU(XParam, XLoop, XForcing, XModel);\n        }\n\n\n        // Time keeping\n        XLoop.totaltime = XLoop.totaltime + XLoop.dt;\n        //log(\"timestep = \" + std::to_string(XLoop.totaltime));\n\n        // Detected if the model crashed\n        CrashDetection(XParam, XLoop, XModel, XModel_g);\n\n        // Apply tsunami deformation if any (this needs to happen after totaltime has been incremented)\n        deformstep(XParam, XLoop, XForcing.deform, XModel, XModel_g);\n\n        // Do Sum &amp; Max variables Here\n        Calcmeanmax(XParam, XLoop, XModel, XModel_g);\n\n        // Check &amp; collect TSoutput\n        pointoutputstep(XParam, XLoop, XModel, XModel_g);\n\n        // Check for map output\n        mapoutput(XParam, XLoop, XModel, XModel_g);\n\n        // Reset mean/Max if needed\n        resetmeanmax(XParam, XLoop, XModel, XModel_g);\n\n\n\n\n        printstatus(XLoop.totaltime, XLoop.dt);\n    }\n\n\n\n\n}\ntemplate void MainLoop&lt;float&gt;(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;float&gt;&amp; XModel, Model&lt;float&gt;&amp; XModel_g);\ntemplate void MainLoop&lt;double&gt;(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;double&gt;&amp; XModel, Model&lt;double&gt;&amp; XModel_g);\n\n\n\ntemplate &lt;class T&gt; void DebugLoop(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel, Model&lt;T&gt;&amp; XModel_g)\n{\n\n    log(\"Initialising model main loop\");\n\n    Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n\n    //Define some useful variables \n    Initmeanmax(XParam, XLoop, XModel, XModel_g);\n\n    // fill halo for zb\n    // only need to do that once \n    fillHaloC(XParam, XModel.blocks, XModel.zb);\n    gradientC(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    gradientHalo(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        dim3 blockDim(16, 16, 1);\n        dim3 gridDim(XParam.nblk, 1, 1);\n        CUDA_CHECK(cudaStreamCreate(&amp;XLoop.streams[0]));\n        fillHaloGPU(XParam, XModel_g.blocks, XLoop.streams[0], XModel_g.zb);\n        cudaStreamDestroy(XLoop.streams[0]);\n\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XModel_g.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel_g.zb, XModel_g.grad.dzbdx, XModel_g.grad.dzbdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientHaloGPU(XParam, XModel_g.blocks, XModel_g.zb, XModel_g.grad.dzbdx, XModel_g.grad.dzbdy);\n\n    }\n\n\n\n    log(\"\\t\\tCompleted\");\n    log(\"Model Running...\");\n    while (XLoop.nstep &lt; 100)\n    {\n        // Bnd stuff here\n        updateBnd(XParam, XLoop, XForcing, XModel, XModel_g);\n\n\n        // Calculate Forcing at this step\n        updateforcing(XParam, XLoop, XForcing);\n\n        // Core engine\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            //HalfStepGPU(XParam, XLoop, XForcing, XModel_g);\n        }\n        else\n        {\n            HalfStepCPU(XParam, XLoop, XForcing, XModel);\n        }\n\n        // Time keeping\n        XLoop.totaltime = XLoop.totaltime + XLoop.dt;\n\n        // Force output at every step\n        XLoop.nextoutputtime = XLoop.totaltime;\n\n        // Apply tsunami deformation if any (this needs to happen after totaltime has been incremented)\n        deformstep(XParam, XLoop, XForcing.deform, XModel, XModel_g);\n\n        // Do Sum &amp; Max variables Here\n        Calcmeanmax(XParam, XLoop, XModel, XModel_g);\n\n        // Check &amp; collect TSoutput\n        pointoutputstep(XParam, XLoop, XModel, XModel_g);\n\n        // Check for map output\n        mapoutput(XParam, XLoop, XModel, XModel_g);\n\n        // Reset mean/Max if needed\n        resetmeanmax(XParam, XLoop, XModel, XModel_g);\n\n        printstatus(XLoop.totaltime, XLoop.dt);\n        XLoop.nstep++;\n    }\n\n\n\n\n}\ntemplate void DebugLoop&lt;float&gt;(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;float&gt;&amp; XModel, Model&lt;float&gt;&amp; XModel_g);\ntemplate void DebugLoop&lt;double&gt;(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;double&gt;&amp; XModel, Model&lt;double&gt;&amp; XModel_g);\n\n\n\n\ntemplate &lt;class T&gt; Loop&lt;T&gt; InitLoop(Param &amp;XParam, Model&lt;T&gt; &amp;XModel)\n{\n    Loop&lt;T&gt; XLoop;\n    XLoop.atmpuni = T(XParam.Paref);\n    XLoop.totaltime = XParam.totaltime;\n    XLoop.nextoutputtime = XModel.OutputT[0];\n\n    // Prepare output files\n    InitSave2Netcdf(XParam, XModel);\n    InitTSOutput(XParam);\n    // Add empty row for each output point\n    // This will allow for the loop to each point to work later\n    for (int o = 0; o &lt; XParam.TSnodesout.size(); o++)\n    {\n        XLoop.TSAllout.push_back(std::vector&lt;Pointout&gt;());\n    }\n\n    // GPU stuff\n    //if (XParam.GPUDEVICE &gt;= 0)\n    //{\n        //XLoop.blockDim = (16, 16, 1);\n        //XLoop.gridDim = (XParam.nblk, 1, 1);\n    //}\n\n    //XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.hugenegval = T(-1.0)* XLoop.hugeposval;\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n\n    XLoop.dtmax = initdt(XParam, XLoop, XModel);\n    //XLoop.dtmin = XLoop.dtmax;\n\n    return XLoop;\n\n}\n\ntemplate &lt;class T&gt; void updateBnd(Param XParam, Loop&lt;T&gt; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    for (int ibndseg = 0; ibndseg &lt; XForcing.bndseg.size(); ibndseg++)\n    {\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n\n\n            Flowbnd(XParam, XLoop, XModel_g.blocks, XForcing.left, XForcing.Atmp, XModel_g.evolv);\n            Flowbnd(XParam, XLoop, XModel_g.blocks, XForcing.right, XForcing.Atmp, XModel_g.evolv);\n            Flowbnd(XParam, XLoop, XModel_g.blocks, XForcing.top, XForcing.Atmp, XModel_g.evolv);\n            Flowbnd(XParam, XLoop, XModel_g.blocks, XForcing.bot, XForcing.Atmp, XModel_g.evolv);\n\n        }\n        else\n        {\n            Flowbnd(XParam, XLoop, XModel.blocks, XForcing.left, XForcing.Atmp, XModel.evolv);\n            Flowbnd(XParam, XLoop, XModel.blocks, XForcing.right, XForcing.Atmp, XModel.evolv);\n            Flowbnd(XParam, XLoop, XModel.blocks, XForcing.top, XForcing.Atmp, XModel.evolv);\n            Flowbnd(XParam, XLoop, XModel.blocks, XForcing.bot, XForcing.Atmp, XModel.evolv);\n        }\n    }\n}\n\n\n\n\ntemplate &lt;class T&gt; void mapoutput(Param XParam, Loop&lt;T&gt; &amp;XLoop, Model&lt;T&gt;&amp; XModel, Model&lt;T&gt; XModel_g)\n{\n    XLoop.nstepout++;\n    double tiny = 0.0000001;\n    /*\n    if  (abs(XLoop.nextoutputtime - XParam.totaltime) &lt; tiny)\n    {\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n            {\n                CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[XParam.outvars[ivar]], XModel_g.OutputVarMap[XParam.outvars[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n            }\n        }\n\n        SaveInitialisation2Netcdf(XParam, XModel);\n\n        XLoop.indNextoutputtime++;\n        if (XLoop.indNextoutputtime &lt; XModel.OutputT.size())\n        {\n            XLoop.nextoutputtime = min(XModel.OutputT[XLoop.indNextoutputtime], XParam.endtime);\n\n        }\n\n        XLoop.nstepout = 0;\n\n    }\n    */\n    if (XLoop.nextoutputtime - XLoop.totaltime &lt;= XLoop.dt * tiny)\n    {\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n            {\n                CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[XParam.outvars[ivar]], XModel_g.OutputVarMap[XParam.outvars[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n            }\n        }\n\n        Save2Netcdf(XParam, XLoop, XModel);\n\n        XLoop.indNextoutputtime++;\n        if (XLoop.indNextoutputtime &lt; XModel.OutputT.size())\n        {\n            XLoop.nextoutputtime = min(XModel.OutputT[XLoop.indNextoutputtime], XParam.endtime);\n\n        }\n\n        XLoop.nstepout = 0;\n    }\n\n\n}\n\ntemplate &lt;class T&gt; void pointoutputstep(Param XParam, Loop&lt;T&gt; &amp;XLoop, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    //\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XModel.bndblk.nblkTs, 1, 1);\n    FILE* fsSLTS;\n    if (XParam.GPUDEVICE&gt;=0)\n    {\n\n        for (int o = 0; o &lt; XParam.TSnodesout.size(); o++)\n        {\n            //\n            Pointout stepread;\n\n            stepread.time = XLoop.totaltime;\n            stepread.zs = 0.0;// That is a bit useless\n            stepread.h = 0.0;\n            stepread.u = 0.0;\n            stepread.v = 0.0;\n            XLoop.TSAllout[o].push_back(stepread);\n\n\n            storeTSout &lt;&lt;&lt;gridDim, blockDim, 0 &gt;&gt;&gt; (XParam,(int)XParam.TSnodesout.size(), o, XLoop.nTSsteps, XParam.TSnodesout[o].block, XParam.TSnodesout[o].i, XParam.TSnodesout[o].j, XModel_g.bndblk.Tsout, XModel_g.evolv, XModel_g.TSstore);\n            CUDA_CHECK(cudaDeviceSynchronize());\n        }\n        //CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else\n    {\n        for (int o = 0; o &lt; XParam.TSnodesout.size(); o++)\n        {\n            //\n            Pointout stepread;\n\n            int i = memloc(XParam.halowidth, XParam.blkmemwidth, XParam.TSnodesout[o].i, XParam.TSnodesout[o].j, XParam.TSnodesout[o].block);\n\n            stepread.time = XLoop.totaltime;\n            stepread.zs = XModel.evolv.zs[i];\n            stepread.h = XModel.evolv.h[i];;\n            stepread.u = XModel.evolv.u[i];;\n            stepread.v = XModel.evolv.v[i];;\n            XLoop.TSAllout[o].push_back(stepread);\n\n        }\n    }\n    XLoop.nTSsteps++;\n\n    // if the buffer is full or if the model is complete\n    if ((XLoop.nTSsteps + 1) * XParam.TSnodesout.size() * 4 &gt; XParam.maxTSstorage || XParam.endtime - XLoop.totaltime &lt;= XLoop.dt * 0.00001f)\n    {\n\n        //Flush to disk\n        if (XParam.GPUDEVICE &gt;= 0 &amp;&amp; XParam.TSnodesout.size() &gt; 0)\n        {\n            CUDA_CHECK(cudaMemcpy(XModel.TSstore, XModel_g.TSstore, XParam.maxTSstorage * sizeof(T), cudaMemcpyDeviceToHost));\n            int oo;\n\n            for (int o = 0; o &lt; XParam.TSnodesout.size(); o++)\n            {\n                for (int istep = 0; istep &lt; XLoop.TSAllout[o].size(); istep++)\n                {\n                    oo = o * 4 + istep * int(XParam.TSnodesout.size()) * 4;\n                    //\n                    XLoop.TSAllout[o][istep].h = XModel.TSstore[0 + oo];\n                    XLoop.TSAllout[o][istep].zs = XModel.TSstore[1 + oo];\n                    XLoop.TSAllout[o][istep].u = XModel.TSstore[2 + oo];\n                    XLoop.TSAllout[o][istep].v = XModel.TSstore[3 + oo];\n                }\n            }\n\n        }\n        for (int o = 0; o &lt; XParam.TSnodesout.size(); o++)\n        {\n            fsSLTS = fopen(XParam.TSnodesout[o].outname.c_str(), \"a\");\n\n\n            for (int n = 0; n &lt; XLoop.nTSsteps; n++)\n            {\n                //\n\n\n                fprintf(fsSLTS, \"%f\\t%.4f\\t%.4f\\t%.4f\\t%.4f\\n\", XLoop.TSAllout[o][n].time, XLoop.TSAllout[o][n].zs, XLoop.TSAllout[o][n].h, XLoop.TSAllout[o][n].u, XLoop.TSAllout[o][n].v);\n\n\n            }\n            fclose(fsSLTS);\n            //reset output buffer\n            XLoop.TSAllout[o].clear();\n        }\n        // Reset buffer counter\n        XLoop.nTSsteps = 0;\n\n\n\n\n    }\n}\n\n\ntemplate &lt;class T&gt; __global__ void storeTSout(Param XParam,int noutnodes, int outnode, int istep,int blknode, int inode,int jnode, int * blkTS, EvolvingP&lt;T&gt; XEv, T* store)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = blkTS[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    //printf(\"ib=%d; ix=%d; iy=%d; blknode=%d; inode=%d; jnode=%d\\n\", ib, ix,iy,blknode,inode,jnode);\n\n    if (ib == blknode &amp;&amp; ix == inode &amp;&amp; iy == jnode)\n    {\n        store[0 + outnode * 4 + istep * noutnodes * 4] = XEv.h[i];\n        store[1 + outnode * 4 + istep * noutnodes * 4] = XEv.zs[i];\n        store[2 + outnode * 4 + istep * noutnodes * 4] = XEv.u[i];\n        store[3 + outnode * 4 + istep * noutnodes * 4] = XEv.v[i];\n\n\n\n        //printf(\"XEv.h[i]=%f; store[h]=%f\\n\", XEv.h[i], store[0 + outnode * 4 + istep * noutnodes * 4]);\n    }\n}\n\n\ntemplate &lt;class T&gt; __host__ double initdt(Param XParam, Loop&lt;T&gt; XLoop, Model&lt;T&gt; XModel)\n{\n    //dim3 blockDim = (XParam.blkwidth, XParam.blkwidth, 1);\n    //dim3 gridDim = (XParam.nblk, 1, 1);\n\n    double initdt;\n\n    XLoop.dtmax = XLoop.hugeposval;\n\n    //to limit the initial time steps (by user input)\n    if (XParam.dtinit &gt; 0)\n    {\n        XLoop.dtmax = XParam.dtinit / 1.5;\n    }\n    else\n    {\n        // WARNING here we specify at least an initial time step if there was 10.0m of water at the highest resolution cell.\n        // The modle will recalculate the optimal dt in subsequent step;\n        XLoop.dtmax = calcres(XParam.delta, XParam.maxlevel) / (sqrt(XParam.g * 10.0));\n    }\n\n    //BlockP&lt;T&gt; XBlock = XModel.blocks;\n\n    /*\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        CalcInitdtGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.time.dtmax);\n        initdt = double(CalctimestepGPU(XParam, XLoop, XModel.blocks, XModel.time));\n    }\n    else\n    {\n    */\n        CalcInitdtCPU(XParam, XModel.blocks, XModel.evolv, XModel.time.dtmax);\n        initdt = double(CalctimestepCPU(XParam, XLoop, XModel.blocks, XModel.time));\n\n    //}\n\n\n    return initdt;\n}\ntemplate __host__ double initdt&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, Model&lt;float&gt; XModel);\ntemplate __host__ double initdt&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, Model&lt;double&gt; XModel);\n\ntemplate &lt;class T&gt; __host__ void CalcInitdtCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEvolv, T* dtmax)\n{\n    int ib;\n    T delta;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                dtmax[i] = delta / sqrt(T(XParam.g) * std::max(XEvolv.h[i],T(XParam.eps)));\n            }\n        }\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void CalcInitdtGPU(Param XParam, BlockP&lt;T&gt; XBlock,EvolvingP&lt;T&gt; XEvolv, T* dtmax)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    T delta = calcres(XParam.delta, XBlock.level[ib]);\n\n    dtmax[i] = delta / sqrt(XParam.g * max(XEvolv.h[i],T(XParam.eps)));\n}\n\n\ntemplate &lt;class T&gt; void printstatus(T totaltime, T dt)\n{\n    std::cout &lt;&lt; \"\\r\\e[K\" &lt;&lt; std::flush;\n    std::cout &lt;&lt; \"\\rtotaltime = \"&lt;&lt; std::to_string(totaltime) &lt;&lt; \"   dt = \" &lt;&lt; std::to_string(dt) &lt;&lt; std::flush;\n    std::cout &lt;&lt; \"\\r\" &lt;&lt; std::flush;\n    //std::cout &lt;&lt; std::endl; // all done\n}\n\ntemplate &lt;class T&gt; void CrashDetection(Param&amp; XParam, Loop&lt;T&gt; XLoop, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    if ((XLoop.dt &lt; XParam.dtmin) &amp;&amp; (XLoop.totaltime &lt; XParam.endtime))\n    {\n        // stop the model\n        XParam.endtime = XLoop.totaltime;\n        XLoop.nextoutputtime = XLoop.totaltime;\n\n        log(\" \\n \");\n        log(\"\\t\\tModel CRASHED: time steps (\" + std::to_string(XLoop.dt) + \") inferior to \" + std::to_string(XParam.dtmin) + \"\\n\");\n\n        std::vector&lt;std::string&gt; outvi = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"ho\",\"vo\",\"uo\",\"zso\" };\n        std::vector&lt;std::string&gt; outvold = XParam.outvars;\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            for (int ivar = 0; ivar &lt; outvi.size(); ivar++)\n            {\n                CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[outvi[ivar]], XModel_g.OutputVarMap[outvi[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n            }\n        }\n        std::vector&lt;std::string&gt; extvec = split(XModel.blocks.outZone[0].outname, '.');\n        std::string newname, oldname;\n\n        oldname = XParam.outfile;\n\n        newname = extvec[0];\n        for (int nstin = 1; nstin &lt; extvec.size() - 1; nstin++)\n        {\n            // This is in case there are \".\" in the file name that do not relate to the file extension\"\n            newname = newname + \".\" + extvec[nstin];\n        }\n        newname = newname + \"_CrashReport.nc\";\n\n        //XParam.outfile = newname;\n        XParam.outvars = outvi;\n\n\n        outzoneB XzoneB;\n        std::vector&lt;int&gt; blksall;\n        //Define the full domain as a zone\n        XzoneB.outname = newname; //.assign(XParam.outfile);\n        XzoneB.xo = XParam.xo;\n        XzoneB.yo = XParam.yo;\n        XzoneB.xmax = XParam.xmax;\n        XzoneB.ymax = XParam.ymax;\n        XzoneB.nblk = XParam.nblk;\n        XzoneB.maxlevel = XParam.maxlevel;\n        XzoneB.minlevel = XParam.minlevel;\n        AllocateCPU(XParam.nblk, 1, XzoneB.blk);\n        int I = 0;\n        for (int ib = 0; ib &lt; XParam.nblk; ib++)\n        {\n            XzoneB.blk[ib] = XModel.blocks.active[ib];\n        }\n        //InitSave2Netcdf(XParam, XModel);\n        creatncfileBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, XzoneB);\n        writenctimestep(XzoneB.outname, XParam.totaltime);\n        for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n        {\n            defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, XParam.outvars[ivar], 3, XModel.OutputVarMap[XParam.outvars[ivar]], XzoneB);\n        }\n        XParam.outvars = outvold;\n        //XParam.outfile = oldname;\n\n\n\n    }\n    //double weight = 0.25;\n    //log(\"\\t\\tdt=\" + std::to_string(XLoop.dt) + \", dtmin=\" + std::to_string(XLoop.dtmin) + \"\\n\");\n    //XLoop.dtmin = weight * XLoop.dt + (1 - weight) * XLoop.dtmin;\n\n}\n</code></pre>"},{"location":"BGFlood/Mainloop_8h/","title":"File Mainloop.h","text":""},{"location":"BGFlood/Mainloop_8h/#file-mainlooph","title":"File Mainloop.h","text":"<p>FileList &gt; src &gt; Mainloop.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Mesh.h\"</code></li> <li><code>#include \"Write_netcdf.h\"</code></li> <li><code>#include \"InitialConditions.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Boundary.h\"</code></li> <li><code>#include \"FlowGPU.h\"</code></li> <li><code>#include \"FlowCPU.h\"</code></li> <li><code>#include \"Meanmax.h\"</code></li> <li><code>#include \"Updateforcing.h\"</code></li> <li><code>#include \"FlowMLGPU.h\"</code></li> </ul>"},{"location":"BGFlood/Mainloop_8h/#public-functions","title":"Public Functions","text":"Type Name void DebugLoop (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; &amp; XModel, Model&lt; T &gt; &amp; XModel_g)  Loop&lt; T &gt; InitLoop (Param &amp; XParam, Model&lt; T &gt; &amp; XModel)  void MainLoop (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; &amp; XModel, Model&lt; T &gt; &amp; XModel_g)  __host__ double initdt (Param XParam, Loop&lt; T &gt; XLoop, Model&lt; T &gt; XModel)  void printstatus (T totaltime, T dt)  __global__ void storeTSout (Param XParam, int noutnodes, int outnode, int istep, int blknode, int inode, int jnode, int * blkTS, EvolvingP&lt; T &gt; XEv, T * store)"},{"location":"BGFlood/Mainloop_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Mainloop_8h/#function-debugloop","title":"function DebugLoop","text":"<pre><code>template&lt;class T&gt;\nvoid DebugLoop (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; &amp; XModel,\n    Model &lt; T &gt; &amp; XModel_g\n) \n</code></pre> <p>Debugging loop This function was crated to debug to properly wrap the debug flow engine of the model </p>"},{"location":"BGFlood/Mainloop_8h/#function-initloop","title":"function InitLoop","text":"<pre><code>template&lt;class T&gt;\nLoop &lt; T &gt; InitLoop (\n    Param &amp; XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8h/#function-mainloop","title":"function MainLoop","text":"<pre><code>template&lt;class T&gt;\nvoid MainLoop (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; &amp; XModel,\n    Model &lt; T &gt; &amp; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8h/#function-initdt","title":"function initdt","text":"<pre><code>template&lt;class T&gt;\n__host__ double initdt (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8h/#function-printstatus","title":"function printstatus","text":"<pre><code>template&lt;class T&gt;\nvoid printstatus (\n    T totaltime,\n    T dt\n) \n</code></pre>"},{"location":"BGFlood/Mainloop_8h/#function-storetsout","title":"function storeTSout","text":"<pre><code>template&lt;class T&gt;\n__global__ void storeTSout (\n    Param XParam,\n    int noutnodes,\n    int outnode,\n    int istep,\n    int blknode,\n    int inode,\n    int jnode,\n    int * blkTS,\n    EvolvingP &lt; T &gt; XEv,\n    T * store\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Mainloop.h</code></p>"},{"location":"BGFlood/Mainloop_8h_source/","title":"File Mainloop.h","text":""},{"location":"BGFlood/Mainloop_8h_source/#file-mainlooph","title":"File Mainloop.h","text":"<p>File List &gt; src &gt; Mainloop.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef MAINLOOP_H\n#define MAINLOOP_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"Mesh.h\"\n#include \"Write_netcdf.h\"\n#include \"InitialConditions.h\"\n#include \"MemManagement.h\"\n#include \"Boundary.h\"\n#include \"FlowGPU.h\"\n#include \"FlowCPU.h\"\n#include \"Meanmax.h\"\n#include \"Updateforcing.h\"\n#include \"FlowMLGPU.h\"\n\ntemplate &lt;class T&gt; void MainLoop(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel, Model&lt;T&gt;&amp; XModel_g);\n\ntemplate &lt;class T&gt; void DebugLoop(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel, Model&lt;T&gt;&amp; XModel_g);\n\ntemplate &lt;class T&gt; __host__ double initdt(Param XParam, Loop&lt;T&gt; XLoop, Model&lt;T&gt; XModel);\n\ntemplate &lt;class T&gt; Loop&lt;T&gt; InitLoop(Param&amp; XParam, Model&lt;T&gt;&amp; XModel);\n\ntemplate &lt;class T&gt; void printstatus(T totaltime, T dt);\n\n\ntemplate &lt;class T&gt; __global__ void storeTSout(Param XParam, int noutnodes, int outnode, int istep, int blknode, int inode, int jnode, int* blkTS, EvolvingP&lt;T&gt; XEv, T* store);\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/","title":"File Meanmax.cu","text":""},{"location":"BGFlood/Meanmax_8cu/#file-meanmaxcu","title":"File Meanmax.cu","text":"<p>FileList &gt; src &gt; Meanmax.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Meanmax.h\"</code></li> </ul>"},{"location":"BGFlood/Meanmax_8cu/#public-functions","title":"Public Functions","text":"Type Name void Calcmeanmax (Param XParam, Loop&lt; T &gt; &amp; XLoop, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  template void Calcmeanmax&lt; double &gt; (Param XParam, Loop&lt; double &gt; &amp; XLoop, Model&lt; double &gt; XModel, Model&lt; double &gt; XModel_g)  template void Calcmeanmax&lt; float &gt; (Param XParam, Loop&lt; float &gt; &amp; XLoop, Model&lt; float &gt; XModel, Model&lt; float &gt; XModel_g)  void Initmeanmax (Param XParam, Loop&lt; T &gt; XLoop, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  template void Initmeanmax&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, Model&lt; double &gt; XModel, Model&lt; double &gt; XModel_g)  template void Initmeanmax&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, Model&lt; float &gt; XModel, Model&lt; float &gt; XModel_g)  __host__ void addUandhU_CPU (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * u, T * v, T * U, T * hU)  __global__ void addUandhU_GPU (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * u, T * v, T * U, T * hU)  __host__ void addavg_varCPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmean, T * Var)  __global__ void addavg_varGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmean, T * Var)  __host__ void addwettime_CPU (Param XParam, BlockP&lt; T &gt; XBlock, T * wett, T * h, T thresold, T time)  __global__ void addwettime_GPU (Param XParam, BlockP&lt; T &gt; XBlock, T * wett, T * h, T thresold, T time)  __host__ void divavg_varCPU (Param XParam, BlockP&lt; T &gt; XBlock, T ntdiv, T * Varmean)  __global__ void divavg_varGPU (Param XParam, BlockP&lt; T &gt; XBlock, T ntdiv, T * Varmean)  __host__ void max_Norm_CPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * Var1, T * Var2)  __global__ void max_Norm_GPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * Var1, T * Var2)  __host__ void max_hU_CPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * h, T * u, T * v)  __global__ void max_hU_GPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * h, T * u, T * v)  __host__ void max_varCPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * Var)  __global__ void max_varGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * Var)  void resetmaxCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, EvolvingP_M&lt; T &gt; &amp; XEv)  void resetmaxGPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, EvolvingP_M&lt; T &gt; &amp; XEv)  void resetmeanCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, EvolvingP_M&lt; T &gt; &amp; XEv)  template void resetmeanCPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, EvolvingP_M&lt; double &gt; &amp; XEv)  template void resetmeanCPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, EvolvingP_M&lt; float &gt; &amp; XEv)  void resetmeanGPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, EvolvingP_M&lt; T &gt; &amp; XEv)  template void resetmeanGPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, EvolvingP_M&lt; double &gt; &amp; XEv)  template void resetmeanGPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, EvolvingP_M&lt; float &gt; &amp; XEv)  void resetmeanmax (Param XParam, Loop&lt; T &gt; &amp; XLoop, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  template void resetmeanmax&lt; double &gt; (Param XParam, Loop&lt; double &gt; &amp; XLoop, Model&lt; double &gt; XModel, Model&lt; double &gt; XModel_g)  template void resetmeanmax&lt; float &gt; (Param XParam, Loop&lt; float &gt; &amp; XLoop, Model&lt; float &gt; XModel, Model&lt; float &gt; XModel_g)  void resetvalCPU (Param XParam, BlockP&lt; T &gt; XBlock, T *&amp; var, T val)  template void resetvalCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double *&amp; var, double val)  template void resetvalCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float *&amp; var, float val)  void resetvalGPU (Param XParam, BlockP&lt; T &gt; XBlock, T *&amp; var, T val)  template void resetvalGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double *&amp; var, double val)  template void resetvalGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float *&amp; var, float val)"},{"location":"BGFlood/Meanmax_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Meanmax_8cu/#function-calcmeanmax","title":"function Calcmeanmax","text":"<pre><code>template&lt;class T&gt;\nvoid Calcmeanmax (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-calcmeanmax-double","title":"function Calcmeanmax&lt; double &gt;","text":"<pre><code>template void Calcmeanmax&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; &amp; XLoop,\n    Model &lt; double &gt; XModel,\n    Model &lt; double &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-calcmeanmax-float","title":"function Calcmeanmax&lt; float &gt;","text":"<pre><code>template void Calcmeanmax&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; &amp; XLoop,\n    Model &lt; float &gt; XModel,\n    Model &lt; float &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-initmeanmax","title":"function Initmeanmax","text":"<pre><code>template&lt;class T&gt;\nvoid Initmeanmax (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-initmeanmax-double","title":"function Initmeanmax&lt; double &gt;","text":"<pre><code>template void Initmeanmax&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    Model &lt; double &gt; XModel,\n    Model &lt; double &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-initmeanmax-float","title":"function Initmeanmax&lt; float &gt;","text":"<pre><code>template void Initmeanmax&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    Model &lt; float &gt; XModel,\n    Model &lt; float &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-adduandhu_cpu","title":"function addUandhU_CPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void addUandhU_CPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * u,\n    T * v,\n    T * U,\n    T * hU\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-adduandhu_gpu","title":"function addUandhU_GPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void addUandhU_GPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * u,\n    T * v,\n    T * U,\n    T * hU\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-addavg_varcpu","title":"function addavg_varCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void addavg_varCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmean,\n    T * Var\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-addavg_vargpu","title":"function addavg_varGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void addavg_varGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmean,\n    T * Var\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-addwettime_cpu","title":"function addwettime_CPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void addwettime_CPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * wett,\n    T * h,\n    T thresold,\n    T time\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-addwettime_gpu","title":"function addwettime_GPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void addwettime_GPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * wett,\n    T * h,\n    T thresold,\n    T time\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-divavg_varcpu","title":"function divavg_varCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void divavg_varCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T ntdiv,\n    T * Varmean\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-divavg_vargpu","title":"function divavg_varGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void divavg_varGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T ntdiv,\n    T * Varmean\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-max_norm_cpu","title":"function max_Norm_CPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void max_Norm_CPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * Var1,\n    T * Var2\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-max_norm_gpu","title":"function max_Norm_GPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void max_Norm_GPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * Var1,\n    T * Var2\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-max_hu_cpu","title":"function max_hU_CPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void max_hU_CPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * h,\n    T * u,\n    T * v\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-max_hu_gpu","title":"function max_hU_GPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void max_hU_GPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * h,\n    T * u,\n    T * v\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-max_varcpu","title":"function max_varCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void max_varCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * Var\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-max_vargpu","title":"function max_varGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void max_varGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * Var\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-resetmaxcpu","title":"function resetmaxCPU","text":"<pre><code>template&lt;class T&gt;\nvoid resetmaxCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP_M &lt; T &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-resetmaxgpu","title":"function resetmaxGPU","text":"<pre><code>template&lt;class T&gt;\nvoid resetmaxGPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP_M &lt; T &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-resetmeancpu","title":"function resetmeanCPU","text":"<pre><code>template&lt;class T&gt;\nvoid resetmeanCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP_M &lt; T &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-resetmeancpu-double","title":"function resetmeanCPU&lt; double &gt;","text":"<pre><code>template void resetmeanCPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP_M &lt; double &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-resetmeancpu-float","title":"function resetmeanCPU&lt; float &gt;","text":"<pre><code>template void resetmeanCPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP_M &lt; float &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-resetmeangpu","title":"function resetmeanGPU","text":"<pre><code>template&lt;class T&gt;\nvoid resetmeanGPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP_M &lt; T &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-resetmeangpu-double","title":"function resetmeanGPU&lt; double &gt;","text":"<pre><code>template void resetmeanGPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP_M &lt; double &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-resetmeangpu-float","title":"function resetmeanGPU&lt; float &gt;","text":"<pre><code>template void resetmeanGPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP_M &lt; float &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-resetmeanmax","title":"function resetmeanmax","text":"<pre><code>template&lt;class T&gt;\nvoid resetmeanmax (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-resetmeanmax-double","title":"function resetmeanmax&lt; double &gt;","text":"<pre><code>template void resetmeanmax&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; &amp; XLoop,\n    Model &lt; double &gt; XModel,\n    Model &lt; double &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-resetmeanmax-float","title":"function resetmeanmax&lt; float &gt;","text":"<pre><code>template void resetmeanmax&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; &amp; XLoop,\n    Model &lt; float &gt; XModel,\n    Model &lt; float &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-resetvalcpu","title":"function resetvalCPU","text":"<pre><code>template&lt;class T&gt;\nvoid resetvalCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; var,\n    T val\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-resetvalcpu-double","title":"function resetvalCPU&lt; double &gt;","text":"<pre><code>template void resetvalCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double *&amp; var,\n    double val\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-resetvalcpu-float","title":"function resetvalCPU&lt; float &gt;","text":"<pre><code>template void resetvalCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float *&amp; var,\n    float val\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-resetvalgpu","title":"function resetvalGPU","text":"<pre><code>template&lt;class T&gt;\nvoid resetvalGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; var,\n    T val\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-resetvalgpu-double","title":"function resetvalGPU&lt; double &gt;","text":"<pre><code>template void resetvalGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double *&amp; var,\n    double val\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8cu/#function-resetvalgpu-float","title":"function resetvalGPU&lt; float &gt;","text":"<pre><code>template void resetvalGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float *&amp; var,\n    float val\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Meanmax.cu</code></p>"},{"location":"BGFlood/Meanmax_8cu_source/","title":"File Meanmax.cu","text":""},{"location":"BGFlood/Meanmax_8cu_source/#file-meanmaxcu","title":"File Meanmax.cu","text":"<p>File List &gt; src &gt; Meanmax.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Meanmax.h\"\n\n// Calculate the mean and or max of requested variable on the GPU/CPU\ntemplate &lt;class T&gt; void Calcmeanmax(Param XParam, Loop&lt;T&gt;&amp; XLoop, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n\n    if (XParam.outmean)\n    {\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            addavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmean.h, XModel_g.evolv.h);\n            addavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmean.zs, XModel_g.evolv.zs);\n            addavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmean.u, XModel_g.evolv.u);\n            addavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmean.v, XModel_g.evolv.v);\n            addUandhU_GPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evolv.h, XModel_g.evolv.u, XModel_g.evolv.v, XModel_g.evmean.U, XModel_g.evmean.hU);\n\n            CUDA_CHECK(cudaDeviceSynchronize());\n        }\n        else\n        {\n\n            addavg_varCPU(XParam, XModel.blocks, XModel.evmean.h, XModel.evolv.h);\n            addavg_varCPU(XParam, XModel.blocks, XModel.evmean.zs, XModel.evolv.zs);\n            addavg_varCPU(XParam, XModel.blocks, XModel.evmean.u, XModel.evolv.u);\n            addavg_varCPU(XParam, XModel.blocks, XModel.evmean.v, XModel.evolv.v);\n            addUandhU_CPU(XParam, XModel.blocks, XModel.evolv.h, XModel.evolv.u, XModel.evolv.v, XModel.evmean.U, XModel.evmean.hU);\n\n        }\n\n\n        XLoop.nstep++;\n\n        if (XLoop.nextoutputtime - XLoop.totaltime &lt;= XLoop.dt * T(0.00001))\n        {\n            // devide by number of steps\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                divavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, T(XLoop.nstep), XModel_g.evmean.h);\n                divavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, T(XLoop.nstep), XModel_g.evmean.zs);\n                divavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, T(XLoop.nstep), XModel_g.evmean.u);\n                divavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, T(XLoop.nstep), XModel_g.evmean.v);\n                divavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, T(XLoop.nstep), XModel_g.evmean.U);\n                divavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, T(XLoop.nstep), XModel_g.evmean.hU);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n            else\n            {\n                divavg_varCPU(XParam, XModel.blocks, T(XLoop.nstep), XModel.evmean.h);\n                divavg_varCPU(XParam, XModel.blocks, T(XLoop.nstep), XModel.evmean.zs);\n                divavg_varCPU(XParam, XModel.blocks, T(XLoop.nstep), XModel.evmean.u);\n                divavg_varCPU(XParam, XModel.blocks, T(XLoop.nstep), XModel.evmean.v);\n                divavg_varCPU(XParam, XModel.blocks, T(XLoop.nstep), XModel.evmean.U);\n                divavg_varCPU(XParam, XModel.blocks, T(XLoop.nstep), XModel.evmean.hU);\n            }\n\n            //XLoop.nstep will be reset after a save to the disk which occurs in a different function\n        }\n\n    }\n    if (XParam.outmax)\n    {\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            max_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmax.h, XModel_g.evolv.h);\n            max_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmax.zs, XModel_g.evolv.zs);\n            max_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmax.u, XModel_g.evolv.u);\n            max_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmax.v, XModel_g.evolv.v);\n            max_Norm_GPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmax.U, XModel_g.evolv.u, XModel_g.evolv.v);\n            max_hU_GPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmax.hU, XModel_g.evolv.h, XModel_g.evolv.u, XModel_g.evolv.v);\n            CUDA_CHECK(cudaDeviceSynchronize());\n        }\n        else\n        {\n            max_varCPU(XParam, XModel.blocks, XModel.evmax.h, XModel.evolv.h);\n            max_varCPU(XParam, XModel.blocks, XModel.evmax.zs, XModel.evolv.zs);\n            max_varCPU(XParam, XModel.blocks, XModel.evmax.u, XModel.evolv.u);\n            max_varCPU(XParam, XModel.blocks, XModel.evmax.v, XModel.evolv.v);\n            max_Norm_CPU(XParam, XModel.blocks, XModel.evmax.U, XModel.evolv.u, XModel.evolv.v);\n            max_hU_CPU(XParam, XModel.blocks, XModel.evmax.hU, XModel.evolv.h, XModel.evolv.u, XModel.evolv.v);\n        }\n    }\n    if (XParam.outtwet)\n    {\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            // Add value GPU\n            addwettime_GPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.wettime, XModel_g.evolv.h, T(XParam.wet_threshold), T(XLoop.dt));\n        }\n        else\n        {\n            // Add value CPU\n            addwettime_CPU(XParam, XModel.blocks, XModel.wettime, XModel.evolv.h, T(XParam.wet_threshold), T(XLoop.dt));\n        }\n    }\n}\ntemplate void Calcmeanmax&lt;float&gt;(Param XParam, Loop&lt;float&gt;&amp; XLoop, Model&lt;float&gt; XModel, Model&lt;float&gt; XModel_g);\ntemplate void Calcmeanmax&lt;double&gt;(Param XParam, Loop&lt;double&gt;&amp; XLoop, Model&lt;double&gt; XModel, Model&lt;double&gt; XModel_g);\n\n\ntemplate &lt;class T&gt; void resetmeanmax(Param XParam, Loop&lt;T&gt;&amp; XLoop, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    // Reset mean and or max only at output steps\n    //XLoop.nextoutputtime - XLoop.totaltime &lt;= XLoop.dt * T(0.00001)\n    if (XLoop.nstepout == 0) //This implis an output was just produced so need to reset\n    {\n        //Define some useful variables \n        if (XParam.outmean)\n        {\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                resetmeanGPU(XParam, XLoop, XModel_g.blocks, XModel_g.evmean);\n            }\n            else\n            {\n                resetmeanCPU(XParam, XLoop, XModel.blocks, XModel.evmean);\n            }\n            XLoop.nstep = 0;\n        }\n\n        //Reset Max \n        if (XParam.outmax &amp;&amp; XParam.resetmax)\n        {\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                resetmaxGPU(XParam, XLoop, XModel_g.blocks, XModel_g.evmax);\n            }\n            else\n            {\n                resetmaxCPU(XParam, XLoop, XModel.blocks, XModel.evmax);\n\n            }\n        }\n\n        //Reset Wet duration\n        if (XParam.outtwet &amp;&amp; XParam.resetmax)\n        {\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                resetvalGPU(XParam, XModel_g.blocks, XModel_g.wettime, T(0.0));\n            }\n            else\n            {\n                resetvalCPU(XParam, XModel.blocks, XModel.wettime, T(0.0));\n            }\n        }\n    }\n}\ntemplate void resetmeanmax&lt;float&gt;(Param XParam, Loop&lt;float&gt;&amp; XLoop, Model&lt;float&gt; XModel, Model&lt;float&gt; XModel_g);\ntemplate void resetmeanmax&lt;double&gt;(Param XParam, Loop&lt;double&gt;&amp; XLoop, Model&lt;double&gt; XModel, Model&lt;double&gt; XModel_g);\n\ntemplate &lt;class T&gt; void Initmeanmax(Param XParam, Loop&lt;T&gt; XLoop, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    //at the initial step overide the reset max to initialise the max variable (if needed)\n    //this override is not preserved so wont affect the rest of the loop\n    XParam.resetmax = true;\n    XLoop.nextoutputtime = XLoop.totaltime;\n    XLoop.dt = T(1.0);\n    resetmeanmax(XParam, XLoop, XModel, XModel_g);\n}\ntemplate void Initmeanmax&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, Model&lt;float&gt; XModel, Model&lt;float&gt; XModel_g);\ntemplate void Initmeanmax&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, Model&lt;double&gt; XModel, Model&lt;double&gt; XModel_g);\n\ntemplate &lt;class T&gt; void resetmaxGPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, EvolvingP_M&lt;T&gt;&amp; XEv)\n{\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XLoop.hugenegval, XEv.h);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XLoop.hugenegval, XEv.zs);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XLoop.hugenegval, XEv.u);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XLoop.hugenegval, XEv.v);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XLoop.hugenegval, XEv.U);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XLoop.hugenegval, XEv.hU);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n}\n\n\ntemplate &lt;class T&gt; void resetmaxCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, EvolvingP_M&lt;T&gt;&amp; XEv)\n{\n\n    InitArrayBUQ(XParam, XBlock, XLoop.hugenegval, XEv.h);\n    InitArrayBUQ(XParam, XBlock, XLoop.hugenegval, XEv.zs);\n    InitArrayBUQ(XParam, XBlock, XLoop.hugenegval, XEv.u);\n    InitArrayBUQ(XParam, XBlock, XLoop.hugenegval, XEv.v);\n    InitArrayBUQ(XParam, XBlock, XLoop.hugenegval, XEv.U);\n    InitArrayBUQ(XParam, XBlock, XLoop.hugenegval, XEv.hU);\n\n}\n\n\ntemplate &lt;class T&gt; void resetmeanCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, EvolvingP_M&lt;T&gt;&amp; XEv)\n{\n\n    InitArrayBUQ(XParam, XBlock, T(0.0), XEv.h);\n    InitArrayBUQ(XParam, XBlock, T(0.0), XEv.zs);\n    InitArrayBUQ(XParam, XBlock, T(0.0), XEv.u);\n    InitArrayBUQ(XParam, XBlock, T(0.0), XEv.v);\n    InitArrayBUQ(XParam, XBlock, T(0.0), XEv.U);\n    InitArrayBUQ(XParam, XBlock, T(0.0), XEv.hU);\n\n}\ntemplate void resetmeanCPU&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, EvolvingP_M&lt;float&gt;&amp; XEv);\ntemplate void resetmeanCPU&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, EvolvingP_M&lt;double&gt;&amp; XEv);\n\ntemplate &lt;class T&gt; void resetmeanGPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, EvolvingP_M&lt;T&gt;&amp; XEv)\n{\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n    //\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, T(0.0), XEv.h);\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, T(0.0), XEv.zs);\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, T(0.0), XEv.u);\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, T(0.0), XEv.v);\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, T(0.0), XEv.U);\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, T(0.0), XEv.hU);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n}\ntemplate void resetmeanGPU&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, EvolvingP_M&lt;float&gt;&amp; XEv);\ntemplate void resetmeanGPU&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, EvolvingP_M&lt;double&gt;&amp; XEv);\n\n\ntemplate &lt;class T&gt; void resetvalCPU(Param XParam, BlockP&lt;T&gt; XBlock, T*&amp; var, T val)\n{\n\n    InitArrayBUQ(XParam, XBlock, val, var);\n\n}\ntemplate void resetvalCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float*&amp; var, float val);\ntemplate void resetvalCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double*&amp; var, double val);\n\ntemplate &lt;class T&gt; void resetvalGPU(Param XParam, BlockP&lt;T&gt; XBlock, T*&amp; var, T val)\n{\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, val, var);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n}\ntemplate void resetvalGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float*&amp; var, float val);\ntemplate void resetvalGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double*&amp; var, double val);\n\n\n\ntemplate &lt;class T&gt; __global__ void addavg_varGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmean, T* Var)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n\n    Varmean[i] = Varmean[i] + Var[i];\n\n}\n\n\ntemplate &lt;class T&gt; __host__ void addavg_varCPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmean, T* Var)\n{\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                Varmean[i] = Varmean[i] + Var[i];\n            }\n        }\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void divavg_varGPU(Param XParam, BlockP&lt;T&gt; XBlock, T ntdiv, T* Varmean)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    Varmean[i] = Varmean[i] / ntdiv;\n\n}\n\ntemplate &lt;class T&gt; __host__ void divavg_varCPU(Param XParam, BlockP&lt;T&gt; XBlock, T ntdiv, T* Varmean)\n{\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                Varmean[i] = Varmean[i] / ntdiv;\n            }\n        }\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void addUandhU_GPU(Param XParam, BlockP&lt;T&gt; XBlock, T * h, T * u, T * v, T* U, T* hU)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    U[i] = sqrt((u[i] * u[i]) + (v[i] * v[i]));\n    hU[i] = h[i] * U[i];\n\n}\n\ntemplate &lt;class T&gt; __host__ void addUandhU_CPU(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* u, T* v, T* U, T* hU)\n{\n    int ib, n;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                U[i] = sqrt((u[i] * u[i]) + (v[i] * v[i]));\n                hU[i] = h[i] * U[i];\n            }\n        }\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void max_varGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* Var)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    Varmax[i] = max(Varmax[i], Var[i]);\n\n}\n\ntemplate &lt;class T&gt; __global__ void max_Norm_GPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* Var1, T* Var2)\n{\n    T Var_norm;\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    Var_norm = sqrt((Var1[i] * Var1[i]) + (Var2[i] * Var2[i]));\n    Varmax[i] = max(Varmax[i], Var_norm);\n\n}\n\ntemplate &lt;class T&gt; __global__ void max_hU_GPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* h, T* u, T* v)\n{\n    T Var_hU;\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    Var_hU = h[i] * sqrt((u[i]*u[i])+(v[i]*v[i]));\n    Varmax[i] = max(Varmax[i], Var_hU);\n\n}\n\ntemplate &lt;class T&gt; __host__ void max_varCPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* Var)\n{\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                Varmax[i] = utils::max(Varmax[i], Var[i]);\n            }\n        }\n    }\n\n}\n\ntemplate &lt;class T&gt; __host__ void max_Norm_CPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* Var1, T* Var2)\n{\n    int ib, n;\n    T Var_norm;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n                Var_norm = sqrt((Var1[i] * Var1[i]) + (Var2[i] * Var2[i]));\n                Varmax[i] = utils::max(Varmax[i], Var_norm);\n            }\n        }\n    }\n\n}\n\ntemplate &lt;class T&gt; __host__ void max_hU_CPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* h, T* u, T* v)\n{\n    int ib, n;\n    T Var_hU;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n                Var_hU = h[i] * sqrt((u[i] * u[i]) + (v[i] * v[i]));\n                Varmax[i] = utils::max(Varmax[i], Var_hU);\n            }\n        }\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void addwettime_GPU(Param XParam, BlockP&lt;T&gt; XBlock, T* wett, T* h, T thresold, T time)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    if (h[i] &gt; thresold)\n    {\n        wett[i] = wett[i] + time;\n    }\n\n}\n\n\ntemplate &lt;class T&gt; __host__ void addwettime_CPU(Param XParam, BlockP&lt;T&gt; XBlock, T* wett, T* h, T thresold, T time)\n{\n    int ib, n;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                if (h[i] &gt; thresold)\n                {\n                    wett[i] = wett[i] + time;\n                }\n            }\n        }\n    }\n\n}\n</code></pre>"},{"location":"BGFlood/Meanmax_8h/","title":"File Meanmax.h","text":""},{"location":"BGFlood/Meanmax_8h/#file-meanmaxh","title":"File Meanmax.h","text":"<p>FileList &gt; src &gt; Meanmax.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"FlowGPU.h\"</code></li> </ul>"},{"location":"BGFlood/Meanmax_8h/#public-functions","title":"Public Functions","text":"Type Name void Calcmeanmax (Param XParam, Loop&lt; T &gt; &amp; XLoop, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  void Initmeanmax (Param XParam, Loop&lt; T &gt; XLoop, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  __global__ void addUandhU_GPU (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * u, T * v, T * U, T * hU)  __global__ void addavg_varGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmean, T * Var)  __global__ void addwettime_GPU (Param XParam, BlockP&lt; T &gt; XBlock, T * wett, T * h, T thresold, T time)  __global__ void divavg_varGPU (Param XParam, BlockP&lt; T &gt; XBlock, T ntdiv, T * Varmean)  __global__ void max_Norm_GPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * Var1, T * Var2)  __global__ void max_hU_GPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * Var1, T * Var2, T * Var3)  __global__ void max_varGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * Var)  void resetmeanmax (Param XParam, Loop&lt; T &gt; &amp; XLoop, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  void resetvalGPU (Param XParam, BlockP&lt; T &gt; XBlock, T *&amp; var, T val)"},{"location":"BGFlood/Meanmax_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Meanmax_8h/#function-calcmeanmax","title":"function Calcmeanmax","text":"<pre><code>template&lt;class T&gt;\nvoid Calcmeanmax (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8h/#function-initmeanmax","title":"function Initmeanmax","text":"<pre><code>template&lt;class T&gt;\nvoid Initmeanmax (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8h/#function-adduandhu_gpu","title":"function addUandhU_GPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void addUandhU_GPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * u,\n    T * v,\n    T * U,\n    T * hU\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8h/#function-addavg_vargpu","title":"function addavg_varGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void addavg_varGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmean,\n    T * Var\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8h/#function-addwettime_gpu","title":"function addwettime_GPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void addwettime_GPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * wett,\n    T * h,\n    T thresold,\n    T time\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8h/#function-divavg_vargpu","title":"function divavg_varGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void divavg_varGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T ntdiv,\n    T * Varmean\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8h/#function-max_norm_gpu","title":"function max_Norm_GPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void max_Norm_GPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * Var1,\n    T * Var2\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8h/#function-max_hu_gpu","title":"function max_hU_GPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void max_hU_GPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * Var1,\n    T * Var2,\n    T * Var3\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8h/#function-max_vargpu","title":"function max_varGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void max_varGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * Var\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8h/#function-resetmeanmax","title":"function resetmeanmax","text":"<pre><code>template&lt;class T&gt;\nvoid resetmeanmax (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Meanmax_8h/#function-resetvalgpu","title":"function resetvalGPU","text":"<pre><code>template&lt;class T&gt;\nvoid resetvalGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; var,\n    T val\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Meanmax.h</code></p>"},{"location":"BGFlood/Meanmax_8h_source/","title":"File Meanmax.h","text":""},{"location":"BGFlood/Meanmax_8h_source/#file-meanmaxh","title":"File Meanmax.h","text":"<p>File List &gt; src &gt; Meanmax.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef MEANMAX_H\n#define MEANMAX_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"FlowGPU.h\"\n\n\ntemplate &lt;class T&gt; void Calcmeanmax(Param XParam, Loop&lt;T&gt;&amp; XLoop, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g);\ntemplate &lt;class T&gt; void resetmeanmax(Param XParam, Loop&lt;T&gt;&amp; XLoop, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g);\ntemplate &lt;class T&gt; void Initmeanmax(Param XParam, Loop&lt;T&gt; XLoop, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g);\ntemplate &lt;class T&gt; void resetvalGPU(Param XParam, BlockP&lt;T&gt; XBlock, T*&amp; var, T val);\n\n\ntemplate &lt;class T&gt; __global__ void addavg_varGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmean, T* Var);\ntemplate &lt;class T&gt; __global__ void divavg_varGPU(Param XParam, BlockP&lt;T&gt; XBlock, T ntdiv, T* Varmean);\ntemplate &lt;class T&gt; __global__ void addUandhU_GPU(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* u, T* v, T* U, T* hU);\ntemplate &lt;class T&gt; __global__ void max_varGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* Var);\ntemplate &lt;class T&gt; __global__ void max_Norm_GPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* Var1, T* Var2);\ntemplate &lt;class T&gt; __global__ void max_hU_GPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* Var1, T* Var2, T* Var3);\ntemplate &lt;class T&gt; __global__ void addwettime_GPU(Param XParam, BlockP&lt;T&gt; XBlock, T* wett, T* h, T thresold, T time);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/","title":"File MemManagement.cu","text":""},{"location":"BGFlood/MemManagement_8cu/#file-memmanagementcu","title":"File MemManagement.cu","text":"<p>FileList &gt; src &gt; MemManagement.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"MemManagement.h\"</code></li> </ul>"},{"location":"BGFlood/MemManagement_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ void AllocateCPU (int nx, int ny, T *&amp; zb)  __host__ void AllocateCPU (int nx, int ny, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v)  __host__ void AllocateCPU (int nx, int ny, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v, T *&amp; U, T *&amp; hU)  __host__ void AllocateCPU (int nx, int ny, GradientsP&lt; T &gt; &amp; Grad)  void AllocateCPU (int nblk, int blksize, EvolvingP&lt; T &gt; &amp; Ev)  void AllocateCPU (int nblk, int blksize, EvolvingP_M&lt; T &gt; &amp; Ev)  void AllocateCPU (int nblk, int blksize, Param XParam, Model&lt; T &gt; &amp; XModel)  template void AllocateCPU&lt; double &gt; (int nx, int ny, double *&amp; zs, double *&amp; h, double *&amp; u, double *&amp; v)  template void AllocateCPU&lt; double &gt; (int nx, int ny, double *&amp; zs, double *&amp; h, double *&amp; u, double *&amp; v, double *&amp; U, double *&amp; hU)  template void AllocateCPU&lt; double &gt; (int nx, int ny, GradientsP&lt; double &gt; &amp; Grad)  template void AllocateCPU&lt; double &gt; (int nblk, int blksize, Param XParam, Model&lt; double &gt; &amp; XModel)  template void AllocateCPU&lt; float &gt; (int nx, int ny, float *&amp; zs, float *&amp; h, float *&amp; u, float *&amp; v)  template void AllocateCPU&lt; float &gt; (int nx, int ny, float *&amp; zs, float *&amp; h, float *&amp; u, float *&amp; v, float *&amp; U, float *&amp; hU)  template void AllocateCPU&lt; float &gt; (int nx, int ny, GradientsP&lt; float &gt; &amp; Grad)  template void AllocateCPU&lt; float &gt; (int nblk, int blksize, Param XParam, Model&lt; float &gt; &amp; XModel)  template void AllocateCPU&lt; int &gt; (int nx, int ny, int *&amp; zs, int *&amp; h, int *&amp; u, int *&amp; v)  template void AllocateCPU&lt; int &gt; (int nx, int ny, int *&amp; zs, int *&amp; h, int *&amp; u, int *&amp; v, int *&amp; U, int *&amp; hU)  void AllocateGPU (int nx, int ny, T *&amp; z_g)  void AllocateGPU (int nx, int ny, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v)  void AllocateGPU (int nx, int ny, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v, T *&amp; U, T *&amp; hU)  void AllocateGPU (int nx, int ny, GradientsP&lt; T &gt; &amp; Grad)  void AllocateGPU (int nblk, int blksize, EvolvingP&lt; T &gt; &amp; Ev)  void AllocateGPU (int nblk, int blksize, EvolvingP_M&lt; T &gt; &amp; Ev)  void AllocateGPU (int nblk, int blksize, Param XParam, Model&lt; T &gt; &amp; XModel)  template void AllocateGPU&lt; double &gt; (int nx, int ny, double *&amp; zs, double *&amp; h, double *&amp; u, double *&amp; v)  template void AllocateGPU&lt; double &gt; (int nx, int ny, double *&amp; zs, double *&amp; h, double *&amp; u, double *&amp; v, double *&amp; U, double *&amp; hU)  template void AllocateGPU&lt; double &gt; (int nx, int ny, GradientsP&lt; double &gt; &amp; Grad)  template void AllocateGPU&lt; double &gt; (int nblk, int blksize, Param XParam, Model&lt; double &gt; &amp; XModel)  template void AllocateGPU&lt; float &gt; (int nx, int ny, float *&amp; zs, float *&amp; h, float *&amp; u, float *&amp; v)  template void AllocateGPU&lt; float &gt; (int nx, int ny, float *&amp; zs, float *&amp; h, float *&amp; u, float *&amp; v, float *&amp; U, float *&amp; hU)  template void AllocateGPU&lt; float &gt; (int nx, int ny, GradientsP&lt; float &gt; &amp; Grad)  template void AllocateGPU&lt; float &gt; (int nblk, int blksize, Param XParam, Model&lt; float &gt; &amp; XModel)  template void AllocateGPU&lt; int &gt; (int nx, int ny, int *&amp; zs, int *&amp; h, int *&amp; u, int *&amp; v)  template void AllocateGPU&lt; int &gt; (int nx, int ny, int *&amp; zs, int *&amp; h, int *&amp; u, int *&amp; v, int *&amp; U, int *&amp; hU)  void AllocateMappedMemCPU (int nx, int ny, int gpudevice, T *&amp; z)  template void AllocateMappedMemCPU&lt; double &gt; (int nx, int ny, int gpudevice, double *&amp; z)  template void AllocateMappedMemCPU&lt; float &gt; (int nx, int ny, int gpudevice, float *&amp; z)  template void AllocateMappedMemCPU&lt; int &gt; (int nx, int ny, int gpudevice, int *&amp; z)  void AllocateMappedMemGPU (int nx, int ny, int gpudevice, T *&amp; z_g, T * z)  template void AllocateMappedMemGPU&lt; double &gt; (int nx, int ny, int gpudevice, double *&amp; z_g, double * z)  template void AllocateMappedMemGPU&lt; float &gt; (int nx, int ny, int gpudevice, float *&amp; z_g, float * z)  template void AllocateMappedMemGPU&lt; int &gt; (int nx, int ny, int gpudevice, int *&amp; z_g, int * z)  __host__ void FillCPU (int nx, int ny, T fillval, T *&amp; zb)  template void FillCPU&lt; double &gt; (int nx, int ny, double fillval, double *&amp; zb)  template void FillCPU&lt; float &gt; (int nx, int ny, float fillval, float *&amp; zb)  template void FillCPU&lt; int &gt; (int nx, int ny, int fillval, int *&amp; zb)  void ReallocArray (int nblk, int blksize, T *&amp; zb)  void ReallocArray (int nblk, int blksize, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v)  void ReallocArray (int nblk, int blksize, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v, T *&amp; U, T *&amp; hU)  void ReallocArray (int nblk, int blksize, EvolvingP&lt; T &gt; &amp; Ev)  void ReallocArray (int nblk, int blksize, EvolvingP_M&lt; T &gt; &amp; Ev)  void ReallocArray (int nblk, int blksize, Param XParam, Model&lt; T &gt; &amp; XModel)  template void ReallocArray&lt; double &gt; (int nblk, int blksize, double *&amp; zs, double *&amp; h, double *&amp; u, double *&amp; v)  template void ReallocArray&lt; double &gt; (int nblk, int blksize, double *&amp; zs, double *&amp; h, double *&amp; u, double *&amp; v, double *&amp; U, double *&amp; hU)  template void ReallocArray&lt; double &gt; (int nblk, int blksize, EvolvingP&lt; double &gt; &amp; Ev)  template void ReallocArray&lt; double &gt; (int nblk, int blksize, EvolvingP_M&lt; double &gt; &amp; Ev)  template void ReallocArray&lt; double &gt; (int nblk, int blksize, Param XParam, Model&lt; double &gt; &amp; XModel)  template void ReallocArray&lt; float &gt; (int nblk, int blksize, float *&amp; zs, float *&amp; h, float *&amp; u, float *&amp; v)  template void ReallocArray&lt; float &gt; (int nblk, int blksize, float *&amp; zs, float *&amp; h, float *&amp; u, float *&amp; v, float *&amp; U, float *&amp; hU)  template void ReallocArray&lt; float &gt; (int nblk, int blksize, EvolvingP&lt; float &gt; &amp; Ev)  template void ReallocArray&lt; float &gt; (int nblk, int blksize, EvolvingP_M&lt; float &gt; &amp; Ev)  template void ReallocArray&lt; float &gt; (int nblk, int blksize, Param XParam, Model&lt; float &gt; &amp; XModel)  template void ReallocArray&lt; int &gt; (int nblk, int blksize, int *&amp; zs, int *&amp; h, int *&amp; u, int *&amp; v)  template void ReallocArray&lt; int &gt; (int nblk, int blksize, int *&amp; zs, int *&amp; h, int *&amp; u, int *&amp; v, int *&amp; U, int *&amp; hU)  __host__ int memloc (Param XParam, int i, int j, int ib)  __host__ __device__ int memloc (int halowidth, int blkmemwidth, int i, int j, int ib)"},{"location":"BGFlood/MemManagement_8cu/#macros","title":"Macros","text":"Type Name define ALIGN_UP (x, size) <code>( ((size\\_t)x+(size-1))&amp;(~(size-1)) )</code> define MEMORY_ALIGNMENT <code>4096</code>"},{"location":"BGFlood/MemManagement_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/MemManagement_8cu/#function-allocatecpu","title":"function AllocateCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AllocateCPU (\n    int nx,\n    int ny,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatecpu_1","title":"function AllocateCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AllocateCPU (\n    int nx,\n    int ny,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatecpu_2","title":"function AllocateCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AllocateCPU (\n    int nx,\n    int ny,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v,\n    T *&amp; U,\n    T *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatecpu_3","title":"function AllocateCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AllocateCPU (\n    int nx,\n    int ny,\n    GradientsP &lt; T &gt; &amp; Grad\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatecpu_4","title":"function AllocateCPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; T &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatecpu_5","title":"function AllocateCPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; T &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatecpu_6","title":"function AllocateCPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatecpu-double","title":"function AllocateCPU&lt; double &gt;","text":"<pre><code>template void AllocateCPU&lt; double &gt; (\n    int nx,\n    int ny,\n    double *&amp; zs,\n    double *&amp; h,\n    double *&amp; u,\n    double *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatecpu-double_1","title":"function AllocateCPU&lt; double &gt;","text":"<pre><code>template void AllocateCPU&lt; double &gt; (\n    int nx,\n    int ny,\n    double *&amp; zs,\n    double *&amp; h,\n    double *&amp; u,\n    double *&amp; v,\n    double *&amp; U,\n    double *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatecpu-double_2","title":"function AllocateCPU&lt; double &gt;","text":"<pre><code>template void AllocateCPU&lt; double &gt; (\n    int nx,\n    int ny,\n    GradientsP &lt; double &gt; &amp; Grad\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatecpu-double_3","title":"function AllocateCPU&lt; double &gt;","text":"<pre><code>template void AllocateCPU&lt; double &gt; (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatecpu-float","title":"function AllocateCPU&lt; float &gt;","text":"<pre><code>template void AllocateCPU&lt; float &gt; (\n    int nx,\n    int ny,\n    float *&amp; zs,\n    float *&amp; h,\n    float *&amp; u,\n    float *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatecpu-float_1","title":"function AllocateCPU&lt; float &gt;","text":"<pre><code>template void AllocateCPU&lt; float &gt; (\n    int nx,\n    int ny,\n    float *&amp; zs,\n    float *&amp; h,\n    float *&amp; u,\n    float *&amp; v,\n    float *&amp; U,\n    float *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatecpu-float_2","title":"function AllocateCPU&lt; float &gt;","text":"<pre><code>template void AllocateCPU&lt; float &gt; (\n    int nx,\n    int ny,\n    GradientsP &lt; float &gt; &amp; Grad\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatecpu-float_3","title":"function AllocateCPU&lt; float &gt;","text":"<pre><code>template void AllocateCPU&lt; float &gt; (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatecpu-int","title":"function AllocateCPU&lt; int &gt;","text":"<pre><code>template void AllocateCPU&lt; int &gt; (\n    int nx,\n    int ny,\n    int *&amp; zs,\n    int *&amp; h,\n    int *&amp; u,\n    int *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatecpu-int_1","title":"function AllocateCPU&lt; int &gt;","text":"<pre><code>template void AllocateCPU&lt; int &gt; (\n    int nx,\n    int ny,\n    int *&amp; zs,\n    int *&amp; h,\n    int *&amp; u,\n    int *&amp; v,\n    int *&amp; U,\n    int *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocategpu","title":"function AllocateGPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nx,\n    int ny,\n    T *&amp; z_g\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocategpu_1","title":"function AllocateGPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nx,\n    int ny,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocategpu_2","title":"function AllocateGPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nx,\n    int ny,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v,\n    T *&amp; U,\n    T *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocategpu_3","title":"function AllocateGPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nx,\n    int ny,\n    GradientsP &lt; T &gt; &amp; Grad\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocategpu_4","title":"function AllocateGPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; T &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocategpu_5","title":"function AllocateGPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; T &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocategpu_6","title":"function AllocateGPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocategpu-double","title":"function AllocateGPU&lt; double &gt;","text":"<pre><code>template void AllocateGPU&lt; double &gt; (\n    int nx,\n    int ny,\n    double *&amp; zs,\n    double *&amp; h,\n    double *&amp; u,\n    double *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocategpu-double_1","title":"function AllocateGPU&lt; double &gt;","text":"<pre><code>template void AllocateGPU&lt; double &gt; (\n    int nx,\n    int ny,\n    double *&amp; zs,\n    double *&amp; h,\n    double *&amp; u,\n    double *&amp; v,\n    double *&amp; U,\n    double *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocategpu-double_2","title":"function AllocateGPU&lt; double &gt;","text":"<pre><code>template void AllocateGPU&lt; double &gt; (\n    int nx,\n    int ny,\n    GradientsP &lt; double &gt; &amp; Grad\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocategpu-double_3","title":"function AllocateGPU&lt; double &gt;","text":"<pre><code>template void AllocateGPU&lt; double &gt; (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocategpu-float","title":"function AllocateGPU&lt; float &gt;","text":"<pre><code>template void AllocateGPU&lt; float &gt; (\n    int nx,\n    int ny,\n    float *&amp; zs,\n    float *&amp; h,\n    float *&amp; u,\n    float *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocategpu-float_1","title":"function AllocateGPU&lt; float &gt;","text":"<pre><code>template void AllocateGPU&lt; float &gt; (\n    int nx,\n    int ny,\n    float *&amp; zs,\n    float *&amp; h,\n    float *&amp; u,\n    float *&amp; v,\n    float *&amp; U,\n    float *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocategpu-float_2","title":"function AllocateGPU&lt; float &gt;","text":"<pre><code>template void AllocateGPU&lt; float &gt; (\n    int nx,\n    int ny,\n    GradientsP &lt; float &gt; &amp; Grad\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocategpu-float_3","title":"function AllocateGPU&lt; float &gt;","text":"<pre><code>template void AllocateGPU&lt; float &gt; (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocategpu-int","title":"function AllocateGPU&lt; int &gt;","text":"<pre><code>template void AllocateGPU&lt; int &gt; (\n    int nx,\n    int ny,\n    int *&amp; zs,\n    int *&amp; h,\n    int *&amp; u,\n    int *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocategpu-int_1","title":"function AllocateGPU&lt; int &gt;","text":"<pre><code>template void AllocateGPU&lt; int &gt; (\n    int nx,\n    int ny,\n    int *&amp; zs,\n    int *&amp; h,\n    int *&amp; u,\n    int *&amp; v,\n    int *&amp; U,\n    int *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatemappedmemcpu","title":"function AllocateMappedMemCPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateMappedMemCPU (\n    int nx,\n    int ny,\n    int gpudevice,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatemappedmemcpu-double","title":"function AllocateMappedMemCPU&lt; double &gt;","text":"<pre><code>template void AllocateMappedMemCPU&lt; double &gt; (\n    int nx,\n    int ny,\n    int gpudevice,\n    double *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatemappedmemcpu-float","title":"function AllocateMappedMemCPU&lt; float &gt;","text":"<pre><code>template void AllocateMappedMemCPU&lt; float &gt; (\n    int nx,\n    int ny,\n    int gpudevice,\n    float *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatemappedmemcpu-int","title":"function AllocateMappedMemCPU&lt; int &gt;","text":"<pre><code>template void AllocateMappedMemCPU&lt; int &gt; (\n    int nx,\n    int ny,\n    int gpudevice,\n    int *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatemappedmemgpu","title":"function AllocateMappedMemGPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateMappedMemGPU (\n    int nx,\n    int ny,\n    int gpudevice,\n    T *&amp; z_g,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatemappedmemgpu-double","title":"function AllocateMappedMemGPU&lt; double &gt;","text":"<pre><code>template void AllocateMappedMemGPU&lt; double &gt; (\n    int nx,\n    int ny,\n    int gpudevice,\n    double *&amp; z_g,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatemappedmemgpu-float","title":"function AllocateMappedMemGPU&lt; float &gt;","text":"<pre><code>template void AllocateMappedMemGPU&lt; float &gt; (\n    int nx,\n    int ny,\n    int gpudevice,\n    float *&amp; z_g,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-allocatemappedmemgpu-int","title":"function AllocateMappedMemGPU&lt; int &gt;","text":"<pre><code>template void AllocateMappedMemGPU&lt; int &gt; (\n    int nx,\n    int ny,\n    int gpudevice,\n    int *&amp; z_g,\n    int * z\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-fillcpu","title":"function FillCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void FillCPU (\n    int nx,\n    int ny,\n    T fillval,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-fillcpu-double","title":"function FillCPU&lt; double &gt;","text":"<pre><code>template void FillCPU&lt; double &gt; (\n    int nx,\n    int ny,\n    double fillval,\n    double *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-fillcpu-float","title":"function FillCPU&lt; float &gt;","text":"<pre><code>template void FillCPU&lt; float &gt; (\n    int nx,\n    int ny,\n    float fillval,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-fillcpu-int","title":"function FillCPU&lt; int &gt;","text":"<pre><code>template void FillCPU&lt; int &gt; (\n    int nx,\n    int ny,\n    int fillval,\n    int *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray","title":"function ReallocArray","text":"<pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray_1","title":"function ReallocArray","text":"<pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray_2","title":"function ReallocArray","text":"<pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v,\n    T *&amp; U,\n    T *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray_3","title":"function ReallocArray","text":"<pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; T &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray_4","title":"function ReallocArray","text":"<pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; T &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray_5","title":"function ReallocArray","text":"<pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray-double","title":"function ReallocArray&lt; double &gt;","text":"<pre><code>template void ReallocArray&lt; double &gt; (\n    int nblk,\n    int blksize,\n    double *&amp; zs,\n    double *&amp; h,\n    double *&amp; u,\n    double *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray-double_1","title":"function ReallocArray&lt; double &gt;","text":"<pre><code>template void ReallocArray&lt; double &gt; (\n    int nblk,\n    int blksize,\n    double *&amp; zs,\n    double *&amp; h,\n    double *&amp; u,\n    double *&amp; v,\n    double *&amp; U,\n    double *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray-double_2","title":"function ReallocArray&lt; double &gt;","text":"<pre><code>template void ReallocArray&lt; double &gt; (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; double &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray-double_3","title":"function ReallocArray&lt; double &gt;","text":"<pre><code>template void ReallocArray&lt; double &gt; (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; double &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray-double_4","title":"function ReallocArray&lt; double &gt;","text":"<pre><code>template void ReallocArray&lt; double &gt; (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray-float","title":"function ReallocArray&lt; float &gt;","text":"<pre><code>template void ReallocArray&lt; float &gt; (\n    int nblk,\n    int blksize,\n    float *&amp; zs,\n    float *&amp; h,\n    float *&amp; u,\n    float *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray-float_1","title":"function ReallocArray&lt; float &gt;","text":"<pre><code>template void ReallocArray&lt; float &gt; (\n    int nblk,\n    int blksize,\n    float *&amp; zs,\n    float *&amp; h,\n    float *&amp; u,\n    float *&amp; v,\n    float *&amp; U,\n    float *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray-float_2","title":"function ReallocArray&lt; float &gt;","text":"<pre><code>template void ReallocArray&lt; float &gt; (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; float &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray-float_3","title":"function ReallocArray&lt; float &gt;","text":"<pre><code>template void ReallocArray&lt; float &gt; (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; float &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray-float_4","title":"function ReallocArray&lt; float &gt;","text":"<pre><code>template void ReallocArray&lt; float &gt; (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray-int","title":"function ReallocArray&lt; int &gt;","text":"<pre><code>template void ReallocArray&lt; int &gt; (\n    int nblk,\n    int blksize,\n    int *&amp; zs,\n    int *&amp; h,\n    int *&amp; u,\n    int *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-reallocarray-int_1","title":"function ReallocArray&lt; int &gt;","text":"<pre><code>template void ReallocArray&lt; int &gt; (\n    int nblk,\n    int blksize,\n    int *&amp; zs,\n    int *&amp; h,\n    int *&amp; u,\n    int *&amp; v,\n    int *&amp; U,\n    int *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-memloc","title":"function memloc","text":"<pre><code>__host__ int memloc (\n    Param XParam,\n    int i,\n    int j,\n    int ib\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#function-memloc_1","title":"function memloc","text":"<pre><code>__host__ __device__ int memloc (\n    int halowidth,\n    int blkmemwidth,\n    int i,\n    int j,\n    int ib\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"BGFlood/MemManagement_8cu/#define-align_up","title":"define ALIGN_UP","text":"<pre><code>#define ALIGN_UP (\n    x,\n    size\n) `( ((size_t)x+(size-1))&amp;(~(size-1)) )`\n</code></pre>"},{"location":"BGFlood/MemManagement_8cu/#define-memory_alignment","title":"define MEMORY_ALIGNMENT","text":"<pre><code>#define MEMORY_ALIGNMENT `4096`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/MemManagement.cu</code></p>"},{"location":"BGFlood/MemManagement_8cu_source/","title":"File MemManagement.cu","text":""},{"location":"BGFlood/MemManagement_8cu_source/#file-memmanagementcu","title":"File MemManagement.cu","text":"<p>File List &gt; src &gt; MemManagement.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"MemManagement.h\"\n\n\n#define MEMORY_ALIGNMENT  4096\n#define ALIGN_UP(x,size) ( ((size_t)x+(size-1))&amp;(~(size-1)) )\n\n__host__ int memloc(Param XParam, int i, int j, int ib)\n{\n    return (i+XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n}\n\n\n__host__ __device__ int memloc(int halowidth, int blkmemwidth, int i, int j, int ib)\n{\n    return (i + halowidth) + (j + halowidth) * blkmemwidth + ib * (blkmemwidth* blkmemwidth);\n}\n\ntemplate &lt;class T&gt; __host__ void AllocateCPU(int nx, int ny, T *&amp;zb)\n{\n    zb = (T *)malloc(nx*ny * sizeof(T));\n    if (!zb)\n    {\n        fprintf(stderr, \"Memory allocation failure\\n\");\n\n        exit(EXIT_FAILURE);\n    }\n}\n\ntemplate &lt;class T&gt; __host__ void FillCPU(int nx, int ny,T fillval, T*&amp; zb)\n{\n    for (int ix = 0; ix &lt; nx; ix++)\n    {\n        for (int iy = 0; iy &lt; ny; iy++)\n        {\n            zb[iy * nx + ix] = fillval;\n        }\n    }\n}\ntemplate void FillCPU&lt;double&gt;(int nx, int ny, double fillval, double*&amp; zb);\ntemplate void FillCPU&lt;float&gt;(int nx, int ny, float fillval, float*&amp; zb);\ntemplate void FillCPU&lt;int&gt;(int nx, int ny, int fillval, int*&amp; zb);\n\ntemplate &lt;class T&gt; __host__ void AllocateCPU(int nx, int ny, T *&amp;zs, T *&amp;h, T *&amp;u, T *&amp;v)\n{\n\n    AllocateCPU(nx, ny, zs);\n    AllocateCPU(nx, ny, h);\n    AllocateCPU(nx, ny, u);\n    AllocateCPU(nx, ny, v);\n\n}\n\ntemplate void AllocateCPU&lt;double&gt;(int nx, int ny, double *&amp;zs, double *&amp;h, double *&amp;u, double *&amp;v);\ntemplate void AllocateCPU&lt;float&gt;(int nx, int ny, float *&amp;zs, float *&amp;h, float *&amp;u, float *&amp;v);\ntemplate void AllocateCPU&lt;int&gt;(int nx, int ny, int *&amp;zs, int *&amp;h, int *&amp;u, int *&amp;v);\n\ntemplate &lt;class T&gt; __host__ void AllocateCPU(int nx, int ny, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v, T*&amp; U, T*&amp; hU)\n{\n\n    AllocateCPU(nx, ny, zs);\n    AllocateCPU(nx, ny, h);\n    AllocateCPU(nx, ny, u);\n    AllocateCPU(nx, ny, v);\n    AllocateCPU(nx, ny, U);\n    AllocateCPU(nx, ny, hU);\n}\n\ntemplate void AllocateCPU&lt;double&gt;(int nx, int ny, double*&amp; zs, double*&amp; h, double*&amp; u, double*&amp; v, double*&amp; U, double*&amp; hU);\ntemplate void AllocateCPU&lt;float&gt;(int nx, int ny, float*&amp; zs, float*&amp; h, float*&amp; u, float*&amp; v, float*&amp; U, float*&amp; hU);\ntemplate void AllocateCPU&lt;int&gt;(int nx, int ny, int*&amp; zs, int*&amp; h, int*&amp; u, int*&amp; v, int*&amp; U, int*&amp; hU);\n\ntemplate &lt;class T&gt; __host__\nvoid AllocateCPU(int nx, int ny, GradientsP&lt;T&gt;&amp; Grad)\n{\n    AllocateCPU(nx, ny, Grad.dhdx, Grad.dzsdx, Grad.dudx, Grad.dvdx);\n    AllocateCPU(nx, ny, Grad.dhdy, Grad.dzsdy, Grad.dudy, Grad.dvdy);\n\n    AllocateCPU(nx, ny, Grad.dzbdx);\n    AllocateCPU(nx, ny, Grad.dzbdy);\n}\ntemplate void AllocateCPU&lt;float&gt;(int nx, int ny, GradientsP&lt;float&gt;&amp; Grad);\ntemplate void AllocateCPU&lt;double&gt;(int nx, int ny, GradientsP&lt;double&gt;&amp; Grad);\n\ntemplate &lt;class T&gt; void AllocateCPU(int nblk, int blksize, EvolvingP&lt;T&gt; &amp; Ev)\n{\n    AllocateCPU(nblk, blksize, Ev.h, Ev.zs, Ev.u, Ev.v);\n}\n\ntemplate &lt;class T&gt; void AllocateCPU(int nblk, int blksize, EvolvingP_M&lt;T&gt;&amp; Ev)\n{\n    AllocateCPU(nblk, blksize, Ev.h, Ev.zs, Ev.u, Ev.v, Ev.U, Ev.hU);\n\n}\n\ntemplate &lt;class T&gt;\nvoid AllocateCPU(int nblk, int blksize, Param XParam, Model&lt;T&gt;&amp; XModel)\n{\n    // Allocate blocks data \n    AllocateCPU(nblk, blksize, XModel.evolv);\n    AllocateCPU(nblk, blksize, XModel.evolv_o);\n\n    AllocateCPU(nblk, blksize, XModel.grad.dhdy, XModel.grad.dzsdy, XModel.grad.dudy, XModel.grad.dvdy);\n    AllocateCPU(nblk, blksize, XModel.grad.dhdx, XModel.grad.dzsdx, XModel.grad.dudx, XModel.grad.dvdx);\n\n    AllocateCPU(nblk, blksize, XModel.grad.dzbdx);\n    AllocateCPU(nblk, blksize, XModel.grad.dzbdy);\n    if (XParam.engine==5)\n    {\n        AllocateCPU(nblk, blksize, XModel.fluxml.Fux, XModel.fluxml.Fvy, XModel.fluxml.Fuy, XModel.fluxml.Fvx);\n        AllocateCPU(nblk, blksize, XModel.fluxml.hfu, XModel.fluxml.hfv, XModel.fluxml.hu, XModel.fluxml.hv);\n        AllocateCPU(nblk, blksize, XModel.fluxml.hau);\n        AllocateCPU(nblk, blksize, XModel.fluxml.hav);\n    }\n    else\n    {\n        AllocateCPU(nblk, blksize, XModel.flux.Fhu, XModel.flux.Fhv, XModel.flux.Fqux, XModel.flux.Fquy);\n\n        AllocateCPU(nblk, blksize, XModel.flux.Fqvx, XModel.flux.Fqvy, XModel.flux.Su, XModel.flux.Sv);\n    }\n    AllocateCPU(nblk, blksize, XModel.zb, XModel.adv.dh, XModel.adv.dhu, XModel.adv.dhv);\n\n    AllocateCPU(nblk, blksize, XModel.cf, XModel.time.arrmax, XModel.time.arrmin, XModel.time.dtmax);\n\n\n    //Allocate block info\n    AllocateCPU(nblk, 1, XModel.blocks.active);\n    AllocateCPU(nblk, blksize, XModel.blocks.activeCell);\n    AllocateCPU(nblk, 1, XModel.blocks.level);\n\n    AllocateCPU(nblk, 1, XModel.blocks.BotLeft, XModel.blocks.BotRight, XModel.blocks.LeftBot, XModel.blocks.LeftTop);\n    AllocateCPU(nblk, 1, XModel.blocks.RightBot, XModel.blocks.RightTop, XModel.blocks.TopLeft, XModel.blocks.TopRight);\n\n    AllocateCPU(nblk, 1, XModel.blocks.xo);\n    AllocateCPU(nblk, 1, XModel.blocks.yo);\n\n    // do allocate 1 mask block (block with at least 1 empty neighbourhood) \n    // this will be reallocated eventually\n    AllocateCPU(1, 1, XModel.blocks.mask.side);\n    AllocateCPU(1, 1, XModel.blocks.mask.blks);\n\n    // If no adatptation ignore this!\n    if (XParam.maxlevel != XParam.minlevel)\n    {\n        AllocateCPU(nblk, 1, XModel.adapt.availblk, XModel.adapt.csumblk, XModel.adapt.invactive, XModel.adapt.newlevel);\n        AllocateCPU(nblk, 1, XModel.adapt.coarsen);\n        AllocateCPU(nblk, 1, XModel.adapt.refine);\n    }\n\n    // do allocate 1 outzone block, this will be reallocated eventually\n    //AllocateCPU(1, 1, XModel.blocks.outZone[0].blk);\n    //if (XParam.outzone.size() &gt; 0)\n    //{\n    //  //XModel.blocks.outZone.resize(XParam.outzone.size())\n    //  for (int o = 1; o &lt; XParam.outzone.size(); o++)\n    //  {\n    //      AllocateCPU(1, 1, XModel.blocks.outZone[o].blk);\n    //  }\n    //}\n\n\n\n    if (XParam.TSnodesout.size() &gt; 0)\n    {\n        // Timeseries output temporary storage\n        int storage = XParam.maxTSstorage;\n        AllocateCPU(storage, 1, XModel.TSstore);\n    }\n\n    if (XParam.atmpforcing)\n    {\n        AllocateCPU(nblk, blksize, XModel.Patm);\n        AllocateCPU(nblk, blksize, XModel.datmpdx);\n        AllocateCPU(nblk, blksize, XModel.datmpdy);\n    }\n\n    if (XParam.infiltration)\n    {\n        AllocateCPU(nblk, blksize, XModel.il);\n        AllocateCPU(nblk, blksize, XModel.cl);\n        AllocateCPU(nblk, blksize, XModel.hgw);\n    }\n\n    if (XParam.outmax)\n    {\n        AllocateCPU(nblk, blksize, XModel.evmax);\n    }\n    if (XParam.outmean)\n    {\n        AllocateCPU(nblk, blksize, XModel.evmean);\n    }\n    if (XParam.outtwet)\n    {\n        AllocateCPU(nblk, blksize, XModel.wettime);\n    }\n\n    /*if (XParam.outvort)\n    {\n        AllocateCPU(nblk, blksize, XModel.vort);\n    }\n    if (XParam.outU)\n    {\n        AllocateCPU(nblk, blksize, XModel.U);\n    }*/\n\n    if (XParam.TSnodesout.size() &gt; 0)\n    {\n        // Timeseries output temporary storage\n        int storage = XParam.maxTSstorage;\n        AllocateCPU(storage, 1, XModel.TSstore);\n    }\n\n    if (XParam.nrivers &gt; 0)\n    {\n        //this will be eventually reallocated later\n        AllocateCPU(1, 1, XModel.bndblk.river);\n        XModel.bndblk.nblkriver = 1;\n\n        AllocateCPU(1, 1, XModel.bndblk.Riverinfo.Xbidir);\n        AllocateCPU(1, 1, XModel.bndblk.Riverinfo.Xridib);\n    }\n    // preallocate 1 block along all bnds\n    //this will be eventually reallocated later\n    //AllocateCPU(1, 1, XModel.bndblk.left);\n    //AllocateCPU(1, 1, XModel.bndblk.right);\n    //AllocateCPU(1, 1, XModel.bndblk.top);\n    //AllocateCPU(1, 1, XModel.bndblk.bot);\n\n}\n\ntemplate void AllocateCPU&lt;float&gt;(int nblk, int blksize, Param XParam, Model&lt;float&gt;&amp; XModel);\ntemplate void AllocateCPU&lt;double&gt;(int nblk, int blksize, Param XParam, Model&lt;double&gt;&amp; XModel);\n\n\n\n\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, T* &amp; zb)\n{\n    //\n    if (nblk &gt; 0)\n    {\n        zb = (T*)realloc(zb, nblk * blksize * sizeof(T));\n        if (zb == NULL)\n        {\n            fprintf(stderr, \"Memory reallocation failure\\n\");\n\n            exit(EXIT_FAILURE);\n        }\n    }\n    //return nblkmem\n}\n\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v)\n{\n    //\n\n    ReallocArray(nblk, blksize, zs);\n    ReallocArray(nblk, blksize, h);\n    ReallocArray(nblk, blksize, u);\n    ReallocArray(nblk, blksize, v);\n    //return nblkmem\n}\ntemplate void ReallocArray&lt;int&gt;(int nblk, int blksize, int*&amp; zs, int*&amp; h, int*&amp; u, int*&amp; v);\ntemplate void ReallocArray&lt;float&gt;(int nblk, int blksize, float*&amp; zs, float*&amp; h, float*&amp; u, float*&amp; v);\ntemplate void ReallocArray&lt;double&gt;(int nblk, int blksize, double*&amp; zs, double*&amp; h, double*&amp; u, double*&amp; v);\n\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v, T*&amp; U, T*&amp; hU)\n{\n    //\n\n    ReallocArray(nblk, blksize, zs);\n    ReallocArray(nblk, blksize, h);\n    ReallocArray(nblk, blksize, u);\n    ReallocArray(nblk, blksize, v);\n    ReallocArray(nblk, blksize, U);\n    ReallocArray(nblk, blksize, hU);\n    //return nblkmem\n}\n\ntemplate void ReallocArray&lt;int&gt;(int nblk, int blksize, int* &amp; zs, int*&amp; h, int*&amp; u, int*&amp; v, int*&amp; U, int*&amp; hU);\ntemplate void ReallocArray&lt;float&gt;(int nblk, int blksize, float* &amp; zs, float*&amp; h, float*&amp; u, float*&amp; v, float*&amp; U, float*&amp; hU);\ntemplate void ReallocArray&lt;double&gt;(int nblk, int blksize, double* &amp; zs, double*&amp; h, double*&amp; u, double*&amp; v, double*&amp; U, double*&amp; hU);\n\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, EvolvingP&lt;T&gt;&amp; Ev)\n{\n    ReallocArray(nblk, blksize, Ev.zs, Ev.h, Ev.u, Ev.v);\n}\ntemplate void ReallocArray&lt;float&gt;(int nblk, int blksize, EvolvingP&lt;float&gt;&amp; Ev);\ntemplate void ReallocArray&lt;double&gt;(int nblk, int blksize, EvolvingP&lt;double&gt;&amp; Ev);\n\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, EvolvingP_M&lt;T&gt;&amp; Ev)\n{\n    ReallocArray(nblk, blksize, Ev.zs, Ev.h, Ev.u, Ev.v, Ev.U, Ev.hU);\n}\ntemplate void ReallocArray&lt;float&gt;(int nblk, int blksize, EvolvingP_M&lt;float&gt;&amp; Ev);\ntemplate void ReallocArray&lt;double&gt;(int nblk, int blksize, EvolvingP_M&lt;double&gt;&amp; Ev);\n\ntemplate &lt;class T&gt;\nvoid ReallocArray(int nblk, int blksize, Param XParam, Model&lt;T&gt;&amp; XModel)\n{\n    // Allocate blocks data \n    ReallocArray(nblk, blksize, XModel.evolv);\n    ReallocArray(nblk, blksize, XModel.evolv_o);\n\n    ReallocArray(nblk, blksize, XModel.grad.dhdy, XModel.grad.dzsdy, XModel.grad.dudy, XModel.grad.dvdy);\n    ReallocArray(nblk, blksize, XModel.grad.dhdx, XModel.grad.dzsdx, XModel.grad.dudx, XModel.grad.dvdx);\n\n    ReallocArray(nblk, blksize, XModel.grad.dzbdx);\n    ReallocArray(nblk, blksize, XModel.grad.dzbdy);\n    if (XParam.engine == 5)\n    {\n        ReallocArray(nblk, blksize, XModel.fluxml.Fux, XModel.fluxml.Fvy, XModel.fluxml.Fuy, XModel.fluxml.Fvx);\n        ReallocArray(nblk, blksize, XModel.fluxml.hfu, XModel.fluxml.hfv, XModel.fluxml.hu, XModel.fluxml.hv);\n        ReallocArray(nblk, blksize, XModel.fluxml.hau);\n        ReallocArray(nblk, blksize, XModel.fluxml.hav);\n    }\n    else\n    {\n        ReallocArray(nblk, blksize, XModel.flux.Fhu, XModel.flux.Fhv, XModel.flux.Fqux, XModel.flux.Fquy);\n\n        ReallocArray(nblk, blksize, XModel.flux.Fqvx, XModel.flux.Fqvy, XModel.flux.Su, XModel.flux.Sv);\n    }\n\n    ReallocArray(nblk, blksize, XModel.zb, XModel.adv.dh, XModel.adv.dhu, XModel.adv.dhv);\n\n    ReallocArray(nblk, blksize, XModel.cf, XModel.time.arrmax, XModel.time.arrmin, XModel.time.dtmax);\n\n\n    //Allocate block info\n    ReallocArray(nblk, 1, XModel.blocks.active);\n    ReallocArray(nblk, blksize, XModel.blocks.activeCell);\n    ReallocArray(nblk, 1, XModel.blocks.level);\n\n    ReallocArray(nblk, 1, XModel.blocks.BotLeft, XModel.blocks.BotRight, XModel.blocks.LeftBot, XModel.blocks.LeftTop);\n    ReallocArray(nblk, 1, XModel.blocks.RightBot, XModel.blocks.RightTop, XModel.blocks.TopLeft, XModel.blocks.TopRight);\n\n    ReallocArray(nblk, 1, XModel.blocks.xo);\n    ReallocArray(nblk, 1, XModel.blocks.yo);\n\n    // If no adatptation ignore this!\n    if (XParam.maxlevel != XParam.minlevel)\n    {\n        ReallocArray(nblk, 1, XModel.adapt.availblk, XModel.adapt.csumblk, XModel.adapt.invactive, XModel.adapt.newlevel);\n        ReallocArray(nblk, 1, XModel.adapt.coarsen);\n        ReallocArray(nblk, 1, XModel.adapt.refine);\n    }\n\n\n    if (XParam.atmpforcing)\n    {\n        ReallocArray(nblk, blksize, XModel.Patm);\n        ReallocArray(nblk, blksize, XModel.datmpdx);\n        ReallocArray(nblk, blksize, XModel.datmpdy);\n    }\n\n    if (XParam.infiltration)\n    {\n        ReallocArray(nblk, blksize, XModel.il);\n        ReallocArray(nblk, blksize, XModel.cl);\n        ReallocArray(nblk, blksize, XModel.hgw);\n\n    }\n\n    if (XParam.outmax)\n    {\n        ReallocArray(nblk, blksize, XModel.evmax);\n    }\n    if (XParam.outmean)\n    {\n        ReallocArray(nblk, blksize, XModel.evmean);\n    }\n    if (XParam.outtwet)\n    {\n        ReallocArray(nblk, blksize, XModel.wettime);\n    }\n    //ReallocArray(nx, ny, XModel.);\n\n\n\n}\n\ntemplate void ReallocArray&lt;float&gt;(int nblk, int blksize, Param XParam, Model&lt;float&gt;&amp; XModel);\ntemplate void ReallocArray&lt;double&gt;(int nblk, int blksize, Param XParam, Model&lt;double&gt;&amp; XModel);\n\n\n\n\ntemplate &lt;class T&gt; void AllocateMappedMemCPU(int nx, int ny,int gpudevice, T*&amp; z)\n{\n\n    bool bPinGenericMemory;\n    cudaDeviceProp deviceProp;\n#if defined(__APPLE__) || defined(MACOSX)\n    bPinGenericMemory = false;  // Generic Pinning of System Paged memory is not currently supported on Mac OSX\n#else\n    bPinGenericMemory = true;\n#endif\n\n    // Here there should be a limit for cudar version less than 4.000\n\n\n    if (bPinGenericMemory)\n    {\n        //printf(\"&gt; Using Generic System Paged Memory (malloc)\\n\");\n    }\n    else\n    {\n        //printf(\"&gt; Using CUDA Host Allocated (cudaHostAlloc)\\n\");\n    }\n    if (gpudevice &gt;= 0)\n    {\n        cudaGetDeviceProperties(&amp;deviceProp, gpudevice);\n\n        if (!deviceProp.canMapHostMemory)\n        {\n            fprintf(stderr, \"Device %d does not support mapping CPU host memory!\\n\", gpudevice);\n            bPinGenericMemory = false;\n        }\n    }\n    size_t bytes = nx * ny * sizeof(T);\n    if (bPinGenericMemory)\n    {\n\n\n\n        T* a_UA = (T*)malloc(bytes + MEMORY_ALIGNMENT);\n\n\n        // We need to ensure memory is aligned to 4K (so we will need to padd memory accordingly)\n        z = (T*)ALIGN_UP(a_UA, MEMORY_ALIGNMENT);\n\n        if (gpudevice &gt;= 0)\n        {\n            CUDA_CHECK(cudaHostRegister(z, bytes, cudaHostRegisterMapped));\n        }\n\n    }\n    else\n    {\n\n        //flags = cudaHostAllocMapped;\n        CUDA_CHECK(cudaHostAlloc((void**)&amp;z, bytes, cudaHostAllocMapped));\n\n\n    }\n\n\n}\ntemplate void AllocateMappedMemCPU&lt;int&gt;(int nx, int ny, int gpudevice, int*&amp; z);\ntemplate void AllocateMappedMemCPU&lt;float&gt;(int nx, int ny, int gpudevice, float*&amp; z);\ntemplate void AllocateMappedMemCPU&lt;double&gt;(int nx, int ny, int gpudevice, double*&amp; z);\n\ntemplate &lt;class T&gt; void AllocateMappedMemGPU(int nx, int ny, int gpudevice, T*&amp; z_g, T* z)\n{\n    CUDA_CHECK(cudaHostGetDevicePointer((void**)&amp;z_g, (void*)z, 0));\n}\ntemplate void AllocateMappedMemGPU&lt;int&gt;(int nx, int ny, int gpudevice, int*&amp; z_g, int* z);\ntemplate void AllocateMappedMemGPU&lt;float&gt;(int nx, int ny, int gpudevice,float*&amp; z_g, float* z);\ntemplate void AllocateMappedMemGPU&lt;double&gt;(int nx, int ny, int gpudevice, double*&amp; z_g, double* z);\n\n\ntemplate &lt;class T&gt; void AllocateGPU(int nx, int ny, T*&amp; z_g)\n{\n    CUDA_CHECK(cudaMalloc((void**)&amp; z_g, nx * ny * sizeof(T)));\n}\n\ntemplate &lt;class T&gt; void AllocateGPU(int nx, int ny, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v)\n{\n\n    AllocateGPU(nx, ny, zs);\n    AllocateGPU(nx, ny, h);\n    AllocateGPU(nx, ny, u);\n    AllocateGPU(nx, ny, v);\n\n}\ntemplate void AllocateGPU&lt;double&gt;(int nx, int ny, double*&amp; zs, double*&amp; h, double*&amp; u, double*&amp; v);\ntemplate void AllocateGPU&lt;float&gt;(int nx, int ny, float*&amp; zs, float*&amp; h, float*&amp; u, float*&amp; v);\ntemplate void AllocateGPU&lt;int&gt;(int nx, int ny, int*&amp; zs, int*&amp; h, int*&amp; u, int*&amp; v);\n\ntemplate &lt;class T&gt; void AllocateGPU(int nx, int ny, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v, T*&amp; U, T*&amp; hU)\n{\n\n    AllocateGPU(nx, ny, zs);\n    AllocateGPU(nx, ny, h);\n    AllocateGPU(nx, ny, u);\n    AllocateGPU(nx, ny, v);\n    AllocateGPU(nx, ny, U);\n    AllocateGPU(nx, ny, hU);\n\n}\ntemplate void AllocateGPU&lt;double&gt;(int nx, int ny, double*&amp; zs, double*&amp; h, double*&amp; u, double*&amp; v, double*&amp; U, double*&amp; hU);\ntemplate void AllocateGPU&lt;float&gt;(int nx, int ny, float*&amp; zs, float*&amp; h, float*&amp; u, float*&amp; v, float*&amp; U, float*&amp; hU);\ntemplate void AllocateGPU&lt;int&gt;(int nx, int ny, int*&amp; zs, int*&amp; h, int*&amp; u, int*&amp; v, int*&amp; U, int*&amp; hU);\n\ntemplate &lt;class T&gt; \nvoid AllocateGPU(int nx, int ny, GradientsP&lt;T&gt;&amp; Grad)\n{\n    AllocateGPU(nx, ny, Grad.dhdx, Grad.dzsdx, Grad.dudx, Grad.dvdx);\n    AllocateGPU(nx, ny, Grad.dhdy, Grad.dzsdy, Grad.dudy, Grad.dvdy);\n    AllocateGPU(nx, ny, Grad.dzbdy);\n    AllocateGPU(nx, ny, Grad.dzbdx);\n}\ntemplate void AllocateGPU&lt;float&gt;(int nx, int ny, GradientsP&lt;float&gt;&amp; Grad);\ntemplate void AllocateGPU&lt;double&gt;(int nx, int ny, GradientsP&lt;double&gt;&amp; Grad);\n\ntemplate &lt;class T&gt; void AllocateGPU(int nblk, int blksize, EvolvingP&lt;T&gt;&amp; Ev)\n{\n    AllocateGPU(nblk, blksize, Ev.h, Ev.zs, Ev.u, Ev.v);\n}\n\ntemplate &lt;class T&gt; void AllocateGPU(int nblk, int blksize, EvolvingP_M&lt;T&gt;&amp; Ev)\n{\n    AllocateGPU(nblk, blksize, Ev.h, Ev.zs, Ev.u, Ev.v, Ev.U, Ev.hU);\n}\n\ntemplate &lt;class T&gt;\nvoid AllocateGPU(int nblk, int blksize, Param XParam, Model&lt;T&gt;&amp; XModel)\n{\n    // Allocate blocks data \n    AllocateGPU(nblk, blksize, XModel.evolv);\n    AllocateGPU(nblk, blksize, XModel.evolv_o);\n\n    AllocateGPU(nblk, blksize, XModel.grad);\n    if (XParam.engine == 5)\n    {\n        AllocateGPU(nblk, blksize, XModel.fluxml.Fux, XModel.fluxml.Fvy, XModel.fluxml.hau, XModel.fluxml.hav);\n        AllocateGPU(nblk, blksize, XModel.fluxml.hfu, XModel.fluxml.hfv, XModel.fluxml.hu, XModel.fluxml.hv);\n        AllocateGPU(nblk, blksize, XModel.fluxml.Fuy);\n        AllocateGPU(nblk, blksize, XModel.fluxml.Fvx);\n    }\n    else\n    {\n        AllocateGPU(nblk, blksize, XModel.flux.Fhu, XModel.flux.Fhv, XModel.flux.Fqux, XModel.flux.Fquy);\n\n        AllocateGPU(nblk, blksize, XModel.flux.Fqvx, XModel.flux.Fqvy, XModel.flux.Su, XModel.flux.Sv);\n    }\n    AllocateGPU(nblk, blksize, XModel.zb, XModel.adv.dh, XModel.adv.dhu, XModel.adv.dhv);\n\n    AllocateGPU(nblk, blksize, XModel.cf, XModel.time.arrmax, XModel.time.arrmin, XModel.time.dtmax);\n\n\n    //Allocate block info\n    AllocateGPU(nblk, 1, XModel.blocks.active);\n    AllocateGPU(nblk, blksize, XModel.blocks.activeCell);\n    AllocateGPU(nblk, 1, XModel.blocks.level);\n\n    AllocateGPU(nblk, 1, XModel.blocks.BotLeft, XModel.blocks.BotRight, XModel.blocks.LeftBot, XModel.blocks.LeftTop);\n    AllocateGPU(nblk, 1, XModel.blocks.RightBot, XModel.blocks.RightTop, XModel.blocks.TopLeft, XModel.blocks.TopRight);\n\n    AllocateGPU(nblk, 1, XModel.blocks.xo);\n    AllocateGPU(nblk, 1, XModel.blocks.yo);\n\n    // If no adatptation ignore this!\n    /*\n    if (XParam.maxlevel != XParam.minlevel)\n    {\n        AllocateGPU(nblk, 1, XModel.adapt.availblk, XModel.adapt.csumblk, XModel.adapt.invactive, XModel.adapt.newlevel);\n        AllocateGPU(nblk, 1, XModel.adapt.coarsen);\n        AllocateGPU(nblk, 1, XModel.adapt.refine);\n    }\n    */\n\n\n\n    if (XParam.atmpforcing)\n    {\n        AllocateGPU(nblk, blksize, XModel.Patm);\n        AllocateGPU(nblk, blksize, XModel.datmpdx);\n        AllocateGPU(nblk, blksize, XModel.datmpdy);\n    }\n\n    if (XParam.infiltration)\n    {\n        AllocateGPU(nblk, blksize, XModel.il);\n        AllocateGPU(nblk, blksize, XModel.cl);\n        AllocateGPU(nblk, blksize, XModel.hgw);\n    }\n\n    if (XParam.outmax)\n    {\n        AllocateGPU(nblk, blksize, XModel.evmax);\n    }\n    if (XParam.outmean)\n    {\n        AllocateGPU(nblk, blksize, XModel.evmean);\n    }\n    if (XParam.outtwet)\n    {\n        AllocateGPU(nblk, blksize, XModel.wettime);\n    }\n\n\n    /*if (XParam.outvort)\n    {\n        AllocateGPU(nblk, blksize, XModel.vort);\n    }\n    if (XParam.outU)\n    {\n        AllocateGPU(nblk, blksize, XModel.U);\n    }*/\n\n    if (XParam.TSnodesout.size() &gt; 0)\n    {\n        // Timeseries output temporary storage\n        int storage = XParam.maxTSstorage;\n        AllocateGPU(storage, 1, XModel.TSstore);\n    }\n\n    // Allocate textures for boundary and forcing is done in init forcing\n\n\n\n}\n\ntemplate void AllocateGPU&lt;float&gt;(int nblk, int blksize, Param XParam, Model&lt;float&gt;&amp; XModel);\ntemplate void AllocateGPU&lt;double&gt;(int nblk, int blksize, Param XParam, Model&lt;double&gt;&amp; XModel);\n</code></pre>"},{"location":"BGFlood/MemManagement_8h/","title":"File MemManagement.h","text":""},{"location":"BGFlood/MemManagement_8h/#file-memmanagementh","title":"File MemManagement.h","text":"<p>FileList &gt; src &gt; MemManagement.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Setup_GPU.h\"</code></li> </ul>"},{"location":"BGFlood/MemManagement_8h/#public-functions","title":"Public Functions","text":"Type Name void AllocateCPU (int nx, int ny, T *&amp; zb)  void AllocateCPU (int nx, int ny, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v)  void AllocateCPU (int nx, int ny, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v, T *&amp; U, T *&amp; hU)  void AllocateCPU (int nx, int ny, GradientsP&lt; T &gt; &amp; Grad)  void AllocateCPU (int nblk, int blksize, EvolvingP&lt; T &gt; &amp; Ev)  void AllocateCPU (int nblk, int blksize, EvolvingP_M&lt; T &gt; &amp; Ev)  void AllocateCPU (int nblk, int blksize, Param XParam, Model&lt; T &gt; &amp; XModel)  void AllocateGPU (int nblk, int blksize, Param XParam, Model&lt; T &gt; &amp; XModel)  void AllocateGPU (int nx, int ny, T *&amp; z_g)  void AllocateMappedMemCPU (int nx, int ny, int gpudevice, T *&amp; z)  void AllocateMappedMemGPU (int nx, int ny, int gpudevice, T *&amp; z_g, T * z)  __host__ void FillCPU (int nx, int ny, T fillval, T *&amp; zb)  void ReallocArray (int nblk, int blksize, T *&amp; zb)  void ReallocArray (int nblk, int blksize, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v)  void ReallocArray (int nblk, int blksize, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v, T *&amp; U, T *&amp; hU)  void ReallocArray (int nblk, int blksize, EvolvingP&lt; T &gt; &amp; Ev)  void ReallocArray (int nblk, int blksize, EvolvingP_M&lt; T &gt; &amp; Ev)  void ReallocArray (int nblk, int blksize, Param XParam, Model&lt; T &gt; &amp; XModel)  int memloc (Param XParam, int i, int j, int ib)  __host__ __device__ int memloc (int halowidth, int blkmemwidth, int i, int j, int ib)"},{"location":"BGFlood/MemManagement_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/MemManagement_8h/#function-allocatecpu","title":"function AllocateCPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nx,\n    int ny,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-allocatecpu_1","title":"function AllocateCPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nx,\n    int ny,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-allocatecpu_2","title":"function AllocateCPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nx,\n    int ny,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v,\n    T *&amp; U,\n    T *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-allocatecpu_3","title":"function AllocateCPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nx,\n    int ny,\n    GradientsP &lt; T &gt; &amp; Grad\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-allocatecpu_4","title":"function AllocateCPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; T &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-allocatecpu_5","title":"function AllocateCPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; T &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-allocatecpu_6","title":"function AllocateCPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-allocategpu","title":"function AllocateGPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-allocategpu_1","title":"function AllocateGPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nx,\n    int ny,\n    T *&amp; z_g\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-allocatemappedmemcpu","title":"function AllocateMappedMemCPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateMappedMemCPU (\n    int nx,\n    int ny,\n    int gpudevice,\n    T *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-allocatemappedmemgpu","title":"function AllocateMappedMemGPU","text":"<pre><code>template&lt;class T&gt;\nvoid AllocateMappedMemGPU (\n    int nx,\n    int ny,\n    int gpudevice,\n    T *&amp; z_g,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-fillcpu","title":"function FillCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void FillCPU (\n    int nx,\n    int ny,\n    T fillval,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-reallocarray","title":"function ReallocArray","text":"<pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-reallocarray_1","title":"function ReallocArray","text":"<pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-reallocarray_2","title":"function ReallocArray","text":"<pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v,\n    T *&amp; U,\n    T *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-reallocarray_3","title":"function ReallocArray","text":"<pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; T &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-reallocarray_4","title":"function ReallocArray","text":"<pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; T &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-reallocarray_5","title":"function ReallocArray","text":"<pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-memloc","title":"function memloc","text":"<pre><code>int memloc (\n    Param XParam,\n    int i,\n    int j,\n    int ib\n) \n</code></pre>"},{"location":"BGFlood/MemManagement_8h/#function-memloc_1","title":"function memloc","text":"<pre><code>__host__ __device__ int memloc (\n    int halowidth,\n    int blkmemwidth,\n    int i,\n    int j,\n    int ib\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/MemManagement.h</code></p>"},{"location":"BGFlood/MemManagement_8h_source/","title":"File MemManagement.h","text":""},{"location":"BGFlood/MemManagement_8h_source/#file-memmanagementh","title":"File MemManagement.h","text":"<p>File List &gt; src &gt; MemManagement.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef MEMMANAGEMENT_H\n#define MEMMANAGEMENT_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Setup_GPU.h\"\n\n\ntemplate &lt;class T&gt; void AllocateCPU(int nx, int ny, T*&amp; zb);\ntemplate &lt;class T&gt; void AllocateCPU(int nx, int ny, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v);\ntemplate &lt;class T&gt; void AllocateCPU(int nx, int ny, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v, T*&amp; U, T*&amp; hU);\n\ntemplate &lt;class T&gt; void AllocateCPU(int nx, int ny, GradientsP&lt;T&gt;&amp; Grad);\ntemplate &lt;class T&gt; void AllocateCPU(int nblk, int blksize, EvolvingP&lt;T&gt; &amp;Ev);\ntemplate &lt;class T&gt; void AllocateCPU(int nblk, int blksize, EvolvingP_M&lt;T&gt;&amp; Ev);\ntemplate &lt;class T&gt; void AllocateCPU(int nblk, int blksize, Param XParam, Model&lt;T&gt;&amp; XModel);\n\n\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, T*&amp; zb);\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v);\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v, T*&amp; U, T*&amp; hU);\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, EvolvingP&lt;T&gt;&amp; Ev);\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, EvolvingP_M&lt;T&gt;&amp; Ev);\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, Param XParam, Model&lt;T&gt;&amp; XModel);\n\ntemplate &lt;class T&gt; void AllocateMappedMemCPU(int nx, int ny, int gpudevice, T*&amp; z);\n\n\ntemplate &lt;class T&gt; __host__ void FillCPU(int nx, int ny, T fillval, T*&amp; zb);\n\nint memloc(Param XParam, int i, int j, int ib);\n//__device__ int memloc(int halowidth, int blkmemwidth, int  blksize, int i, int j, int ib);\n__host__ __device__ int memloc(int halowidth, int blkmemwidth, int i, int j, int ib);\n\ntemplate &lt;class T&gt; void AllocateGPU(int nblk, int blksize, Param XParam, Model&lt;T&gt;&amp; XModel);\ntemplate &lt;class T&gt; void AllocateGPU(int nx, int ny, T*&amp; z_g);\ntemplate &lt;class T&gt; void AllocateMappedMemGPU(int nx, int ny, int gpudevice, T*&amp; z_g, T* z);\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Mesh_8cu/","title":"File Mesh.cu","text":""},{"location":"BGFlood/Mesh_8cu/#file-meshcu","title":"File Mesh.cu","text":"<p>FileList &gt; src &gt; Mesh.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Mesh.h\"</code></li> </ul>"},{"location":"BGFlood/Mesh_8cu/#public-functions","title":"Public Functions","text":"Type Name int CalcInitnblk (Param XParam, Forcing&lt; float &gt; XForcing)  int CalcMaskblk (Param XParam, BlockP&lt; T &gt; XBlock)  template int CalcMaskblk&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock)  template int CalcMaskblk&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock)  void FindMaskblk (Param XParam, BlockP&lt; T &gt; &amp; XBlock)  template void FindMaskblk&lt; double &gt; (Param XParam, BlockP&lt; double &gt; &amp; XBlock)  template void FindMaskblk&lt; float &gt; (Param XParam, BlockP&lt; float &gt; &amp; XBlock)  void InitBlockInfo (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; T &gt; &amp; XBlock)  void InitBlockadapt (Param &amp; XParam, BlockP&lt; T &gt; XBlock, AdaptP &amp; XAdap)  template void InitBlockadapt&lt; double &gt; (Param &amp; XParam, BlockP&lt; double &gt; XBlock, AdaptP &amp; XAdap)  template void InitBlockadapt&lt; float &gt; (Param &amp; XParam, BlockP&lt; float &gt; XBlock, AdaptP &amp; XAdap)  void InitBlockneighbours (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; T &gt; &amp; XBlock)  template void InitBlockneighbours&lt; double &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; double &gt; &amp; XBlock)  template void InitBlockneighbours&lt; float &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; float &gt; &amp; XBlock)  void InitBlockxoyo (Param XParam, Forcing&lt; float &gt; XForcing, BlockP&lt; T &gt; &amp; XBlock)  template void InitBlockxoyo&lt; double &gt; (Param XParam, Forcing&lt; float &gt; XForcing, BlockP&lt; double &gt; &amp; XBlockP)  template void InitBlockxoyo&lt; float &gt; (Param XParam, Forcing&lt; float &gt; XForcing, BlockP&lt; float &gt; &amp; XBlock)  void InitMesh (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel)  template void InitMesh&lt; double &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; double &gt; &amp; XModel)  template void InitMesh&lt; float &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; float &gt; &amp; XModel)"},{"location":"BGFlood/Mesh_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Mesh_8cu/#function-calcinitnblk","title":"function CalcInitnblk","text":"<pre><code>int CalcInitnblk (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-calcmaskblk","title":"function CalcMaskblk","text":"<pre><code>template&lt;class T&gt;\nint CalcMaskblk (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-calcmaskblk-double","title":"function CalcMaskblk&lt; double &gt;","text":"<pre><code>template int CalcMaskblk&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-calcmaskblk-float","title":"function CalcMaskblk&lt; float &gt;","text":"<pre><code>template int CalcMaskblk&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-findmaskblk","title":"function FindMaskblk","text":"<pre><code>template&lt;class T&gt;\nvoid FindMaskblk (\n    Param XParam,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-findmaskblk-double","title":"function FindMaskblk&lt; double &gt;","text":"<pre><code>template void FindMaskblk&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-findmaskblk-float","title":"function FindMaskblk&lt; float &gt;","text":"<pre><code>template void FindMaskblk&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-initblockinfo","title":"function InitBlockInfo","text":"<pre><code>template&lt;class T&gt;\nvoid InitBlockInfo (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-initblockadapt","title":"function InitBlockadapt","text":"<pre><code>template&lt;class T&gt;\nvoid InitBlockadapt (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; XBlock,\n    AdaptP &amp; XAdap\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-initblockadapt-double","title":"function InitBlockadapt&lt; double &gt;","text":"<pre><code>template void InitBlockadapt&lt; double &gt; (\n    Param &amp; XParam,\n    BlockP &lt; double &gt; XBlock,\n    AdaptP &amp; XAdap\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-initblockadapt-float","title":"function InitBlockadapt&lt; float &gt;","text":"<pre><code>template void InitBlockadapt&lt; float &gt; (\n    Param &amp; XParam,\n    BlockP &lt; float &gt; XBlock,\n    AdaptP &amp; XAdap\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-initblockneighbours","title":"function InitBlockneighbours","text":"<pre><code>template&lt;class T&gt;\nvoid InitBlockneighbours (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-initblockneighbours-double","title":"function InitBlockneighbours&lt; double &gt;","text":"<pre><code>template void InitBlockneighbours&lt; double &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; double &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-initblockneighbours-float","title":"function InitBlockneighbours&lt; float &gt;","text":"<pre><code>template void InitBlockneighbours&lt; float &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; float &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-initblockxoyo","title":"function InitBlockxoyo","text":"<pre><code>template&lt;class T&gt;\nvoid InitBlockxoyo (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-initblockxoyo-double","title":"function InitBlockxoyo&lt; double &gt;","text":"<pre><code>template void InitBlockxoyo&lt; double &gt; (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    BlockP &lt; double &gt; &amp; XBlockP\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-initblockxoyo-float","title":"function InitBlockxoyo&lt; float &gt;","text":"<pre><code>template void InitBlockxoyo&lt; float &gt; (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    BlockP &lt; float &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-initmesh","title":"function InitMesh","text":"<pre><code>template&lt;class T&gt;\nvoid InitMesh (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-initmesh-double","title":"function InitMesh&lt; double &gt;","text":"<pre><code>template void InitMesh&lt; double &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8cu/#function-initmesh-float","title":"function InitMesh&lt; float &gt;","text":"<pre><code>template void InitMesh&lt; float &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Mesh.cu</code></p>"},{"location":"BGFlood/Mesh_8cu_source/","title":"File Mesh.cu","text":""},{"location":"BGFlood/Mesh_8cu_source/#file-meshcu","title":"File Mesh.cu","text":"<p>File List &gt; src &gt; Mesh.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //    \n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n\n#include \"Mesh.h\"\n\nint CalcInitnblk(Param XParam, Forcing&lt;float&gt; XForcing)\n{\n\n    // Rearrange the memory in uniform blocks\n\n\n    //max nb of blocks is ceil(nx/16)*ceil(ny/16)\n    int nblk = 0;\n    int nmask = 0;\n    //int mloc = 0;\n\n    bool insidepoly = false;\n\n    double levdx = calcres(XParam.dx, XParam.initlevel);\n\n    int maxnbx = ftoi(ceil(XParam.nx / (double)XParam.blkwidth));\n    int maxnby = ftoi(ceil(XParam.ny / (double)XParam.blkwidth));\n\n    for (int nblky = 0; nblky &lt; maxnby; nblky++)\n    {\n        for (int nblkx = 0; nblkx &lt; maxnbx; nblkx++)\n        {\n            insidepoly = true;\n            if (XForcing.AOI.active)\n            {\n                insidepoly = blockinpoly(XParam.xo + nblkx * XParam.blkwidth * levdx, XParam.yo + nblky * XParam.blkwidth * levdx, levdx, XParam.blkwidth, XForcing.AOI.poly);\n            }\n            nmask = 0;\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                for (int j = 0; j &lt; XParam.blkwidth; j++)\n                {\n                    double x = XParam.xo + (double(i) + (double)XParam.blkwidth * (double)nblkx) * levdx + 0.5 * levdx;\n                    double y = XParam.yo + (double(j) + (double)XParam.blkwidth * (double)nblky) * levdx + 0.5 * levdx;\n\n                    //if (x &gt;= XForcing.Bathy.xo &amp;&amp; x &lt;= XForcing.Bathy.xmax &amp;&amp; y &gt;= XForcing.Bathy.yo &amp;&amp; y &lt;= XForcing.Bathy.ymax)\n                    {\n                        // cells that falls off this domain are assigned\n                        double x1, x2, y1, y2;\n                        double q11, q12, q21, q22, q;\n                        int cfi, cfip, cfj, cfjp;\n\n                        x = utils::max(utils::min(x, XForcing.Bathy[0].xmax), XForcing.Bathy[0].xo);\n                        y = utils::max(utils::min(y, XForcing.Bathy[0].ymax), XForcing.Bathy[0].yo);\n\n                        cfi = utils::min(utils::max((int)floor((x - XForcing.Bathy[0].xo) / XForcing.Bathy[0].dx), 0), XForcing.Bathy[0].nx - 2);\n                        cfip = cfi + 1;\n\n                        x1 = XForcing.Bathy[0].xo + XForcing.Bathy[0].dx * cfi;\n                        x2 = XForcing.Bathy[0].xo + XForcing.Bathy[0].dx * cfip;\n\n                        cfj = utils::min(utils::max((int)floor((y - XForcing.Bathy[0].yo) / XForcing.Bathy[0].dx), 0), XForcing.Bathy[0].ny - 2);\n                        cfjp = cfj + 1;\n\n                        y1 = XForcing.Bathy[0].yo + XForcing.Bathy[0].dx * cfj;\n                        y2 = XForcing.Bathy[0].yo + XForcing.Bathy[0].dx * cfjp;\n\n                        q11 = XForcing.Bathy[0].val[cfi + cfj * XForcing.Bathy[0].nx];\n                        q12 = XForcing.Bathy[0].val[cfi + cfjp * XForcing.Bathy[0].nx];\n                        q21 = XForcing.Bathy[0].val[cfip + cfj * XForcing.Bathy[0].nx];\n                        q22 = XForcing.Bathy[0].val[cfip + cfjp * XForcing.Bathy[0].nx];\n\n                        q = BilinearInterpolation(q11, q12, q21, q22, x1, x2, y1, y2, x, y);\n                        //printf(\"q = %f\\n\", q);\n                        //printf(\"mloc: %i\\n\", mloc);\n                        if (q &gt;= XParam.mask)\n                            nmask++;\n                    }\n                    //else\n                    //{\n                        //computational domnain is outside of the bathy domain\n                    //}\n\n                }\n            }\n            if ((nmask &lt; (XParam.blkwidth* XParam.blkwidth)) &amp;&amp; insidepoly)\n                nblk++;\n        }\n    }\n\n    return nblk;\n}\n\ntemplate &lt;class T&gt;\nvoid InitMesh(Param &amp;XParam, Forcing&lt;float&gt; &amp; XForcing, Model&lt;T&gt; &amp;XModel)\n{\n    //=============================\n    // Calculate an initial number of block\n\n    log(\"\\nInitializing mesh\");\n    int nblk;\n\n    nblk = CalcInitnblk(XParam, XForcing);\n\n    XParam.nblk = nblk;\n    // allocate a few extra blocks for adaptation\n    XParam.nblkmem = (int)ceil(nblk * XParam.membuffer); //5% buffer on the memory for adaptation \n\n    log(\"\\tInitial number of blocks: \" + std::to_string(nblk) + \"; Will be allocating \" + std::to_string(XParam.nblkmem) + \" in memory.\");\n\n    //==============================\n    // Allocate CPU memory for the whole model\n    AllocateCPU(XParam.nblkmem, XParam.blksize, XParam, XModel);\n\n\n    //==============================\n    // Initialise blockinfo info\n    InitBlockInfo(XParam, XForcing, XModel.blocks);\n\n    //==============================\n    // Init. adaptation info if needed\n    if (XParam.maxlevel != XParam.minlevel)\n    {\n\n        InitBlockadapt(XParam, XModel.blocks, XModel.adapt);\n    }\n\n    //==============================\n    // Reallocate array containing boundary blocks\n\n    //==============================\n    // Add mask block info (flag the block with at least one empty neighbour that is not boundary)\n    FindMaskblk(XParam, XModel.blocks);\n\n\n}\n\ntemplate void InitMesh&lt;float&gt;(Param &amp;XParam, Forcing&lt;float&gt;&amp; XForcing, Model&lt;float&gt; &amp;XModel);\ntemplate void InitMesh&lt;double&gt;(Param &amp;XParam, Forcing&lt;float&gt;&amp; XForcing, Model&lt;double&gt; &amp;XModel);\n\ntemplate &lt;class T&gt; void InitBlockInfo(Param &amp;XParam, Forcing&lt;float&gt; &amp;XForcing, BlockP&lt;T&gt;&amp; XBlock)\n{\n    //============================\n    // Init active and level\n\n    // Initialise activeblk array as all inactive ( = -1 )\n    // Here we cannot yet use the InitBlkBUQ function since none of the blk are active\n    //InitBlkBUQ(XParam, XBlock, XParam.initlevel, XBlock.level)\n    for (int ib = 0; ib &lt; XParam.nblkmem; ib++)\n    {\n        XBlock.active[ib] = -1;\n        XBlock.level[ib] = XParam.initlevel;\n    }\n\n\n\n    //============================\n    // Init xo, yo and active blk\n    InitBlockxoyo(XParam, XForcing, XBlock);\n\n    //============================\n    // Init neighbours\n    InitBlockneighbours(XParam, XForcing, XBlock);\n    //Calcbndblks(XParam, XForcing, XBlock);\n\n}\n\ntemplate &lt;class T&gt; void InitBlockadapt(Param &amp;XParam, BlockP&lt;T&gt; XBlock, AdaptP&amp; XAdap)\n{\n        InitBlkBUQ(XParam, XBlock, XParam.initlevel, XAdap.newlevel);\n        InitBlkBUQ(XParam, XBlock, false, XAdap.coarsen);\n        InitBlkBUQ(XParam, XBlock, false, XAdap.refine);\n        //InitBlkBUQ(XParam, XBlock, XParam.initlevel, XBlock.level);\n        //InitBlkBUQ(XParam, XBlock, XParam.initlevel, XBlock.level);\n        //InitArrayBUQ(XParam.nblkmem, 1, 0, XParam.initlevel, XAdap.newlevel);\n        //InitArrayBUQ(XParam.nblkmem, 1, 0, false, XAdap.coarsen);\n        //InitArrayBUQ(XParam.nblkmem, 1, 0, false, XAdap.refine);\n\n\n        for (int ibl = 0; ibl &lt; (XParam.nblkmem - XParam.nblk); ibl++)\n        {\n\n            XAdap.availblk[ibl] = XParam.nblk + ibl;\n            XParam.navailblk++;\n\n        }\n\n}\ntemplate void InitBlockadapt&lt;float&gt;(Param &amp;XParam, BlockP&lt;float&gt; XBlock, AdaptP&amp; XAdap);\ntemplate void InitBlockadapt&lt;double&gt;(Param &amp;XParam, BlockP&lt;double&gt; XBlock, AdaptP&amp; XAdap);\n\n\n\ntemplate &lt;class T&gt; void InitBlockxoyo(Param XParam, Forcing&lt;float&gt; XForcing, BlockP&lt;T&gt; &amp;XBlock)\n{\n\n    int nmask = 0;\n    //mloc = 0;\n    int blkid = 0;\n    double levdx = calcres(XParam.dx, XParam.initlevel);\n\n    bool insidepoly = true;\n\n    int maxnbx = ftoi(ceil(XParam.nx / (double)XParam.blkwidth));\n    int maxnby = ftoi(ceil(XParam.ny / (double)XParam.blkwidth));\n\n    for (int nblky = 0; nblky &lt; maxnby; nblky++)\n    {\n        for (int nblkx = 0; nblkx &lt; maxnbx; nblkx++)\n        {\n            insidepoly = true;\n            if (XForcing.AOI.active)\n            {\n                insidepoly = blockinpoly(XParam.xo + nblkx * XParam.blkwidth * levdx, XParam.yo + nblky * XParam.blkwidth * levdx, levdx, XParam.blkwidth, XForcing.AOI.poly);\n            }\n            nmask = 0;\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                for (int j = 0; j &lt; XParam.blkwidth; j++)\n                {\n                    double x = XParam.xo + (double(i) + (T)XParam.blkwidth * (T)nblkx)*levdx + 0.5 * levdx;\n                    double y = XParam.yo + (double(j) + (T)XParam.blkwidth * (T)nblky)*levdx + 0.5 * levdx;\n\n                    int n = memloc(XParam, i, j, blkid);\n\n                    //x = max(min(x, XParam.Bathymetry.xmax), XParam.Bathymetry.xo);\n                    //y = max(min(y, XParam.Bathymetry.ymax), XParam.Bathymetry.yo);\n\n                    {\n                        x = utils::max(utils::min(x, XForcing.Bathy[0].xmax), XForcing.Bathy[0].xo);\n                        y = utils::max(utils::min(y, XForcing.Bathy[0].ymax), XForcing.Bathy[0].yo);\n                        // cells that falls off this domain are assigned\n                        double x1, x2, y1, y2;\n                        double q11, q12, q21, q22, q;\n                        int cfi, cfip, cfj, cfjp;\n\n\n\n                        cfi = utils::min(utils::max((int)floor((x - XForcing.Bathy[0].xo) / XForcing.Bathy[0].dx), 0), XForcing.Bathy[0].nx - 2);\n                        cfip = cfi + 1;\n\n                        x1 = XForcing.Bathy[0].xo + XForcing.Bathy[0].dx*cfi;\n                        x2 = XForcing.Bathy[0].xo + XForcing.Bathy[0].dx*cfip;\n\n                        cfj = utils::min(utils::max((int)floor((y - XForcing.Bathy[0].yo) / XForcing.Bathy[0].dx), 0), XForcing.Bathy[0].ny - 2);\n                        cfjp = cfj + 1;\n\n                        y1 = XForcing.Bathy[0].yo + XForcing.Bathy[0].dx*cfj;\n                        y2 = XForcing.Bathy[0].yo + XForcing.Bathy[0].dx*cfjp;\n\n                        q11 = XForcing.Bathy[0].val[cfi + cfj*XForcing.Bathy[0].nx];\n                        q12 = XForcing.Bathy[0].val[cfi + cfjp*XForcing.Bathy[0].nx];\n                        q21 = XForcing.Bathy[0].val[cfip + cfj*XForcing.Bathy[0].nx];\n                        q22 = XForcing.Bathy[0].val[cfip + cfjp*XForcing.Bathy[0].nx];\n\n                        q = BilinearInterpolation(q11, q12, q21, q22, x1, x2, y1, y2, x, y);\n                        //printf(\"q = %f\\t q11=%f\\t, q12=%f\\t, q21=%f\\t, q22=%f\\t, x1=%f\\t, x2=%f\\t, y1=%f\\t, y2=%f\\t, x=%f\\t, y=%f\\t\\n\", q, q11, q12, q21, q22, x1, x2, y1, y2, x, y);\n                        //printf(\"mloc: %i\\n\", mloc);\n                        if (q &gt;= XParam.mask)\n                        {\n                            nmask++;\n\n                        }\n                    }\n\n\n                }\n            }\n            if ((nmask &lt; (XParam.blkwidth * XParam.blkwidth)) &amp;&amp; insidepoly)\n            {\n                //\n                XBlock.xo[blkid] = nblkx * ((T)XParam.blkwidth) * (T)levdx + T(0.5) * (T)levdx;\n                XBlock.yo[blkid] = nblky * ((T)XParam.blkwidth) * (T)levdx + T(0.5) * (T)levdx;\n                XBlock.active[blkid] = blkid;\n                //printf(\"blkxo=%f\\tblkyo=%f\\n\", blockxo_d[blkid], blockyo_d[blkid]);\n                blkid++;\n            }\n        }\n    }\n\n\n\n\n}\ntemplate void InitBlockxoyo&lt;float&gt;(Param XParam, Forcing&lt;float&gt; XForcing, BlockP&lt;float&gt; &amp;XBlock);\ntemplate void InitBlockxoyo&lt;double&gt;(Param XParam, Forcing&lt;float&gt; XForcing, BlockP&lt;double&gt; &amp; XBlockP);\n\ntemplate &lt;class T&gt; void InitBlockneighbours(Param &amp;XParam,Forcing&lt;float&gt; &amp;XForcing,  BlockP&lt;T&gt;&amp; XBlock)\n{\n    // This function will only work if the blocks are uniform\n    // A separate function is used for adaptivity\n    T leftxo, rightxo, topxo, botxo, leftyo, rightyo, topyo, botyo;\n\n    //====================================\n    // First setp up neighbours\n\n    double levdx = calcres(XParam.dx, XParam.initlevel);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n\n        int bl = XBlock.active[ibl];\n        //T espdist = std::numeric_limits&lt;T&gt;::epsilon() * (T)100.0; // i.e. distances are calculated within 100x theoretical machine precision\n        // This too theoretical error definition has been modified to allow more flexibility\n        T espdist = (T)levdx/3;\n\n\n        leftxo = XBlock.xo[bl] - ((T)XParam.blkwidth) * (T)levdx;\n\n        leftyo = XBlock.yo[bl];\n        rightxo = XBlock.xo[bl] + ((T)XParam.blkwidth) * (T)levdx;\n        rightyo = XBlock.yo[bl];\n        topxo = XBlock.xo[bl];\n        topyo = XBlock.yo[bl] + ((T)XParam.blkwidth) * (T)levdx;\n        botxo = XBlock.xo[bl];\n        botyo = XBlock.yo[bl] - ((T)XParam.blkwidth) * (T)levdx;\n\n        // by default neighbour block refer to itself. i.e. if the neighbour block is itself then there are no neighbour\n        XBlock.LeftBot[bl] = bl;\n        XBlock.LeftTop[bl] = bl;\n        XBlock.RightBot[bl] = bl;\n        XBlock.RightTop[bl] = bl;\n        XBlock.TopLeft[bl] = bl;\n        XBlock.TopRight[bl] = bl;\n        XBlock.BotLeft[bl] = bl;\n        XBlock.BotRight[bl] = bl;\n\n\n        for (int iblb = 0; iblb &lt; XParam.nblk; iblb++)\n        {\n            //\n            int blb = XBlock.active[iblb];\n            if (abs(XBlock.xo[blb] - leftxo) &lt; espdist &amp;&amp; abs(XBlock.yo[blb] - leftyo) &lt; espdist)\n            {\n                XBlock.LeftBot[bl] = blb;\n                XBlock.LeftTop[bl] = blb;\n            }\n            if (abs(XBlock.xo[blb] - rightxo) &lt; espdist &amp;&amp; abs(XBlock.yo[blb] - rightyo) &lt; espdist)\n            {\n                XBlock.RightBot[bl] = blb;\n                XBlock.RightTop[bl] = blb;\n            }\n            if (abs(XBlock.xo[blb] - topxo) &lt; espdist &amp;&amp; abs(XBlock.yo[blb] - topyo) &lt; espdist)\n            {\n                XBlock.TopLeft[bl] = blb;\n                XBlock.TopRight[bl] = blb;\n\n            }\n            if (abs(XBlock.xo[blb] - botxo) &lt; espdist &amp;&amp; abs(XBlock.yo[blb] - botyo) &lt; espdist)\n            {\n                XBlock.BotLeft[bl] = blb;\n                XBlock.BotRight[bl] = blb;\n            }\n        }\n    }\n\n\n\n    //\n\n\n}\ntemplate void InitBlockneighbours&lt;float&gt;(Param &amp;XParam,  Forcing&lt;float&gt;&amp; XForcing, BlockP&lt;float&gt;&amp; XBlock);\ntemplate void InitBlockneighbours&lt;double&gt;(Param &amp;XParam, Forcing&lt;float&gt;&amp; XForcing, BlockP&lt;double&gt;&amp; XBlock);\n\n\n\ntemplate &lt;class T&gt; int CalcMaskblk(Param XParam, BlockP&lt;T&gt; XBlock)\n{\n    int nmask = 0;\n    bool neighbourmask = false;\n    T leftxo, rightxo, topyo,  botyo;\n    T initlevdx = calcres((T)XParam.dx, XParam.initlevel);\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        T levdx = calcres((T)XParam.dx, XBlock.level[ib]);\n\n        leftxo = XBlock.xo[ib]; // in adaptive this shoulbe be a range \n\n        //leftyo = XBlock.yo[ib];\n        rightxo = XBlock.xo[ib] + (XParam.blkwidth - 1) * levdx;\n        //rightyo = XBlock.yo[ib];\n        //topxo = XBlock.xo[ib];\n        topyo = XBlock.yo[ib] + (XParam.blkwidth - 1) * levdx;\n        //botxo = XBlock.xo[ib];\n        botyo = XBlock.yo[ib];\n\n        neighbourmask = false;\n\n        if ((XBlock.LeftBot[ib] == ib || XBlock.LeftTop[ib] == ib) &amp;&amp; leftxo &gt; levdx)\n        {\n            neighbourmask = true;\n        }\n        if ((XBlock.BotLeft[ib] == ib || XBlock.BotRight[ib] == ib) &amp;&amp; botyo &gt; levdx)\n        {\n            neighbourmask = true;\n        }\n        if ((XBlock.TopLeft[ib] == ib || XBlock.TopRight[ib] == ib) &amp;&amp; ((topyo - (XParam.ymax - XParam.yo)) &lt; (-1.0 * levdx)))\n        {\n            neighbourmask = true;\n        }\n        if ((XBlock.RightBot[ib] == ib || XBlock.RightBot[ib] == ib) &amp;&amp; ((rightxo - (XParam.xmax - XParam.xo)) &lt; (-1.0 * levdx)))\n        {\n            neighbourmask = true;\n        }\n\n        int nadd = neighbourmask ? 1 : 0;\n\n        nmask = nmask + nadd;\n\n    }\n\n    return nmask;\n}\ntemplate int CalcMaskblk&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock);\ntemplate int CalcMaskblk&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock);\n\n\n\ntemplate &lt;class T&gt; void FindMaskblk(Param XParam, BlockP&lt;T&gt; &amp;XBlock)\n{\n\n    XBlock.mask.nblk = CalcMaskblk(XParam, XBlock);\n    if (XBlock.mask.nblk &gt; 0)\n    {\n        int nmask = 0;\n        bool neighbourmask = false;\n        T leftxo, rightxo,  topyo, botyo;\n\n        // Reallocate array if necessary\n        ReallocArray(XBlock.mask.nblk, 1, XBlock.mask.side);\n        ReallocArray(XBlock.mask.nblk, 1, XBlock.mask.blks);\n\n\n        for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n        {\n            int ib = XBlock.active[ibl];\n            T levdx = calcres((T)XParam.dx, XBlock.level[ib]);\n\n            leftxo = XBlock.xo[ib]; // in adaptive this shoulbe be a range \n\n            //leftyo = XBlock.yo[ib];\n            rightxo = XBlock.xo[ib] + (XParam.blkwidth - 1) * levdx;\n            //rightyo = XBlock.yo[ib];\n            //topxo = XBlock.xo[ib];\n            topyo = XBlock.yo[ib] + (XParam.blkwidth - 1) * levdx;\n            //botxo = XBlock.xo[ib];\n            botyo = XBlock.yo[ib];\n\n            neighbourmask = false;\n\n            if (nmask &lt; XBlock.mask.nblk)\n            {\n                XBlock.mask.side[nmask] = 0b00000000;\n            }\n\n\n            if ((XBlock.LeftBot[ib] == ib || XBlock.LeftTop[ib] == ib) &amp;&amp; leftxo &gt; levdx)\n            {\n                XBlock.mask.blks[nmask] = ib;\n\n                if (XBlock.LeftBot[ib] == ib)\n                {\n                    XBlock.mask.side[nmask] = XBlock.mask.side[nmask] | 0b10000000;\n                }\n                if (XBlock.LeftTop[ib] == ib)\n                {\n                    XBlock.mask.side[nmask] = XBlock.mask.side[nmask] | 0b01000000;\n                }\n                neighbourmask = true;\n            }\n\n            if ((XBlock.TopLeft[ib] == ib || XBlock.TopRight[ib] == ib) &amp;&amp; ((topyo - (XParam.ymax - XParam.yo)) &lt; (-1.0 * levdx)))\n            {\n                XBlock.mask.blks[nmask] = ib;\n                if (XBlock.TopLeft[ib] == ib)\n                {\n                    XBlock.mask.side[nmask] = XBlock.mask.side[nmask] | 0b00100000;\n                }\n                if (XBlock.TopRight[ib] == ib)\n                {\n                    XBlock.mask.side[nmask] = XBlock.mask.side[nmask] | 0b00010000;\n                }\n\n                neighbourmask = true;\n            }\n            if ((XBlock.RightBot[ib] == ib || XBlock.RightBot[ib] == ib) &amp;&amp; ((rightxo - (XParam.xmax - XParam.xo)) &lt; (-1.0 * levdx)))\n            {\n                XBlock.mask.blks[nmask] = ib;\n                if (XBlock.RightTop[ib] == ib)\n                {\n                    XBlock.mask.side[nmask] = XBlock.mask.side[nmask] | 0b00001000;\n                }\n                if (XBlock.RightBot[ib] == ib)\n                {\n                    XBlock.mask.side[nmask] = XBlock.mask.side[nmask] | 0b00000100;\n                }\n                neighbourmask = true;\n            }\n            if ((XBlock.BotLeft[ib] == ib || XBlock.BotRight[ib] == ib) &amp;&amp; botyo &gt; levdx)\n            {\n                XBlock.mask.blks[nmask] = ib;\n                if (XBlock.BotRight[ib] == ib)\n                {\n                    XBlock.mask.side[nmask] = XBlock.mask.side[nmask] | 0b00000010;\n                }\n                if (XBlock.BotLeft[ib] == ib)\n                {\n                    XBlock.mask.side[nmask] = XBlock.mask.side[nmask] | 0b00000001;\n                }\n                neighbourmask = true;\n            }\n\n            int nadd = neighbourmask ? 1 : 0;\n\n            nmask = nmask + nadd;\n\n        }\n    }\n}\ntemplate void FindMaskblk&lt;float&gt;(Param XParam, BlockP&lt;float&gt; &amp;XBlock);\ntemplate void FindMaskblk&lt;double&gt;(Param XParam, BlockP&lt;double&gt; &amp;XBlock);\n</code></pre>"},{"location":"BGFlood/Mesh_8h/","title":"File Mesh.h","text":""},{"location":"BGFlood/Mesh_8h/#file-meshh","title":"File Mesh.h","text":"<p>FileList &gt; src &gt; Mesh.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"GridManip.h\"</code></li> <li><code>#include \"Poly.h\"</code></li> </ul>"},{"location":"BGFlood/Mesh_8h/#public-functions","title":"Public Functions","text":"Type Name int CalcInitnblk (Param XParam, Forcing&lt; float &gt; XForcing)  int CalcMaskblk (Param XParam, BlockP&lt; T &gt; XBlock)  void FindMaskblk (Param XParam, BlockP&lt; T &gt; &amp; XBlock)  void InitBlockInfo (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; T &gt; &amp; XBlock)  void InitBlockadapt (Param &amp; XParam, BlockP&lt; T &gt; XBlock, AdaptP &amp; XAdap)  void InitBlockneighbours (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; T &gt; &amp; XBlock)  void InitBlockxoyo (Param XParam, Forcing&lt; float &gt; XForcing, BlockP&lt; T &gt; &amp; XBlock)  void InitMesh (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel)"},{"location":"BGFlood/Mesh_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Mesh_8h/#function-calcinitnblk","title":"function CalcInitnblk","text":"<pre><code>int CalcInitnblk (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8h/#function-calcmaskblk","title":"function CalcMaskblk","text":"<pre><code>template&lt;class T&gt;\nint CalcMaskblk (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8h/#function-findmaskblk","title":"function FindMaskblk","text":"<pre><code>template&lt;class T&gt;\nvoid FindMaskblk (\n    Param XParam,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8h/#function-initblockinfo","title":"function InitBlockInfo","text":"<pre><code>template&lt;class T&gt;\nvoid InitBlockInfo (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8h/#function-initblockadapt","title":"function InitBlockadapt","text":"<pre><code>template&lt;class T&gt;\nvoid InitBlockadapt (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; XBlock,\n    AdaptP &amp; XAdap\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8h/#function-initblockneighbours","title":"function InitBlockneighbours","text":"<pre><code>template&lt;class T&gt;\nvoid InitBlockneighbours (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8h/#function-initblockxoyo","title":"function InitBlockxoyo","text":"<pre><code>template&lt;class T&gt;\nvoid InitBlockxoyo (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Mesh_8h/#function-initmesh","title":"function InitMesh","text":"<pre><code>template&lt;class T&gt;\nvoid InitMesh (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Mesh.h</code></p>"},{"location":"BGFlood/Mesh_8h_source/","title":"File Mesh.h","text":""},{"location":"BGFlood/Mesh_8h_source/#file-meshh","title":"File Mesh.h","text":"<p>File List &gt; src &gt; Mesh.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef MESH_H\n#define MESH_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"Write_txtlog.h\"\n#include \"GridManip.h\"\n#include \"Poly.h\"\n\n\nint CalcInitnblk(Param XParam, Forcing&lt;float&gt; XForcing);\n\n\ntemplate &lt;class T&gt; void InitMesh(Param&amp; XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;T&gt;&amp; XModel);\ntemplate &lt;class T&gt; void InitBlockInfo(Param &amp;XParam, Forcing&lt;float&gt; &amp;XForcing, BlockP&lt;T&gt;&amp; XBlock);\ntemplate &lt;class T&gt; void InitBlockadapt(Param &amp;XParam, BlockP&lt;T&gt; XBlock, AdaptP&amp; XAdap);\ntemplate &lt;class T&gt; void InitBlockxoyo(Param XParam, Forcing&lt;float&gt; XForcing, BlockP&lt;T&gt;&amp; XBlock);\ntemplate &lt;class T&gt; void InitBlockneighbours(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing, BlockP&lt;T&gt;&amp; XBlock);\n\ntemplate &lt;class T&gt; int CalcMaskblk(Param XParam, BlockP&lt;T&gt; XBlock);\ntemplate &lt;class T&gt; void FindMaskblk(Param XParam, BlockP&lt;T&gt; &amp;XBlock);\n\n// End of global definition;\n#endif\n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/","title":"File Multilayer.cu","text":""},{"location":"BGFlood/Multilayer_8cu/#file-multilayercu","title":"File Multilayer.cu","text":"<p>FileList &gt; src &gt; Multilayer.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Multilayer.h\"</code></li> </ul>"},{"location":"BGFlood/Multilayer_8cu/#public-functions","title":"Public Functions","text":"Type Name __global__ void AdvecEv (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  template __global__ void AdvecEv&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxMLP&lt; double &gt; XFlux)  template __global__ void AdvecEv&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxMLP&lt; float &gt; XFlux)  __global__ void AdvecFluxML (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  template __global__ void AdvecFluxML&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxMLP&lt; double &gt; XFlux)  template __global__ void AdvecFluxML&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxMLP&lt; float &gt; XFlux)  __global__ void CalcfaceValX (T pdt, Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux, T * dtmax, T * zb)  template __global__ void CalcfaceValX&lt; double &gt; (double pdt, Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxMLP&lt; double &gt; XFlux, double * dtmax, double * zb)  template __global__ void CalcfaceValX&lt; float &gt; (float pdt, Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxMLP&lt; float &gt; XFlux, float * dtmax, float * zb)  __global__ void CalcfaceValY (T pdt, Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux, T * dtmax, T * zb)  template __global__ void CalcfaceValY&lt; double &gt; (double pdt, Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxMLP&lt; double &gt; XFlux, double * dtmax, double * zb)  template __global__ void CalcfaceValY&lt; float &gt; (float pdt, Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxMLP&lt; float &gt; XFlux, float * dtmax, float * zb)  __global__ void CheckadvecMLX (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  template __global__ void CheckadvecMLX&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxMLP&lt; double &gt; XFlux)  template __global__ void CheckadvecMLX&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxMLP&lt; float &gt; XFlux)  __global__ void CheckadvecMLY (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  template __global__ void CheckadvecMLY&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxMLP&lt; double &gt; XFlux)  template __global__ void CheckadvecMLY&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxMLP&lt; float &gt; XFlux)  __global__ void CleanupML (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  template __global__ void CleanupML&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, double * zb)  template __global__ void CleanupML&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, float * zb)  __global__ void pressureML (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  template __global__ void pressureML&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxMLP&lt; double &gt; XFlux)  template __global__ void pressureML&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxMLP&lt; float &gt; XFlux)"},{"location":"BGFlood/Multilayer_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Multilayer_8cu/#function-advecev","title":"function AdvecEv","text":"<pre><code>template&lt;class T&gt;\n__global__ void AdvecEv (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-advecev-double","title":"function AdvecEv&lt; double &gt;","text":"<pre><code>template __global__ void AdvecEv&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxMLP &lt; double &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-advecev-float","title":"function AdvecEv&lt; float &gt;","text":"<pre><code>template __global__ void AdvecEv&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxMLP &lt; float &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-advecfluxml","title":"function AdvecFluxML","text":"<pre><code>template&lt;class T&gt;\n__global__ void AdvecFluxML (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-advecfluxml-double","title":"function AdvecFluxML&lt; double &gt;","text":"<pre><code>template __global__ void AdvecFluxML&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxMLP &lt; double &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-advecfluxml-float","title":"function AdvecFluxML&lt; float &gt;","text":"<pre><code>template __global__ void AdvecFluxML&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxMLP &lt; float &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-calcfacevalx","title":"function CalcfaceValX","text":"<pre><code>template&lt;class T&gt;\n__global__ void CalcfaceValX (\n    T pdt,\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-calcfacevalx-double","title":"function CalcfaceValX&lt; double &gt;","text":"<pre><code>template __global__ void CalcfaceValX&lt; double &gt; (\n    double pdt,\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxMLP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-calcfacevalx-float","title":"function CalcfaceValX&lt; float &gt;","text":"<pre><code>template __global__ void CalcfaceValX&lt; float &gt; (\n    float pdt,\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxMLP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-calcfacevaly","title":"function CalcfaceValY","text":"<pre><code>template&lt;class T&gt;\n__global__ void CalcfaceValY (\n    T pdt,\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-calcfacevaly-double","title":"function CalcfaceValY&lt; double &gt;","text":"<pre><code>template __global__ void CalcfaceValY&lt; double &gt; (\n    double pdt,\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxMLP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-calcfacevaly-float","title":"function CalcfaceValY&lt; float &gt;","text":"<pre><code>template __global__ void CalcfaceValY&lt; float &gt; (\n    float pdt,\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxMLP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-checkadvecmlx","title":"function CheckadvecMLX","text":"<pre><code>template&lt;class T&gt;\n__global__ void CheckadvecMLX (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-checkadvecmlx-double","title":"function CheckadvecMLX&lt; double &gt;","text":"<pre><code>template __global__ void CheckadvecMLX&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxMLP &lt; double &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-checkadvecmlx-float","title":"function CheckadvecMLX&lt; float &gt;","text":"<pre><code>template __global__ void CheckadvecMLX&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxMLP &lt; float &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-checkadvecmly","title":"function CheckadvecMLY","text":"<pre><code>template&lt;class T&gt;\n__global__ void CheckadvecMLY (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-checkadvecmly-double","title":"function CheckadvecMLY&lt; double &gt;","text":"<pre><code>template __global__ void CheckadvecMLY&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxMLP &lt; double &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-checkadvecmly-float","title":"function CheckadvecMLY&lt; float &gt;","text":"<pre><code>template __global__ void CheckadvecMLY&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxMLP &lt; float &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-cleanupml","title":"function CleanupML","text":"<pre><code>template&lt;class T&gt;\n__global__ void CleanupML (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-cleanupml-double","title":"function CleanupML&lt; double &gt;","text":"<pre><code>template __global__ void CleanupML&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-cleanupml-float","title":"function CleanupML&lt; float &gt;","text":"<pre><code>template __global__ void CleanupML&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-pressureml","title":"function pressureML","text":"<pre><code>template&lt;class T&gt;\n__global__ void pressureML (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-pressureml-double","title":"function pressureML&lt; double &gt;","text":"<pre><code>template __global__ void pressureML&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxMLP &lt; double &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8cu/#function-pressureml-float","title":"function pressureML&lt; float &gt;","text":"<pre><code>template __global__ void pressureML&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxMLP &lt; float &gt; XFlux\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Multilayer.cu</code></p>"},{"location":"BGFlood/Multilayer_8cu_source/","title":"File Multilayer.cu","text":""},{"location":"BGFlood/Multilayer_8cu_source/#file-multilayercu","title":"File Multilayer.cu","text":"<p>File List &gt; src &gt; Multilayer.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Multilayer.h\"\n\n//template &lt;class T&gt; void calcAbaro()\n//{\n//\n//  T gmetric = (2. * fm.x[i] / (cm[i] + cm[i - 1]))\n//\n//  a_baro[i] (G*gmetric*(eta[i-1] - eta[i])/Delta)\n//}\n\ntemplate &lt;class T&gt; __global__ void CalcfaceValX(T pdt,Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux, T* dtmax,T* zb)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps);// +epsi;\n    T dry = eps;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T CFL_H = T(0.5);\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n    T zsi = XEv.zs[i];\n\n    T zsn = XEv.zs[ileft];\n\n    T zbi = zb[i];\n    T zbn = zb[ileft];\n\n\n    T fmu = T(1.0);\n    T cm = T(1.0);//T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T gmetric = T(1.0);// (2. * fm.x[i] / (cm[i] + cm[i - 1]));\n\n    T ax = (g * gmetric * (zsn - zsi) / delta);\n\n    T H = 0.;\n    T um = 0.;\n    T Hr = 0.;\n    T Hl = 0.;\n\n\n    //foreach_layer() {\n    {\n        T hi = XEv.h[i];\n        T hn = XEv.h[ileft];\n        Hr += hi;\n        Hl += hn;\n        T hl = hn &gt; dry ? hn : 0.;\n        T hr = hi &gt; dry ? hi : 0.;\n\n\n\n        //XFlux.hu[i] = hl &gt; 0. || hr &gt; 0. ? (hl * XEv.u[ileft] + hr * XEvu[i]) / (hl + hr) : 0.;\n        T hui = hl &gt; 0. || hr &gt; 0. ? (hl * XEv.u[ileft] + hr * XEv.u[i]) / (hl + hr) : 0.;\n\n        T hff;\n\n        if (Hl &lt;= dry)\n            hff = max(min(zbi + Hr - zbn, hi), T(0.0));\n        else if (Hr &lt;= dry)\n            hff = max(min(zbn + Hl - zbi, hn), T(0.0));\n        else\n        {\n            T un = pdt * (hui) / delta; //pdt * (hui + pdt * ax) / delta;\n            T a =  signof(un);\n            int iu = un &gt; 0.0 ? ileft : i;// -(a + 1.) / 2.;\n            //double dhdx = h.gradient ? h.gradient(h[i - 1], h[i], h[i + 1]) / Delta : (h[i + 1] - h[i - 1]) / (2. * Delta);\n\n            hff = XEv.h[iu] + a * (1. - a * un) * XGrad.dhdx[iu] * delta / 2.;\n        }\n        XFlux.hfu[i] = fmu * hff;\n\n        if (fabs(hui) &gt; um)\n            um = fabs(hui);\n\n        XFlux.hu[i] = hui* fmu * hff;\n        XFlux.hau[i] = fmu * hff * ax;\n\n        H += hff;\n    }\n\n    if (H &gt; dry) {\n        T c = um / CFL + sqrt(g*H) / CFL_H;//um / CFL + sqrt(g * (hydrostatic ? H : delta * tanh(H / delta))) / CFL_H;\n        if (c &gt; 0.) {\n            dtmax[i] = min(delta / (c * fmu),dtmax[i]);\n            //if (dt &lt; dtmax)\n            //  dtmax = dt;\n        }\n    }\n    //pdt = dt = dtnext(dtmax);\n}\ntemplate __global__ void CalcfaceValX&lt;float&gt;(float pdt, Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxMLP&lt;float&gt; XFlux, float* dtmax, float* zb);\ntemplate __global__ void CalcfaceValX&lt;double&gt;(double pdt, Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxMLP&lt;double&gt; XFlux, double* dtmax, double* zb);\n\ntemplate &lt;class T&gt; __global__ void CalcfaceValY(T pdt, Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux, T* dtmax, T* zb)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps);// +epsi;\n    T dry = eps;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T CFL_H = T(0.5);\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ibot = memloc(halowidth, blkmemwidth, ix, iy-1, ib);\n\n    T zsi = XEv.zs[i];\n\n    T zsn = XEv.zs[ibot];\n\n    T zbi = zb[i];\n    T zbn = zb[ibot];\n\n\n    T fmu = T(1.0);\n    T cm = T(1.0);//T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T gmetric = T(1.0);// (2. * fm.x[i] / (cm[i] + cm[i - 1]));\n\n    T ax = (g * gmetric * (zsn - zsi) / delta);\n\n    T H = 0.;\n    T um = 0.;\n    T Hr = 0.;\n    T Hl = 0.;\n\n\n    //foreach_layer() {\n    {\n        T hi = XEv.h[i];\n        T hn = XEv.h[ibot];\n        Hr += hi;\n        Hl += hn;\n        T hl = hn &gt; dry ? hn : 0.;\n        T hr = hi &gt; dry ? hi : 0.;\n\n\n\n        //XFlux.hu[i] = hl &gt; 0. || hr &gt; 0. ? (hl * XEv.u[ileft] + hr * XEvu[i]) / (hl + hr) : 0.;\n        T hvi = hl &gt; 0. || hr &gt; 0. ? (hl * XEv.v[ibot] + hr * XEv.v[i]) / (hl + hr) : 0.;\n\n        T hff;\n\n        if (Hl &lt;= dry)\n            hff = max(min(zbi + Hr - zbn, hi), 0.);\n        else if (Hr &lt;= dry)\n            hff = max(min(zbn + Hl - zbi, hn), 0.);\n        else\n        {\n            T vn = pdt * (hvi) / delta;//pdt * (hvi + pdt * ax) / delta;\n            T a = signof(vn);\n            int iu = vn &gt; 0.0 ? ibot : i;// -(a + 1.) / 2.;\n            //double dhdx = h.gradient ? h.gradient(h[i - 1], h[i], h[i + 1]) / Delta : (h[i + 1] - h[i - 1]) / (2. * Delta);\n\n            hff = XEv.h[iu] + a * (1. - a * vn) * XGrad.dhdy[iu] * delta / 2.;\n        }\n        XFlux.hfv[i] = fmu * hff;\n\n        if (fabs(hvi) &gt; um)\n            um = fabs(hvi);\n\n        XFlux.hv[i] = hvi* fmu * hff;\n        XFlux.hav[i] = fmu * hff * ax;\n\n        H += hff;\n    }\n\n    if (H &gt; dry) {\n        T c = um / CFL + sqrt(g * H) / CFL_H;//um / CFL + sqrt(g * (hydrostatic ? H : delta * tanh(H / delta))) / CFL_H;\n        if (c &gt; 0.) {\n            dtmax[i] = min(delta / (c * fmu), dtmax[i]);\n            //if (dt &lt; dtmax)\n            //  dtmax = dt;\n        }\n    }\n    //pdt = dt = dtnext(dtmax);\n}\ntemplate __global__ void CalcfaceValY&lt;float&gt;(float pdt, Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxMLP&lt;float&gt; XFlux, float* dtmax, float* zb);\ntemplate __global__ void CalcfaceValY&lt;double&gt;(double pdt, Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxMLP&lt;double&gt; XFlux, double* dtmax, double* zb);\n\n\n\ntemplate &lt;class T&gt; __global__ void CheckadvecMLX(Param XParam, BlockP&lt;T&gt; XBlock,T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps);// +epsi;\n    T dry = eps;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T CFL_H = T(0.5);\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n    //For each layer\n    {\n        T hul = XFlux.hu[i];\n        T hi = XEv.h[i];\n        T hn = XEv.h[ileft];\n\n        T cmn = T(1.0);//cm[-1]\n        T cmi = T(1.0);//cm[]\n\n        if (hul * dt / (delta * cmn) &gt; CFL * hn)\n        {\n            hul = CFL * hn * delta * cmn / dt;\n        }\n        else if (-hul * dt / (delta * cmi) &gt; CFL * hi)\n        {\n            hul = -CFL * hi * delta * cmi / dt;\n        }\n\n        if (hul != XFlux.hu[i])\n        {\n            /*if (l &lt; nl - 1)\n            {\n                hu.x[0, 0, 1] += hu.x[] - hul;\n            }*/\n            XFlux.hu[i] = hul;\n        }\n    }\n\n\n}\ntemplate __global__ void CheckadvecMLX&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float dt, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxMLP&lt;float&gt; XFlux);\ntemplate __global__ void CheckadvecMLX&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double dt, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxMLP&lt;double&gt; XFlux);\n\ntemplate &lt;class T&gt; __global__ void CheckadvecMLY(Param XParam, BlockP&lt;T&gt; XBlock,T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps);// +epsi;\n    T dry = eps;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T CFL_H = T(0.5);\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ibot = memloc(halowidth, blkmemwidth, ix, iy-1, ib);\n\n    //For each layer\n    {\n        T hvl = XFlux.hv[i];\n        T hi = XEv.h[i];\n        T hn = XEv.h[ibot];\n\n        T cmn = T(1.0);//cm[-1]\n        T cmi = T(1.0);//cm[]\n\n        if (hvl * dt / (delta * cmn) &gt; CFL * hn)\n        {\n            hvl = CFL * hn * delta * cmn / dt;\n        }\n        else if (-hvl * dt / (delta * cmi) &gt; CFL * hi)\n        {\n            hvl = -CFL * hi * delta * cmi / dt;\n        }\n\n        if (hvl != XFlux.hv[i])\n        {\n            /*if (l &lt; nl - 1)\n            {\n                hu.x[0, 0, 1] += hu.x[] - hul;\n            }*/\n            XFlux.hv[i] = hvl;\n        }\n    }\n\n\n}\ntemplate __global__ void CheckadvecMLY&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float dt, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxMLP&lt;float&gt; XFlux);\ntemplate __global__ void CheckadvecMLY&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double dt, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxMLP&lt;double&gt; XFlux);\n\n\n\ntemplate &lt;class T&gt; __global__ void AdvecFluxML(Param XParam, BlockP&lt;T&gt; XBlock,T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps);// +epsi;\n    T dry = eps;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n\n    //For each layer\n    {\n        T un = dt * XFlux.hu[i] / ((XFlux.hfu[i] + dry) * delta);\n        //T vn = dt * XFlux.hu[i] / ((XFlux.hfu[i] + dry) * delta);\n        T vn = dt * XFlux.hv[i] / ((XFlux.hfv[i] + dry) * delta);\n\n        T au = signof(un);\n        T av = signof(vn);\n\n        int ixshft = un &gt; 0.0 ? -1: 0;\n        int iyshft = vn &gt; 0.0 ? -1 : 0;\n        //int iu = un &gt;= 0.0 ? ileft : i;//-(a + 1.) / 2.;\n        int iu = memloc(halowidth, blkmemwidth, ix + ixshft, iy, ib);\n\n        int iut, iub;\n\n\n        /*\n        if (ix == 0 &amp;&amp; iy == 15)\n        {\n            iut = memloc(halowidth, blkmemwidth, ix, iy + 1, ib);\n        }\n        else\n        {\n            iut = memloc(halowidth, blkmemwidth, ix + ixshft, iy + 1, ib);\n        }\n        if (ix == 0 &amp;&amp; iy == 0)\n        {\n            iub = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n        }\n        else\n        {\n            iub = memloc(halowidth, blkmemwidth, ix + ixshft, iy - 1, ib);\n        }\n        */\n        iub = memloc(halowidth, blkmemwidth, ix + ixshft, iy - 1, ib);\n        iut = memloc(halowidth, blkmemwidth, ix + ixshft, iy + 1, ib);\n\n\n        int iv = memloc(halowidth, blkmemwidth, ix, iy + iyshft, ib);\n\n        int ivr, ivl;\n        /*\n        if (iy == 0 &amp;&amp; ix == 15)\n        {\n            ivr = memloc(halowidth, blkmemwidth, ix + 1, iy, ib);\n        }\n        else\n        {\n            ivr = memloc(halowidth, blkmemwidth, ix + 1, iy + iyshft, ib);\n        }\n\n        if (iy == 0 &amp;&amp; ix == 0)\n        {\n            ivl = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n        }\n        else\n        {\n            ivl = memloc(halowidth, blkmemwidth, ix - 1, iy+iyshft, ib);\n        }\n        */\n        ivr = memloc(halowidth, blkmemwidth, ix + 1, iy + iyshft, ib);\n        ivl = memloc(halowidth, blkmemwidth, ix - 1, iy + iyshft, ib);\n\n\n        T sux2 = XEv.u[iu] + au * (1. - au * un) * XGrad.dudx[iu] * delta / 2.0;\n        T suy2 = XEv.u[iv] + av * (1. - av * vn) * XGrad.dudy[iv] * delta / 2.0;\n\n        T svy2 = XEv.v[iv] + av * (1. - av * vn) * XGrad.dvdy[iv] * delta / 2.0;\n        T svx2 = XEv.v[iu] + au * (1. - au * un) * XGrad.dvdx[iu] * delta / 2.0;\n        if (XFlux.hfv[iu] + XFlux.hfv[iut] &gt; dry)\n        {\n            T vvn = (XFlux.hv[iu] + XFlux.hv[iut]) / (XFlux.hfv[iu] + XFlux.hfv[iut]);\n            T syy = XGrad.dudy[iu] * delta;// != 0.0 ? XGrad.dudy[iu] :*/ vvn &lt; 0.0 ? XEv.u[iut] - XEv.u[iu] : XEv.u[iu] - XEv.u[iub];\n            T sxx = XGrad.dvdy[iu] * delta;\n            sux2 -= dt * vvn * syy / (2. * delta);\n            svx2 -= dt * vvn * sxx / (2. * delta);\n\n        }\n        if (XFlux.hfu[iv] + XFlux.hfu[ivr] &gt; dry)\n        {\n            T uun = (XFlux.hu[iv] + XFlux.hu[ivr]) / (XFlux.hfu[iv] + XFlux.hfu[ivr]);\n            T syy = XGrad.dvdx[iv] * delta;// != 0.0 ? XGrad.dvdx[iv] : uun &lt; 0.0 ? XEv.v[ivr] - XEv.v[iv] : XEv.v[iv] - XEv.v[ivl];\n            T sxx = XGrad.dudx[iv] * delta;\n            svy2 -= dt * uun * syy / (2. * delta);\n            suy2 -= dt * uun * sxx / (2. * delta);\n            //svx2 -= dt * vvn * syy / (2. * delta);\n            //su2 -= dt * uun * syy / (2. * delta);\n        }\n\n\n\n        XFlux.Fux[i] = sux2 * XFlux.hu[i];\n        XFlux.Fuy[i] = suy2 * XFlux.hv[i];// suy2* XFlux.hv[i];// su2*XFlux.hu[i];\n\n        //XFlux.Fvx[i] = svy2 * XFlux.hv[i];// sv2*XFlux.hv[i];\n        XFlux.Fvx[i] = svx2 * XFlux.hu[i];;// svx2* XFlux.hu[i];// sv2*XFlux.hv[i];\n        XFlux.Fvy[i] = svy2 * XFlux.hv[i];\n        // Confirmed equations\n        //XFlux.Fux[i] = sux2 * XFlux.hu[i];\n\n        //XFlux.Fvy[i] = svy2 * XFlux.hv[i];\n\n\n\n    }\n}\ntemplate __global__ void AdvecFluxML&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float dt, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxMLP&lt;float&gt; XFlux);\ntemplate __global__ void AdvecFluxML&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double dt, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxMLP&lt;double&gt; XFlux);\n\n\ntemplate &lt;class T&gt; __global__ void AdvecEv(Param XParam, BlockP&lt;T&gt; XBlock,T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps);// +epsi;\n    T dry = eps;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T cmu = T(1.0);\n    T cmv = T(1.0);\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n    int iright = memloc(halowidth, blkmemwidth, ix + 1, iy, ib);\n    int itop = memloc(halowidth, blkmemwidth, ix, iy + 1, ib);\n    //For each layer\n    {\n        T uui = XEv.u[i];\n        T vvi = XEv.v[i];\n        T hi = XEv.h[i];\n\n\n\n        uui *= hi;\n        vvi *= hi;\n\n\n        //for debugging\n        //uui += XFlux.Fux[i];\n        //vvi += XFlux.Fvx[i];\n\n\n        //Below is correct\n\n        uui += dt * (XFlux.Fux[i] - XFlux.Fux[iright]) / (delta * cmu);\n        uui += dt * (XFlux.Fuy[i] - XFlux.Fuy[itop]) / (delta * cmv);\n\n        vvi += dt * (XFlux.Fvx[i] - XFlux.Fvx[iright]) / (delta * cmu);\n        vvi += dt * (XFlux.Fvy[i] - XFlux.Fvy[itop]) / (delta * cmv);\n\n\n\n\n\n\n        T h1 = hi;\n        h1 += dt * (XFlux.hu[i] - XFlux.hu[iright]) / (delta * cmu);\n        h1 += dt * (XFlux.hv[i] - XFlux.hv[itop]) / (delta * cmv);\n\n        XEv.h[i] = max(h1, T(0.0));\n\n        if (h1 &lt; dry)\n        {\n            uui = T(0.0);\n            vvi = T(0.0);\n        }\n        else\n        {\n            uui /=  h1;\n            vvi /=  h1;\n        }\n        XEv.u[i] = uui;\n        XEv.v[i] = vvi;\n    }\n\n}\ntemplate __global__ void AdvecEv&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float dt, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxMLP&lt;float&gt; XFlux);\ntemplate __global__ void AdvecEv&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double dt, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxMLP&lt;double&gt; XFlux);\n\n\n\ntemplate &lt;class T&gt; __global__ void pressureML(Param XParam, BlockP&lt;T&gt; XBlock,T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps);// +epsi;\n    T dry = eps;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n    int iright = memloc(halowidth, blkmemwidth, ix + 1, iy, ib);\n    int itop = memloc(halowidth, blkmemwidth, ix, iy + 1, ib);\n\n    T cm = T(1.0);// XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T fmu = T(1.0);\n    T fmv = T(1.0);// XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, ydwn) : T(1.0);\n    T fmup = T(1.0);\n    T fmvp = T(1.0);// XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, yup) : T(1.0);\n\n    T cmdinv, ga;\n\n    cmdinv = T(1.0) / (cm * delta);\n    ga = T(0.5) * g;\n\n    //For each layer\n    {\n\n        T uui = XEv.u[i];\n        T vvi = XEv.v[i];\n        //\n        XFlux.hu[i] += dt * XFlux.hau[i];\n        XFlux.hv[i] += dt * XFlux.hav[i];\n\n        uui += dt * (XFlux.hau[i] + XFlux.hau[iright]) / (XFlux.hfu[i] + XFlux.hfu[iright] + dry);\n        vvi += dt * (XFlux.hav[i] + XFlux.hav[itop]) / (XFlux.hfv[i] + XFlux.hfv[itop] + dry);\n\n        T dmdl = (fmup - fmu) * cmdinv;// absurd if not spherical!\n        T dmdt = (fmvp - fmv) * cmdinv;\n        T fG = vvi * dmdl - uui * dmdt;\n\n        uui += dt * fG * vvi;\n        vvi -= dt * fG * uui;\n\n        XEv.u[i] = uui;\n        XEv.v[i] = vvi;\n    }\n\n\n\n}\ntemplate __global__ void pressureML&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float dt, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxMLP&lt;float&gt; XFlux);\ntemplate __global__ void pressureML&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double dt, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxMLP&lt;double&gt; XFlux);\n\n\n\ntemplate &lt;class T&gt; __global__ void CleanupML(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv,T* zb)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n\n    XEv.zs[i] = zb[i] + max(XEv.h[i], 0.0);\n}\ntemplate __global__ void CleanupML&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, float* zb);\ntemplate __global__ void CleanupML&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, double* zb);\n</code></pre>"},{"location":"BGFlood/Multilayer_8h/","title":"File Multilayer.h","text":""},{"location":"BGFlood/Multilayer_8h/#file-multilayerh","title":"File Multilayer.h","text":"<p>FileList &gt; src &gt; Multilayer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Spherical.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> </ul>"},{"location":"BGFlood/Multilayer_8h/#public-functions","title":"Public Functions","text":"Type Name __global__ void AdvecEv (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  __global__ void AdvecFluxML (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  __global__ void CalcfaceValX (T pdt, Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux, T * dtmax, T * zb)  __global__ void CalcfaceValY (T pdt, Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux, T * dtmax, T * zb)  __global__ void CheckadvecMLX (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  __global__ void CheckadvecMLY (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  __global__ void CleanupML (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void pressureML (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)"},{"location":"BGFlood/Multilayer_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Multilayer_8h/#function-advecev","title":"function AdvecEv","text":"<pre><code>template&lt;class T&gt;\n__global__ void AdvecEv (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8h/#function-advecfluxml","title":"function AdvecFluxML","text":"<pre><code>template&lt;class T&gt;\n__global__ void AdvecFluxML (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8h/#function-calcfacevalx","title":"function CalcfaceValX","text":"<pre><code>template&lt;class T&gt;\n__global__ void CalcfaceValX (\n    T pdt,\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8h/#function-calcfacevaly","title":"function CalcfaceValY","text":"<pre><code>template&lt;class T&gt;\n__global__ void CalcfaceValY (\n    T pdt,\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8h/#function-checkadvecmlx","title":"function CheckadvecMLX","text":"<pre><code>template&lt;class T&gt;\n__global__ void CheckadvecMLX (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8h/#function-checkadvecmly","title":"function CheckadvecMLY","text":"<pre><code>template&lt;class T&gt;\n__global__ void CheckadvecMLY (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8h/#function-cleanupml","title":"function CleanupML","text":"<pre><code>template&lt;class T&gt;\n__global__ void CleanupML (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Multilayer_8h/#function-pressureml","title":"function pressureML","text":"<pre><code>template&lt;class T&gt;\n__global__ void pressureML (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Multilayer.h</code></p>"},{"location":"BGFlood/Multilayer_8h_source/","title":"File Multilayer.h","text":""},{"location":"BGFlood/Multilayer_8h_source/#file-multilayerh","title":"File Multilayer.h","text":"<p>File List &gt; src &gt; Multilayer.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef MULTILAYER_H\n#define MULTILAYER_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"Spherical.h\"\n#include \"Util_CPU.h\"\n\ntemplate &lt;class T&gt; __global__ void CalcfaceValX(T pdt, Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __global__ void CalcfaceValY(T pdt, Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux, T* dtmax, T* zb);\n\ntemplate &lt;class T&gt; __global__ void CheckadvecMLX(Param XParam, BlockP&lt;T&gt; XBlock, T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux);\ntemplate &lt;class T&gt; __global__ void CheckadvecMLY(Param XParam, BlockP&lt;T&gt; XBlock, T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux);\ntemplate &lt;class T&gt; __global__ void AdvecFluxML(Param XParam, BlockP&lt;T&gt; XBlock, T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux);\ntemplate &lt;class T&gt; __global__ void AdvecEv(Param XParam, BlockP&lt;T&gt; XBlock, T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux);\ntemplate &lt;class T&gt; __global__ void pressureML(Param XParam, BlockP&lt;T&gt; XBlock, T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux);\n\ntemplate &lt;class T&gt; __global__ void CleanupML(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Param_8h/","title":"File Param.h","text":""},{"location":"BGFlood/Param_8h/#file-paramh","title":"File Param.h","text":"<p>FileList &gt; src &gt; Param.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Input.h\"</code></li> </ul>"},{"location":"BGFlood/Param_8h/#classes","title":"Classes","text":"Type Name class Param <p>The documentation for this class was generated from the following file <code>src/Param.h</code></p>"},{"location":"BGFlood/Param_8h_source/","title":"File Param.h","text":""},{"location":"BGFlood/Param_8h_source/#file-paramh","title":"File Param.h","text":"<p>File List &gt; src &gt; Param.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef PARAM_H\n#define PARAM_H\n\n#include \"General.h\"\n#include \"Input.h\"\n\nclass Param {\npublic:\n\n    //*General parameters\n    int test = -1; //-1: no test, 99: run all independent tests, X: run test X\n    double g = 9.81; // Acceleration of gravity in m.s-2\n    double rho = 1025.0; // Fluid density in kg.m-3\n    double eps = 0.0001; // Drying height in m (if h&lt;eps, the surface is concidered dry)\n    double dt = 0.0; // Model time step in s.\n    double CFL = 0.5; // Current Freidrich Limiter criterium (between 0 and 1. Higher values may make the model unstable)\n    double theta = 1.3; // Minmod limiter parameter, theta in [1,2]. &lt;br&gt;Can be used to tune the momentum dissipation (theta=1 gives minmod the most dissipative limiter and theta = 2 gives    superbee, the least dissipative).\n    double VelThreshold = -1.0; // Using Velocity threshold if the the velocuity exceeds that threshold. Advice value of 16.0 to use or negative value (-1) to turn off\n    int frictionmodel = 0; // Bottom friction model flag (-1: Manning model, 0: quadratic, 1: Smart roughtness length model)\n    double cf = 0.0001; // Bottom friction coefficient for the model (if constant)\n    double Cd = 0.002; // Wind drag coefficient\n    double il = 0.0; //Initial Loss value (if constant)\n    double cl = 0.0; //Continuous Loss value (if constant)\n    bool windforcing = false; //not working yet\n    bool atmpforcing = false;\n    bool rainforcing = false;\n    bool infiltration = false;\n\n    bool conserveElevation = false; //Switch to force the conservation of zs instead of h at the interface between coarse and fine blocks\n    bool wetdryfix = true; // Switch to remove wet/dry instability (i.e. true reoves instability and false leaves the model as is)\n    bool ForceMassConserve = false; // Switch to enforce mass conservation only useful on steep slope\n\n    double Pa2m = 0.00009916; // Conversion between atmospheric pressure changes to water level changes in Pa (if unit is hPa then user should use 0.009916)\n    double Paref = 101300.0; // Reference pressure in Pa (if unit is hPa then user should use 1013.0)\n    double lat = 0.0; // Model latitude. This is ignored in spherical case\n    int GPUDEVICE = 0; // 0: first available GPU, -1: CPU single core, 2+: other GPU\n\n    int doubleprecision = 0; // 0: float precision, 1: double precision (for the solver and math)\n    bool savebyblk = true;\n\n    int engine = 1; // 1: Buttinger-Kreuzhuber et al. 2019, 2: Kurganov (Popinet 2011), 3: KurganovATMP same as Kurganov but with atmospheric forcing terms \n\n    //*Grid parameters\n    double dx = nan(\"\"); // Grid resolution, in m for a metric grid or in decimal degree for a sperical grid.\n    double delta; // Grid resolution for the model. in Spherical coordinates this is dx * Radius*pi / 180.0\n    int nx = 0; // Initial/input grid size (number of nodes) in x direction\n    int ny = 0; //Initial/input grid size (number of nodes) in y direction\n    int nblk = 0; // Number of compute blocks\n    int blkwidth = 16; //Block width in number of cells\n    int blkmemwidth = 0; // Calculated in sanity check as blkwidth+2*halowidth\n    int blksize = 0; // Calculated in sanity check as blkmemwidth*blkmemwidth\n    int halowidth = 1; // Use a halo around the blocks default is 1 cell: the memory for each blk is 18x18 when blkwidth is 16\n\n\n    double xo = nan(\"\"); // Grid x origin (if not alter by the user, will be defined based on the topography/bathymetry input map)\n    double yo = nan(\"\"); // Grid y origin (if not alter by the user, will be defined based on the topography/bathymetry input map)\n    double ymax = nan(\"\"); // Grid ymax (if not alter by the user, will be defined based on the topography/bathymetry input map)\n    double xmax = nan(\"\"); // Grid xmax (if not alter by the user, will be defined based on the topography/bathymetry input map)\n    double grdalpha = nan(\"\"); // Grid rotation on Y axis from the North input in degrees but later converted to rad\n    int posdown = 0; // Flag for bathy input. Model requirement is positive up  so if posdown ==1 then zb=zb*-1.0f\n    bool spherical = 0; // Flag for sperical coordinate (still in development)\n    double Radius = 6371220.; //Earth radius [m]\n    double mask = 9999.0; //Mask any zb above this value. If the entire Block is masked then it is not allocated in the memory\n\n    //*Adaptation\n    int initlevel = 0; //Initial level of grid adaptation (based on dx if defined by the user or on the resolution of the topography/bathymetry input)\n    int maxlevel = -99999; //Maximum level for grid adaptation (overwrite the adaptation map if use) \n    int minlevel = -99999; //Minumim level for grid adaptation (overwrite the adaptation map if use) \n    int nblkmem = 0;\n    int navailblk = 0;\n    double membuffer = 1.05; //Needs to allocate more memory than initially needed so adaptation can happen without memory reallocation\n\n\n\n    //*Timekeeping\n    //double outputtimeinit = -99999; //Initial time for the output, initialised to initial running time\n    double outputtimestep = 0.0; //Number of seconds between netCDF outputs, 0.0 for none\n    double endtime = std::numeric_limits&lt;double&gt;::max(); // Total runtime in s, will be calculated based on bnd input as min(length of the shortest time series, user defined) and should be shorter than any time-varying forcing\n    double totaltime = 0.0; // Total simulation time in s\n    double inittime = 0.0; // Initital model time. At start of simulation inittime==totaltime\n    double dtinit = -1; // Maximum initial time steps in s (should be positive, advice 0.1 if dry domain initialement) \n    double dtmin = 0.0005; //Minimum accepted time steps in s (a lower value will be concidered a crash of the code, and stop the run)\n    std::string reftime = \"\"; // Reference time string as yyyy-mm-ddTHH:MM:SS\n    std::string crs_ref = \"no_crs\"; //\"PROJCS[\\\"NZGD2000 / New Zealand Transverse Mercator 2000\\\",GEOGCS[\\\"NZGD2000\\\",DATUM[\\\"New_Zealand_Geodetic_Datum_2000\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101]],PRIMEM[\\\"Greenwich\\\",0],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4167\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",173],PARAMETER[\\\"scale_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",1600000],PARAMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1],AXIS[\\\"Northing\\\",NORTH],AXIS[\\\"Easting\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"2193\\\"]]\";\n\n\n    //*Boundaries\n    bool leftbnd = false; // bnd is forced (i.e. not a wall or neuman)\n    bool rightbnd = false; // bnd is forced (i.e. not a wall or neuman)\n    bool topbnd = false; // bnd is forced (i.e. not a wall or neuman)\n    bool botbnd = false; // bnd is forced (i.e. not a wall or neuman)\n\n    int aoibnd = 0; // Boundary type for AOI: 0=wall; 1 neumann; 3 absorbing\n    double bndrelaxtime = 3600.0; // Realxation time for absorbing boundary\n    double bndfiltertime = 60.0; // Filtering time for absorbing boundary\n\n\n    //* Initialisation\n    double zsinit = nan(\"\"); //Init zs for cold start in m. If not specified by user and no bnd file = 1 then sanity check will set it to 0.0\n\n    double zsoffset = nan(\"\"); //Add a water level offset in m to initial conditions and boundaries (0.0 by default)\n\n    std::string hotstartfile;\n    /*Allow to hotstart (or restart) the computation providing a netcdf file containing at least zb, h or zs, u and v\n    Default: None\n    */\n    //std::string deformfile;\n    int hotstep = 0; //Step to read if hotstart file has multiple steps (step and not (computation) time)\n\n\n    double bndtaper = 0.0; // number of second to taper boundary values to smooth transition with initial conditions default is no tapering but 600s is good practice\n    //other\n    clock_t startcputime, endcputime, setupcputime;\n    size_t GPU_initmem_byte, GPU_totalmem_byte;\n\n\n    //*Outputs\n    //std::string Bathymetryfile;// bathymetry file name\n    //inputmap Bathymetry;\n\n    T_output Toutput;\n    /* Flexible time definition for outputs (nc files)\n    Example: \"Toutput = 0.0:3600:7200,7000,7100; which mean every 3600s from 0 to 7200s, and the two times 7000 and 7100\"\n    Default = First and last timne steps*/\n\n    //Timeseries output (save as a vector containing information for each Time Serie output)\n    std::vector&lt;TSoutnode&gt; TSnodesout;\n    /*Time serie output, giving a file name and a (x,y) position\n    (which will be converted to nearest grid position).\n    This keyword can be used multiple times to extract time series at different locations.\n    The data is stocked for each timestep and written by flocs.\n    The resulting file contains (t,zs,h,u,v)\n    Example: \"TSnodesout = Offshore.txt,3101.00,4982.57\" (*filename,x,y*)\n    Default: None\n    */\n\n    std::string outfile = \"Output.nc\"; // Netcdf output file name (if it exists, a number will be happened to the file name to not overwrite it)\n    std::vector&lt;std::string&gt; outvars; \n    /*List of names of the variables to output (for 2D maps)\n    Supported variables = \"zb\", \"zs\", \"u\", \"v\", \"h\", \"hmean\", \"zsmean\", \"umean\", \"vmean\", \"hUmean\", \"Umean\", \"hmax\", \"zsmax\", \"umax\", \"vmax\", \"hUmax\", \"Umax\", \"twet\", \"dhdx\",\"dhdy\",\"dzsdx\",\"dzsdy\",\"dudx\",\"dudy\",\"dvdx\",\"dvdy\",\"Fhu\",\"Fhv\",\"Fqux\",\"Fqvy\",\"Fquy\",\"Fqvx\",\"Su\",\"Sv\",\"dh\",\"dhu\",\"dhv\",\"cf\",\"Patm\", \"datmpdx\",\"datmpdy\",\"il\",\"cl\",\"hgw\";\n    Example: \"outvars = zs,h,u,v,zb,hmax,Umax;\"\n    Default: \"zb\", \"zs\", \"u\", \"v\", \"h\"\n    */\n    double wet_threshold = 0.1; //in m. Limit to consider a cell wet for the twet output (duration of inundation (s))\n\n    std::vector&lt;outzoneP&gt; outzone;\n    /*Zoned output (netcdf file), giving a file name and the position of two corner points\n    (which will be converted to a rectagle containing full blocks).\n    Time vector or values can also be added to specified special outputs for this one in particular.\n    This keyword can be used multiple times to output maps of different areas.\n    Example: \"outzone=zoomed.nc,5.3,5.4,0.5,0.8;\" (*filename,x1,x2,y1,y2*) or \"outzone=zoomed.nc,5.3,5.4,0.5,0.8, 3600:360:7200;\" (*filename,x1,x2,y1,y2, t_init:t_step:t_end*)\n    Default: Full domain\n    */\n\n    int maxTSstorage = 16384; //maximum strorage (nTSnodes*4*nTSsteps) before time series output are flushed to disk [2^14]\n\n\n\n\n    // Output switch controls\n    bool resetmax = false; //Switch to reset the \"max\" outputs after each output (reset if 1, no reset if 0)\n    bool outmax = false;\n    bool outmean = false;\n    //bool outvort = false;\n    bool outtwet = false;\n    //bool outU = false;\n\n    // WARNING FOR DEBUGGING PURPOSE ONLY\n// For debugging one can shift the output by 1 or -1 in the i and j direction.\n// this will save the value in the halo to the output file allowing debugging of values there.\n    int outishift = 0; //DEBUGGING ONLY: allow cell shift (1 or -1) in x direction to visualise the halo around blocks in the output \n    int outjshift = 0; //DEBUGGING ONLY: allow cell shift (1 or -1) in y direction to visualise the halo around blocks in the output \n\n\n    //Rivers\n    //std::vector&lt;River&gt; Rivers; // empty vector to hold river location and discharge time series\n    int nrivers = 0;\n    int nblkriver = 0;\n\n    // length of bnd blk, redundant from XForcing but useful\n    int nbndblkleft = 0;\n    int nbndblkright = 0;\n    int nbndblktop = 0;\n    int nbndblkbot = 0;\n\n    int nmaskblk = 0;\n\n\n\n    //*Netcdf parameters\n    int smallnc = 1; //Short integer conversion for netcdf outputs. 1: save as short integer for the netcdf file, if 0 then save all variables as float\n    float scalefactor = 0.01f; //Scale factor used for the short integer conversion for netcdf outputs. This follow the COARDS convention.\n    float addoffset = 0.0f; //Offset add during the short integer conversion for netcdf outputs (follow the COARDS convention)\n\n#ifdef USE_CATALYST\n        //* ParaView Catalyst parameters (special use with ParaView)\n    int use_catalyst = 0; // Switch to use ParaView Catalyst\n    int catalyst_python_pipeline = 0; //Pipeline to use ParaView Catalyst\n    int vtk_output_frequency = 0; // Output frequency for ParaView Catalyst\n    double vtk_output_time_interval = 1.0; // Output time step for ParaView Catalyst\n    std::string vtk_outputfile_root = \"bg_out\"; //output file name for ParaView Catalyst\n    std::string python_pipeline = \"coproc.py\"; //python pipeline for ParaView Catalyst\n#endif\n\n\n\n\n    // info of the mapped cf\n    //inputmap roughnessmap;\n\n    //forcingmap windU;\n    //forcingmap windV;\n    //forcingmap atmP;\n    //forcingmap Rainongrid;\n\n    // deformation forcing for tsunami generation\n    //std::vector&lt;deformmap&gt; deform;\n    double deformmaxtime = 0.0; // time (s) after which no deformation occurs (internal parameter to cut some of the loops)\n    bool rainbnd = false; // when false it force the rain forcing on the bnd cells to be null.\n\n    // This here should be stored in a structure at a later stage\n\n    std::string AdaptCrit;\n    int* AdaptCrit_funct_pointer;\n\n    std::string Adapt_arg1, Adapt_arg2, Adapt_arg3, Adapt_arg4, Adapt_arg5;\n    int adaptmaxiteration = 20; // Maximum number of iteration for adaptation. default 20\n\n\n\n\n};\n\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Poly_8cu/","title":"File Poly.cu","text":""},{"location":"BGFlood/Poly_8cu/#file-polycu","title":"File Poly.cu","text":"<p>FileList &gt; src &gt; Poly.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Poly.h\"</code></li> </ul>"},{"location":"BGFlood/Poly_8cu/#public-functions","title":"Public Functions","text":"Type Name Polygon CounterCWPoly (Polygon Poly) check polygon handedness and reverse if necessary. bool PolygonIntersect (Polygon P, Polygon Q) Intersection between 2 polygons. bool SegmentIntersect (Polygon P, Polygon Q) Intersection between segments. Vertex VertAdd (Vertex A, Vertex B) Vertex Add. Vertex VertSub (Vertex A, Vertex B) Vertex Substract. bool blockinpoly (T xo, T yo, T dx, int blkwidth, Polygon Poly) check whether a block is inside or intersectin a polygon template bool blockinpoly&lt; double &gt; (double xo, double yo, double dx, int blkwidth, Polygon Poly)  template bool blockinpoly&lt; float &gt; (float xo, float yo, float dx, int blkwidth, Polygon Poly)  int cn_PnPoly (T Px, T Py, F * Vx, F * Vy, int n) cn_PnPoly(): crossing number test for a point in a polygon double dotprod (Vertex A, Vertex B) Vertex dot product. T isLeft (T P0x, T P0y, T P1x, T P1y, T P2x, T P2y) isLeft(): tests if a point is Left|On|Right of an infinite line. bool test_SegmentIntersect () Test segment intersect function. bool test_intersectpoly () Test polygon intersect function. bool test_wninpoly () Test winding number inpoly function. int wn_PnPoly (T Px, T Py, T * Vx, T * Vy, unsigned int n) winding number test for a point in a polygon int wn_PnPoly (T Px, T Py, Polygon Poly) winding number test for a point in a polygon template int wn_PnPoly&lt; double &gt; (double Px, double Py, Polygon Poly)  template int wn_PnPoly&lt; float &gt; (float Px, float Py, Polygon Poly)  double xprod (Vertex A, Vertex B) Vertex cross-product."},{"location":"BGFlood/Poly_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Poly_8cu/#function-countercwpoly","title":"function CounterCWPoly","text":"<p>check polygon handedness and reverse if necessary. </p><pre><code>Polygon CounterCWPoly (\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#description","title":"Description","text":"<p>check polygon handedness and enforce left-handesness (Counter-clockwise). This function is used to ensure the right polygon handedness for the winding number inpoly (using the isleft()) </p>"},{"location":"BGFlood/Poly_8cu/#function-polygonintersect","title":"function PolygonIntersect","text":"<p>Intersection between 2 polygons. </p><pre><code>bool PolygonIntersect (\n    Polygon P,\n    Polygon Q\n) \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#description_1","title":"Description","text":"<p>Check whether 2 polygons intersect. The function checks whether each segment of Polygon P intersect any segment of Poly Q. if an intersect is detected theh loops are broken and true is returned. </p>"},{"location":"BGFlood/Poly_8cu/#function-segmentintersect","title":"function SegmentIntersect","text":"<p>Intersection between segments. </p><pre><code>bool SegmentIntersect (\n    Polygon P,\n    Polygon Q\n) \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#description_2","title":"Description","text":"<p>Check whether 2 polygon segment intersect. Polygon P and Q are only 2 vertex long each. i.e. they represent a segment each.</p>"},{"location":"BGFlood/Poly_8cu/#where-does-this-come-from","title":"Where does this come from:","text":"<p>https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect Best answer from Gareth Rees </p>"},{"location":"BGFlood/Poly_8cu/#function-vertadd","title":"function VertAdd","text":"<p>Vertex Add. </p><pre><code>Vertex VertAdd (\n    Vertex A,\n    Vertex B\n) \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#function-vertsub","title":"function VertSub","text":"<p>Vertex Substract. </p><pre><code>Vertex VertSub (\n    Vertex A,\n    Vertex B\n) \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#function-blockinpoly","title":"function blockinpoly","text":"<p>check whether a block is inside or intersectin a polygon </p><pre><code>template&lt;class T&gt;\nbool blockinpoly (\n    T xo,\n    T yo,\n    T dx,\n    int blkwidth,\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#description_3","title":"Description","text":"<p>Check whether a block is inside or intersectin a polygon</p>"},{"location":"BGFlood/Poly_8cu/#usage-blockinpoly-blockxo-blockyo-blockdx-blkwidth-polygon","title":"Usage blockinpoly( blockxo,  blockyo,  blockdx, blkwidth, Polygon)","text":""},{"location":"BGFlood/Poly_8cu/#function-blockinpoly-double","title":"function blockinpoly&lt; double &gt;","text":"<pre><code>template bool blockinpoly&lt; double &gt; (\n    double xo,\n    double yo,\n    double dx,\n    int blkwidth,\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#function-blockinpoly-float","title":"function blockinpoly&lt; float &gt;","text":"<pre><code>template bool blockinpoly&lt; float &gt; (\n    float xo,\n    float yo,\n    float dx,\n    int blkwidth,\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#function-cn_pnpoly","title":"function cn_PnPoly","text":"<p>cn_PnPoly(): crossing number test for a point in a polygon </p><pre><code>template&lt;class T, class F&gt;\nint cn_PnPoly (\n    T Px,\n    T Py,\n    F * Vx,\n    F * Vy,\n    int n\n) \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#description_4","title":"Description","text":"<p>cn_PnPoly(): crossing number test for a point in a polygon Input: P = a point, V[] = vertex points of a polygon V[n+1] with V[n]=V[0] Return: 0 = outside, 1 = inside</p>"},{"location":"BGFlood/Poly_8cu/#where-does-this-come-from_1","title":"Where does this come from:","text":"<p>Copyright 2000 softSurfer, 2012 Dan Sunday </p>"},{"location":"BGFlood/Poly_8cu/#original-licence","title":"Original Licence","text":"<p>This code may be freely used and modified for any purpose providing that this copyright notice is included with it. SoftSurfer makes no warranty for this code, and cannot be held liable for any real or imagined damage resulting from its use. Users of this code must verify correctness for their application. Code modified to fit the use in DisperGPU</p> <p>This code is patterned after [Franklin, 2000] </p>"},{"location":"BGFlood/Poly_8cu/#function-dotprod","title":"function dotprod","text":"<p>Vertex dot product. </p><pre><code>double dotprod (\n    Vertex A,\n    Vertex B\n) \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#function-isleft","title":"function isLeft","text":"<p>isLeft(): tests if a point is Left|On|Right of an infinite line. </p><pre><code>template&lt;class T&gt;\nT isLeft (\n    T P0x,\n    T P0y,\n    T P1x,\n    T P1y,\n    T P2x,\n    T P2y\n) \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#description_5","title":"Description","text":""},{"location":"BGFlood/Poly_8cu/#a-point-is-defined-by-its-coordinates","title":"a Point is defined by its coordinates","text":"<p>isLeft(): tests if a point is Left|On|Right of an infinite line. Input: three points P0, P1, and P2 Return: &gt;0 for P2 left of the line through P0 and P1 =0 for P2 on the line &lt;0 for P2 right of the line See: Algorithm 1 \"Area of Triangles and Polygons\"</p>"},{"location":"BGFlood/Poly_8cu/#where-does-this-come-from_2","title":"Where does this come from:","text":"<p>Copyright 2000 softSurfer, 2012 Dan Sunday </p>"},{"location":"BGFlood/Poly_8cu/#original-licence_1","title":"Original Licence","text":"<p>This code may be freely used and modified for any purpose providing that this copyright notice is included with it. SoftSurfer makes no warranty for this code, and cannot be held liable for any real or imagined damage resulting from its use. Users of this code must verify correctness for their application. Code modified to fit the use in DisperGPU </p>"},{"location":"BGFlood/Poly_8cu/#function-test_segmentintersect","title":"function test_SegmentIntersect","text":"<p>Test segment intersect function. </p><pre><code>bool test_SegmentIntersect () \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#function-test_intersectpoly","title":"function test_intersectpoly","text":"<p>Test polygon intersect function. </p><pre><code>bool test_intersectpoly () \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#function-test_wninpoly","title":"function test_wninpoly","text":"<p>Test winding number inpoly function. </p><pre><code>bool test_wninpoly () \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#function-wn_pnpoly","title":"function wn_PnPoly","text":"<p>winding number test for a point in a polygon </p><pre><code>template&lt;class T&gt;\nint wn_PnPoly (\n    T Px,\n    T Py,\n    T * Vx,\n    T * Vy,\n    unsigned int n\n) \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#description_6","title":"Description","text":"<p>wn_PnPoly(): winding number test for a point in a polygon Input: P = a point, V[] = vertex points of a polygon V[n+1] with V[n]=V[0] Return: wn = the winding number (=0 only when P is outside)</p>"},{"location":"BGFlood/Poly_8cu/#where-does-this-come-from_3","title":"Where does this come from:","text":"<p>Copyright 2000 softSurfer, 2012 Dan Sunday </p>"},{"location":"BGFlood/Poly_8cu/#original-licence_2","title":"Original Licence","text":"<p>This code may be freely used and modified for any purpose providing that this copyright notice is included with it. SoftSurfer makes no warranty for this code, and cannot be held liable for any real or imagined damage resulting from its use. Users of this code must verify correctness for their application. Code modified to fit the use in DisperGPU </p>"},{"location":"BGFlood/Poly_8cu/#function-wn_pnpoly_1","title":"function wn_PnPoly","text":"<p>winding number test for a point in a polygon </p><pre><code>template&lt;class T&gt;\nint wn_PnPoly (\n    T Px,\n    T Py,\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#description_7","title":"Description","text":"<p>wn_PnPoly(): winding number test for a point in a polygon Input: P = a point, V[] = vertex points of a polygon V[n+1] with V[n]=V[0] Return: wn = the winding number (=0 only when P is outside)</p>"},{"location":"BGFlood/Poly_8cu/#where-does-this-come-from_4","title":"Where does this come from:","text":"<p>Copyright 2000 softSurfer, 2012 Dan Sunday </p>"},{"location":"BGFlood/Poly_8cu/#original-licence_3","title":"Original Licence","text":"<p>This code may be freely used and modified for any purpose providing that this copyright notice is included with it. SoftSurfer makes no warranty for this code, and cannot be held liable for any real or imagined damage resulting from its use. Users of this code must verify correctness for their application. Code modified to fit the use in DisperGPU </p>"},{"location":"BGFlood/Poly_8cu/#function-wn_pnpoly-double","title":"function wn_PnPoly&lt; double &gt;","text":"<pre><code>template int wn_PnPoly&lt; double &gt; (\n    double Px,\n    double Py,\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#function-wn_pnpoly-float","title":"function wn_PnPoly&lt; float &gt;","text":"<pre><code>template int wn_PnPoly&lt; float &gt; (\n    float Px,\n    float Py,\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/Poly_8cu/#function-xprod","title":"function xprod","text":"<p>Vertex cross-product. </p><pre><code>double xprod (\n    Vertex A,\n    Vertex B\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Poly.cu</code></p>"},{"location":"BGFlood/Poly_8cu_source/","title":"File Poly.cu","text":""},{"location":"BGFlood/Poly_8cu_source/#file-polycu","title":"File Poly.cu","text":"<p>File List &gt; src &gt; Poly.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n// This code contains an adaptation of the St Venant equation from Basilisk     //\n// See                                                                          //\n// http://basilisk.fr/src/saint-venant.h and                                    //\n// S. Popinet. Quadtree-adaptive tsunami modelling. Ocean Dynamics,             //\n// doi: 61(9) : 1261 - 1285, 2011                                               //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //\n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n\n#include \"Poly.h\"\n\n\ntemplate &lt;class T&gt; T isLeft(T P0x, T P0y, T P1x, T P1y, T P2x, T P2y)\n{\n    return ((P1x - P0x) * (P2y - P0y)\n        - (P2x - P0x) * (P1y - P0y));\n}\n//===================================================================\n\ntemplate &lt;class T, class F&gt; int cn_PnPoly(T Px, T Py, F* Vx, F* Vy, int n)\n{\n    int    cn = 0;    // the  crossing number counter\n\n    // loop through all edges of the polygon\n    for (int i = 0; i &lt; n; i++) {    // edge from V[i]  to V[i+1]\n        if (((Vy[i] &lt;= Py) &amp;&amp; (Vy[i + 1] &gt; Py))     // an upward crossing\n            || ((Vy[i] &gt; Py) &amp;&amp; (Vy[i + 1] &lt;= Py))) { // a downward crossing\n            // compute  the actual edge-ray intersect x-coordinate\n            T vt = (T)(Py - Vy[i]) / (Vy[i + 1] - Vy[i]);\n            if (Px &lt; Vx[i] + vt * (Vx[i + 1] - Vx[i])) // P.x &lt; intersect\n                ++cn;   // a valid crossing of y=P.y right of P.x\n        }\n    }\n    return (cn &amp; 1);    // 0 if even (out), and 1 if  odd (in)\n\n}\n//===================================================================\n\ntemplate &lt;class T&gt; int wn_PnPoly(T Px, T Py, T* Vx, T* Vy, unsigned int n)\n{\n    int    wn = 0;    // the  winding number counter\n\n    // loop through all edges of the polygon\n    for (int i = 0; i &lt; n; i++) {   // edge from V[i] to  V[i+1]\n        if (Vy[i] &lt;= Py) {          // start y &lt;= P.y\n            if (Vy[i + 1] &gt; Py)      // an upward crossing\n                if (isLeft(Vx[i], Vy[i], Vx[i + 1], Vy[i + 1], Px, Py) &gt; 0)  // P left of  edge\n                    ++wn;            // have  a valid up intersect\n        }\n        else {                        // start y &gt; P.y (no test needed)\n            if (Vy[i + 1] &lt;= Py)     // a downward crossing\n                if (isLeft(Vx[i], Vy[i], Vx[i + 1], Vy[i + 1], Px, Py) &lt; 0)  // P right of  edge\n                    --wn;            // have  a valid down intersect\n        }\n    }\n    return wn;\n}\n\ntemplate &lt;class T&gt; int wn_PnPoly(T Px, T Py, Polygon Poly)\n{\n    int    wn = 0;    // the  winding number counter\n\n    // loop through all edges of the polygon\n    for (int i = 0; i &lt; (Poly.vertices.size() - 1); i++) {   // edge from V[i] to  V[i+1]\n        if (Poly.vertices[i].y &lt;= Py) {          // start y &lt;= P.y\n            if (Poly.vertices[i + 1].y &gt; Py)      // an upward crossing\n                if (isLeft(T(Poly.vertices[i].x), T(Poly.vertices[i].y), T(Poly.vertices[i + 1].x), T(Poly.vertices[i + 1].y), Px, Py) &gt; 0)  // P left of  edge\n                    ++wn;            // have  a valid up intersect\n        }\n        else {                        // start y &gt; P.y (no test needed)\n            if (Poly.vertices[i + 1].y &lt;= Py)     // a downward crossing\n                if (isLeft(T(Poly.vertices[i].x), T(Poly.vertices[i].y), T(Poly.vertices[i + 1].x), T(Poly.vertices[i + 1].y), Px, Py) &lt; 0)  // P right of  edge\n                    --wn;            // have  a valid down intersect\n        }\n    }\n    return wn;\n}\ntemplate int wn_PnPoly&lt;float&gt;(float Px, float Py, Polygon Poly);\ntemplate int wn_PnPoly&lt;double&gt;(double Px, double Py, Polygon Poly);\n//===================================================================\n\n\nPolygon CounterCWPoly(Polygon Poly)\n{\n    double sum = 0.0;\n    Polygon Rev;\n\n\n    for (int i = 0; i &lt; (Poly.vertices.size() - 1); i++)\n    {\n        //\n        sum = sum + (Poly.vertices[i + 1].x - Poly.vertices[i].x) * (Poly.vertices[i + 1].y - Poly.vertices[i].y);\n    }\n\n    std::string res = sum &gt; 0.0 ? \"ClockWise\" : \"CCW\";\n\n    log(\" Polygon is \" + res );\n\n\n    // sum&lt;0.0 -&gt; counterclockwise Polygon; sum&gt;0.0 -&gt; clockwise\n    if (sum &gt; 0.0)\n    {\n        log(\" Reversing Polygon handedness\");\n        for (int i = Poly.vertices.size()-1; i &gt; 0; i--)\n        {\n            //\n\n\n            Rev.vertices.push_back(Poly.vertices[i]);\n        }\n        Rev.vertices.push_back(Rev.vertices[0]);\n\n    }\n    return sum &gt; 0.0 ? Rev : Poly;\n\n}\n\nVertex VertAdd(Vertex A, Vertex B)\n{\n    Vertex v;\n    v.x = A.x + B.x; \n    v.y = A.y + B.y;\n\n    return v;\n}\n\nVertex VertSub(Vertex A, Vertex B)\n{\n    Vertex v;\n    v.x = A.x - B.x;\n    v.y = A.y - B.y;\n\n    return v;\n}\n\ndouble dotprod(Vertex A, Vertex B)\n{\n    double a = 0.0;\n    a = A.x * B.x + A.x + B.y + A.y * B.x + A.y * B.y;\n    return a;\n}\n\ndouble xprod(Vertex A, Vertex B)\n{\n    double a = 0.0;\n    a = A.x*B.y-A.y*B.x;\n    return a;\n}\n\nbool SegmentIntersect(Polygon P, Polygon Q)\n{\n    //\n    Vertex r, s, p, q, qmp;\n    double rxs, qmpxr, eps, t, u;\n    bool intersect = false;\n\n    eps = 1e-9;\n\n    p = P.vertices[0];\n    q = Q.vertices[0];\n    r = VertSub(P.vertices[1], P.vertices[0]);\n    s = VertSub(Q.vertices[1], Q.vertices[0]);\n\n    qmp= VertSub(q, p);\n\n    rxs = xprod(r, s);\n\n    qmpxr = xprod(qmp, r);\n\n\n\n\n    if (abs(rxs) &lt;= eps &amp;&amp; abs(qmpxr) &lt;= eps)\n    {\n        // colinear\n        double t0, t1, rdr, sdr;\n        sdr= dotprod(s, r);\n        rdr = dotprod(r, r);\n\n        t0 = dotprod(qmp, r) / rdr;\n        t1 = t0 + dotprod(s, r) / rdr;\n\n        if (sdr &lt; 0.0)\n        {\n            intersect = (t0 &gt;= 0.0 &amp;&amp; t1 &lt;= 1);\n        }\n        else\n        {\n            intersect = (t1 &gt;= 0.0 &amp;&amp; t0 &lt;= 1);\n        }\n\n\n    }\n    else if (abs(rxs) &lt;= eps &amp;&amp; abs(qmpxr) &gt; eps)\n    {\n        // parallele lines and non intersecting\n        intersect = false;\n    }\n    else if (abs(rxs) &gt; eps)\n    {\n        t = xprod(qmp, s) / rxs;\n        u = qmpxr / rxs;\n\n        if (t &gt;= 0.0 &amp;&amp; t &lt;= 1.0 &amp;&amp; u &lt;= 1.0 &amp;&amp; u &gt;= 0.0)\n        {\n            intersect = true;\n        }\n\n    }\n    else\n    {\n        intersect = false;\n    }\n\n\n    return intersect;\n}\n\nbool PolygonIntersect(Polygon P, Polygon Q)\n{\n    bool intersect=false;\n    for (int i = 0; i &lt; (P.vertices.size() - 1); i++)\n    {\n        for (int j = 0; j &lt; (Q.vertices.size() - 1); j++)\n        {\n            // build segments\n            Polygon Pseg, Qseg;\n            Pseg.vertices = { P.vertices[i], P.vertices[i + 1] };\n            Qseg.vertices = { Q.vertices[j], Q.vertices[j + 1] };\n\n            intersect = SegmentIntersect(Pseg, Qseg);\n\n            if (intersect)\n            {\n                i = (int)P.vertices.size();\n                j = (int)Q.vertices.size();\n                break;\n            }\n\n        }\n\n\n    }\n\n    return intersect;\n\n}\n\ntemplate &lt;class T&gt; bool blockinpoly(T xo, T yo, T dx, int blkwidth, Polygon Poly)\n{\n    bool insidepoly = false;\n\n\n\n\n\n    //bool test = test_wninpoly();\n\n\n\n    //printf(\"wn_inpolytest=%s\\n\", test ? \"true\" : \"false\");\n\n    //test = test_intersectpoly();\n    //printf(\"test_intersectpoly=%s\\n\", test ? \"true\" : \"false\");\n\n    //test = test_SegmentIntersect();\n    //printf(\"test_SegmentIntersect=%s\\n\", test ? \"true\" : \"false\");\n\n    // First check if it isinmside the bounding box\n    insidepoly = OBBdetect(xo, xo + dx * blkwidth, yo, yo + dx * blkwidth, T(Poly.xmin), T(Poly.xmax), T(Poly.ymin), T(Poly.ymax));\n\n    if (insidepoly)\n    {\n        //printf(\"xo=%f, yo=%f, dx=%f, blkwidth=%d\\n\", xo, yo, dx, blkwidth);\n        // being in the bounding box doesn't say much\n\n        // Is there any corner of the block inside the polygon?\n        int wnBL,wnBR,wnTL,wnTR;\n        insidepoly = false;\n\n        wnBL = wn_PnPoly(xo, yo, Poly);\n        wnBR = wn_PnPoly(xo + blkwidth*dx, yo, Poly);\n        wnTL = wn_PnPoly(xo, yo + blkwidth * dx, Poly);\n        wnTR = wn_PnPoly(xo + blkwidth * dx, yo + blkwidth * dx, Poly);\n\n        insidepoly = (wnBL != 0 || wnBR != 0 || wnTL != 0 || wnTR != 0);\n\n        if (!insidepoly)\n        {\n            // maybe a thin arn of the polygon intersect the block\n            Polygon Polyblock;\n            Vertex vxBL, vxBR, vxTL, vxTR;\n            vxBL.x = xo; vxBL.y = yo;\n            vxBR.x = xo + blkwidth * dx; vxBR.y = yo;\n            vxTL.x = xo; vxTL.y = yo + blkwidth * dx;\n            vxTR.x = xo + blkwidth * dx; vxTR.y = yo + blkwidth * dx;\n\n            Polyblock.vertices.push_back(vxBL);\n            Polyblock.vertices.push_back(vxBR);\n            Polyblock.vertices.push_back(vxTR);\n            Polyblock.vertices.push_back(vxTL);\n            Polyblock.vertices.push_back(vxBL);\n\n            insidepoly = PolygonIntersect(Polyblock, Poly);\n        }\n\n    }\n\n    return insidepoly;\n}\ntemplate bool blockinpoly&lt;float&gt;(float xo, float yo, float dx, int blkwidth, Polygon Poly);\ntemplate bool blockinpoly&lt;double&gt;(double xo, double yo, double dx, int blkwidth, Polygon Poly);\n//template &lt;class T&gt; Poly&lt;T&gt; ReadPoly();\n\nbool test_wninpoly()\n{\n    int in, out;\n    bool success = false;\n    Polygon Polyblock;\n    Vertex vxBL, vxBR, vxTL, vxTR;\n    vxBL.x = 0.0; vxBL.y = 0.0;\n    vxBR.x = 1.0; vxBR.y = 0.0;\n    vxTL.x = 0.0; vxTL.y = 1.0;\n    vxTR.x = 1.0; vxTR.y = 1.0;\n\n    Polyblock.vertices.push_back(vxBL);\n    Polyblock.vertices.push_back(vxBR);\n    Polyblock.vertices.push_back(vxTR);\n    Polyblock.vertices.push_back(vxTL);\n    Polyblock.vertices.push_back(vxBL);\n\n    in = wn_PnPoly(0.2, 0.3, Polyblock);\n    out = wn_PnPoly(1.2, 0.3, Polyblock);\n\n    success = (out == 0 &amp;&amp; in != 0);\n    return success;\n}\n\nbool test_SegmentIntersect()\n{\n    bool in, out, success;\n    Vertex a, b, c, d, e, f;\n    Polygon P, Q, R;\n\n    a.x = -1.0; a.y = -1.0;\n    b.x = 1.0; b.y = 1.0;\n\n    c.x = -1.0; c.y = 1.0;\n    d.x = 1.0; d.y = -1.0;\n\n    double eps = 0.0001;\n\n    e.x = a.x + eps; e.y = a.y ;\n    f.x = b.x + eps; f.y = b.y;\n\n    P.vertices.push_back(a);\n    P.vertices.push_back(b);\n\n    Q.vertices.push_back(c);\n    Q.vertices.push_back(d);\n\n    R.vertices.push_back(e);\n    R.vertices.push_back(f);\n\n    in = SegmentIntersect(P, Q);\n    out = SegmentIntersect(P, R);\n    success = (in &amp;&amp; !out);\n    return success;\n}\n\nbool test_intersectpoly()\n{\n    bool success = false;\n    bool in = false;\n    bool out = false;\n    Polygon Polyblock;\n\n    Polygon PolyTriA, PolyTriB;\n    Vertex vxBL, vxBR, vxTL, vxTR, TriA, TriB, TriC;\n    vxBL.x = 0.0; vxBL.y = 0.0;\n    vxBR.x = 1.0; vxBR.y = 0.0;\n    vxTL.x = 0.0; vxTL.y = 1.0;\n    vxTR.x = 1.0; vxTR.y = 1.0;\n\n    Polyblock.vertices.push_back(vxBL);\n    Polyblock.vertices.push_back(vxBR);\n    Polyblock.vertices.push_back(vxTR);\n    Polyblock.vertices.push_back(vxTL);\n    Polyblock.vertices.push_back(vxBL);\n\n    TriA.x = -1.0; TriA.y = 1.0;\n\n    TriB.x = -1.0; TriB.y = -1.0;\n\n    TriC.x = 0.8; TriC.y = -0.8;\n\n    PolyTriA.vertices.push_back(TriA);\n    PolyTriA.vertices.push_back(TriB);\n    PolyTriA.vertices.push_back(TriC);\n    PolyTriA.vertices.push_back(TriA);\n\n    in = PolygonIntersect(Polyblock, PolyTriA);\n\n    TriA.x = -2.0; TriA.y = 1.0;\n\n    TriB.x = -2.0; TriB.y = -1.0;\n\n    TriC.x = -1.8; TriC.y = -0.8;\n\n    PolyTriB.vertices.push_back(TriA);\n    PolyTriB.vertices.push_back(TriB);\n    PolyTriB.vertices.push_back(TriC);\n    PolyTriB.vertices.push_back(TriA);\n\n    out = PolygonIntersect(Polyblock, PolyTriB);\n\n    success = (in &amp;&amp; !out);\n    return success;\n\n}\n</code></pre>"},{"location":"BGFlood/Poly_8h/","title":"File Poly.h","text":""},{"location":"BGFlood/Poly_8h/#file-polyh","title":"File Poly.h","text":"<p>FileList &gt; src &gt; Poly.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Input.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> </ul>"},{"location":"BGFlood/Poly_8h/#public-functions","title":"Public Functions","text":"Type Name Polygon CounterCWPoly (Polygon Poly) check polygon handedness and reverse if necessary. bool blockinpoly (T xo, T yo, T dx, int blkwidth, Polygon Poly) check whether a block is inside or intersectin a polygon int wn_PnPoly (T Px, T Py, Polygon Poly) winding number test for a point in a polygon"},{"location":"BGFlood/Poly_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Poly_8h/#function-countercwpoly","title":"function CounterCWPoly","text":"<p>check polygon handedness and reverse if necessary. </p><pre><code>Polygon CounterCWPoly (\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/Poly_8h/#description","title":"Description","text":"<p>check polygon handedness and enforce left-handesness (Counter-clockwise). This function is used to ensure the right polygon handedness for the winding number inpoly (using the isleft()) </p>"},{"location":"BGFlood/Poly_8h/#function-blockinpoly","title":"function blockinpoly","text":"<p>check whether a block is inside or intersectin a polygon </p><pre><code>template&lt;class T&gt;\nbool blockinpoly (\n    T xo,\n    T yo,\n    T dx,\n    int blkwidth,\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/Poly_8h/#description_1","title":"Description","text":"<p>Check whether a block is inside or intersectin a polygon</p>"},{"location":"BGFlood/Poly_8h/#usage-blockinpoly-blockxo-blockyo-blockdx-blkwidth-polygon","title":"Usage blockinpoly( blockxo,  blockyo,  blockdx, blkwidth, Polygon)","text":""},{"location":"BGFlood/Poly_8h/#function-wn_pnpoly","title":"function wn_PnPoly","text":"<p>winding number test for a point in a polygon </p><pre><code>template&lt;class T&gt;\nint wn_PnPoly (\n    T Px,\n    T Py,\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/Poly_8h/#description_2","title":"Description","text":"<p>wn_PnPoly(): winding number test for a point in a polygon Input: P = a point, V[] = vertex points of a polygon V[n+1] with V[n]=V[0] Return: wn = the winding number (=0 only when P is outside)</p>"},{"location":"BGFlood/Poly_8h/#where-does-this-come-from","title":"Where does this come from:","text":"<p>Copyright 2000 softSurfer, 2012 Dan Sunday </p>"},{"location":"BGFlood/Poly_8h/#original-licence","title":"Original Licence","text":"<p>This code may be freely used and modified for any purpose providing that this copyright notice is included with it. SoftSurfer makes no warranty for this code, and cannot be held liable for any real or imagined damage resulting from its use. Users of this code must verify correctness for their application. Code modified to fit the use in DisperGPU </p> <p>The documentation for this class was generated from the following file <code>src/Poly.h</code></p>"},{"location":"BGFlood/Poly_8h_source/","title":"File Poly.h","text":""},{"location":"BGFlood/Poly_8h_source/#file-polyh","title":"File Poly.h","text":"<p>File List &gt; src &gt; Poly.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef POLY_H\n#define POLY_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Input.h\"\n#include \"Write_txtlog.h\"\n#include \"Util_CPU.h\"\n#include \"Forcing.h\"\n#include \"Arrays.h\"\n#include \"MemManagement.h\"\n\ntemplate &lt;class T&gt; bool blockinpoly(T xo, T yo, T dx, int blkwidth, Polygon Poly);\ntemplate &lt;class T&gt; int wn_PnPoly(T Px, T Py, Polygon Poly);\nPolygon CounterCWPoly(Polygon Poly);\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/","title":"File ReadForcing.cu","text":""},{"location":"BGFlood/ReadForcing_8cu/#file-readforcingcu","title":"File ReadForcing.cu","text":"<p>FileList &gt; src &gt; ReadForcing.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ReadForcing.h\"</code></li> </ul>"},{"location":"BGFlood/ReadForcing_8cu/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; std::string &gt; DelimLine (std::string line, int n, char delim)  std::vector&lt; std::string &gt; DelimLine (std::string line, int n)  void InitDynforcing (bool gpgpu, Param &amp; XParam, DynForcingP&lt; float &gt; &amp; Dforcing)  void clampedges (int nx, int ny, T clamp, T * z)  void denan (int nx, int ny, float denanval, T * z)  void denan (int nx, int ny, float denanval, int * z)  template void denan&lt; double &gt; (int nx, int ny, float denanval, double * z)  template void denan&lt; float &gt; (int nx, int ny, float denanval, float * z)  std::string readCRSfrombathy (std::string crs_ref, StaticForcingP&lt; float &gt; &amp; Sforcing)  void readDynforcing (bool gpgpu, double totaltime, DynForcingP&lt; float &gt; &amp; Dforcing)  std::vector&lt; Flowin &gt; readFlowfile (std::string Flowfilename, std::string &amp; refdate)  std::vector&lt; Windin &gt; readINfileUNI (std::string filename, std::string &amp; refdate)  std::vector&lt; SLTS &gt; readNestfile (std::string ncfile, std::string varname, int hor, double eps, double bndxo, double bndxmax, double bndy)  Polygon readPolygon (std::string filename)  std::vector&lt; SLTS &gt; readWLfile (std::string WLfilename, std::string &amp; refdate)  std::vector&lt; Windin &gt; readWNDfileUNI (std::string filename, std::string &amp; refdate, double grdalpha)  void readXBbathy (std::string filename, int nx, int ny, T *&amp; zb)  template void readXBbathy&lt; float &gt; (std::string filename, int nx, int ny, float *&amp; zb)  template void readXBbathy&lt; int &gt; (std::string filename, int nx, int ny, int *&amp; zb)  void readbathyASCHead (std::string filename, int &amp; nx, int &amp; ny, double &amp; dx, double &amp; xo, double &amp; yo, double &amp; grdalpha)  void readbathyASCzb (std::string filename, int nx, int ny, T *&amp; zb)  template void readbathyASCzb&lt; float &gt; (std::string filename, int nx, int ny, float *&amp; zb)  template void readbathyASCzb&lt; int &gt; (std::string filename, int nx, int ny, int *&amp; zb)  void readbathyHeadMD (std::string filename, int &amp; nx, int &amp; ny, double &amp; dx, double &amp; grdalpha)  void readbathyMD (std::string filename, T *&amp; zb)  template void readbathyMD&lt; float &gt; (std::string filename, float *&amp; zb)  template void readbathyMD&lt; int &gt; (std::string filename, int *&amp; zb)  void readbathydata (int posdown, StaticForcingP&lt; float &gt; &amp; Sforcing)  std::vector&lt; SLTS &gt; readbndfile (std::string filename, Param &amp; XParam)  Polygon readbndpolysegment (bndsegment bnd, Param XParam)  void readforcing (Param &amp; XParam, Forcing&lt; T &gt; &amp; XForcing)  template void readforcing&lt; float &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing)  void readforcingdata (int step, T forcing)  void readforcingdata (double totaltime, DynForcingP&lt; float &gt; &amp; forcing)  template void readforcingdata&lt; StaticForcingP&lt; float &gt; &gt; (int step, StaticForcingP&lt; float &gt; forcing)  template void readforcingdata&lt; StaticForcingP&lt; int &gt; &gt; (int step, StaticForcingP&lt; int &gt; forcing)  template void readforcingdata&lt; deformmap&lt; float &gt; &gt; (int step, deformmap&lt; float &gt; forcing)  DynForcingP&lt; float &gt; readforcinghead (DynForcingP&lt; float &gt; Fmap, Param XParam)  T readforcinghead (T ForcingParam)  template StaticForcingP&lt; float &gt; readforcinghead&lt; StaticForcingP&lt; float &gt; &gt; (StaticForcingP&lt; float &gt; ForcingParam)  template forcingmap readforcinghead&lt; forcingmap &gt; (forcingmap BathyParam)  template inputmap readforcinghead&lt; inputmap &gt; (inputmap BathyParam)  void readstaticforcing (T &amp; Sforcing)  void readstaticforcing (int step, T &amp; Sforcing)  template void readstaticforcing&lt; StaticForcingP&lt; float &gt; &gt; (StaticForcingP&lt; float &gt; &amp; Sforcing)  template void readstaticforcing&lt; StaticForcingP&lt; float &gt; &gt; (int step, StaticForcingP&lt; float &gt; &amp; Sforcing)  template void readstaticforcing&lt; StaticForcingP&lt; int &gt; &gt; (StaticForcingP&lt; int &gt; &amp; Sforcing)  template void readstaticforcing&lt; StaticForcingP&lt; int &gt; &gt; (int step, StaticForcingP&lt; int &gt; &amp; Sforcing)  template void readstaticforcing&lt; deformmap&lt; float &gt; &gt; (deformmap&lt; float &gt; &amp; Sforcing)  template void readstaticforcing&lt; deformmap&lt; float &gt; &gt; (int step, deformmap&lt; float &gt; &amp; Sforcing)"},{"location":"BGFlood/ReadForcing_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/ReadForcing_8cu/#function-delimline","title":"function DelimLine","text":"<pre><code>std::vector&lt; std::string &gt; DelimLine (\n    std::string line,\n    int n,\n    char delim\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-delimline_1","title":"function DelimLine","text":"<pre><code>std::vector&lt; std::string &gt; DelimLine (\n    std::string line,\n    int n\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-initdynforcing","title":"function InitDynforcing","text":"<pre><code>void InitDynforcing (\n    bool gpgpu,\n    Param &amp; XParam,\n    DynForcingP &lt; float &gt; &amp; Dforcing\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-clampedges","title":"function clampedges","text":"<pre><code>template&lt;class T&gt;\nvoid clampedges (\n    int nx,\n    int ny,\n    T clamp,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-denan","title":"function denan","text":"<pre><code>template&lt;class T&gt;\nvoid denan (\n    int nx,\n    int ny,\n    float denanval,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-denan_1","title":"function denan","text":"<pre><code>void denan (\n    int nx,\n    int ny,\n    float denanval,\n    int * z\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-denan-double","title":"function denan&lt; double &gt;","text":"<pre><code>template void denan&lt; double &gt; (\n    int nx,\n    int ny,\n    float denanval,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-denan-float","title":"function denan&lt; float &gt;","text":"<pre><code>template void denan&lt; float &gt; (\n    int nx,\n    int ny,\n    float denanval,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readcrsfrombathy","title":"function readCRSfrombathy","text":"<pre><code>std::string readCRSfrombathy (\n    std::string crs_ref,\n    StaticForcingP &lt; float &gt; &amp; Sforcing\n) \n</code></pre> <p>Reading the CRS information from the bathymetry file (last one read); </p>"},{"location":"BGFlood/ReadForcing_8cu/#function-readdynforcing","title":"function readDynforcing","text":"<pre><code>void readDynforcing (\n    bool gpgpu,\n    double totaltime,\n    DynForcingP &lt; float &gt; &amp; Dforcing\n) \n</code></pre> <p>This is a deprecated function! See InitDynforcing() instead </p>"},{"location":"BGFlood/ReadForcing_8cu/#function-readflowfile","title":"function readFlowfile","text":"<pre><code>std::vector&lt; Flowin &gt; readFlowfile (\n    std::string Flowfilename,\n    std::string &amp; refdate\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readinfileuni","title":"function readINfileUNI","text":"<pre><code>std::vector&lt; Windin &gt; readINfileUNI (\n    std::string filename,\n    std::string &amp; refdate\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readnestfile","title":"function readNestfile","text":"<pre><code>std::vector&lt; SLTS &gt; readNestfile (\n    std::string ncfile,\n    std::string varname,\n    int hor,\n    double eps,\n    double bndxo,\n    double bndxmax,\n    double bndy\n) \n</code></pre> <p>Read boundary Nesting data </p>"},{"location":"BGFlood/ReadForcing_8cu/#function-readpolygon","title":"function readPolygon","text":"<pre><code>Polygon readPolygon (\n    std::string filename\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readwlfile","title":"function readWLfile","text":"<pre><code>std::vector&lt; SLTS &gt; readWLfile (\n    std::string WLfilename,\n    std::string &amp; refdate\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readwndfileuni","title":"function readWNDfileUNI","text":"<pre><code>std::vector&lt; Windin &gt; readWNDfileUNI (\n    std::string filename,\n    std::string &amp; refdate,\n    double grdalpha\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readxbbathy","title":"function readXBbathy","text":"<pre><code>template&lt;class T&gt;\nvoid readXBbathy (\n    std::string filename,\n    int nx,\n    int ny,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readxbbathy-float","title":"function readXBbathy&lt; float &gt;","text":"<pre><code>template void readXBbathy&lt; float &gt; (\n    std::string filename,\n    int nx,\n    int ny,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readxbbathy-int","title":"function readXBbathy&lt; int &gt;","text":"<pre><code>template void readXBbathy&lt; int &gt; (\n    std::string filename,\n    int nx,\n    int ny,\n    int *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readbathyaschead","title":"function readbathyASCHead","text":"<pre><code>void readbathyASCHead (\n    std::string filename,\n    int &amp; nx,\n    int &amp; ny,\n    double &amp; dx,\n    double &amp; xo,\n    double &amp; yo,\n    double &amp; grdalpha\n) \n</code></pre> <p>Read ASC file meta/header data </p>"},{"location":"BGFlood/ReadForcing_8cu/#function-readbathyasczb","title":"function readbathyASCzb","text":"<pre><code>template&lt;class T&gt;\nvoid readbathyASCzb (\n    std::string filename,\n    int nx,\n    int ny,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readbathyasczb-float","title":"function readbathyASCzb&lt; float &gt;","text":"<pre><code>template void readbathyASCzb&lt; float &gt; (\n    std::string filename,\n    int nx,\n    int ny,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readbathyasczb-int","title":"function readbathyASCzb&lt; int &gt;","text":"<pre><code>template void readbathyASCzb&lt; int &gt; (\n    std::string filename,\n    int nx,\n    int ny,\n    int *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readbathyheadmd","title":"function readbathyHeadMD","text":"<pre><code>void readbathyHeadMD (\n    std::string filename,\n    int &amp; nx,\n    int &amp; ny,\n    double &amp; dx,\n    double &amp; grdalpha\n) \n</code></pre> <p>Read MD file header data </p>"},{"location":"BGFlood/ReadForcing_8cu/#function-readbathymd","title":"function readbathyMD","text":"<pre><code>template&lt;class T&gt;\nvoid readbathyMD (\n    std::string filename,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readbathymd-float","title":"function readbathyMD&lt; float &gt;","text":"<pre><code>template void readbathyMD&lt; float &gt; (\n    std::string filename,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readbathymd-int","title":"function readbathyMD&lt; int &gt;","text":"<pre><code>template void readbathyMD&lt; int &gt; (\n    std::string filename,\n    int *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readbathydata","title":"function readbathydata","text":"<pre><code>void readbathydata (\n    int posdown,\n    StaticForcingP &lt; float &gt; &amp; Sforcing\n) \n</code></pre> <p>special case of readstaticforcing(Sforcing); where the data </p>"},{"location":"BGFlood/ReadForcing_8cu/#function-readbndfile","title":"function readbndfile","text":"<pre><code>std::vector&lt; SLTS &gt; readbndfile (\n    std::string filename,\n    Param &amp; XParam\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readbndpolysegment","title":"function readbndpolysegment","text":"<pre><code>Polygon readbndpolysegment (\n    bndsegment bnd,\n    Param XParam\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readforcing","title":"function readforcing","text":"<pre><code>template&lt;class T&gt;\nvoid readforcing (\n    Param &amp; XParam,\n    Forcing &lt; T &gt; &amp; XForcing\n) \n</code></pre> <p>wrapping function for reading all the forcing data </p>"},{"location":"BGFlood/ReadForcing_8cu/#function-readforcing-float","title":"function readforcing&lt; float &gt;","text":"<pre><code>template void readforcing&lt; float &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readforcingdata","title":"function readforcingdata","text":"<pre><code>template&lt;class T&gt;\nvoid readforcingdata (\n    int step,\n    T forcing\n) \n</code></pre> <p>Read static forcing data </p>"},{"location":"BGFlood/ReadForcing_8cu/#function-readforcingdata_1","title":"function readforcingdata","text":"<pre><code>void readforcingdata (\n    double totaltime,\n    DynForcingP &lt; float &gt; &amp; forcing\n) \n</code></pre> <p>Read Dynamic forcing data </p>"},{"location":"BGFlood/ReadForcing_8cu/#function-readforcingdata-staticforcingp-float","title":"function readforcingdata&lt; StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template void readforcingdata&lt; StaticForcingP&lt; float &gt; &gt; (\n    int step,\n    StaticForcingP &lt; float &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readforcingdata-staticforcingp-int","title":"function readforcingdata&lt; StaticForcingP&lt; int &gt; &gt;","text":"<pre><code>template void readforcingdata&lt; StaticForcingP&lt; int &gt; &gt; (\n    int step,\n    StaticForcingP &lt; int &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readforcingdata-deformmap-float","title":"function readforcingdata&lt; deformmap&lt; float &gt; &gt;","text":"<pre><code>template void readforcingdata&lt; deformmap&lt; float &gt; &gt; (\n    int step,\n    deformmap &lt; float &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readforcinghead","title":"function readforcinghead","text":"<pre><code>DynForcingP &lt; float &gt; readforcinghead (\n    DynForcingP &lt; float &gt; Fmap,\n    Param XParam\n) \n</code></pre> <p>Read Dynamic forcing meta/header data </p>"},{"location":"BGFlood/ReadForcing_8cu/#function-readforcinghead_1","title":"function readforcinghead","text":"<pre><code>template&lt;class T&gt;\nT readforcinghead (\n    T ForcingParam\n) \n</code></pre> <p>Read Static forcing meta/header data </p>"},{"location":"BGFlood/ReadForcing_8cu/#function-readforcinghead-staticforcingp-float","title":"function readforcinghead&lt; StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template StaticForcingP &lt; float &gt; readforcinghead&lt; StaticForcingP&lt; float &gt; &gt; (\n    StaticForcingP &lt; float &gt; ForcingParam\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readforcinghead-forcingmap","title":"function readforcinghead&lt; forcingmap &gt;","text":"<pre><code>template forcingmap readforcinghead&lt; forcingmap &gt; (\n    forcingmap BathyParam\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readforcinghead-inputmap","title":"function readforcinghead&lt; inputmap &gt;","text":"<pre><code>template inputmap readforcinghead&lt; inputmap &gt; (\n    inputmap BathyParam\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readstaticforcing","title":"function readstaticforcing","text":"<pre><code>template&lt;class T&gt;\nvoid readstaticforcing (\n    T &amp; Sforcing\n) \n</code></pre> <p>single parameter version of readstaticforcing(int step,T&amp; Sforcing) readstaticforcing(0, Sforcing); </p>"},{"location":"BGFlood/ReadForcing_8cu/#function-readstaticforcing_1","title":"function readstaticforcing","text":"<pre><code>template&lt;class T&gt;\nvoid readstaticforcing (\n    int step,\n    T &amp; Sforcing\n) \n</code></pre> <p>Allocate and read static (i.e. not varying in time) forcing Used for Bathy, roughness, deformation </p>"},{"location":"BGFlood/ReadForcing_8cu/#function-readstaticforcing-staticforcingp-float","title":"function readstaticforcing&lt; StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template void readstaticforcing&lt; StaticForcingP&lt; float &gt; &gt; (\n    StaticForcingP &lt; float &gt; &amp; Sforcing\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readstaticforcing-staticforcingp-float_1","title":"function readstaticforcing&lt; StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template void readstaticforcing&lt; StaticForcingP&lt; float &gt; &gt; (\n    int step,\n    StaticForcingP &lt; float &gt; &amp; Sforcing\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readstaticforcing-staticforcingp-int","title":"function readstaticforcing&lt; StaticForcingP&lt; int &gt; &gt;","text":"<pre><code>template void readstaticforcing&lt; StaticForcingP&lt; int &gt; &gt; (\n    StaticForcingP &lt; int &gt; &amp; Sforcing\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readstaticforcing-staticforcingp-int_1","title":"function readstaticforcing&lt; StaticForcingP&lt; int &gt; &gt;","text":"<pre><code>template void readstaticforcing&lt; StaticForcingP&lt; int &gt; &gt; (\n    int step,\n    StaticForcingP &lt; int &gt; &amp; Sforcing\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readstaticforcing-deformmap-float","title":"function readstaticforcing&lt; deformmap&lt; float &gt; &gt;","text":"<pre><code>template void readstaticforcing&lt; deformmap&lt; float &gt; &gt; (\n    deformmap &lt; float &gt; &amp; Sforcing\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8cu/#function-readstaticforcing-deformmap-float_1","title":"function readstaticforcing&lt; deformmap&lt; float &gt; &gt;","text":"<pre><code>template void readstaticforcing&lt; deformmap&lt; float &gt; &gt; (\n    int step,\n    deformmap &lt; float &gt; &amp; Sforcing\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/ReadForcing.cu</code></p>"},{"location":"BGFlood/ReadForcing_8cu_source/","title":"File ReadForcing.cu","text":""},{"location":"BGFlood/ReadForcing_8cu_source/#file-readforcingcu","title":"File ReadForcing.cu","text":"<p>File List &gt; src &gt; ReadForcing.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //    \n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n\n\n\n#include \"ReadForcing.h\"\n\n\ntemplate &lt;class T&gt;\nvoid readforcing(Param &amp; XParam, Forcing&lt;T&gt; &amp; XForcing)\n{\n    int nt;\n\n    //=================\n    // Read Bathymetry\n    log(\"\\nReading bathymetry grid data...\");\n    for (int ib = 0; ib &lt; XForcing.Bathy.size(); ib++)\n    {\n        readbathydata(XParam.posdown, XForcing.Bathy[ib]);\n\n        if (ib == 0) // Fill Nan for only the first bathy listed, the others will use values from original bathy topo.\n        {\n            denan(XForcing.Bathy[ib].nx, XForcing.Bathy[ib].ny, T(0.0), XForcing.Bathy[ib].val);\n        }\n    }\n\n    if (XForcing.Bathy[0].extension.compare(\"nc\") == 0)\n    {\n        std::string nccrs;\n        //Get_CRS information from last bathymetry file\n        nccrs = readCRSfrombathy(XParam.crs_ref, XForcing.Bathy[XForcing.Bathy.size() - 1]);\n\n        if (!nccrs.empty())\n        {\n            XParam.crs_ref = nccrs;\n        }\n        //XParam.crs_ref = \"test2\";\n    }\n\n    if (isnan(XParam.grdalpha))\n    {\n        XParam.grdalpha=0.0;\n    }\n\n    bool gpgpu = XParam.GPUDEVICE &gt;= 0;\n\n    //=================\n    // Read bnd files\n    log(\"\\nReading boundary data...\");\n\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n        if (XForcing.bndseg[iseg].on)\n        {\n            //XForcing.bndseg[iseg].data = readbndfile(XForcing.bndseg[iseg].inputfile, XParam);\n\n            if (XForcing.bndseg[iseg].uniform == 1)\n            {\n                // grid uniform time varying rain input\n                XForcing.bndseg[iseg].data = readINfileUNI(XForcing.bndseg[iseg].inputfile, XParam.reftime);\n            }\n            else\n            {\n                XForcing.bndseg[iseg].WLmap.denanval = 0.0;\n                InitDynforcing(gpgpu, XParam, XForcing.bndseg[iseg].WLmap);\n                //readDynforcing(gpgpu, XParam.totaltime, XForcing.Rain);\n            }\n        }\n    }\n\n    /*\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n\n    if (!XForcing.left.inputfile.empty())\n    {\n        //XParam.leftbnd.data = readWLfile(XParam.leftbnd.inputfile);\n        XForcing.left.data = readbndfile(XForcing.left.inputfile, XParam, 0);\n\n        XForcing.left.on = true; \n        XForcing.left.nbnd = int(XForcing.left.data[0].wlevs.size());\n\n        if (gpgpu)\n        {\n            AllocateBndTEX(XForcing.left);\n        }\n\n\n    }\n    if (!XForcing.right.inputfile.empty())\n    {\n        XForcing.right.data = readbndfile(XForcing.right.inputfile, XParam, 2);\n        XForcing.right.on = true;\n        XForcing.right.nbnd = int(XForcing.right.data[0].wlevs.size());\n        if (gpgpu)\n        {\n            AllocateBndTEX(XForcing.right);\n        }\n    }\n    if (!XForcing.top.inputfile.empty())\n    {\n        XForcing.top.data = readbndfile(XForcing.top.inputfile, XParam, 3);\n        XForcing.top.on = true;\n        XForcing.top.nbnd = int(XForcing.top.data[0].wlevs.size());\n        if (gpgpu)\n        {\n            AllocateBndTEX(XForcing.top);\n        }\n    }\n    if (!XForcing.bot.inputfile.empty())\n    {\n        XForcing.bot.data = readbndfile(XForcing.bot.inputfile, XParam, 1);\n        XForcing.bot.on = true;\n        XForcing.bot.nbnd = int(XForcing.bot.data[0].wlevs.size());\n        if (gpgpu)\n        {\n            AllocateBndTEX(XForcing.bot);\n        }\n    }\n    */\n\n\n\n    //Check that endtime is no longer than boundaries (if specified to other than wall or neumann)\n    // Removed. This is better done in the sanity check!\n\n    //log(\"...done\");\n\n    //==================\n    // Friction maps \n\n    if (!XForcing.cf.empty())\n    {\n        //denanval = 0.0000001;\n        log(\"\\nRead Roughness map (cf) data...\");\n        // roughness map was specified!\n        //readstaticforcing(XForcing.cf);\n        //log(\"...done\");\n        // Here we are not using the automated denaning because we want to preserve the Nan in all but the \"main/first\" listed roughness map. \n        // This mean that subsequently listed roughness map can have large NAN holes in them.\n        for (int ib = 0; ib &lt; XForcing.cf.size(); ib++)\n        {\n\n            readstaticforcing(XForcing.cf[ib]);\n            if (ib == 0) // Fill Nan for only the first map listed, the others will use values from original bathy topo.\n            {\n                denan(XForcing.cf[ib].nx, XForcing.cf[ib].ny, T(0.0000001), XForcing.cf[ib].val);\n            }\n        }\n    }\n\n\n\n\n\n    //==================\n    // Rain losses maps\n\n    if (!XForcing.il.inputfile.empty())\n    {\n        log(\"\\nRead initial losses map (il) data...\");\n        XForcing.il.denanval = 0.0;\n\n        readstaticforcing(XForcing.il);\n        XParam.infiltration = true;\n    }\n    if (!XForcing.cl.inputfile.empty())\n    {\n        log(\"\\nRead initial losses map (cl) data...\");\n        XForcing.cl.denanval = 0.0;\n        readstaticforcing(XForcing.cl);\n        XParam.infiltration = true;\n    }\n\n    //=====================\n    // Deformation (tsunami generation)\n    if (XForcing.deform.size() &gt; 0)\n    {\n        log(\"\\nRead deform data...\");\n        // Deformation files was specified!\n\n        for (int nd = 0; nd &lt; XForcing.deform.size(); nd++)\n        {\n            XForcing.deform[nd].denanval = 0.0;\n            // read the roughness map header\n            readstaticforcing(XForcing.deform[nd]);\n            //XForcing.deform[nd].grid = readcfmaphead(XForcing.deform[nd].grid);\n\n            //Clamp edges to 0.0\n            clampedges(XForcing.deform[nd].nx, XForcing.deform[nd].ny, 0.0f, XForcing.deform[nd].val);\n\n\n\n            XParam.deformmaxtime = utils::max(XParam.deformmaxtime, XForcing.deform[nd].startime + XForcing.deform[nd].duration);\n\n            AllocateTEX(XForcing.deform[nd].nx, XForcing.deform[nd].ny, XForcing.deform[nd].GPU, XForcing.deform[nd].val);\n\n            // below might seem redundant but it simplifies the \n            // template &lt;class T&gt; __device__ T interpDyn2BUQ(T x, T y, TexSetP Forcing)\n            // function\n            XForcing.deform[nd].GPU.xo = float(XForcing.deform[nd].xo);\n            XForcing.deform[nd].GPU.yo = float(XForcing.deform[nd].yo);\n            XForcing.deform[nd].GPU.uniform = false;\n            XForcing.deform[nd].GPU.dx = float(XForcing.deform[nd].dx);\n            XForcing.deform[nd].GPU.dy = float(XForcing.deform[nd].dy);\n        }\n        //log(\"...done\");\n\n    }\n\n    //=====================\n    // Target level\n    if (XParam.AdaptCrit.compare(\"Targetlevel\") == 0)\n    {\n        log(\"\\nRead Target level data...\");\n        for (int nd = 0; nd &lt; XForcing.targetadapt.size(); nd++)\n        {\n            //\n            readstaticforcing(XForcing.targetadapt[nd]);\n        }\n    }\n\n\n    //======================\n    // Rivers\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        // This part of the code only reads the meta data and data \n        // the full initialisation and detection of river blocks is done in model initialisation\n        log(\"\\nPreparing rivers (\" + std::to_string(XForcing.rivers.size()) + \" rivers)\");\n        for (int Rin = 0; Rin &lt; XForcing.rivers.size(); Rin++)\n        {\n            // Now read the discharge input and store to  \n            XForcing.rivers[Rin].flowinput = readFlowfile(XForcing.rivers[Rin].Riverflowfile, XParam.reftime);\n\n            //Check the time range of the river forcing\n            nt = (int)XForcing.rivers[Rin].flowinput.size();\n            XForcing.rivers[Rin].to = XForcing.rivers[Rin].flowinput[0].time;\n            XForcing.rivers[Rin].tmax = XForcing.rivers[Rin].flowinput[nt-1].time;\n            if ( XForcing.rivers[Rin].tmax &lt; XParam.endtime)\n            {\n                XParam.endtime = XForcing.rivers[Rin].tmax;\n                log(\"\\nWARNING: simulation endtime reduced to \" + std::to_string(XParam.endtime) + \" to fit the time range of the River number \" + std::to_string(Rin));\n            }\n            if (XForcing.rivers[Rin].to &gt; XParam.totaltime)\n            {\n                XParam.totaltime = XForcing.rivers[Rin].to;\n                log(\"\\nWARNING: simulation initial time increased to \" + std::to_string(XParam.totaltime) + \" to fit the time range of the River number \" + std::to_string(Rin));\n            }\n        }\n    }\n\n\n    //======================\n    // Wind file(s)\n    if (!XForcing.UWind.inputfile.empty())\n    {   \n        log(\"\\nPreparing Wind forcing\");\n        // This part of the code only reads the meta data and data for initial step\n        // the full initialisation of the cuda array and texture is done in model initialisation\n        if (XForcing.UWind.uniform == 1)\n        {\n            XForcing.VWind.uniform = true;\n\n            // grid uniform time varying wind input: wlevs[0] is wind speed and wlev[1] is direction\n            XForcing.VWind.inputfile = XForcing.UWind.inputfile;\n            XForcing.UWind.unidata = readWNDfileUNI(XForcing.UWind.inputfile, XParam.reftime, XParam.grdalpha);\n            XForcing.VWind.unidata = readWNDfileUNI(XForcing.VWind.inputfile, XParam.reftime, XParam.grdalpha);\n\n            // this below is a bit ugly but it simplifies the other functions\n            for (int n = 0; n &lt; XForcing.VWind.unidata.size(); n++)\n            {\n                XForcing.VWind.unidata[n].wspeed = XForcing.VWind.unidata[n].vwind;\n            }\n            for (int n = 0; n &lt; XForcing.UWind.unidata.size(); n++)\n            {\n                XForcing.UWind.unidata[n].wspeed = XForcing.UWind.unidata[n].uwind;\n            }\n\n            //Sanity check on the time range of the forcing\n            nt = (int)XForcing.UWind.unidata.size();\n            if (XForcing.UWind.unidata[nt - 1].time &lt; XParam.endtime || XForcing.VWind.unidata[nt - 1].time &lt; XParam.endtime)\n            {\n                XParam.endtime = min(XForcing.UWind.unidata[nt - 1].time, XForcing.VWind.unidata[nt - 1].time);\n                log(\"\\nWARNING: simulation endtime reduced to \" + std::to_string(XParam.endtime) + \" to fit the time range of the wind forcing. \");\n            }\n            if (XForcing.UWind.unidata[0].time &gt; XParam.totaltime || XForcing.VWind.unidata[0].time &gt; XParam.totaltime)\n            {\n                XParam.totaltime = max(XForcing.UWind.unidata[0].time, XForcing.VWind.unidata[0].time);\n                log(\"\\nWARNING: simulation initial time increased to \" + std::to_string(XParam.totaltime) + \" to fit the time range of the wind forcing. \");\n            }\n\n        }\n        else\n        {\n            //\n            //readDynforcing(gpgpu, XParam.totaltime, XForcing.UWind);\n            //readDynforcing(gpgpu, XParam.totaltime, XForcing.VWind);\n\n            XForcing.UWind.denanval = 0.0;\n            XForcing.VWind.denanval = 0.0;\n            InitDynforcing(gpgpu, XParam, XForcing.UWind);\n            InitDynforcing(gpgpu, XParam, XForcing.VWind);\n\n\n\n        }\n\n    }\n\n    //======================\n    // ATM file\n    if (!XForcing.Atmp.inputfile.empty())\n    {\n        log(\"\\nPreparing Atmospheric pressure forcing\");\n        // This part of the code only reads the meta data and data for initial step\n        // the full initialisation of the cuda array and texture is done in model initialisation\n        XForcing.Atmp.uniform = (XForcing.Atmp.extension.compare(\"nc\") == 0) ? 0 : 1;\n        if (XForcing.Atmp.uniform == 1)\n        {\n            // grid uniform time varying atm pressure input is pretty useless...\n            XForcing.Atmp.unidata = readINfileUNI(XForcing.Atmp.inputfile, XParam.reftime);\n        }\n        else\n        {\n            XForcing.Atmp.denanval = XParam.Paref;\n            InitDynforcing(gpgpu, XParam, XForcing.Atmp);\n            // Deflault is zero wich is terrible so change to Paref so limitwaves generated at the edge of forcing\n            // Users should insure there forcing extend well beyond the intended model extent.\n            XForcing.Atmp.clampedge = T(XParam.Paref);\n            //readDynforcing(gpgpu, XParam.totaltime, XForcing.Atmp);\n        }\n    }\n\n    //======================\n    // Rain file\n    if (!XForcing.Rain.inputfile.empty())\n    {\n        log(\"\\nPreparing Rain forcing\");\n        // This part of the code only reads the meta data and data for initial step\n        // the full initialisation of the cuda array and texture is done in model initialisation\n        if (XForcing.Rain.uniform == 1)\n        {\n            // grid uniform time varying rain input\n            XForcing.Rain.unidata = readINfileUNI(XForcing.Rain.inputfile, XParam.reftime);\n        }\n        else\n        {\n            XForcing.Rain.denanval = 0.0;\n            InitDynforcing(gpgpu, XParam, XForcing.Rain);\n            //readDynforcing(gpgpu, XParam.totaltime, XForcing.Rain);\n        }\n    }\n\n    //======================\n    // Polygon data\n    if (!XForcing.AOI.file.empty())\n    {\n        log(\"\\nRead AOI polygon\");\n\n        //Polygon Poly;\n        XForcing.AOI.poly = readPolygon(XForcing.AOI.file);\n\n        // = CounterCWPoly(Poly);\n        //\n\n    }\n\n    //======================\n    // Done\n    //======================\n}\n\ntemplate void readforcing&lt;float&gt;(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing);\n//template void readforcing&lt;double&gt;(Param&amp; XParam, Forcing&lt;double&gt;&amp; XForcing);\n\ntemplate &lt;class T&gt; void readstaticforcing(T&amp; Sforcing)\n{\n    readstaticforcing(0, Sforcing);\n}\n\ntemplate void readstaticforcing&lt;deformmap&lt;float&gt;&gt;(deformmap&lt;float&gt;&amp; Sforcing);\ntemplate void readstaticforcing&lt;StaticForcingP&lt;float&gt;&gt;(StaticForcingP&lt;float&gt;&amp; Sforcing);\ntemplate void readstaticforcing&lt;StaticForcingP&lt;int&gt;&gt;(StaticForcingP&lt;int&gt;&amp; Sforcing);\n\ntemplate &lt;class T&gt; void readstaticforcing(int step,T&amp; Sforcing)\n{\n    Sforcing=readforcinghead(Sforcing);\n\n\n    if (Sforcing.nx &gt; 0 &amp;&amp; Sforcing.ny &gt; 0)\n    {\n        AllocateCPU(Sforcing.nx, Sforcing.ny, Sforcing.val);\n\n        //readvarinfo(Sforcing.inputfile, Sforcing.varname, ddimU)\n        // read the roughness map header\n        //readvardata(0, Sforcing, Sforcing.val);\n        readforcingdata(step,Sforcing);\n        //readvardata(forcing.inputfile, forcing.varname, step, forcing.val);\n\n        denan(Sforcing.nx, Sforcing.ny, float(Sforcing.denanval), Sforcing.val);\n\n    }\n    else\n    {\n        //Error message\n        log(\"Error while reading forcing map file: \" + Sforcing.inputfile);\n    }\n}\ntemplate void readstaticforcing&lt;deformmap&lt;float&gt;&gt;(int step, deformmap&lt;float&gt;&amp; Sforcing);\ntemplate void readstaticforcing&lt;StaticForcingP&lt;float&gt;&gt;(int step, StaticForcingP&lt;float&gt;&amp; Sforcing);\ntemplate void readstaticforcing&lt;StaticForcingP&lt;int&gt;&gt;(int step, StaticForcingP&lt;int&gt;&amp; Sforcing);\n\nvoid InitDynforcing(bool gpgpu,Param&amp; XParam,DynForcingP&lt;float&gt;&amp; Dforcing)\n{\n    Dforcing = readforcinghead(Dforcing, XParam);\n\n    //Sanity check on the time range of the forcing\n    if (Dforcing.tmax &lt; XParam.endtime)\n    {\n        XParam.endtime = Dforcing.tmax;\n        log(\"\\nWARNING: simulation endtime reduced to \" + std::to_string(XParam.endtime) + \" to fit the time range provided in \" + Dforcing.inputfile);\n    }\n    if (Dforcing.to &gt; XParam.totaltime)\n    {\n        XParam.totaltime = Dforcing.to;\n        log(\"\\nWARNING: simulation initial time increased to \" + std::to_string(XParam.totaltime) + \" to fit the time provided in \" + Dforcing.inputfile);\n    }\n\n\n    if (Dforcing.nx &gt; 0 &amp;&amp; Dforcing.ny &gt; 0)\n    {\n        AllocateCPU(Dforcing.nx, Dforcing.ny, Dforcing.now, Dforcing.before, Dforcing.after, Dforcing.val);\n        readforcingdata(XParam.totaltime, Dforcing);\n\n        if (gpgpu)\n        { \n            AllocateGPU(Dforcing.nx, Dforcing.ny, Dforcing.now_g);\n            AllocateGPU(Dforcing.nx, Dforcing.ny, Dforcing.before_g);\n            AllocateGPU(Dforcing.nx, Dforcing.ny, Dforcing.after_g);\n            CopytoGPU(Dforcing.nx, Dforcing.ny, Dforcing.now, Dforcing.now_g);\n            CopytoGPU(Dforcing.nx, Dforcing.ny, Dforcing.before, Dforcing.before_g);\n            CopytoGPU(Dforcing.nx, Dforcing.ny, Dforcing.after, Dforcing.after_g);\n\n            // Allocate and bind textures\n            AllocateTEX(Dforcing.nx, Dforcing.ny, Dforcing.GPU, Dforcing.now);\n\n            // below might seem redundant but it simplifies the \n            // template &lt;class T&gt; __device__ T interpDyn2BUQ(T x, T y, TexSetP Forcing)\n            // function\n            Dforcing.GPU.xo = float(Dforcing.xo);\n            Dforcing.GPU.yo = float(Dforcing.yo);\n            Dforcing.GPU.uniform = Dforcing.uniform;\n            Dforcing.GPU.dx = float(Dforcing.dx);\n            Dforcing.GPU.dy = float(Dforcing.dy);\n        }\n\n    }\n    else\n    {\n        //Error message\n        log(\"Error while reading forcing map file: \" + Dforcing.inputfile);\n    }\n}\n\n\nvoid readDynforcing(bool gpgpu, double totaltime, DynForcingP&lt;float&gt;&amp; Dforcing)\n{\n    Dforcing = readforcinghead(Dforcing);\n\n\n    if (Dforcing.nx &gt; 0 &amp;&amp; Dforcing.ny &gt; 0)\n    {\n        AllocateCPU(Dforcing.nx, Dforcing.ny, Dforcing.now, Dforcing.before, Dforcing.after, Dforcing.val);\n        //\n        readforcingdata(totaltime, Dforcing);\n        if (gpgpu)\n        {\n            // Allocate and bind textures\n            AllocateTEX(Dforcing.nx, Dforcing.ny, Dforcing.GPU, Dforcing.now);\n        }\n\n    }\n    else\n    {\n        //Error message\n        log(\"Error while reading forcing map file: \" + Dforcing.inputfile);\n    }\n}\n\n\nvoid readbathydata(int posdown, StaticForcingP&lt;float&gt; &amp;Sforcing)\n{\n    readstaticforcing(Sforcing);\n\n    if (posdown == 1)\n    {\n\n        log(\"Bathy data is positive down...correcting\");\n        for (int j = 0; j &lt; Sforcing.ny; j++)\n        {\n            for (int i = 0; i &lt; Sforcing.nx; i++)\n            {\n                Sforcing.val[i + j * Sforcing.nx] = Sforcing.val[i + j * Sforcing.nx] * -1.0f;\n                //printf(\"%f\\n\", zb[i + (j)*nx]);\n\n            }\n        }\n    }\n}\n\nstd::string readCRSfrombathy(std::string crs_ref, StaticForcingP&lt;float&gt;&amp; Sforcing)\n{\n    int ncid, ncvarid, ncAttid, status;\n    size_t t_len;\n    char* crs;\n    char* crs_wkt;\n    std::string crs_ref2;\n\n    crs_wkt = \"\";\n\n    if (!Sforcing.inputfile.empty())\n    {\n\n        log(\"Reading CRS information from forcing metadata (file: \" + Sforcing.inputfile + \")\");\n\n\n        /* Open the netCDF file */\n        status = nc_open(Sforcing.inputfile.c_str(), NC_NOWRITE, &amp;ncid);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        /* Get variable ID */\n        status = nc_inq_varid(ncid, Sforcing.varname.c_str(), &amp;ncvarid);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        /* Get the attribute ID */\n        status = nc_inq_attid(ncid, ncvarid, \"grid_mapping\", &amp;ncAttid);\n        if (status == NC_NOERR)\n        {\n\n\n\n\n            /* Read CRS attribute from the variable */\n            status = nc_inq_attlen(ncid, ncvarid, \"grid_mapping\", &amp;t_len);\n            if (status != NC_NOERR) handle_ncerror(status);\n\n            crs = (char*)malloc(t_len + 1);\n\n            crs[t_len] = '\\0';\n\n            /* Read CRS attribute from the variable */\n            status = nc_get_att_text(ncid, ncvarid, \"grid_mapping\", crs);\n            if (status != NC_NOERR) handle_ncerror(status);\n\n            printf(\"grid info detected: %s\\n\", crs);\n\n\n            /*Get associated CRS variable ID*/\n            status = nc_inq_varid(ncid, crs, &amp;ncvarid);\n            if (status != NC_NOERR) handle_ncerror(status);\n\n            std::vector&lt;std::string&gt; attnamevec = { \"crs_wkt\",\"spatial_ref\" };\n\n            int idatt = -1;\n\n            for (int id = 0; id &lt; attnamevec.size(); id++)\n            {\n                /* Get the attribute ID */\n                status = nc_inq_attid(ncid, ncvarid, attnamevec[id].c_str(), &amp;ncAttid);\n                if (status == NC_NOERR)\n                {\n                    idatt = id;\n                    break;\n                }\n            }\n\n            if (idatt &gt; -1)\n            {\n\n                /* Get the attribute ID */\n                status = nc_inq_attid(ncid, ncvarid, attnamevec[idatt].c_str(), &amp;ncAttid);\n                if (status != NC_NOERR) handle_ncerror(status);\n\n\n                /* Read CRS attribute from the variable */\n                status = nc_inq_attlen(ncid, ncvarid, attnamevec[idatt].c_str(), &amp;t_len);\n                if (status != NC_NOERR) handle_ncerror(status);\n\n                crs_wkt = (char*)malloc(t_len + 1);\n                crs_wkt[t_len] = '\\0';\n\n                /* Read CRS attribute from the variable */\n                status = nc_get_att_text(ncid, ncvarid, attnamevec[idatt].c_str(), crs_wkt);\n                if (status != NC_NOERR) handle_ncerror(status);\n\n                printf(\"CRS_info: %s\\n\", crs_wkt);\n\n                //crs_ref = crs_wkt;\n                //crs_ref2 = crs_wkt;\n\n                //printf(\"CRS_info: %s\\n\", crs_ref2.c_str());\n            }\n            else\n            {\n                printf(\"CRS_info detected but not understood reverting to default CRS\\n Rename attribute in grid-mapping variable\\n\");\n\n                //crs_wkt = \"\"; //Move to the top of the file for initialisation\n            }\n\n        }\n        status = nc_close(ncid);\n        /* Close the netCDF file */\n        if ( status != NC_NOERR) {\n            fprintf(stderr, \"Error: Failed to close file.\\n\");\n        }\n    }\n    return crs_wkt;\n}\n\nPolygon readbndpolysegment(bndsegment bnd, Param XParam)\n{\n    Polygon bndpoly;\n    Vertex va,vb,vc,vd;\n    double epsbnd = calcres(XParam.dx,XParam.initlevel);\n    double xo = XParam.xo;\n    double xmax = XParam.xmax;\n    double yo = XParam.yo;\n    double ymax = XParam.ymax;\n\n\n    if (case_insensitive_compare(bnd.polyfile, \"all\") == 0)\n    {\n        va.x = xo - epsbnd; va.y = yo - epsbnd;\n        vb.x = xmax + epsbnd; vb.y = yo - epsbnd;\n        vc.x = xmax + epsbnd; vc.y = ymax + epsbnd;\n        vd.x = xo - epsbnd; vd.y = ymax + epsbnd;\n\n        bndpoly.vertices.push_back(va);\n        bndpoly.vertices.push_back(vb);\n        bndpoly.vertices.push_back(vc);\n        bndpoly.vertices.push_back(vd);\n        bndpoly.vertices.push_back(va);\n        bndpoly.xmin = va.x;\n        bndpoly.xmax = vb.x;\n        bndpoly.ymin = va.y;\n        bndpoly.ymax = vd.y;\n    }\n    else if (case_insensitive_compare(bnd.polyfile, \"file\") == 0)\n    {\n        if (bnd.WLmap.uniform == 1)\n        {\n\n            log(\"Warning: 'file' keyword used for uniform boundary, using 'all' instead\");\n\n            va.x = xo - epsbnd; va.y = yo - epsbnd;\n            vb.x = xmax + epsbnd; vb.y = yo - epsbnd;\n            vc.x = xmax + epsbnd; vc.y = ymax + epsbnd;\n            vd.x = xo - epsbnd; vd.y = ymax + epsbnd;\n\n            bndpoly.vertices.push_back(va);\n            bndpoly.vertices.push_back(vb);\n            bndpoly.vertices.push_back(vc);\n            bndpoly.vertices.push_back(vd);\n            bndpoly.vertices.push_back(va);\n            bndpoly.xmin = va.x;\n            bndpoly.xmax = vb.x;\n            bndpoly.ymin = va.y;\n            bndpoly.ymax = vd.y;\n        }\n        else\n        {\n            DynForcingP&lt;float&gt; Df = readforcinghead(bnd.WLmap, XParam);\n\n\n\n\n            va.x = Df.xo - epsbnd; va.y = Df.yo - epsbnd;\n            vb.x = Df.xmax + epsbnd; vb.y = Df.yo - epsbnd;\n            vc.x = Df.xmax + epsbnd; vc.y = Df.ymax + epsbnd;\n            vd.x = Df.xo - epsbnd; vd.y = Df.ymax + epsbnd;\n\n            bndpoly.vertices.push_back(va);\n            bndpoly.vertices.push_back(vb);\n            bndpoly.vertices.push_back(vc);\n            bndpoly.vertices.push_back(vd);\n            bndpoly.vertices.push_back(va);\n            bndpoly.xmin = va.x;\n            bndpoly.xmax = vb.x;\n            bndpoly.ymin = va.y;\n            bndpoly.ymax = vd.y;\n\n        }\n\n    }\n    else if (case_insensitive_compare(bnd.polyfile,\"left\")==0)\n    {\n        va.x = xo - epsbnd; va.y = yo;\n        vb.x = xo + epsbnd; vb.y = yo;\n        vc.x = xo + epsbnd; vc.y = ymax;\n        vd.x = xo - epsbnd; vd.y = ymax;\n\n        bndpoly.vertices.push_back(va);\n        bndpoly.vertices.push_back(vb);\n        bndpoly.vertices.push_back(vc);\n        bndpoly.vertices.push_back(vd);\n        bndpoly.vertices.push_back(va);\n        bndpoly.xmin = xo - epsbnd;\n        bndpoly.xmax = xo + epsbnd;\n        bndpoly.ymin = yo;\n        bndpoly.ymax = ymax;\n\n    }\n    else if (case_insensitive_compare(bnd.polyfile, \"bot\") == 0)\n    {\n        va.x = xo ; va.y = yo - epsbnd;\n        vb.x = xmax; vb.y = yo - epsbnd;\n        vc.x = xmax; vc.y = yo + epsbnd;\n        vd.x = xo; vd.y = yo + epsbnd;\n\n        bndpoly.vertices.push_back(va);\n        bndpoly.vertices.push_back(vb);\n        bndpoly.vertices.push_back(vc);\n        bndpoly.vertices.push_back(vd);\n        bndpoly.vertices.push_back(va);\n        bndpoly.xmin = xo ;\n        bndpoly.xmax = xmax;\n        bndpoly.ymin = yo - epsbnd;\n        bndpoly.ymax = yo + epsbnd;\n    }\n    else if (case_insensitive_compare(bnd.polyfile, \"right\") == 0)\n    {\n        va.x = xmax - epsbnd; va.y = yo;\n        vb.x = xmax + epsbnd; vb.y = yo;\n        vc.x = xmax + epsbnd; vc.y = ymax;\n        vd.x = xmax - epsbnd; vd.y = ymax;\n\n        bndpoly.vertices.push_back(va);\n        bndpoly.vertices.push_back(vb);\n        bndpoly.vertices.push_back(vc);\n        bndpoly.vertices.push_back(vd);\n        bndpoly.vertices.push_back(va);\n        bndpoly.xmin = xmax - epsbnd;\n        bndpoly.xmax = xmax + epsbnd;\n        bndpoly.ymin = yo;\n        bndpoly.ymax = ymax;\n\n    }\n    else if (case_insensitive_compare(bnd.polyfile, \"top\") == 0)\n    {\n\n        va.x = xo; va.y = ymax - epsbnd;\n        vb.x = xmax; vb.y = ymax - epsbnd;\n        vc.x = xmax; vc.y = ymax + epsbnd;\n        vd.x = xo; vd.y = ymax + epsbnd;\n\n        bndpoly.vertices.push_back(va);\n        bndpoly.vertices.push_back(vb);\n        bndpoly.vertices.push_back(vc);\n        bndpoly.vertices.push_back(vd);\n        bndpoly.vertices.push_back(va);\n        bndpoly.xmin = xo;\n        bndpoly.xmax = xmax;\n        bndpoly.ymin = ymax - epsbnd;\n        bndpoly.ymax = ymax + epsbnd;\n    }\n    else\n    {\n        bndpoly = readPolygon(bnd.polyfile);\n    }\n\n    return bndpoly;\n}\n\nstd::vector&lt;SLTS&gt; readbndfile(std::string filename,Param &amp; XParam)\n{\n    // read bnd or nest file\n    // side is for deciding whether we are talking about a left(side=0) bot (side =1) right (side=2) or top (side=3)\n    // Warning just made this up and need to have some sort of convention in the model\n    std::string fileext;\n    std::vector&lt;std::string&gt; extvec = split(filename, '.');\n\n    std::vector&lt;std::string&gt; nameelements;\n\n    std::vector&lt;SLTS&gt; Bndinfo;\n\n    //\n    //printf(\"%d\\n\", side);\n    /*\n    double xxmax;\n    int hor;\n    switch (side)\n    {\n        case 0://Left bnd\n        {\n            //xxo = XParam.yo;\n            xxmax = XParam.ymax;\n            //yy = XParam.xo;\n            hor = 0;\n            break;\n        }\n        case 1://Bot bnd\n        {\n            //xxo = XParam.xo;\n            xxmax = XParam.xmax;\n            //yy = XParam.yo;\n            hor = 1;\n            break;\n        }\n        case 2://Right bnd\n        {\n            //xxo = XParam.yo;\n            xxmax = XParam.ymax;\n            //yy = XParam.xmax;\n            hor = 0;\n            break;\n        }\n        case 3://Top bnd\n        {\n            //xxo = XParam.xo;\n            xxmax = XParam.xmax;\n            //yy = XParam.ymax;\n            hor = 1;\n            break;\n        }\n    }\n    */\n\n    //printf(\"%f\\t%f\\t%f\\n\", xxo, xxmax, yy);\n\n    nameelements = split(extvec.back(), '?');\n    if (nameelements.size() &gt; 1)\n    {\n\n        fileext = nameelements[0];\n    }\n    else\n    {\n        fileext = extvec.back();\n    }\n\n    if (fileext.compare(\"nc\") == 0)\n    {\n        //Bndinfo = readNestfile(filename);\n        //Bndinfo = readNestfile(filename, hor, XParam.eps, xxo, xxmax, yy);\n    }\n    else\n    {\n        Bndinfo = readWLfile(filename,XParam.reftime);\n    }\n\n    // Add zsoffset\n    for (int i = 0; i &lt; Bndinfo.size(); i++)\n    {\n        for (int n = 0; n &lt; Bndinfo[i].wlevs.size(); n++)\n        {\n            double addoffset = std::isnan(XParam.zsoffset) ? 0.0 : XParam.zsoffset;\n            Bndinfo[i].wlevs[n] = Bndinfo[i].wlevs[n] + addoffset;\n        }\n    }\n\n\n    return Bndinfo;\n}\n\n\nstd::vector&lt;SLTS&gt; readWLfile(std::string WLfilename, std::string &amp; refdate)\n{\n    std::vector&lt;SLTS&gt; slbnd;\n\n    std::ifstream fs(WLfilename);\n\n    if (fs.fail()) {\n        //std::cerr &lt;&lt; WLfilename &lt;&lt; \" Water level bnd file could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: Water level bnd file could not be opened : \" + WLfilename);\n        exit(1);\n    }\n\n    std::string line;\n    std::vector&lt;std::string&gt; lineelements;\n    std::vector&lt;double&gt; WLS;\n    SLTS slbndline;\n    while (std::getline(fs, line))\n    {\n        //std::cout &lt;&lt; line &lt;&lt; std::endl;\n\n        // skip empty lines and lines starting with #\n        if (!line.empty() &amp;&amp; line.substr(0, 1).compare(\"#\") != 0)\n        {\n            //Data should be in the format : time,Water level 1,Water level 2,...Water level n\n            //Location where the water level is 0:ny/(nwl-1):ny where nwl i the number of wlevnodes\n\n            //by default we expect tab delimitation\n            lineelements = split(line, '\\t');\n            if (lineelements.size() &lt; 2)\n            {\n                // Is it space delimited?\n                lineelements.clear();\n                lineelements = split(line, ' ');\n            }\n\n            if (lineelements.size() &lt; 2)\n            {\n                //Well it has to be comma delimited then\n                lineelements.clear();\n                lineelements = split(line, ',');\n            }\n            if (lineelements.size() &lt; 2)\n            {\n                // Giving up now! Could not read the files\n                //issue a warning and exit\n                //std::cerr &lt;&lt; WLfilename &lt;&lt; \"ERROR Water level bnd file format error. only \" &lt;&lt; lineelements.size() &lt;&lt; \" where at least 2 were expected. Exiting.\" &lt;&lt; std::endl;\n                log(\"ERROR:  Water level bnd file (\" + WLfilename + \") format error. only \" + std::to_string(lineelements.size()) + \" where at least 2 were expected. Exiting.\");\n                log(line);\n                exit(1);\n            }\n\n\n            //slbndline.time = std::stod(lineelements[0]);\n            slbndline.time = readinputtimetxt(lineelements[0], refdate);\n\n            for (int n = 1; n &lt; lineelements.size(); n++)\n            {\n                WLS.push_back(std::stod(lineelements[n]));\n            }\n\n\n\n            slbndline.wlevs = WLS;\n\n\n\n            //slbndline = readBSHline(line);\n            slbnd.push_back(slbndline);\n            //std::cout &lt;&lt; line &lt;&lt; std::endl;\n            WLS.clear();\n        }\n\n    }\n    fs.close();\n\n    //std::cout &lt;&lt; slbnd[0].wlev &lt;&lt; std::endl;\n\n\n    return slbnd;\n}\n\n\nstd::vector&lt;SLTS&gt; readNestfile(std::string ncfile,std::string varname, int hor ,double eps, double bndxo, double bndxmax, double bndy)\n{\n    // Prep boundary input vector from anorthe model output file\n    //this function works for botom top bnd as written but flips x and y for left and right bnds\n    // hor controls wheter the boundary is a top/botom bnd hor=1 or left/right hor=0 \n    std::vector&lt;SLTS&gt; slbnd;\n    SLTS slbndline;\n\n    std::vector&lt;double&gt; WLS,Unest,Vnest;\n    //Define NC file variables\n    int nnx, nny, nt, nbndpts, indxx, indyy, indx, indy,nx, ny;\n    double dx, dy, xxo, yyo, tmax,xo,yo;\n    double * ttt, *zsa;\n    bool checkhh = false;\n    int iswet;\n    bool flipx = false;\n    bool flipy = false;\n\n\n    // Read NC info // \n    //readgridncsize(ncfile,varname, nnx, nny, nt, dx, xxo, yyo, to, xmax, ymax, tmax, flipx, flipy);\n\n\n    if (hor == 0)\n    {\n        nx = nny;\n        ny = nnx;\n        xo = yyo;\n        yo = xxo;\n\n    }\n    else\n    {\n        nx = nnx;\n        ny = nny;\n        xo = xxo;\n        yo = yyo;\n    }\n\n    // Read time vector\n    ttt=(double *)malloc(nt*sizeof(double));\n    zsa = (double *)malloc(1*sizeof(double));\n    readnctime(ncfile, ttt);\n\n\n\n\n    nbndpts = (int)((bndxmax - bndxo) / dx)+1;\n\n    //printf(\"%f\\t%f\\t%f\\t%f\\n\", bndxmax, bndxo, xo, yo);\n    //printf(\"%f\\t%f\\t%f\\t%f\\n\", bndxmax, bndxo, xxo, yyo);\n    //printf(\"%f\\t%d\\t%d\\t%f\\n\", bndy, nx, ny, dx);\n\n    //printf(\"%d\\n\", nbndpts);\n    std::string ncfilestr;\n    std::string varstr,varstruu,varstrvv;\n\n\n    //char ncfile[]=\"ocean_ausnwsrstwq2.nc\";\n    std::vector&lt;std::string&gt; nameelements;\n    nameelements = split(ncfile, '?');\n    if (nameelements.size() &gt; 1)\n    {\n\n        ncfilestr = nameelements[0];\n        varstr = nameelements[1];\n    }\n    else\n    {\n\n        ncfilestr = ncfile;\n        varstr = \"zs\";\n        checkhh = true;\n    }\n\n\n    for (int it = 0; it &lt; nt; it++)\n    {\n        slbndline.time = ttt[it];\n        for (int ibnd = 0; ibnd &lt; nbndpts; ibnd++)\n        {\n            //\n            // Read// interpolate data for each bnds\n            indxx = utils::max(utils::min((int)((bndxo+(dx*ibnd) - xo) / dx), nx - 1), 0);\n            indyy = utils::max(utils::min((int)((bndy - yo) / dx), ny - 1), 0);\n\n            if (hor == 0)\n            {\n                indy = indxx;\n                indx = indyy;\n            }\n            else\n            {\n                indx = indxx;\n                indy = indyy;\n            }\n\n            iswet=readncslev1(ncfile, varstr, indx, indy, it, checkhh,eps, zsa);\n            //varstr\n            //printf(\"%d\\t%d\\t%d\\tzs=%f\\t%d\\n\", it,indx, indy, zsa[0],iswet);\n\n            if (iswet == 0)\n            {\n                if (WLS.size() &gt;= 1)\n                {\n                    zsa[0] = WLS.back();\n                }\n                else\n                {\n                    zsa[0] = 0.0;\n                }\n            }\n\n            WLS.push_back(zsa[0]);\n\n            printf(\"zs=%f\\\\n\", zsa[0]);\n\n            // If true nesting then uu and vv are expected to be present in the netcdf file \n\n            if (checkhh)\n            {\n                varstruu = \"uu\";\n                iswet = readncslev1(ncfilestr, varstruu, indx, indy, it, checkhh, eps, zsa);\n                //printf(\"%d\\t%d\\t%d\\tuu=%f\\t%d\\n\", it, indx, indy, zsa[0], iswet);\n                //printf(\"%d\\t%d\\t%f\\n\", indx, indy, zsa[0]);\n\n                if (iswet == 0)\n                {\n\n                    if (Unest.size() &gt;= 1)\n                    {\n                        zsa[0] = Unest.back();\n                    }\n                    else\n                    {\n                        zsa[0] = 0.0;\n                    }\n                }\n\n                Unest.push_back(zsa[0]);\n\n                varstrvv = \"vv\";\n                iswet = readncslev1(ncfile, varstrvv, indx, indy, it, checkhh, eps, zsa);\n                //printf(\"%d\\t%d\\t%d\\tvv=%f\\t%d\\n\", it, indx, indy, zsa[0], iswet);\n                //printf(\"%d\\t%d\\t%f\\n\", indx, indy, zsa[0]);\n\n                if (iswet == 0)\n                {\n                    if (Vnest.size() &gt;= 1)\n                    {\n                        zsa[0] = Vnest.back();\n                    }\n                    else\n                    {\n                        zsa[0] = 0.0;\n                    }\n                }\n\n                Vnest.push_back(zsa[0]);\n            }\n\n\n\n\n        }\n        slbndline.wlevs = WLS;\n        WLS.clear();\n        if (checkhh)\n        {\n            slbndline.uuvel = Unest;\n            slbndline.vvvel = Vnest;\n            Unest.clear();\n            Vnest.clear();\n        }\n\n        slbnd.push_back(slbndline);\n        //std::cout &lt;&lt; line &lt;&lt; std::endl;\n\n    }\n\n    free(ttt);\n    free(zsa);\n    return slbnd;\n}\n\nstd::vector&lt;Flowin&gt; readFlowfile(std::string Flowfilename, std::string &amp;refdate)\n{\n    std::vector&lt;Flowin&gt; slbnd;\n\n    std::ifstream fs(Flowfilename);\n\n    if (fs.fail()) {\n        std::cerr &lt;&lt; Flowfilename &lt;&lt; \" Flow file could not be opened\" &lt;&lt; std::endl;\n        write_text_to_log_file(\"ERROR: Flow/River file could not be opened \");\n        exit(1);\n    }\n\n    std::string line;\n    std::vector&lt;std::string&gt; lineelements;\n    //std::vector&lt;double&gt; WLS;\n    Flowin slbndline;\n    while (std::getline(fs, line))\n    {\n        //std::cout &lt;&lt; line &lt;&lt; std::endl;\n\n        // skip empty lines and lines starting with #\n        if (!line.empty() &amp;&amp; line.substr(0, 1).compare(\"#\") != 0)\n        {\n            //Data should be in the format : time,Water level 1,Water level 2,...Water level n\n            //Location where the water level is 0:ny/(nwl-1):ny where nwl i the number of wlevnodes\n\n            //by default we expect tab delimitation\n            lineelements = split(line, '\\t');\n            if (lineelements.size() != 2)\n            {\n                // Is it space delimited?\n                lineelements.clear();\n                lineelements = split(line, ' ');\n            }\n\n            if (lineelements.size() != 2)\n            {\n                //Well it has to be comma delimited then\n                lineelements.clear();\n                lineelements = split(line, ',');\n            }\n            if (lineelements.size() != 2)\n            {\n                // Giving up now! Could not read the files\n                //issue a warning and exit\n                //std::cerr &lt;&lt; Flowfilename &lt;&lt; \"ERROR flow file format error. only \" &lt;&lt; lineelements.size() &lt;&lt; \" where at least 2 were expected. Exiting.\" &lt;&lt; std::endl;\n                log(\"ERROR:  flow file (\" + Flowfilename + \") format error. only \" + std::to_string(lineelements.size()) + \" where at least 2 were expected. Exiting.\");\n                log(line);\n                exit(1);\n            }\n\n            slbndline.time = readinputtimetxt(lineelements[0], refdate);\n            //slbndline.time = std::stod(lineelements[0]);\n\n\n\n\n\n            slbndline.q = std::stod(lineelements[1]);;\n\n\n\n            //slbndline = readBSHline(line);\n            slbnd.push_back(slbndline);\n            //std::cout &lt;&lt; line &lt;&lt; std::endl;\n            //WLS.clear();\n        }\n\n    }\n    fs.close();\n\n    //std::cout &lt;&lt; slbnd[0].wlev &lt;&lt; std::endl;\n\n\n    return slbnd;\n}\n\n\nstd::vector&lt;Windin&gt; readINfileUNI(std::string filename, std::string &amp;refdate)\n{\n    std::vector&lt;Windin&gt; wndinput;\n\n    std::ifstream fs(filename);\n\n    if (fs.fail()) {\n        //std::cerr &lt;&lt; filename &lt;&lt; \"ERROR: Atm presssure / Rainfall file could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: Bnd file / Atm presssure / Rainfall file could not be opened : \" + filename);\n        exit(1);\n    }\n\n    std::string line;\n    std::vector&lt;std::string&gt; lineelements;\n    std::vector&lt;double&gt; WLS;\n    Windin wndline;\n    while (std::getline(fs, line))\n    {\n        // skip empty lines and lines starting with #\n        if (!line.empty() &amp;&amp; line.substr(0, 1).compare(\"#\") != 0)\n        {\n            //Data should be in the format : time,wind speed, wind dir, uwind vwind\n            //Location where the water level is 0:ny/(nwl-1):ny where nwl i the number of wlevnodes\n\n            //by default we expect tab delimitation\n            lineelements = split(line, '\\t');\n            if (lineelements.size() &lt; 2)\n            {\n                // Is it space delimited?\n                lineelements.clear();\n                lineelements = split(line, ' ');\n            }\n\n            if (lineelements.size() &lt; 2)\n            {\n                //Well it has to be comma delimited then\n                lineelements.clear();\n                lineelements = split(line, ',');\n            }\n            if (lineelements.size() &lt; 2)\n            {\n                // Giving up now! Could not read the files\n                //issue a warning and exit\n                //std::cerr &lt;&lt; filename &lt;&lt; \"ERROR Atm presssure / Rainfall  file format error. only \" &lt;&lt; lineelements.size() &lt;&lt; \" where at least 2 were expected. Exiting.\" &lt;&lt; std::endl;\n                log(\"ERROR:  Atm presssure / Rainfall file (\" + filename + \") format error. only \" + std::to_string(lineelements.size()) + \" where at least 2 were expected. Exiting.\");\n                log(line);\n                exit(1);\n            }\n\n            wndline.time = readinputtimetxt(lineelements[0], refdate);\n            //wndline.time = std::stod(lineelements[0]);\n            wndline.wspeed = std::stod(lineelements[1]);\n\n            wndinput.push_back(wndline);\n\n\n        }\n\n    }\n    fs.close();\n\n    return wndinput;\n}\n\n\nstd::vector&lt;Windin&gt; readWNDfileUNI(std::string filename, std::string &amp; refdate, double grdalpha)\n{\n    // Warning grdapha is expected in radian here\n    std::vector&lt;Windin&gt; wndinput;\n\n    std::ifstream fs(filename);\n\n    if (fs.fail()) {\n        //std::cerr &lt;&lt; filename &lt;&lt; \"ERROR: Wind file could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: Wind file could not be opened : \"+ filename);\n        exit(1);\n    }\n\n    std::string line;\n    std::vector&lt;std::string&gt; lineelements;\n    std::vector&lt;double&gt; WLS;\n    Windin wndline;\n    while (std::getline(fs, line))\n    {\n        //std::cout &lt;&lt; line &lt;&lt; std::endl;\n\n        // skip empty lines and lines starting with #\n        if (!line.empty() &amp;&amp; line.substr(0, 1).compare(\"#\") != 0)\n        {\n            //Data should be in the format : time,wind speed, wind dir, uwind vwind\n            //Location where the water level is 0:ny/(nwl-1):ny where nwl i the number of wlevnodes\n\n            //by default we expect tab delimitation\n            lineelements = split(line, '\\t');\n            if (lineelements.size() &lt; 3)\n            {\n                // Is it space delimited?\n                lineelements.clear();\n                lineelements = split(line, ' ');\n            }\n\n            if (lineelements.size() &lt; 3)\n            {\n                //Well it has to be comma delimited then\n                lineelements.clear();\n                lineelements = split(line, ',');\n            }\n            if (lineelements.size() &lt; 3)\n            {\n                // Giving up now! Could not read the files\n                //issue a warning and exit\n                //std::cerr &lt;&lt; filename &lt;&lt; \"ERROR Wind  file format error. only \" &lt;&lt; lineelements.size() &lt;&lt; \" where at least 3 were expected. Exiting.\" &lt;&lt; std::endl;\n                log(\"ERROR:  Wind file (\" + filename + \") format error. only \" + std::to_string(lineelements.size()) + \" where at least 3 were expected. Exiting.\");\n                log(line);\n                exit(1);\n            }\n\n            wndline.time = readinputtimetxt(lineelements[0], refdate);\n            //wndline.time = std::stod(lineelements[0]);\n            if (lineelements.size() == 5)\n            {\n                // U and v are explicitelly stated\n                wndline.wspeed = std::stod(lineelements[1]); // Actually his is a dummy \n                wndline.wdirection= std::stod(lineelements[2]); // Actually his is a dummy\n                wndline.uwind = std::stod(lineelements[3]);\n                wndline.vwind = std::stod(lineelements[4]);\n            }\n            else\n            {\n                // read speed and direction and directly convert to u and v\n                wndline.wspeed = std::stod(lineelements[1]); // Actually his is a dummy \n                wndline.wdirection = std::stod(lineelements[2]);\n                double theta = (1.5*pi - grdalpha) - wndline.wdirection*pi / 180;\n\n                wndline.uwind = wndline.wspeed*cos(theta);\n                wndline.vwind = wndline.wspeed*sin(theta);\n            }\n            //slbndline.wlevs = WLS;\n\n\n\n            //slbndline = readBSHline(line);\n            wndinput.push_back(wndline);\n            //std::cout &lt;&lt; line &lt;&lt; std::endl;\n\n        }\n\n    }\n    fs.close();\n\n    //std::cout &lt;&lt; slbnd[0].wlev &lt;&lt; std::endl;\n\n\n    return wndinput;\n}\n\n\n\nPolygon readPolygon(std::string filename)\n{\n    Polygon poly, polyB;\n    Vertex v;\n\n    std::string line;\n    std::vector&lt;std::string&gt; lineelements;\n\n    std::ifstream fs(filename);\n\n    if (fs.fail()) {\n        //std::cerr &lt;&lt; filename &lt;&lt; \"ERROR: Wind file could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: Polygon file could not be opened : \" + filename);\n        return poly;\n    }\n\n    while (std::getline(fs, line))\n    {\n        // skip empty lines and lines starting with #\n        if (!line.empty() &amp;&amp; line.substr(0, 1).compare(\"#\") != 0)\n        {\n            //\n            //line.substr(0, 1).compare(\"&gt;\") != 0\n            //by default we expect tab delimitation\n            lineelements = DelimLine(line, 2);\n            v.x = std::stod(lineelements[0]);\n            v.y = std::stod(lineelements[1]);\n\n            poly.vertices.push_back(v);\n\n        }\n    }\n\n\n    size_t nv = poly.vertices.size();\n\n    // Make sure ploygon is closed\n    double epsilon = std::numeric_limits&lt;double&gt;::epsilon() * 1000.0;\n\n    if ( !(abs(poly.vertices[0].x - poly.vertices[nv - 1].x) &lt; epsilon &amp;&amp; abs(poly.vertices[0].y - poly.vertices[nv - 1].y) &lt; epsilon) )\n    {\n        v.x = poly.vertices[0].x;\n        v.y = poly.vertices[0].y;\n\n        poly.vertices.push_back(v);\n    }\n\n    polyB = CounterCWPoly(poly);\n\n    polyB.xmin = polyB.vertices[0].x;\n    polyB.xmax = polyB.vertices[0].x;\n\n    polyB.ymin = polyB.vertices[0].y;\n    polyB.ymax = polyB.vertices[0].y;\n\n    for (int i = 0; i &lt; polyB.vertices.size(); i++)\n    {\n        polyB.xmin = utils::min(polyB.vertices[i].x, polyB.xmin);\n        polyB.xmax = utils::max(polyB.vertices[i].x, polyB.xmax);\n        polyB.ymin = utils::min(polyB.vertices[i].y, polyB.ymin);\n        polyB.ymax = utils::max(polyB.vertices[i].y, polyB.ymax);\n    }\n\n\n    return polyB;\n}\n\n\nstd::vector&lt;std::string&gt; DelimLine(std::string line, int n, char delim)\n{\n    std::vector&lt;std::string&gt; lineelements;\n    lineelements = split(line, delim);\n    if (lineelements.size() != n)\n    {\n        lineelements.clear();\n\n\n    }\n    return lineelements;\n}\n\nstd::vector&lt;std::string&gt; DelimLine(std::string line, int n)\n{\n    std::vector&lt;std::string&gt; LeTab;\n    std::vector&lt;std::string&gt; LeSpace;\n    std::vector&lt;std::string&gt; LeComma;\n\n    //std::vector&lt;std::string&gt; lineelements;\n\n    LeTab = DelimLine(line, n, '\\t');\n    LeSpace = DelimLine(line, n, ' ');\n    LeComma = DelimLine(line, n, ',');\n\n    if (LeTab.size() == n)\n    {\n        return LeTab;\n    }\n    if (LeSpace.size() == n)\n    {\n        return LeSpace;\n    }\n    if (LeComma.size() == n)\n    {\n        return LeComma;\n    }\n\n    LeTab.clear();\n\n    return LeTab;\n\n}\n\ntemplate &lt;class T&gt;\nvoid readforcingdata(int step,T forcing)\n{\n    // Check extension \n    std::string fileext;\n\n    fileext = forcing.extension;\n    //Now choose the right function to read the data\n\n    if (fileext.compare(\"md\") == 0)\n    {\n        readbathyMD(forcing.inputfile, forcing.val);\n    }\n    if (fileext.compare(\"nc\") == 0)\n    {\n        readvardata(forcing.inputfile, forcing.varname,step, forcing.val, forcing.flipxx, forcing.flipyy);\n    }\n    if (fileext.compare(\"bot\") == 0 || fileext.compare(\"dep\") == 0)\n    {\n        readXBbathy(forcing.inputfile, forcing.nx, forcing.ny, forcing.val);\n    }\n    if (fileext.compare(\"asc\") == 0)\n    {\n        //\n        readbathyASCzb(forcing.inputfile, forcing.nx, forcing.ny, forcing.val);\n    }\n\n    //return 1;\n}\ntemplate void readforcingdata&lt;StaticForcingP&lt;float&gt;&gt;(int step, StaticForcingP&lt;float&gt; forcing);\ntemplate void readforcingdata&lt;deformmap&lt;float&gt;&gt;(int step, deformmap&lt;float&gt; forcing);\ntemplate void readforcingdata&lt;StaticForcingP&lt;int&gt;&gt;(int step, StaticForcingP&lt;int&gt; forcing);\n//template void readforcingdata&lt;DynForcingP&lt;float&gt;&gt;(int step, DynForcingP&lt;float&gt; forcing);\n\nvoid readforcingdata(double totaltime, DynForcingP&lt;float&gt;&amp; forcing)\n{\n    int step = utils::min(utils::max((int)floor((totaltime - forcing.to) / forcing.dt), 0), forcing.nt - 2);\n    readvardata(forcing.inputfile, forcing.varname, step, forcing.before, forcing.flipxx, forcing.flipyy);\n    readvardata(forcing.inputfile, forcing.varname, step+1, forcing.after, forcing.flipxx, forcing.flipyy);\n\n    denan(forcing.nx, forcing.ny, float(forcing.denanval), forcing.before);\n    denan(forcing.nx, forcing.ny, float(forcing.denanval), forcing.after);\n\n    clampedges(forcing.nx, forcing.ny, forcing.clampedge, forcing.before);\n    clampedges(forcing.nx, forcing.ny, forcing.clampedge, forcing.after);\n\n    InterpstepCPU(forcing.nx, forcing.ny, step, totaltime, forcing.dt, forcing.now, forcing.before, forcing.after);\n    forcing.val = forcing.now;\n}\n\nDynForcingP&lt;float&gt; readforcinghead(DynForcingP&lt;float&gt; Fmap, Param XParam)\n{\n    // Read critical parameter for the forcing map\n    log(\"Forcing map was specified. Checking file... \");\n    std::string fileext = Fmap.extension;\n    //double dummy;\n\n\n    if (fileext.compare(\"nc\") == 0)\n    {\n        log(\"Reading Forcing file as netcdf file\");\n\n        //readgridncsize(Fmap.inputfile,Fmap.varname, Fmap.nx, Fmap.ny, Fmap.nt, Fmap.dx, Fmap.xo, Fmap.yo, Fmap.to, Fmap.xmax, Fmap.ymax, Fmap.tmax, Fmap.flipxx, Fmap.flipyy);\n        readgridncsize(Fmap, XParam);\n\n\n    }\n    else\n    {\n        log(\"Forcing file needs to be a .nc file you also need to specify the netcdf variable name like this ncfile.nc?myvar\");\n    }\n\n\n    return Fmap;\n}\n\n\n\ntemplate&lt;class T&gt; T readforcinghead(T ForcingParam)\n{\n    //std::string fileext;\n\n    //read bathy and perform sanity check\n\n    if (!ForcingParam.inputfile.empty())\n    {\n        //printf(\"bathy: %s\\n\", BathyParam.inputfile.c_str());\n\n        log(\"Reading forcing metadata. file: \" + ForcingParam.inputfile + \" extension: \" + ForcingParam.extension);\n\n\n\n\n        if (ForcingParam.extension.compare(\"md\") == 0)\n        {\n            //log(\"'md' file\");\n            readbathyHeadMD(ForcingParam.inputfile, ForcingParam.nx, ForcingParam.ny, ForcingParam.dx, ForcingParam.grdalpha);\n            ForcingParam.dy = ForcingParam.dx;\n            ForcingParam.xo = 0.0;\n            ForcingParam.yo = 0.0;\n            ForcingParam.xmax = ForcingParam.xo + (double(ForcingParam.nx) - 1.0) * ForcingParam.dx;\n            ForcingParam.ymax = ForcingParam.yo + (double(ForcingParam.ny) - 1.0) * ForcingParam.dx;\n\n        }\n        if (ForcingParam.extension.compare(\"nc\") == 0)\n        {\n            //int dummy;\n            //double dummyb, dummyc;\n            //log(\"netcdf file\");\n\n            //readgridncsize(ForcingParam.inputfile, ForcingParam.varname, ForcingParam.nx, ForcingParam.ny, dummy, ForcingParam.dx, ForcingParam.xo, ForcingParam.yo, dummyb, ForcingParam.xmax, ForcingParam.ymax, dummyc, ForcingParam.flipxx, ForcingParam.flipyy);\n            readgridncsize(ForcingParam);\n\n            //log(\"For nc of bathy file please specify grdalpha in the BG_param.txt (default 0)\");\n\n            //Check that the x and y variable are in crescent order:\n            if (ForcingParam.xmax &lt; ForcingParam.xo)\n            {\n                log(\"FATAL ERROR:  x coordinate isn't in crescent order in file: \" + ForcingParam.inputfile);\n                exit(1);\n            }\n            if (ForcingParam.ymax &lt; ForcingParam.yo)\n            {\n                log(\"FATAL ERROR:  y coordinate isn't in crescent order in file: \" + ForcingParam.inputfile);\n                exit(1);\n            }\n\n        }\n        if (ForcingParam.extension.compare(\"dep\") == 0 || ForcingParam.extension.compare(\"bot\") == 0)\n        {\n            //XBeach style file\n            log(ForcingParam.extension + \" file\");\n            log(\"For this type of bathy file please specify nx, ny, dx, xo, yo and grdalpha in the XBG_param.txt\");\n        }\n        if (ForcingParam.extension.compare(\"asc\") == 0)\n        {\n            //\n            //log(\"asc file\");\n            readbathyASCHead(ForcingParam.inputfile, ForcingParam.nx, ForcingParam.ny, ForcingParam.dx, ForcingParam.xo, ForcingParam.yo, ForcingParam.grdalpha);\n            ForcingParam.xmax = ForcingParam.xo + (ForcingParam.nx-1)* ForcingParam.dx;\n            ForcingParam.ymax = ForcingParam.yo + (ForcingParam.ny-1)* ForcingParam.dx;\n\n            log(\"For asc of bathy file please specify grdalpha in the BG_param.txt (default 0)\");\n        }\n\n\n\n        //XParam.nx = ceil(XParam.nx / 16) * 16;\n        //XParam.ny = ceil(XParam.ny / 16) * 16;\n\n\n\n        //printf(\"Bathymetry grid info: nx=%d\\tny=%d\\tdx=%lf\\talpha=%f\\txo=%lf\\tyo=%lf\\txmax=%lf\\tymax=%lf\\n\", BathyParam.nx, BathyParam.ny, BathyParam.dx, BathyParam.grdalpha * 180.0 / pi, BathyParam.xo, BathyParam.yo, BathyParam.xmax, BathyParam.ymax);\n        log(\"Forcing grid info: nx=\" + std::to_string(ForcingParam.nx) + \" ny=\" + std::to_string(ForcingParam.ny) + \" dx=\" + std::to_string(ForcingParam.dx) + \" dy=\" + std::to_string(ForcingParam.dy) + \" grdalpha=\" + std::to_string(ForcingParam.grdalpha*180.0 / pi) + \" xo=\" + std::to_string(ForcingParam.xo) + \" xmax=\" + std::to_string(ForcingParam.xmax) + \" yo=\" + std::to_string(ForcingParam.yo) + \" ymax=\" + std::to_string(ForcingParam.ymax));\n\n\n\n\n\n\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Fatal error: No bathymetry file specified. Please specify using 'bathy = Filename.bot'\" &lt;&lt; std::endl;\n        log(\"Fatal error : No bathymetry file specified. Please specify using 'bathy = Filename.md'\");\n        exit(1);\n    }\n    return ForcingParam;\n}\ntemplate inputmap readforcinghead&lt;inputmap&gt;(inputmap BathyParam);\ntemplate forcingmap readforcinghead&lt;forcingmap&gt;(forcingmap BathyParam);\n//template StaticForcingP&lt;float&gt; readBathyhead&lt;StaticForcingP&lt;float&gt;&gt;(StaticForcingP&lt;float&gt; BathyParam);\ntemplate StaticForcingP&lt;float&gt; readforcinghead&lt;StaticForcingP&lt;float&gt;&gt;(StaticForcingP&lt;float&gt; ForcingParam);\n\n\nvoid readbathyHeadMD(std::string filename, int &amp;nx, int &amp;ny, double &amp;dx, double &amp;grdalpha)\n{\n\n\n    std::ifstream fs(filename);\n\n    if (fs.fail()) {\n        std::cerr &lt;&lt; filename &lt;&lt; \" bathy file (md file) could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: bathy file could not be opened \"+ filename);\n        exit(1);\n    }\n\n    std::string line;\n    std::vector&lt;std::string&gt; lineelements;\n\n    std::getline(fs, line);\n    // skip empty lines\n    if (!line.empty())\n    {\n\n        //by default we expect tab delimitation\n        lineelements = split(line, '\\t');\n        if (lineelements.size() &lt; 5)\n        {\n            // Is it space delimited?\n            lineelements.clear();\n            lineelements = split(line, ' ');\n        }\n\n        if (lineelements.size() &lt; 5)\n        {\n            //Well it has to be comma delimited then\n            lineelements.clear();\n            lineelements = split(line, ',');\n        }\n        if (lineelements.size() &lt; 5)\n        {\n            // Giving up now! Could not read the files\n            //issue a warning and exit\n            std::cerr &lt;&lt; filename &lt;&lt; \"ERROR Wind bnd file format error. only \" &lt;&lt; lineelements.size() &lt;&lt; \" where 5 were expected. Exiting.\" &lt;&lt; std::endl;\n            log(\"ERROR:  Wind bnd file (\" + filename + \") format error. only \" + std::to_string(lineelements.size()) + \" where 3 were expected. Exiting.\");\n            log(line);\n            exit(1);\n        }\n\n        nx = std::stoi(lineelements[0]);\n        ny = std::stoi(lineelements[1]);\n        dx = std::stod(lineelements[2]);\n        grdalpha = std::stod(lineelements[4]);\n    }\n\n    fs.close();\n}\n\n\ntemplate &lt;class T&gt; void readbathyMD(std::string filename, T*&amp; zb)\n{\n    // Shit that doesn'y wor... Needs fixing \n    int nx;\n    //int ny;\n    //float dx;\n    std::ifstream fs(filename);\n\n    if (fs.fail()) {\n        std::cerr &lt;&lt; filename &lt;&lt; \" bathy file (md file) could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: bathy file could not be opened \" + filename);\n        exit(1);\n    }\n\n    std::string line;\n\n    std::vector&lt;std::string&gt; lineelements;\n\n    std::getline(fs, line);\n    if (!line.empty() &amp;&amp; line.substr(0, 1).compare(\"#\") != 0)\n    {\n        //by default we expect tab delimitation\n        lineelements = split(line, '\\t');\n        if (lineelements.size() &lt; 5)\n        {\n            // Is it space delimited?\n            lineelements.clear();\n            lineelements = split(line, ' ');\n        }\n\n        if (lineelements.size() &lt; 5)\n        {\n            //Well it has to be comma delimited then\n            lineelements.clear();\n            lineelements = split(line, ',');\n        }\n        if (lineelements.size() &lt; 5)\n        {\n            // Giving up now! Could not read the files\n            //issue a warning and exit\n            std::cerr &lt;&lt; filename &lt;&lt; \"ERROR Wind bnd file format error. only \" &lt;&lt; lineelements.size() &lt;&lt; \" where 5 were expected. Exiting.\" &lt;&lt; std::endl;\n            log(\"ERROR:  Wind bnd file (\" + filename + \") format error. only \" + std::to_string(lineelements.size()) + \" where 3 were expected. Exiting.\");\n            log(line);\n            exit(1);\n        }\n\n        nx = std::stoi(lineelements[0]);\n        //ny = std::stoi(lineelements[1]);\n        //dx = std::stof(lineelements[2]);\n        //grdalpha = std::stof(lineelements[4]);\n    }\n\n    int j = 0;\n    while (std::getline(fs, line))\n    {\n        //std::cout &lt;&lt; line &lt;&lt; std::endl;\n\n        // skip empty lines and lines starting with #\n        if (!line.empty() &amp;&amp; line.substr(0, 1).compare(\"#\") != 0)\n        {\n            lineelements = split(line, '\\t');\n            for (int i = 0; i &lt; nx; i++)\n            {\n                zb[i + j * nx] = T(std::stof(lineelements[0]));\n            }\n            j++;\n        }\n    }\n\n    fs.close();\n\n}\ntemplate void readbathyMD&lt;int&gt;(std::string filename, int*&amp; zb);\ntemplate void readbathyMD&lt;float&gt;(std::string filename, float*&amp; zb);\n\ntemplate &lt;class T&gt; void readXBbathy(std::string filename, int nx,int ny, T *&amp;zb)\n{\n    //read input data:\n    //printf(\"bathy: %s\\n\", filename);\n\n\n    //read md file\n     std::ifstream fs(filename);\n     std::string line;\n     std::vector&lt;std::string&gt; lineelements;\n\n\n\n\n\n    //int jreadzs;\n    for (int jnod = 0; jnod &lt; ny; jnod++)\n    {\n\n        std::getline(fs, line);\n\n        for (int inod = 0; inod &lt; nx; inod++)\n        {\n            //fscanf(fid, \"%f\", &amp;zb[inod + (jnod)*nx]);\n            zb[inod + jnod * nx] = T(std::stod(lineelements[0]));\n\n        }\n    }\n    fs.close();\n    //fclose(fid);\n}\ntemplate void readXBbathy&lt;int&gt;(std::string filename, int nx, int ny, int*&amp; zb);\ntemplate void readXBbathy&lt;float&gt;(std::string filename, int nx, int ny, float*&amp; zb);\n\n\nvoid readbathyASCHead(std::string filename, int &amp;nx, int &amp;ny, double &amp;dx, double &amp;xo, double &amp;yo, double &amp;grdalpha)\n{\n    std::ifstream fs(filename);\n\n    if (fs.fail()) {\n        std::cerr &lt;&lt; filename &lt;&lt; \" bathy file (md file) could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: bathy file could not be opened \" + filename);\n        exit(1);\n    }\n\n    std::string line,left,right;\n    std::vector&lt;std::string&gt; lineelements;\n    //std::size_t found;\n    //std::getline(fs, line);\n    int linehead = 0;\n\n    bool pixelreg = true;\n\n    while (linehead &lt; 6)\n    {\n        std::getline(fs, line);\n        // skip empty lines\n        if (!line.empty())\n        {\n\n            //by default we expect tab delimitation\n            lineelements = split(line, ' ');\n            if (lineelements.size() &lt; 2)\n            {\n                lineelements = split(line, '\\t');\n\n            }\n\n\n\n\n            left = trim(lineelements[0], \" \");\n            right = lineelements[1]; \n            //printf(\"left: %s ;right: %s\\n\", left.c_str(), right.c_str());\n            //found = left.compare(\"ncols\");// it needs to strictly compare\n            if (left.compare(\"ncols\") == 0) // found the parameter\n            {\n\n                //\n                nx = std::stoi(right);\n\n            }\n\n            if (left.compare(\"nrows\") == 0) // found the parameter\n            {\n\n                //\n                ny = std::stoi(right);\n\n            }\n            if (left.compare(\"cellsize\") == 0) // found the parameter\n            {\n\n                //\n                dx = std::stod(right);\n\n            }\n            if (left.compare(\"xllcenter\") == 0) // found the parameter\n            {\n\n                //\n                xo = std::stod(right);\n\n            }\n            if (left.compare(\"yllcenter\") == 0) // found the parameter\n            {\n                pixelreg = false;\n                //\n                yo = std::stod(right);\n\n            }\n            //if gridnode registration this should happen\n            if (left.compare(\"xllcorner\") == 0) // found the parameter\n            {\n                pixelreg = false;\n                //\n                xo = std::stod(right);\n\n            }\n            if (left.compare(\"yllcorner\") == 0) // found the parameter\n            {\n\n                //\n                yo = std::stod(right);\n                //This should be:\n                //yo = std::stod(right) + dx / 2.0;\n                //but by the time xo and yo are found dx has not been setup... awkward...\n\n            }\n            linehead++;\n        }\n    }\n\n    if (!pixelreg)\n    {\n        xo = xo + 0.5 * dx;\n        yo = yo + 0.5 * dx;\n    }\n\n    grdalpha = 0.0;\n    fs.close();\n\n}\n\n\ntemplate &lt;class T&gt; void readbathyASCzb(std::string filename,int nx, int ny, T* &amp;zb)\n{\n    //\n    std::ifstream fs(filename);\n    int linehead = 0;\n    std::string line;\n    if (fs.fail()) {\n        std::cerr &lt;&lt; filename &lt;&lt; \" bathy file (md file) could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: bathy file could not be opened \" + filename);\n        exit(1);\n    }\n    while (linehead &lt; 6)\n    {\n        //Skip header\n        std::getline(fs, line);\n        linehead++;\n    }\n    //int jreadzs;\n    for (int jnod = ny-1; jnod &gt;= 0; jnod--)\n    {\n\n\n\n        for (int inod = 0; inod &lt; nx; inod++)\n        {\n            //fscanf(fid, \"%f\", &amp;zb[inod + (jnod)*nx]);\n\n            fs &gt;&gt; zb[inod + (jnod)*nx];\n            //printf(\"%f\\n\", zb[inod + (jnod)*nx]);\n\n        }\n    }\n\n    fs.close();\n}\ntemplate void readbathyASCzb&lt;int&gt;(std::string filename, int nx, int ny, int*&amp; zb);\ntemplate void readbathyASCzb&lt;float&gt;(std::string filename, int nx, int ny, float*&amp; zb);\n\ntemplate &lt;class T&gt; void clampedges(int nx, int ny, T clamp, T* z)\n{\n    //\n    int ii;\n    for (int ix = 0; ix &lt;nx; ix++)\n    {\n        ii = ix + 0 * nx;\n        z[ii] = clamp;\n        ii = ix + (ny - 1) * nx;\n        z[ii] = clamp;\n    }\n\n    for (int iy = 0; iy &lt; ny; iy++)\n    {\n        ii = 0 + iy * nx;\n        z[ii] = clamp;\n        ii = (nx - 1) + (iy)* nx;\n        z[ii] = clamp;\n    }\n}\n\ntemplate &lt;class T&gt; void denan(int nx, int ny, float denanval, T* z)\n{\n    for (int j = 0; j &lt; ny; j++)\n    {\n        for (int i = 0; i &lt; nx; i++)\n        {\n            if (isnan(z[i + j * nx]))\n            {\n                z[i + j * nx] = denanval;\n            }\n        }\n    }\n}\ntemplate void denan&lt;float&gt;(int nx, int ny, float denanval, float* z);\ntemplate void denan&lt;double&gt;(int nx, int ny, float denanval, double* z);\n\nvoid denan(int nx, int ny, float denanval, int* z)\n{\n    //don't do nothing\n    // This function exist for cleaner compiling requirement that NaN do not exist in int form\n}\n\n//template &lt;class T&gt; void InterpstepCPU(int nx, int ny, int hdstep, float totaltime, float hddt, T*&amp; Ux, T* Uo, T* Un)\n//{\n//  //float fac = 1.0;\n//  T Uxo, Uxn;\n//\n//  /*Ums[tx]=Umask[ix];*/\n//\n//\n//\n//\n//  for (int i = 0; i &lt; nx; i++)\n//  {\n//      for (int j = 0; j &lt; ny; j++)\n//      {\n//          Uxo = Uo[i + nx * j];\n//          Uxn = Un[i + nx * j];\n//\n//          Ux[i + nx * j] = Uxo + (totaltime - hddt * hdstep) * (Uxn - Uxo) / hddt;\n//      }\n//  }\n//}\n//template void InterpstepCPU&lt;int&gt;(int nx, int ny, int hdstep, float totaltime, float hddt, int*&amp; Ux, int* Uo, int* Un);\n//template void InterpstepCPU&lt;float&gt;(int nx, int ny, int hdstep, float totaltime, float hddt, float*&amp; Ux, float* Uo, float* Un);\n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/","title":"File ReadForcing.h","text":""},{"location":"BGFlood/ReadForcing_8h/#file-readforcingh","title":"File ReadForcing.h","text":"<p>FileList &gt; src &gt; ReadForcing.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Input.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"Read_netcdf.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Setup_GPU.h\"</code></li> <li><code>#include \"Poly.h\"</code></li> </ul>"},{"location":"BGFlood/ReadForcing_8h/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; std::string &gt; DelimLine (std::string line, int n, char delim)  std::vector&lt; std::string &gt; DelimLine (std::string line, int n)  void InitDynforcing (bool gpgpu, Param &amp; XParam, DynForcingP&lt; float &gt; &amp; Dforcing)  void InterpstepCPU (int nx, int ny, int hdstep, float totaltime, float hddt, T *&amp; Ux, T * Uo, T * Un)  void clampedges (int nx, int ny, T clamp, T * z)  void denan (int nx, int ny, float denanval, int * z)  void denan (int nx, int ny, float denanval, T * z)  void readDynforcing (bool gpgpu, double totaltime, DynForcingP&lt; float &gt; &amp; Dforcing)  std::vector&lt; Flowin &gt; readFlowfile (std::string Flowfilename, std::string &amp; refdate)  std::vector&lt; Windin &gt; readINfileUNI (std::string filename, std::string &amp; refdate)  std::vector&lt; SLTS &gt; readNestfile (std::string ncfile, std::string varname, int hor, double eps, double bndxo, double bndxmax, double bndy)  Polygon readPolygon (std::string filename)  std::vector&lt; SLTS &gt; readWLfile (std::string WLfilename, std::string &amp; refdate)  std::vector&lt; Windin &gt; readWNDfileUNI (std::string filename, std::string &amp; refdate, double grdalpha)  void readXBbathy (std::string filename, int nx, int ny, T *&amp; zb)  void readbathyASCHead (std::string filename, int &amp; nx, int &amp; ny, double &amp; dx, double &amp; xo, double &amp; yo, double &amp; grdalpha)  void readbathyASCzb (std::string filename, int nx, int ny, T *&amp; zb)  void readbathyHeadMD (std::string filename, int &amp; nx, int &amp; ny, double &amp; dx, double &amp; grdalpha)  void readbathyMD (std::string filename, T *&amp; zb)  std::vector&lt; SLTS &gt; readbndfile (std::string filename, Param &amp; XParam)  Polygon readbndpolysegment (bndsegment bnd, Param XParam)  void readforcing (Param &amp; XParam, Forcing&lt; T &gt; &amp; XForcing)  void readforcingdata (int step, T forcing)  void readforcingdata (double totaltime, DynForcingP&lt; float &gt; &amp; forcing)  DynForcingP&lt; float &gt; readforcinghead (DynForcingP&lt; float &gt; Fmap, Param XParam)  T readforcinghead (T Fmap)  void readstaticforcing (T &amp; Sforcing)  void readstaticforcing (int step, T &amp; Sforcing)"},{"location":"BGFlood/ReadForcing_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/ReadForcing_8h/#function-delimline","title":"function DelimLine","text":"<pre><code>std::vector&lt; std::string &gt; DelimLine (\n    std::string line,\n    int n,\n    char delim\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/#function-delimline_1","title":"function DelimLine","text":"<pre><code>std::vector&lt; std::string &gt; DelimLine (\n    std::string line,\n    int n\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/#function-initdynforcing","title":"function InitDynforcing","text":"<pre><code>void InitDynforcing (\n    bool gpgpu,\n    Param &amp; XParam,\n    DynForcingP &lt; float &gt; &amp; Dforcing\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/#function-interpstepcpu","title":"function InterpstepCPU","text":"<pre><code>template&lt;class T&gt;\nvoid InterpstepCPU (\n    int nx,\n    int ny,\n    int hdstep,\n    float totaltime,\n    float hddt,\n    T *&amp; Ux,\n    T * Uo,\n    T * Un\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/#function-clampedges","title":"function clampedges","text":"<pre><code>template&lt;class T&gt;\nvoid clampedges (\n    int nx,\n    int ny,\n    T clamp,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/#function-denan","title":"function denan","text":"<pre><code>void denan (\n    int nx,\n    int ny,\n    float denanval,\n    int * z\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/#function-denan_1","title":"function denan","text":"<pre><code>template&lt;class T&gt;\nvoid denan (\n    int nx,\n    int ny,\n    float denanval,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/#function-readdynforcing","title":"function readDynforcing","text":"<pre><code>void readDynforcing (\n    bool gpgpu,\n    double totaltime,\n    DynForcingP &lt; float &gt; &amp; Dforcing\n) \n</code></pre> <p>This is a deprecated function! See InitDynforcing() instead </p>"},{"location":"BGFlood/ReadForcing_8h/#function-readflowfile","title":"function readFlowfile","text":"<pre><code>std::vector&lt; Flowin &gt; readFlowfile (\n    std::string Flowfilename,\n    std::string &amp; refdate\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/#function-readinfileuni","title":"function readINfileUNI","text":"<pre><code>std::vector&lt; Windin &gt; readINfileUNI (\n    std::string filename,\n    std::string &amp; refdate\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/#function-readnestfile","title":"function readNestfile","text":"<pre><code>std::vector&lt; SLTS &gt; readNestfile (\n    std::string ncfile,\n    std::string varname,\n    int hor,\n    double eps,\n    double bndxo,\n    double bndxmax,\n    double bndy\n) \n</code></pre> <p>Read boundary Nesting data </p>"},{"location":"BGFlood/ReadForcing_8h/#function-readpolygon","title":"function readPolygon","text":"<pre><code>Polygon readPolygon (\n    std::string filename\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/#function-readwlfile","title":"function readWLfile","text":"<pre><code>std::vector&lt; SLTS &gt; readWLfile (\n    std::string WLfilename,\n    std::string &amp; refdate\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/#function-readwndfileuni","title":"function readWNDfileUNI","text":"<pre><code>std::vector&lt; Windin &gt; readWNDfileUNI (\n    std::string filename,\n    std::string &amp; refdate,\n    double grdalpha\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/#function-readxbbathy","title":"function readXBbathy","text":"<pre><code>template&lt;class T&gt;\nvoid readXBbathy (\n    std::string filename,\n    int nx,\n    int ny,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/#function-readbathyaschead","title":"function readbathyASCHead","text":"<pre><code>void readbathyASCHead (\n    std::string filename,\n    int &amp; nx,\n    int &amp; ny,\n    double &amp; dx,\n    double &amp; xo,\n    double &amp; yo,\n    double &amp; grdalpha\n) \n</code></pre> <p>Read ASC file meta/header data </p>"},{"location":"BGFlood/ReadForcing_8h/#function-readbathyasczb","title":"function readbathyASCzb","text":"<pre><code>template&lt;class T&gt;\nvoid readbathyASCzb (\n    std::string filename,\n    int nx,\n    int ny,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/#function-readbathyheadmd","title":"function readbathyHeadMD","text":"<pre><code>void readbathyHeadMD (\n    std::string filename,\n    int &amp; nx,\n    int &amp; ny,\n    double &amp; dx,\n    double &amp; grdalpha\n) \n</code></pre> <p>Read MD file header data </p>"},{"location":"BGFlood/ReadForcing_8h/#function-readbathymd","title":"function readbathyMD","text":"<pre><code>template&lt;class T&gt;\nvoid readbathyMD (\n    std::string filename,\n    T *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/#function-readbndfile","title":"function readbndfile","text":"<pre><code>std::vector&lt; SLTS &gt; readbndfile (\n    std::string filename,\n    Param &amp; XParam\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/#function-readbndpolysegment","title":"function readbndpolysegment","text":"<pre><code>Polygon readbndpolysegment (\n    bndsegment bnd,\n    Param XParam\n) \n</code></pre>"},{"location":"BGFlood/ReadForcing_8h/#function-readforcing","title":"function readforcing","text":"<pre><code>template&lt;class T&gt;\nvoid readforcing (\n    Param &amp; XParam,\n    Forcing &lt; T &gt; &amp; XForcing\n) \n</code></pre> <p>wrapping function for reading all the forcing data </p>"},{"location":"BGFlood/ReadForcing_8h/#function-readforcingdata","title":"function readforcingdata","text":"<pre><code>template&lt;class T&gt;\nvoid readforcingdata (\n    int step,\n    T forcing\n) \n</code></pre> <p>Read static forcing data </p>"},{"location":"BGFlood/ReadForcing_8h/#function-readforcingdata_1","title":"function readforcingdata","text":"<pre><code>void readforcingdata (\n    double totaltime,\n    DynForcingP &lt; float &gt; &amp; forcing\n) \n</code></pre> <p>Read Dynamic forcing data </p>"},{"location":"BGFlood/ReadForcing_8h/#function-readforcinghead","title":"function readforcinghead","text":"<pre><code>DynForcingP &lt; float &gt; readforcinghead (\n    DynForcingP &lt; float &gt; Fmap,\n    Param XParam\n) \n</code></pre> <p>Read Dynamic forcing meta/header data </p>"},{"location":"BGFlood/ReadForcing_8h/#function-readforcinghead_1","title":"function readforcinghead","text":"<pre><code>template&lt;class T&gt;\nT readforcinghead (\n    T Fmap\n) \n</code></pre> <p>Read Static forcing meta/header data </p>"},{"location":"BGFlood/ReadForcing_8h/#function-readstaticforcing","title":"function readstaticforcing","text":"<pre><code>template&lt;class T&gt;\nvoid readstaticforcing (\n    T &amp; Sforcing\n) \n</code></pre> <p>single parameter version of readstaticforcing(int step,T&amp; Sforcing) readstaticforcing(0, Sforcing); </p>"},{"location":"BGFlood/ReadForcing_8h/#function-readstaticforcing_1","title":"function readstaticforcing","text":"<pre><code>template&lt;class T&gt;\nvoid readstaticforcing (\n    int step,\n    T &amp; Sforcing\n) \n</code></pre> <p>Allocate and read static (i.e. not varying in time) forcing Used for Bathy, roughness, deformation </p> <p>The documentation for this class was generated from the following file <code>src/ReadForcing.h</code></p>"},{"location":"BGFlood/ReadForcing_8h_source/","title":"File ReadForcing.h","text":""},{"location":"BGFlood/ReadForcing_8h_source/#file-readforcingh","title":"File ReadForcing.h","text":"<p>File List &gt; src &gt; ReadForcing.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef READFORCING_H\n#define READFORCING_H\n\n#include \"General.h\"\n#include \"Input.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"Read_netcdf.h\"\n#include \"Forcing.h\"\n#include \"Util_CPU.h\"\n#include \"Setup_GPU.h\"\n#include \"Poly.h\"\n\ntemplate&lt;class T&gt; void readforcing(Param&amp; XParam, Forcing&lt;T&gt; &amp; XForcing);\n\nstd::vector&lt;SLTS&gt; readbndfile(std::string filename, Param &amp; XParam);\nstd::vector&lt;SLTS&gt; readWLfile(std::string WLfilename,  std::string&amp; refdate);\n\nstd::vector&lt;SLTS&gt; readNestfile(std::string ncfile, std::string varname, int hor, double eps, double bndxo, double bndxmax, double bndy);\n\nstd::vector&lt;Flowin&gt; readFlowfile(std::string Flowfilename, std::string &amp;refdate);\nstd::vector&lt;Windin&gt; readINfileUNI(std::string filename, std::string &amp;refdate);\nstd::vector&lt;Windin&gt; readWNDfileUNI(std::string filename, std::string &amp; refdate, double grdalpha);\n\nvoid denan(int nx, int ny, float denanval, int* z);\ntemplate &lt;class T&gt; void denan(int nx, int ny, float denanval, T* z);\n\n\nvoid readDynforcing(bool gpgpu,double totaltime, DynForcingP&lt;float&gt;&amp; Dforcing);\n\n//DynForcingP&lt;float&gt; readforcinghead(DynForcingP&lt;float&gt; Fmap);\nDynForcingP&lt;float&gt; readforcinghead(DynForcingP&lt;float&gt; Fmap, Param XParam);\n\n\ntemplate&lt;class T&gt; T readforcinghead(T Fmap);\n//template&lt;class T&gt; T readBathyhead(T BathyParam);\ntemplate&lt;class T&gt; void readstaticforcing(T&amp; Sforcing);\ntemplate &lt;class T&gt; void readstaticforcing(int step, T&amp; Sforcing);\n\ntemplate &lt;class T&gt; void readforcingdata(int step, T forcing);\nvoid readforcingdata(double totaltime, DynForcingP&lt;float&gt;&amp; forcing);\nvoid readbathyHeadMD(std::string filename, int &amp;nx, int &amp;ny, double &amp;dx, double &amp;grdalpha);\ntemplate &lt;class T&gt; void readbathyMD(std::string filename, T*&amp; zb);\ntemplate &lt;class T&gt; void readXBbathy(std::string filename, int nx, int ny, T*&amp; zb);\n\nvoid InitDynforcing(bool gpgpu, Param&amp; XParam, DynForcingP&lt;float&gt;&amp; Dforcing);\n\nvoid readbathyASCHead(std::string filename, int &amp;nx, int &amp;ny, double &amp;dx, double &amp;xo, double &amp;yo, double &amp;grdalpha);\ntemplate &lt;class T&gt; void readbathyASCzb(std::string filename, int nx, int ny, T*&amp; zb);\n\ntemplate &lt;class T&gt; void InterpstepCPU(int nx, int ny, int hdstep, float totaltime, float hddt, T*&amp; Ux, T* Uo, T* Un);\n\ntemplate &lt;class T&gt; void clampedges(int nx, int ny, T clamp, T* z);\n\nstd::vector&lt;std::string&gt; DelimLine(std::string line, int n, char delim);\nstd::vector&lt;std::string&gt; DelimLine(std::string line, int n);\nPolygon readPolygon(std::string filename);\nPolygon readbndpolysegment(bndsegment bnd, Param XParam);\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/","title":"File ReadInput.cu","text":""},{"location":"BGFlood/ReadInput_8cu/#file-readinputcu","title":"File ReadInput.cu","text":"<p>FileList &gt; src &gt; ReadInput.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ReadInput.h\"</code></li> </ul>"},{"location":"BGFlood/ReadInput_8cu/#public-functions","title":"Public Functions","text":"Type Name void InitialiseToutput (T_output &amp; Toutput_loc, Param XParam)  std::vector&lt; double &gt; ReadTRangestr (std::vector&lt; std::string &gt; timestr, double start, double end, std::string reftime)  std::vector&lt; std::string &gt; ReadToutSTR (std::string paramstr)  std::vector&lt; double &gt; ReadToutput (std::vector&lt; std::string &gt; paramstr, Param XParam)  double ReadTvalstr (std::string timestr, double start, double end, std::string reftime)  void Readparamfile (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, std::string Paramfile)  std::size_t case_insensitive_compare (std::string s1, std::string s2)  std::size_t case_insensitive_compare (std::string s1, std::vector&lt; std::string &gt; vecstr)  void checkparamsanity (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing)  std::string findparameter (std::vector&lt; std::string &gt; parameterstr, std::string line)  std::string findparameter (std::string parameterstr, std::string line)  double readApproxtimestr (std::string input)  bndsegment readbndline (std::string parametervalue)  bndsegment readbndlineside (std::string parametervalue, std::string side)  T readfileinfo (std::string input, T outinfo)  template DynForcingP&lt; float &gt; readfileinfo&lt; DynForcingP&lt; float &gt; &gt; (std::string input, DynForcingP&lt; float &gt; outinfo)  template StaticForcingP&lt; float &gt; readfileinfo&lt; StaticForcingP&lt; float &gt; &gt; (std::string input, StaticForcingP&lt; float &gt; outinfo)  template deformmap&lt; float &gt; readfileinfo&lt; deformmap&lt; float &gt; &gt; (std::string input, deformmap&lt; float &gt; outinfo)  template forcingmap readfileinfo&lt; forcingmap &gt; (std::string input, forcingmap outinfo)  template inputmap readfileinfo&lt; inputmap &gt; (std::string input, inputmap outinfo)  bool readparambool (std::string paramstr, bool defaultval)  Param readparamstr (std::string line, Param param)  Forcing&lt; T &gt; readparamstr (std::string line, Forcing&lt; T &gt; forcing)  double setendtime (Param XParam, Forcing&lt; float &gt; XForcing)  void split (const std::string &amp; s, char delim, std::vector&lt; std::string &gt; &amp; elems)  std::vector&lt; std::string &gt; split (const std::string &amp; s, char delim)  std::vector&lt; std::string &gt; split (const std::string s, const std::string delim)  void split_full (const std::string &amp; s, char delim, std::vector&lt; std::string &gt; &amp; elems)  std::vector&lt; std::string &gt; split_full (const std::string &amp; s, char delim)  std::string trim (const std::string &amp; str, const std::string &amp; whitespace)"},{"location":"BGFlood/ReadInput_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/ReadInput_8cu/#function-initialisetoutput","title":"function InitialiseToutput","text":"<pre><code>void InitialiseToutput (\n    T_output &amp; Toutput_loc,\n    Param XParam\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-readtrangestr","title":"function ReadTRangestr","text":"<pre><code>std::vector&lt; double &gt; ReadTRangestr (\n    std::vector&lt; std::string &gt; timestr,\n    double start,\n    double end,\n    std::string reftime\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-readtoutstr","title":"function ReadToutSTR","text":"<pre><code>std::vector&lt; std::string &gt; ReadToutSTR (\n    std::string paramstr\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-readtoutput","title":"function ReadToutput","text":"<pre><code>std::vector&lt; double &gt; ReadToutput (\n    std::vector&lt; std::string &gt; paramstr,\n    Param XParam\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-readtvalstr","title":"function ReadTvalstr","text":"<pre><code>double ReadTvalstr (\n    std::string timestr,\n    double start,\n    double end,\n    std::string reftime\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-readparamfile","title":"function Readparamfile","text":"<pre><code>void Readparamfile (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    std::string Paramfile\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-case_insensitive_compare","title":"function case_insensitive_compare","text":"<pre><code>std::size_t case_insensitive_compare (\n    std::string s1,\n    std::string s2\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-case_insensitive_compare_1","title":"function case_insensitive_compare","text":"<pre><code>std::size_t case_insensitive_compare (\n    std::string s1,\n    std::vector&lt; std::string &gt; vecstr\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-checkparamsanity","title":"function checkparamsanity","text":"<pre><code>void checkparamsanity (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre> <p>Check the Sanity of both Param and Forcing class If required some parameter are infered </p>"},{"location":"BGFlood/ReadInput_8cu/#function-findparameter","title":"function findparameter","text":"<pre><code>std::string findparameter (\n    std::vector&lt; std::string &gt; parameterstr,\n    std::string line\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-findparameter_1","title":"function findparameter","text":"<pre><code>std::string findparameter (\n    std::string parameterstr,\n    std::string line\n) \n</code></pre> <p>separate parameter from value </p>"},{"location":"BGFlood/ReadInput_8cu/#function-readapproxtimestr","title":"function readApproxtimestr","text":"<pre><code>double readApproxtimestr (\n    std::string input\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-readbndline","title":"function readbndline","text":"<pre><code>bndsegment readbndline (\n    std::string parametervalue\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-readbndlineside","title":"function readbndlineside","text":"<pre><code>bndsegment readbndlineside (\n    std::string parametervalue,\n    std::string side\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-readfileinfo","title":"function readfileinfo","text":"<pre><code>template&lt;class T&gt;\nT readfileinfo (\n    std::string input,\n    T outinfo\n) \n</code></pre> <p>convert file name into name and extension This is used for various input classes</p> <p>template inputmap readfileinfo&lt;inputmap&gt;(std::string input, inputmap outinfo); template forcingmap readfileinfo&lt;forcingmap&gt;(std::string input, forcingmap outinfo); template StaticForcingP&lt;float&gt; readfileinfo&lt;StaticForcingP&lt;float&gt;&gt;(std::string input, StaticForcingP&lt;float&gt; outinfo); template DynForcingP&lt;float&gt; readfileinfo&lt;DynForcingP&lt;float&gt;&gt;(std::string input, DynForcingP&lt;float&gt; outinfo); template deformmap&lt;float&gt; readfileinfo&lt;deformmap&lt;float&gt;&gt;(std::string input, deformmap&lt;float&gt; outinfo); </p>"},{"location":"BGFlood/ReadInput_8cu/#function-readfileinfo-dynforcingp-float","title":"function readfileinfo&lt; DynForcingP&lt; float &gt; &gt;","text":"<pre><code>template DynForcingP &lt; float &gt; readfileinfo&lt; DynForcingP&lt; float &gt; &gt; (\n    std::string input,\n    DynForcingP &lt; float &gt; outinfo\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-readfileinfo-staticforcingp-float","title":"function readfileinfo&lt; StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template StaticForcingP &lt; float &gt; readfileinfo&lt; StaticForcingP&lt; float &gt; &gt; (\n    std::string input,\n    StaticForcingP &lt; float &gt; outinfo\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-readfileinfo-deformmap-float","title":"function readfileinfo&lt; deformmap&lt; float &gt; &gt;","text":"<pre><code>template deformmap &lt; float &gt; readfileinfo&lt; deformmap&lt; float &gt; &gt; (\n    std::string input,\n    deformmap &lt; float &gt; outinfo\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-readfileinfo-forcingmap","title":"function readfileinfo&lt; forcingmap &gt;","text":"<pre><code>template forcingmap readfileinfo&lt; forcingmap &gt; (\n    std::string input,\n    forcingmap outinfo\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-readfileinfo-inputmap","title":"function readfileinfo&lt; inputmap &gt;","text":"<pre><code>template inputmap readfileinfo&lt; inputmap &gt; (\n    std::string input,\n    inputmap outinfo\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-readparambool","title":"function readparambool","text":"<pre><code>bool readparambool (\n    std::string paramstr,\n    bool defaultval\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-readparamstr","title":"function readparamstr","text":"<pre><code>Param readparamstr (\n    std::string line,\n    Param param\n) \n</code></pre> <p>Read BG_param.txt line and convert parameter to the righ parameter in the class retrun an updated Param class </p>"},{"location":"BGFlood/ReadInput_8cu/#function-readparamstr_1","title":"function readparamstr","text":"<pre><code>template&lt;class T&gt;\nForcing &lt; T &gt; readparamstr (\n    std::string line,\n    Forcing &lt; T &gt; forcing\n) \n</code></pre> <p>Read BG_param.txt line and convert parameter to the righ parameter in the class return an updated Param class </p>"},{"location":"BGFlood/ReadInput_8cu/#function-setendtime","title":"function setendtime","text":"<pre><code>double setendtime (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing\n) \n</code></pre> <p>Calculate/modify endtime based on maximum time in forcing </p>"},{"location":"BGFlood/ReadInput_8cu/#function-split","title":"function split","text":"<pre><code>void split (\n    const std::string &amp; s,\n    char delim,\n    std::vector&lt; std::string &gt; &amp; elems\n) \n</code></pre> <p>split string based in character </p>"},{"location":"BGFlood/ReadInput_8cu/#function-split_1","title":"function split","text":"<pre><code>std::vector&lt; std::string &gt; split (\n    const std::string &amp; s,\n    char delim\n) \n</code></pre> <p>split string based in character </p>"},{"location":"BGFlood/ReadInput_8cu/#function-split_2","title":"function split","text":"<pre><code>std::vector&lt; std::string &gt; split (\n    const std::string s,\n    const std::string delim\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8cu/#function-split_full","title":"function split_full","text":"<pre><code>void split_full (\n    const std::string &amp; s,\n    char delim,\n    std::vector&lt; std::string &gt; &amp; elems\n) \n</code></pre> <p>split string based in character, conserving empty item </p>"},{"location":"BGFlood/ReadInput_8cu/#function-split_full_1","title":"function split_full","text":"<pre><code>std::vector&lt; std::string &gt; split_full (\n    const std::string &amp; s,\n    char delim\n) \n</code></pre> <p>split string based in character, conserving empty items </p>"},{"location":"BGFlood/ReadInput_8cu/#function-trim","title":"function trim","text":"<pre><code>std::string trim (\n    const std::string &amp; str,\n    const std::string &amp; whitespace\n) \n</code></pre> <p>remove leading and trailing space in a string </p> <p>The documentation for this class was generated from the following file <code>src/ReadInput.cu</code></p>"},{"location":"BGFlood/ReadInput_8cu_source/","title":"File ReadInput.cu","text":""},{"location":"BGFlood/ReadInput_8cu_source/#file-readinputcu","title":"File ReadInput.cu","text":"<p>File List &gt; src &gt; ReadInput.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //    \n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n#include \"ReadInput.h\"\n\n// Collection of functions to read input to the model\n\n\ntemplate &lt;class T&gt; T readfileinfo(std::string input, T outinfo)\n{\n    // Outinfo is based on an inputmap (or it's sub classes)\n\n    //filename include the file extension\n\n    std::vector&lt;std::string&gt; extvec = split(input, '.');\n\n    //outinfo.inputfile = extvec.front();\n\n    std::vector&lt;std::string&gt; nameelements, filename;\n    //\n    nameelements = split(extvec.back(), '?');\n\n    filename = split(input, '?');\n    if (nameelements.size() &gt; 1)\n    {\n        //variable name for bathy is not given so it is assumed to be zb\n        outinfo.extension = nameelements[0];\n        outinfo.varname = nameelements.back();\n\n    }\n    else\n    {\n        outinfo.extension = extvec.back();\n        outinfo.varname = \"z\";\n    }\n\n    //Reconstruct filename with extension but without varname\n    //outinfo.inputfile = extvec.front() + \".\" + outinfo.extension;\n    outinfo.inputfile = filename.front();\n\n    return outinfo;\n}\n\ntemplate inputmap readfileinfo&lt;inputmap&gt;(std::string input, inputmap outinfo);\ntemplate forcingmap readfileinfo&lt;forcingmap&gt;(std::string input, forcingmap outinfo);\ntemplate StaticForcingP&lt;float&gt; readfileinfo&lt;StaticForcingP&lt;float&gt;&gt;(std::string input, StaticForcingP&lt;float&gt; outinfo);\ntemplate DynForcingP&lt;float&gt; readfileinfo&lt;DynForcingP&lt;float&gt;&gt;(std::string input, DynForcingP&lt;float&gt; outinfo);\ntemplate deformmap&lt;float&gt; readfileinfo&lt;deformmap&lt;float&gt;&gt;(std::string input, deformmap&lt;float&gt; outinfo);\n\n\n\n\nvoid Readparamfile(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing, std::string Paramfile)\n{\n    //\n    log(\"\\nReading parameter file: \" + Paramfile + \" ...\");\n    //std::ifstream fs(\"BG_param.txt\");\n    std::ifstream fs(Paramfile);\n\n    if (fs.fail()) {\n        //std::cerr &lt;&lt; \"BG_param.txt file could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: BG_param.txt file could not be opened...use this log file to create a file named BG_param.txt\");\n        SaveParamtolog(XParam);\n\n        exit(1);\n\n    }\n    else\n    {\n        // Read and interpret each line of the BG_param.txt\n        std::string line;\n        while (std::getline(fs, line))\n        {\n\n            //Get param or skip empty lines\n            if (!line.empty() &amp;&amp; line.substr(0, 1).compare(\"#\") != 0)\n            {\n                XParam = readparamstr(line, XParam);\n                XForcing = readparamstr(line, XForcing);\n\n                //std::cout &lt;&lt; line &lt;&lt; std::endl;\n            }\n\n        }\n        fs.close();\n\n\n    }\n\n}\n\n\n\n\n\nParam readparamstr(std::string line, Param param)\n{\n\n\n    std::string parameterstr, parametervalue;\n    std::vector&lt;std::string&gt; paramvec;\n    // General parameters\n    //\n\n    parameterstr = \"test\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.test = std::stoi(parametervalue);\n    }\n\n    paramvec = { \"GPUDEVICE\",\"gpu\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.GPUDEVICE = std::stoi(parametervalue);\n    }\n\n    parameterstr = \"doubleprecision\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.doubleprecision = std::stoi(parametervalue);\n    }\n\n    parameterstr = \"engine\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        std::vector&lt;std::string&gt; buttingerstr = { \"b\",\"butt\",\"buttinger\",\"1\" };\n        std::size_t found;\n        bool foo = false;\n        for (int ii = 0; ii &lt; buttingerstr.size(); ii++)\n        {\n            found = case_insensitive_compare(parametervalue, buttingerstr[ii]);// it needs to strictly compare\n            if (found == 0)\n            {\n                param.engine = 1;\n                foo = true;\n            }\n\n        }\n        if (!foo)\n        {\n            param.engine = 5;\n        }\n    }\n    // Adaptation\n    //\n    parameterstr = \"maxlevel\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.maxlevel = std::stoi(parametervalue);\n    }\n\n    parameterstr = \"minlevel\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.minlevel = std::stoi(parametervalue);\n    }\n\n    parameterstr = \"initlevel\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.initlevel = std::stoi(parametervalue);\n    }\n\n    paramvec = { \"adaptmaxiteration\",\"maxiterationadapt\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.adaptmaxiteration = std::stoi(parametervalue);\n    }\n\n    parameterstr = \"conserveElevation\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.conserveElevation = readparambool(parametervalue, param.conserveElevation);\n    }\n\n    paramvec = { \"wetdryfix\",\"reminstab\",\"fixinstab\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n\n        param.wetdryfix = readparambool(parametervalue, param.wetdryfix);\n\n    }\n\n\n    parameterstr = \"membuffer\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.membuffer = std::stod(parametervalue);\n    }\n\n    // Flow parameters\n    //\n    parameterstr = \"eps\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.eps = std::stod(parametervalue);\n    }\n\n    paramvec = { \"cf\",\"roughness\",\"cfmap\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        if (std::any_of(parametervalue.begin(), parametervalue.end(), ::isalpha) == false) //(std::isdigit(parametervalue[0]) == true)\n        {\n            param.cf = std::stod(parametervalue);\n        }\n    }\n\n    paramvec = { \"il\",\"Rain_il\",\"initialloss\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        if (std::any_of(parametervalue.begin(), parametervalue.end(), ::isalpha) == false) //(std::isdigit(parametervalue[0]) == true)\n        {\n            param.il = std::stod(parametervalue);\n            param.infiltration = true;\n        }\n    }\n\n    paramvec = { \"cl\",\"Rain_cl\",\"continuousloss\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        if (std::any_of(parametervalue.begin(), parametervalue.end(), ::isalpha) == false) //(std::isdigit(parametervalue[0]) == true)\n        {\n            param.cl = std::stod(parametervalue);\n            param.infiltration = true;\n        }\n    }\n\n    paramvec = { \"VelThreshold\",\"vthresh\",\"vmax\",\"velmax\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.VelThreshold = std::stod(parametervalue);\n    }\n\n    parameterstr = \"Cd\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.Cd = std::stod(parametervalue);\n    }\n\n    parameterstr = \"Pa2m\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.Pa2m = std::stod(parametervalue);\n    }\n\n    parameterstr = \"Paref\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.Paref = std::stod(parametervalue);\n    }\n\n    parameterstr = \"mask\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.mask = std::stod(parametervalue);\n    }\n\n    // Timekeeping parameters\n    //\n    parameterstr = \"dt\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.dt = std::stod(parametervalue);\n\n    }\n\n    parameterstr = \"dtmin\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.dtmin = std::stod(parametervalue);\n\n    }\n    parameterstr = \"bndtaper\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.bndtaper = std::stod(parametervalue);\n\n    }\n\n    parameterstr = \"bndrelaxtime\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.bndrelaxtime = std::stod(parametervalue);\n\n    }\n    parameterstr = \"bndfiltertime\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.bndfiltertime = std::stod(parametervalue);\n\n    }\n\n\n    paramvec = { \"aoibnd\",\"remainderbnd\",\"remainbndtype\",\"aoibndtype\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.aoibnd = std::stoi(parametervalue);\n    }\n\n\n    parameterstr = \"CFL\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.CFL = std::stod(parametervalue);\n\n    }\n    parameterstr = \"theta\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.theta = std::stod(parametervalue);\n\n    }\n\n    paramvec = { \"outputtimestep\",\"outtimestep\",\"outputstep\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.outputtimestep = std::stod(parametervalue);\n\n    }\n\n    paramvec = { \"endtime\", \"stoptime\", \"end\", \"stop\",\"end_time\",\"stop_time\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.endtime = readinputtimetxt(parametervalue, param.reftime);\n\n    }\n\n    paramvec = { \"totaltime\",\"inittime\",\"starttime\", \"start_time\", \"init_time\", \"start\", \"init\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        //param.totaltime = std::stod(parametervalue);\n        param.totaltime = readinputtimetxt(parametervalue, param.reftime);\n\n    }\n\n    paramvec = { \"MassConservation\", \"MassCon\",\"forcemassconservation\",\"forcevolumeconservation\",\"Volumeconservation\",\"VolumeCon\", \"ForceMassConserve\", \"ForceVolConserve\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        //param.totaltime = std::stod(parametervalue);\n        param.totaltime = readinputtimetxt(parametervalue, param.reftime);\n        param.ForceMassConserve = readparambool(parametervalue, param.ForceMassConserve);\n\n    }\n\n\n    parameterstr = \"dtinit\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.dtinit = std::stod(parametervalue);\n\n    }\n\n    paramvec = { \"reftime\",\"referencetime\",\"timeref\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        if (param.reftime.empty())\n        {\n            param.reftime = parametervalue;\n        }\n\n    }\n\n    // Input and output files\n    //\n\n    parameterstr = \"outfile\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.outfile = parametervalue;\n\n    }\n\n\n    // Below is a bit more complex than usual because more than 1 node can be outputed as a timeseries\n    paramvec = { \"TSnodesout\",\"TSOutput\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        TSoutnode node;\n        std::vector&lt;std::string&gt; nodeitems = split(parametervalue, ',');\n        if (nodeitems.size() &gt;= 3)\n        {\n            node.outname = nodeitems[0];\n            node.x = std::stod(nodeitems[1]);\n            node.y = std::stod(nodeitems[2]);\n\n            param.TSnodesout.push_back(node);\n        }\n        else\n        {\n            std::cerr &lt;&lt; \"Node input failed there should be 3 arguments (comma separated) when inputing a outout node: TSOutput = filename, xvalue, yvalue; see log file for details\" &lt;&lt; std::endl;\n\n            log(\"Node input failed there should be 3 arguments (comma separated) when inputing a outout node: TSOutput = filename, xvalue, yvalue; see log file for details. Input was: \" + parametervalue);\n\n        }\n\n    }\n\n\n\n    //outvars\n    parameterstr = \"outvars\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        std::vector&lt;std::string&gt; vars = split(parametervalue, ',');\n        for (int nv = 0; nv &lt; vars.size(); nv++)\n        {\n            //Verify that the variable name makes sense?\n            //Need to add more here\n\n\n            std::vector&lt;std::string&gt; SupportedVarNames = { \"zb\",\"zs\",\"u\",\"v\",\"h\",\"hmean\",\"zsmean\",\"umean\",\"vmean\",\"hUmean\",\"Umean\",\"hmax\",\"zsmax\",\"umax\",\"vmax\",\"hUmax\",\"Umax\",\"twet\",\"dhdx\",\"dhdy\",\"dzsdx\",\"dzsdy\",\"dzbdx\",\"dzbdy\",\"dudx\",\"dudy\",\"dvdx\",\"dvdy\",\"Fhu\",\"Fhv\",\"Fqux\",\"Fqvy\",\"Fquy\",\"Fqvx\",\"Su\",\"Sv\",\"dh\",\"dhu\",\"dhv\",\"cf\",\"Patm\",\"datmpdx\",\"datmpdy\",\"il\",\"cl\",\"hgw\",\"hu\",\"hv\",\"hfu\" ,\"hfv\",\"hau\",\"hav\",\"Fux\",\"Fvx\",\"Fuy\",\"Fvy\" };\n\n\n            std::string vvar = trim(vars[nv], \" \");\n            for (int isup = 0; isup &lt; SupportedVarNames.size(); isup++)\n            {\n\n                //std::cout &lt;&lt; \"...\" &lt;&lt; vvar &lt;&lt; \"...\" &lt;&lt; std::endl;\n                if (vvar.compare(SupportedVarNames[isup]) == 0)\n                {\n                    param.outvars.push_back(vvar);\n                    break;\n                }\n\n            }\n\n            param.outmean = (vvar.compare(\"hmean\") == 0) ? true : param.outmean;\n            param.outmean = (vvar.compare(\"zsmean\") == 0) ? true : param.outmean;\n            param.outmean = (vvar.compare(\"umean\") == 0) ? true : param.outmean;\n            param.outmean = (vvar.compare(\"vmean\") == 0) ? true : param.outmean;\n            param.outmean = (vvar.compare(\"Umean\") == 0) ? true : param.outmean;\n            param.outmean = (vvar.compare(\"hUmean\") == 0) ? true : param.outmean;\n\n            param.outmax = (vvar.compare(\"hmax\") == 0) ? true : param.outmax;\n            param.outmax = (vvar.compare(\"zsmax\") == 0) ? true : param.outmax;\n            param.outmax = (vvar.compare(\"umax\") == 0) ? true : param.outmax;\n            param.outmax = (vvar.compare(\"vmax\") == 0) ? true : param.outmax;\n            param.outmax = (vvar.compare(\"Umax\") == 0) ? true : param.outmax;\n            param.outmax = (vvar.compare(\"hUmax\") == 0) ? true : param.outmax;\n\n            param.outtwet = (vvar.compare(\"twet\") == 0) ? true : param.outtwet;\n\n            //param.outvort = (vvar.compare(\"vort\") == 0) ? true : param.outvort;\n            //param.outU = (vvar.compare(\"U\") == 0) ? true : param.outU;\n        }\n\n\n\n    }\n\n\n    // Same as for TSnodesout, the same key word can be used for different zones Output\n    parameterstr = \"outzone\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        outzoneP zone;\n        std::vector&lt;std::string&gt; zoneitems = split(parametervalue, ',');\n        if (zoneitems.size() &gt;= 5)\n        {\n            zone.outname = zoneitems[0];\n            zone.xstart = std::stod(zoneitems[1]);\n            zone.xend = std::stod(zoneitems[2]);\n            zone.ystart = std::stod(zoneitems[3]);\n            zone.yend = std::stod(zoneitems[4]);\n        }\n        if (zoneitems.size() &gt; 5)\n        {\n            // concatenate 5,6,.... together\n            std::string constr;\n\n            for (int ist = 5; ist &lt; zoneitems.size(); ist++)\n            {\n                constr = constr + zoneitems[ist];\n                if (ist &lt; (zoneitems.size() - 1))\n                {\n                    constr = constr + \",\";\n                }\n\n            }\n            zone.Toutput.inputstr = ReadToutSTR(constr);\n\n\n        }\n        else if (zoneitems.size() == 5)//No time input in the zone area\n        {\n            zone.Toutput.inputstr = ReadToutSTR(\"\"); // Thats needs to move to sanity check\n        }\n        else\n        {\n            std::cerr &lt;&lt; \"Zone input failed there should be at least 5 arguments (comma separated) when inputing a outout zone: outzone = filename, xstart, xend, ystart, yend; see log file for details\" &lt;&lt; std::endl;\n            log(\"Node input failed there should be at least 5 arguments (comma separated) when inputing a outout zone: outzone = filename, xstart, xend, ystart, yend; see log file for details (with possibly some time inputs after). Input was: \" + parametervalue);\n        }\n        param.outzone.push_back(zone);\n    }\n\n    parameterstr = \"resetmax\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        if (std::stoi(parametervalue) == 1)\n        {\n            param.resetmax = true;\n        }\n    }\n\n    // WARNING FOR DEBUGGING PURPOSE ONLY\n    // For debugging one can shift the output by 1 or -1 in the i and j direction.\n    // this will save the value in the halo to the output file allowing debugging of values there.\n    parameterstr = \"outishift\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.outishift = std::stoi(parametervalue);\n    }\n    parameterstr = \"outjshift\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.outjshift = std::stoi(parametervalue);\n    }\n\n\n\n    parameterstr = \"nx\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.nx = std::stoi(parametervalue);\n    }\n\n    parameterstr = \"ny\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.ny = std::stoi(parametervalue);\n    }\n\n    parameterstr = \"dx\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.dx = std::stod(parametervalue);\n    }\n\n    parameterstr = \"grdalpha\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.grdalpha = std::stod(parametervalue);\n    }\n\n    paramvec = { \"xo\",\"xmin\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.xo = std::stod(parametervalue);\n    }\n\n    paramvec = { \"yo\",\"ymin\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.yo = std::stod(parametervalue);\n    }\n\n    parameterstr = \"xmax\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.xmax = std::stod(parametervalue);\n    }\n\n    parameterstr = \"ymax\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.ymax = std::stod(parametervalue);\n    }\n\n    parameterstr = \"g\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.g = std::stod(parametervalue);\n\n    }\n\n    parameterstr = \"rho\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.rho = std::stod(parametervalue);\n    }\n\n    parameterstr = \"smallnc\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.smallnc = std::stoi(parametervalue);\n    }\n    parameterstr = \"scalefactor\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.scalefactor = std::stof(parametervalue);\n    }\n    parameterstr = \"addoffset\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.addoffset = std::stof(parametervalue);\n    }\n    parameterstr = \"posdown\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.posdown = std::stoi(parametervalue);\n    }\n\n#ifdef USE_CATALYST\n    parameterstr = \"use_catalyst\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.use_catalyst = std::stoi(parametervalue);\n    }\n    parameterstr = \"catalyst_python_pipeline\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.catalyst_python_pipeline = std::stoi(parametervalue);\n    }\n    parameterstr = \"vtk_output_frequency\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.vtk_output_frequency = std::stoi(parametervalue);\n    }\n    parameterstr = \"vtk_output_time_interval\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.vtk_output_time_interval = std::stod(parametervalue);\n    }\n    parameterstr = \"vtk_outputfile_root\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.vtk_outputfile_root = parametervalue;\n    }\n    parameterstr = \"python_pipeline\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.python_pipeline = parametervalue;\n    }\n#endif\n\n    paramvec = { \"zsinit\", \"initzs\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.zsinit = std::stod(parametervalue);\n    }\n\n    parameterstr = \"zsoffset\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.zsoffset = std::stod(parametervalue);\n    }\n    paramvec = { \"rainbnd\", \"rainonbnd\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.rainbnd = readparambool(parametervalue, param.rainbnd);\n\n    }\n\n\n    parameterstr = \"hotstartfile\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.hotstartfile = parametervalue;\n\n    }\n\n    parameterstr = \"hotstep\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.hotstep = std::stoi(parametervalue);\n    }\n\n\n    paramvec = { \"spherical\", \"geo\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.spherical = readparambool(parametervalue, param.spherical);\n    }\n\n    parameterstr = \"Radius\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.Radius = std::stod(parametervalue);\n    }\n\n    parameterstr = \"frictionmodel\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.frictionmodel = std::stoi(parametervalue);\n    }\n\n    parameterstr = \"Adaptation\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        std::vector&lt;std::string&gt; adaptpar = split(parametervalue, ',');\n\n        if (!adaptpar.empty())\n        {\n            param.AdaptCrit = adaptpar[0];\n            if (adaptpar.size() &gt; 1)\n                param.Adapt_arg1 = adaptpar[1];\n            if (adaptpar.size() &gt; 2)\n                param.Adapt_arg2 = adaptpar[2];\n            if (adaptpar.size() &gt; 3)\n                param.Adapt_arg3 = adaptpar[3];\n            if (adaptpar.size() &gt; 4)\n                param.Adapt_arg4 = adaptpar[4];\n            if (adaptpar.size() &gt; 5)\n                param.Adapt_arg5 = adaptpar[5];\n        }\n    }\n\n    paramvec = { \"crs\", \"spatialref\", \"spatial_ref\", \"wtk\", \"crsinfo\",\"crs_info\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.crs_ref = parametervalue;\n    }\n\n    //Read Flexible Toutput variable\n    parameterstr = \"Toutput\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.Toutput.inputstr = ReadToutSTR(parametervalue);\n    }\n\n    paramvec = { \"savebyblk\", \"writebyblk\",\"saveperblk\", \"writeperblk\",\"savebyblock\", \"writebyblock\",\"saveperblock\", \"writeperblock\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.savebyblk = readparambool(parametervalue, param.savebyblk);\n    }\n\n    return param;\n}\n\n\n\ntemplate &lt;class T&gt;\nForcing&lt;T&gt; readparamstr(std::string line, Forcing&lt;T&gt; forcing)\n{\n    std::string parameterstr, parametervalue;\n    std::vector&lt;std::string&gt; paramvec;\n\n    paramvec = { \"Bathy\",\"bathyfile\",\"bathymetry\",\"depfile\",\"depthfile\",\"topofile\",\"topo\",\"DEM\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        StaticForcingP&lt;float&gt; infobathy;\n        forcing.Bathy.push_back(readfileinfo(parametervalue, infobathy));\n        //std::cerr &lt;&lt; \"Bathymetry file found!\" &lt;&lt; std::endl;\n    }\n\n\n\n    paramvec = { \"AOI\",\"aoipoly\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        forcing.AOI.file = parametervalue;\n        forcing.AOI.active = true;\n    }\n\n    /*parameterstr = \"bathyfile\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        StaticForcingP&lt;float&gt; infobathy;\n        forcing.Bathy.push_back(readfileinfo(parametervalue, infobathy));\n        //forcing.Bathy = readfileinfo(parametervalue, forcing.Bathy);\n        //std::cerr &lt;&lt; \"Bathymetry file found!\" &lt;&lt; std::endl;\n    }\n\n    parameterstr = \"bathymetry\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        StaticForcingP&lt;float&gt; infobathy;\n        forcing.Bathy.push_back(readfileinfo(parametervalue, infobathy));\n        //forcing.Bathy = readfileinfo(parametervalue, forcing.Bathy);\n        //std::cerr &lt;&lt; \"Bathymetry file found!\" &lt;&lt; std::endl;\n    }\n\n    //\n    parameterstr = \"depfile\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        StaticForcingP&lt;float&gt; infobathy;\n        forcing.Bathy.push_back(readfileinfo(parametervalue, infobathy));\n        //forcing.Bathy = readfileinfo(parametervalue, forcing.Bathy);\n    }*/\n\n\n    // Boundaries\n\n    paramvec = { \"left\",\"leftbndfile\",\"leftbnd\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        //forcing.left = readbndline(parametervalue);\n        forcing.bndseg.push_back(readbndlineside(parametervalue, \"left\"));\n\n\n\n    }\n\n    paramvec = { \"right\",\"rightbndfile\",\"rightbnd\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        //forcing.right = readbndline(parametervalue);\n        forcing.bndseg.push_back(readbndlineside(parametervalue, \"right\"));\n\n    }\n\n    paramvec = { \"top\",\"topbndfile\",\"topbnd\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        //forcing.top = readbndline(parametervalue);\n        forcing.bndseg.push_back(readbndlineside(parametervalue, \"top\"));\n    }\n\n    paramvec = { \"bot\",\"botbndfile\",\"botbnd\",\"bottom\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        //forcing.bot = readbndline(parametervalue);\n        forcing.bndseg.push_back(readbndlineside(parametervalue, \"bot\"));\n    }\n\n    paramvec = { \"bnd\",\"bndseg\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        //forcing.bot = readbndline(parametervalue);\n        forcing.bndseg.push_back(readbndline(parametervalue));\n    }\n\n\n    //Tsunami deformation input files\n    parameterstr = \"deform\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n\n        deformmap&lt;float&gt; thisdeform;\n        std::vector&lt;std::string&gt; items = split(parametervalue, ',');\n        //Need sanity check here\n        thisdeform = readfileinfo(items[0], thisdeform);\n        //thisdeform.inputfile = items[0];\n        if (items.size() &gt; 1)\n        {\n            thisdeform.startime = std::stod(items[1]);\n\n        }\n        if (items.size() &gt; 2)\n        {\n            thisdeform.duration = std::stod(items[2]);\n\n        }\n\n        forcing.deform.push_back(thisdeform);\n\n    }\n\n    //Tsunami deformation input files\n    parameterstr = \"cavity\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n\n        deformmap&lt;float&gt; thisdeform;\n\n        thisdeform.iscavity = true;\n        std::vector&lt;std::string&gt; items = split(parametervalue, ',');\n        //Need sanity check here\n        thisdeform = readfileinfo(items[0], thisdeform);\n        //thisdeform.inputfile = items[0];\n        if (items.size() &gt; 1)\n        {\n            thisdeform.startime = std::stod(items[1]);\n\n        }\n        if (items.size() &gt; 2)\n        {\n            thisdeform.duration = std::stod(items[2]);\n\n        }\n\n        forcing.deform.push_back(thisdeform);\n\n    }\n\n    //River\n    paramvec = { \"rivers\",\"river\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        std::vector&lt;std::string&gt; vars = split(parametervalue, ',');\n        if (vars.size() == 5)\n        {\n            River thisriver;\n            thisriver.Riverflowfile = trim(vars[0], \" \");\n            thisriver.xstart = std::stod(vars[1]);\n            thisriver.xend = std::stod(vars[2]);\n            thisriver.ystart = std::stod(vars[3]);\n            thisriver.yend = std::stod(vars[4]);\n\n            forcing.rivers.push_back(thisriver);\n        }\n        else\n        {\n            //Failed there should be 5 arguments (comma separated) when inputing a river: filename, xstart,xend,ystart,yend;\n            std::cerr &lt;&lt; \"River input failed there should be 5 arguments (comma separated) when inputing a river: river = filename, xstart,xend,ystart,yend; see log file for details\" &lt;&lt; std::endl;\n\n            log(\"River input below failed there should be 5 arguments (comma separated) when inputing a river: river = filename, xstart,xend,ystart,yend;\");\n            log(parametervalue);\n        }\n    }\n\n    // friction coefficient (mapped or constant)\n    // if it is a constant no-need to do anything below but if it is a file it overwrites any other value\n    paramvec = { \"cf\",\"roughness\",\"cfmap\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        if (std::any_of(parametervalue.begin(), parametervalue.end(), ::isalpha)) //(std::isdigit(parametervalue[0]) == false)\n        {\n            //forcing.cf = readfileinfo(parametervalue, forcing.cf);\n            StaticForcingP&lt;float&gt; infoRoughness;\n            forcing.cf.push_back(readfileinfo(parametervalue, infoRoughness));\n        }\n    }\n\n\n    //if (!parametervalue.empty())\n    //{\n    //\n        //std::cerr &lt;&lt; \"Bathymetry file found!\" &lt;&lt; std::endl;\n    //}\n\n    // Rain losses, initial and continuous loss\n    paramvec = { \"il\",\"Rain_il\",\"initialloss\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        if (std::any_of(parametervalue.begin(), parametervalue.end(), ::isalpha)) //(std::isdigit(parametervalue[0]) == false)\n        {\n            forcing.il = readfileinfo(parametervalue, forcing.il);\n        }\n    }\n    paramvec = { \"cl\",\"Rain_cl\",\"continuousloss\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        if (std::any_of(parametervalue.begin(), parametervalue.end(), ::isalpha)) //(std::isdigit(parametervalue[0]) == false)\n        {\n            forcing.cl = readfileinfo(parametervalue, forcing.cl);\n        }\n    }\n\n    // wind forcing\n    paramvec = { \"Wind\",\"windfiles\" }; //## forcing.Wind\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n\n        std::vector&lt;std::string&gt; vars = split(parametervalue, ',');\n        if (vars.size() == 2)\n        {\n            // If 2 parameters (files) are given then 1st file is U wind and second is V wind.\n            // This is for variable winds no rotation of the data is performed\n\n            forcing.UWind = readfileinfo(trim(vars[0], \" \"), forcing.UWind);\n            forcing.VWind = readfileinfo(trim(vars[1], \" \"), forcing.VWind);\n        }\n        else if (vars.size() == 1)\n        {\n            // if 1 parameter(file) is given then a 3 column file is expected showing time windspeed and direction\n            // wind direction is rotated (later) to the grid direction (via grdalpha)\n            forcing.UWind = readfileinfo(parametervalue, forcing.UWind);\n            forcing.UWind.uniform = 1;\n\n            //apply the same for Vwind? seem unecessary but need to be careful later in the code\n        }\n        else\n        {\n            //Failed there should be 5 arguments (comma separated) when inputing a river: filename, xstart,xend,ystart,yend;\n            //std::cerr &lt;&lt; \"Wind input failed there should be 2 arguments (comma separated) when inputing a wind: windfiles = windfile.nc?uwind, windfile.nc?vwind; see log file for details\" &lt;&lt; std::endl;\n\n            log(\"Wind input failed there should be 2 arguments(comma separated) when inputing a wind : windfiles = windfile.nc ? uwind, windfile.nc ? vwind; see log file for details\");\n            log(parametervalue);\n        }\n\n    }\n\n    // atmospheric pressure forcing\n    paramvec = { \"Atmp\",\"atmpfile\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        // needs to be a netcdf file \n        forcing.Atmp = readfileinfo(parametervalue, forcing.Atmp);\n\n    }\n\n    // rain forcing\n    paramvec = { \"Rain\",\"rainfile\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        // netcdf file == Variable spatially\n        // txt file (other than .nc) == spatially cst (txt file with 2 col time and mmm/h )\n        forcing.Rain = readfileinfo(parametervalue, forcing.Rain);\n\n        //set the expected type of input\n\n        if (forcing.Rain.extension.compare(\"nc\") == 0)\n        {\n            forcing.Rain.uniform = 0;\n        }\n        else\n        {\n            forcing.Rain.uniform = 1;\n        }\n\n    }\n\n    parameterstr = \"Adaptation\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        std::vector&lt;std::string&gt; adaptpar = split(parametervalue, ',');\n        // special case for 'Targetlevel' adaptation\n        if (!adaptpar.empty())\n        {\n            //if (adaptpar[0].compare(\"Targetlevel\") == 0)\n            if (case_insensitive_compare(adaptpar[0], std::string(\"Targetlevel\")) == 0)\n            {\n                for (int ng = 1; ng &lt; adaptpar.size(); ng++)\n                {\n                    StaticForcingP&lt;int&gt; infogrid;\n                    forcing.targetadapt.push_back(readfileinfo(adaptpar[ng], infogrid));\n                }\n            }\n        }\n\n    }\n\n    return forcing;\n}\n\n\nvoid checkparamsanity(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing)\n{\n    Param DefaultParams;\n\n    double tiny = 0.0000001;\n\n    // Sanity check for model levels\n    int minlev = XParam.minlevel;\n    int maxlev = XParam.maxlevel;\n\n    if (minlev == -99999)\n    {\n        minlev = XParam.initlevel;\n    }\n    if (maxlev == -99999)\n    {\n        maxlev = XParam.initlevel;\n    }\n\n    XParam.maxlevel = utils::max(maxlev, minlev);\n    XParam.minlevel = utils::min(maxlev, minlev);\n\n    XParam.initlevel = utils::min(utils::max(XParam.minlevel, XParam.initlevel), XParam.maxlevel);\n\n    //force double for Rain on grid cases\n    if (!XForcing.Rain.inputfile.empty())\n    {\n        XParam.doubleprecision = 1;\n    }\n\n    XParam.blkmemwidth = XParam.blkwidth + 2 * XParam.halowidth;\n    XParam.blksize = utils::sq(XParam.blkmemwidth);\n\n    // zsoffset\n\n    XParam.zsoffset = std::isnan(XParam.zsoffset) ? 0.0 : XParam.zsoffset;\n\n    //  Read Bathy Information\n\n    //this sets xo yo  etc...\n\n    // Any of xo,yo,xmax,ymax or dx not defined is assigned the value from bathy file\n    //default value is nan in default param file\n\n    //inputmap Bathymetry;\n    //Bathymetry.inputfile = XForcing.Bathy.inputfile;\n    //XForcing.Bathy = readforcinghead(XForcing.Bathy);\n\n\n\n    if (std::isnan(XParam.xo))\n        XParam.xo = XForcing.Bathy[0].xo - (0.5 * XForcing.Bathy[0].dx);\n    if (std::isnan(XParam.xmax))\n        XParam.xmax = XForcing.Bathy[0].xmax + (0.5 * XForcing.Bathy[0].dx);\n    if (std::isnan(XParam.yo))\n        XParam.yo = XForcing.Bathy[0].yo - (0.5 * XForcing.Bathy[0].dx);\n    if (std::isnan(XParam.ymax))\n        XParam.ymax = XForcing.Bathy[0].ymax + (0.5 * XForcing.Bathy[0].dx);\n\n    if (std::isnan(XParam.dx))\n        XParam.dx = XForcing.Bathy[0].dx;\n\n    if (std::isnan(XParam.grdalpha))\n        XParam.grdalpha = XForcing.Bathy[0].grdalpha; // here the default bathy grdalpha is 0.0 as defined by inputmap/Bathymetry class\n\n\n    //Check Bathy input type\n    if (XForcing.Bathy[0].extension.compare(\"dep\") == 0 || XForcing.Bathy[0].extension.compare(\"bot\") == 0)\n    {\n        if (std::isnan(XParam.dx))\n        {\n            //std::cerr &lt;&lt; \"FATAL ERROR: nx or ny or dx were not specified. These parameters are required when using .\" &lt;&lt; bathyext &lt;&lt; \" file\" &lt;&lt; std::endl;\n            log(\"FATAL ERROR: nx or ny or dx were not specified. These parameters are required when using .\" + XForcing.Bathy[0].extension + \" file\");\n            exit(1);\n        }\n    }\n\n    double levdx = calcres(XParam.dx, XParam.initlevel);// true grid resolution as in dx/2^(initlevel)\n    //printf(\"levdx=%f;1 &lt;&lt; XParam.initlevel=%f\\n\", levdx, calcres(1.0, XParam.initlevel));\n\n    // First estimate nx and ny\n    XParam.nx = ftoi((XParam.xmax - XParam.xo) / (levdx));\n    XParam.ny = ftoi((XParam.ymax - XParam.yo) / (levdx)); //+1?\n    //if desire size in one direction is under the bathy resolution or dx requested\n    if (XParam.nx == 0) { XParam.nx = 1; }\n    if (XParam.ny == 0) { XParam.ny = 1; }\n\n\n    // Adjust xmax and ymax so that nx and ny are a factor of XParam.blkwidth [16]\n    XParam.xmax = XParam.xo + (ceil(XParam.nx / ((double)XParam.blkwidth)) * ((double)XParam.blkwidth)) * levdx;\n    XParam.ymax = XParam.yo + (ceil(XParam.ny / ((double)XParam.blkwidth)) * ((double)XParam.blkwidth)) * levdx;\n\n    // Update nx and ny \n    XParam.nx = ftoi((XParam.xmax - XParam.xo) / (levdx));\n    XParam.ny = ftoi((XParam.ymax - XParam.yo) / (levdx)); //+1?\n\n    log(\"\\nAdjusted model domain (xo/xmax/yo/ymax): \");\n    log(\"\\t\" + std::to_string(XParam.xo) + \"/\" + std::to_string(XParam.xmax) + \"/\" + std::to_string(XParam.yo) + \"/\" + std::to_string(XParam.ymax));\n    log(\"\\t Initial resolution (level \" + std::to_string(XParam.initlevel) + \") = \" + std::to_string(levdx));\n\n    if (XParam.spherical == false)\n    {\n        XParam.delta = XParam.dx;\n        XParam.grdalpha = XParam.grdalpha * pi / 180.0; // grid rotation\n\n    }\n    else\n    {\n        //Geo grid\n\n        XParam.delta = XParam.dx * XParam.Radius * pi / 180.0;\n        //XParam.engine = 2;\n\n        //printf(\"Using spherical coordinate; delta=%f rad\\n\", XParam.delta);\n        log(\"Using spherical coordinate; delta=\" + std::to_string(XParam.delta));\n        if (XParam.grdalpha != 0.0)\n        {\n            //printf(\"grid rotation in spherical coordinate is not supported yet. grdalpha=%f rad\\n\", XParam.grdalpha);\n            log(\"grid rotation in spherical coordinate is not supported yet. grdalpha=\" + std::to_string(XParam.grdalpha * 180.0 / pi));\n        }\n    }\n\n    // Read/setup bdn segment polygon. Note this can't be part of the \"readforcing\" step because xmin, xmax ymin ymax are not known then\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n\n        XForcing.bndseg[iseg].poly= readbndpolysegment(XForcing.bndseg[iseg], XParam);\n        //if (XForcing.bndseg[iseg].type == 2)\n        //{\n        //  XForcing.bndseg[iseg].type = 3;\n        //}\n\n\n        XForcing.bndseg[iseg].left.isright = -1;\n        XForcing.bndseg[iseg].left.istop = 0;\n\n        XForcing.bndseg[iseg].right.isright = 1;\n        XForcing.bndseg[iseg].right.istop = 0;\n\n        XForcing.bndseg[iseg].top.isright = 0;\n        XForcing.bndseg[iseg].top.istop = 1;\n\n        XForcing.bndseg[iseg].bot.isright = 0;\n        XForcing.bndseg[iseg].bot.istop = -1;\n    }\n\n    bndsegment remainderblk;\n\n    remainderblk.left.isright = -1;\n    remainderblk.left.istop = 0;\n\n    remainderblk.right.isright = 1;\n    remainderblk.right.istop = 0;\n\n    remainderblk.top.isright = 0;\n    remainderblk.top.istop = 1;\n\n    remainderblk.bot.isright = 0;\n    remainderblk.bot.istop = -1;\n    remainderblk.type = XParam.aoibnd;\n\n    XForcing.bndseg.push_back(remainderblk);\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n\n        AllocateCPU(1, 1, XForcing.bndseg[iseg].left.blk);\n        AllocateCPU(1, 1, XForcing.bndseg[iseg].right.blk);\n        AllocateCPU(1, 1, XForcing.bndseg[iseg].top.blk);\n        AllocateCPU(1, 1, XForcing.bndseg[iseg].bot.blk);\n\n        AllocateCPU(1, 1, XForcing.bndseg[iseg].left.qmean);\n        AllocateCPU(1, 1, XForcing.bndseg[iseg].right.qmean);\n        AllocateCPU(1, 1, XForcing.bndseg[iseg].top.qmean);\n        AllocateCPU(1, 1, XForcing.bndseg[iseg].bot.qmean);\n    }\n\n\n\n\n\n    //setup extra infor about boundaries\n    // This is not needed anymore\n    XForcing.left.side = 3;\n    XForcing.left.isright = -1;\n    XForcing.left.istop = 0;\n\n    XForcing.right.side = 1;\n    XForcing.right.isright = 1;\n    XForcing.right.istop = 0;\n\n    XForcing.top.side = 0;\n    XForcing.top.isright = 0;\n    XForcing.top.istop = 1;\n\n    XForcing.bot.side = 2;\n    XForcing.bot.isright = 0;\n    XForcing.bot.istop = -1;\n\n\n    //\n\n    XForcing.Atmp.clampedge = float(XParam.Paref);\n\n    if (!XForcing.Atmp.inputfile.empty())\n    {\n        XParam.atmpforcing = true;\n        XParam.engine = 3;\n    }\n\n\n    // Make sure the nriver in param (used for preallocation of memory) and number of rivers in XForcing are consistent\n    XParam.nrivers = int(XForcing.rivers.size());\n\n    // Engine checks\n    if (XParam.engine == 5)\n    {\n        XParam.CFL = utils::max(XParam.CFL, 0.25);\n        //XParam.eps = 0.0000000001;\n    }\n\n    // Check whether endtime was specified by the user\n    //No; i.e. endtimne =0.0\n    //so the following conditions are useless\n\n\n\n    if (abs(XParam.endtime - DefaultParams.endtime) &lt;= tiny)\n    {\n        //No; i.e. endtimne =0.0\n        XParam.endtime = 1.0 / tiny; //==huge\n    }\n\n    XParam.endtime = setendtime(XParam, XForcing);\n\n\n    // Assign a value for reftime if not yet set. \n    //It is needed in the Netcdf file generation\n    if (XParam.reftime.empty())\n    {\n        XParam.reftime = \"2000-01-01T00:00:00\";\n    }\n\n    XParam.inittime = XParam.totaltime;\n\n    log(\"Reference time: \" + XParam.reftime);\n    log(\"Model Initial time: \" + std::to_string(XParam.totaltime) + \" ; \" );\n\n    log(\"Model end time: \" + std::to_string(XParam.endtime));\n\n    // Check that outputtimestep is not zero, so at least the first and final time step are saved\n    // If only the model stepup is needed than just run with endtime=0.0\n    /*\n    // No longer needed\n    if (abs(XParam.outputtimestep - DefaultParams.outputtimestep) &lt;= tiny)\n    {\n        XParam.outputtimestep = XParam.endtime;\n        //otherwise there is really no point running the model\n    }\n    if (XParam.outputtimestep &gt; XParam.endtime)\n    {\n        XParam.outputtimestep = XParam.endtime;\n        //otherwise, no final output\n    }\n    */\n    //Initialisation of the main time output vector\n    //Initialise default values for Toutput (output times for map outputs)\n    InitialiseToutput(XParam.Toutput, XParam);\n    if (XParam.Toutput.val.empty())\n    {\n        if (abs(XParam.outputtimestep - DefaultParams.outputtimestep) &lt;= tiny)\n        {\n            XParam.Toutput.val.push_back(XParam.totaltime);\n            XParam.Toutput.val.push_back(XParam.endtime);\n        }\n        else\n        {\n            int nstep = (XParam.endtime - XParam.totaltime) / XParam.outputtimestep + 1;\n\n            for (int k = 0; k &lt; nstep; k++)\n            {\n                XParam.Toutput.val.push_back(std::min(XParam.totaltime + XParam.outputtimestep * k, XParam.endtime));\n            }\n\n        }\n    }\n    else\n    {\n\n        XParam.Toutput.val.push_back(XParam.totaltime);\n        XParam.Toutput.val.push_back(XParam.endtime);\n    }\n\n\n    // Initialisation of the time output vector for the zones outputs\n    if (XParam.outzone.size() &gt; 0)\n    {\n        for (int ii = 0; ii &lt; XParam.outzone.size(); ii++)\n        {\n            {\n                InitialiseToutput(XParam.outzone[ii].Toutput, XParam);\n            }\n        }\n    }\n\n\n\n    if (XParam.outvars.empty() &amp;&amp; XParam.outputtimestep &gt; 0.0)\n    {\n        //a nc file was specified but no output variable were specified\n        std::vector&lt;std::string&gt; SupportedVarNames = { \"zb\", \"zs\", \"u\", \"v\", \"h\" };\n        for (int isup = 0; isup &lt; SupportedVarNames.size(); isup++)\n        {\n            XParam.outvars.push_back(SupportedVarNames[isup]);\n\n        }\n\n    }\n\n\n    // Check whether a cuda compatible GPU is present\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        // Init GPU\n        int nDevices;\n        cudaGetDeviceCount(&amp;nDevices);\n        cudaDeviceProp prop;\n\n        if (XParam.GPUDEVICE &gt; (nDevices - 1))\n        {\n            //  if no GPU device are present then use the CPU (GPUDEVICE = -1)\n            XParam.GPUDEVICE = (nDevices - 1);\n        }\n        cudaGetDeviceProperties(&amp;prop, XParam.GPUDEVICE);\n        //printf(\"There are %d GPU devices on this machine\\n\", nDevices);\n        log(\"There are \" + std::to_string(nDevices) + \" GPU devices on this machine\");\n\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n\n            log(\"Using Device: \" + std::string(prop.name));\n        }\n        else\n        {\n            log(\"No GPU device were detected on this machine... Using CPU instead\");\n        }\n\n    }\n\n\n    if (XParam.minlevel != XParam.maxlevel)\n    {\n        if (XParam.AdaptCrit.empty())\n        {\n            XParam.AdaptCrit = \"Threshold\";\n            XParam.Adapt_arg1 = \"0.0\";\n            XParam.Adapt_arg2 = \"h\";\n        }\n    }\n\n    //Check that we have both initial loss and continuous loss if one is given\n    if (!XForcing.il.inputfile.empty())\n    {\n        if (XForcing.cl.inputfile.empty())\n        {\n            log(\"Error: File identified for initial loss but no data entered for continuous loss.\\n Please, enter a \");\n        }\n    }\n    if (!XForcing.cl.inputfile.empty())\n    {\n        if (XForcing.il.inputfile.empty())\n        {\n            log(\"Error: File identified for continuous loss but no data entered for initial loss\");\n        }\n    }\n\n    //Check that the Initial Loss/ Continuing Loss model is used if il, cl or hgw output are asked by user.\n    if (!XParam.infiltration) // (XForcing.il.inputfile.empty() &amp;&amp; XForcing.cl.inputfile.empty() &amp;&amp; (XParam.il == 0.0) &amp;&amp; (XParam.cl == 0.0))\n    {\n        std::vector&lt;std::string&gt; namestr = { \"il\",\"cl\",\"hgw\" };\n        for (int ii = 0; ii &lt; namestr.size(); ii++)\n        {\n            std::vector&lt;std::string&gt;::iterator itr = std::find(XParam.outvars.begin(), XParam.outvars.end(), namestr[ii]);\n            if (itr != XParam.outvars.end())\n            {\n                log(\"The output variable associated to the ILCL model \\\"\" + namestr[ii] + \"\\\" is requested but the model is not used. The variable is removed from the outputs.\");\n                XParam.outvars.erase(itr);\n            }\n        }\n    }\n\n    //Check that the atmospheric forcing is used if datmpdx, datmpdy output are asked by user.\n    if (XForcing.Atmp.inputfile.empty())\n    {\n        std::vector&lt;std::string&gt; namestr = { \"datmpdx\", \"datmpdy\" };\n        for (int ii = 0; ii &lt; namestr.size(); ii++)\n        {\n            std::vector&lt;std::string&gt;::iterator itr = std::find(XParam.outvars.begin(), XParam.outvars.end(), namestr[ii]);\n            if (itr != XParam.outvars.end())\n            {\n                log(\"The output variable associated to the atmosheric forcing \\\"\" + namestr[ii] + \"\\\" is requested but the model is not used. The variable is removed from the outputs.\");\n                XParam.outvars.erase(itr);\n            }\n        }\n\n    }\n\n}\n\n//Initialise default values for Toutput (output times for map outputs)\nvoid InitialiseToutput(T_output&amp; Toutput_loc, Param XParam)\n{\n\n    Toutput_loc.val = ReadToutput(Toutput_loc.inputstr, XParam);\n    // Make sure Toutput is not empty and that all values are &gt;= totaltime and &lt;= endtime\n    if (Toutput_loc.val.empty())\n    {\n        for (int i = 0; i &lt; XParam.Toutput.val.size(); i++)\n        {\n            Toutput_loc.val.push_back(std::min(std::max(XParam.totaltime, XParam.Toutput.val[i]), XParam.endtime));\n        }\n    }\n\n    // This may seem redundant but the uniq function used in the initial condition should clean out duplicate\n\n\n\n}\n\ndouble setendtime(Param XParam, Forcing&lt;float&gt; XForcing)\n{\n    //endtime cannot be bigger than the smallest time set in a boundary\n    SLTS tempSLTS;\n    double endtime = XParam.endtime;\n    if (XForcing.left.on)\n    {\n        tempSLTS = XForcing.left.data.back();\n        endtime = utils::min(endtime, tempSLTS.time);\n\n    }\n    if (XForcing.right.on)\n    {\n        tempSLTS = XForcing.right.data.back();\n        endtime = utils::min(endtime, tempSLTS.time);\n    }\n    if (XForcing.top.on)\n    {\n        tempSLTS = XForcing.top.data.back();\n        endtime = utils::min(endtime, tempSLTS.time);\n    }\n    if (XForcing.bot.on)\n    {\n        tempSLTS = XForcing.bot.data.back();\n        endtime = utils::min(endtime, tempSLTS.time);\n    }\n\n    if (endtime &lt; XParam.endtime)\n    {\n        log(\"\\nWARNING: Boundary definition too short, endtime of the simulation reduced to : \" + std::to_string(endtime));\n    }\n\n    return endtime;\n}\n\nstd::string findparameter(std::vector&lt;std::string&gt; parameterstr, std::string line)\n{\n    std::size_t found;\n\n    std::string parameternumber,left,right;\n    std::vector&lt;std::string&gt; splittedstr, splittedstrnohash;\n\n\n    // first look for an equal sign\n    // No equal sign mean not a valid line so skip\n    splittedstr = split(line, '=');\n    if (splittedstr.size() &gt; 1)\n    {\n        left = trim(splittedstr[0], \" \");\n        right = splittedstr[1]; // if there are more than one equal sign in the line the second one is ignored\n        for (int ieq = 2; ieq &lt; splittedstr.size(); ieq++)\n        {\n            right = right + \"=\" + splittedstr[ieq];\n        }\n        for (int ii = 0; ii &lt; parameterstr.size(); ii++)\n        {\n            found = case_insensitive_compare(left, parameterstr[ii]);// it needs to strictly compare\n            if (found == 0)\n                break;\n        }\n        if (found == 0) // found the parameter\n        {\n            //std::cout &lt;&lt;\"found LonMin at : \"&lt;&lt; found &lt;&lt; std::endl;\n            //Numberstart = found + parameterstr.length();\n\n\n            splittedstrnohash = split(right, '#');\n\n            splittedstr = split(splittedstrnohash[0], ';');\n\n            if (splittedstr.size() &gt;= 1)\n            {\n                parameternumber = splittedstr[0];\n            }\n            //std::cout &lt;&lt; parameternumber &lt;&lt; std::endl;\n\n        }\n    }\n    return trim(parameternumber, \" \");\n    //return parameternumber;\n}\n\n\nstd::string findparameter(std::string parameterstr, std::string line)\n{\n    std::vector&lt;std::string&gt; parametervec;\n\n    parametervec.push_back(parameterstr);\n    return findparameter(parametervec, line);\n}\n\n\nvoid split(const std::string&amp; s, char delim, std::vector&lt;std::string&gt;&amp; elems) {\n    std::stringstream ss;\n    ss.str(s);\n    std::string item;\n    while (std::getline(ss, item, delim)) {\n        if (!item.empty())//skip empty tokens\n        {\n            elems.push_back(item);\n        }\n\n    }\n}\n\nstd::vector&lt;std::string&gt; split(const std::string&amp; s, char delim) {\n    std::vector&lt;std::string&gt; elems;\n    split(s, delim, elems);\n    return elems;\n}\n\n\n\nvoid split_full(const std::string&amp; s, char delim, std::vector&lt;std::string&gt;&amp; elems) {\n    std::stringstream ss;\n    ss.str(s);\n    std::string item;\n    while (std::getline(ss, item, delim)) {\n        std::string::iterator end_pos = std::remove(item.begin(), item.end(), ' ');\n        item.erase(end_pos, item.end());\n        elems.push_back(item);\n    }\n    if (s[s.length() - 1] == delim)\n    {\n        std::string item;\n        elems.push_back(item);\n    }\n}\n\nstd::vector&lt;std::string&gt; split_full(const std::string&amp; s, char delim) {\n    std::vector&lt;std::string&gt; elems;\n    split_full(s, delim, elems);\n    return elems;\n}\n\n\nstd::vector&lt;std::string&gt; split(const std::string s, const std::string delim)\n{\n    size_t ide = 0;\n    int loc = 0;\n    std::vector&lt;std::string&gt; output;\n    std::string rem = s;\n\n\n    while (ide &lt; std::string::npos || output.size() == 0)\n    {\n\n        ide = rem.find(delim);\n        if (ide == 0 || ide == std::string::npos)\n        {\n            output.push_back(rem);\n            ide = std::string::npos;\n        }\n        else\n        {\n            output.push_back(rem.substr(loc, ide));\n        }\n\n        if (ide &lt; (rem.length() - delim.length()))\n        {\n            loc = int(ide + delim.length());\n            rem = rem.substr(loc);\n        }\n    }\n\n    return output;\n\n\n\n}\n\n\nstd::string trim(const std::string&amp; str, const std::string&amp; whitespace)\n{\n    const auto strBegin = str.find_first_not_of(whitespace);\n    if (strBegin == std::string::npos)\n        return \"\"; // no content\n\n    const auto strEnd = str.find_last_not_of(whitespace);\n    const auto strRange = strEnd - strBegin + 1;\n\n    return str.substr(strBegin, strRange);\n}\n\nstd::size_t case_insensitive_compare(std::string s1, std::string s2)\n{\n    //Convert s1 and s2 to lower case strings\n    std::transform(s1.begin(), s1.end(), s1.begin(), ::tolower);\n    std::transform(s2.begin(), s2.end(), s2.begin(), ::tolower);\n    //if (s1.compare(s2) == 0)\n    return s1.compare(s2);\n}\n\nstd::size_t case_insensitive_compare(std::string s1, std::vector&lt;std::string&gt; vecstr)\n{\n    std::size_t found;\n    //Convert s1 and s2 to lower case strings\n    for (int ii = 0; ii &lt; vecstr.size(); ii++)\n    {\n        found = case_insensitive_compare(s1, vecstr[ii]);// it needs to strictly compare\n        if (found == 0)\n        {\n            break;\n        }\n    }\n    return found;\n}\n\n\nbndsegment readbndlineside(std::string parametervalue, std::string side)\n{\n    bndsegment bnd;\n\n\n    std::vector&lt;std::string&gt; items = split(parametervalue, ',');\n\n    if (items.size() == 1)\n    {\n        bnd.type = std::stoi(items[0]);\n\n    }\n    else if (items.size() &gt;= 2)\n    {\n        const char* cstr = items[1].c_str();\n\n        if (isdigit(cstr[0]))\n        {\n            //?\n            bnd.type = std::stoi(items[1]);\n            bnd.inputfile = items[0];\n            bnd.on = true;\n\n\n\n        }\n        else\n        {\n            bnd.type = std::stoi(items[0]);\n            bnd.inputfile = items[1];\n            bnd.on = true;\n        }\n\n    }\n    bnd.polyfile = side;\n    if (bnd.on)\n    {\n        bnd.WLmap = readfileinfo(bnd.inputfile, bnd.WLmap);\n\n        //set the expected type of input\n\n        if (bnd.WLmap.extension.compare(\"nc\") == 0)\n        {\n            bnd.WLmap.uniform = 0;\n            bnd.uniform = 0;\n        }\n        else\n        {\n            bnd.WLmap.uniform = 1;\n            bnd.uniform = 1;\n        }\n    }\n    return bnd;\n}\n\n\nbndsegment readbndline(std::string parametervalue)\n{\n    //bndseg = area.txt, waterlevelforcing, 1;\n    bndsegment bnd;\n    std::vector&lt;std::string&gt; items = split(parametervalue, ',');\n    if (items.size() == 1)\n    {\n        bnd.type = std::stoi(items[0]);\n\n    }\n    else if (items.size() &gt;= 2)\n    {\n        const char* cstr = items[1].c_str();\n        if (items[1].length() &gt; 2)\n        {\n            bnd.polyfile = items[0];\n            bnd.type = std::stoi(items[2]);\n            bnd.inputfile = items[1];\n            bnd.on = true;\n\n        }\n        else\n        {\n            bnd.polyfile = items[0];\n            bnd.type = std::max(std::stoi(items[1]), 1); // only 2 param implies that it is either a wall or Neumann bnd\n\n        }\n    }\n\n\n    //set the expected type of input\n\n    if (bnd.on)\n    {\n        bnd.WLmap = readfileinfo(bnd.inputfile, bnd.WLmap);\n\n        //set the expected type of input\n\n        if (bnd.WLmap.extension.compare(\"nc\") == 0)\n        {\n            bnd.WLmap.uniform = 0;\n            bnd.uniform = 0;\n        }\n        else\n        {\n            bnd.WLmap.uniform = 1;\n            bnd.uniform = 1;\n        }\n    }\n    return bnd;\n}\n\n\n\nbool readparambool(std::string paramstr, bool defaultval)\n{\n    bool out = defaultval;\n    std::vector&lt;std::string&gt; truestr = { \"1\",\"true\",\"yes\", \"on\" };\n    std::vector&lt;std::string&gt; falsestr = { \"-1\",\"false\",\"no\",\"off\" };\n\n    if (case_insensitive_compare(paramstr, truestr) == 0)\n    {\n        out = true;\n    }\n    if (case_insensitive_compare(paramstr, falsestr) == 0)\n    {\n        out = false;\n    }\n\n    return out;\n}\n\n\n\n\n//inline bool fileexists(const std::string&amp; name) {\n//  struct stat buffer;\n//  return (stat(name.c_str(), &amp;buffer) == 0);\n//}\n\n\nstd::vector&lt;std::string&gt; ReadToutSTR(std::string paramstr)\n{\n    std::vector&lt;std::string&gt; Toutputpar = split(paramstr, ',');\n    return Toutputpar;\n\n}\n\n\ndouble ReadTvalstr(std::string timestr,double start, double end,std::string reftime)\n{\n    double time = 0.0;\n    std::vector&lt;std::string&gt; STstr = { \"start\",\"begin\" };\n    std::vector&lt;std::string&gt; ENstr = { \"end\",\"finish\" };\n\n    bool isdatest = timestr.find('T') != std::string::npos;\n\n    if (case_insensitive_compare(timestr, STstr) == 0)\n    {\n        time = start;\n    }\n    else if (case_insensitive_compare(timestr, ENstr) == 0)\n    {\n        time = end;\n    }\n    else if (!isdatest)\n    {\n        time = start + readApproxtimestr(timestr);\n    }\n    else\n    {\n        time = date_string_to_s(timestr, reftime);\n    }\n\n    return time = std::min(std::max(start, time), end);\n\n}\n\nstd::vector&lt;double&gt; ReadTRangestr(std::vector&lt;std::string&gt; timestr, double start, double end, std::string reftime)\n{\n    double init = 0.0;\n    double step = 0.0;\n    double last = 0.0;\n\n    std::vector&lt;std::string&gt; STstr = { \"start\",\"begin\" };\n\n    std::vector&lt;std::string&gt; ENstr = { \"end\",\"finish\" };\n\n    std::string initstr = timestr[0];\n    std::string stepstr = timestr[1];\n    std::string laststr = timestr[2];\n\n    bool isdateinit = initstr.find('T') != std::string::npos;\n\n    bool isdatelast = laststr.find('T') != std::string::npos;\n\n\n    if (case_insensitive_compare(initstr, STstr) == 0 || initstr.empty())\n    {\n        init = start;\n    }\n    else if (!isdateinit)\n    {\n        init = start + readApproxtimestr(initstr);\n    }\n    else\n    {\n        init = date_string_to_s(initstr, reftime);\n    }\n\n    if (case_insensitive_compare(laststr, ENstr) == 0 || laststr.empty())\n    {\n        last = end;\n    }\n    else if (!isdatelast)\n    {\n        last = start + readApproxtimestr(laststr);\n    }\n    else\n    {\n        last = date_string_to_s(laststr, reftime);\n    }\n\n    if (stepstr.empty())\n    {\n        step = (last - init);\n    }\n    else\n    {\n        step = readApproxtimestr(stepstr);\n    }\n\n    std::vector&lt;double&gt; tout;\n    int nstep = (last - init) / step + 1;\n\n    for (int k = 0; k &lt; nstep; k++)\n    {\n        tout.push_back(std::min(init + step * k, last));\n    }\n\n\n    return tout;\n\n}\n\n\ndouble readApproxtimestr(std::string input)\n{\n    double time = 0.0;\n\n    double fac = 1.0;\n\n    std::string numberst;\n    std::string unit;\n\n    // first split the digit from the string\n    for (auto e : input)\n    {\n        if (isalpha(e) &amp;&amp; e!='.')\n            unit.push_back(e);\n        else if (isdigit(e) || e == '.')\n            numberst.push_back(e);\n    }\n\n    double number = std::stod(numberst);\n\n    std::vector&lt;std::string&gt; secondvec = { \"seconds\",\"second\",\"sec\",\"s\" };\n    std::vector&lt;std::string&gt; minutevec = { \"minutes\",\"minute\",\"min\",\"m\" };\n    std::vector&lt;std::string&gt; hourvec = { \"hours\",\"hour\",\"hrs\",\"hr\",\"h\" };\n    std::vector&lt;std::string&gt; dayvec = { \"days\",\"day\",\"d\" };\n    std::vector&lt;std::string&gt; monthvec = { \"months\",\"month\",\"mths\", \"mth\", \"mon\" };\n    std::vector&lt;std::string&gt; yearvec = { \"years\",\"year\",\"yrs\", \"yr\", \"y\" };\n\n\n    std::size_t found;\n    found = case_insensitive_compare(unit, secondvec);\n    if (found == 0)\n        fac = 1.0;\n\n    found = case_insensitive_compare(unit, minutevec);\n    if (found == 0)\n        fac = 60.0;\n\n    found = case_insensitive_compare(unit, hourvec);\n    if (found == 0)\n        fac = 3600.0;\n\n    found = case_insensitive_compare(unit, dayvec);\n    if (found == 0)\n        fac = 3600.0 * 24.0;\n\n    found = case_insensitive_compare(unit, monthvec);\n    if (found == 0)\n        fac = 3600.0 * 24.0 * 30.4375;\n\n    found = case_insensitive_compare(unit, yearvec);\n    if (found == 0)\n        fac = 3600.0 * 24.0 * 365.25;\n\n    // If unit is not understood it will return number\n    time = fac * number;\n\n    return time;\n}\n\n\nstd::vector&lt;double&gt; ReadToutput(std::vector&lt;std::string&gt; paramstr,Param XParam)\n{\n    //\n\n    T_output tout;\n    double Xstart = XParam.totaltime;\n    double Xend = XParam.endtime;\n    std::string reftime = XParam.reftime;\n\n\n    for (int ipa = 0; ipa &lt; paramstr.size(); ipa++)\n    {\n\n        //Check if it is a range or a single value\n\n\n        std::vector&lt;std::string&gt; Toutputpar_vect = split_full(paramstr[ipa], '|');\n\n        if (Toutputpar_vect.size() == 3)\n        {\n\n            // It is range\n            std::vector&lt;double&gt; rgvals = ReadTRangestr(Toutputpar_vect, Xstart, Xend, reftime);\n            //a.insert(a.end(), b.begin(), b.end());\n            tout.val.insert(tout.val.end(), rgvals.begin(), rgvals.end());\n\n\n        }\n        else if (Toutputpar_vect.size() &gt; 1)\n        {\n            //Failed: Toutput must be exactly 3 values, separated by \":\" for a vector shape, in virst position. \"t_init:t_step:t_end\" (with possible empty values as \"t_init:t_setps: \" to use the last time steps as t_end;\n            std::cerr &lt;&lt; \"Failed: Toutput must be exactly 3 values, separated by ':' for a vector shape, in virst position. 't_init : t_step : t_end' (with possible empty values as 't_init : t_setps : ' to use the last time steps as t_end; see log file for details\" &lt;&lt; std::endl;\n\n            log(\"Failed: Toutput must be exactly 3 values, separated by ':' for a vector shape, in virst position. 't_init : t_step : t_end' (with possible empty values as 't_init : t_setps : ' to use the last time steps as t_end;\");\n            log(paramstr[ipa]);\n        }\n        else {\n            tout.val.push_back(ReadTvalstr(paramstr[ipa],Xstart, Xend, reftime));\n        }\n    }\n\n    return tout.val;\n}\n</code></pre>"},{"location":"BGFlood/ReadInput_8h/","title":"File ReadInput.h","text":""},{"location":"BGFlood/ReadInput_8h/#file-readinputh","title":"File ReadInput.h","text":"<p>FileList &gt; src &gt; ReadInput.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"utctime.h\"</code></li> <li><code>#include \"Input.h\"</code></li> <li><code>#include \"ReadForcing.h\"</code></li> </ul>"},{"location":"BGFlood/ReadInput_8h/#public-functions","title":"Public Functions","text":"Type Name void InitialiseToutput (T_output &amp; Toutput, Param XParam)  std::vector&lt; double &gt; ReadTRangestr (std::vector&lt; std::string &gt; timestr, double start, double end, std::string reftime)  std::vector&lt; std::string &gt; ReadToutSTR (std::string paramstr)  std::vector&lt; double &gt; ReadToutput (std::vector&lt; std::string &gt; paramstr, Param XParam)  double ReadTvalstr (std::string timestr, double start, double end, std::string reftime)  void Readparamfile (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, std::string Paramfile)  std::size_t case_insensitive_compare (std::string s1, std::string s2)  std::size_t case_insensitive_compare (std::string s1, std::vector&lt; std::string &gt; vecstr)  void checkparamsanity (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing)  std::string findparameter (std::vector&lt; std::string &gt; parameterstr, std::string line)  std::string findparameter (std::string parameterstr, std::string line)  double readApproxtimestr (std::string input)  bndsegment readbndline (std::string parametervalue)  bndsegment readbndlineside (std::string parametervalue, std::string side)  T readfileinfo (std::string input, T outinfo)  bool readparambool (std::string paramstr, bool defaultval)  Forcing&lt; T &gt; readparamstr (std::string line, Forcing&lt; T &gt; forcing)  Param readparamstr (std::string line, Param param)  double setendtime (Param XParam, Forcing&lt; float &gt; XForcing)  void split (const std::string &amp; s, char delim, std::vector&lt; std::string &gt; &amp; elems)  std::vector&lt; std::string &gt; split (const std::string &amp; s, char delim)  std::vector&lt; std::string &gt; split (const std::string s, const std::string delim)  void split_full (const std::string &amp; s, char delim, std::vector&lt; std::string &gt; &amp; elems)  std::vector&lt; std::string &gt; split_full (const std::string &amp; s, char delim)  std::string trim (const std::string &amp; str, const std::string &amp; whitespace)"},{"location":"BGFlood/ReadInput_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/ReadInput_8h/#function-initialisetoutput","title":"function InitialiseToutput","text":"<pre><code>void InitialiseToutput (\n    T_output &amp; Toutput,\n    Param XParam\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8h/#function-readtrangestr","title":"function ReadTRangestr","text":"<pre><code>std::vector&lt; double &gt; ReadTRangestr (\n    std::vector&lt; std::string &gt; timestr,\n    double start,\n    double end,\n    std::string reftime\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8h/#function-readtoutstr","title":"function ReadToutSTR","text":"<pre><code>std::vector&lt; std::string &gt; ReadToutSTR (\n    std::string paramstr\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8h/#function-readtoutput","title":"function ReadToutput","text":"<pre><code>std::vector&lt; double &gt; ReadToutput (\n    std::vector&lt; std::string &gt; paramstr,\n    Param XParam\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8h/#function-readtvalstr","title":"function ReadTvalstr","text":"<pre><code>double ReadTvalstr (\n    std::string timestr,\n    double start,\n    double end,\n    std::string reftime\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8h/#function-readparamfile","title":"function Readparamfile","text":"<pre><code>void Readparamfile (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    std::string Paramfile\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8h/#function-case_insensitive_compare","title":"function case_insensitive_compare","text":"<pre><code>std::size_t case_insensitive_compare (\n    std::string s1,\n    std::string s2\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8h/#function-case_insensitive_compare_1","title":"function case_insensitive_compare","text":"<pre><code>std::size_t case_insensitive_compare (\n    std::string s1,\n    std::vector&lt; std::string &gt; vecstr\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8h/#function-checkparamsanity","title":"function checkparamsanity","text":"<pre><code>void checkparamsanity (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre> <p>Check the Sanity of both Param and Forcing class If required some parameter are infered </p>"},{"location":"BGFlood/ReadInput_8h/#function-findparameter","title":"function findparameter","text":"<pre><code>std::string findparameter (\n    std::vector&lt; std::string &gt; parameterstr,\n    std::string line\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8h/#function-findparameter_1","title":"function findparameter","text":"<pre><code>std::string findparameter (\n    std::string parameterstr,\n    std::string line\n) \n</code></pre> <p>separate parameter from value </p>"},{"location":"BGFlood/ReadInput_8h/#function-readapproxtimestr","title":"function readApproxtimestr","text":"<pre><code>double readApproxtimestr (\n    std::string input\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8h/#function-readbndline","title":"function readbndline","text":"<pre><code>bndsegment readbndline (\n    std::string parametervalue\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8h/#function-readbndlineside","title":"function readbndlineside","text":"<pre><code>bndsegment readbndlineside (\n    std::string parametervalue,\n    std::string side\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8h/#function-readfileinfo","title":"function readfileinfo","text":"<pre><code>template&lt;class T&gt;\nT readfileinfo (\n    std::string input,\n    T outinfo\n) \n</code></pre> <p>convert file name into name and extension This is used for various input classes</p> <p>template inputmap readfileinfo&lt;inputmap&gt;(std::string input, inputmap outinfo); template forcingmap readfileinfo&lt;forcingmap&gt;(std::string input, forcingmap outinfo); template StaticForcingP&lt;float&gt; readfileinfo&lt;StaticForcingP&lt;float&gt;&gt;(std::string input, StaticForcingP&lt;float&gt; outinfo); template DynForcingP&lt;float&gt; readfileinfo&lt;DynForcingP&lt;float&gt;&gt;(std::string input, DynForcingP&lt;float&gt; outinfo); template deformmap&lt;float&gt; readfileinfo&lt;deformmap&lt;float&gt;&gt;(std::string input, deformmap&lt;float&gt; outinfo); </p>"},{"location":"BGFlood/ReadInput_8h/#function-readparambool","title":"function readparambool","text":"<pre><code>bool readparambool (\n    std::string paramstr,\n    bool defaultval\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8h/#function-readparamstr","title":"function readparamstr","text":"<pre><code>template&lt;class T&gt;\nForcing &lt; T &gt; readparamstr (\n    std::string line,\n    Forcing &lt; T &gt; forcing\n) \n</code></pre> <p>Read BG_param.txt line and convert parameter to the righ parameter in the class return an updated Param class </p>"},{"location":"BGFlood/ReadInput_8h/#function-readparamstr_1","title":"function readparamstr","text":"<pre><code>Param readparamstr (\n    std::string line,\n    Param param\n) \n</code></pre> <p>Read BG_param.txt line and convert parameter to the righ parameter in the class retrun an updated Param class </p>"},{"location":"BGFlood/ReadInput_8h/#function-setendtime","title":"function setendtime","text":"<pre><code>double setendtime (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing\n) \n</code></pre> <p>Calculate/modify endtime based on maximum time in forcing </p>"},{"location":"BGFlood/ReadInput_8h/#function-split","title":"function split","text":"<pre><code>void split (\n    const std::string &amp; s,\n    char delim,\n    std::vector&lt; std::string &gt; &amp; elems\n) \n</code></pre> <p>split string based in character </p>"},{"location":"BGFlood/ReadInput_8h/#function-split_1","title":"function split","text":"<pre><code>std::vector&lt; std::string &gt; split (\n    const std::string &amp; s,\n    char delim\n) \n</code></pre> <p>split string based in character </p>"},{"location":"BGFlood/ReadInput_8h/#function-split_2","title":"function split","text":"<pre><code>std::vector&lt; std::string &gt; split (\n    const std::string s,\n    const std::string delim\n) \n</code></pre>"},{"location":"BGFlood/ReadInput_8h/#function-split_full","title":"function split_full","text":"<pre><code>void split_full (\n    const std::string &amp; s,\n    char delim,\n    std::vector&lt; std::string &gt; &amp; elems\n) \n</code></pre> <p>split string based in character, conserving empty item </p>"},{"location":"BGFlood/ReadInput_8h/#function-split_full_1","title":"function split_full","text":"<pre><code>std::vector&lt; std::string &gt; split_full (\n    const std::string &amp; s,\n    char delim\n) \n</code></pre> <p>split string based in character, conserving empty items </p>"},{"location":"BGFlood/ReadInput_8h/#function-trim","title":"function trim","text":"<pre><code>std::string trim (\n    const std::string &amp; str,\n    const std::string &amp; whitespace\n) \n</code></pre> <p>remove leading and trailing space in a string </p> <p>The documentation for this class was generated from the following file <code>src/ReadInput.h</code></p>"},{"location":"BGFlood/ReadInput_8h_source/","title":"File ReadInput.h","text":""},{"location":"BGFlood/ReadInput_8h_source/#file-readinputh","title":"File ReadInput.h","text":"<p>File List &gt; src &gt; ReadInput.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef READINPUT_H\n#define READINPUT_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"Forcing.h\"\n#include \"Util_CPU.h\"\n#include \"utctime.h\"\n#include \"Input.h\"\n#include \"ReadForcing.h\"\n\n\ntemplate &lt;class T&gt; T readfileinfo(std::string input, T outinfo);\n\nvoid Readparamfile(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing, std::string Paramfile);\n\ntemplate &lt;class T&gt; Forcing&lt;T&gt; readparamstr(std::string line, Forcing&lt;T&gt; forcing);\n\nParam readparamstr(std::string line, Param param);\n\ntemplate &lt;class T&gt;Forcing&lt;T&gt; readparamstr(std::string line, Forcing&lt;T&gt; forcing);\nvoid checkparamsanity(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing);\ndouble setendtime(Param XParam, Forcing&lt;float&gt; XForcing);\nstd::string findparameter(std::vector&lt;std::string&gt; parameterstr, std::string line);\nstd::string findparameter(std::string parameterstr, std::string line);\nvoid split(const std::string&amp; s, char delim, std::vector&lt;std::string&gt;&amp; elems);\nstd::vector&lt;std::string&gt; split(const std::string&amp; s, char delim);\nvoid split_full(const std::string&amp; s, char delim, std::vector&lt;std::string&gt;&amp; elems);\nstd::vector&lt;std::string&gt; split_full(const std::string&amp; s, char delim);\nstd::vector&lt;std::string&gt; split(const std::string s, const std::string delim);\nstd::string trim(const std::string&amp; str, const std::string&amp; whitespace);\nstd::size_t case_insensitive_compare(std::string s1, std::string s2);\nstd::size_t case_insensitive_compare(std::string s1, std::vector&lt;std::string&gt; vecstr);\nbool readparambool(std::string paramstr, bool defaultval);\nvoid InitialiseToutput(T_output&amp; Toutput, Param XParam);\nbndsegment readbndline(std::string parametervalue);\nbndsegment readbndlineside(std::string parametervalue, std::string side);\n\n//T_output ReadToutput(std::vector&lt;std::string&gt; paramstr, Param XParam);\nstd::vector&lt;double&gt; ReadToutput(std::vector&lt;std::string&gt; paramstr, Param XParam);\n\nstd::vector&lt;std::string&gt; ReadToutSTR(std::string paramstr);\ndouble ReadTvalstr(std::string timestr, double start, double end, std::string reftime);\nstd::vector&lt;double&gt; ReadTRangestr(std::vector&lt;std::string&gt; timestr, double start, double end, std::string reftime);\ndouble readApproxtimestr(std::string input);\n\n//inline bool fileexists(const std::string&amp; name);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/","title":"File Read_netcdf.cu","text":""},{"location":"BGFlood/Read__netcdf_8cu/#file-read_netcdfcu","title":"File Read_netcdf.cu","text":"<p>FileList &gt; src &gt; Read_netcdf.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Read_netcdf.h\"</code></li> </ul>"},{"location":"BGFlood/Read__netcdf_8cu/#public-functions","title":"Public Functions","text":"Type Name std::string checkncvarname (int ncid, std::string stringA, std::string stringB, std::string stringC, std::string stringD, std::string stringE)  int nc_get_var1_T (int ncid, int varid, const size_t * startp, float * zsa)  int nc_get_var1_T (int ncid, int varid, const size_t * startp, double * zsa)  int nc_get_var_T (int ncid, int varid, float *&amp; zb)  int nc_get_var_T (int ncid, int varid, double *&amp; zb)  int nc_get_var_T (int ncid, int varid, int *&amp; zb)  int nc_get_vara_T (int ncid, int varid, const size_t * startp, const size_t * countp, int *&amp; zb)  int nc_get_vara_T (int ncid, int varid, const size_t * startp, const size_t * countp, float *&amp; zb)  int nc_get_vara_T (int ncid, int varid, const size_t * startp, const size_t * countp, double *&amp; zb)  void read2Dnc (int nx, int ny, char ncfile, float *&amp; hh)  void read3Dnc (int nx, int ny, int ntheta, char ncfile, float *&amp; ee)  void readATMstep (forcingmap ATMPmap, int steptoread, float *&amp; Po)  void readWNDstep (forcingmap WNDUmap, forcingmap WNDVmap, int steptoread, float *&amp; Uo, float *&amp; Vo)  void readgridncsize (const std::string ncfilestr, const std::string varstr, std::string reftime, int &amp; nx, int &amp; ny, int &amp; nt, double &amp; dx, double &amp; dy, double &amp; dt, double &amp; xo, double &amp; yo, double &amp; to, double &amp; xmax, double &amp; ymax, double &amp; tmax, bool &amp; flipx, bool &amp; flipy)  void readgridncsize (forcingmap &amp; Fmap, Param XParam)  void readgridncsize (T &amp; Imap)  template void readgridncsize&lt; DynForcingP&lt; float &gt; &gt; (DynForcingP&lt; float &gt; &amp; Imap)  template void readgridncsize&lt; StaticForcingP&lt; float &gt; &gt; (StaticForcingP&lt; float &gt; &amp; Imap)  template void readgridncsize&lt; StaticForcingP&lt; int &gt; &gt; (StaticForcingP&lt; int &gt; &amp; Imap)  template void readgridncsize&lt; deformmap&lt; float &gt; &gt; (deformmap&lt; float &gt; &amp; Imap)  template void readgridncsize&lt; forcingmap &gt; (forcingmap &amp; Imap)  template void readgridncsize&lt; inputmap &gt; (inputmap &amp; Imap)  int readncslev1 (std::string filename, std::string varstr, size_t indx, size_t indy, size_t indt, bool checkhh, double eps, T *&amp; zsa)  template int readncslev1&lt; double &gt; (std::string filename, std::string varstr, size_t indx, size_t indy, size_t indt, bool checkhh, double eps, double *&amp; zsa)  template int readncslev1&lt; float &gt; (std::string filename, std::string varstr, size_t indx, size_t indy, size_t indt, bool checkhh, double eps, float *&amp; zsa)  int readnctime (std::string filename, double *&amp; time)  int readnctime2 (int ncid, char * timecoordname, std::string refdate, size_t nt, double *&amp; time)  void readnczb (int nx, int ny, std::string ncfile, float *&amp; zb)  int readvardata (std::string filename, std::string Varname, int step, T *&amp; vardata, bool flipx, bool flipy)  template int readvardata&lt; double &gt; (std::string filename, std::string Varname, int step, double *&amp; vardata, bool flipx, bool flipy)  template int readvardata&lt; float &gt; (std::string filename, std::string Varname, int step, float *&amp; vardata, bool flipx, bool flipy)  template int readvardata&lt; int &gt; (std::string filename, std::string Varname, int step, int *&amp; vardata, bool flipx, bool flipy)  int readvarinfo (std::string filename, std::string Varname, size_t *&amp; ddimU)"},{"location":"BGFlood/Read__netcdf_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Read__netcdf_8cu/#function-checkncvarname","title":"function checkncvarname","text":"<pre><code>std::string checkncvarname (\n    int ncid,\n    std::string stringA,\n    std::string stringB,\n    std::string stringC,\n    std::string stringD,\n    std::string stringE\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-nc_get_var1_t","title":"function nc_get_var1_T","text":"<pre><code>inline int nc_get_var1_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    float * zsa\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-nc_get_var1_t_1","title":"function nc_get_var1_T","text":"<pre><code>inline int nc_get_var1_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    double * zsa\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-nc_get_var_t","title":"function nc_get_var_T","text":"<pre><code>inline int nc_get_var_T (\n    int ncid,\n    int varid,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-nc_get_var_t_1","title":"function nc_get_var_T","text":"<pre><code>inline int nc_get_var_T (\n    int ncid,\n    int varid,\n    double *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-nc_get_var_t_2","title":"function nc_get_var_T","text":"<pre><code>inline int nc_get_var_T (\n    int ncid,\n    int varid,\n    int *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-nc_get_vara_t","title":"function nc_get_vara_T","text":"<pre><code>inline int nc_get_vara_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    const size_t * countp,\n    int *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-nc_get_vara_t_1","title":"function nc_get_vara_T","text":"<pre><code>inline int nc_get_vara_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    const size_t * countp,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-nc_get_vara_t_2","title":"function nc_get_vara_T","text":"<pre><code>inline int nc_get_vara_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    const size_t * countp,\n    double *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-read2dnc","title":"function read2Dnc","text":"<pre><code>void read2Dnc (\n    int nx,\n    int ny,\n    char ncfile,\n    float *&amp; hh\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-read3dnc","title":"function read3Dnc","text":"<pre><code>void read3Dnc (\n    int nx,\n    int ny,\n    int ntheta,\n    char ncfile,\n    float *&amp; ee\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readatmstep","title":"function readATMstep","text":"<pre><code>void readATMstep (\n    forcingmap ATMPmap,\n    int steptoread,\n    float *&amp; Po\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readwndstep","title":"function readWNDstep","text":"<pre><code>void readWNDstep (\n    forcingmap WNDUmap,\n    forcingmap WNDVmap,\n    int steptoread,\n    float *&amp; Uo,\n    float *&amp; Vo\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readgridncsize","title":"function readgridncsize","text":"<pre><code>void readgridncsize (\n    const std::string ncfilestr,\n    const std::string varstr,\n    std::string reftime,\n    int &amp; nx,\n    int &amp; ny,\n    int &amp; nt,\n    double &amp; dx,\n    double &amp; dy,\n    double &amp; dt,\n    double &amp; xo,\n    double &amp; yo,\n    double &amp; to,\n    double &amp; xmax,\n    double &amp; ymax,\n    double &amp; tmax,\n    bool &amp; flipx,\n    bool &amp; flipy\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readgridncsize_1","title":"function readgridncsize","text":"<pre><code>void readgridncsize (\n    forcingmap &amp; Fmap,\n    Param XParam\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readgridncsize_2","title":"function readgridncsize","text":"<pre><code>template&lt;class T&gt;\nvoid readgridncsize (\n    T &amp; Imap\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readgridncsize-dynforcingp-float","title":"function readgridncsize&lt; DynForcingP&lt; float &gt; &gt;","text":"<pre><code>template void readgridncsize&lt; DynForcingP&lt; float &gt; &gt; (\n    DynForcingP &lt; float &gt; &amp; Imap\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readgridncsize-staticforcingp-float","title":"function readgridncsize&lt; StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template void readgridncsize&lt; StaticForcingP&lt; float &gt; &gt; (\n    StaticForcingP &lt; float &gt; &amp; Imap\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readgridncsize-staticforcingp-int","title":"function readgridncsize&lt; StaticForcingP&lt; int &gt; &gt;","text":"<pre><code>template void readgridncsize&lt; StaticForcingP&lt; int &gt; &gt; (\n    StaticForcingP &lt; int &gt; &amp; Imap\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readgridncsize-deformmap-float","title":"function readgridncsize&lt; deformmap&lt; float &gt; &gt;","text":"<pre><code>template void readgridncsize&lt; deformmap&lt; float &gt; &gt; (\n    deformmap &lt; float &gt; &amp; Imap\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readgridncsize-forcingmap","title":"function readgridncsize&lt; forcingmap &gt;","text":"<pre><code>template void readgridncsize&lt; forcingmap &gt; (\n    forcingmap &amp; Imap\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readgridncsize-inputmap","title":"function readgridncsize&lt; inputmap &gt;","text":"<pre><code>template void readgridncsize&lt; inputmap &gt; (\n    inputmap &amp; Imap\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readncslev1","title":"function readncslev1","text":"<pre><code>template&lt;class T&gt;\nint readncslev1 (\n    std::string filename,\n    std::string varstr,\n    size_t indx,\n    size_t indy,\n    size_t indt,\n    bool checkhh,\n    double eps,\n    T *&amp; zsa\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readncslev1-double","title":"function readncslev1&lt; double &gt;","text":"<pre><code>template int readncslev1&lt; double &gt; (\n    std::string filename,\n    std::string varstr,\n    size_t indx,\n    size_t indy,\n    size_t indt,\n    bool checkhh,\n    double eps,\n    double *&amp; zsa\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readncslev1-float","title":"function readncslev1&lt; float &gt;","text":"<pre><code>template int readncslev1&lt; float &gt; (\n    std::string filename,\n    std::string varstr,\n    size_t indx,\n    size_t indy,\n    size_t indt,\n    bool checkhh,\n    double eps,\n    float *&amp; zsa\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readnctime","title":"function readnctime","text":"<pre><code>int readnctime (\n    std::string filename,\n    double *&amp; time\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readnctime2","title":"function readnctime2","text":"<pre><code>int readnctime2 (\n    int ncid,\n    char * timecoordname,\n    std::string refdate,\n    size_t nt,\n    double *&amp; time\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readnczb","title":"function readnczb","text":"<pre><code>void readnczb (\n    int nx,\n    int ny,\n    std::string ncfile,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readvardata","title":"function readvardata","text":"<pre><code>template&lt;class T&gt;\nint readvardata (\n    std::string filename,\n    std::string Varname,\n    int step,\n    T *&amp; vardata,\n    bool flipx,\n    bool flipy\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readvardata-double","title":"function readvardata&lt; double &gt;","text":"<pre><code>template int readvardata&lt; double &gt; (\n    std::string filename,\n    std::string Varname,\n    int step,\n    double *&amp; vardata,\n    bool flipx,\n    bool flipy\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readvardata-float","title":"function readvardata&lt; float &gt;","text":"<pre><code>template int readvardata&lt; float &gt; (\n    std::string filename,\n    std::string Varname,\n    int step,\n    float *&amp; vardata,\n    bool flipx,\n    bool flipy\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readvardata-int","title":"function readvardata&lt; int &gt;","text":"<pre><code>template int readvardata&lt; int &gt; (\n    std::string filename,\n    std::string Varname,\n    int step,\n    int *&amp; vardata,\n    bool flipx,\n    bool flipy\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8cu/#function-readvarinfo","title":"function readvarinfo","text":"<pre><code>int readvarinfo (\n    std::string filename,\n    std::string Varname,\n    size_t *&amp; ddimU\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Read_netcdf.cu</code></p>"},{"location":"BGFlood/Read__netcdf_8cu_source/","title":"File Read_netcdf.cu","text":""},{"location":"BGFlood/Read__netcdf_8cu_source/#file-read_netcdfcu","title":"File Read_netcdf.cu","text":"<p>File List &gt; src &gt; Read_netcdf.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //\n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n#include \"Read_netcdf.h\"\n\n\n\n\n\ninline int nc_get_var_T(int ncid, int varid, float * &amp;zb)\n{\n    int status;\n    status = nc_get_var_float(ncid, varid, zb);\n    return status;\n}\ninline int nc_get_var_T(int ncid, int varid, double * &amp;zb)\n{\n    int status;\n    status = nc_get_var_double(ncid, varid, zb);\n    return status;\n}\ninline int nc_get_var_T(int ncid, int varid, int*&amp; zb)\n{\n    int status;\n    status = nc_get_var_int(ncid, varid, zb);\n    return status;\n}\n\ninline int nc_get_vara_T(int ncid, int varid, const size_t* startp, const size_t* countp, int*&amp; zb)\n{\n    int status;\n    status = nc_get_vara_int(ncid, varid, startp, countp, zb);\n    return status;\n\n}\ninline int nc_get_vara_T(int ncid, int varid, const size_t* startp, const size_t* countp, float * &amp;zb)\n{\n    int status;\n    status = nc_get_vara_float(ncid, varid, startp, countp, zb);\n    return status;\n\n}\ninline int nc_get_vara_T(int ncid, int varid, const size_t* startp, const size_t* countp, double * &amp;zb)\n{\n    int status;\n    status = nc_get_vara_double(ncid, varid, startp, countp, zb);\n    return status;\n\n}\n\ninline int nc_get_var1_T(int ncid, int varid, const size_t* startp, float * zsa)\n{\n    int status;\n    status = nc_get_var1_float(ncid, varid, startp, zsa);\n    return status;\n}\ninline int nc_get_var1_T(int ncid, int varid, const size_t* startp, double * zsa)\n{\n    int status;\n    status = nc_get_var1_double(ncid, varid, startp, zsa);\n    return status;\n}\n\n\n\n\n//void readgridncsize(const std::string ncfilestr, const std::string varstr, int &amp;nx, int &amp;ny, int &amp;nt, double &amp;dx, double &amp;xo, double &amp;yo, double &amp;to, double &amp;xmax, double &amp;ymax, double &amp;tmax, bool &amp; flipx, bool &amp; flipy)\n//void readgridncsize(forcingmap &amp;Fmap, Param XParam)\nvoid readgridncsize(const std::string ncfilestr, const std::string varstr, std::string reftime, int&amp; nx, int&amp; ny, int&amp; nt, double&amp; dx, double&amp; dy, double&amp; dt, double&amp; xo, double&amp; yo, double&amp; to, double&amp; xmax, double&amp; ymax, double&amp; tmax, bool&amp; flipx, bool&amp; flipy)\n{\n    //std::string ncfilestr = Fmap.inputfile;\n    //std::string varstr = Fmap.varname;\n\n    //int nx, ny, nt;\n    //double dx, dt, xo, xmax, yo, ymax, to, tmax;\n    //bool flipx, flipy;\n\n    //read the dimentions of grid, levels and time\n    int status;\n    int ncid, ndimshh, ndims;\n    double *xcoord, *ycoord;\n    int varid;\n\n    //int ndimsp, nvarsp, nattsp, unlimdimidp;\n\n    int dimids[NC_MAX_VAR_DIMS];   /* dimension IDs */\n    char coordname[NC_MAX_NAME + 1];\n    //char varname[NC_MAX_NAME + 1];\n    size_t  *ddimhh;\n\n\n    //Open NC file\n    //printf(\"Open file\\n\");\n    status = nc_open(ncfilestr.c_str(), NC_NOWRITE, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n    //printf(\" %s...\\n\", hhvar);\n    status = nc_inq_varid(ncid, varstr.c_str(), &amp;varid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n\n    status = nc_inq_varndims(ncid, varid, &amp;ndimshh);\n    if (status != NC_NOERR) handle_ncerror(status);\n    //printf(\"hhVar:%d dims\\n\", ndimshh);\n\n    status = nc_inq_vardimid(ncid, varid, dimids);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    ddimhh = (size_t *)malloc(ndimshh*sizeof(size_t));\n\n    //Read dimensions nx_u ny_u\n    for (int iddim = 0; iddim &lt; ndimshh; iddim++)\n    {\n        status = nc_inq_dimlen(ncid, dimids[iddim], &amp;ddimhh[iddim]);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        //printf(\"dim:%d=%d\\n\", iddim, ddimhh[iddim]);\n    }\n\n    if (ndimshh &gt; 2)\n    {\n        nt = (int) ddimhh[0];\n        ny = (int) ddimhh[1];\n        nx = (int) ddimhh[2];\n\n    }\n    else\n    {\n        nt = 0;\n        ny = (int) ddimhh[0];\n        nx = (int) ddimhh[1];\n    }\n\n    //allocate\n    xcoord = (double *)malloc(nx*ny*sizeof(double));\n    ycoord = (double *)malloc(nx*ny*sizeof(double));\n\n    //inquire variable name for x dimension\n    //aka x dim of hh\n    int ycovar, xcovar, tcovar;\n\n    if (ndimshh &gt; 2)\n    {\n        tcovar = dimids[0];\n        ycovar = dimids[1];\n        xcovar = dimids[2];\n    }\n    else\n    {\n        ycovar = dimids[0];\n        xcovar = dimids[1];\n    }\n\n    //ycoord\n    status = nc_inq_dimname(ncid, ycovar, coordname);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_inq_varid(ncid, coordname, &amp;varid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_inq_varndims(ncid, varid, &amp;ndims);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    if (ndims &lt; 2)\n    {\n        double * ytempvar;\n        ytempvar = (double *)malloc(ny*sizeof(double));\n        size_t start[] = { 0 };\n        size_t count[] = { (size_t)ny };\n        status = nc_get_vara_double(ncid, varid, start, count, ytempvar);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        for (int i = 0; i&lt;nx; i++)\n        {\n            for (int j = 0; j&lt;ny; j++)\n            {\n\n                ycoord[i + j*nx] = ytempvar[j];\n\n            }\n        }\n        free(ytempvar);\n    }\n    else\n    {\n        size_t start[] = { 0, 0 };\n        size_t count[] = { (size_t)ny, (size_t)nx };\n        status = nc_get_vara_double(ncid, varid, start, count, ycoord);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n    }\n    //xcoord\n    status = nc_inq_dimname(ncid, xcovar, coordname);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_inq_varid(ncid, coordname, &amp;varid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_inq_varndims(ncid, varid, &amp;ndims);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    if (ndims &lt; 2)\n    {\n        double * xtempvar;\n        xtempvar = (double *)malloc(nx*sizeof(double));\n        size_t start[] = { 0 };\n        size_t count[] = { (size_t)nx };\n        status = nc_get_vara_double(ncid, varid, start, count, xtempvar);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        for (int i = 0; i&lt;nx; i++)\n        {\n            for (int j = 0; j&lt;ny; j++)\n            {\n\n                xcoord[i + j*nx] = xtempvar[i];\n\n            }\n        }\n        free(xtempvar);\n    }\n    else\n    {\n        size_t start[] = { 0, 0 };\n        size_t count[] = { (size_t)ny, (size_t)nx };\n        status = nc_get_vara_double(ncid, varid, start, count, xcoord);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n    }\n\n    double dxx,ddy;\n    //check dx\n    dxx = abs(xcoord[nx - 1] - xcoord[0]) / (nx - 1.0);\n    ddy = abs(ycoord[(ny - 1) * nx]- ycoord[0]) / (ny - 1.0);\n    //log(\"xo=\" + std::to_string(xcoord[0])+\"; xmax=\"+ std::to_string(xcoord[nx - 1]) +\"; nx=\"+ std::to_string(nx) +\"; dxx=\" +std::to_string(dxx));\n    //dyy = (float) abs(ycoord[0] - ycoord[(ny - 1)*nx]) / (ny - 1);\n\n\n    //Read time dimension if any\n    if (nt &gt; 0)\n    {\n        //read dimension name\n        status = nc_inq_dimname(ncid, tcovar, coordname);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n\n\n\n        //inquire variable id\n        status = nc_inq_varid(ncid, coordname, &amp;varid);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n\n\n\n        // read the dimension of time variable // yes it should be == 1\n        status = nc_inq_varndims(ncid, varid, &amp;ndims);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        //allocate temporary array and read time vector\n        double * ttempvar;\n        ttempvar = (double *)malloc(nt * sizeof(double));\n        //size_t start[] = { 0 };\n        //size_t count[] = { (size_t)nt };\n        //status = nc_get_vara_double(ncid, varid, start, count, ttempvar);\n\n        status = readnctime2(ncid, coordname, reftime, nt, ttempvar);\n\n        to = ttempvar[0];\n        tmax= ttempvar[nt-1];\n        dt = ttempvar[1] - ttempvar[0];\n\n        free(ttempvar);\n    }\n    else\n    {\n        //this is a 2d file so assign dummy values\n        to = 0.0;\n        tmax = 0.0;\n    }\n\n    dx = dxx;\n    dy = ddy;\n\n    xo = utils::min(xcoord[0], xcoord[nx - 1]);\n    xmax = utils::max(xcoord[0], xcoord[nx - 1]);\n    yo = utils::min(ycoord[0], ycoord[(ny - 1) * nx]);\n    ymax = utils::max(ycoord[(ny - 1)*nx], ycoord[0]);\n\n\n    if (xcoord[0] &gt; xcoord[nx - 1])\n        flipx = true;\n\n    if (ycoord[0] &gt; ycoord[(ny - 1) * nx])\n        flipy = true;\n\n\n    status = nc_close(ncid);\n\n\n\n    free(ddimhh);\n    free(xcoord);\n    free(ycoord);\n\n\n}\n\n\nvoid readgridncsize(forcingmap&amp; Fmap, Param XParam)\n{\n\n    readgridncsize(Fmap.inputfile, Fmap.varname, XParam.reftime, Fmap.nx, Fmap.ny, Fmap.nt, Fmap.dx, Fmap.dy, Fmap.dt, Fmap.xo, Fmap.yo, Fmap.to, Fmap.xmax, Fmap.ymax, Fmap.tmax, Fmap.flipxx, Fmap.flipyy);\n}\n\n\ntemplate&lt;class T&gt; void readgridncsize(T&amp; Imap)\n{\n    double a, b, c;\n    int duma;\n    readgridncsize(Imap.inputfile, Imap.varname, \"2000-01-01T00:00:00\", Imap.nx, Imap.ny, duma, Imap.dx, Imap.dy, a, Imap.xo, Imap.yo, b, Imap.xmax, Imap.ymax, c, Imap.flipxx, Imap.flipyy);\n}\ntemplate void readgridncsize&lt;inputmap&gt;(inputmap &amp;Imap);\ntemplate void readgridncsize&lt;forcingmap&gt;(forcingmap &amp;Imap);\ntemplate void readgridncsize&lt;StaticForcingP&lt;int &gt;&gt;(StaticForcingP&lt;int&gt;&amp; Imap);\ntemplate void readgridncsize&lt;StaticForcingP&lt;float &gt;&gt;(StaticForcingP&lt;float&gt; &amp;Imap);\ntemplate void readgridncsize&lt;deformmap&lt;float &gt;&gt;(deformmap&lt;float &gt;&amp; Imap);\ntemplate void readgridncsize&lt;DynForcingP&lt;float &gt;&gt;(DynForcingP&lt;float &gt;&amp; Imap);\n\n\nint readvarinfo(std::string filename, std::string Varname, size_t *&amp;ddimU)\n{\n    // This function reads the dimensions for each variables\n    int status, varid;\n    int ncid, ndims;\n    int dimids[NC_MAX_VAR_DIMS];\n    //Open NC file\n    //printf(\"Open file\\n\");\n\n    status = nc_open(filename.c_str(), 0, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //inquire variable by name\n    //printf(\"Reading information about %s...\", Varname.c_str());\n    status = nc_inq_varid(ncid, Varname.c_str(), &amp;varid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_inq_varndims(ncid, varid, &amp;ndims);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n    status = nc_inq_vardimid(ncid, varid, dimids);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    ddimU = (size_t *)malloc(ndims*sizeof(size_t));\n\n    //Read dimensions nx_u ny_u\n    for (int iddim = 0; iddim &lt; ndims; iddim++)\n    {\n        status = nc_inq_dimlen(ncid, dimids[iddim], &amp;ddimU[iddim]);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        //printf(\"dim:%d=%d\\n\", iddim, ddimU[iddim]);\n    }\n\n\n    status = nc_close(ncid);\n\n    return ndims;\n}\n\n\nint readnctime(std::string filename, double * &amp;time)\n{\n    int status, ncid, varid;\n\n    std::string ncfilestr;\n    std::string varstr;\n\n\n    //char ncfile[]=\"ocean_ausnwsrstwq2.nc\";\n    std::vector&lt;std::string&gt; nameelements;\n\n    nameelements = split(filename, '?');\n    if (nameelements.size() &gt; 1)\n    {\n        //variable name for bathy is not given so it is assumed to be zb\n        ncfilestr = nameelements[0];\n        //varstr = nameelements[1];\n    }\n    else\n    {\n        ncfilestr = filename;\n        //varstr = \"time\";\n    }\n\n    // Warning this could be more robust by taking the unlimited dimention if time does not exist!\n    std::string Varname = \"time\";\n\n    status = nc_open(ncfilestr.c_str(), 0, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_inq_varid(ncid, Varname.c_str(), &amp;varid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_get_var_double(ncid, varid, time);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_close(ncid);\n\n    return status;\n}\n\nint readnctime2(int ncid,char * timecoordname,std::string refdate,size_t nt, double*&amp; time)\n{\n\n    int status, varid;\n\n    std::string ncfilestr;\n    std::string varstr;\n\n    double fac = 1.0;\n    double offset = 0.0;\n\n    //char ncfile[]=\"ocean_ausnwsrstwq2.nc\";\n\n\n    // Warning this could be more robust by taking the unlimited dimension if time does not exist!\n    //std::string Varname = \"time\";\n\n\n    status = nc_inq_varid(ncid, timecoordname, &amp;varid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    // inquire unit of time\n    int ncAttid;\n    size_t t_len;\n\n    char* tunit;\n\n    std::string tunitstr;\n\n    /* Get the attribute ID */\n    status = nc_inq_attid(ncid, varid, \"units\", &amp;ncAttid);\n    if (status == NC_NOERR)\n    {\n        /* Read units attribute length from the variable */\n        status = nc_inq_attlen(ncid, varid, \"units\", &amp;t_len);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        tunit = (char*)malloc(t_len + 1); // +1 to automatically have a null character at the end. Is this cross platform portable?\n\n        /* Read units attribute from the variable */\n        status = nc_get_att_text(ncid, varid, \"units\", tunit);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        // convert to string\n        tunitstr = std::string(tunit);\n\n        std::string ncstepunit= tunitstr;\n\n        if (tunitstr.find(\"since\") != std::string::npos)\n        {\n\n            // Try to make sense of the unit\n            // The word \"since\" should be in the center\n            // e.g. hour since 2000-01-01 00:00:00 \n            std::vector&lt;std::string&gt; nodeitems = split(tunitstr, \"since\");\n            ncstepunit = trim(nodeitems[0], \" \");\n            std::string ncrefdatestr = trim(nodeitems[1], \" \");\n\n            //time_t ncrefdate = date_string_to_time(ncrefdatestr);\n            offset = date_string_to_s(ncrefdatestr, refdate);\n        }\n\n        std::vector&lt;std::string&gt; secondvec = { \"seconds\",\"second\",\"sec\",\"s\" };\n        std::vector&lt;std::string&gt; minutevec = { \"minutes\",\"minute\",\"min\",\"m\" };\n        std::vector&lt;std::string&gt; hourvec = { \"hours\",\"hour\",\"hrs\",\"hr\",\"h\" };\n        std::vector&lt;std::string&gt; dayvec = { \"days\",\"day\",\"d\" };\n        std::vector&lt;std::string&gt; monthvec = { \"months\",\"month\",\"mths\", \"mth\", \"mon\" };\n        std::vector&lt;std::string&gt; yearvec = { \"years\",\"year\",\"yrs\", \"yr\", \"y\" };\n\n\n        std::size_t found;\n        found = case_insensitive_compare(ncstepunit, secondvec);\n        if (found == 0)\n            fac = 1.0;\n\n        found = case_insensitive_compare(ncstepunit, minutevec);\n        if (found == 0)\n            fac = 60.0;\n\n        found = case_insensitive_compare(ncstepunit, hourvec);\n        if (found == 0)\n            fac = 3600.0;\n\n        found = case_insensitive_compare(ncstepunit, dayvec);\n        if (found == 0)\n            fac = 3600.0*24.0;\n\n        found = case_insensitive_compare(ncstepunit, monthvec);\n        if (found == 0)\n            fac = 3600.0 * 24.0 * 30.4375;\n\n        found = case_insensitive_compare(ncstepunit, yearvec);\n        if (found == 0)\n            fac = 3600.0 * 24.0 * 365.25;\n\n\n    }\n\n    status = nc_get_var_double(ncid, varid, time);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    for (int it = 0; it &lt; nt; it++)\n    {\n        time[it] = time[it] * fac + offset;\n        //printf(\"%f\\n\", time[it]);\n    }\n\n\n    return status;\n\n}\n\ntemplate &lt;class T&gt;\nint readncslev1(std::string filename, std::string varstr, size_t indx, size_t indy, size_t indt, bool checkhh, double eps, T * &amp;zsa)\n{\n    int status, ncid, varid,ndims,sferr,oferr,misserr,fillerr, iderr;\n    double scalefac, offset, missing, fillval;\n\n    double hha,zza;\n\n    //bool checkhh = false;\n\n    int wet = 1;\n\n    size_t *start;\n    //std::string Varname = \"time\";\n    ndims = 3;\n\n    start = (size_t *)malloc(ndims*sizeof(size_t));\n    //count = (size_t *)malloc(ndims*sizeof(size_t));\n\n    start[0] = indt;\n    start[1] = indy;\n    start[2] = indx;\n\n    //std::string ncfilestr;\n    //std::string varstr;\n\n\n    //char ncfile[]=\"ocean_ausnwsrstwq2.nc\";\n    //std::vector&lt;std::string&gt; nameelements;\n\n    /*nameelements = split(filename, '?');\n    if (nameelements.size() &gt; 1)\n    {\n\n        ncfilestr = nameelements[0];\n        varstr = nameelements[1];\n    }\n    else\n    {\n\n        ncfilestr = filename;\n        varstr = \"zs\";\n        checkhh = true;\n    }*/\n\n    status = nc_open(filename.c_str(), 0, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_inq_varid(ncid, varstr.c_str(), &amp;varid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_get_var1_T(ncid, varid, start, zsa);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n\n    sferr = nc_get_att_double(ncid, varid, \"scale_factor\", &amp;scalefac);\n    oferr = nc_get_att_double(ncid, varid, \"add_offset\", &amp;offset);\n\n    // Check if variable is a missing value\n\n    misserr = nc_get_att_double(ncid, varid, \"_FillValue\", &amp;missing);\n\n    fillerr = nc_get_att_double(ncid, varid, \"missingvalue\", &amp;fillval);\n\n    if (misserr == NC_NOERR)\n    {\n        if (zsa[0] == missing)\n        {\n            zsa[0] = 0.0;\n            wet = 0;\n        }\n    }\n    if (fillerr == NC_NOERR)\n    {\n        if (zsa[0] == fillval)\n        {\n            zsa[0] = 0.0;\n            wet = 0;\n        }\n    }\n\n\n\n\n    if (sferr == NC_NOERR || oferr == NC_NOERR) // data must be packed\n    {\n        zsa[0] = zsa[0] * (T)scalefac + (T)offset;\n    }\n\n    if (checkhh)\n    {\n        zza = zsa[0];\n        iderr = nc_inq_varid(ncid, \"hh\", &amp;varid);\n        if (iderr == NC_NOERR)\n        {\n            if (typeid(T) == typeid(float))\n                status = nc_get_var1_T(ncid, varid, start, zsa);\n            if (typeid(T) == typeid(double))\n                status = nc_get_var1_T(ncid, varid, start, zsa);\n            //status = nc_get_var1_double(ncid, varid, start, zsa);\n            sferr = nc_get_att_double(ncid, varid, \"scale_factor\", &amp;scalefac);\n            oferr = nc_get_att_double(ncid, varid, \"add_offset\", &amp;offset);\n\n            // Check if variable is a missing value\n\n            misserr = nc_get_att_double(ncid, varid, \"_FillValue\", &amp;missing);\n\n            fillerr = nc_get_att_double(ncid, varid, \"missingvalue\", &amp;fillval);\n\n            if (misserr == NC_NOERR)\n            {\n                if (zsa[0] == missing)\n                {\n                    zsa[0] = 0.0;\n                    wet = 0;\n                }\n            }\n            if (fillerr == NC_NOERR)\n            {\n                if (zsa[0] == fillval)\n                {\n                    zsa[0] = 0.0;\n                    wet = 0;\n                }\n            }\n\n\n\n\n            if (sferr == NC_NOERR || oferr == NC_NOERR) // data must be packed\n            {\n                zsa[0] = zsa[0] * (T)scalefac + (T)offset;\n            }\n\n            hha = zsa[0];\n            if (hha &gt; eps)\n            {\n                zsa[0] = T(zza);\n            }\n            else\n            {\n                zsa[0] = T(0.0);\n                wet = 0;\n            }\n\n        }\n\n\n    }\n\n\n\n    status = nc_close(ncid);\n\n    free(start);\n    //free(count);\n\n\n    return wet;\n}\n\ntemplate int readncslev1&lt;float&gt;(std::string filename, std::string varstr, size_t indx, size_t indy, size_t indt, bool checkhh, double eps, float * &amp;zsa);\ntemplate int readncslev1&lt;double&gt;(std::string filename, std::string varstr, size_t indx, size_t indy, size_t indt, bool checkhh, double eps, double * &amp;zsa);\n\n\ntemplate &lt;class T&gt;\nint readvardata(std::string filename, std::string Varname, int step, T * &amp;vardata, bool flipx, bool flipy)\n{\n    // function to standardise the way to read netCDF data off a file\n    // The role of this function is to offload and simplify the rest of the code\n\n\n    int nx, ny, nt, status, ncid, varid, sferr, oferr, merr,ndims;\n    size_t * start, * count, *ddim;\n    double scalefac, offset, missing;\n\n\n\n\n\n    ndims = readvarinfo(filename, Varname, ddim);\n\n    start = (size_t *)malloc(ndims*sizeof(size_t));\n    count = (size_t *)malloc(ndims*sizeof(size_t));\n\n\n\n    //\n    status = nc_open(filename.c_str(), 0, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_inq_varid(ncid, Varname.c_str(), &amp;varid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    if (ndims == 1)\n    {\n        nx = (int)ddim[0];\n        start[0] = 0;\n        count[0] =  nx ;\n\n\n\n    }\n    else if (ndims == 2)\n    {\n        ny = (int)ddim[0];\n        nx = (int)ddim[1];\n        start[0] = 0;\n        start[1] = 0;\n\n        count[0] = ny;\n        count[1] = nx;\n\n\n\n\n    }\n    else //(ndim&gt;2)\n    {\n        nt = (int)ddim[0];\n        ny = (int)ddim[1];\n        nx = (int)ddim[2];\n        start[0] = size_t(utils::min(step, nt - 1));\n        start[1] = size_t(0);\n        start[2] = size_t(0);\n\n        count[0] = size_t(1);\n        count[1] = size_t(ny);\n        count[2] = size_t(nx);\n\n\n\n    }\n\n    //double* xo,xnd;\n\n\n    status = nc_get_vara_T(ncid, varid, start, count, vardata);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    if (ndims &gt; 1)\n    {\n\n        sferr = nc_get_att_double(ncid, varid, \"scale_factor\", &amp;scalefac);\n        oferr = nc_get_att_double(ncid, varid, \"add_offset\", &amp;offset);\n\n        merr = nc_get_att_double(ncid, varid, \"missingvalue\", &amp;missing);\n        if (merr != NC_NOERR)\n        {\n            merr = nc_get_att_double(ncid, varid, \"_FillValue\", &amp;missing);\n        }\n        if (merr != NC_NOERR)\n        {\n            merr = nc_get_att_double(ncid, varid, \"missing_value\", &amp;missing);\n        }\n\n        // remove fill value\n        if (merr == NC_NOERR)\n        {\n            //T maxval = T(-99999.0);\n            for (int j = 0; j &lt; ny; j++)\n            {\n                for (int i = 0; i &lt; nx; i++)\n                {\n                    bool test = missing != missing ? vardata[i + j * nx] != vardata[i + j * nx] : (abs(vardata[i + j * nx]) &gt; abs(T(0.9 * missing)));\n                    if (test) // i.e. if vardata is anywhere near missing\n                    {\n\n                        vardata[i + j * nx] = T(NAN);\n                    }\n                    //maxval = utils::max(maxval, vardata[i + j * nx]);\n                }\n            }\n            //printf(\"maxval = %f\\n\", float(maxval));\n        }\n\n        if (flipx)\n        {\n            T* xdata;\n            xdata=(T*)malloc(nx * sizeof(T));\n            for (int j = 0; j &lt; ny; j++)\n            {\n                for (int i = 0; i &lt; nx; i++)\n                {\n                    xdata[i] = vardata[i + j * nx];\n                    //unpacked_value = packed_value * scale_factor + add_offset\n\n                }\n                for (int i = 0; i &lt; nx; i++)\n                {\n                    vardata[i + j * nx] = xdata[nx - 1 - i];\n                    //unpacked_value = packed_value * scale_factor + add_offset\n\n                }\n            }\n            free(xdata);\n        }\n\n        if (flipy)\n        {\n            T* ydata;\n            ydata = (T*)malloc(ny * sizeof(T));\n            for (int i = 0; i &lt; nx; i++)\n            {\n                for (int j = 0; j &lt; ny; j++)\n                {\n                    ydata[j] = vardata[i + j * nx];\n                    //unpacked_value = packed_value * scale_factor + add_offset\n\n                }\n                for (int j = 0; j &lt; ny; j++)\n                {\n                    vardata[i + j * nx] = ydata[ny - 1 - j];\n                    //unpacked_value = packed_value * scale_factor + add_offset\n\n                }\n            }\n            free(ydata);\n        }\n\n\n\n        // apply scale and offset\n        if (sferr == NC_NOERR || oferr == NC_NOERR) // data must be packed\n        {\n            for (int j = 0; j &lt; ny; j++)\n            {\n                for (int i = 0; i &lt; nx; i++)\n                {\n                    vardata[i + j * nx] = vardata[i + j * nx] * (T)scalefac + (T)offset;\n                    //unpacked_value = packed_value * scale_factor + add_offset\n\n                }\n            }\n        }\n    }\n\n\n\n    //clean up\n    free(start);\n    free(count);\n\n    status = nc_close(ncid);\n\n    return status;\n\n}\ntemplate int readvardata&lt;int&gt;(std::string filename, std::string Varname, int step, int*&amp; vardata, bool flipx, bool flipy);\ntemplate int readvardata&lt;float&gt;(std::string filename, std::string Varname, int step, float * &amp;vardata, bool flipx, bool flipy);\ntemplate int readvardata&lt;double&gt;(std::string filename, std::string Varname, int step, double * &amp;vardata, bool flipx, bool flipy);\n\n\n\n\nstd::string checkncvarname(int ncid, std::string stringA, std::string stringB, std::string stringC, std::string stringD, std::string stringE)\n{\n    int varid;\n    int errorA, errorB,errorC,errorD,errorE;\n    std::string outstring;\n\n    //std::vector&lt;std::string&gt; teststr;\n\n    //teststr.push_back((stringA))\n\n\n    errorA = nc_inq_varid(ncid, stringA.c_str(), &amp;varid);\n    errorB = nc_inq_varid(ncid, stringB.c_str(), &amp;varid);\n    errorC = nc_inq_varid(ncid, stringC.c_str(), &amp;varid);\n    errorD = nc_inq_varid(ncid, stringD.c_str(), &amp;varid);\n    errorE = nc_inq_varid(ncid, stringE.c_str(), &amp;varid);\n\n\n    if (errorA == NC_NOERR)\n    {\n        outstring = stringA;\n    }\n    else if (errorB == NC_NOERR)\n    {\n        outstring = stringB;\n    }\n    else if (errorC == NC_NOERR)\n    {\n        outstring = stringC;\n    }\n    else if (errorD == NC_NOERR)\n    {\n        outstring = stringD;\n    }\n    else if (errorE == NC_NOERR)\n    {\n        outstring = stringE;\n    }\n\n    return outstring;\n\n\n}\n\n//By default we want to read wind info as float because it will reside in a texture. the value is converted to the apropriate type only when it is used. so there is no need to template this function \nvoid readWNDstep(forcingmap WNDUmap, forcingmap WNDVmap, int steptoread, float *&amp;Uo, float *&amp;Vo)\n{\n    //\n    int status;\n    int ncid;\n    //float NanValU = -9999, NanValV = -9999, NanValH = -9999;\n    int uu_id, vv_id;\n    // step to read should be adjusted in each variables so that it keeps using the last output and teh model keeps on going\n    // right now the model will catch anexception\n    printf(\"Reading Wind data step: %d ...\", steptoread);\n    //size_t startl[]={hdstep-1,lev,0,0};\n    //size_t countlu[]={1,1,netau,nxiu};\n    //size_t countlv[]={1,1,netav,nxiv};\n    size_t startl[] = { (size_t)steptoread, 0, 0 };\n    size_t countlu[] = { 1, (size_t)WNDUmap.ny, (size_t)WNDUmap.nx };\n    size_t countlv[] = { 1, (size_t)WNDVmap.ny, (size_t)WNDVmap.nx };\n\n    //static ptrdiff_t stridel[]={1,1,1,1};\n    //static ptrdiff_t stridel[] = { 1, 1, 1 };\n\n    std::string ncfilestrU, ncfilestrV;\n    std::string Uvarstr, Vvarstr;\n\n\n    //char ncfile[]=\"ocean_ausnwsrstwq2.nc\";\n    std::vector&lt;std::string&gt; nameelements;\n    //by default we expect tab delimitation\n    nameelements = split(WNDUmap.inputfile, '?');\n    if (nameelements.size() &gt; 1)\n    {\n        //variable name for bathy is not given so it is assumed to be zb\n        ncfilestrU = nameelements[0];\n        Uvarstr = nameelements[1];\n    }\n    else\n    {\n        ncfilestrU = WNDUmap.inputfile;\n        Uvarstr = \"uwnd\";\n    }\n\n    nameelements = split(WNDVmap.inputfile, '?');\n    if (nameelements.size() &gt; 1)\n    {\n        //variable name for bathy is not given so it is assumed to be zb\n        ncfilestrV = nameelements[0];\n        Vvarstr = nameelements[1];\n    }\n    else\n    {\n        ncfilestrV = WNDVmap.inputfile;\n        Vvarstr = \"vwnd\";\n    }\n\n\n    //Open NC file\n\n    status = nc_open(ncfilestrU.c_str(), 0, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //status = nc_inq_varid (ncid, \"u\", &amp;uu_id);\n    status = nc_inq_varid(ncid, Uvarstr.c_str(), &amp;uu_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_get_vara_float(ncid, uu_id, startl, countlu, Uo);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //status = nc_get_att_float(ncid, uu_id, \"_FillValue\", &amp;NanValU);\n    //if (status != NC_NOERR) handle_error(status);\n\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_open(ncfilestrV.c_str(), 0, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    //status = nc_inq_varid (ncid, \"v\", &amp;vv_id);\n    status = nc_inq_varid(ncid, Vvarstr.c_str(), &amp;vv_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_get_vara_float(ncid, vv_id, startl, countlv, Vo);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //status = nc_get_att_float(ncid, vv_id, \"_FillValue\", &amp;NanValV);\n    //if (status != NC_NOERR) handle_error(status);\n\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    printf(\"Done!\\n\");\n\n}\n\n//Atm pressure is same as wind we on;ly read floats and that is plenty for real world application\nvoid readATMstep(forcingmap ATMPmap, int steptoread, float *&amp;Po)\n{\n    //\n    int status;\n    int ncid;\n    //float NanValU = -9999, NanValV = -9999, NanValH = -9999;\n    int uu_id;\n    // step to read should be adjusted in each variables so that it keeps using the last output and teh model keeps on going\n    // right now the model will catch anexception\n    printf(\"Reading atm pressure data. step: %d ...\", steptoread);\n    //size_t startl[]={hdstep-1,lev,0,0};\n    //size_t countlu[]={1,1,netau,nxiu};\n    //size_t countlv[]={1,1,netav,nxiv};\n    size_t startl[] = { (size_t)steptoread, 0, 0 };\n    size_t countlu[] = { 1, (size_t)ATMPmap.ny, (size_t)ATMPmap.nx };\n    //size_t countlv[] = { 1, WNDVmap.ny, WNDVmap.nx };\n\n    //static ptrdiff_t stridel[]={1,1,1,1};\n    //static ptrdiff_t stridel[] = { 1, 1, 1 };\n\n    std::string ncfilestr;\n    std::string atmpvarstr;\n\n\n    //char ncfile[]=\"ocean_ausnwsrstwq2.nc\";\n    std::vector&lt;std::string&gt; nameelements;\n    //by default we expect tab delimitation\n    nameelements = split(ATMPmap.inputfile, '?');\n    if (nameelements.size() &gt; 1)\n    {\n        //variable name for bathy is not given so it is assumed to be zb\n        ncfilestr = nameelements[0];\n        atmpvarstr = nameelements[1];\n    }\n    else\n    {\n        ncfilestr = ATMPmap.inputfile;\n        atmpvarstr = \"atmP\";\n    }\n\n\n    //Open NC file\n\n    status = nc_open(ncfilestr.c_str(), 0, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //status = nc_inq_varid (ncid, \"u\", &amp;uu_id);\n    status = nc_inq_varid(ncid, atmpvarstr.c_str(), &amp;uu_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_get_vara_float(ncid, uu_id, startl, countlu, Po);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //status = nc_get_att_float(ncid, uu_id, \"_FillValue\", &amp;NanValU);\n    //if (status != NC_NOERR) handle_error(status);\n\n    status = nc_close(ncid);\n\n    printf(\"Done!\\n\");\n\n}\n\n// The following functions are simple tools to create 2D or 3D netcdf files (for testing for example)\n\nextern \"C\" void read3Dnc(int nx, int ny, int ntheta, char ncfile[], float * &amp;ee)\n{\n    int status;\n    int ncid, ee_id;\n    //static size_t count[] = { nx, ny,ntheta };\n    status = nc_open(ncfile, NC_NOWRITE, &amp;ncid);\n    status = nc_inq_varid(ncid, \"z\", &amp;ee_id);\n    status = nc_get_var_float(ncid, ee_id, ee);\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n}\n\nextern \"C\" void read2Dnc(int nx, int ny, char ncfile[], float * &amp;hh)\n{\n    int status;\n    int ncid, hh_id;\n    //static size_t count[] = { nx, ny };\n    status = nc_open(ncfile, NC_NOWRITE, &amp;ncid);\n    status = nc_inq_varid(ncid, \"hh\", &amp;hh_id);\n    status = nc_get_var_float(ncid, hh_id, hh);\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n}\n\nextern \"C\" void readnczb(int nx, int ny, std::string ncfile, float * &amp;zb)\n{\n    int status;\n    int ncid, hh_id;\n    //static size_t count[] = { nx, ny };\n\n    status = nc_open(ncfile.c_str(), NC_NOWRITE, &amp;ncid);\n    status = nc_inq_varid(ncid, \"zb\", &amp;hh_id);\n    status = nc_get_var_float(ncid, hh_id, zb);\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n}\n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/","title":"File Read_netcdf.h","text":""},{"location":"BGFlood/Read__netcdf_8h/#file-read_netcdfh","title":"File Read_netcdf.h","text":"<p>FileList &gt; src &gt; Read_netcdf.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Input.h\"</code></li> <li><code>#include \"ReadInput.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"Write_netcdf.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"GridManip.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"utctime.h\"</code></li> </ul>"},{"location":"BGFlood/Read__netcdf_8h/#public-functions","title":"Public Functions","text":"Type Name std::string checkncvarname (int ncid, std::string stringA, std::string stringB, std::string stringC, std::string stringD, std::string stringE)  int nc_get_var1_T (int ncid, int varid, const size_t * startp, float * zsa)  int nc_get_var1_T (int ncid, int varid, const size_t * startp, double * zsa)  int nc_get_var_T (int ncid, int varid, float *&amp; zb)  int nc_get_var_T (int ncid, int varid, double *&amp; zb)  int nc_get_vara_T (int ncid, int varid, const size_t * startp, const size_t * countp, float *&amp; zb)  int nc_get_vara_T (int ncid, int varid, const size_t * startp, const size_t * countp, double *&amp; zb)  void read2Dnc (int nx, int ny, char ncfile, float *&amp; hh)  void read3Dnc (int nx, int ny, int ntheta, char ncfile, float *&amp; ee)  void readATMstep (forcingmap ATMPmap, int steptoread, float *&amp; Po)  void readWNDstep (forcingmap WNDUmap, forcingmap WNDVmap, int steptoread, float *&amp; Uo, float *&amp; Vo)  void readgridncsize (const std::string ncfilestr, const std::string varstr, std::string reftime, int &amp; nx, int &amp; ny, int &amp; nt, double &amp; dx, double &amp; dy, double &amp; dt, double &amp; xo, double &amp; yo, double &amp; to, double &amp; xmax, double &amp; ymax, double &amp; tmax, bool &amp; flipx, bool &amp; flipy)  void readgridncsize (forcingmap &amp; Fmap, Param XParam)  void readgridncsize (T &amp; Imap)  int readncslev1 (std::string filename, std::string varstr, size_t indx, size_t indy, size_t indt, bool checkhh, double eps, T *&amp; zsa)  int readnctime (std::string filename, double *&amp; time)  int readnctime2 (int ncid, char * timecoordname, std::string refdate, size_t nt, double *&amp; time)  void readnczb (int nx, int ny, std::string ncfile, float *&amp; zb)  int readvardata (std::string filename, std::string Varname, int step, T *&amp; vardata, bool flipx, bool flipy)  int readvarinfo (std::string filename, std::string Varname, size_t *&amp; ddimU)"},{"location":"BGFlood/Read__netcdf_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Read__netcdf_8h/#function-checkncvarname","title":"function checkncvarname","text":"<pre><code>std::string checkncvarname (\n    int ncid,\n    std::string stringA,\n    std::string stringB,\n    std::string stringC,\n    std::string stringD,\n    std::string stringE\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-nc_get_var1_t","title":"function nc_get_var1_T","text":"<pre><code>inline int nc_get_var1_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    float * zsa\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-nc_get_var1_t_1","title":"function nc_get_var1_T","text":"<pre><code>inline int nc_get_var1_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    double * zsa\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-nc_get_var_t","title":"function nc_get_var_T","text":"<pre><code>inline int nc_get_var_T (\n    int ncid,\n    int varid,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-nc_get_var_t_1","title":"function nc_get_var_T","text":"<pre><code>inline int nc_get_var_T (\n    int ncid,\n    int varid,\n    double *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-nc_get_vara_t","title":"function nc_get_vara_T","text":"<pre><code>inline int nc_get_vara_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    const size_t * countp,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-nc_get_vara_t_1","title":"function nc_get_vara_T","text":"<pre><code>inline int nc_get_vara_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    const size_t * countp,\n    double *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-read2dnc","title":"function read2Dnc","text":"<pre><code>void read2Dnc (\n    int nx,\n    int ny,\n    char ncfile,\n    float *&amp; hh\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-read3dnc","title":"function read3Dnc","text":"<pre><code>void read3Dnc (\n    int nx,\n    int ny,\n    int ntheta,\n    char ncfile,\n    float *&amp; ee\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-readatmstep","title":"function readATMstep","text":"<pre><code>void readATMstep (\n    forcingmap ATMPmap,\n    int steptoread,\n    float *&amp; Po\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-readwndstep","title":"function readWNDstep","text":"<pre><code>void readWNDstep (\n    forcingmap WNDUmap,\n    forcingmap WNDVmap,\n    int steptoread,\n    float *&amp; Uo,\n    float *&amp; Vo\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-readgridncsize","title":"function readgridncsize","text":"<pre><code>void readgridncsize (\n    const std::string ncfilestr,\n    const std::string varstr,\n    std::string reftime,\n    int &amp; nx,\n    int &amp; ny,\n    int &amp; nt,\n    double &amp; dx,\n    double &amp; dy,\n    double &amp; dt,\n    double &amp; xo,\n    double &amp; yo,\n    double &amp; to,\n    double &amp; xmax,\n    double &amp; ymax,\n    double &amp; tmax,\n    bool &amp; flipx,\n    bool &amp; flipy\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-readgridncsize_1","title":"function readgridncsize","text":"<pre><code>void readgridncsize (\n    forcingmap &amp; Fmap,\n    Param XParam\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-readgridncsize_2","title":"function readgridncsize","text":"<pre><code>template&lt;class T&gt;\nvoid readgridncsize (\n    T &amp; Imap\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-readncslev1","title":"function readncslev1","text":"<pre><code>template&lt;class T&gt;\nint readncslev1 (\n    std::string filename,\n    std::string varstr,\n    size_t indx,\n    size_t indy,\n    size_t indt,\n    bool checkhh,\n    double eps,\n    T *&amp; zsa\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-readnctime","title":"function readnctime","text":"<pre><code>int readnctime (\n    std::string filename,\n    double *&amp; time\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-readnctime2","title":"function readnctime2","text":"<pre><code>int readnctime2 (\n    int ncid,\n    char * timecoordname,\n    std::string refdate,\n    size_t nt,\n    double *&amp; time\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-readnczb","title":"function readnczb","text":"<pre><code>void readnczb (\n    int nx,\n    int ny,\n    std::string ncfile,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-readvardata","title":"function readvardata","text":"<pre><code>template&lt;class T&gt;\nint readvardata (\n    std::string filename,\n    std::string Varname,\n    int step,\n    T *&amp; vardata,\n    bool flipx,\n    bool flipy\n) \n</code></pre>"},{"location":"BGFlood/Read__netcdf_8h/#function-readvarinfo","title":"function readvarinfo","text":"<pre><code>int readvarinfo (\n    std::string filename,\n    std::string Varname,\n    size_t *&amp; ddimU\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Read_netcdf.h</code></p>"},{"location":"BGFlood/Read__netcdf_8h_source/","title":"File Read_netcdf.h","text":""},{"location":"BGFlood/Read__netcdf_8h_source/#file-read_netcdfh","title":"File Read_netcdf.h","text":"<p>File List &gt; src &gt; Read_netcdf.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef READNETCDF_H\n#define READNETCDF_H\n\n#include \"General.h\"\n#include \"Input.h\"\n#include \"ReadInput.h\"\n#include \"Write_txtlog.h\"\n#include \"Write_netcdf.h\"\n#include \"Util_CPU.h\"\n#include \"GridManip.h\"\n#include \"Forcing.h\"\n#include \"utctime.h\"\n\n\n\ninline int nc_get_var_T(int ncid, int varid, float * &amp;zb);\ninline int nc_get_var_T(int ncid, int varid, double * &amp;zb);\n\ninline int nc_get_vara_T(int ncid, int varid, const size_t* startp, const size_t* countp, float * &amp;zb);\ninline int nc_get_vara_T(int ncid, int varid, const size_t* startp, const size_t* countp, double * &amp;zb);\n\ninline int nc_get_var1_T(int ncid, int varid, const size_t* startp, float * zsa);\ninline int nc_get_var1_T(int ncid, int varid, const size_t* startp, double * zsa);\n\n//template &lt;class T&gt; int readnczb(int nx, int ny, const std::string ncfile, T * &amp;zb);\n//int readnczb(int nx, int ny, const std::string ncfile, float*&amp; zb);\n//int readnczb(int nx, int ny, const std::string ncfile, double*&amp; zb);\nstd::string checkncvarname(int ncid, std::string stringA, std::string stringB, std::string stringC, std::string stringD, std::string stringE);\n\n\nvoid readgridncsize(const std::string ncfilestr, const std::string varstr, std::string reftime, int&amp; nx, int&amp; ny, int&amp; nt, double&amp; dx, double&amp; dy, double&amp; dt, double&amp; xo, double&amp; yo, double&amp; to, double&amp; xmax, double&amp; ymax, double&amp; tmax, bool&amp; flipx, bool&amp; flipy);\nvoid readgridncsize(forcingmap&amp; Fmap, Param XParam);\n\ntemplate&lt;class T&gt; void readgridncsize(T&amp; Imap);\n\n\nint readvarinfo(std::string filename, std::string Varname, size_t *&amp;ddimU);\nint readnctime(std::string filename, double * &amp;time);\nint readnctime2(int ncid,char* timecoordname, std::string refdate, size_t nt, double*&amp; time);\ntemplate &lt;class T&gt; int readncslev1(std::string filename, std::string varstr, size_t indx, size_t indy, size_t indt, bool checkhh, double eps, T * &amp;zsa);\ntemplate &lt;class T&gt; int readvardata(std::string filename, std::string Varname, int step, T*&amp; vardata, bool flipx, bool flipy);\n//template &lt;class T&gt; int readhotstartfile(Param XParam, int * leftblk, int *rightblk, int * topblk, int* botblk, double * blockxo, double * blockyo, T * &amp;zs, T * &amp;zb, T * &amp;hh, T *&amp;uu, T * &amp;vv);\n\nvoid readWNDstep(forcingmap WNDUmap, forcingmap WNDVmap, int steptoread, float *&amp;Uo, float *&amp;Vo);\nvoid readATMstep(forcingmap ATMPmap, int steptoread, float *&amp;Po);\n\nextern \"C\" void read3Dnc(int nx, int ny, int ntheta, char ncfile[], float*&amp; ee);\nextern \"C\" void read2Dnc(int nx, int ny, char ncfile[], float*&amp; hh);\nextern \"C\" void readnczb(int nx, int ny, std::string ncfile, float*&amp; zb);\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Reimann_8cu/","title":"File Reimann.cu","text":""},{"location":"BGFlood/Reimann_8cu/#file-reimanncu","title":"File Reimann.cu","text":"<p>FileList &gt; src &gt; Reimann.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Reimann.h\"</code></li> </ul>"},{"location":"BGFlood/Reimann_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ void UpdateButtingerXCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) \"Adaptive\" second-order hydrostatic reconstruction. CPU version for the X-axis template __host__ void UpdateButtingerXCPU (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb)  template __host__ void UpdateButtingerXCPU (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb)  __global__ void UpdateButtingerXGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) \"Adaptive\" second-order hydrostatic reconstruction. GPU version for t X-axis template __global__ void UpdateButtingerXGPU (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb)  template __global__ void UpdateButtingerXGPU (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb)  __host__ void UpdateButtingerYCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) \"Adaptive\" second-order hydrostatic reconstruction. CPU version for the Y-axis template __host__ void UpdateButtingerYCPU (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb)  template __host__ void UpdateButtingerYCPU (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb)  __global__ void UpdateButtingerYGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) \"Adaptive\" second-order hydrostatic reconstruction. GPU version for the Y-axis template __global__ void UpdateButtingerYGPU (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb)  template __global__ void UpdateButtingerYGPU (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb)  __host__ __device__ T hllc (T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T &amp; fh, T &amp; fq) Calculate the Harten-Lax-van Leer-contact (HLLC) flux."},{"location":"BGFlood/Reimann_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Reimann_8cu/#function-updatebuttingerxcpu","title":"function UpdateButtingerXCPU","text":"<p>\"Adaptive\" second-order hydrostatic reconstruction. CPU version for the X-axis </p><pre><code>template&lt;class T&gt;\n__host__ void UpdateButtingerXCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8cu/#description","title":"Description","text":"<p>This function computes the flux term at the cell interface using the hydrostatic reconstruction from Buttinger et al (2019). This reconstruction is safe for steep slope with thin water depth and is well-balanced meaning that it conserve the \"lake-at-rest\" states.</p> <p>For optimising the code on CPU and GPU there are 4 versions of this function: X or Y and CPU or GPU</p>"},{"location":"BGFlood/Reimann_8cu/#where-does-this-come-from","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk / B-Flood source code. I (CypB) changed the zr and zl term back to the Audusse type reconstruction http://basilisk.fr/sandbox/b-flood/saint-venant-topo.h</p> <p>Reference: Kirstetter, G., Delestre, O., Lagree, P.-Y., Popinet, S., and Josserand, C.: B-flood 1.0: an open-source Saint-Venant model for flash flood simulation using adaptive refinement, Geosci. Model Dev. Discuss. [preprint], https://doi.org/10.5194/gmd-2021-15, in review, 2021.* Buttinger-Kreuzhuber, A., Horvath, Z., Noelle, S., Bloschl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89-108, 2019. </p>"},{"location":"BGFlood/Reimann_8cu/#function-updatebuttingerxcpu_1","title":"function UpdateButtingerXCPU","text":"<pre><code>template __host__ void UpdateButtingerXCPU (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8cu/#function-updatebuttingerxcpu_2","title":"function UpdateButtingerXCPU","text":"<pre><code>template __host__ void UpdateButtingerXCPU (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8cu/#function-updatebuttingerxgpu","title":"function UpdateButtingerXGPU","text":"<p>\"Adaptive\" second-order hydrostatic reconstruction. GPU version for t X-axis </p><pre><code>template&lt;class T&gt;\n__global__ void UpdateButtingerXGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8cu/#description_1","title":"Description","text":"<p>This function computes the flux term at the cell interface using the hydrostatic reconstruction from Buttinger et al (2019). This reconstruction is safe for steep slope with thin water depth and is well-balanced meaning that it conserve the \"lake-at-rest\" states.</p> <p>For optimising the code on CPU and GPU there are 4 versions of this function: X or Y and CPU or GPU</p>"},{"location":"BGFlood/Reimann_8cu/#where-does-this-come-from_1","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk / B-Flood source code. I (CypB) changed the zr and zl term back to the Audusse type reconstruction http://basilisk.fr/sandbox/b-flood/saint-venant-topo.h</p> <p>Reference: Kirstetter, G., Delestre, O., Lagree, P.-Y., Popinet, S., and Josserand, C.: B-flood 1.0: an open-source Saint-Venant model for flash flood simulation using adaptive refinement, Geosci. Model Dev. Discuss. [preprint], https://doi.org/10.5194/gmd-2021-15, in review, 2021.* Buttinger-Kreuzhuber, A., Horvath, Z., Noelle, S., Bloschl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89-108, 2019. </p>"},{"location":"BGFlood/Reimann_8cu/#function-updatebuttingerxgpu_1","title":"function UpdateButtingerXGPU","text":"<pre><code>template __global__ void UpdateButtingerXGPU (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8cu/#function-updatebuttingerxgpu_2","title":"function UpdateButtingerXGPU","text":"<pre><code>template __global__ void UpdateButtingerXGPU (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8cu/#function-updatebuttingerycpu","title":"function UpdateButtingerYCPU","text":"<p>\"Adaptive\" second-order hydrostatic reconstruction. CPU version for the Y-axis </p><pre><code>template&lt;class T&gt;\n__host__ void UpdateButtingerYCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8cu/#description_2","title":"Description","text":"<p>This function computes the flux term at the cell interface using the hydrostatic reconstruction from Buttinger et al (2019). This reconstruction is safe for steep slope with thin water depth and is well-balanced meaning that it conserve the \"lake-at-rest\" states.</p> <p>For optimising the code on CPU and GPU there are 4 versions of this function: X or Y and CPU or GPU</p>"},{"location":"BGFlood/Reimann_8cu/#where-does-this-come-from_2","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk / B-Flood source code. I (CypB) changed the zr and zl term back to the Audusse type reconstruction http://basilisk.fr/sandbox/b-flood/saint-venant-topo.h</p> <p>Reference: Kirstetter, G., Delestre, O., Lagree, P.-Y., Popinet, S., and Josserand, C.: B-flood 1.0: an open-source Saint-Venant model for flash flood simulation using adaptive refinement, Geosci. Model Dev. Discuss. [preprint], https://doi.org/10.5194/gmd-2021-15, in review, 2021.* Buttinger-Kreuzhuber, A., Horvath, Z., Noelle, S., Bloschl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89-108, 2019. </p>"},{"location":"BGFlood/Reimann_8cu/#function-updatebuttingerycpu_1","title":"function UpdateButtingerYCPU","text":"<pre><code>template __host__ void UpdateButtingerYCPU (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8cu/#function-updatebuttingerycpu_2","title":"function UpdateButtingerYCPU","text":"<pre><code>template __host__ void UpdateButtingerYCPU (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8cu/#function-updatebuttingerygpu","title":"function UpdateButtingerYGPU","text":"<p>\"Adaptive\" second-order hydrostatic reconstruction. GPU version for the Y-axis </p><pre><code>template&lt;class T&gt;\n__global__ void UpdateButtingerYGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8cu/#description_3","title":"Description","text":"<p>This function computes the flux term at the cell interface using the hydrostatic reconstruction from Buttinger et al (2019). This reconstruction is safe for steep slope with thin water depth and is well-balanced meaning that it conserve the \"lake-at-rest\" states.</p> <p>For optimising the code on CPU and GPU there are 4 versions of this function: X or Y and CPU or GPU</p>"},{"location":"BGFlood/Reimann_8cu/#where-does-this-come-from_3","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk / B-Flood source code. I (CypB) changed the zr and zl term back to the Audusse type reconstruction http://basilisk.fr/sandbox/b-flood/saint-venant-topo.h</p> <p>Reference: Kirstetter, G., Delestre, O., Lagree, P.-Y., Popinet, S., and Josserand, C.: B-flood 1.0: an open-source Saint-Venant model for flash flood simulation using adaptive refinement, Geosci. Model Dev. Discuss. [preprint], https://doi.org/10.5194/gmd-2021-15, in review, 2021.* Buttinger-Kreuzhuber, A., Horvath, Z., Noelle, S., Bloschl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89-108, 2019. </p>"},{"location":"BGFlood/Reimann_8cu/#function-updatebuttingerygpu_1","title":"function UpdateButtingerYGPU","text":"<pre><code>template __global__ void UpdateButtingerYGPU (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8cu/#function-updatebuttingerygpu_2","title":"function UpdateButtingerYGPU","text":"<pre><code>template __global__ void UpdateButtingerYGPU (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8cu/#function-hllc","title":"function hllc","text":"<p>Calculate the Harten-Lax-van Leer-contact (HLLC) flux. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T hllc (\n    T g,\n    T delta,\n    T epsi,\n    T CFL,\n    T cm,\n    T fm,\n    T hm,\n    T hp,\n    T um,\n    T up,\n    T &amp; fh,\n    T &amp; fq\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8cu/#description_4","title":"Description","text":"<p>This an implementation of the HLLC solver.</p>"},{"location":"BGFlood/Reimann_8cu/#where-does-this-come-from_4","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk source code. http://basilisk.fr/src/riemann.h</p> <p>Reference: (Basilisk reference the scheme from Kurganov reference below) Kurganov, A., &amp; Levy, D. (2002). Central-upwind schemes for the Saint-Venant system. Mathematical Modelling and Numerical Analysis, 36(3), 397-425. </p> <p>The documentation for this class was generated from the following file <code>src/Reimann.cu</code></p>"},{"location":"BGFlood/Reimann_8cu_source/","title":"File Reimann.cu","text":""},{"location":"BGFlood/Reimann_8cu_source/#file-reimanncu","title":"File Reimann.cu","text":"<p>File List &gt; src &gt; Reimann.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Reimann.h\"\n\n\ntemplate &lt;class T&gt; __global__ void UpdateButtingerXGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int RB, LBRB, LB, RBLB, levRB, levLB;\n    RB = XBlock.RightBot[ib];\n    levRB = XBlock.level[RB];\n    LBRB = XBlock.LeftBot[RB];\n\n    LB = XBlock.LeftBot[ib];\n    levLB = XBlock.level[LB];\n    RBLB = XBlock.RightBot[LB];\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n    T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n\n    //T dhdxi = XGrad.dhdx[i];\n    //T dhdxmin = XGrad.dhdx[ileft];\n    T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T fmu = T(1.0);\n\n    T hi = XEv.h[i];\n\n    T hn = XEv.h[ileft];\n\n\n    if (hi &gt; eps || hn &gt; eps)\n    {\n        T dx, zi, zn, hr, hl, etar, etal, zr, zl, zA, zCN, hCNr, hCNl;\n        T ui, vi, uli, vli, dhdxi, dhdxil, dudxi, dudxil, dvdxi,dvdxil;\n\n        T ga = g * T(0.5);\n        // along X\n        dx = delta * T(0.5);\n        zi = zb[i];\n        zn = zb[ileft];\n\n        ui = XEv.u[i];\n        vi = XEv.v[i];\n        uli = XEv.u[ileft];\n        vli = XEv.v[ileft];\n\n        dhdxi = XGrad.dhdx[i];\n        dhdxil = XGrad.dhdx[ileft];\n        dudxi = XGrad.dudx[i];\n        dudxil = XGrad.dudx[ileft];\n        dvdxi = XGrad.dvdx[i];\n        dvdxil = XGrad.dvdx[ileft];\n\n\n        hr = hi - dx * dhdxi;\n        hl = hn + dx * dhdxil;\n        etar = XEv.zs[i] - dx * XGrad.dzsdx[i];\n        etal = XEv.zs[ileft] + dx * XGrad.dzsdx[ileft];\n\n        //define the topography term at the interfaces\n        zr = etar - hr;// zi - dx * XGrad.dzbdx[i];\n        zl = etal - hl;// zn + dx * XGrad.dzbdx[ileft];\n\n        //define the Audusse terms\n        zA = max(zr, zl);\n\n        // Now the CN terms\n        zCN = min(zA, min(etal, etar));\n        hCNr = max(T(0.0), min(etar - zCN, hr));\n        hCNl = max(T(0.0), min(etal - zCN, hl));\n\n        //Velocity reconstruction\n        //To avoid high velocities near dry cells, we reconstruct velocities according to Bouchut.\n        T ul, ur, vl, vr,sl,sr;\n        if (hi &gt; eps) {\n            ur = ui - (1. + dx * dhdxi / hi) * dx * dudxi;\n            vr = vi - (1. + dx * dhdxi / hi) * dx * dvdxi;\n        }\n        else {\n            ur = ui - dx * dudxi;\n            vr = vi - dx * dvdxi;\n        }\n        if (hn &gt; eps) {\n            ul = uli + (T(1.0) - dx * dhdxil / hn) * dx * dudxil;\n            vl = vli + (T(1.0) - dx * dhdxil / hn) * dx * dvdxil;\n        }\n        else {\n            ul = uli + dx * dudxil;\n            vl = vli + dx * dvdxil;\n        }\n\n\n\n\n        T fh, fu, fv, dt;\n\n\n        //solver below also modifies fh and fu\n        dt = hllc(g, delta, epsi, CFL, cm, fmu, hCNl, hCNr, ul, ur, fh, fu);\n        //hllc(T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T &amp; fh, T &amp; fq)\n\n        if (dt &lt; dtmax[i])\n        {\n            dtmax[i] = dt;\n        }\n\n\n        fv = (fh &gt; 0. ? vl : vr) * fh;\n\n\n        // Topographic source term\n\n        // In the case of adaptive refinement, care must be taken to ensure\n        // well-balancing at coarse/fine faces (see [notes/balanced.tm]()). \n        if ((ix == blockDim.y) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = LBRB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n            int iright = memloc(halowidth, blkmemwidth, 0, jj, RB);;\n            hi = XEv.h[iright];\n            zi = zb[iright];\n        }\n        if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = RBLB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n            int ilc = memloc(halowidth, blkmemwidth, blockDim.y - 1, jj, LB);\n            hn = XEv.h[ilc];\n            zn = zb[ilc];\n        }\n\n        sl = ga * (hi + hCNr) * (zi - zCN);\n        sr = ga * (hCNl + hn) * (zn - zCN);\n\n\n        XFlux.Fhu[i] = fmu * fh;\n        XFlux.Fqux[i] = fmu * (fu - sl);\n        XFlux.Su[i] = fmu * (fu - sr);\n        XFlux.Fqvx[i] = fmu * fv;\n    }\n    else\n    {\n        dtmax[i] = T(1.0) / epsi;\n        XFlux.Fhu[i] = T(0.0);\n        XFlux.Fqux[i] = T(0.0);\n        XFlux.Su[i] = T(0.0);\n        XFlux.Fqvx[i] = T(0.0);\n    }\n\n}\ntemplate __global__ void UpdateButtingerXGPU(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb);\ntemplate __global__ void UpdateButtingerXGPU(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double* zb);\n\n\ntemplate &lt;class T&gt; __host__ void UpdateButtingerXCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb)\n{\n\n\n    T delta;\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    int RB, LBRB, LB, RBLB, levRB, levLB;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        int lev = XBlock.level[ib];\n        delta = calcres(T(XParam.delta), lev);\n\n        // neighbours for source term\n\n        RB = XBlock.RightBot[ib];\n        levRB = XBlock.level[RB];\n        LBRB = XBlock.LeftBot[RB];\n\n        LB = XBlock.LeftBot[ib];\n        levLB = XBlock.level[LB];\n        RBLB = XBlock.RightBot[LB];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth + XParam.halowidth); ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n                T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n\n                //T dhdxi = XGrad.dhdx[i];\n                //T dhdxmin = XGrad.dhdx[ileft];\n                T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n                T fmu = T(1.0);\n\n                T hi = XEv.h[i];\n\n                T hn = XEv.h[ileft];\n\n\n                if (hi &gt; eps || hn &gt; eps)\n                {\n                    T dx, zi, zn, hr, hl, etar, etal, zr, zl, zA, zCN, hCNr, hCNl;\n                    T ui, vi, uli, vli, dhdxi, dhdxil, dudxi, dudxil, dvdxi, dvdxil;\n\n                    T ga = g * T(0.5);\n                    // along X\n                    dx = delta * T(0.5);\n                    zi = zb[i];\n                    zn = zb[ileft];\n\n                    ui = XEv.u[i];\n                    vi = XEv.v[i];\n                    uli = XEv.u[ileft];\n                    vli = XEv.v[ileft];\n\n                    dhdxi = XGrad.dhdx[i];\n                    dhdxil = XGrad.dhdx[ileft];\n                    dudxi = XGrad.dudx[i];\n                    dudxil = XGrad.dudx[ileft];\n                    dvdxi = XGrad.dvdx[i];\n                    dvdxil = XGrad.dvdx[ileft];\n\n\n                    hr = hi - dx * dhdxi;\n                    hl = hn + dx * dhdxil;\n                    etar = XEv.zs[i] - dx * XGrad.dzsdx[i];\n                    etal = XEv.zs[ileft] + dx * XGrad.dzsdx[ileft];\n\n                    //define the topography term at the interfaces\n                    zr = etar - hr;// zi - dx * XGrad.dzbdx[i];\n                    zl = etal - hl;// zn + dx * XGrad.dzbdx[ileft];\n\n                    //define the Audusse terms\n                    zA = max(zr, zl);\n\n                    // Now the CN terms\n                    zCN = min(zA, min(etal, etar));\n                    hCNr = max(T(0.0), min(etar - zCN, hr));\n                    hCNl = max(T(0.0), min(etal - zCN, hl));\n\n                    //Velocity reconstruction\n                    //To avoid high velocities near dry cells, we reconstruct velocities according to Bouchut.\n                    T ul, ur, vl, vr, sl, sr;\n                    if (hi &gt; eps) {\n                        ur = ui - (T(1.0) + dx * dhdxi / hi) * dx * dudxi;\n                        vr = vi - (T(1.0) + dx * dhdxi / hi) * dx * dvdxi;\n                    }\n                    else {\n                        ur = ui - dx * dudxi;\n                        vr = vi - dx * dvdxi;\n                    }\n                    if (hn &gt; eps) {\n                        ul = uli + (T(1.0) - dx * dhdxil / hn) * dx * dudxil;\n                        vl = vli + (T(1.0) - dx * dhdxil / hn) * dx * dvdxil;\n                    }\n                    else {\n                        ul = uli + dx * dudxil;\n                        vl = vli + dx * dvdxil;\n                    }\n\n\n\n\n                    T fh, fu, fv, dt;\n\n\n                    //solver below also modifies fh and fu\n                    dt = hllc(g, delta, epsi, CFL, cm, fmu, hCNl, hCNr, ul, ur, fh, fu);\n                    //hllc(T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T &amp; fh, T &amp; fq)\n\n                    if (dt &lt; dtmax[i])\n                    {\n                        dtmax[i] = dt;\n                    }\n\n\n                    fv = (fh &gt; 0. ? vl : vr) * fh;\n\n\n                    // Topographic source term\n\n                    // In the case of adaptive refinement, care must be taken to ensure\n                    // well-balancing at coarse/fine faces (see [notes/balanced.tm]()). \n                    if ((ix == XParam.blkwidth) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n                    {\n                        int jj = LBRB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n                        int iright = memloc(halowidth, blkmemwidth, 0, jj, RB);;\n                        hi = XEv.h[iright];\n                        zi = zb[iright];\n                    }\n                    if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo if you \n                    {\n                        int jj = RBLB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n                        int ilc = memloc(halowidth, blkmemwidth, XParam.blkwidth- 1, jj, LB);\n\n                        hn = XEv.h[ilc];\n                        zn = zb[ilc];\n                    }\n\n                    sl = ga * (hi + hCNr) * (zi - zCN);\n                    sr = ga * (hCNl + hn) * (zn - zCN);\n\n\n                    XFlux.Fhu[i] = fmu * fh;\n                    XFlux.Fqux[i] = fmu * (fu - sl);\n                    XFlux.Su[i] = fmu * (fu - sr);\n                    XFlux.Fqvx[i] = fmu * fv;\n                }\n                else\n                {\n                    dtmax[i] = T(1.0) / epsi;\n                    XFlux.Fhu[i] = T(0.0);\n                    XFlux.Fqux[i] = T(0.0);\n                    XFlux.Su[i] = T(0.0);\n                    XFlux.Fqvx[i] = T(0.0);\n                }\n            }\n        }\n    }\n}\ntemplate __host__ void UpdateButtingerXCPU(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb);\ntemplate __host__ void UpdateButtingerXCPU(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double* zb);\n\n\ntemplate &lt;class T&gt; __global__ void UpdateButtingerYGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int TL, BLTL, BL, TLBL, levTL, levBL;\n    TL = XBlock.TopLeft[ib];\n    levTL = XBlock.level[TL];\n    BLTL = XBlock.BotLeft[TL];\n\n    BL = XBlock.BotLeft[ib];\n    levBL = XBlock.level[BL];\n    TLBL = XBlock.TopLeft[BL];\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n\n\n    T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n    //T dhdyi = XGrad.dhdy[i];\n    //T dhdymin = XGrad.dhdy[ibot];\n    T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, T(iy)) : T(1.0);\n\n    T hi = XEv.h[i];\n\n    T hn = XEv.h[ibot];\n\n\n    if (hi &gt; eps || hn &gt; eps)\n    {\n        T dx, zi, zn, hr, hl, etar, etal, zr, zl, zA, zCN, hCNr, hCNl;\n        T ui, vi, uli, vli, dhdyi, dhdyil, dudyi, dudyil, dvdyi, dvdyil;\n\n        T ga = g * T(0.5);\n        // along X\n        dx = delta * T(0.5);\n        zi = zb[i];\n        zn = zb[ibot];\n\n        ui = XEv.u[i];\n        vi = XEv.v[i];\n        uli = XEv.u[ibot];\n        vli = XEv.v[ibot];\n\n        dhdyi = XGrad.dhdy[i];\n        dhdyil = XGrad.dhdy[ibot];\n        dudyi = XGrad.dudy[i];\n        dudyil = XGrad.dudy[ibot];\n        dvdyi = XGrad.dvdy[i];\n        dvdyil = XGrad.dvdy[ibot];\n\n\n        hr = hi - dx * dhdyi;\n        hl = hn + dx * dhdyil;\n        etar = XEv.zs[i] - dx * XGrad.dzsdy[i];\n        etal = XEv.zs[ibot] + dx * XGrad.dzsdy[ibot];\n\n        //define the topography term at the interfaces\n        zr = etar - hr;// zi - dx * XGrad.dzbdy[i];\n        zl = etal - hl;// zn + dx * XGrad.dzbdy[ibot];\n\n        //define the Audusse terms\n        zA = max(zr, zl);\n\n        // Now the CN terms\n        zCN = min(zA, min(etal, etar));\n        hCNr = max(T(0.0), min(etar - zCN, hr));\n        hCNl = max(T(0.0), min(etal - zCN, hl));\n\n        //Velocity reconstruction\n        //To avoid high velocities near dry cells, we reconstruct velocities according to Bouchut.\n        T ul, ur, vl, vr, sl, sr;\n        if (hi &gt; eps) {\n            ur = ui - (1. + dx * dhdyi / hi) * dx * dudyi;\n            vr = vi - (1. + dx * dhdyi / hi) * dx * dvdyi;\n        }\n        else {\n            ur = ui - dx * dudyi;\n            vr = vi - dx * dvdyi;\n        }\n        if (hn &gt; eps) {\n            ul = uli + (1. - dx * dhdyil / hn) * dx * dudyil;\n            vl = vli + (1. - dx * dhdyil / hn) * dx * dvdyil;\n        }\n        else {\n            ul = uli + dx * dudyil;\n            vl = vli + dx * dvdyil;\n        }\n\n\n\n\n        T fh, fu, fv, dt;\n\n\n        //solver below also modifies fh and fu\n        dt = hllc(g, delta, epsi, CFL, cm, fmv, hCNl, hCNr, vl, vr, fh, fu);\n        //hllc(T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T &amp; fh, T &amp; fq)\n\n        if (dt &lt; dtmax[i])\n        {\n            dtmax[i] = dt;\n        }\n\n\n        fv = (fh &gt; 0. ? ul : ur) * fh;\n\n\n        // Topographic source term\n\n        // In the case of adaptive refinement, care must be taken to ensure\n        // well-balancing at coarse/fine faces (see [notes/balanced.tm]()). \n        if ((iy == blockDim.x) &amp;&amp; levTL &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = BLTL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n            int itop = memloc(halowidth, blkmemwidth, jj, 0, TL);;\n            hi = XEv.h[itop];\n            zi = zb[itop];\n        }\n        if ((iy == 0) &amp;&amp; levBL &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = TLBL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n            int ibc = memloc(halowidth, blkmemwidth, jj, blockDim.x - 1, BL);\n            hn = XEv.h[ibc];\n            zn = zb[ibc];\n        }\n\n        sl = ga * (hi + hCNr) * (zi - zCN);\n        sr = ga * (hCNl + hn) * (zn - zCN);\n\n\n        XFlux.Fhv[i] = fmv * fh;\n        XFlux.Fqvy[i] = fmv * (fu - sl);\n        XFlux.Sv[i] = fmv * (fu - sr);\n        XFlux.Fquy[i] = fmv * fv;\n    }\n    else\n    {\n        dtmax[i] = T(1.0) / epsi;\n        XFlux.Fhv[i] = T(0.0);\n        XFlux.Fqvy[i] = T(0.0);\n        XFlux.Sv[i] = T(0.0);\n        XFlux.Fquy[i] = T(0.0);\n    }\n\n}\ntemplate __global__ void UpdateButtingerYGPU(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb);\ntemplate __global__ void UpdateButtingerYGPU(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double* zb);\n\ntemplate &lt;class T&gt; __host__ void UpdateButtingerYCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb)\n{\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n    T delta;\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    int TL, BLTL, BL, TLBL, levTL, levBL, lev;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n\n\n\n        TL = XBlock.TopLeft[ib];\n        levTL = XBlock.level[TL];\n        BLTL = XBlock.BotLeft[TL];\n\n        BL = XBlock.BotLeft[ib];\n        levBL = XBlock.level[BL];\n        TLBL = XBlock.TopLeft[BL];\n\n        lev = XBlock.level[ib];\n\n        delta = calcres(T(XParam.delta), lev);\n\n        for (int iy = 0; iy &lt; (XParam.blkwidth + XParam.halowidth); iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n\n                T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n\n                //T dhdyi = XGrad.dhdy[i];\n                //T dhdymin = XGrad.dhdy[ibot];\n                T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n                T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, T(iy)) : T(1.0);\n\n                T hi = XEv.h[i];\n\n                T hn = XEv.h[ibot];\n\n\n                if (hi &gt; eps || hn &gt; eps)\n                {\n                    T dx, zi, zn, hr, hl, etar, etal, zr, zl, zA, zCN, hCNr, hCNl;\n                    T ui, vi, uli, vli, dhdyi, dhdyil, dudyi, dudyil, dvdyi, dvdyil;\n\n                    T ga = g * T(0.5);\n                    // along X\n                    dx = delta * T(0.5);\n                    zi = zb[i];\n                    zn = zb[ibot];\n\n                    ui = XEv.u[i];\n                    vi = XEv.v[i];\n                    uli = XEv.u[ibot];\n                    vli = XEv.v[ibot];\n\n                    dhdyi = XGrad.dhdy[i];\n                    dhdyil = XGrad.dhdy[ibot];\n                    dudyi = XGrad.dudy[i];\n                    dudyil = XGrad.dudy[ibot];\n                    dvdyi = XGrad.dvdy[i];\n                    dvdyil = XGrad.dvdy[ibot];\n\n\n                    hr = hi - dx * dhdyi;\n                    hl = hn + dx * dhdyil;\n                    etar = XEv.zs[i] - dx * XGrad.dzsdy[i];\n                    etal = XEv.zs[ibot] + dx * XGrad.dzsdy[ibot];\n\n                    //define the topography term at the interfaces\n                    zr = etar - hr;// zi - dx * XGrad.dzbdy[i];\n                    zl = etal - hl;// zn + dx * XGrad.dzbdy[ibot];\n\n                    //define the Audusse terms\n                    zA = max(zr, zl);\n\n                    // Now the CN terms\n                    zCN = min(zA, min(etal, etar));\n                    hCNr = max(T(0.0), min(etar - zCN, hr));\n                    hCNl = max(T(0.0), min(etal - zCN, hl));\n\n                    //Velocity reconstruction\n                    //To avoid high velocities near dry cells, we reconstruct velocities according to Bouchut.\n                    T ul, ur, vl, vr, sl, sr;\n                    if (hi &gt; eps) {\n                        ur = ui - (T(1.0) + dx * dhdyi / hi) * dx * dudyi;\n                        vr = vi - (T(1.0) + dx * dhdyi / hi) * dx * dvdyi;\n                    }\n                    else {\n                        ur = ui - dx * dudyi;\n                        vr = vi - dx * dvdyi;\n                    }\n                    if (hn &gt; eps) {\n                        ul = uli + (T(1.0) - dx * dhdyil / hn) * dx * dudyil;\n                        vl = vli + (T(1.0) - dx * dhdyil / hn) * dx * dvdyil;\n                    }\n                    else {\n                        ul = uli + dx * dudyil;\n                        vl = vli + dx * dvdyil;\n                    }\n\n\n\n\n                    T fh, fu, fv, dt;\n\n\n                    //solver below also modifies fh and fu\n                    dt = hllc(g, delta, epsi, CFL, cm, fmv, hCNl, hCNr, vl, vr, fh, fu);\n                    //hllc(T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T &amp; fh, T &amp; fq)\n\n                    if (dt &lt; dtmax[i])\n                    {\n                        dtmax[i] = dt;\n                    }\n\n\n                    fv = (fh &gt; T(0.0) ? ul : ur) * fh;\n\n\n                    // Topographic source term\n\n                    // In the case of adaptive refinement, care must be taken to ensure\n                    // well-balancing at coarse/fine faces (see [notes/balanced.tm]()). \n                    if ((iy == XParam.blkwidth) &amp;&amp; levTL &lt; lev)//(ix==16) i.e. in the top halo\n                    {\n                        int jj = BLTL == ib ? ftoi(floor(ix * (T)0.5)) : ftoi(floor(ix * (T)0.5) + XParam.blkwidth / 2);\n                        int itop = memloc(halowidth, blkmemwidth, jj, 0, TL);\n                        hi = XEv.h[itop];\n                        zi = zb[itop];\n                    }\n                    if ((iy == 0) &amp;&amp; levBL &lt; lev)//(ix==16) i.e. in the bot halo\n                    {\n                        int jj = TLBL == ib ? ftoi(floor(ix * (T)0.5)) : ftoi(floor(ix * (T)0.5) + XParam.blkwidth / 2);\n                        int ibc = memloc(halowidth, blkmemwidth, jj, XParam.blkwidth - 1, BL);\n                        // Warning I think the above is wrong and should be as below to be consistent with halo flux scheme:\n                        //int ibc = memloc(halowidth, blkmemwidth, jj, XParam.blkwidth, BL);\n                        hn = XEv.h[ibc];\n                        zn = zb[ibc];\n                    }\n\n                    sl = ga * (hi + hCNr) * (zi - zCN);\n                    sr = ga * (hCNl + hn) * (zn - zCN);\n\n\n                    XFlux.Fhv[i] = fmv * fh;\n                    XFlux.Fqvy[i] = fmv * (fu - sl);\n                    XFlux.Sv[i] = fmv * (fu - sr);\n                    XFlux.Fquy[i] = fmv * fv;\n                }\n                else\n                {\n                    dtmax[i] = T(1.0) / epsi;\n                    XFlux.Fhv[i] = T(0.0);\n                    XFlux.Fqvy[i] = T(0.0);\n                    XFlux.Sv[i] = T(0.0);\n                    XFlux.Fquy[i] = T(0.0);\n                }\n            }\n        }\n    }\n}\ntemplate __host__ void UpdateButtingerYCPU(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb);\ntemplate __host__ void UpdateButtingerYCPU(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double* zb);\n\n\n\n\ntemplate &lt;class T&gt; __host__ __device__ T hllc(T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T &amp;fh, T &amp;fq)\n{\n    T cp, cmo , dt, ustar, cstar, SL, SR, fhm, fum,fhp, fup,dlt;\n    cmo = sqrt(g * hm);\n    cp = sqrt(g * hp);\n    ustar = (um + up) / T(2.) + cmo - cp;\n    cstar = (cmo + cp) / T(2.) + (um - up) / T(4.);\n    SL = hm == T(0.) ? up - T(2.) * cp : min(um - cmo, ustar - cstar);\n    SR = hp == T(0.) ? um + T(2.) * cmo : max(up + cp, ustar + cstar);\n\n    if (T(0.) &lt;= SL) {\n        fh = um * hm;\n        fq = hm * (um * um + g * hm / T(2.));\n    }\n    else if (T(0.) &gt;= SR) {\n        fh = up * hp;\n        fq = hp * (up * up + g * hp / T(2.));\n    }\n    else {\n        fhm = um * hm;\n        fum = hm * (um * um + g * hm / T(2.));\n        fhp = up * hp;\n        fup = hp * (up * up + g * hp / T(2.));\n        fh = (SR * fhm - SL * fhp + SL * SR * (hp - hm)) / (SR - SL);\n        fq = (SR * fum - SL * fup + SL * SR * (hp * up - hm * um)) / (SR - SL);\n    }\n\n    double a = max(fabs(SL), fabs(SR));\n    if (a &gt; epsi) {\n        dlt = delta * cm / fm;\n        dt = CFL * dlt / T(a);\n\n    }\n    else\n    {\n        dt = T(1.0) / epsi;\n    }\n    return dt;\n}\n</code></pre>"},{"location":"BGFlood/Reimann_8h/","title":"File Reimann.h","text":""},{"location":"BGFlood/Reimann_8h/#file-reimannh","title":"File Reimann.h","text":"<p>FileList &gt; src &gt; Reimann.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> </ul>"},{"location":"BGFlood/Reimann_8h/#public-functions","title":"Public Functions","text":"Type Name __host__ void UpdateButtingerXCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) \"Adaptive\" second-order hydrostatic reconstruction. CPU version for the X-axis __global__ void UpdateButtingerXGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) \"Adaptive\" second-order hydrostatic reconstruction. GPU version for t X-axis __host__ void UpdateButtingerYCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) \"Adaptive\" second-order hydrostatic reconstruction. CPU version for the Y-axis __global__ void UpdateButtingerYGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) \"Adaptive\" second-order hydrostatic reconstruction. GPU version for the Y-axis __host__ __device__ T hllc (T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T &amp; fh, T &amp; fq) Calculate the Harten-Lax-van Leer-contact (HLLC) flux."},{"location":"BGFlood/Reimann_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Reimann_8h/#function-updatebuttingerxcpu","title":"function UpdateButtingerXCPU","text":"<p>\"Adaptive\" second-order hydrostatic reconstruction. CPU version for the X-axis </p><pre><code>template&lt;class T&gt;\n__host__ void UpdateButtingerXCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8h/#description","title":"Description","text":"<p>This function computes the flux term at the cell interface using the hydrostatic reconstruction from Buttinger et al (2019). This reconstruction is safe for steep slope with thin water depth and is well-balanced meaning that it conserve the \"lake-at-rest\" states.</p> <p>For optimising the code on CPU and GPU there are 4 versions of this function: X or Y and CPU or GPU</p>"},{"location":"BGFlood/Reimann_8h/#where-does-this-come-from","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk / B-Flood source code. I (CypB) changed the zr and zl term back to the Audusse type reconstruction http://basilisk.fr/sandbox/b-flood/saint-venant-topo.h</p> <p>Reference: Kirstetter, G., Delestre, O., Lagree, P.-Y., Popinet, S., and Josserand, C.: B-flood 1.0: an open-source Saint-Venant model for flash flood simulation using adaptive refinement, Geosci. Model Dev. Discuss. [preprint], https://doi.org/10.5194/gmd-2021-15, in review, 2021.* Buttinger-Kreuzhuber, A., Horvath, Z., Noelle, S., Bloschl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89-108, 2019. </p>"},{"location":"BGFlood/Reimann_8h/#function-updatebuttingerxgpu","title":"function UpdateButtingerXGPU","text":"<p>\"Adaptive\" second-order hydrostatic reconstruction. GPU version for t X-axis </p><pre><code>template&lt;class T&gt;\n__global__ void UpdateButtingerXGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8h/#description_1","title":"Description","text":"<p>This function computes the flux term at the cell interface using the hydrostatic reconstruction from Buttinger et al (2019). This reconstruction is safe for steep slope with thin water depth and is well-balanced meaning that it conserve the \"lake-at-rest\" states.</p> <p>For optimising the code on CPU and GPU there are 4 versions of this function: X or Y and CPU or GPU</p>"},{"location":"BGFlood/Reimann_8h/#where-does-this-come-from_1","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk / B-Flood source code. I (CypB) changed the zr and zl term back to the Audusse type reconstruction http://basilisk.fr/sandbox/b-flood/saint-venant-topo.h</p> <p>Reference: Kirstetter, G., Delestre, O., Lagree, P.-Y., Popinet, S., and Josserand, C.: B-flood 1.0: an open-source Saint-Venant model for flash flood simulation using adaptive refinement, Geosci. Model Dev. Discuss. [preprint], https://doi.org/10.5194/gmd-2021-15, in review, 2021.* Buttinger-Kreuzhuber, A., Horvath, Z., Noelle, S., Bloschl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89-108, 2019. </p>"},{"location":"BGFlood/Reimann_8h/#function-updatebuttingerycpu","title":"function UpdateButtingerYCPU","text":"<p>\"Adaptive\" second-order hydrostatic reconstruction. CPU version for the Y-axis </p><pre><code>template&lt;class T&gt;\n__host__ void UpdateButtingerYCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8h/#description_2","title":"Description","text":"<p>This function computes the flux term at the cell interface using the hydrostatic reconstruction from Buttinger et al (2019). This reconstruction is safe for steep slope with thin water depth and is well-balanced meaning that it conserve the \"lake-at-rest\" states.</p> <p>For optimising the code on CPU and GPU there are 4 versions of this function: X or Y and CPU or GPU</p>"},{"location":"BGFlood/Reimann_8h/#where-does-this-come-from_2","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk / B-Flood source code. I (CypB) changed the zr and zl term back to the Audusse type reconstruction http://basilisk.fr/sandbox/b-flood/saint-venant-topo.h</p> <p>Reference: Kirstetter, G., Delestre, O., Lagree, P.-Y., Popinet, S., and Josserand, C.: B-flood 1.0: an open-source Saint-Venant model for flash flood simulation using adaptive refinement, Geosci. Model Dev. Discuss. [preprint], https://doi.org/10.5194/gmd-2021-15, in review, 2021.* Buttinger-Kreuzhuber, A., Horvath, Z., Noelle, S., Bloschl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89-108, 2019. </p>"},{"location":"BGFlood/Reimann_8h/#function-updatebuttingerygpu","title":"function UpdateButtingerYGPU","text":"<p>\"Adaptive\" second-order hydrostatic reconstruction. GPU version for the Y-axis </p><pre><code>template&lt;class T&gt;\n__global__ void UpdateButtingerYGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8h/#description_3","title":"Description","text":"<p>This function computes the flux term at the cell interface using the hydrostatic reconstruction from Buttinger et al (2019). This reconstruction is safe for steep slope with thin water depth and is well-balanced meaning that it conserve the \"lake-at-rest\" states.</p> <p>For optimising the code on CPU and GPU there are 4 versions of this function: X or Y and CPU or GPU</p>"},{"location":"BGFlood/Reimann_8h/#where-does-this-come-from_3","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk / B-Flood source code. I (CypB) changed the zr and zl term back to the Audusse type reconstruction http://basilisk.fr/sandbox/b-flood/saint-venant-topo.h</p> <p>Reference: Kirstetter, G., Delestre, O., Lagree, P.-Y., Popinet, S., and Josserand, C.: B-flood 1.0: an open-source Saint-Venant model for flash flood simulation using adaptive refinement, Geosci. Model Dev. Discuss. [preprint], https://doi.org/10.5194/gmd-2021-15, in review, 2021.* Buttinger-Kreuzhuber, A., Horvath, Z., Noelle, S., Bloschl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89-108, 2019. </p>"},{"location":"BGFlood/Reimann_8h/#function-hllc","title":"function hllc","text":"<p>Calculate the Harten-Lax-van Leer-contact (HLLC) flux. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T hllc (\n    T g,\n    T delta,\n    T epsi,\n    T CFL,\n    T cm,\n    T fm,\n    T hm,\n    T hp,\n    T um,\n    T up,\n    T &amp; fh,\n    T &amp; fq\n) \n</code></pre>"},{"location":"BGFlood/Reimann_8h/#description_4","title":"Description","text":"<p>This an implementation of the HLLC solver.</p>"},{"location":"BGFlood/Reimann_8h/#where-does-this-come-from_4","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk source code. http://basilisk.fr/src/riemann.h</p> <p>Reference: (Basilisk reference the scheme from Kurganov reference below) Kurganov, A., &amp; Levy, D. (2002). Central-upwind schemes for the Saint-Venant system. Mathematical Modelling and Numerical Analysis, 36(3), 397-425. </p> <p>The documentation for this class was generated from the following file <code>src/Reimann.h</code></p>"},{"location":"BGFlood/Reimann_8h_source/","title":"File Reimann.h","text":""},{"location":"BGFlood/Reimann_8h_source/#file-reimannh","title":"File Reimann.h","text":"<p>File List &gt; src &gt; Reimann.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef REIMANN_H\n#define REIMANN_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"Util_CPU.h\"\n\ntemplate &lt;class T&gt; __global__ void UpdateButtingerXGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __host__ void UpdateButtingerXCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __global__ void UpdateButtingerYGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __host__ void UpdateButtingerYCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __host__ __device__ T hllc(T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T&amp; fh, T&amp; fq);\n#endif\n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/","title":"File Setup_GPU.cu","text":""},{"location":"BGFlood/Setup__GPU_8cu/#file-setup_gpucu","title":"File Setup_GPU.cu","text":"<p>FileList &gt; src &gt; Setup_GPU.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Setup_GPU.h\"</code></li> </ul>"},{"location":"BGFlood/Setup__GPU_8cu/#public-functions","title":"Public Functions","text":"Type Name void AllocateBndTEX (bndparam &amp; side)  void AllocateTEX (int nx, int ny, TexSetP &amp; Tex, float * input)  void CUDA_CHECK (cudaError CUDerr)  void CopyGPUtoCPU (int nblk, int blksize, T * z_cpu, T * z_gpu)  template void CopyGPUtoCPU&lt; bool &gt; (int nblk, int blksize, bool * z_cpu, bool * z_gpu)  template void CopyGPUtoCPU&lt; double &gt; (int nblk, int blksize, double * z_cpu, double * z_gpu)  template void CopyGPUtoCPU&lt; float &gt; (int nblk, int blksize, float * z_cpu, float * z_gpu)  template void CopyGPUtoCPU&lt; int &gt; (int nblk, int blksize, int * z_cpu, int * z_gpu)  void CopytoGPU (int nblk, int blksize, T * z_cpu, T * z_gpu)  void CopytoGPU (int nblk, int blksize, EvolvingP&lt; T &gt; XEv_cpu, EvolvingP&lt; T &gt; XEv_gpu)  void CopytoGPU (int nblk, int blksize, EvolvingP_M&lt; T &gt; XEv_cpu, EvolvingP_M&lt; T &gt; XEv_gpu)  void CopytoGPU (int nblk, int blksize, GradientsP&lt; T &gt; XGrad_cpu, GradientsP&lt; T &gt; XGrad_gpu)  template void CopytoGPU (int nblk, int blksize, GradientsP&lt; float &gt; XGrad_cpu, GradientsP&lt; float &gt; XGrad_gpu)  template void CopytoGPU (int nblk, int blksize, GradientsP&lt; double &gt; XGrad_cpu, GradientsP&lt; double &gt; XGrad_gpu)  void CopytoGPU (int nblk, int blksize, Param XParam, Model&lt; T &gt; XModel_cpu, Model&lt; T &gt; XModel_gpu)  template void CopytoGPU&lt; bool &gt; (int nblk, int blksize, bool * z_cpu, bool * z_gpu)  template void CopytoGPU&lt; double &gt; (int nblk, int blksize, double * z_cpu, double * z_gpu)  template void CopytoGPU&lt; double &gt; (int nblk, int blksize, EvolvingP&lt; double &gt; XEv_cpu, EvolvingP&lt; double &gt; XEv_gpu)  template void CopytoGPU&lt; double &gt; (int nblk, int blksize, EvolvingP_M&lt; double &gt; XEv_cpu, EvolvingP_M&lt; double &gt; XEv_gpu)  template void CopytoGPU&lt; double &gt; (int nblk, int blksize, Param XParam, Model&lt; double &gt; XModel_cpu, Model&lt; double &gt; XModel_gpu)  template void CopytoGPU&lt; float &gt; (int nblk, int blksize, float * z_cpu, float * z_gpu)  template void CopytoGPU&lt; float &gt; (int nblk, int blksize, EvolvingP&lt; float &gt; XEv_cpu, EvolvingP&lt; float &gt; XEv_gpu)  template void CopytoGPU&lt; float &gt; (int nblk, int blksize, EvolvingP_M&lt; float &gt; XEv_cpu, EvolvingP_M&lt; float &gt; XEv_gpu)  template void CopytoGPU&lt; float &gt; (int nblk, int blksize, Param XParam, Model&lt; float &gt; XModel_cpu, Model&lt; float &gt; XModel_gpu)  template void CopytoGPU&lt; int &gt; (int nblk, int blksize, int * z_cpu, int * z_gpu)  void SetupGPU (Param &amp; XParam, Model&lt; T &gt; XModel, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel_g)  template void SetupGPU&lt; double &gt; (Param &amp; XParam, Model&lt; double &gt; XModel, Forcing&lt; float &gt; &amp; XForcing, Model&lt; double &gt; &amp; XModel_g)  template void SetupGPU&lt; float &gt; (Param &amp; XParam, Model&lt; float &gt; XModel, Forcing&lt; float &gt; &amp; XForcing, Model&lt; float &gt; &amp; XModel_g)"},{"location":"BGFlood/Setup__GPU_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Setup__GPU_8cu/#function-allocatebndtex","title":"function AllocateBndTEX","text":"<pre><code>void AllocateBndTEX (\n    bndparam &amp; side\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-allocatetex","title":"function AllocateTEX","text":"<pre><code>void AllocateTEX (\n    int nx,\n    int ny,\n    TexSetP &amp; Tex,\n    float * input\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-cuda_check","title":"function CUDA_CHECK","text":"<pre><code>void CUDA_CHECK (\n    cudaError CUDerr\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copygputocpu","title":"function CopyGPUtoCPU","text":"<pre><code>template&lt;class T&gt;\nvoid CopyGPUtoCPU (\n    int nblk,\n    int blksize,\n    T * z_cpu,\n    T * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copygputocpu-bool","title":"function CopyGPUtoCPU&lt; bool &gt;","text":"<pre><code>template void CopyGPUtoCPU&lt; bool &gt; (\n    int nblk,\n    int blksize,\n    bool * z_cpu,\n    bool * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copygputocpu-double","title":"function CopyGPUtoCPU&lt; double &gt;","text":"<pre><code>template void CopyGPUtoCPU&lt; double &gt; (\n    int nblk,\n    int blksize,\n    double * z_cpu,\n    double * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copygputocpu-float","title":"function CopyGPUtoCPU&lt; float &gt;","text":"<pre><code>template void CopyGPUtoCPU&lt; float &gt; (\n    int nblk,\n    int blksize,\n    float * z_cpu,\n    float * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copygputocpu-int","title":"function CopyGPUtoCPU&lt; int &gt;","text":"<pre><code>template void CopyGPUtoCPU&lt; int &gt; (\n    int nblk,\n    int blksize,\n    int * z_cpu,\n    int * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copytogpu","title":"function CopytoGPU","text":"<pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    T * z_cpu,\n    T * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copytogpu_1","title":"function CopytoGPU","text":"<pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; T &gt; XEv_cpu,\n    EvolvingP &lt; T &gt; XEv_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copytogpu_2","title":"function CopytoGPU","text":"<pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; T &gt; XEv_cpu,\n    EvolvingP_M &lt; T &gt; XEv_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copytogpu_3","title":"function CopytoGPU","text":"<pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    GradientsP &lt; T &gt; XGrad_cpu,\n    GradientsP &lt; T &gt; XGrad_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copytogpu_4","title":"function CopytoGPU","text":"<pre><code>template void CopytoGPU (\n    int nblk,\n    int blksize,\n    GradientsP &lt; float &gt; XGrad_cpu,\n    GradientsP &lt; float &gt; XGrad_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copytogpu_5","title":"function CopytoGPU","text":"<pre><code>template void CopytoGPU (\n    int nblk,\n    int blksize,\n    GradientsP &lt; double &gt; XGrad_cpu,\n    GradientsP &lt; double &gt; XGrad_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copytogpu_6","title":"function CopytoGPU","text":"<pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; T &gt; XModel_cpu,\n    Model &lt; T &gt; XModel_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copytogpu-bool","title":"function CopytoGPU&lt; bool &gt;","text":"<pre><code>template void CopytoGPU&lt; bool &gt; (\n    int nblk,\n    int blksize,\n    bool * z_cpu,\n    bool * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copytogpu-double","title":"function CopytoGPU&lt; double &gt;","text":"<pre><code>template void CopytoGPU&lt; double &gt; (\n    int nblk,\n    int blksize,\n    double * z_cpu,\n    double * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copytogpu-double_1","title":"function CopytoGPU&lt; double &gt;","text":"<pre><code>template void CopytoGPU&lt; double &gt; (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; double &gt; XEv_cpu,\n    EvolvingP &lt; double &gt; XEv_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copytogpu-double_2","title":"function CopytoGPU&lt; double &gt;","text":"<pre><code>template void CopytoGPU&lt; double &gt; (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; double &gt; XEv_cpu,\n    EvolvingP_M &lt; double &gt; XEv_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copytogpu-double_3","title":"function CopytoGPU&lt; double &gt;","text":"<pre><code>template void CopytoGPU&lt; double &gt; (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; double &gt; XModel_cpu,\n    Model &lt; double &gt; XModel_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copytogpu-float","title":"function CopytoGPU&lt; float &gt;","text":"<pre><code>template void CopytoGPU&lt; float &gt; (\n    int nblk,\n    int blksize,\n    float * z_cpu,\n    float * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copytogpu-float_1","title":"function CopytoGPU&lt; float &gt;","text":"<pre><code>template void CopytoGPU&lt; float &gt; (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; float &gt; XEv_cpu,\n    EvolvingP &lt; float &gt; XEv_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copytogpu-float_2","title":"function CopytoGPU&lt; float &gt;","text":"<pre><code>template void CopytoGPU&lt; float &gt; (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; float &gt; XEv_cpu,\n    EvolvingP_M &lt; float &gt; XEv_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copytogpu-float_3","title":"function CopytoGPU&lt; float &gt;","text":"<pre><code>template void CopytoGPU&lt; float &gt; (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; float &gt; XModel_cpu,\n    Model &lt; float &gt; XModel_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-copytogpu-int","title":"function CopytoGPU&lt; int &gt;","text":"<pre><code>template void CopytoGPU&lt; int &gt; (\n    int nblk,\n    int blksize,\n    int * z_cpu,\n    int * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-setupgpu","title":"function SetupGPU","text":"<pre><code>template&lt;class T&gt;\nvoid SetupGPU (\n    Param &amp; XParam,\n    Model &lt; T &gt; XModel,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-setupgpu-double","title":"function SetupGPU&lt; double &gt;","text":"<pre><code>template void SetupGPU&lt; double &gt; (\n    Param &amp; XParam,\n    Model &lt; double &gt; XModel,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; double &gt; &amp; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8cu/#function-setupgpu-float","title":"function SetupGPU&lt; float &gt;","text":"<pre><code>template void SetupGPU&lt; float &gt; (\n    Param &amp; XParam,\n    Model &lt; float &gt; XModel,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; float &gt; &amp; XModel_g\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Setup_GPU.cu</code></p>"},{"location":"BGFlood/Setup__GPU_8cu_source/","title":"File Setup_GPU.cu","text":""},{"location":"BGFlood/Setup__GPU_8cu_source/#file-setup_gpucu","title":"File Setup_GPU.cu","text":"<p>File List &gt; src &gt; Setup_GPU.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Setup_GPU.h\"\n\n\n\ntemplate &lt;class T&gt; void SetupGPU(Param &amp;XParam, Model&lt;T&gt; XModel,Forcing&lt;float&gt; &amp;XForcing, Model&lt;T&gt;&amp; XModel_g)\n{\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        log(\"Setting up GPU\");\n\n        size_t free_byte;\n\n        size_t total_byte;\n\n        cudaSetDevice(XParam.GPUDEVICE);\n\n        CUDA_CHECK(cudaMemGetInfo(&amp;free_byte, &amp;total_byte));\n\n        XParam.GPU_initmem_byte = total_byte - free_byte;\n\n\n        //Allocate memory for the model on the GPU\n        AllocateGPU(XParam.nblkmem, XParam.blksize, XParam, XModel_g);\n\n        // Copy arrays from CPU to GPU\n        CopytoGPU(XParam.nblkmem, XParam.blksize,XParam, XModel, XModel_g);\n\n        //\n        fillHaloGPU(XParam, XModel_g.blocks, XModel_g.evolv);\n\n        //=============================\n        // Same for Bnds\n\n\n        // Allocate memory for the boundary blk\n        AllocateGPU(XForcing.left.nblk, 1, XForcing.left.blks_g);\n        //copy bnd blk info on GPU\n        CopytoGPU(XForcing.left.nblk, 1, XForcing.left.blks, XForcing.left.blks_g);\n\n        AllocateGPU(XForcing.right.nblk, 1, XForcing.right.blks_g);\n        CopytoGPU(XForcing.right.nblk, 1, XForcing.right.blks, XForcing.right.blks_g);\n\n        AllocateGPU(XForcing.top.nblk, 1, XForcing.top.blks_g);\n        CopytoGPU(XForcing.top.nblk, 1, XForcing.top.blks, XForcing.top.blks_g);\n\n        AllocateGPU(XForcing.bot.nblk, 1, XForcing.bot.blks_g);\n        CopytoGPU(XForcing.bot.nblk, 1, XForcing.bot.blks, XForcing.bot.blks_g);\n\n\n        for (int s = 0; s &lt; XForcing.bndseg.size(); s++)\n        {\n            AllocateGPU(XForcing.bndseg[s].left.nblk, 1, XForcing.bndseg[s].left.blk_g);\n            CopytoGPU(XForcing.bndseg[s].left.nblk, 1, XForcing.bndseg[s].left.blk, XForcing.bndseg[s].left.blk_g);\n\n            AllocateGPU(XForcing.bndseg[s].right.nblk, 1, XForcing.bndseg[s].right.blk_g);\n            CopytoGPU(XForcing.bndseg[s].right.nblk, 1, XForcing.bndseg[s].right.blk, XForcing.bndseg[s].right.blk_g);\n\n            AllocateGPU(XForcing.bndseg[s].top.nblk, 1, XForcing.bndseg[s].top.blk_g);\n            CopytoGPU(XForcing.bndseg[s].top.nblk, 1, XForcing.bndseg[s].top.blk, XForcing.bndseg[s].top.blk_g);\n\n            AllocateGPU(XForcing.bndseg[s].bot.nblk, 1, XForcing.bndseg[s].bot.blk_g);\n            CopytoGPU(XForcing.bndseg[s].bot.nblk, 1, XForcing.bndseg[s].bot.blk, XForcing.bndseg[s].bot.blk_g);\n\n            AllocateGPU(XForcing.bndseg[s].left.nblk, XParam.blkwidth, XForcing.bndseg[s].left.qmean_g);\n            CopytoGPU(XForcing.bndseg[s].left.nblk, XParam.blkwidth, XForcing.bndseg[s].left.qmean, XForcing.bndseg[s].left.qmean_g);\n\n            AllocateGPU(XForcing.bndseg[s].right.nblk, XParam.blkwidth, XForcing.bndseg[s].right.qmean_g);\n            CopytoGPU(XForcing.bndseg[s].right.nblk, XParam.blkwidth, XForcing.bndseg[s].right.qmean, XForcing.bndseg[s].right.qmean_g);\n\n            AllocateGPU(XForcing.bndseg[s].top.nblk, XParam.blkwidth, XForcing.bndseg[s].top.qmean_g);\n            CopytoGPU(XForcing.bndseg[s].top.nblk, XParam.blkwidth, XForcing.bndseg[s].top.qmean, XForcing.bndseg[s].top.qmean_g);\n\n            AllocateGPU(XForcing.bndseg[s].bot.nblk, XParam.blkwidth, XForcing.bndseg[s].bot.qmean_g);\n            CopytoGPU(XForcing.bndseg[s].bot.nblk, XParam.blkwidth, XForcing.bndseg[s].bot.qmean, XForcing.bndseg[s].bot.qmean_g);\n        }\n\n\n        // Also for mask\n        XModel_g.blocks.mask.nblk = XModel.blocks.mask.nblk;\n        AllocateGPU(XModel_g.blocks.mask.nblk, 1, XModel_g.blocks.mask.side);\n        AllocateGPU(XModel_g.blocks.mask.nblk, 1, XModel_g.blocks.mask.blks);\n        CopytoGPU(XModel_g.blocks.mask.nblk, 1, XModel.blocks.mask.side, XModel_g.blocks.mask.side);\n        CopytoGPU(XModel_g.blocks.mask.nblk, 1, XModel.blocks.mask.blks, XModel_g.blocks.mask.blks);\n\n\n        // things are quite different for Time Series output. Why is that?.\n        if (XParam.TSnodesout.size() &gt; 0)\n        {\n\n            AllocateGPU(XModel.bndblk.nblkTs, 1, XModel_g.bndblk.Tsout);\n            CopytoGPU(XModel.bndblk.nblkTs, 1, XModel.bndblk.Tsout, XModel_g.bndblk.Tsout);\n\n        }\n\n        // River are a bit of a special case too\n        if (XForcing.rivers.size() &gt; 0)\n        {\n            //\n            XModel_g.bndblk.nblkriver = XModel.bndblk.nblkriver;\n            AllocateGPU(XModel.bndblk.nblkriver, 1, XModel_g.bndblk.river);\n            CopytoGPU(XModel.bndblk.nblkriver, 1, XModel.bndblk.river, XModel_g.bndblk.river);\n\n            int nribmax = XModel.bndblk.Riverinfo.nribmax;\n            int nburmax = XModel.bndblk.Riverinfo.nburmax;\n\n            XModel_g.bndblk.Riverinfo.nribmax = nribmax;\n            XModel_g.bndblk.Riverinfo.nburmax = nburmax;\n\n\n            AllocateMappedMemGPU(XForcing.rivers.size(), 1,XParam.GPUDEVICE, XModel_g.bndblk.Riverinfo.qnow_g,XModel.bndblk.Riverinfo.qnow);\n            XModel_g.bndblk.Riverinfo.qnow = XModel.bndblk.Riverinfo.qnow;\n\n\n            AllocateGPU(nribmax, nburmax, XModel_g.bndblk.Riverinfo.Xbidir);\n            AllocateGPU(nribmax, nburmax, XModel_g.bndblk.Riverinfo.Xridib);\n            CopytoGPU(nribmax, nburmax, XModel.bndblk.Riverinfo.Xbidir, XModel_g.bndblk.Riverinfo.Xbidir);\n            CopytoGPU(nribmax, nburmax, XModel.bndblk.Riverinfo.Xridib, XModel_g.bndblk.Riverinfo.Xridib);\n\n            AllocateGPU(nribmax, nburmax, XModel_g.bndblk.Riverinfo.xstart);\n            AllocateGPU(nribmax, nburmax, XModel_g.bndblk.Riverinfo.xend);\n            AllocateGPU(nribmax, nburmax, XModel_g.bndblk.Riverinfo.ystart);\n            AllocateGPU(nribmax, nburmax, XModel_g.bndblk.Riverinfo.yend);\n\n            CopytoGPU(nribmax, nburmax, XModel.bndblk.Riverinfo.xstart, XModel_g.bndblk.Riverinfo.xstart);\n            CopytoGPU(nribmax, nburmax, XModel.bndblk.Riverinfo.xend, XModel_g.bndblk.Riverinfo.xend);\n            CopytoGPU(nribmax, nburmax, XModel.bndblk.Riverinfo.ystart, XModel_g.bndblk.Riverinfo.ystart);\n            CopytoGPU(nribmax, nburmax, XModel.bndblk.Riverinfo.yend, XModel_g.bndblk.Riverinfo.yend);\n\n        }\n\n        // Reset GPU mean and max arrays\n        if (XParam.outmax)\n        {\n            //ResetmaxvarGPU(XParam);\n        }\n        if (XParam.outmean)\n        {\n            //ResetmeanvarGPU(XParam);\n        }\n\n        Initmaparray(XModel_g);\n\n        //InitzbgradientGPU(XParam, XModel_g);\n\n\n    }\n}\ntemplate void SetupGPU&lt;float&gt;(Param &amp;XParam, Model&lt;float&gt; XModel, Forcing&lt;float&gt;&amp; XForcing, Model&lt;float&gt;&amp; XModel_g);\ntemplate void SetupGPU&lt;double&gt;(Param &amp;XParam, Model&lt;double&gt; XModel, Forcing&lt;float&gt;&amp; XForcing, Model&lt;double&gt;&amp; XModel_g);\n\n\nvoid CUDA_CHECK(cudaError CUDerr)\n{\n\n\n    if (cudaSuccess != CUDerr) {\n\n        fprintf(stderr, \"Cuda error in file '%s' in line %i : %s.\\n\", \\\n\n            __FILE__, __LINE__, cudaGetErrorString(CUDerr));\n\n        exit(EXIT_FAILURE);\n\n    }\n}\n\n\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, T * z_cpu, T* z_gpu)\n{\n    CUDA_CHECK(cudaMemcpy(z_gpu, z_cpu, nblk * blksize * sizeof(T), cudaMemcpyHostToDevice));\n}\ntemplate void CopytoGPU&lt;bool&gt;(int nblk, int blksize, bool* z_cpu, bool* z_gpu);\ntemplate void CopytoGPU&lt;int&gt;(int nblk, int blksize, int* z_cpu, int* z_gpu);\ntemplate void CopytoGPU&lt;float&gt;(int nblk, int blksize, float* z_cpu, float* z_gpu);\ntemplate void CopytoGPU&lt;double&gt;(int nblk, int blksize, double* z_cpu, double* z_gpu);\n\ntemplate &lt;class T&gt; void CopyGPUtoCPU(int nblk, int blksize, T* z_cpu, T* z_gpu)\n{\n    CUDA_CHECK(cudaMemcpy(z_cpu, z_gpu, nblk * blksize * sizeof(T), cudaMemcpyDeviceToHost));\n}\ntemplate void CopyGPUtoCPU&lt;bool&gt;(int nblk, int blksize, bool* z_cpu, bool* z_gpu);\ntemplate void CopyGPUtoCPU&lt;int&gt;(int nblk, int blksize, int* z_cpu, int* z_gpu);\ntemplate void CopyGPUtoCPU&lt;float&gt;(int nblk, int blksize, float* z_cpu, float* z_gpu);\ntemplate void CopyGPUtoCPU&lt;double&gt;(int nblk, int blksize, double* z_cpu, double* z_gpu);\n\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, EvolvingP&lt;T&gt; XEv_cpu, EvolvingP&lt;T&gt; XEv_gpu)\n{\n    CopytoGPU(nblk, blksize, XEv_cpu.h, XEv_gpu.h);\n    CopytoGPU(nblk, blksize, XEv_cpu.zs, XEv_gpu.zs);\n    CopytoGPU(nblk, blksize, XEv_cpu.u, XEv_gpu.u);\n    CopytoGPU(nblk, blksize, XEv_cpu.v, XEv_gpu.v);\n}\ntemplate void CopytoGPU&lt;float&gt;(int nblk, int blksize, EvolvingP&lt;float&gt; XEv_cpu, EvolvingP&lt;float&gt; XEv_gpu);\ntemplate void CopytoGPU &lt; double &gt;(int nblk, int blksize, EvolvingP&lt;double&gt; XEv_cpu, EvolvingP&lt;double&gt; XEv_gpu);\n\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, EvolvingP_M&lt;T&gt; XEv_cpu, EvolvingP_M&lt;T&gt; XEv_gpu)\n{\n    CopytoGPU(nblk, blksize, XEv_cpu.h, XEv_gpu.h);\n    CopytoGPU(nblk, blksize, XEv_cpu.zs, XEv_gpu.zs);\n    CopytoGPU(nblk, blksize, XEv_cpu.u, XEv_gpu.u);\n    CopytoGPU(nblk, blksize, XEv_cpu.v, XEv_gpu.v);\n    CopytoGPU(nblk, blksize, XEv_cpu.U, XEv_gpu.U);\n    CopytoGPU(nblk, blksize, XEv_cpu.hU, XEv_gpu.hU);\n}\ntemplate void CopytoGPU&lt;float&gt;(int nblk, int blksize, EvolvingP_M&lt;float&gt; XEv_cpu, EvolvingP_M&lt;float&gt; XEv_gpu);\ntemplate void CopytoGPU &lt; double &gt;(int nblk, int blksize, EvolvingP_M&lt;double&gt; XEv_cpu, EvolvingP_M &lt; double &gt;  XEv_gpu);\n\n\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, GradientsP&lt;T&gt; XGrad_cpu, GradientsP&lt;T&gt; XGrad_gpu)\n{\n    CopytoGPU(nblk, blksize, XGrad_cpu.dhdx, XGrad_gpu.dhdx);\n    CopytoGPU(nblk, blksize, XGrad_cpu.dhdy, XGrad_gpu.dhdy);\n    CopytoGPU(nblk, blksize, XGrad_cpu.dudx, XGrad_gpu.dudx);\n    CopytoGPU(nblk, blksize, XGrad_cpu.dudy, XGrad_gpu.dudy);\n    CopytoGPU(nblk, blksize, XGrad_cpu.dvdx, XGrad_gpu.dvdx);\n    CopytoGPU(nblk, blksize, XGrad_cpu.dvdy, XGrad_gpu.dvdy);\n    CopytoGPU(nblk, blksize, XGrad_cpu.dzsdx, XGrad_gpu.dzsdx);\n    CopytoGPU(nblk, blksize, XGrad_cpu.dzsdy, XGrad_gpu.dzsdy);\n}\ntemplate void CopytoGPU(int nblk, int blksize, GradientsP&lt;float&gt; XGrad_cpu, GradientsP&lt;float&gt; XGrad_gpu);\ntemplate void CopytoGPU(int nblk, int blksize, GradientsP&lt;double&gt; XGrad_cpu, GradientsP&lt;double&gt; XGrad_gpu);\n\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, Param XParam, Model&lt;T&gt; XModel_cpu, Model&lt;T&gt; XModel_gpu)\n{\n    CopytoGPU(nblk, blksize, XModel_cpu.zb, XModel_gpu.zb);\n\n    CopytoGPU(nblk, blksize, XModel_cpu.evolv, XModel_gpu.evolv);\n    //CopytoGPU(nblk, blksize, XModel_cpu.evolv_o, XModel_gpu.evolv_o);\n\n    CopytoGPU(nblk, blksize, XModel_cpu.evolv_o, XModel_gpu.evolv_o);\n\n    CopytoGPU(nblk, blksize, XModel_cpu.cf, XModel_gpu.cf);\n\n    CopytoGPU(nblk, blksize, XModel_cpu.grad.dzbdx, XModel_gpu.grad.dzbdx);\n    CopytoGPU(nblk, blksize, XModel_cpu.grad.dzbdy, XModel_gpu.grad.dzbdy);\n\n\n    //Block info\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.active, XModel_gpu.blocks.active);\n    CopytoGPU(nblk, blksize, XModel_cpu.blocks.activeCell, XModel_gpu.blocks.activeCell);\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.level, XModel_gpu.blocks.level);\n\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.xo, XModel_gpu.blocks.xo);\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.yo, XModel_gpu.blocks.yo);\n\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.BotLeft, XModel_gpu.blocks.BotLeft);\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.BotRight, XModel_gpu.blocks.BotRight);\n\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.TopLeft, XModel_gpu.blocks.TopLeft);\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.TopRight, XModel_gpu.blocks.TopRight);\n\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.LeftBot, XModel_gpu.blocks.LeftBot);\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.LeftTop, XModel_gpu.blocks.LeftTop);\n\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.RightBot, XModel_gpu.blocks.RightBot);\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.RightTop, XModel_gpu.blocks.RightTop);\n\n\n    if (XParam.infiltration)\n    {\n        CopytoGPU(nblk, blksize, XModel_cpu.il, XModel_gpu.il);\n        CopytoGPU(nblk, blksize, XModel_cpu.cl, XModel_gpu.cl);\n        CopytoGPU(nblk, blksize, XModel_cpu.hgw, XModel_gpu.hgw);\n    }\n\n    if (XParam.outmax)\n    {\n        CopytoGPU(nblk, blksize, XModel_cpu.evmax, XModel_gpu.evmax);\n    }\n    if (XParam.outmean)\n    {\n        CopytoGPU(nblk, blksize, XModel_cpu.evmean, XModel_gpu.evmean);\n    }\n    if (XParam.outtwet)\n    {\n        CopytoGPU(nblk, blksize, XModel_cpu.wettime, XModel_gpu.wettime);\n    }\n}\ntemplate void CopytoGPU&lt;float&gt;(int nblk, int blksize, Param XParam, Model&lt;float&gt; XModel_cpu, Model&lt;float&gt; XModel_gpu);\ntemplate void CopytoGPU&lt;double&gt;(int nblk, int blksize, Param XParam, Model&lt;double&gt; XModel_cpu, Model&lt;double&gt; XModel_gpu);\n\n\nvoid AllocateTEX(int nx, int ny, TexSetP&amp; Tex, float* input)\n{\n\n\n    CUDA_CHECK(cudaMallocArray(&amp;Tex.CudArr, &amp;Tex.channelDesc, nx, ny));\n    CUDA_CHECK(cudaMemcpyToArray(Tex.CudArr, 0, 0, input, nx * ny * sizeof(float), cudaMemcpyHostToDevice));\n\n\n    memset(&amp;Tex.texDesc, 0, sizeof(cudaTextureDesc));\n    Tex.texDesc.addressMode[0] = cudaAddressModeClamp;\n    Tex.texDesc.addressMode[1] = cudaAddressModeClamp;\n    Tex.texDesc.filterMode = cudaFilterModeLinear;\n    //Tex.texDesc.filterMode = cudaFilterModePoint;\n    Tex.texDesc.normalizedCoords = false;\n\n    memset(&amp;Tex.resDesc, 0, sizeof(cudaResourceDesc));\n\n    Tex.resDesc.resType = cudaResourceTypeArray;\n    Tex.resDesc.res.array.array = Tex.CudArr;\n\n    CUDA_CHECK(cudaCreateTextureObject(&amp;Tex.tex, &amp;Tex.resDesc, &amp;Tex.texDesc, NULL));\n    //CUDA_CHECK(cudaBindTextureToArray(Tex, zca, cCFD));\n\n\n}\n\n\nvoid AllocateBndTEX(bndparam &amp; side)\n{\n    int nbndtimes = (int)side.data.size();\n    int nbndvec = (int)side.data[0].wlevs.size();\n\n    float* lWLS;\n    lWLS = (float*)malloc(nbndtimes * nbndvec * sizeof(float));\n\n    for (int ibndv = 0; ibndv &lt; nbndvec; ibndv++)\n    {\n        for (int ibndt = 0; ibndt &lt; nbndtimes; ibndt++)\n        {\n            //\n            lWLS[ibndt + ibndv * nbndtimes] = (float)side.data[ibndt].wlevs[ibndv];\n        }\n    }\n    AllocateTEX(nbndtimes, nbndvec, side.GPU.WLS, lWLS);\n\n    // In case of Nesting U and V are also prescribed\n\n    // If uu information is available in the boundary we can assume it is a nesting type of bnd\n    int nbndvecuu = (int)side.data[0].uuvel.size();\n    if (nbndvecuu == nbndvec)\n    {\n        //\n        for (int ibndv = 0; ibndv &lt; nbndvec; ibndv++)\n        {\n            for (int ibndt = 0; ibndt &lt; nbndtimes; ibndt++)\n            {\n                //\n                lWLS[ibndt + ibndv * nbndtimes] = (float)side.data[ibndt].uuvel[ibndv];\n            }\n        }\n        AllocateTEX(nbndtimes, nbndvec, side.GPU.Uvel, lWLS);\n\n    }\n    //V velocity side\n    int nbndvecvv = (int)side.data[0].vvvel.size();\n\n    if (nbndvecvv == nbndvec)\n    {\n        for (int ibndv = 0; ibndv &lt; nbndvec; ibndv++)\n        {\n            for (int ibndt = 0; ibndt &lt; nbndtimes; ibndt++)\n            {\n                //\n                lWLS[ibndt + ibndv * nbndtimes] = (float)side.data[ibndt].vvvel[ibndv];\n            }\n        }\n        AllocateTEX(nbndtimes, nbndvec, side.GPU.Vvel, lWLS);\n    }\n\n    free(lWLS);\n\n\n}\n</code></pre>"},{"location":"BGFlood/Setup__GPU_8h/","title":"File Setup_GPU.h","text":""},{"location":"BGFlood/Setup__GPU_8h/#file-setup_gpuh","title":"File Setup_GPU.h","text":"<p>FileList &gt; src &gt; Setup_GPU.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Halo.h\"</code></li> <li><code>#include \"InitialConditions.h\"</code></li> </ul>"},{"location":"BGFlood/Setup__GPU_8h/#public-functions","title":"Public Functions","text":"Type Name void AllocateBndTEX (bndparam &amp; side)  void AllocateTEX (int nx, int ny, TexSetP &amp; Tex, float * input)  void CUDA_CHECK (cudaError CUDerr)  void CopyGPUtoCPU (int nblk, int blksize, T * z_cpu, T * z_gpu)  void CopytoGPU (int nblk, int blksize, Param XParam, Model&lt; T &gt; XModel_cpu, Model&lt; T &gt; XModel_gpu)  void CopytoGPU (int nblk, int blksize, T * z_cpu, T * z_gpu)  void CopytoGPU (int nblk, int blksize, EvolvingP&lt; T &gt; XEv_cpu, EvolvingP&lt; T &gt; XEv_gpu)  void CopytoGPU (int nblk, int blksize, EvolvingP_M&lt; T &gt; XEv_cpu, EvolvingP_M&lt; T &gt; XEv_gpu)  void CopytoGPU (int nblk, int blksize, GradientsP&lt; T &gt; XGrad_cpu, GradientsP&lt; T &gt; XGrad_gpu)  void SetupGPU (Param &amp; XParam, Model&lt; T &gt; XModel, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel_g)"},{"location":"BGFlood/Setup__GPU_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Setup__GPU_8h/#function-allocatebndtex","title":"function AllocateBndTEX","text":"<pre><code>void AllocateBndTEX (\n    bndparam &amp; side\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8h/#function-allocatetex","title":"function AllocateTEX","text":"<pre><code>void AllocateTEX (\n    int nx,\n    int ny,\n    TexSetP &amp; Tex,\n    float * input\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8h/#function-cuda_check","title":"function CUDA_CHECK","text":"<pre><code>void CUDA_CHECK (\n    cudaError CUDerr\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8h/#function-copygputocpu","title":"function CopyGPUtoCPU","text":"<pre><code>template&lt;class T&gt;\nvoid CopyGPUtoCPU (\n    int nblk,\n    int blksize,\n    T * z_cpu,\n    T * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8h/#function-copytogpu","title":"function CopytoGPU","text":"<pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; T &gt; XModel_cpu,\n    Model &lt; T &gt; XModel_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8h/#function-copytogpu_1","title":"function CopytoGPU","text":"<pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    T * z_cpu,\n    T * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8h/#function-copytogpu_2","title":"function CopytoGPU","text":"<pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; T &gt; XEv_cpu,\n    EvolvingP &lt; T &gt; XEv_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8h/#function-copytogpu_3","title":"function CopytoGPU","text":"<pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; T &gt; XEv_cpu,\n    EvolvingP_M &lt; T &gt; XEv_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8h/#function-copytogpu_4","title":"function CopytoGPU","text":"<pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    GradientsP &lt; T &gt; XGrad_cpu,\n    GradientsP &lt; T &gt; XGrad_gpu\n) \n</code></pre>"},{"location":"BGFlood/Setup__GPU_8h/#function-setupgpu","title":"function SetupGPU","text":"<pre><code>template&lt;class T&gt;\nvoid SetupGPU (\n    Param &amp; XParam,\n    Model &lt; T &gt; XModel,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel_g\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Setup_GPU.h</code></p>"},{"location":"BGFlood/Setup__GPU_8h_source/","title":"File Setup_GPU.h","text":""},{"location":"BGFlood/Setup__GPU_8h_source/#file-setup_gpuh","title":"File Setup_GPU.h","text":"<p>File List &gt; src &gt; Setup_GPU.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef SETUPGPU_H\n#define SETUPGPU_H\n\n#include \"General.h\"\n#include \"Forcing.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"MemManagement.h\"\n#include \"Halo.h\"\n#include \"InitialConditions.h\"\n\nvoid CUDA_CHECK(cudaError CUDerr);\n\ntemplate &lt;class T&gt; void SetupGPU(Param &amp;XParam, Model&lt;T&gt; XModel, Forcing&lt;float&gt;&amp; XForcing, Model&lt;T&gt;&amp; XModel_g);\nvoid AllocateTEX(int nx, int ny, TexSetP&amp; Tex, float* input);\nvoid AllocateBndTEX(bndparam&amp; side);\n\ntemplate &lt;class T&gt; void CopyGPUtoCPU(int nblk, int blksize, T* z_cpu, T* z_gpu);\n\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, Param XParam, Model&lt;T&gt; XModel_cpu, Model&lt;T&gt; XModel_gpu);\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, T* z_cpu, T* z_gpu);\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, EvolvingP&lt;T&gt; XEv_cpu, EvolvingP&lt;T&gt; XEv_gpu);\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, EvolvingP_M&lt;T&gt; XEv_cpu, EvolvingP_M&lt;T&gt; XEv_gpu);\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, GradientsP&lt;T&gt; XGrad_cpu, GradientsP&lt;T&gt; XGrad_gpu);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Spherical_8cu/","title":"File Spherical.cu","text":""},{"location":"BGFlood/Spherical_8cu/#file-sphericalcu","title":"File Spherical.cu","text":"<p>FileList &gt; src &gt; Spherical.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Spherical.h\"</code></li> </ul>"},{"location":"BGFlood/Spherical_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ __device__ T calcCM (T Radius, T delta, T yo, int iy)  template __host__ __device__ double calcCM (double Radius, double delta, double yo, int iy)  template __host__ __device__ float calcCM (float Radius, float delta, float yo, int iy)  __host__ __device__ T calcFM (T Radius, T delta, T yo, T iy)  template __host__ __device__ double calcFM (double Radius, double delta, double yo, double iy)  template __host__ __device__ float calcFM (float Radius, float delta, float yo, float iy)  __host__ __device__ T haversin (T Radius, T lon1, T lat1, T lon2, T lat2)  __host__ __device__ T spharea (T Radius, T lon, T lat, T dx)  template __host__ __device__ double spharea (double Radius, double lon, double lat, double dx)  template __host__ __device__ float spharea (float Radius, float lon, float lat, float dx)"},{"location":"BGFlood/Spherical_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Spherical_8cu/#function-calccm","title":"function calcCM","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T calcCM (\n    T Radius,\n    T delta,\n    T yo,\n    int iy\n) \n</code></pre> <p>Scale factor for y face length (x face lengh scale is always 1 in spherical model assuming that lat long are entered) </p>"},{"location":"BGFlood/Spherical_8cu/#function-calccm_1","title":"function calcCM","text":"<pre><code>template __host__ __device__ double calcCM (\n    double Radius,\n    double delta,\n    double yo,\n    int iy\n) \n</code></pre>"},{"location":"BGFlood/Spherical_8cu/#function-calccm_2","title":"function calcCM","text":"<pre><code>template __host__ __device__ float calcCM (\n    float Radius,\n    float delta,\n    float yo,\n    int iy\n) \n</code></pre>"},{"location":"BGFlood/Spherical_8cu/#function-calcfm","title":"function calcFM","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T calcFM (\n    T Radius,\n    T delta,\n    T yo,\n    T iy\n) \n</code></pre>"},{"location":"BGFlood/Spherical_8cu/#function-calcfm_1","title":"function calcFM","text":"<pre><code>template __host__ __device__ double calcFM (\n    double Radius,\n    double delta,\n    double yo,\n    double iy\n) \n</code></pre>"},{"location":"BGFlood/Spherical_8cu/#function-calcfm_2","title":"function calcFM","text":"<pre><code>template __host__ __device__ float calcFM (\n    float Radius,\n    float delta,\n    float yo,\n    float iy\n) \n</code></pre>"},{"location":"BGFlood/Spherical_8cu/#function-haversin","title":"function haversin","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T haversin (\n    T Radius,\n    T lon1,\n    T lat1,\n    T lon2,\n    T lat2\n) \n</code></pre> <p>Classic haversin function The function is too slow to use directly in BG_flood engine but is more usable (i.e. naive) for model setup </p>"},{"location":"BGFlood/Spherical_8cu/#function-spharea","title":"function spharea","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T spharea (\n    T Radius,\n    T lon,\n    T lat,\n    T dx\n) \n</code></pre>"},{"location":"BGFlood/Spherical_8cu/#function-spharea_1","title":"function spharea","text":"<pre><code>template __host__ __device__ double spharea (\n    double Radius,\n    double lon,\n    double lat,\n    double dx\n) \n</code></pre>"},{"location":"BGFlood/Spherical_8cu/#function-spharea_2","title":"function spharea","text":"<pre><code>template __host__ __device__ float spharea (\n    float Radius,\n    float lon,\n    float lat,\n    float dx\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Spherical.cu</code></p>"},{"location":"BGFlood/Spherical_8cu_source/","title":"File Spherical.cu","text":""},{"location":"BGFlood/Spherical_8cu_source/#file-sphericalcu","title":"File Spherical.cu","text":"<p>File List &gt; src &gt; Spherical.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Spherical.h\"\n\n\n\ntemplate &lt;class T&gt; \n__host__ __device__ T calcCM(T Radius, T delta, T yo, int iy)\n{\n    T y = yo + (iy+0.5) * delta / Radius * T(180.0 / pi);\n    // THis should be the y of the face so fo the v face you need to remove 0.5*delta\n\n    T phi = y * T(pi / 180.0);\n\n    T dphi = delta / (T(2.0 * Radius));// dy*0.5f*pi/180.0f;\n\n    T cm = (sin(phi + dphi) - sin(phi - dphi)) / (2.0 * dphi);\n\n    return cm;\n}\ntemplate __host__ __device__ double calcCM(double Radius, double delta, double yo, int iy);\ntemplate __host__ __device__ float calcCM(float Radius, float delta, float yo, int iy);\n\n\n\ntemplate &lt;class T&gt; \n__host__ __device__  T calcFM(T Radius, T delta, T yo, T iy)\n{\n    T dy = delta / Radius * T(180.0 / pi);\n    T y = yo + iy * dy;\n    // THis should be the y of the face so fo the v face you need to remove 0.5*delta\n\n    T phi = y * T(pi / 180.0);\n\n    //T dphi = delta / (T(2.0 * Radius));// dy*0.5f*pi/180.0f;\n\n    T fmu = cos(phi);\n\n    return fmu;\n}\ntemplate __host__ __device__ double calcFM(double Radius, double delta, double yo, double iy);\ntemplate __host__ __device__ float calcFM(float Radius, float delta, float yo, float iy);\n\ntemplate &lt;class T&gt;\n__host__ __device__  T haversin(T Radius, T lon1, T lat1, T lon2, T lat2)\n{\n    T phi1, phi2, dphi, dlbda, a, c;\n    dphi = (lat2 - lat1) * T(pi / 180.0);\n    dlbda = (lon2 -lon1) * T(pi / 180.0);\n\n    phi1 = lat1 * T(pi / 180.0);\n    phi2 = lat2 * T(pi / 180.0);\n\n    T sindphid2 = sin(dphi / T(2.0));\n    T sindlbdad2 = sin(dlbda / T(2.0));\n\n    a = sindphid2 * sindphid2 + cos(phi1) * cos(phi2) * sindlbdad2 * sindlbdad2;\n\n    c = T(2.0) * atan2(sqrt(a), sqrt(T(1.0) - a));\n\n    return Radius * c;\n\n}\n\ntemplate &lt;class T&gt;\n__host__ __device__  T spharea(T Radius, T lon, T lat, T dx)\n{\n    T lon1, lon2, lat1, lat2;\n    lon1 = lon - T(0.5) * dx;\n    lon2 = lon + T(0.5) * dx;\n\n    lat1 = lat - T(0.5) * dx;\n    lat2 = lat + T(0.5) * dx;\n\n    T a, b, c;\n\n    a = haversin(Radius, lon1, lat1, lon2, lat1);\n    c = haversin(Radius, lon1, lat2, lon2, lat2);\n    b = haversin(Radius, lon1, lat1, lon1, lat2);\n\n    T Area = T(0.5) * (a * b + c * b);\n\n    return Area;\n\n}\ntemplate __host__ __device__  double spharea(double Radius, double lon, double lat, double dx);\ntemplate __host__ __device__  float spharea(float Radius, float lon, float lat, float dx);\n</code></pre>"},{"location":"BGFlood/Spherical_8h/","title":"File Spherical.h","text":""},{"location":"BGFlood/Spherical_8h/#file-sphericalh","title":"File Spherical.h","text":"<p>FileList &gt; src &gt; Spherical.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Kurganov.h\"</code></li> </ul>"},{"location":"BGFlood/Spherical_8h/#public-functions","title":"Public Functions","text":"Type Name __host__ __device__ T calcCM (T Radius, T delta, T yo, int iy)  __host__ __device__ T calcFM (T Radius, T delta, T yo, T iy)  __host__ __device__ T spharea (T Radius, T lon, T lat, T dx)"},{"location":"BGFlood/Spherical_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Spherical_8h/#function-calccm","title":"function calcCM","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T calcCM (\n    T Radius,\n    T delta,\n    T yo,\n    int iy\n) \n</code></pre> <p>Scale factor for y face length (x face lengh scale is always 1 in spherical model assuming that lat long are entered) </p>"},{"location":"BGFlood/Spherical_8h/#function-calcfm","title":"function calcFM","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T calcFM (\n    T Radius,\n    T delta,\n    T yo,\n    T iy\n) \n</code></pre>"},{"location":"BGFlood/Spherical_8h/#function-spharea","title":"function spharea","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T spharea (\n    T Radius,\n    T lon,\n    T lat,\n    T dx\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Spherical.h</code></p>"},{"location":"BGFlood/Spherical_8h_source/","title":"File Spherical.h","text":""},{"location":"BGFlood/Spherical_8h_source/#file-sphericalh","title":"File Spherical.h","text":"<p>File List &gt; src &gt; Spherical.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef SPHERICAL_H\n#define SPHERICAL_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"Util_CPU.h\"\n#include \"Kurganov.h\"\n\ntemplate &lt;class T&gt; __host__ __device__ T calcCM(T Radius, T delta, T yo, int iy);\ntemplate &lt;class T&gt; __host__ __device__  T calcFM(T Radius, T delta, T yo, T iy);\ntemplate &lt;class T&gt; __host__ __device__  T spharea(T Radius, T lon, T lat, T dx);\n\n\n#endif\n</code></pre>"},{"location":"BGFlood/Testing_8cu/","title":"File Testing.cu","text":""},{"location":"BGFlood/Testing_8cu/#file-testingcu","title":"File Testing.cu","text":"<p>FileList &gt; src &gt; Testing.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Testing.h\"</code></li> </ul>"},{"location":"BGFlood/Testing_8cu/#public-functions","title":"Public Functions","text":"Type Name bool CPUGPUtest (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  void CompareCPUvsGPU (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g, std::vector&lt; std::string &gt; varlist, bool checkhalo)  template void CompareCPUvsGPU&lt; double &gt; (Param XParam, Model&lt; double &gt; XModel, Model&lt; double &gt; XModel_g, std::vector&lt; std::string &gt; varlist, bool checkhalo)  template void CompareCPUvsGPU&lt; float &gt; (Param XParam, Model&lt; float &gt; XModel, Model&lt; float &gt; XModel_g, std::vector&lt; std::string &gt; varlist, bool checkhalo)  bool GaussianHumptest (T zsnit, int gpu, bool compare)  template bool GaussianHumptest&lt; double &gt; (double zsnit, int gpu, bool compare)  template bool GaussianHumptest&lt; float &gt; (float zsnit, int gpu, bool compare)  bool LakeAtRest (Param XParam, Model&lt; T &gt; XModel)  Forcing&lt; float &gt; MakValleyBathy (Param XParam, T slope, bool bottop, bool flip)  bool MassConserveSteepSlope (T zsnit, int gpu)  template bool MassConserveSteepSlope&lt; double &gt; (double zsnit, int gpu)  template bool MassConserveSteepSlope&lt; float &gt; (float zsnit, int gpu)  bool Rainlossestest (T zsinit, int gpu, float alpha)  bool Raintest (T zsnit, int gpu, float alpha, int engine)  bool Raintestinput (int gpu)  std::vector&lt; float &gt; Raintestmap (int gpu, int dimf, T zinit)  template std::vector&lt; float &gt; Raintestmap&lt; double &gt; (int gpu, int dimf, double Zsinit)  template std::vector&lt; float &gt; Raintestmap&lt; float &gt; (int gpu, int dimf, float Zsinit)  bool RiverOnBoundary (Param XParam, T slope, int Dir, int Bound_type)  bool RiverVolumeAdapt (Param XParam, T maxslope)  bool RiverVolumeAdapt (Param XParam, T slope, bool bottop, bool flip) Simulate a river flowing in a steep valley and heck the Volume conservation. bool Rivertest (T zsnit, int gpu)  template bool Rivertest&lt; double &gt; (double zsnit, int gpu)  template bool Rivertest&lt; float &gt; (float zsnit, int gpu)  int TestAIObnd (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g, bool bottop, bool flip, bool withaoi)  void TestFirsthalfstep (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  bool TestFlexibleOutputTimes (int gpu, T ref, int scenario)  int TestGradientSpeed (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  bool TestHaloSpeed (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  int TestInstability (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  bool TestMultiBathyRough (int gpu, T ref, int scenario)  int TestPinMem (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  template int TestPinMem&lt; double &gt; (Param XParam, Model&lt; double &gt; XModel, Model&lt; double &gt; XModel_g)  template int TestPinMem&lt; float &gt; (Param XParam, Model&lt; float &gt; XModel, Model&lt; float &gt; XModel_g)  bool Testing (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  template bool Testing&lt; double &gt; (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; XModel, Model&lt; double &gt; XModel_g)  template bool Testing&lt; float &gt; (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; XModel, Model&lt; float &gt; XModel_g)  void TestingOutput (Param XParam, Model&lt; T &gt; XModel)  template void TestingOutput&lt; double &gt; (Param XParam, Model&lt; double &gt; XModel)  template void TestingOutput&lt; float &gt; (Param XParam, Model&lt; float &gt; XModel)  void Testzbinit (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  T ThackerBathy (T x, T y, T L, T D) create a parabolic bassin bool ThackerLakeAtRest (Param XParam, T zsinit)  template bool ThackerLakeAtRest&lt; double &gt; (Param XParam, double zsinit)  template bool ThackerLakeAtRest&lt; float &gt; (Param XParam, float zsinit)  T ValleyBathy (T x, T y, T slope, T center) create V shape Valley basin bool ZoneOutputTest (int nzones, T zsinit)  template bool ZoneOutputTest&lt; double &gt; (int nzones, double zsinit)  template bool ZoneOutputTest&lt; float &gt; (int nzones, float zsinit)  void alloc_init2Darray (float ** arr, int NX, int NY)  void copyBlockinfo2var (Param XParam, BlockP&lt; T &gt; XBlock, int * blkinfo, T * z)  template void copyBlockinfo2var&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, int * blkinfo, double * z)  template void copyBlockinfo2var&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, int * blkinfo, float * z)  void copyID2var (Param XParam, BlockP&lt; T &gt; XBlock, T * z)  template void copyID2var&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z)  template void copyID2var&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z)  void diffArray (Param XParam, BlockP&lt; T &gt; XBlock, std::string varname, bool checkhalo, T * cpu, T * gpu, T * dummy, T * out)  void diffSource (Param XParam, BlockP&lt; T &gt; XBlock, T * Fqux, T * Su, T * output)  void diffdh (Param XParam, BlockP&lt; T &gt; XBlock, T * input, T * output, T * shuffle)  void fillgauss (Param XParam, BlockP&lt; T &gt; XBlock, T amp, T * z)  template void fillgauss&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double amp, double * z)  template void fillgauss&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float amp, float * z)  void fillrandom (Param XParam, BlockP&lt; T &gt; XBlock, T * z)  template void fillrandom&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z)  template void fillrandom&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z)  void init3Darray (float *** arr, int rows, int cols, int depths)  bool reductiontest (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  template bool reductiontest&lt; double &gt; (Param XParam, Model&lt; double &gt; XModel, Model&lt; double &gt; XModel_g)  template bool reductiontest&lt; float &gt; (Param XParam, Model&lt; float &gt; XModel, Model&lt; float &gt; XModel_g)  void testButtingerX (Param XParam, int ib, int ix, int iy, Model&lt; T &gt; XModel)  bool testboundaries (Param XParam, T maxslope)  void testkurganovX (Param XParam, int ib, int ix, int iy, Model&lt; T &gt; XModel)  __global__ void vectoroffsetGPU (int nx, T offset, T * z)"},{"location":"BGFlood/Testing_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Testing_8cu/#function-cpugputest","title":"function CPUGPUtest","text":"<pre><code>template&lt;class T&gt;\nbool CPUGPUtest (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-comparecpuvsgpu","title":"function CompareCPUvsGPU","text":"<pre><code>template&lt;class T&gt;\nvoid CompareCPUvsGPU (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g,\n    std::vector&lt; std::string &gt; varlist,\n    bool checkhalo\n) \n</code></pre> <p>This function compares the Valiables in a CPU model and a GPU models This function is quite useful when checking both are identical enough one needs to provide a list (vector&lt;string&gt;) of variable to check </p>"},{"location":"BGFlood/Testing_8cu/#function-comparecpuvsgpu-double","title":"function CompareCPUvsGPU&lt; double &gt;","text":"<pre><code>template void CompareCPUvsGPU&lt; double &gt; (\n    Param XParam,\n    Model &lt; double &gt; XModel,\n    Model &lt; double &gt; XModel_g,\n    std::vector&lt; std::string &gt; varlist,\n    bool checkhalo\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-comparecpuvsgpu-float","title":"function CompareCPUvsGPU&lt; float &gt;","text":"<pre><code>template void CompareCPUvsGPU&lt; float &gt; (\n    Param XParam,\n    Model &lt; float &gt; XModel,\n    Model &lt; float &gt; XModel_g,\n    std::vector&lt; std::string &gt; varlist,\n    bool checkhalo\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-gaussianhumptest","title":"function GaussianHumptest","text":"<pre><code>template&lt;class T&gt;\nbool GaussianHumptest (\n    T zsnit,\n    int gpu,\n    bool compare\n) \n</code></pre> <p>This function tests the full hydrodynamics model and compares the results with pre-conmputed (Hard wired) values The function creates it own model setup and mesh independantly to what the user might want to do The setup consist of a centrally located gaussian hump radiating away The test stops at an arbitrary time to compare with 8 values extracted from a identical run in basilisk This function also compares the result of the GPU and CPU code (until they diverge) </p>"},{"location":"BGFlood/Testing_8cu/#function-gaussianhumptest-double","title":"function GaussianHumptest&lt; double &gt;","text":"<pre><code>template bool GaussianHumptest&lt; double &gt; (\n    double zsnit,\n    int gpu,\n    bool compare\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-gaussianhumptest-float","title":"function GaussianHumptest&lt; float &gt;","text":"<pre><code>template bool GaussianHumptest&lt; float &gt; (\n    float zsnit,\n    int gpu,\n    bool compare\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-lakeatrest","title":"function LakeAtRest","text":"<pre><code>template&lt;class T&gt;\nbool LakeAtRest (\n    Param XParam,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>This function simulates the first predictive step and check whether the lake at rest is preserved otherwise it prints out to screen the cells (and neighbour) where the test fails </p>"},{"location":"BGFlood/Testing_8cu/#function-makvalleybathy","title":"function MakValleyBathy","text":"<pre><code>template&lt;class T&gt;\nForcing &lt; float &gt; MakValleyBathy (\n    Param XParam,\n    T slope,\n    bool bottop,\n    bool flip\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-massconservesteepslope","title":"function MassConserveSteepSlope","text":"<pre><code>template&lt;class T&gt;\nbool MassConserveSteepSlope (\n    T zsnit,\n    int gpu\n) \n</code></pre> <p>This function tests the mass conservation of the vertical injection (used for rivers) The function creates it own model setup and mesh independantly to what the user might want to do This starts with a initial water level (zsnit=0 is dry) and runs for 0.1s before comparing results with zsnit=0.1 that is approx 20 steps </p>"},{"location":"BGFlood/Testing_8cu/#function-massconservesteepslope-double","title":"function MassConserveSteepSlope&lt; double &gt;","text":"<pre><code>template bool MassConserveSteepSlope&lt; double &gt; (\n    double zsnit,\n    int gpu\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-massconservesteepslope-float","title":"function MassConserveSteepSlope&lt; float &gt;","text":"<pre><code>template bool MassConserveSteepSlope&lt; float &gt; (\n    float zsnit,\n    int gpu\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-rainlossestest","title":"function Rainlossestest","text":"<pre><code>template&lt;class T&gt;\nbool Rainlossestest (\n    T zsinit,\n    int gpu,\n    float alpha\n) \n</code></pre> <p>This function tests the Initial Losses and Continuous Losses implementation a plain domain, under constant rain. The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsinit=0.0 is dry) and runs for 1s comparing results every 0.1s (that is approx 20 steps) </p>"},{"location":"BGFlood/Testing_8cu/#function-raintest","title":"function Raintest","text":"<pre><code>template&lt;class T&gt;\nbool Raintest (\n    T zsnit,\n    int gpu,\n    float alpha,\n    int engine\n) \n</code></pre> <p>This function tests the mass conservation of the spacial injection (used to model rain on grid) The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsnit=0.0 is dry) and runs for 0.1s before comparing results with zsnit=0.1 that is approx 20 steps </p>"},{"location":"BGFlood/Testing_8cu/#function-raintestinput","title":"function Raintestinput","text":"<pre><code>bool Raintestinput (\n    int gpu\n) \n</code></pre> <p>This function tests the different inputs for rain forcing. This test is based on the paper Aureli2020, the 3 slopes test with regional rain. The experiment has been presented in Iwagaki1955. The first test compares a time varying rain input using a uniform time serie forcing and a time varying 2D field (with same value). The second test check the 3D rain forcing (comparing it to expected values). </p>"},{"location":"BGFlood/Testing_8cu/#function-raintestmap","title":"function Raintestmap","text":"<pre><code>template&lt;class T&gt;\nstd::vector&lt; float &gt; Raintestmap (\n    int gpu,\n    int dimf,\n    T zinit\n) \n</code></pre> <p>\\fnstdvector&lt;float&gt; Raintestmap(int gpu, int dimf, T zinit)</p> <p>This function return the flux at the bottom of the 3 part slope for different types of rain forcings using the test case based on Iwagaki1955 </p>"},{"location":"BGFlood/Testing_8cu/#function-raintestmap-double","title":"function Raintestmap&lt; double &gt;","text":"<pre><code>template std::vector&lt; float &gt; Raintestmap&lt; double &gt; (\n    int gpu,\n    int dimf,\n    double Zsinit\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-raintestmap-float","title":"function Raintestmap&lt; float &gt;","text":"<pre><code>template std::vector&lt; float &gt; Raintestmap&lt; float &gt; (\n    int gpu,\n    int dimf,\n    float Zsinit\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-riveronboundary","title":"function RiverOnBoundary","text":"<pre><code>template&lt;class T&gt;\nbool RiverOnBoundary (\n    Param XParam,\n    T slope,\n    int Dir,\n    int Bound_type\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-rivervolumeadapt","title":"function RiverVolumeAdapt","text":"<pre><code>template&lt;class T&gt;\nbool RiverVolumeAdapt (\n    Param XParam,\n    T maxslope\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-rivervolumeadapt_1","title":"function RiverVolumeAdapt","text":"<p>Simulate a river flowing in a steep valley and heck the Volume conservation. </p><pre><code>template&lt;class T&gt;\nbool RiverVolumeAdapt (\n    Param XParam,\n    T slope,\n    bool bottop,\n    bool flip\n) \n</code></pre> <p>This function creates a dry steep valley topography to a given level and run the model for a while and checks that the Volume matches the theory.</p> <p>The function can test the water volume for 4 scenario each time: * left to right: bottop=false &amp; flip=true; * right to left: bottop=false &amp; flip=false; * bottom to top: bottop=true &amp; flip=true; * top to bottom: bottop=true &amp; flip=false;</p> <p>The function inherits the adaptation set in XParam so needs to be rerun to accnout for the different scenarios: * uniform level * flow from coasrse to fine * flow from fine to coarse This is done in the higher level wrapping function </p>"},{"location":"BGFlood/Testing_8cu/#function-rivertest","title":"function Rivertest","text":"<pre><code>template&lt;class T&gt;\nbool Rivertest (\n    T zsnit,\n    int gpu\n) \n</code></pre> <p>This function tests the mass conservation of the vertical injection (used for rivers) The function creates it own model setup and mesh independantly to what the user might want to do This starts with a initial water level (zsnit=0 is dry) and runs for 0.1s before comparing results with zsnit=0.1 that is approx 20 steps </p>"},{"location":"BGFlood/Testing_8cu/#function-rivertest-double","title":"function Rivertest&lt; double &gt;","text":"<pre><code>template bool Rivertest&lt; double &gt; (\n    double zsnit,\n    int gpu\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-rivertest-float","title":"function Rivertest&lt; float &gt;","text":"<pre><code>template bool Rivertest&lt; float &gt; (\n    float zsnit,\n    int gpu\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-testaiobnd","title":"function TestAIObnd","text":"<pre><code>template&lt;class T&gt;\nint TestAIObnd (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g,\n    bool bottop,\n    bool flip,\n    bool withaoi\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-testfirsthalfstep","title":"function TestFirsthalfstep","text":"<pre><code>template&lt;class T&gt;\nvoid TestFirsthalfstep (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-testflexibleoutputtimes","title":"function TestFlexibleOutputTimes","text":"<pre><code>template&lt;class T&gt;\nbool TestFlexibleOutputTimes (\n    int gpu,\n    T ref,\n    int scenario\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-testgradientspeed","title":"function TestGradientSpeed","text":"<pre><code>template&lt;class T&gt;\nint TestGradientSpeed (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>This function fill an array with random values (0 - 1)</p> <p>This function test the spped and accuracy of a new gradient function gradient are only calculated for zb but assigned to different gradient variable for storage </p>"},{"location":"BGFlood/Testing_8cu/#function-testhalospeed","title":"function TestHaloSpeed","text":"<pre><code>template&lt;class T&gt;\nbool TestHaloSpeed (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-testinstability","title":"function TestInstability","text":"<pre><code>template&lt;class T&gt;\nint TestInstability (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-testmultibathyrough","title":"function TestMultiBathyRough","text":"<pre><code>template&lt;class T&gt;\nbool TestMultiBathyRough (\n    int gpu,\n    T ref,\n    int scenario\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-testpinmem","title":"function TestPinMem","text":"<pre><code>template&lt;class T&gt;\nint TestPinMem (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-testpinmem-double","title":"function TestPinMem&lt; double &gt;","text":"<pre><code>template int TestPinMem&lt; double &gt; (\n    Param XParam,\n    Model &lt; double &gt; XModel,\n    Model &lt; double &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-testpinmem-float","title":"function TestPinMem&lt; float &gt;","text":"<pre><code>template int TestPinMem&lt; float &gt; (\n    Param XParam,\n    Model &lt; float &gt; XModel,\n    Model &lt; float &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-testing","title":"function Testing","text":"<pre><code>template&lt;class T&gt;\nbool Testing (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-testing-double","title":"function Testing&lt; double &gt;","text":"<pre><code>template bool Testing&lt; double &gt; (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; XModel,\n    Model &lt; double &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-testing-float","title":"function Testing&lt; float &gt;","text":"<pre><code>template bool Testing&lt; float &gt; (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; XModel,\n    Model &lt; float &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-testingoutput","title":"function TestingOutput","text":"<pre><code>template&lt;class T&gt;\nvoid TestingOutput (\n    Param XParam,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>OUTDATED? </p>"},{"location":"BGFlood/Testing_8cu/#function-testingoutput-double","title":"function TestingOutput&lt; double &gt;","text":"<pre><code>template void TestingOutput&lt; double &gt; (\n    Param XParam,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-testingoutput-float","title":"function TestingOutput&lt; float &gt;","text":"<pre><code>template void TestingOutput&lt; float &gt; (\n    Param XParam,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-testzbinit","title":"function Testzbinit","text":"<pre><code>template&lt;class T&gt;\nvoid Testzbinit (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-thackerbathy","title":"function ThackerBathy","text":"<p>create a parabolic bassin </p><pre><code>template&lt;class T&gt;\nT ThackerBathy (\n    T x,\n    T y,\n    T L,\n    T D\n) \n</code></pre> <p>This function creates a parabolic bassin. The function returns a single value of the bassin</p> <p>Borrowed from Buttinger et al. 2019.</p>"},{"location":"BGFlood/Testing_8cu/#reference","title":"Reference","text":"<p>Buttinger-Kreuzhuber, A., Horv\u00e1th, Z., Noelle, S., Bl\u00f6schl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89\u2013108, 2019. </p>"},{"location":"BGFlood/Testing_8cu/#function-thackerlakeatrest","title":"function ThackerLakeAtRest","text":"<pre><code>template&lt;class T&gt;\nbool ThackerLakeAtRest (\n    Param XParam,\n    T zsinit\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-thackerlakeatrest-double","title":"function ThackerLakeAtRest&lt; double &gt;","text":"<pre><code>template bool ThackerLakeAtRest&lt; double &gt; (\n    Param XParam,\n    double zsinit\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-thackerlakeatrest-float","title":"function ThackerLakeAtRest&lt; float &gt;","text":"<pre><code>template bool ThackerLakeAtRest&lt; float &gt; (\n    Param XParam,\n    float zsinit\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-valleybathy","title":"function ValleyBathy","text":"<p>create V shape Valley basin </p><pre><code>template&lt;class T&gt;\nT ValleyBathy (\n    T x,\n    T y,\n    T slope,\n    T center\n) \n</code></pre> <p>This function creates a simple V shape Valley basin </p>"},{"location":"BGFlood/Testing_8cu/#function-zoneoutputtest","title":"function ZoneOutputTest","text":"<pre><code>template&lt;class T&gt;\nbool ZoneOutputTest (\n    int nzones,\n    T zsinit\n) \n</code></pre> <p>This function test the zoned output for a basic configuration</p> <p>This function test the spped and accuracy of a new gradient function gradient are only calculated for zb but assigned to different gradient variable for storage </p>"},{"location":"BGFlood/Testing_8cu/#function-zoneoutputtest-double","title":"function ZoneOutputTest&lt; double &gt;","text":"<pre><code>template bool ZoneOutputTest&lt; double &gt; (\n    int nzones,\n    double zsinit\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-zoneoutputtest-float","title":"function ZoneOutputTest&lt; float &gt;","text":"<pre><code>template bool ZoneOutputTest&lt; float &gt; (\n    int nzones,\n    float zsinit\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-alloc_init2darray","title":"function alloc_init2Darray","text":"<pre><code>void alloc_init2Darray (\n    float ** arr,\n    int NX,\n    int NY\n) \n</code></pre> <p>This function allocates and fills a 2D array with zero values </p>"},{"location":"BGFlood/Testing_8cu/#function-copyblockinfo2var","title":"function copyBlockinfo2var","text":"<pre><code>template&lt;class T&gt;\nvoid copyBlockinfo2var (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    int * blkinfo,\n    T * z\n) \n</code></pre> <p>This function copies blick info to an output variable This function is somewhat useful when checking bugs in the mesh refinement or coarsening one needs to provide a pointer(z) allocated on the CPU to store the clockinfo This fonction only works on CPU </p>"},{"location":"BGFlood/Testing_8cu/#function-copyblockinfo2var-double","title":"function copyBlockinfo2var&lt; double &gt;","text":"<pre><code>template void copyBlockinfo2var&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    int * blkinfo,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-copyblockinfo2var-float","title":"function copyBlockinfo2var&lt; float &gt;","text":"<pre><code>template void copyBlockinfo2var&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    int * blkinfo,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-copyid2var","title":"function copyID2var","text":"<pre><code>template&lt;class T&gt;\nvoid copyID2var (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>This function copies block info to an output variable This function is somewhat useful when checking bugs in the mesh refinement or coarsening one needs to provide a pointer(z) allocated on the CPU to store the clockinfo This fonction only works on CPU </p>"},{"location":"BGFlood/Testing_8cu/#function-copyid2var-double","title":"function copyID2var&lt; double &gt;","text":"<pre><code>template void copyID2var&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-copyid2var-float","title":"function copyID2var&lt; float &gt;","text":"<pre><code>template void copyID2var&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-diffarray","title":"function diffArray","text":"<pre><code>template&lt;class T&gt;\nvoid diffArray (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    std::string varname,\n    bool checkhalo,\n    T * cpu,\n    T * gpu,\n    T * dummy,\n    T * out\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-diffsource","title":"function diffSource","text":"<pre><code>template&lt;class T&gt;\nvoid diffSource (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Fqux,\n    T * Su,\n    T * output\n) \n</code></pre> <p>This function Calculate The source term of the equation. This function is quite useful when checking for Lake-at-Rest states This function requires an outputCPU pointers to save the result of teh calculation </p>"},{"location":"BGFlood/Testing_8cu/#function-diffdh","title":"function diffdh","text":"<pre><code>template&lt;class T&gt;\nvoid diffdh (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * input,\n    T * output,\n    T * shuffle\n) \n</code></pre> <p>This function Calculates The difference in left and right flux terms. This function is quite useful when checking for Lake-at-Rest states This function requires a preallocated output and a shuffle (right side term) CPU pointers to save the result of teh calculation </p>"},{"location":"BGFlood/Testing_8cu/#function-fillgauss","title":"function fillgauss","text":"<pre><code>template&lt;class T&gt;\nvoid fillgauss (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T amp,\n    T * z\n) \n</code></pre> <p>This function fill an array with a gaussian bump</p> <p>borrowed/adapted from Basilisk test (?) </p>"},{"location":"BGFlood/Testing_8cu/#function-fillgauss-double","title":"function fillgauss&lt; double &gt;","text":"<pre><code>template void fillgauss&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double amp,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-fillgauss-float","title":"function fillgauss&lt; float &gt;","text":"<pre><code>template void fillgauss&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float amp,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-fillrandom","title":"function fillrandom","text":"<pre><code>template&lt;class T&gt;\nvoid fillrandom (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>This function fill an array with random values (0 - 1) </p>"},{"location":"BGFlood/Testing_8cu/#function-fillrandom-double","title":"function fillrandom&lt; double &gt;","text":"<pre><code>template void fillrandom&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-fillrandom-float","title":"function fillrandom&lt; float &gt;","text":"<pre><code>template void fillrandom&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-init3darray","title":"function init3Darray","text":"<pre><code>void init3Darray (\n    float *** arr,\n    int rows,\n    int cols,\n    int depths\n) \n</code></pre> <p>This function fill a 3D array with zero values </p>"},{"location":"BGFlood/Testing_8cu/#function-reductiontest","title":"function reductiontest","text":"<pre><code>template&lt;class T&gt;\nbool reductiontest (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Test the algorithm for reducing the global time step on the user grid layout </p>"},{"location":"BGFlood/Testing_8cu/#function-reductiontest-double","title":"function reductiontest&lt; double &gt;","text":"<pre><code>template bool reductiontest&lt; double &gt; (\n    Param XParam,\n    Model &lt; double &gt; XModel,\n    Model &lt; double &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-reductiontest-float","title":"function reductiontest&lt; float &gt;","text":"<pre><code>template bool reductiontest&lt; float &gt; (\n    Param XParam,\n    Model &lt; float &gt; XModel,\n    Model &lt; float &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-testbuttingerx","title":"function testButtingerX","text":"<pre><code>template&lt;class T&gt;\nvoid testButtingerX (\n    Param XParam,\n    int ib,\n    int ix,\n    int iy,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>This function goes through the Buttinger scheme but instead of the normal output just prints all teh usefull values This function is/was used in the lake-at-rest verification</p> <p>See also: void testkurganovX(Param XParam, int ib, int ix, int iy, Model&lt;T&gt; XModel) </p>"},{"location":"BGFlood/Testing_8cu/#function-testboundaries","title":"function testboundaries","text":"<pre><code>template&lt;class T&gt;\nbool testboundaries (\n    Param XParam,\n    T maxslope\n) \n</code></pre>"},{"location":"BGFlood/Testing_8cu/#function-testkurganovx","title":"function testkurganovX","text":"<pre><code>template&lt;class T&gt;\nvoid testkurganovX (\n    Param XParam,\n    int ib,\n    int ix,\n    int iy,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>This function goes through the Kurganov scheme but instead of the normal output just prints all teh usefull values This function is/was used in the lake-at-rest verification </p>"},{"location":"BGFlood/Testing_8cu/#function-vectoroffsetgpu","title":"function vectoroffsetGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void vectoroffsetGPU (\n    int nx,\n    T offset,\n    T * z\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Testing.cu</code></p>"},{"location":"BGFlood/Testing_8cu_source/","title":"File Testing.cu","text":""},{"location":"BGFlood/Testing_8cu_source/#file-testingcu","title":"File Testing.cu","text":"<p>File List &gt; src &gt; Testing.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Testing.h\"\n\n\n\n\ntemplate &lt;class T&gt; bool Testing(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n\n    bool isfailed = false;\n    std::string result;\n\n    log(\"\\nRunning internal test(s):\");\n\n    int mytest;\n    mytest = XParam.test;\n    if (XParam.test == 99)\n    {\n        mytest = 0;\n    }\n\n    while (mytest &lt;= XParam.test)\n    {\n        if (mytest == 0)\n        {\n            bool bumptest, bumptestComp;\n            bool bumptestGPU = true;\n            // Test 0 is pure bump test\n            log(\"\\t ### Gaussian wave on Cartesian grid ###\");\n            //set gpu is -1 for cpu test\n\n            bumptest = GaussianHumptest(0.1, -1, false);\n            result = bumptest ? \"successful\" : \"failed\";\n            log(\"\\t\\tCPU test: \" + result);\n\n            // If original XParam tried to use GPU we try also\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                bumptestGPU = GaussianHumptest(0.1, XParam.GPUDEVICE, false);\n                result = bumptestGPU ? \"successful\" : \"failed\";\n                log(\"\\t\\tGPU test: \" + result);\n\n                if (!bumptestGPU)\n                {\n                    bumptestComp = GaussianHumptest(0.1, XParam.GPUDEVICE, true);\n                }\n            }\n            isfailed = ((bumptest == true) &amp;&amp; (bumptestGPU == true)) ? false : true;\n        }\n        if (mytest == 1)\n        {\n            bool rivertest;\n            // Test 1 is vertical discharge on a flat uniorm cartesian mesh (GPU and CU version)\n            log(\"\\t ### River Mass conservation grid ###\");\n            rivertest = Rivertest(0.1, -1);\n            result = rivertest ? \"successful\" : \"failed\";\n            log(\"\\t\\tCPU test: \" + result);\n            isfailed = (!rivertest || isfailed) ? true : false;\n\n            log(\" \\t\\t\\t GPU device= \" + std::to_string(XParam.GPUDEVICE));\n\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                rivertest = Rivertest(0.1, XParam.GPUDEVICE);\n                result = rivertest ? \"successful\" : \"failed\";\n                log(\"\\t\\tGPU test: \" + result);\n                isfailed = (!rivertest || isfailed) ? true : false;\n            }\n\n            rivertest = RiverVolumeAdapt(XParam, T(0.4));\n            result = rivertest ? \"successful\" : \"failed\";\n            log(\"\\t\\tRiver Volume Adapt: \" + result);\n            isfailed = (!rivertest || isfailed) ? true : false;\n\n        }\n        if (mytest == 2)\n        {\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                bool GPUvsCPUtest;\n                log(\"\\t### Gaussian wave on Cartesian grid: CPU vs GPU ###\");\n                GPUvsCPUtest = GaussianHumptest(0.1, XParam.GPUDEVICE, true);\n                result = GPUvsCPUtest ? \"successful\" : \"failed\";\n                log(\"\\t\\tCPU vs GPU test: \" + result);\n                isfailed = (!GPUvsCPUtest || isfailed) ? true : false;\n            }\n            else\n            {\n                log(\"Specify GPU device to run test 2 (CPU vs GPU comparison)\");\n            }\n        }\n        if (mytest == 3)\n        {\n\n            bool testresults;\n            bool testreduction = true;\n\n            // Iterate this test niter times:\n            int niter = 1000;\n            srand(time(0));\n            log(\"\\t### Reduction Test ###\");\n            for (int iter = 0; iter &lt; niter; iter++)\n            {\n                testresults = reductiontest(XParam, XModel, XModel_g);\n                testreduction = testreduction &amp;&amp; testresults;\n            }\n\n            result = testreduction ? \"successful\" : \"failed\";\n            log(\"\\t\\tReduction test: \" + result);\n            isfailed = (!testreduction || isfailed) ? true : false;\n\n        }\n        if (mytest == 4)\n        {\n            log(\"\\t### Boundary Test ###\");\n            bool testBound = testboundaries(XParam, T(0.1));\n            result = testBound ? \"successful\" : \"failed\";\n            isfailed = (!testBound || isfailed) ? true : false;\n            log(\"\\t\\tboundaries test: \" + result);\n        }\n        if (mytest == 5)\n        {\n            log(\"\\t### Lake-at-rest Test ###\");\n            bool testTLAR = ThackerLakeAtRest(XParam, T(0.0));\n            result = testTLAR ? \"successful\" : \"failed\";\n            isfailed = (!testTLAR || isfailed) ? true : false;\n            log(\"\\t\\tThaker lake-at-rest test: \" + result);\n            testTLAR = LakeAtRest(XParam, XModel);\n            isfailed = (!testTLAR || isfailed) ? true : false;\n            log(\"\\t\\tLake-at-rest test: \" + result);\n        }\n        if (mytest == 6)\n        {\n            log(\"\\t### Mass conservation Test ###\");\n            bool testSteepSlope = MassConserveSteepSlope(XParam.zsinit, XParam.GPUDEVICE);\n            result = testSteepSlope ? \"successful\" : \"failed\";\n            isfailed = (!testSteepSlope || isfailed) ? true : false;\n            log(\"\\t\\tMass conservation test: \" + result);\n        }\n        if (mytest == 7)\n        {\n            bool testrainGPU, testrainCPU;\n            /* Test 7 is homogeneous rain on a uniform slope for cartesian mesh (GPU and CPU version)\n             The input parameters are :\n                    - the initial water level (zs)\n                    - GPU option\n                    - the slope (%)\n            */\n            log(\"\\t### Homogeneous rain on grid Mass conservation test ###\");\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                testrainGPU = Raintest(0.0, 0, 10, XParam.engine);\n                result = testrainGPU ? \"successful\" : \"failed\";\n                log(\"\\t\\tHomogeneous rain on grid test GPU: \" + result);\n            }\n            testrainCPU = Raintest(0.0, -1, 10, XParam.engine);\n            result = testrainCPU ? \"successful\" : \"failed\";\n            log(\"\\t\\tHomogeneous rain on grid test CPU: \" + result);\n            isfailed = (!testrainCPU || !testrainGPU || isfailed) ? true : false;\n        }\n        if (XParam.test == 8)\n        {\n            bool raintest2;\n            /* Test 8 is non-homogeneous rain on a non-uniform slope for cartesian mesh (GPU and CPU version)\n             It is based on a teste case from litterature (Iwagaki1955) and tests the different\n             rain inputs (time serie for 1D input or netCDF file).\n            */\n\n            log(\"\\t non-uniform rain forcing on slope based on Aureli2020\");\n            int gpu = 0;\n            raintest2 = Raintestinput(gpu);\n            result = raintest2 ? \"successful\" : \"failed\";\n            log(\"\\t\\tNon-uniform rain forcing : \" + result);\n        }\n        if (mytest == 9)\n        {\n            bool testzoneOutDef, testzoneOutUser;\n            /* Test 9 is basic configuration to test the zoned outputs, with different resolutions.\n             The default (without zoned defined by user) configuration is tested.\n             Then, the creation of 3 zones is then tested(whole, zoned complexe, zoned with part of the levels).\n             The size of the created nc files is used to verified this fonctionnality.\n             Parameter: nbzones: number of zones for output defined by the user\n                        zsinit: initial water elevation\n            */\n\n            log(\"\\t### Test zoned output ###\");\n            int nbzones = 0;\n            T zsinit = 0.01;\n            testzoneOutDef = ZoneOutputTest(nbzones, zsinit);\n            result = testzoneOutDef ? \"successful\" : \"failed\";\n            log(\"\\n\\nDefault zoned Outputs: \" + result);\n            nbzones = 3; // 3 only\n            testzoneOutUser = ZoneOutputTest(nbzones, zsinit);\n            result = testzoneOutUser ? \"successful\" : \"failed\";\n            log(\"\\n\\nUser defined zones Outputs: \" + result);\n            isfailed = (!testzoneOutDef || !testzoneOutUser || isfailed) ? true : false;\n        }\n        if (mytest == 10)\n        {\n\n            bool testrainlossesGPU, testrainlossesCPU;\n            /* Test 10 is to test the Initial / Continuous Losses of rain, on a uniform slope, under uniform rain\n            for cartesian mesh (GPU and CPU version)\n             The input parameters are :\n                    - the initial water level (zs)\n                    - GPU option\n                    - the slope (%)\n            */\n            log(\"\\t### IL-CL Rain losses test on GPU ###\");\n            testrainlossesGPU = Rainlossestest(0.0, 0, 10);\n            result = testrainlossesGPU ? \"successful\" : \"failed\";\n            log(\"\\n\\n\\t IL-CL Rain losses test GPU: \" + result);\n            testrainlossesCPU = Rainlossestest(0.0, -1, 10);\n            result = testrainlossesCPU ? \"successful\" : \"failed\";\n            log(\"\\n\\n\\t IL-CL Rain losses test CPU: \" + result);\n            isfailed = (!testrainlossesCPU || !testrainlossesGPU || isfailed) ? true : false;\n        }\n        if (mytest == 11)\n        {\n            bool instab;\n            log(\"\\t### Wet/dry Instability test with Conserve Elevation ###\");\n            instab = TestInstability(XParam, XModel, XModel_g);\n            result = instab ? \"successful\" : \"failed\";\n            log(\"\\t\\tWet/dry Instability test : \" + result);\n        }\n\n        if (mytest == 12)\n        {\n            /* Test 12 is to test the calendar time to second conversion\n                This test will fail if the system or compiler does not suport long long\n\n            */\n            bool timetest;\n            timetest = testime1(1) &amp;&amp; testime2(2);\n            result = timetest ? \"successful\" : \"failed\";\n            log(\"\\t\\tCalendar time test : \" + result);\n        }\n\n        if (mytest == 13)\n        {\n            /* Test 13 is to test the input of different roughness maps (and different bathymetry at the same time)\n                Test1: 2 DEM and 2 roughness netcdf files are created and saved; then read.\n                    The max / min values are check to see if the z/z0 maps are created as expected\n                Test2: A roughness file name is changed to have a number in first position. We check that the\n                    file is read and not the number taken as z0 value.\n                Test3: A roughness is entered as a value, test that it is implemented for the whole domain.\n                Test4 :  Test value input for initial loss / continuous loss\n            */\n            bool RoughBathyresult, RoughInput, RoughtInputnumber, ILCLInputnumber;\n            log(\"\\t### Different bathy and different roughness file inputs ###\");\n            RoughBathyresult = TestMultiBathyRough(0, 0.0, 0);//&amp;&amp; TestRoughness(XParam, XModel, XModel_g);\n            result = RoughBathyresult ? \"successful\" : \"failed\";\n            log(\"\\t\\t ##### \\n\");\n            log(\"\\t\\t ##### Different Bathy and Roughness test : \" + result + \"\\n\");\n            RoughInput = TestMultiBathyRough(0, 0.0, 1);//&amp;&amp; TestRoughness(XParam, XModel, XModel_g);\n            result = RoughInput ? \"successful\" : \"failed\";\n            log(\"\\t\\t ##### \\n\");\n            log(\"\\t\\t ##### Roughness file name test : \" + result + \"\\n\");\n            RoughtInputnumber = TestMultiBathyRough(0, 0.0, 2);//&amp;&amp; TestRoughness(XParam, XModel, XModel_g);\n            result = RoughtInputnumber ? \"successful\" : \"failed\";\n            log(\"\\t\\t ##### \\n\");\n            log(\"\\t\\t ##### Roughness value input test : \" + result + \"\\n\");\n            log(\"\\t\\t ##### \\n\");\n            ILCLInputnumber = TestMultiBathyRough(0, 0.0, 3);//&amp;&amp; TestRoughness(XParam, XModel, XModel_g);\n            result = ILCLInputnumber ? \"successful\" : \"failed\";\n            log(\"\\t\\t ##### \\n\");\n            log(\"\\t\\t ##### Initial Loss / Continuous Loss value input test : \" + result + \"\\n\");\n            log(\"\\t\\t ##### \\n\");\n            isfailed = (!RoughBathyresult || !RoughInput || !RoughtInputnumber || !ILCLInputnumber || isfailed) ? true : false;\n        }\n\n        if (mytest == 14)\n        {\n            /* Test 14  This test AOI bnds aswall to start with\n\n            */\n            bool wallbndleft, wallbndright, wallbndbot, wallbndtop;\n            log(\"\\t###AOI bnd wall test ###\");\n            wallbndleft = TestAIObnd(XParam, XModel, XModel_g, false, false, false);\n            wallbndright = TestAIObnd(XParam, XModel, XModel_g, false, true, false);\n            wallbndbot = TestAIObnd(XParam, XModel, XModel_g, true, false, false);\n            wallbndtop = TestAIObnd(XParam, XModel, XModel_g, true, true, false);\n            result = (wallbndleft &amp; wallbndright &amp; wallbndbot &amp; wallbndtop) ? \"successful\" : \"failed\";\n            log(\"\\t\\tBBox bnd wall test : \" + result);\n            wallbndleft = TestAIObnd(XParam, XModel, XModel_g, false, false, true);\n            wallbndright = TestAIObnd(XParam, XModel, XModel_g, false, true, true);\n            wallbndbot = TestAIObnd(XParam, XModel, XModel_g, true, false, true);\n            wallbndtop = TestAIObnd(XParam, XModel, XModel_g, true, true, true);\n            result = (wallbndleft &amp; wallbndright &amp; wallbndbot &amp; wallbndtop) ? \"successful\" : \"failed\";\n            log(\"\\t\\tAOI bnd wall test : \" + result);\n        }\n\n        if (mytest == 15)\n            /* Test 15 is to test the input of flexible times outputs (general and in zone_outputs)\n                Test1: Test of times in second/durations (for general and zone_outputs)\n                    The data is read from paramfile and we test the reading and nc files created.\n            */\n        {\n            bool FlexibleOutTime;\n            log(\"\\t### Tests for flexible time outputs (general and zones outputs) ###\");\n            FlexibleOutTime = TestFlexibleOutputTimes(0, 0.0, 0);\n            result = FlexibleOutTime ? \"successful\" : \"failed\";\n            log(\"\\t\\t ##### \\n\");\n            log(\"\\t\\t ##### Flexible output times reading test : \" + result + \"\\n\");\n            log(\"\\t\\t ##### \\n\");\n            isfailed = (!FlexibleOutTime || isfailed) ? true : false;\n\n        }\n\n\n\n    if (mytest == 993)\n    {\n        //pinned pageable Memory test\n        TestPinMem(XParam, XModel, XModel_g);\n    }\n\n    if (mytest == 900)\n    {\n        GaussianHumptest(0.1, XParam.GPUDEVICE, false);\n    }\n\n        if (mytest == 994)\n        {\n            Testzbinit(XParam, XForcing, XModel, XModel_g);\n        }\n\n        if (mytest == 995)\n        {\n            TestFirsthalfstep(XParam, XForcing, XModel, XModel_g);\n        }\n        if (mytest == 996)\n        {\n            TestHaloSpeed(XParam, XModel, XModel_g);\n        }\n        if (mytest == 997)\n        {\n            TestGradientSpeed(XParam, XModel, XModel_g);\n        }\n\n        if (mytest == 998)\n        {\n            //\n            bool testresults;\n            log(\"\\t### CPU vs GPU Test ###\");\n            testresults = CPUGPUtest(XParam, XModel, XModel_g);\n            isfailed = (!testresults || isfailed) ? true : false;\n            if (testresults)\n            {\n                exit(0);\n            }\n            else\n            {\n                exit(1);\n            }\n        }\n        if (XParam.test == 999)\n        {\n            //\n            DebugLoop(XParam, XForcing, XModel, XModel_g);\n        }\n        mytest++;\n    }\n    return(isfailed);\n}\ntemplate bool Testing&lt;float&gt;(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;float&gt; XModel, Model&lt;float&gt; XModel_g);\ntemplate bool Testing&lt;double&gt;(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;double&gt; XModel, Model&lt;double&gt; XModel_g);\n\n\ntemplate &lt;class T&gt; bool GaussianHumptest(T zsnit, int gpu, bool compare)\n{\n    log(\"#####\");\n    // this is a preplica of the tutorial case for Basilisk\n    Param XParam;\n\n    T x, y, delta;\n    T cc = T(0.05);// Match the 200 in chracteristic radius used in Basilisk  1/(2*cc^2)=200\n\n    //XParam.engine = 2;\n\n    T a = T(1.0); //Gaussian wave amplitude\n\n    // Verification data\n    // This is a transect across iy=15:16:127 at ix=127 (or vice versa because the solution is symetrical)\n    // These values are based on single precision output from Netcdf file so are only accurate to 10-7 \n    //double ZsVerifKurganov[8] = { 0.100000000023, 0.100000063119, 0.100110376004, 0.195039970749, 0.136739044168, 0.0848024805994, 0.066275833049, 0.0637058445888 };\n    //double ZsVerification[8] = { 0.100000008904, 0.187920326216, 0.152329657390, 0.117710230042, 0.0828616638138, 0.0483274739972, 0.0321501737555, 0.0307609731288 };\n    double ZsVerifButtinger[8] = { 0.100000000023, 0.100000063119, 0.100093580546, 0.195088199869, 0.136767978925, 0.0850706353898, 0.0663028448129, 0.063727949607 };\n\n\n\n\n    // initialise domain and required resolution\n    XParam.dx = 1.0 / ((1 &lt;&lt; 8));\n    XParam.xo = -0.5;\n    XParam.yo = -0.5;\n\n    XParam.xmax = 0.5;\n    XParam.ymax = 0.5;\n    //level 8 is \n\n\n    XParam.initlevel = 0;\n    XParam.minlevel = 0;\n    XParam.maxlevel = 0;\n\n    XParam.zsinit = zsnit;\n    XParam.zsoffset = 0.0;\n\n    XParam.aoibnd = 3;\n\n    //Output times for comparisons\n    XParam.endtime = 1.0;\n    XParam.outputtimestep = 0.1;\n\n    XParam.smallnc = 0;\n\n    XParam.cf = 0.0;\n    XParam.frictionmodel = 0;\n\n    // Enforece GPU/CPU\n    XParam.GPUDEVICE = gpu;\n\n    std::string outvi[18] = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"ho\", \"vo\", \"uo\", \"cf\" };\n\n    std::vector&lt;std::string&gt; outv;\n\n    for (int nv = 0; nv &lt; 18; nv++)\n    {\n        outv.push_back(outvi[nv]);\n    }\n\n    XParam.outvars = outv;\n\n    // create Model setup\n    Model&lt;T&gt; XModel;\n    Model&lt;T&gt; XModel_g;\n\n    Forcing&lt;float&gt; XForcing;\n    StaticForcingP&lt;float&gt; bathy;\n\n    XForcing.Bathy.push_back(bathy);\n    // initialise forcing bathymetry to 0\n    XForcing.Bathy[0].xo = -1.0;\n    XForcing.Bathy[0].yo = -1.0;\n\n    XForcing.Bathy[0].xmax = 1.0;\n    XForcing.Bathy[0].ymax = 1.0;\n    XForcing.Bathy[0].nx = 3;\n    XForcing.Bathy[0].ny = 3;\n\n    XForcing.Bathy[0].dx = 1.0;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n\n    //AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = 0.0f;\n        }\n    }\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    // Recreate the initia;l conditions\n    //InitArrayBUQ(XParam, XModel.blocks, T(0.0), XModel.zb);\n    //InitArrayBUQ(XParam, XModel.blocks, zsnit, XModel.evolv.zs);\n    //zs is initialised here:\n    InitialConditions(XParam, XForcing, XModel);\n\n    T xorigin = T(0.0);\n    T yorigin = T(0.0);\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XModel.blocks.active[ibl];\n        delta = T(calcres(XParam.dx, XModel.blocks.level[ib]));\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int n = memloc(XParam, ix, iy, ib);\n                x = T(XParam.xo) + XModel.blocks.xo[ib] + ix * delta;\n                y = T(XParam.yo) + XModel.blocks.yo[ib] + iy * delta;\n                XModel.evolv.zs[n] = XModel.evolv.zs[n] + a * exp(T(-1.0) * ((x - xorigin) * (x - xorigin) + (y - yorigin) * (y - yorigin)) / (T(2.0) * cc * cc));\n                XModel.evolv.h[n] = utils::max(XModel.evolv.zs[n] - XModel.zb[n], T(0.0));\n\n            }\n        }\n    }\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    Loop&lt;T&gt; XLoop;\n    Loop&lt;T&gt; XLoop_g;\n\n\n    XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n    XLoop.totaltime = 0.0;\n\n    //InitSave2Netcdf(XParam, XModel);\n    XLoop.nextoutputtime = XParam.outputtimestep;\n    XLoop.dtmax = initdt(XParam, XLoop, XModel);\n\n    //XLoop_g = XLoop;\n    XLoop_g.hugenegval = std::numeric_limits&lt;T&gt;::min();\n    XLoop_g.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop_g.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n    XLoop_g.totaltime = 0.0;\n\n    //InitSave2Netcdf(XParam, XModel);\n    XLoop_g.nextoutputtime = XParam.outputtimestep;\n    XLoop_g.dtmax = XLoop.dtmax;\n\n\n    if (XParam.GPUDEVICE &gt;= 0 &amp;&amp; compare)\n    {\n        CompareCPUvsGPU(XParam, XModel, XModel_g, outv, false);\n    }\n    bool modelgood = true;\n\n    fillHaloC(XParam, XModel.blocks, XModel.zb);\n    gradientC(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    gradientHalo(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n\n    refine_linear(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    gradientHalo(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n\n    while (XLoop.totaltime &lt; XLoop.nextoutputtime)\n    {\n\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            if (XParam.engine == 5)\n            {\n                FlowMLGPU(XParam, XLoop, XForcing, XModel_g);\n            }\n            else\n            {\n                FlowGPU(XParam, XLoop_g, XForcing, XModel_g);\n            }\n            XLoop.dt = XLoop_g.dt;\n        }\n        else\n        {\n            FlowCPU(XParam, XLoop, XForcing, XModel);\n        }\n        if (XParam.GPUDEVICE &gt;= 0 &amp;&amp; compare)\n        {\n            int GPUdev = XParam.GPUDEVICE;\n            XParam.GPUDEVICE = -1;\n            FlowCPU(XParam, XLoop, XForcing, XModel);\n            XParam.GPUDEVICE = GPUdev;\n\n            T diffdt = T(XLoop_g.dt - XLoop.dt);\n            if (abs(diffdt) &gt; T(100.0) * (XLoop.epsilon))\n            {\n                printf(\"Timestep Difference=%f\\n\", diffdt);\n\n                compare = false;\n            }\n            CompareCPUvsGPU(XParam, XModel, XModel_g, outv, false);\n        }\n\n        //diffdh(XParam, XModel.blocks, XModel.flux.Su, diff, shuffle);\n        //diffSource(XParam, XModel.blocks, XModel.flux.Fqux, XModel.flux.Su, diff);\n        XLoop.totaltime = XLoop.totaltime + XLoop.dt;\n        XLoop_g.totaltime = XLoop_g.totaltime + XLoop_g.dt;\n        if (XLoop.nextoutputtime - XLoop.totaltime &lt;= XLoop.dt * T(0.00001) &amp;&amp; XParam.outputtimestep &gt; 0.0)\n        {\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n                {\n                    CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[XParam.outvars[ivar]], XModel_g.OutputVarMap[XParam.outvars[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n                }\n            }\n\n            //Save2Netcdf(XParam, XModel);\n            // Verify the Validity of results\n\n\n            double diff;\n            for (int iv = 0; iv &lt; 8; iv++)\n            {\n\n                int ix, iy, ib, ii, jj, ibx, iby, nbx;\n                jj = 127;\n                ii = (iv + 1) * 16 - 1;\n\n                // Theoretical size is 255x255\n                nbx = 256 / 16;\n\n\n                ibx = ftoi(floor(ii / XParam.blkwidth));\n                iby = ftoi(floor(jj / XParam.blkwidth));\n\n                ib = (iby)*nbx + ibx;\n\n                ix = ii - ibx * XParam.blkwidth;\n                iy = jj - iby * XParam.blkwidth;\n\n                int n = memloc(XParam, ix, iy, ib);\n\n                diff = abs(T(XModel.evolv.zs[n]) - ZsVerifButtinger[iv]);\n\n\n\n                if (diff &gt; 1e-6)//Tolerance is 1e-6 or 1e-7/1e-8??\n                {\n\n                    printf(\"ib=%d, ix=%d, iy=%d; simulated=%f; expected=%f; diff=%e\\n\", ib, ix, iy, XModel.evolv.zs[n], ZsVerifButtinger[iv], diff);\n                    modelgood = false;\n                    creatncfileBUQ(XParam, XModel.blocks);\n                    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"zs\", 3, XModel.evolv.zs, XModel.blocks.outZone[0]);\n                }\n\n\n\n            }\n\n\n\n            //XLoop.nextoutputtime = min(XLoop.nextoutputtime + XParam.outputtimestep, XParam.endtime);\n\n        }\n    }\n    log(\"#####\");\n    return modelgood;\n}\ntemplate bool GaussianHumptest&lt;float&gt;(float zsnit, int gpu, bool compare);\ntemplate bool GaussianHumptest&lt;double&gt;(double zsnit, int gpu, bool compare);\n\ntemplate &lt;class T&gt; bool Rivertest(T zsnit, int gpu)\n{\n    log(\"#####\");\n    Param XParam;\n    T delta = 0;\n    T initVol = 0;\n    T finalVol = 0;\n    T TheoryInput = 0;\n\n    // initialise domain and required resolution\n    XParam.dx = 1.0 / ((1 &lt;&lt; 4));\n    XParam.xo = -0.5;\n    XParam.yo = -0.5;\n\n    XParam.xmax = 0.5;\n    XParam.ymax = 0.5;\n    //level 8 is \n\n\n    XParam.initlevel = 0;\n    XParam.minlevel = 0;\n    XParam.maxlevel = 0;\n\n    XParam.zsinit = zsnit;\n    XParam.zsoffset = 0.0;\n\n    //Output times for comparisons\n    XParam.endtime = 1.0;\n    XParam.outputtimestep = 0.1;\n\n    XParam.smallnc = 0;\n\n    XParam.cf = 0.0;\n    XParam.frictionmodel = 0;\n\n    // Enforece GPU/CPU\n    XParam.GPUDEVICE = gpu;\n\n    std::vector&lt;std::string&gt; outv = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"Su\", \"Sv\",\"dhdx\", \"dhdy\", \"dudx\", \"dvdx\", \"dzsdx\", \"twet\", \"hUmax\", \"Umean\" };\n    XParam.outvars = outv;\n\n    XParam.outmax = true;\n    XParam.outmean = true;\n    XParam.outtwet = true;\n\n    XParam.ForceMassConserve = true;\n\n    // create Model setup\n    Model&lt;T&gt; XModel;\n    Model&lt;T&gt; XModel_g;\n\n    Forcing&lt;float&gt; XForcing;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    XForcing.Bathy.push_back(bathy);\n\n    // initialise forcing bathymetry to 0\n    XForcing.Bathy[0].xo = -1.0;\n    XForcing.Bathy[0].yo = -1.0;\n\n    XForcing.Bathy[0].xmax = 1.0;\n    XForcing.Bathy[0].ymax = 1.0;\n    XForcing.Bathy[0].nx = 3;\n    XForcing.Bathy[0].ny = 3;\n\n    XForcing.Bathy[0].dx = 1.0;\n    XForcing.Bathy[0].dy = 1.0;\n\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = 0.0f;\n        }\n    }\n    //\n    //\n    // \n    T Q = T(0.001);\n    TheoryInput = Q * T(XParam.outputtimestep);\n\n\n    //Create a temporary file with river fluxes\n    std::ofstream river_file(\n        \"testriver.tmp\", std::ios_base::out | std::ios_base::trunc);\n    river_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file &lt;&lt; \"3600.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file.close(); //destructor implicitly does it\n\n    River thisriver;\n    thisriver.Riverflowfile = \"testriver.tmp\";\n    thisriver.xstart = -1.0 * XParam.dx * 3.0;\n    thisriver.xend = XParam.dx * 3.0;\n    thisriver.ystart = -1.0 * XParam.dx * 3.0;\n    thisriver.yend = XParam.dx * 3.0;\n\n    XForcing.rivers.push_back(thisriver);\n\n\n    XForcing.rivers[0].flowinput = readFlowfile(XForcing.rivers[0].Riverflowfile, XParam.reftime);\n\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    Loop&lt;T&gt; XLoop;\n\n    XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    XLoop.totaltime = 0.0;\n\n    //InitSave2Netcdf(XParam, XModel);\n    XLoop.nextoutputtime = XParam.outputtimestep;\n    XLoop.dtmax = initdt(XParam, XLoop, XModel);\n    initVol = T(0.0);\n\n    fillHaloC(XParam, XModel.blocks, XModel.zb);\n\n    // Calculate initial water volume\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XModel.blocks.active[ibl];\n        delta = calcres(T(XParam.delta), XModel.blocks.level[ib]);\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int n = memloc(XParam, ix, iy, ib);\n                //printf(\"h[%d] = %f\\n\", n, XModel.evolv.h[n]);\n                initVol = initVol + XModel.evolv.h[n] * delta * delta;\n            }\n        }\n    }\n\n\n    //InitSave2Netcdf(XParam, XModel);\n    bool modelgood = true;\n\n    while (XLoop.totaltime &lt; XLoop.nextoutputtime)\n    {\n\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            FlowGPU(XParam, XLoop, XForcing, XModel_g);\n        }\n        else\n        {\n            printf(\"h[1] = %f\\n\", XModel.evolv.h[1]);\n            FlowCPU(XParam, XLoop, XForcing, XModel);\n        }\n        XLoop.totaltime = XLoop.totaltime + XLoop.dt;\n        //Save2Netcdf(XParam, XLoop, XModel);\n\n        if (XLoop.nextoutputtime - XLoop.totaltime &lt;= XLoop.dt * T(0.00001))\n        {\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n                {\n                    CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[XParam.outvars[ivar]], XModel_g.OutputVarMap[XParam.outvars[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n                }\n            }\n\n            //Save2Netcdf(XParam, XLoop, XModel);\n            // Verify the Validity of results\n            finalVol = T(0.0);\n            for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n            {\n                //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n                int ib = XModel.blocks.active[ibl];\n                delta = calcres(T(XParam.delta), XModel.blocks.level[ib]);\n\n\n                for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n                {\n                    for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n                    {\n                        //\n                        int n = memloc(XParam, ix, iy, ib);\n                        //printf(\"h[%d] = %f\\n\", n, XModel.evolv.h[n]);\n                        finalVol = finalVol + XModel.evolv.h[n] * delta * delta;\n                    }\n                }\n            }\n            T error = ((finalVol - initVol) - TheoryInput) / TheoryInput;\n            printf(\"error = %g %%, initial volume=%4.4f; final Volume=%4.4f; abs. difference=%4.4f, Theoretical  input=%4.4f \\n\", error, initVol, finalVol, abs(finalVol - initVol), TheoryInput);\n\n\n            modelgood = abs(error) &lt; 0.05;\n        }\n\n\n\n    }\n\n    if (!modelgood)\n    {\n        InitSave2Netcdf(XParam, XModel);\n\n    }\n\n\n    log(\"#####\");\n    return modelgood;\n}\ntemplate bool Rivertest&lt;float&gt;(float zsnit, int gpu);\ntemplate bool Rivertest&lt;double&gt;(double zsnit, int gpu);\n\n\n\ntemplate &lt;class T&gt; bool MassConserveSteepSlope(T zsnit, int gpu)\n{\n    log(\"#####\");\n    Param XParam;\n    T delta, initVol, finalVol, TheoryInput;\n    // initialise domain and required resolution\n    XParam.dx = 1.0 / ((1 &lt;&lt; 8));\n    XParam.xo = -0.5;\n    XParam.yo = -0.5;\n\n    XParam.xmax = 0.5;\n    XParam.ymax = 0.5;\n    //level 8 is \n\n\n    XParam.initlevel = 0;\n    XParam.minlevel = -1;\n    XParam.maxlevel = 1;\n\n    XParam.AdaptCrit = \"Threshold\";\n    XParam.Adapt_arg1 = \"3.5\";\n    XParam.Adapt_arg2 = \"zb\";\n\n    XParam.zsinit = zsnit;\n    XParam.zsoffset = 0.0;\n\n    //Output times for comparisons\n    XParam.endtime = 1.0;\n    XParam.outputtimestep = 0.04;//0.035;\n\n    XParam.smallnc = 0;\n\n    XParam.cf = 0.001;\n    XParam.frictionmodel = 1;\n\n    XParam.conserveElevation = false;\n    XParam.ForceMassConserve = true;\n\n    // Enforce GPU/CPU\n    XParam.GPUDEVICE = gpu;\n    std::vector&lt;std::string&gt; outv = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"Su\", \"Sv\",\"dhdx\", \"dhdy\" };\n\n\n    XParam.outvars = outv;\n    // create Model setup\n    Model&lt;T&gt; XModel;\n    Model&lt;T&gt; XModel_g;\n\n    Forcing&lt;float&gt; XForcing;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    XForcing.Bathy.push_back(bathy);\n\n    // initialise forcing bathymetry to 0\n    XForcing.Bathy[0].xo = -1.0;\n    XForcing.Bathy[0].yo = -1.0;\n\n    XForcing.Bathy[0].xmax = 1.0;\n    XForcing.Bathy[0].ymax = 1.0;\n    XForcing.Bathy[0].nx = 3;\n    XForcing.Bathy[0].ny = 3;\n\n    XForcing.Bathy[0].dx = 1.0;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = T(i * 4);\n        }\n    }\n    //\n    //\n    // \n    T Q = T(0.10);\n    TheoryInput = Q * T(XParam.outputtimestep);\n\n\n    //Create a temporary file with river fluxes\n    std::ofstream river_file(\n        \"testriver.tmp\", std::ios_base::out | std::ios_base::trunc);\n    river_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file &lt;&lt; \"3600.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file.close(); //destructor implicitly does it\n\n    River thisriver;\n    thisriver.Riverflowfile = \"testriver.tmp\";\n    thisriver.xstart = -1.0 * XParam.dx * 3.0;\n    thisriver.xend = XParam.dx * 3.0;\n    thisriver.ystart = -1.0 * XParam.dx * 3.0;\n    thisriver.yend = XParam.dx * 3.0;\n\n    XForcing.rivers.push_back(thisriver);\n\n\n    XForcing.rivers[0].flowinput = readFlowfile(XForcing.rivers[0].Riverflowfile, XParam.reftime);\n\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    Loop&lt;T&gt; XLoop;\n\n    XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    XLoop.totaltime = 0.0;\n\n\n\n    InitSave2Netcdf(XParam, XModel);\n    XLoop.nextoutputtime = XParam.outputtimestep;\n    XLoop.dtmax = 0.025;// initdt(XParam, XLoop, XModel);\n\n\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XModel.blocks.active[ibl];\n        //delta = calcres(XParam.dx, XModel.blocks.level[ib]);\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int n = memloc(XParam, ix, iy, ib);\n                if (XModel.zb[n] &lt; XParam.eps)\n                {\n                    printf(\"ix=%d, iy=%d, ib=%d, n=%d; zb=%f \\n\", ix, iy, ib, n, XModel.zb[n]);\n                }\n            }\n        }\n    }\n\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        cudaStream_t stream;\n        CUDA_CHECK(cudaStreamCreate(&amp;stream));\n\n        fillHaloGPU(XParam, XModel_g.blocks, stream, XModel_g.zb);\n\n        cudaStreamDestroy(stream);\n    }\n    else\n    {\n        fillHaloC(XParam, XModel.blocks, XModel.zb);\n    }\n\n    initVol = T(0.0);\n    // Calculate initial water volume\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XModel.blocks.active[ibl];\n        delta = calcres(T(XParam.delta), XModel.blocks.level[ib]);\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int n = memloc(XParam, ix, iy, ib);\n                initVol = initVol + XModel.evolv.h[n] * delta * delta;\n            }\n        }\n    }\n\n\n    //InitSave2Netcdf(XParam, XModel);+\n\n\n\n    bool modelgood = true;\n\n    while (XLoop.totaltime &lt; XLoop.nextoutputtime)\n    {\n\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            FlowGPU(XParam, XLoop, XForcing, XModel_g);\n        }\n        else\n        {\n            FlowCPU(XParam, XLoop, XForcing, XModel);\n        }\n        XLoop.totaltime = XLoop.totaltime + XLoop.dt;\n        //Save2Netcdf(XParam, XLoop, XModel);\n\n        if (XLoop.nextoutputtime - XLoop.totaltime &lt;= XLoop.dt * T(0.00001) &amp;&amp; XParam.outputtimestep &gt; 0.0)\n        {\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n                {\n                    CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[XParam.outvars[ivar]], XModel_g.OutputVarMap[XParam.outvars[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n                }\n            }\n\n            Save2Netcdf(XParam, XLoop, XModel);\n            // Verify the Validity of results\n            finalVol = T(0.0);\n            for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n            {\n                //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n                int ib = XModel.blocks.active[ibl];\n                delta = calcres(T(XParam.delta), XModel.blocks.level[ib]);\n\n\n                for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n                {\n                    for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n                    {\n                        //\n                        int n = memloc(XParam, ix, iy, ib);\n                        finalVol = finalVol + XModel.evolv.h[n] * delta * delta;\n                    }\n                }\n            }\n            T error = (finalVol - initVol) - TheoryInput;\n\n            modelgood = error / TheoryInput &lt; 0.05;\n        }\n\n\n    }\n    log(\"#####\");\n    return modelgood;\n}\ntemplate bool MassConserveSteepSlope&lt;float&gt;(float zsnit, int gpu);\ntemplate bool MassConserveSteepSlope&lt;double&gt;(double zsnit, int gpu);\n\n\ntemplate &lt;class T&gt; bool reductiontest(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n    //srand(seed);\n    T mininput = T(rand()) / T(RAND_MAX);\n    bool test = true;\n\n    Loop&lt;T&gt; XLoop;\n\n    XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    XLoop.totaltime = 0.0;\n\n    //InitSave2Netcdf(XParam, XModel);\n    XLoop.nextoutputtime = mininput * T(2.0);\n    XLoop.dtmax = mininput * T(2.01);\n\n    // Fill in dtmax with random values that are larger than  mininput\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int n = memloc(XParam, ix, iy, ib);\n                XModel.time.dtmax[n] = mininput * T(1.1) + utils::max(T(rand()) / T(RAND_MAX), T(0.0));\n            }\n        }\n    }\n\n    // randomly select a block a i and a j were the maximum value will be relocated\n    int ibbl = ftoi(floor(T(rand()) / T(RAND_MAX) * XParam.nblk));\n    int ibb = XModel.blocks.active[ibbl];\n    int ixx = ftoi(floor(T(rand()) / T(RAND_MAX) * XParam.blkwidth));\n    int iyy = ftoi(floor(T(rand()) / T(RAND_MAX) * XParam.blkwidth));\n\n    int nn = memloc(XParam, ixx, iyy, ibb);\n\n    XModel.time.dtmax[nn] = mininput;\n\n    T reducedt = CalctimestepCPU(XParam, XLoop, XModel.blocks, XModel.time);\n\n    test = abs(reducedt - mininput) &lt; T(100.0) * (XLoop.epsilon);\n    bool testgpu;\n\n    if (!test)\n    {\n        char buffer[256]; sprintf(buffer, \"%e\", abs(reducedt - mininput));\n        std::string str(buffer);\n        log(\"\\t\\t CPU test failed! : Expected=\" + std::to_string(mininput) + \";  Reduced=\" + std::to_string(reducedt) + \";  error=\" + str);\n    }\n\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n\n        reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XLoop.hugeposval, XModel_g.time.dtmax);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        CopytoGPU(XParam.nblkmem, XParam.blksize, XModel.time.dtmax, XModel_g.time.dtmax);\n        T reducedtgpu = CalctimestepGPU(XParam, XLoop, XModel_g.blocks, XModel_g.time);\n        testgpu = abs(reducedtgpu - mininput) &lt; T(100.0) * (XLoop.epsilon);\n\n        if (!testgpu)\n        {\n            char buffer[256]; sprintf(buffer, \"%e\", abs(reducedtgpu - mininput));\n            std::string str(buffer);\n            log(\"\\t\\t GPU test failed! : Expected=\" + std::to_string(mininput) + \";  Reduced=\" + std::to_string(reducedtgpu) + \";  error=\" + str);\n        }\n\n        if (abs(reducedtgpu - reducedt) &gt; T(100.0) * (XLoop.epsilon))\n        {\n            char buffer[256]; sprintf(buffer, \"%e\", abs(reducedtgpu - reducedt));\n            std::string str(buffer);\n            log(\"\\t\\t CPU vs GPU test failed! : Expected=\" + std::to_string(reducedt) + \";  Reduced=\" + std::to_string(reducedtgpu) + \";  error=\" + str);\n        }\n\n        test = test &amp;&amp; testgpu;\n    }\n\n\n    return test;\n}\ntemplate bool reductiontest&lt;float&gt;(Param XParam, Model&lt;float&gt; XModel, Model&lt;float&gt; XModel_g);\ntemplate bool reductiontest&lt;double&gt;(Param XParam, Model&lt;double&gt; XModel, Model&lt;double&gt; XModel_g);\n\ntemplate&lt;class T&gt; bool CPUGPUtest(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    bool test = true;\n\n    T initdepth = T(0.1);\n    T testamp = T(1.0);\n\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    // for flux reconstruction the loop overlap the right(or top for the y direction) halo\n    dim3 blockDimKX(XParam.blkwidth + XParam.halowidth, XParam.blkwidth, 1);\n    dim3 blockDimKY(XParam.blkwidth, XParam.blkwidth + XParam.halowidth, 1);\n\n    InitArrayBUQ(XParam, XModel.blocks, T(0.0), XModel.zb);\n    InitArrayBUQ(XParam, XModel.blocks, T(initdepth), XModel.evolv.zs);\n    InitArrayBUQ(XParam, XModel.blocks, T(initdepth), XModel.evolv.h);\n    InitArrayBUQ(XParam, XModel.blocks, T(0.0), XModel.evolv.u);\n    InitArrayBUQ(XParam, XModel.blocks, T(0.0), XModel.evolv.v);\n\n\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, T(0.0), XModel_g.zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    // Create some usefull vectors\n    std::string evolvst[4] = { \"h\",\"zs\",\"u\",\"v\" };\n\n    std::vector&lt;std::string&gt; evolvVar;\n\n    for (int nv = 0; nv &lt; 4; nv++)\n    {\n        evolvVar.push_back(evolvst[nv]);\n    }\n\n\n    // Check fillhalo function\n\n    // fill with all evolv array with random value\n    /*\n    fillrandom(XParam, XModel.blocks, XModel.evolv.zs);\n    fillrandom(XParam, XModel.blocks, XModel.evolv.h);\n    fillrandom(XParam, XModel.blocks, XModel.evolv.u);\n    fillrandom(XParam, XModel.blocks, XModel.evolv.v);\n    */\n    fillgauss(XParam, XModel.blocks, testamp, XModel.evolv.zs);\n    fillgauss(XParam, XModel.blocks, testamp, XModel.evolv.h);\n    fillgauss(XParam, XModel.blocks, T(0.5 * testamp), XModel.evolv.u);\n    fillgauss(XParam, XModel.blocks, T(0.5 * testamp), XModel.evolv.v);\n\n    //copy to GPU\n    CopytoGPU(XParam.nblkmem, XParam.blksize, XModel.evolv, XModel_g.evolv);\n\n    //============================================\n    //  Fill the halo for gradient reconstruction\n    fillHalo(XParam, XModel.blocks, XModel.evolv, XModel.zb);\n    fillHaloGPU(XParam, XModel_g.blocks, XModel_g.evolv, XModel_g.zb);\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, evolvVar, true);\n\n    //============================================\n    //perform gradient reconstruction\n    //gradientCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.zb);\n    //gradientGPU(XParam, XModel_g.blocks, XModel_g.evolv, XModel_g.grad, XModel.zb);\n\n\n    // CPU gradients\n    std::thread t0(&amp;gradientC&lt;T&gt;, XParam, XModel.blocks, XModel.evolv.h, XModel.grad.dhdx, XModel.grad.dhdy);\n    std::thread t1(&amp;gradientC&lt;T&gt;, XParam, XModel.blocks, XModel.evolv.zs, XModel.grad.dzsdx, XModel.grad.dzsdy);\n    std::thread t2(&amp;gradientC&lt;T&gt;, XParam, XModel.blocks, XModel.evolv.u, XModel.grad.dudx, XModel.grad.dudy);\n    std::thread t3(&amp;gradientC&lt;T&gt;, XParam, XModel.blocks, XModel.evolv.v, XModel.grad.dvdx, XModel.grad.dvdy);\n\n    t0.join();\n    t1.join();\n    t2.join();\n    t3.join();\n\n    //GPU gradients\n\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XModel_g.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel_g.evolv.h, XModel_g.grad.dhdx, XModel_g.grad.dhdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XModel_g.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel_g.evolv.zs, XModel_g.grad.dzsdx, XModel_g.grad.dzsdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XModel_g.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel_g.evolv.u, XModel_g.grad.dudx, XModel_g.grad.dudy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XModel_g.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel_g.evolv.v, XModel_g.grad.dvdx, XModel_g.grad.dvdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    std::string gradst[8] = { \"dhdx\",\"dzsdx\",\"dudx\",\"dvdx\",\"dhdy\",\"dzsdy\",\"dudy\",\"dvdy\" };\n\n    std::vector&lt;std::string&gt; gradVar;\n\n    for (int nv = 0; nv &lt; 8; nv++)\n    {\n        gradVar.push_back(gradst[nv]);\n    }\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, gradVar, false);\n\n    // Gradient in Halo\n\n    // CPU\n    gradientHalo(XParam, XModel.blocks, XModel.evolv.h, XModel.grad.dhdx, XModel.grad.dhdy);\n    gradientHalo(XParam, XModel.blocks, XModel.evolv.zs, XModel.grad.dzsdx, XModel.grad.dzsdy);\n    gradientHalo(XParam, XModel.blocks, XModel.evolv.u, XModel.grad.dudx, XModel.grad.dudy);\n    gradientHalo(XParam, XModel.blocks, XModel.evolv.v, XModel.grad.dvdx, XModel.grad.dvdy);\n\n    // GPU\n    gradientHaloGPU(XParam, XModel_g.blocks, XModel_g.evolv.h, XModel_g.grad.dhdx, XModel_g.grad.dhdy);\n    gradientHaloGPU(XParam, XModel_g.blocks, XModel_g.evolv.zs, XModel_g.grad.dzsdx, XModel_g.grad.dzsdy);\n    gradientHaloGPU(XParam, XModel_g.blocks, XModel_g.evolv.u, XModel_g.grad.dudx, XModel_g.grad.dudy);\n    gradientHaloGPU(XParam, XModel_g.blocks, XModel_g.evolv.v, XModel_g.grad.dvdx, XModel_g.grad.dvdy);\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, gradVar, true);\n\n    //============================================\n    // Kurganov scheme\n\n    std::string fluxst[8] = { \"Fhu\",\"Su\",\"Fqux\",\"Fqvx\",\"Fhv\",\"Sv\",\"Fqvy\",\"Fquy\" };\n\n    std::vector&lt;std::string&gt; fluxVar;\n\n    for (int nv = 0; nv &lt; 8; nv++)\n    {\n        fluxVar.push_back(fluxst[nv]);\n    }\n\n    updateKurgXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n\n    //GPU part\n    updateKurgXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evolv, XModel_g.grad, XModel_g.flux, XModel_g.time.dtmax, XModel_g.zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    // Y- direction\n    updateKurgYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n\n    updateKurgYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evolv, XModel_g.grad, XModel_g.flux, XModel_g.time.dtmax, XModel_g.zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, fluxVar, false);\n\n\n    fillHalo(XParam, XModel.blocks, XModel.flux);\n    fillHaloGPU(XParam, XModel_g.blocks, XModel_g.flux);\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, fluxVar, true);\n\n\n    //============================================\n    // Update step\n    std::string advst[3] = { \"dh\",\"dhu\",\"dhv\" };\n\n    std::vector&lt;std::string&gt; advVar;\n\n    for (int nv = 0; nv &lt; 3; nv++)\n    {\n        advVar.push_back(advst[nv]);\n    }\n    updateEVCPU(XParam, XModel.blocks, XModel.evolv, XModel.flux, XModel.adv);\n    updateEVGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evolv, XModel_g.flux, XModel_g.adv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, advVar, false);\n\n    //============================================\n    // Advance step\n    std::string evost[4] = { \"zso\",\"ho\",\"uo\",\"vo\" };\n\n    std::vector&lt;std::string&gt; evoVar;\n\n    for (int nv = 0; nv &lt; 4; nv++)\n    {\n        evoVar.push_back(evost[nv]);\n    }\n    AdvkernelCPU(XParam, XModel.blocks, T(0.0005), XModel.zb, XModel.evolv, XModel.adv, XModel.evolv_o);\n    AdvkernelGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, T(0.0005), XModel_g.zb, XModel_g.evolv, XModel_g.adv, XModel_g.evolv_o);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, evoVar, false);\n\n    //============================================\n    // Bottom friction\n\n    bottomfrictionCPU(XParam, XModel.blocks, T(0.5), XModel.cf, XModel.evolv_o);\n\n    bottomfrictionGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, T(0.5), XModel_g.cf, XModel_g.evolv_o);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, evoVar, false);\n\n\n    //============================================\n    // Repeat the full test\n    Loop&lt;T&gt; XLoop;\n    Loop&lt;T&gt; XLoop_g;\n\n    XParam.endtime = utils::min(0.5 * (XParam.ymax - XParam.yo), 0.5 * (XParam.xmax - XParam.xo)) / (sqrt(XParam.g * (testamp + initdepth)));\n    XParam.outputtimestep = XParam.endtime / 10.0;\n\n\n    XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    XLoop.totaltime = 0.0;\n\n    //InitSave2Netcdf(XParam, XModel);\n    XLoop.nextoutputtime = XParam.outputtimestep;\n    XLoop.dtmax = initdt(XParam, XLoop, XModel);\n\n    XLoop_g.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop_g.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop_g.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    XLoop_g.totaltime = 0.0;\n\n    //InitSave2Netcdf(XParam, XModel);\n    XLoop_g.nextoutputtime = XLoop.nextoutputtime;\n    XLoop_g.dtmax = XLoop.dtmax;\n\n    std::string outvi[18] = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"ho\", \"vo\", \"uo\", \"cf\" };\n\n    std::vector&lt;std::string&gt; outv;\n\n    for (int nv = 0; nv &lt; 18; nv++)\n    {\n        outv.push_back(outvi[nv]);\n    }\n\n\n    InitArrayBUQ(XParam, XModel.blocks, T(0.0), XModel.evolv.u);\n    InitArrayBUQ(XParam, XModel.blocks, T(0.0), XModel.evolv.v);\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, T(0.0), XModel_g.evolv.u);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, T(0.0), XModel_g.evolv.v);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    Forcing&lt;float&gt; XForcing;\n    while (XLoop.totaltime &lt; XParam.endtime)\n    {\n        FlowGPU(XParam, XLoop_g, XForcing, XModel_g);\n        FlowCPU(XParam, XLoop, XForcing, XModel);\n\n        XLoop.totaltime = XLoop.totaltime + XLoop.dt;\n        XLoop_g.totaltime = XLoop_g.totaltime + XLoop_g.dt;\n        if (XLoop.nextoutputtime - XLoop.totaltime &lt;= XLoop.dt * T(0.00001) &amp;&amp; XParam.outputtimestep &gt; 0.0)\n        {\n            CompareCPUvsGPU(XParam, XModel, XModel_g, outv, false);\n            XLoop.nextoutputtime = min(XLoop.nextoutputtime + XParam.outputtimestep, XParam.endtime);\n            XLoop_g.nextoutputtime = XLoop.nextoutputtime;\n        }\n    }\n\n\n    return test;\n}\n\ntemplate &lt;class T&gt; T ValleyBathy(T x, T y, T slope, T center)\n{\n\n\n    T bathy;\n\n    bathy = (abs(x - center) + y) * slope;\n\n\n    return bathy;\n}\n\n\ntemplate &lt;class T&gt; T ThackerBathy(T x, T y, T L, T D)\n{\n\n\n    T bathy = D * ((x * x + y * y) / (L * L) - 1.0);\n\n\n    return bathy;\n}\n\ntemplate &lt;class T&gt; bool ThackerLakeAtRest(Param XParam, T zsinit)\n{\n    bool test = true;\n    // Make a Parabolic bathy\n\n    auto modeltype = XParam.doubleprecision &lt; 1 ? float() : double();\n    Model&lt;decltype(modeltype)&gt; XModel; // For CPU pointers\n    Model&lt;decltype(modeltype)&gt; XModel_g; // For GPU pointers\n\n    Forcing&lt;float&gt; XForcing;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    XForcing.Bathy.push_back(bathy);\n\n    // initialise forcing bathymetry to 0\n\n    T Lo = T(2500.0);\n    T Do = T(1.0);\n\n    T x, y;\n\n\n\n    XForcing.Bathy[0].xo = -4000.0;\n    XForcing.Bathy[0].yo = -4000.0;\n\n    XForcing.Bathy[0].xmax = 4000.0;\n    XForcing.Bathy[0].ymax = 4000.0;\n    XForcing.Bathy[0].nx = 64;\n    XForcing.Bathy[0].ny = 64;\n\n    XForcing.Bathy[0].dx = 126.0;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            x = T(XForcing.Bathy[0].xo + i * XForcing.Bathy[0].dx);\n            y = T(XForcing.Bathy[0].yo + j * XForcing.Bathy[0].dx);\n            XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = float(ThackerBathy(x, y, Lo, Do));\n        }\n    }\n\n    // Overrule whatever may be set in the param file\n    XParam.xmax = XForcing.Bathy[0].xmax;\n    XParam.ymax = XForcing.Bathy[0].ymax;\n    XParam.xo = XForcing.Bathy[0].xo;\n    XParam.yo = XForcing.Bathy[0].yo;\n\n    XParam.dx = XForcing.Bathy[0].dx;\n\n    XParam.zsinit = zsinit;\n    XParam.endtime = 1390.0;\n\n    XParam.outputtimestep = XParam.endtime;\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    MainLoop(XParam, XForcing, XModel, XModel_g);\n\n\n    // Check Lake at rest state?\n    // all velocities should be very small\n    T smallvel = T(1e-6);\n    int i;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                i = memloc(XParam, ix, iy, ib);\n                if (abs(XModel.evolv.u[i]) &gt; smallvel || abs(XModel.evolv.v[i]) &gt; smallvel)\n                {\n                    log(\"Lake at rest state not acheived!\");\n                    test = false;\n                }\n            }\n        }\n    }\n\n    return test;\n}\ntemplate bool ThackerLakeAtRest&lt;float&gt;(Param XParam, float zsinit);\ntemplate bool ThackerLakeAtRest&lt;double&gt;(Param XParam, double zsinit);\n\n\n\ntemplate &lt;class T&gt; bool RiverVolumeAdapt(Param XParam, T maxslope)\n{\n    //T maxslope = 0.45; // tthe mass conservation is better with smaller slopes \n\n    bool UnitestA, UnitestB, UnitestC, UnitestD;\n    bool ctofA, ctofB, ctofC, ctofD;\n    bool ftocA, ftocB, ftocC, ftocD;\n\n    std::string details;\n\n    XParam.minlevel = 1;\n    XParam.maxlevel = 1;\n    XParam.initlevel = 1;\n\n    XParam.ForceMassConserve = true;\n\n\n    UnitestA=RiverVolumeAdapt(XParam, maxslope, false, false);\n    UnitestB=RiverVolumeAdapt(XParam, maxslope, true, false);\n    UnitestC=RiverVolumeAdapt(XParam, maxslope, false, true);\n    UnitestD=RiverVolumeAdapt(XParam, maxslope, true, true);\n\n\n    if (UnitestA &amp;&amp; UnitestB &amp;&amp; UnitestC &amp;&amp; UnitestD)\n    {\n        log(\"River Volume Conservation Test: Uniform mesh: Success\");\n    }\n    else\n    {\n        log(\"River Volume Conservation Test: Uniform mesh: Failed\");\n        details = UnitestA ? \"successful\" : \"failed\";\n        log(\"\\t Uniform mesh A :\" + details);\n        details = UnitestB ? \"successful\" : \"failed\";\n        log(\"\\t Uniform mesh B :\" + details);\n        details = UnitestC ? \"successful\" : \"failed\";\n        log(\"\\t Uniform mesh C :\" + details);\n        details = UnitestD ? \"successful\" : \"failed\";\n        log(\"\\t Uniform mesh D :\" + details);\n    }\n\n    XParam.minlevel = 0;\n    XParam.maxlevel = 1;\n    XParam.initlevel = 0;\n\n    //Fine to coarse\n    // Change arg 1 and 2 if the slope is changed\n    XParam.AdaptCrit = \"Inrange\";\n    XParam.Adapt_arg1 = \"28.0\";\n    XParam.Adapt_arg2 = \"40.0\";\n    XParam.Adapt_arg3 = \"zb\";\n\n    ftocA = RiverVolumeAdapt(XParam, maxslope, false, false);\n    ftocB = RiverVolumeAdapt(XParam, maxslope, true, false);\n    ftocC = RiverVolumeAdapt(XParam, maxslope, false, true);\n    ftocD = RiverVolumeAdapt(XParam, maxslope, true, true);\n    if (ftocA &amp;&amp; ftocB &amp;&amp; ftocC &amp;&amp; ftocD)\n    {\n        log(\"River Volume Conservation Test: Flow from fine to coarse adapted mesh: Success\");\n    }\n    else\n    {\n        log(\"River Volume Conservation Test: Flow from fine to coarse adapted mesh: Failed\");\n        details = ftocA ? \"successful\" : \"failed\";\n        log(\"\\t Flow from fine to coarse adapted mesh A :\" + details);\n        details = ftocB ? \"successful\" : \"failed\";\n        log(\"\\t Flow from fine to coarse adapted mesh B :\" + details);\n        details = ftocC ? \"successful\" : \"failed\";\n        log(\"\\t Flow from fine to coarse adapted mesh C :\" + details);\n        details = ftocD ? \"successful\" : \"failed\";\n        log(\"\\t Flow from fine to coarse adapted mesh D :\" + details);\n    }\n\n    //coarse to fine\n    // Change arg 1 and 2 if the slope is changed\n    XParam.AdaptCrit = \"Inrange\";\n    XParam.Adapt_arg1 = \"0.0\";\n    XParam.Adapt_arg2 = \"2.0\";\n    XParam.Adapt_arg3 = \"zb\";\n\n    ctofA = RiverVolumeAdapt(XParam, maxslope, false, false);\n    ctofB = RiverVolumeAdapt(XParam, maxslope, true, false);\n    ctofC = RiverVolumeAdapt(XParam, maxslope, false, true);\n    ctofD = RiverVolumeAdapt(XParam, maxslope, true, true);\n    if (ctofA &amp;&amp; ctofB &amp;&amp; ctofC &amp;&amp; ctofD)\n    {\n        log(\"River Volume Conservation Test: Flow from coarse to fine adapted mesh: Success\");\n    }\n    else\n    {\n        log(\"River Volume Conservation Test: Flow from coarse to fine adapted: Failed\");\n        details = ctofA ? \"successful\" : \"failed\";\n        log(\"\\t Flow from coarse to fine adapted mesh A :\" + details);\n        details = ctofB ? \"successful\" : \"failed\";\n        log(\"\\t Flow from coarse to fine adapted mesh B :\" + details);\n        details = ctofC ? \"successful\" : \"failed\";\n        log(\"\\t Flow from coarse to fine adapted mesh C :\" + details);\n        details = ctofD ? \"successful\" : \"failed\";\n        log(\"\\t Flow from coarse to fine adapted mesh D :\" + details);\n\n    }\n\n    return (UnitestA * UnitestB * UnitestC * UnitestD * ctofA * ctofB * ctofC * ctofD * ftocA * ftocB * ftocC * ftocD);\n}\n\n\ntemplate &lt;class T&gt; bool RiverVolumeAdapt(Param XParam, T slope, bool bottop, bool flip)\n{\n    //bool test = true;\n    //\n\n    auto modeltype = XParam.doubleprecision &lt; 1 ? float() : double();\n    Model&lt;decltype(modeltype)&gt; XModel; // For CPU pointers\n    Model&lt;decltype(modeltype)&gt; XModel_g; // For GPU pointers\n\n    Forcing&lt;float&gt; XForcing;\n\n    XForcing = MakValleyBathy(XParam, slope, bottop, flip);\n\n    T x, y;\n    T center = T(10.5);\n\n    float maxtopo = std::numeric_limits&lt;float&gt;::min();\n    float mintopo = std::numeric_limits&lt;float&gt;::max();\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            maxtopo = max(XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx], maxtopo);\n            mintopo = min(XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx], mintopo);\n        }\n    }\n\n\n\n    // Overrule whatever is set in the river forcing\n    T Q = T(1.0);\n\n    double upstream = !flip ? 24.0 : 8;\n    double riverx = !bottop ? upstream : center;\n    double rivery = !bottop ? center : upstream;\n\n    //Create a temporary file with river fluxes\n    std::ofstream river_file(\n        \"testriver.tmp\", std::ios_base::out | std::ios_base::trunc);\n    river_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file &lt;&lt; \"3600.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file.close(); //destructor implicitly does it\n\n    River thisriver;\n    thisriver.Riverflowfile = \"testriver.tmp\";\n    thisriver.xstart = riverx - 1.0;\n    thisriver.xend = riverx + 1.0;\n    thisriver.ystart = rivery - 1.0;\n    thisriver.yend = rivery + 1.0;\n\n    XForcing.rivers.push_back(thisriver);\n\n\n    XForcing.rivers[0].flowinput = readFlowfile(XForcing.rivers[0].Riverflowfile, XParam.reftime);\n\n\n    // Overrule whatever may be set in the param file\n    XParam.xmax = XForcing.Bathy[0].xmax;\n    XParam.ymax = XForcing.Bathy[0].ymax;\n    XParam.xo = XForcing.Bathy[0].xo;\n    XParam.yo = XForcing.Bathy[0].yo;\n\n    XParam.dx = XForcing.Bathy[0].dx;\n\n    XParam.zsinit = mintopo + 0.5;// Had a small amount of water to avoid a huge first step that would surely break the setup\n    XParam.endtime = 20.0;\n\n    XParam.outputtimestep = XParam.endtime;\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n    T initVol = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.delta, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                initVol = initVol + T(XModel.evolv.h[i]) * delta * delta;\n            }\n        }\n    }\n\n\n    MainLoop(XParam, XForcing, XModel, XModel_g);\n\n    T TheoryInput = Q * XParam.endtime;\n\n\n    T SimulatedVolume = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.delta, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                SimulatedVolume = SimulatedVolume + XModel.evolv.h[i] * delta * delta;\n            }\n        }\n    }\n\n    SimulatedVolume = SimulatedVolume - initVol;\n\n    T error = abs(SimulatedVolume - TheoryInput);\n\n    return error / TheoryInput &lt; 0.05;\n\n}\n\n\n\ntemplate &lt;class T&gt; bool testboundaries(Param XParam, T maxslope)\n{\n    //T maxslope = 0.45; // the mass conservation is better with smaller slopes \n\n    bool Wall_B;// , Wall_R, Wall_L, Wall_T;\n    //bool ctofA, ctofB, ctofC, ctofD;\n    //bool ftocA, ftocB, ftocC, ftocD;\n\n\n    std::string details;\n    int Bound_type;\n\n\n    XParam.GPUDEVICE = 0;\n    maxslope = 0.0;\n    //Dir = 3;\n    Bound_type = -1;\n    Wall_B = RiverOnBoundary(XParam, maxslope, 3, Bound_type);\n    //Wall_R = RiverOnBoundary(XParam, maxslope, 0, 0);\n    //Wall_L = RiverOnBoundary(XParam, maxslope, 1, 0);\n    //Wall_T = RiverOnBoundary(XParam, maxslope, 2, 0);\n    /*\n\n    if (UnitestA &amp;&amp; UnitestB &amp;&amp; UnitestC &amp;&amp; UnitestD)\n    {\n        log(\"River Volume Conservation Test: Uniform mesh: Success\");\n    }\n    else\n    {\n        log(\"River Volume Conservation Test: Uniform mesh: Failed\");\n        details = UnitestA ? \"successful\" : \"failed\";\n        log(\"\\t Uniform mesh A :\" + details);\n        details = UnitestB ? \"successful\" : \"failed\";\n        log(\"\\t Uniform mesh B :\" + details);\n        details = UnitestC ? \"successful\" : \"failed\";\n        log(\"\\t Uniform mesh C :\" + details);\n        details = UnitestD ? \"successful\" : \"failed\";\n        log(\"\\t Uniform mesh D :\" + details);\n    }\n\n    XParam.minlevel = 0;\n    XParam.maxlevel = 1;\n    XParam.initlevel = 0;\n\n    //Fine to coarse\n    // Change arg 1 and 2 if the slope is changed\n    XParam.AdaptCrit = \"Inrange\";\n    XParam.Adapt_arg1 = \"28.0\";\n    XParam.Adapt_arg2 = \"40.0\";\n    XParam.Adapt_arg3 = \"zb\";\n\n    ftocA = RiverVolumeAdapt(XParam, maxslope, false, false);\n    ftocB = RiverVolumeAdapt(XParam, maxslope, true, false);\n    ftocC = RiverVolumeAdapt(XParam, maxslope, false, true);\n    ftocD = RiverVolumeAdapt(XParam, maxslope, true, true);\n    if (ftocA &amp;&amp; ftocB &amp;&amp; ftocC &amp;&amp; ftocD)\n    {\n        log(\"River Volume Conservation Test: Flow from fine to coarse adapted mesh: Success\");\n    }\n    else\n    {\n        log(\"River Volume Conservation Test: Flow from fine to coarse adapted mesh: Failed\");\n        details = ftocA ? \"successful\" : \"failed\";\n        log(\"\\t Flow from fine to coarse adapted mesh A :\" + details);\n        details = ftocB ? \"successful\" : \"failed\";\n        log(\"\\t Flow from fine to coarse adapted mesh B :\" + details);\n        details = ftocC ? \"successful\" : \"failed\";\n        log(\"\\t Flow from fine to coarse adapted mesh C :\" + details);\n        details = ftocD ? \"successful\" : \"failed\";\n        log(\"\\t Flow from fine to coarse adapted mesh D :\" + details);\n    }\n\n    //coarse to fine\n    // Change arg 1 and 2 if the slope is changed\n    XParam.AdaptCrit = \"Inrange\";\n    XParam.Adapt_arg1 = \"0.0\";\n    XParam.Adapt_arg2 = \"2.0\";\n    XParam.Adapt_arg3 = \"zb\";\n\n    ctofA = RiverVolumeAdapt(XParam, maxslope, false, false);\n    ctofB = RiverVolumeAdapt(XParam, maxslope, true, false);\n    ctofC = RiverVolumeAdapt(XParam, maxslope, false, true);\n    ctofD = RiverVolumeAdapt(XParam, maxslope, true, true);\n    if (ctofA &amp;&amp; ctofB &amp;&amp; ctofC &amp;&amp; ctofD)\n    {\n        log(\"River Volume Conservation Test: Flow from coarse to fine adapted mesh: Success\");\n    }\n    else\n    {\n        log(\"River Volume Conservation Test: Flow from coarse to fine adapted: Failed\");\n        details = ctofA ? \"successful\" : \"failed\";\n        log(\"\\t Flow from coarse to fine adapted mesh A :\" + details);\n        details = ctofB ? \"successful\" : \"failed\";\n        log(\"\\t Flow from coarse to fine adapted mesh B :\" + details);\n        details = ctofC ? \"successful\" : \"failed\";\n        log(\"\\t Flow from coarse to fine adapted mesh C :\" + details);\n        details = ctofD ? \"successful\" : \"failed\";\n        log(\"\\t Flow from coarse to fine adapted mesh D :\" + details);\n    }*/\n\n    //return (UnitestA * UnitestB * UnitestC * UnitestD * ctofA * ctofB * ctofC * ctofD * ftocA * ftocB * ftocC * ftocD);\n    return(Wall_B);\n}\n\n\ntemplate &lt;class T&gt; bool RiverOnBoundary(Param XParam, T slope, int Dir, int Bound_type)\n{\n    //bool test = true;\n    // Make a Parabolic bathy\n\n    //Param XParam;\n    XParam.GPUDEVICE = -1;\n\n    auto modeltype = XParam.doubleprecision &lt; 1 ? float() : double();\n    Model&lt;decltype(modeltype)&gt; XModel; // For CPU pointers\n    Model&lt;decltype(modeltype)&gt; XModel_g; // For GPU pointers\n\n    Forcing&lt;float&gt; XForcing;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    float* dummybathy;\n\n    //Boundary conditions\n    XForcing.top.type = 0;\n    XForcing.bot.type = 0;\n    XForcing.right.type = 0;\n    XForcing.left.type = 0;\n\n    //Physical wall boundary condition\n    bool PhysWall = 0;\n    if (Bound_type == -1)\n    {\n        PhysWall = 1;\n        Bound_type = 0;\n    }\n\n    if (Dir == 0) //To right\n    {\n        XForcing.right.type = Bound_type;\n        XForcing.top.type = 0;\n    }\n    else if (Dir == 1) //To left\n    {\n        XForcing.left.type = Bound_type;\n        XForcing.bot.type = 0;\n    }\n    else if (Dir == 2) //To top\n    {\n        XForcing.top.type = Bound_type;\n        XForcing.left.type = 0;\n    }\n    else if (Dir == 3) //To bottom\n    {\n        XForcing.bot.type = Bound_type;\n        XForcing.right.type = 0;\n    }\n\n    XForcing.Bathy.push_back(bathy);\n\n    XForcing.Bathy[0].xo = 0.0;\n    XForcing.Bathy[0].yo = 0.0;\n    XForcing.Bathy[0].xmax = 31.0;\n    XForcing.Bathy[0].ymax = 31.0;\n    XForcing.Bathy[0].nx = 32;\n    XForcing.Bathy[0].ny = 32;\n\n    XForcing.Bathy[0].dx = 1.0;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n    T x, y;\n    T center = T(31.0);\n\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, dummybathy);\n\n\n    //float maxtopo = std::numeric_limits&lt;float&gt;::min();\n    float mintopo = 1000000000000.0f;\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            x = T(XForcing.Bathy[0].xo + i * XForcing.Bathy[0].dx);\n            y = T(XForcing.Bathy[0].yo + j * XForcing.Bathy[0].dx);\n\n\n            dummybathy[i + j * XForcing.Bathy[0].nx] = float(ValleyBathy(y, x, slope, center));\n\n            //Add physical walls\n            if (PhysWall == 1)\n            {\n                //if (j &lt; 3)\n                //{\n                //  dummybathy[i + j * XForcing.Bathy[0].nx] = 100.0;\n                //}\n                if (j &gt; XForcing.Bathy[0].ny - 3)\n                {\n                    dummybathy[i + j * XForcing.Bathy[0].nx] = 100.0;\n                }\n                if (i &gt; XForcing.Bathy[0].nx - 3)\n                {\n                    dummybathy[i + j * XForcing.Bathy[0].nx] = 100.0;\n                }\n                if (i &lt; 17)\n                {\n                    dummybathy[i + j * XForcing.Bathy[0].nx] = 1000.0;\n                }\n            }\n\n            mintopo = utils::min(dummybathy[i + j * XForcing.Bathy[0].nx], mintopo);\n            //maxtopo = max(dummybathy[i + j * XForcing.Bathy[0].nx], maxtopo);\n\n        }\n    }\n\n    // Flip or rotate the bathy according to what is requested\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            if (Dir == 1) //left wise\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = dummybathy[i + j * XForcing.Bathy[0].nx];\n            }\n            else if (Dir == 0) //right wise\n            {\n                XForcing.Bathy[0].val[(XForcing.Bathy[0].nx - 1 - i) + j * XForcing.Bathy[0].nx] = dummybathy[i + j * XForcing.Bathy[0].nx];\n            }\n            else if (Dir == 3) //bottom wise\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = dummybathy[j + i * XForcing.Bathy[0].nx];\n            }\n            else if (Dir == 2) //top wise\n            {\n                XForcing.Bathy[0].val[i + (XForcing.Bathy[0].ny - 1 - j) * XForcing.Bathy[0].nx] = dummybathy[j + i * XForcing.Bathy[0].nx];\n            }\n        }\n    }\n\n    free(dummybathy);\n\n    // Overrule whatever is set in the river forcing\n    T Q = T(1.0);\n\n    double riverx = (Dir == 0 | Dir == 2) ? 6.0 : 25.0; //Dir=1 =&gt;leftward\n    double rivery = (Dir == 2 | Dir == 1) ? 6.0 : 25.0; //Dir=2 =&gt;topward\n\n    //Create a temporary file with river fluxes\n    std::ofstream river_file(\n        \"testriver.tmp\", std::ios_base::out | std::ios_base::trunc);\n    river_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file &lt;&lt; \"3600.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file.close(); //destructor implicitly does it\n\n    River thisriver;\n    thisriver.Riverflowfile = \"testriver.tmp\";\n    thisriver.xstart = riverx - 1.0;\n    thisriver.xend = riverx + 1.0;\n    thisriver.ystart = rivery - 1.0;\n    thisriver.yend = rivery + 1.0;\n\n    XForcing.rivers.push_back(thisriver);\n\n\n    XForcing.rivers[0].flowinput = readFlowfile(XForcing.rivers[0].Riverflowfile, XParam.reftime);\n\n\n    // Overrule whatever may be set in the param file\n    XParam.xmax = XForcing.Bathy[0].xmax;\n    XParam.ymax = XForcing.Bathy[0].ymax;\n    XParam.xo = XForcing.Bathy[0].xo;\n    XParam.yo = XForcing.Bathy[0].yo;\n\n    XParam.dx = XForcing.Bathy[0].dx;\n\n    XParam.zsinit = mintopo + 0.5;// Had a small amount of water to avoid a huge first step that would surely break the setup\n    //XParam.zsoffset = 0.2;\n    XParam.endtime = 50.0;\n    XParam.dtinit = 0.1;\n    XParam.mask = 999.0;\n    XParam.outishift = 0;\n    XParam.outjshift = 0;\n    XParam.ForceMassConserve = true;\n\n\n    XParam.outputtimestep = 10.0;// XParam.endtime;\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    InitSave2Netcdf(XParam, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n    T initVol = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.delta, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                initVol = initVol + XModel.evolv.h[i] * delta * delta;\n            }\n        }\n    }\n\n\n    MainLoop(XParam, XForcing, XModel, XModel_g);\n\n    T TheoryInput = Q * (T)XParam.endtime;\n\n\n    T SimulatedVolume = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.delta, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                SimulatedVolume = SimulatedVolume + XModel.evolv.h[i] * delta * delta;\n            }\n        }\n    }\n\n\n    printf(\"End Volume : %f \\n\", SimulatedVolume);\n    printf(\"Init Volume : %f \\n\", initVol);\n\n    SimulatedVolume = SimulatedVolume - initVol;\n\n    printf(\"End Volume - Init volume : %f \\n\", SimulatedVolume);\n\n    T error = abs(SimulatedVolume - TheoryInput);\n\n    printf(\"error : %f \\n\", error);\n    printf(\"Theory input : %f \\n\", TheoryInput);\n    printf(\"return : %f \\n\", (error / TheoryInput));\n\n\n    return error / TheoryInput &lt; 0.01;\n\n}\n\n\n\ntemplate &lt;class T&gt; bool LakeAtRest(Param XParam, Model&lt;T&gt; XModel)\n{\n    T epsi = T(1e-5);\n    int ib;\n\n    bool test = true;\n\n\n    Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n\n    fillHaloC(XParam, XModel.blocks, XModel.zb);\n\n    gradientC(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    gradientHalo(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n\n    refine_linear(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    gradientHalo(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n\n\n\n\n    //============================================\n    // Predictor step in reimann solver\n    //============================================\n\n    //============================================\n    //  Fill the halo for gradient reconstruction\n    fillHalo(XParam, XModel.blocks, XModel.evolv, XModel.zb);\n\n    //============================================\n    // Reset DTmax\n    InitArrayBUQ(XParam, XModel.blocks, XLoop.hugeposval, XModel.time.dtmax);\n\n    //============================================\n    // Calculate gradient for evolving parameters\n    gradientCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.zb);\n\n    //============================================\n    // Flux and Source term reconstruction\n    // X- direction\n    //updateKurgXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n    UpdateButtingerXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n    //AddSlopeSourceXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n\n    // Y- direction\n    //updateKurgYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n    UpdateButtingerYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n    //AddSlopeSourceYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n\n    //============================================\n    // Fill Halo for flux from fine to coarse\n    fillHalo(XParam, XModel.blocks, XModel.flux);\n\n    // Do we need to check also before fill halo part?\n\n    // Check Fhu and Fhv (they should be zero)\n    int i, iright;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XModel.blocks.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                i = memloc(XParam, ix, iy, ib);\n                iright = memloc(XParam, ix + 1, iy, ib);\n                //ileft = memloc(XParam, ix - 1, iy, ib);\n                //itop = memloc(XParam, ix, iy + 1, ib);\n                //ibot = memloc(XParam, ix, iy - 1, ib);\n\n                if (abs(XModel.flux.Fhu[i]) &gt; epsi)\n                {\n                    log(\"Fhu is not zero. Lake at rest not preserved!!!\");\n                    test = false;\n                }\n\n                if (abs(XModel.flux.Fhv[i]) &gt; epsi)\n                {\n                    log(\"Fhv is not zero. Lake at rest not preserved!!!\");\n                    test = false;\n                }\n\n                T dhus = (XModel.flux.Fqux[i] - XModel.flux.Su[iright]);\n                if (abs(dhus) &gt; epsi)\n                {\n                    test = false;\n\n                    log(\"dhu is not zero. Lake at rest not preserved!!!\");\n\n\n                    printf(\"Fhu[i]=%f\\n\", XModel.flux.Fhu[i]);\n\n                    printf(\"Fqux[i]=%f; Su[iright]=%f; Diff=%f \\n\", XModel.flux.Fqux[i], XModel.flux.Su[iright], (XModel.flux.Fqux[i] - XModel.flux.Su[iright]));\n\n                    printf(\" At i: (ib=%d; ix=%d; iy=%d)\\n\", ib, ix, iy);\n                    testButtingerX(XParam, ib, ix, iy, XModel);\n\n                    printf(\" At iright: (ib=%d; ix=%d; iy=%d)\\n\", ib, ix + 1, iy);\n                    testButtingerX(XParam, ib, ix + 1, iy, XModel);\n\n                }\n\n            }\n        }\n    }\n\n\n    if (!test)\n    {\n        copyID2var(XParam, XModel.blocks, XModel.flux.Fhu);\n        copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.LeftBot, XModel.grad.dhdx);\n        copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.LeftTop, XModel.grad.dhdy);\n        copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.TopLeft, XModel.grad.dzsdx);\n        copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.TopRight, XModel.grad.dzsdy);\n        copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.RightTop, XModel.grad.dudx);\n        copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.RightBot, XModel.grad.dudy);\n        copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.BotRight, XModel.grad.dvdx);\n        copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.BotLeft, XModel.grad.dvdy);\n\n        creatncfileBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, XModel.blocks.outZone[0]);\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"blockID\", 3, XModel.flux.Fhu, XModel.blocks.outZone[0]);\n\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"LeftBot\", 3, XModel.grad.dhdx, XModel.blocks.outZone[0]);\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"LeftTop\", 3, XModel.grad.dhdy, XModel.blocks.outZone[0]);\n\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"TopLeft\", 3, XModel.grad.dzsdx, XModel.blocks.outZone[0]);\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"TopRight\", 3, XModel.grad.dzsdy, XModel.blocks.outZone[0]);\n\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"RightTop\", 3, XModel.grad.dudx, XModel.blocks.outZone[0]);\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"RightBot\", 3, XModel.grad.dudy, XModel.blocks.outZone[0]);\n\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"BotLeft\", 3, XModel.grad.dvdx, XModel.blocks.outZone[0]);\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"BotRight\", 3, XModel.grad.dvdy, XModel.blocks.outZone[0]);\n    }\n\n    return test;\n}\n\n\ntemplate &lt;class T&gt; void testButtingerX(Param XParam, int ib, int ix, int iy, Model&lt;T&gt; XModel)\n{\n    int RB, levRB, LBRB, LB, levLB, RBLB;\n    int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n    int ileft = memloc(XParam.halowidth, XParam.blkmemwidth, ix - 1, iy, ib);\n\n    int lev = XModel.blocks.level[ib];\n    T delta = calcres(T(XParam.delta), lev);\n\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n\n    // neighbours for source term\n\n    RB = XModel.blocks.RightBot[ib];\n    levRB = XModel.blocks.level[RB];\n    LBRB = XModel.blocks.LeftBot[RB];\n\n    LB = XModel.blocks.LeftBot[ib];\n    levLB = XModel.blocks.level[LB];\n    RBLB = XModel.blocks.RightBot[LB];\n\n\n    T cm = T(1.0);\n    T fmu = T(1.0);\n\n    T hi = XModel.evolv.h[i];\n\n    T hn = XModel.evolv.h[ileft];\n\n\n    //if (hi &gt; eps || hn &gt; eps)\n    {\n        T dx, zi, zn, hr, hl, etar, etal, zr, zl, zA, zCN, hCNr, hCNl;\n        T ui, vi, uli, vli, dhdxi, dhdxil, dudxi, dudxil, dvdxi, dvdxil;\n\n        T ga = g * T(0.5);\n        // along X\n        dx = delta * T(0.5);\n        zi = XModel.zb[i];\n        zn = XModel.zb[ileft];\n\n        ui = XModel.evolv.u[i];\n        vi = XModel.evolv.v[i];\n        uli = XModel.evolv.u[ileft];\n        vli = XModel.evolv.v[ileft];\n\n        dhdxi = XModel.grad.dhdx[i];\n        dhdxil = XModel.grad.dhdx[ileft];\n        dudxi = XModel.grad.dudx[i];\n        dudxil = XModel.grad.dudx[ileft];\n        dvdxi = XModel.grad.dvdx[i];\n        dvdxil = XModel.grad.dvdx[ileft];\n\n\n        hr = hi - dx * dhdxi;\n        hl = hn + dx * dhdxil;\n        etar = XModel.evolv.zs[i] - dx * XModel.grad.dzsdx[i];\n        etal = XModel.evolv.zs[ileft] + dx * XModel.grad.dzsdx[ileft];\n\n        //define the topography term at the interfaces\n        zr = zi - dx * XModel.grad.dzbdx[i];\n        zl = zn + dx * XModel.grad.dzbdx[ileft];\n\n        //define the Audusse terms\n        zA = max(zr, zl);\n\n        // Now the CN terms\n        zCN = min(zA, min(etal, etar));\n        hCNr = max(T(0.0), min(etar - zCN, hr));\n        hCNl = max(T(0.0), min(etal - zCN, hl));\n\n        //Velocity reconstruction\n        //To avoid high velocities near dry cells, we reconstruct velocities according to Bouchut.\n        T ul, ur, vl, vr, sl, sr;\n        if (hi &gt; eps) {\n            ur = ui - (T(1.) + dx * dhdxi / hi) * dx * dudxi;\n            vr = vi - (T(1.) + dx * dhdxi / hi) * dx * dvdxi;\n        }\n        else {\n            ur = ui - dx * dudxi;\n            vr = vi - dx * dvdxi;\n        }\n        if (hn &gt; eps) {\n            ul = uli + (T(1.) - dx * dhdxil / hn) * dx * dudxil;\n            vl = vli + (T(1.) - dx * dhdxil / hn) * dx * dvdxil;\n        }\n        else {\n            ul = uli + dx * dudxil;\n            vl = vli + dx * dvdxil;\n        }\n\n\n\n\n        T fh, fu, fv, dt;\n\n\n        //solver below also modifies fh and fu\n        dt = hllc(g, delta, epsi, CFL, cm, fmu, hCNl, hCNr, ul, ur, fh, fu);\n        //hllc(T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T &amp; fh, T &amp; fq)\n\n\n\n        fv = (fh &gt; 0. ? vl : vr) * fh;\n\n\n        // Topographic source term\n\n        // In the case of adaptive refinement, care must be taken to ensure\n        // well-balancing at coarse/fine faces (see [notes/balanced.tm]()). \n        if ((ix == XParam.blkwidth) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = LBRB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n            int iright = memloc(XParam.halowidth, XParam.blkmemwidth, 0, jj, RB);;\n            hi = XModel.evolv.h[iright];\n            zi = XModel.zb[iright];\n        }\n        if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo if you \n        {\n            int jj = RBLB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n            int ilc = memloc(XParam.halowidth, XParam.blkmemwidth, XParam.blkwidth - 1, jj, LB);\n            //int ilc = memloc(halowidth, blkmemwidth, -1, iy, ib);\n            hn = XModel.evolv.h[ilc];\n            zn = XModel.zb[ilc];\n        }\n\n        sl = ga * (hi + hCNr) * (zi - zCN);\n        sr = ga * (hCNl + hn) * (zn - zCN);\n\n\n        printf(\"dt=%f; etar=%f; etal=%f; zCN=%f; zi=%f; zn=%f; zA=%f, zr=%f, zl=%f\\n\", dt, etar, etal, zCN, zi, zn, zA, zr, zl);\n\n\n        printf(\"hi=%f; hn=%f,fh=%f; fu=%f; sl=%f; sr=%f; hCNl=%f; hCNr=%f; hr=%f; hl=%f; zr=%f; zl=%f;\\n\", hi, hn, fh, fu, sl, sr, hCNl, hCNr, hr, hl, zr, zl);\n\n        printf(\"h[i]=%f; h[ileft]=%f dhdx[i]=%f, dhdx[ileft]=%f, zs[i]=%f, zs[ileft]=%f, dzsdx[i]=%f, dzsdx[ileft]=%f, dzbdx[i]=%f, dzbdx[ileft]=%f\\n\\n\", XModel.evolv.h[i], XModel.evolv.h[ileft], XModel.grad.dhdx[i], XModel.grad.dhdx[ileft], XModel.evolv.zs[i], XModel.evolv.zs[ileft], XModel.grad.dzsdx[i], XModel.grad.dzsdx[ileft], XModel.grad.dzbdx[i], XModel.grad.dzbdx[ileft]);\n    }\n}\n\n\ntemplate &lt;class T&gt; void testkurganovX(Param XParam, int ib, int ix, int iy, Model&lt;T&gt; XModel)\n{\n    int RB, levRB, LBRB, LB, levLB, RBLB;\n    int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n    int ileft = memloc(XParam.halowidth, XParam.blkmemwidth, ix - 1, iy, ib);\n\n    int lev = XModel.blocks.level[ib];\n    T delta = calcres(T(XParam.delta), lev);\n\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n\n    // neighbours for source term\n\n    RB = XModel.blocks.RightBot[ib];\n    levRB = XModel.blocks.level[RB];\n    LBRB = XModel.blocks.LeftBot[RB];\n\n    LB = XModel.blocks.LeftBot[ib];\n    levLB = XModel.blocks.level[LB];\n    RBLB = XModel.blocks.RightBot[LB];\n\n    T dhdxi = XModel.grad.dhdx[i];\n    T dhdxmin = XModel.grad.dhdx[ileft];\n    T cm = T(1.0);\n    T fmu = T(1.0);\n\n    T hi = XModel.evolv.h[i];\n\n    T hn = XModel.evolv.h[ileft];\n    T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm, ga;\n\n    // along X\n    dx = delta * T(0.5);\n    zi = XModel.evolv.zs[i] - hi;\n\n    //printf(\"%f\\n\", zi);\n\n\n    //zl = zi - dx*(dzsdx[i] - dhdx[i]);\n    zl = zi - dx * (XModel.grad.dzsdx[i] - dhdxi);\n    //printf(\"%f\\n\", zl);\n\n    zn = XModel.evolv.zs[ileft] - hn;\n\n    //printf(\"%f\\n\", zn);\n    zr = zn + dx * (XModel.grad.dzsdx[ileft] - dhdxmin);\n\n\n    zlr = max(zl, zr);\n\n    //hl = hi - dx*dhdx[i];\n    hl = hi - dx * dhdxi;\n    up = XModel.evolv.u[i] - dx * XModel.grad.dudx[i];\n    hp = max(T(0.0), hl + zl - zlr);\n\n    hr = hn + dx * dhdxmin;\n    um = XModel.evolv.u[ileft] + dx * XModel.grad.dudx[ileft];\n    hm = max(T(0.0), hr + zr - zlr);\n\n    ga = g * T(0.5);\n    T fh, fu, fv, sl, sr, dt;\n\n    //solver below also modifies fh and fu\n    dt = KurgSolver(g, delta, epsi, CFL, cm, fmu, hp, hm, up, um, fh, fu);\n\n    if ((ix == XParam.blkwidth) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n    {\n        int jj = LBRB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + XParam.blkwidth / 2;\n        int iright = memloc(XParam.halowidth, XParam.blkmemwidth, 0, jj, RB);;\n        hi = XModel.evolv.h[iright];\n        zi = XModel.zb[iright];\n    }\n    if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo if you \n    {\n        int jj = RBLB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + XParam.blkwidth / 2;\n        int ilc = memloc(XParam.halowidth, XParam.blkmemwidth, XParam.blkwidth - 1, jj, LB);\n        hn = XModel.evolv.h[ilc];\n        zn = XModel.zb[ilc];\n    }\n\n\n    sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n    sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n    //Fhu[i] = fmu * fh;\n    //Fqux[i] = fmu * (fu - sl);\n    //Su[i] = fmu * (fu - sr);\n    //Fqvx[i] = fmu * fv;\n\n    printf(\"hi=%f; hn=%f,fh=%f; fu=%f; sl=%f; sr=%f; hp=%f; hm=%f; hr=%f; hl=%f; zr=%f; zl=%f;\\n\", hi, hn, fh, fu, sl, sr, hp, hm, hr, hl, zr, zl);\n\n    printf(\"h[i]=%f; h[ileft]=%f dhdx[i]=%f, dhdx[ileft]=%f, zs[i]=%f, zs[ileft]=%f, dzsdx[i]=%f, dzsdx[ileft]=%f\\n\", XModel.evolv.h[i], XModel.evolv.h[ileft], XModel.grad.dhdx[i], XModel.grad.dhdx[ileft], XModel.evolv.zs[i], XModel.evolv.zs[ileft], XModel.grad.dzsdx[i], XModel.grad.dzsdx[ileft]);\n\n}\n\ntemplate &lt;class T&gt; bool Raintest(T zsnit, int gpu, float alpha,int engine)\n{\n    log(\"#####\");\n    Param XParam;\n    T initVol, TheoryInput;\n    TheoryInput = T(0.0);\n    // initialise domain and required resolution\n    XParam.dx = 1.0 / ((1 &lt;&lt; 6)); //1&lt;&lt;8  = 2^8\n    XParam.xo = -0.5;\n    XParam.yo = -0.5;\n    XParam.xmax = 0.5;\n    XParam.ymax = 0.5;\n\n    XParam.engine = engine;\n\n    //XParam.initlevel = 0;\n    //XParam.minlevel = 0;\n    //XParam.maxlevel = 0;\n\n    XParam.zsinit = zsnit;\n    //XParam.zsoffset = 0.0;\n\n    //Output times for comparisons\n    XParam.endtime = 1.0;\n    XParam.outputtimestep = 0.1;\n\n    XParam.smallnc = 0;\n\n    XParam.cf = 0.01;\n    XParam.frictionmodel = 0;\n\n    //Specification of the test\n    //XParam.test = 7;\n    XParam.rainforcing = true;\n    XParam.ForceMassConserve = true;\n\n    // Enforce GPU/CPU\n    XParam.GPUDEVICE = gpu;\n    XParam.rainbnd = true;\n    //output vars\n    std::vector&lt;std::string&gt; outv = { \"zb\",\"h\",\"zs\",\"u\",\"v\" };\n    XParam.outvars = outv;\n\n    // create Model setup\n    Model&lt;T&gt; XModel;\n    Model&lt;T&gt; XModel_g;\n\n    Forcing&lt;float&gt; XForcing;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    XForcing.Bathy.push_back(bathy);\n\n    // initialise forcing bathymetry to 0\n    XForcing.Bathy[0].xo = -1.0;\n    XForcing.Bathy[0].yo = -1.0;\n    XForcing.Bathy[0].xmax = 1.0;\n    XForcing.Bathy[0].ymax = 1.0;\n    XForcing.Bathy[0].nx = 3;\n    XForcing.Bathy[0].ny = 3;\n\n    XForcing.Bathy[0].dx = 1.0;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = i * alpha / 100;\n        }\n    }\n\n    // Add wall boundary conditions\n    XForcing.right.type = 0;\n    XForcing.left.type = 0;\n    XForcing.top.type = 0;\n    XForcing.bot.type = 0;\n\n\n    //Value definition for surface rain fall\n    T Q = 300; // mm/hr\n    std::cout &lt;&lt; \"# Theoretical volume of water input during the simulation in m3: \" &lt;&lt; TheoryInput &lt;&lt; \", from a rain input of: \" &lt;&lt; Q &lt;&lt; \"mm/hr.\" &lt;&lt; std::endl;\n    //Create a temporary file with rain fluxes\n    std::ofstream rain_file(\n        \"testrain.tmp\", std::ios_base::out | std::ios_base::trunc);\n    rain_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    rain_file &lt;&lt; \"3600.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    rain_file.close(); //destructor implicitly does it\n\n    XForcing.Rain.inputfile = \"testrain.tmp\";\n    XForcing.Rain.uniform = true;\n\n    // Reading rain forcing from file for CPU and unifor rain\n    XForcing.Rain.unidata = readINfileUNI(XForcing.Rain.inputfile, XParam.reftime);\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n    initVol = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.delta, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                initVol = initVol + XModel.evolv.h[i] * delta * delta;\n            }\n        }\n    }\n\n\n    MainLoop(XParam, XForcing, XModel, XModel_g);\n\n    TheoryInput = Q / T(1000.0) / T(3600.0) * XParam.endtime;\n\n\n    T SimulatedVolume = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.delta, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                SimulatedVolume = SimulatedVolume + XModel.evolv.h[i] * delta * delta;\n            }\n        }\n    }\n\n    SimulatedVolume = SimulatedVolume - initVol;\n\n    T error = abs(SimulatedVolume - TheoryInput);\n\n    T modelgood = error / TheoryInput &lt; 0.05;\n\n    //log(\"#####\");\n    return modelgood;\n}\n\n\nbool Raintestinput(int gpu)\n{\n    //Results of the experiment of Aureli, interpolated to output values\n    bool modelgood1, modelgood2;\n    std::string result;\n    //int dim_flux;\n    std::vector&lt;float&gt; Flux1D, Flux3DUni, Flux3D, Flux_obs;\n    float diff, ref, error;\n\n\n    //Comparison between the 1D forcing and the 3D hommgeneous forcing\n    Flux1D = Raintestmap(gpu, 1, -0.03);\n    Flux3DUni = Raintestmap(gpu, 31, -0.03);\n    ref = 0.0;\n    diff = 0.0;\n    for (int i = 0; i &lt; Flux1D.size(); i++)\n    {\n        diff = diff + Flux1D[i] - Flux3DUni[i];\n        ref = ref + Flux1D[i];\n    }\n\n    error = abs(diff / ref);\n    printf(\"Error %f \\n\", error);\n\n    modelgood1 = error &lt; 0.005;\n    result = modelgood1 ? \"successful\" : \"failed\";\n    log(\"\\t\\tRain test input 1D vs 3D homogeneous: \" + result);\n\n    //Comparison between the 3D forcing and the observations from Iwagaki1955.\n\n    //From Observations\n    //Flux_obs = { 1.75136262,  4.31856716, 24.36350225, 32.02235696, 32.41207121,\n    //   31.68632601, 29.8140878 , 47.9632521 , 68.78608061, 57.03656989 };\n\n    //From BG_run of the testcase\n    Flux_obs = { 4.003079, 12.664897, 25.376514, 33.214722, 34.987427, 34.054474,\n        32.696472, 30.718161, 89.497993, 58.156021 };\n\n    Flux3D = Raintestmap(gpu, 3, -0.03);\n    ref = 0.0;\n    diff = 0.0;\n    for (int i = 0; i &lt; Flux3D.size(); i++)\n    {\n        diff = diff + Flux_obs[i] - Flux3D[i];\n        ref = ref + Flux3D[i];\n    }\n\n    error = abs(diff / ref);\n    printf(\"Error %f \\n\", error);\n\n    modelgood2 = error &lt; 0.00005;\n    result = modelgood2 ? \"successful\" : \"failed\";\n    log(\"\\t\\tRain test input 3D map vs Iwagaki1955: \" + result);\n\n    return (modelgood1 * modelgood2);\n}\n\ntemplate &lt;class T&gt; std::vector&lt;float&gt; Raintestmap(int gpu, int dimf, T zinit)\n{\n    log(\"#####\");\n    int k;\n    T rainDuration = 10.0;\n    int NX = 2502;\n    int NY = 22;\n    int NT;\n    double* xRain;\n    double* yRain;\n    double* tRain;\n    double* rainForcing;\n\n\n    Param XParam;\n    T delta;\n\n    // initialise domain and required resolution\n    XParam.xo = 0;\n    XParam.yo = 0;\n    XParam.ymax = 0.196;\n    XParam.dx = (XParam.ymax - XParam.yo) / (1 &lt;&lt; 1);\n    XParam.delta = XParam.dx;\n    double Xmax_exp = 28.0; //minimum Xmax position (adjust to have a \"full blocks\" config)\n    //Calculating xmax to have full blocs with at least a full block behaving as a reservoir\n    XParam.xmax = XParam.xo + (16 * XParam.dx) * std::ceil((Xmax_exp - XParam.xo) / (16 * XParam.dx)) + (16 * XParam.dx);\n    //Surf = T((XParam.xmax - XParam.xo) * (XParam.ymax - XParam.yo));\n    XParam.nblk = ftoi(((XParam.xmax - XParam.xo) / XParam.dx / 16) * ((XParam.ymax - XParam.yo) / XParam.dx / 16));\n    XParam.rainbnd = true;\n    XParam.zsinit = zinit;\n\n    //Output times for comparisons\n    XParam.endtime = 30.0;\n    XParam.outputtimestep = 3.0;\n\n    XParam.smallnc = 0;\n\n    //Specification of the test\n    XParam.test = 8;\n\n    // Enforce GPU/CPU\n    XParam.GPUDEVICE = gpu;\n\n    //Bottom friction\n    XParam.frictionmodel = -1; //Manning model\n    XParam.cf = 0.009; //n in m^(-1/3)s\n\n    std::string outvi[16] = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"Su\", \"Sv\" };\n\n    std::vector&lt;std::string&gt; outv;\n\n    for (int nv = 0; nv &lt; 15; nv++)\n    {\n        outv.push_back(outvi[nv]);\n    }\n\n    XParam.outvars = outv;\n\n    // create Model setup\n    Model&lt;T&gt; XModel;\n    Model&lt;T&gt; XModel_g;\n\n    Forcing&lt;float&gt; XForcing;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    XForcing.Bathy.push_back(bathy);\n\n    // initialise forcing bathymetry to 0\n    XForcing.Bathy[0].xo = -1.0;\n    XForcing.Bathy[0].yo = -1.0;\n    XForcing.Bathy[0].xmax = 28.0;\n    XForcing.Bathy[0].ymax = 1.0;\n    XForcing.Bathy[0].dx = 0.1;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n    XForcing.Bathy[0].nx = ftoi((XForcing.Bathy[0].xmax - XForcing.Bathy[0].xo) / XForcing.Bathy[0].dx + 1);\n    XForcing.Bathy[0].ny = ftoi((XForcing.Bathy[0].ymax - XForcing.Bathy[0].yo) / XForcing.Bathy[0].dx + 1);\n\n\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = -10.0;\n            if (i &lt; (9 / XForcing.Bathy[0].dx + 1))\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = T(0.2 + (9.0 - i * XForcing.Bathy[0].dx) * 2.0 / 100.0);\n            }\n            else if (i &lt; (17 / XForcing.Bathy[0].dx + 1))\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = T(0.08 + (17.0 - i * XForcing.Bathy[0].dx) * 1.5 / 100.0);\n            }\n            else if (i &lt; (25 / XForcing.Bathy[0].dx + 1))\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = T(0.0 + (25.0 - i * XForcing.Bathy[0].dx) * 1.0 / 100.0);\n            }\n        }\n    }\n\n    // Add wall boundary conditions but at the bottom of the slope\n    //XForcing.right.type = 0;\n    XForcing.left.type = 0;\n    //XForcing.top.type = 0;\n    //XForcing.bot.type = 0;\n\n    //Value definition for surface rain fall\n    T r1 = T(3888.0); // mm/hr\n    T r2 = T(2296.8); //mm/hr\n    T r3 = T(2880.0); //mm/hr\n    T Q = (r1 + r2 + r3) / 3;\n    //TheoryInput = Q * XParam.outputtimestep / T(1000.0) / T(3600.0) * Surf; //m3/s\n    //printf(\"# Theoretical volume of water input during the simulation in m3: %f , from a mean rain input of: %f mm/hr.\\n\", TheoryInput, Q);\n    double eps = 0.0001;\n\n    // Create the rain forcing file\n    if (dimf == 1)\n    {\n        //Create a temporary file with rain fluxes for uniform rain\n        std::ofstream rain_file(\n            \"testrain.tmp\", std::ios_base::out | std::ios_base::trunc);\n        rain_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n        rain_file &lt;&lt; std::to_string(rainDuration) + \" \" + std::to_string(Q) &lt;&lt; std::endl;\n        rain_file &lt;&lt; std::to_string(rainDuration + eps) + \" 0.0\" &lt;&lt; std::endl;\n        rain_file &lt;&lt; std::to_string(rainDuration + 360000) + \" 0.0\" &lt;&lt; std::endl;\n        rain_file.close(); //destructor implicitly does it\n\n        XForcing.Rain.inputfile = \"testrain.tmp\";\n        XForcing.Rain.uniform = true;\n\n        // Reading rain forcing from file for CPU and uniform rain\n        XForcing.Rain.unidata = readINfileUNI(XForcing.Rain.inputfile, XParam.reftime);\n        printf(\"1D rain forcing read\\n\");\n    }\n    else //non-uniform forcing\n    {\n        XForcing.Rain.uniform = false;\n\n        //X Y variables\n\n        xRain = (double*)malloc(sizeof(double) * NX);\n        yRain = (double*)malloc(sizeof(double) * NY);\n\n        for (int i = 0; i &lt; NX; i++) { xRain[i] = -0.005 + 0.01 * i; }\n        for (int j = 0; j &lt; NY; j++) { yRain[j] = -0.01 + 0.01 * j; }\n\n        NT = 601;\n        tRain = (double*)malloc(sizeof(double) * NT);\n        for (int tt = 0; tt &lt; NT; tt++) { tRain[tt] = XParam.endtime / (NT - 1) * tt; }\n\n        rainForcing = (double*)malloc(sizeof(double) * NT * NY * NX);\n\n        //Create a non-uniform time-variable rain forcing\n        if (dimf == 3)\n        {\n            //Create the rain forcing:\n            for (k = 0; k &lt; NT; k++)\n            {\n                for (int j = 0; j &lt; NY; j++)\n                {\n                    for (int i = 0; i &lt; NX; i++)\n                    {\n                        if (tRain[k] &lt; rainDuration + eps)\n                        {\n                            if (xRain[i] &lt; 8.0)\n                            {\n                                rainForcing[k * (NX * NY) + j * NX + i] = r1;\n                            }\n                            else if (xRain[i] &lt; 16.0)\n                            {\n                                rainForcing[k * (NX * NY) + j * NX + i] = r2;\n                            }\n                            else\n                            {\n                                rainForcing[k * (NX * NY) + j * NX + i] = r3;\n                            }\n                        }\n                        else\n                        {\n                            rainForcing[k * (NX * NY) + i * NY + j] = 0.0;\n                        }\n                    }\n                }\n            }\n\n            //Write the netcdf file\n            create3dnc(\"rainTemp.nc\", NX, NY, NT, xRain, yRain, tRain, rainForcing, \"myrainforcing\");\n\n            printf(\"non-uniform forcing\\n\");\n\n            //End creation of the nc file for rain forcing\n        }\n        //Create a uniform time-variable rain forcing using a map forcing (nc file)\n        else if (dimf == 31)\n        {\n            //Create the rain forcing:\n            for (k = 0; k &lt; NT; k++)\n            {\n                for (int j = 0; j &lt; NY; j++)\n                {\n                    for (int i = 0; i &lt; NX; i++)\n                    {\n                        if (tRain[k] &lt; rainDuration + eps)\n                        {\n                            rainForcing[k * (NX * NY) + j * NX + i] = Q;\n                        }\n                        else\n                        {\n                            rainForcing[k * (NX * NY) + i * NY + j] = 0.0;\n                        }\n                    }\n                }\n            }\n\n            //Write the netcdf file\n            create3dnc(\"rainTemp.nc\", NX, NY, NT, xRain, yRain, tRain, rainForcing, \"myrainforcing\");\n\n            printf(\"non-uniform forcing 31\\n\");\n            //End creation of the nc file for rain forcing\n        }\n        /*\n        //2D forcing (map without time variation is not working)\n        else if (dimf == 2)//dimf==2 for rain forcing\n        {\n\n            //Create a non-uniform time-constant rain forcing\n            rainForcing = (double*)malloc(sizeof(double) * NY * NX);\n\n            //Create the rain forcing:\n\n            for (int j = 0; j &lt; NY; j++)\n            {\n                for (int i = 0; i &lt; NX; i++)\n                {\n\n                    if (xRain[i] &lt; 8.0)\n                    {\n                        rainForcing[j * NX + i] = r1;\n                    }\n                    else if (xRain[i] &lt; 16.0)\n                    {\n                        rainForcing[j * NX + i] = r2;\n                    }\n                    else\n                    {\n                        rainForcing[j * NX + i] = r3;\n                    }\n\n                }\n            }\n\n            create2dnc(\"rainTempt.nc\", NX, NY, xRain, yRain, rainForcing, \"myrainforcing\");\n\n            //End creation of the nc file for rain forcing\n        }\n        */\n        else { printf(\"Error in rain forcing dimension (should be in [1,3,31])\\n\"); }\n\n        //Reading non-unform forcing\n        bool gpgpu = 0;\n        if (XParam.GPUDEVICE != -1)\n        {\n            gpgpu = 1;\n        }\n\n        XForcing.Rain = readfileinfo(\"rainTemp.nc\", XForcing.Rain);\n        XForcing.Rain.uniform = 0;\n        XForcing.Rain.varname = \"myrainforcing\";\n\n\n        InitDynforcing(gpgpu, XParam, XForcing.Rain);\n\n        //readDynforcing(gpgpu, XParam.totaltime, XForcing.Rain);\n\n\n        free(rainForcing);\n        free(xRain);\n        free(yRain);\n        free(tRain);\n    }\n\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    log(\"Initialising model main loop\");\n\n    Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n\n    //Define some useful variables \n    Initmeanmax(XParam, XLoop, XModel, XModel_g);\n\n\n    log(\"\\t\\tCompleted\");\n    log(\"Model Running...\");\n    std::vector&lt;float&gt; Flux;\n\n    while (XLoop.totaltime &lt; XParam.endtime)\n    {\n\n        // Calculate Forcing at this step\n        updateforcing(XParam, XLoop, XForcing);\n\n        // Core engine\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            FlowGPU(XParam, XLoop, XForcing, XModel_g);\n        }\n        else\n        {\n            FlowCPU(XParam, XLoop, XForcing, XModel);\n        }\n\n        // Time keeping\n        XLoop.totaltime = XLoop.totaltime + XLoop.dt;\n        //printf(\"\\tTime = %f \\n\", XLoop.totaltime);\n\n        //if Toutput, calculate the flux at x=24m;\n\n\n        // Getting the coordinate for the flux calculation\n        int bl, ixx, ibl, ix, ib;\n        T dist = T(1000000000.0);\n        for (ibl = 0; ibl &lt; XParam.nblk; ibl++)\n        {\n            ib = XModel.blocks.active[ibl];\n            delta = calcres(T(XParam.dx), XModel.blocks.level[ib]);\n            for (ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //n = memloc(XParam, ix, 0, ib);\n                if (abs(XModel.blocks.xo[ibl] + ix * delta - 24.0) &lt; dist)\n                {\n                    ixx = ix;\n                    bl = ibl;\n                    dist = T(abs(XModel.blocks.xo[ibl] + ix * delta - 24.0));\n                }\n            }\n        }\n\n        if (XLoop.nextoutputtime - XLoop.totaltime &lt;= XLoop.dt * T(0.00001) &amp;&amp; XParam.outputtimestep &gt; 0.0)\n        {\n            T finalFlux = T(0.0);\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n                {\n                    CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[XParam.outvars[ivar]], XModel_g.OutputVarMap[XParam.outvars[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n                }\n            }\n\n            Save2Netcdf(XParam, XLoop, XModel);\n\n\n            //Calculation of the flux at the bottom of the slope (x=24m)\n            ib = XModel.blocks.active[bl];\n            delta = calcres(T(XParam.delta), XModel.blocks.level[ib]);\n\n            for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n            {\n                int n = memloc(XParam, ixx, iy, ib);\n                finalFlux = finalFlux + XModel.evolv.h[n] * XModel.evolv.u[n] * delta;\n            }\n            finalFlux = finalFlux / float(XParam.ymax - XParam.yo) * 100.0f * 100.0f;\n            Flux.push_back(finalFlux);\n            XLoop.nextoutputtime = XLoop.nextoutputtime + XParam.outputtimestep;\n            printf(\"\\tTime = %f, Flux at bottom end of slope : %f \\n\", XLoop.totaltime, finalFlux);\n        }\n    }\n    /*\n    for (int n = 0; n &lt; Flux.size(); n++)\n    {\n        printf(\"Flux at %i : %f \\n\", n, Flux[n]);\n    }\n    */\n\n    return Flux;\n}\ntemplate std::vector&lt;float&gt; Raintestmap&lt;float&gt;(int gpu, int dimf, float Zsinit);\ntemplate std::vector&lt;float&gt; Raintestmap&lt;double&gt;(int gpu, int dimf, double Zsinit);\n\n\ntemplate &lt;class T&gt; bool ZoneOutputTest(int nzones, T zsinit)\n//template bool ZoneOutputTest&lt;float&gt;(int nzones, float zsinit);\n{\n    log(\"#####\");\n\n    Param XParam;\n    Forcing&lt;float&gt; XForcing;\n\n\n    if (nzones == 3)\n    {\n        // read param file\n        //readforcing(XParam, XForcing);\n        outzoneP zone;\n        zone.outname = \"whole.nc\";\n        zone.xstart = -10;\n        zone.xend = 10;\n        zone.ystart = -10;\n        zone.yend = 10;\n        XParam.outzone.push_back(zone);\n        zone.outname = \"zoomed.nc\";\n        zone.xstart = 1;\n        zone.xend = 2;\n        zone.ystart = -2;\n        zone.yend = 2;\n        XParam.outzone.push_back(zone);\n        zone.outname = \"zoomed2.nc\";\n        zone.xstart = -2;\n        zone.xend = 2;\n        zone.ystart = -4;\n        zone.yend = 2;\n        XParam.outzone.push_back(zone);\n    }\n\n    // initialise domain and required resolution\n    XParam.dx = 1.0 / ((1 &lt;&lt; 6)); //1&lt;&lt;8  = 2^8\n    XParam.xo = -5;\n    XParam.yo = -5;\n    XParam.xmax = 5;\n    XParam.ymax = 5;\n\n    XParam.initlevel = 0;\n    XParam.minlevel = -1;\n    XParam.maxlevel = 1;\n\n    XParam.zsinit = zsinit;\n    //XParam.zsoffset = 0.0;\n\n    //Output times for comparisons\n    XParam.endtime = 1.0;\n    XParam.outputtimestep = 0.5;\n\n    XParam.smallnc = 0;\n\n    XParam.cf = 0.0001;\n    XParam.frictionmodel = 1;\n\n    //Specification of the test\n    //XParam.test = 7;\n    XParam.rainforcing = true;\n\n    // Enforce GPU/CPU\n    //XParam.GPUDEVICE = gpu;\n    //XParam.rainbnd = true;\n\n    // create Model setup\n    Model&lt;T&gt; XModel;\n    Model&lt;T&gt; XModel_g;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    XForcing.Bathy.push_back(bathy);\n\n    // initialise forcing bathymetry to a central hill\n    XForcing.Bathy[0].xo = -10.0;\n    XForcing.Bathy[0].yo = -10.0;\n    XForcing.Bathy[0].xmax = 10.0;\n    XForcing.Bathy[0].ymax = 10.0;\n    XForcing.Bathy[0].nx = 501;\n    XForcing.Bathy[0].ny = 501;\n\n    XForcing.Bathy[0].dx = 0.1;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n\n    float rs, x, y, r, hm;\n    rs = 20; //hill radio \n    hm = 5; //hill top\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            x = float(XForcing.Bathy[0].xo + i * XForcing.Bathy[0].dx);\n            y = float(XForcing.Bathy[0].yo + j * XForcing.Bathy[0].dx);\n            r = sqrt(x * x + y * y);\n            if (r &lt; rs)\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = hm * (1 - r / rs);\n            }\n            if (x &lt; -4.7 | x &gt; 4.7 | y &lt; -4.7 | y &gt; 4.7)\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = 10;\n            }\n        }\n    }\n\n    //Adaptation\n    XParam.AdaptCrit = \"Targetlevel\";\n\n    StaticForcingP&lt;int&gt; Target;\n    XForcing.targetadapt.push_back(Target);\n\n    XForcing.targetadapt[0].xo = -10;\n    XForcing.targetadapt[0].yo = -10;\n    XForcing.targetadapt[0].xmax = 10.0;\n    XForcing.targetadapt[0].ymax = 10.0;\n    XForcing.targetadapt[0].nx = 501;\n    XForcing.targetadapt[0].ny = 501;\n\n    XForcing.targetadapt[0].dx = 0.1;\n\n    AllocateCPU(XForcing.targetadapt[0].nx, XForcing.targetadapt[0].ny, XForcing.targetadapt[0].val);\n\n    for (int j = 0; j &lt; XForcing.targetadapt[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.targetadapt[0].nx; i++)\n        {\n            x = float(XForcing.targetadapt[0].xo + i * XForcing.targetadapt[0].dx);\n            y = float(XForcing.targetadapt[0].yo + j * XForcing.targetadapt[0].dx);\n            if (x &lt; 0.0)\n            {\n                XForcing.targetadapt[0].val[i + j * XForcing.targetadapt[0].nx] = -1;\n            }\n            else\n            {\n                if (y &lt; 0.0)\n                {\n                    XForcing.targetadapt[0].val[i + j * XForcing.targetadapt[0].nx] = 0;\n                }\n                else\n                {\n                    XForcing.targetadapt[0].val[i + j * XForcing.targetadapt[0].nx] = 1;\n                }\n            }\n        }\n    }\n\n    // Add wall boundary conditions\n    XForcing.right.type = 0;\n    XForcing.left.type = 0;\n    XForcing.top.type = 0;\n    XForcing.bot.type = 0;\n\n\n    //Create a temporary file with river fluxes\n    float Q = 1;\n    std::ofstream river_file(\n        \"testriver.tmp\", std::ios_base::out | std::ios_base::trunc);\n    river_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file &lt;&lt; \"3600.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file.close(); //destructor implicitly does it\n\n    River thisriver;\n    thisriver.Riverflowfile = \"testriver.tmp\";\n    thisriver.xstart = -0.2;\n    thisriver.xend = 0.2;\n    thisriver.ystart = -0.2;\n    thisriver.yend = 0.2;\n\n    XForcing.rivers.push_back(thisriver);\n\n\n    XForcing.rivers[0].flowinput = readFlowfile(XForcing.rivers[0].Riverflowfile, XParam.reftime);\n\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    MainLoop(XParam, XForcing, XModel, XModel_g);\n\n    //Test if file exist and can be open:\n    int error = 1;\n    std::vector&lt;int&gt; observedSize{ 473251462,23304761,130802886 };\n    for (int o = 0; o &lt; XModel.blocks.outZone.size(); o++)\n    {\n        std::ifstream fs(XModel.blocks.outZone[o].outname);\n        if (fs.fail())\n        {\n            error++;\n        }\n        else\n        {\n            //Calculate the size of the file in bytes\n            std::ifstream in_file(XModel.blocks.outZone[o].outname, std::ios::binary);\n            in_file.seekg(0, std::ios::end);\n            int file_size = in_file.tellg();\n            printf(\"sizes : %i in bytes\\n\", file_size);\n            error = error * (observedSize[o] / file_size);\n        }\n    }\n\n    bool modelgood = (1 - abs(error)) &lt; 0.05;\n\n    //log(\"#####\");\n    return modelgood;\n}\ntemplate bool ZoneOutputTest&lt;float&gt;(int nzones, float zsinit);\ntemplate bool ZoneOutputTest&lt;double&gt;(int nzones, double zsinit);\n\n\n\ntemplate &lt;class T&gt; bool Rainlossestest(T zsinit, int gpu, float alpha)\n{\n    int NX = 21;\n    int NY = 21;\n    double* xLoss;\n    double* yLoss;\n    double* ilForcing;\n    double* clForcing;\n\n    log(\"#####\");\n    Param XParam;\n    T initVol, TheoryInput;\n    TheoryInput = T(0.0);\n    // initialise domain and required resolution\n    XParam.dx = 1.0 / ((1 &lt;&lt; 6)); //1&lt;&lt;8  = 2^8\n    XParam.xo = -0.5;\n    XParam.yo = -0.5;\n    XParam.xmax = 0.5;\n    XParam.ymax = 0.5;\n\n    XParam.zsinit = zsinit;\n    //XParam.zsoffset = 0.0;\n\n    XParam.infiltration = true;\n\n    //Output times for comparisons\n    XParam.endtime = 1.0;\n    XParam.outputtimestep = 0.1;\n\n    XParam.smallnc = 0;\n\n    XParam.cf = 0.01;\n    XParam.frictionmodel = 0;\n\n    // Enforce GPU/CPU\n    XParam.GPUDEVICE = gpu;\n    XParam.rainbnd = true;\n    //output vars\n    std::string outvi[17] = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"Su\", \"Sv\", \"hgw\" };\n    std::vector&lt;std::string&gt; outv;\n    for (int nv = 0; nv &lt; 17; nv++)\n    {\n        outv.push_back(outvi[nv]);\n    }\n    XParam.outvars = outv;\n\n    // create Model setup\n    Model&lt;T&gt; XModel;\n    Model&lt;T&gt; XModel_g;\n\n    Forcing&lt;float&gt; XForcing;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    XForcing.Bathy.push_back(bathy);\n\n    // initialise forcing bathymetry to 0\n    XForcing.Bathy[0].xo = -1.0;\n    XForcing.Bathy[0].yo = -1.0;\n    XForcing.Bathy[0].xmax = 1.0;\n    XForcing.Bathy[0].ymax = 1.0;\n    XForcing.Bathy[0].nx = 3;\n    XForcing.Bathy[0].ny = 3;\n\n    XForcing.Bathy[0].dx = 1.0;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = T(0.0);\n        }\n    }\n\n\n    // Add wall boundary conditions\n    XForcing.right.type = 0;\n    XForcing.left.type = 0;\n    XForcing.top.type = 0;\n    XForcing.bot.type = 0;\n\n    //Value definition for surface rain fall\n    T Q = 300; // mm/hr\n    std::cout &lt;&lt; \"# Theoretical volume of water input during the simulation in m3: \" &lt;&lt; TheoryInput &lt;&lt; \", from a rain input of: \" &lt;&lt; Q &lt;&lt; \"mm/hr.\" &lt;&lt; std::endl;\n    //Create a temporary file with rain fluxes\n    std::ofstream rain_file(\n        \"testrain.tmp\", std::ios_base::out | std::ios_base::trunc);\n    rain_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    rain_file &lt;&lt; \"3600.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    rain_file.close(); //destructor implicitly does it\n\n    XForcing.Rain.inputfile = \"testrain.tmp\";\n    XForcing.Rain.uniform = true;\n\n    // Reading rain forcing from file for CPU and unifor rain\n    XForcing.Rain.unidata = readINfileUNI(XForcing.Rain.inputfile, XParam.reftime);\n\n    //Value definition for surface IL-CL\n    T IL = 0.02; // mm\n    T CL = 100; // mm/hr\n\n    //Create a uniform map of IL-CL forcing (nc file)\n    xLoss = (double*)malloc(sizeof(double) * NX);\n    yLoss = (double*)malloc(sizeof(double) * NY);\n    for (int i = 0; i &lt; NX; i++) { xLoss[i] = -1.0 + 0.1 * i; }\n    for (int j = 0; j &lt; NY; j++) { yLoss[j] = -1.0 + 0.1 * j; }\n\n    ilForcing = (double*)malloc(sizeof(double) * NY * NX);\n    clForcing = (double*)malloc(sizeof(double) * NY * NX);\n\n    //Create the Losses forcing:\n    for (int j = 0; j &lt; NY; j++)\n    {\n        for (int i = 0; i &lt; NX; i++)\n        {\n            if (xLoss[i] &lt; 0)\n            {\n                ilForcing[j * NX + i] = 0;\n                clForcing[j * NX + i] = 0;\n            }\n            else\n            {\n                ilForcing[j * NX + i] = IL;\n                clForcing[j * NX + i] = CL;\n            }\n        }\n    }\n    create2dnc(\"ilrainlossTempt.nc\", NX, NY, xLoss, yLoss, ilForcing, \"initialloss\");\n    create2dnc(\"clrainlossTempt.nc\", NX, NY, xLoss, yLoss, clForcing, \"continuousloss\");\n\n    //Reading non-unform forcing\n    bool gpgpu = 0;\n    if (XParam.GPUDEVICE != -1)\n    {\n        gpgpu = 1;\n    }\n\n    XForcing.il = readfileinfo(\"ilrainlossTempt.nc\", XForcing.il);\n    XForcing.il.varname = \"initialloss\";\n    XForcing.cl = readfileinfo(\"clrainlossTempt.nc\", XForcing.cl);\n    XForcing.cl.varname = \"continuousloss\";\n    readstaticforcing(XForcing.il);\n    readstaticforcing(XForcing.cl);\n\n    free(ilForcing);\n    free(clForcing);\n    free(xLoss);\n    free(yLoss);\n\n    //XParam.infiltration = false;\n\n    checkparamsanity(XParam, XForcing);\n    //printf(\"h: %f \\n\", XModel.evolv.h[10]);\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n\n    InitialAdaptation(XParam, XForcing, XModel);\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    initVol = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.dx, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                initVol = initVol + XModel.evolv.h[i] * delta * delta;\n            }\n        }\n    }\n\n\n    MainLoop(XParam, XForcing, XModel, XModel_g);\n\n    TheoryInput = Q / T(1000.0) / T(3600.0) * XParam.endtime;\n\n\n    T SimulatedVolume = T(0.0);\n    T Infiltration_model = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.dx, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                SimulatedVolume = SimulatedVolume + XModel.evolv.h[i] * delta * delta;\n                Infiltration_model = Infiltration_model + XModel.hgw[i] * delta * delta;\n            }\n        }\n    }\n\n\n    SimulatedVolume = SimulatedVolume - initVol;\n\n    T error = abs(SimulatedVolume - TheoryInput + Infiltration_model);\n\n    T modelgood = error / abs(TheoryInput) &lt; 0.05;\n\n    //printf(\"Simulatedvolume: %f , Theory input: %f , Calcultated loss: %f\\n\", SimulatedVolume, TheoryInput, Infiltration_model);\n\n    //log(\"#####\");\n    return modelgood;\n}\n\n\ntemplate &lt;class T&gt; int TestGradientSpeed(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    //\n    int fastest = 1;\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    // for flux reconstruction the loop overlap the right(or top for the y direction) halo\n    dim3 blockDimX2(XParam.blkwidth + XParam.halowidth * 2, XParam.blkwidth + XParam.halowidth * 2, 1);\n\n\n\n    // Allocate CUDA events that we'll use for timing\n    cudaEvent_t startA, startB, startC, startG, startGnew;\n    cudaEvent_t stopA, stopB, stopC, stopG, stopGnew;\n\n    fillHalo(XParam, XModel.blocks, XModel.evolv, XModel.zb);\n\n    std::thread t0(&amp;gradientC&lt;T&gt;, XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    t0.join();\n\n\n    Loop&lt;T&gt; XLoop;\n    // GPU stuff\n\n\n    XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    XLoop.totaltime = 0.0;\n\n    XLoop.nextoutputtime = 3600.0;\n\n\n    cudaEventCreate(&amp;startA);\n\n\n    cudaEventCreate(&amp;stopA);\n\n    // Record the start event\n    cudaEventRecord(startA, NULL);\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XModel_g.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel_g.zb, XModel_g.grad.dzbdx, XModel_g.grad.dzbdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Record the stop event\n    cudaEventRecord(stopA, NULL);\n\n    // Wait for the stop event to complete\n    cudaEventSynchronize(stopA);\n\n    float msecTotalGrad = 0.0f;\n    cudaEventElapsedTime(&amp;msecTotalGrad, startA, stopA);\n\n    cudaEventDestroy(startA);\n    cudaEventDestroy(stopA);\n\n\n    cudaEventCreate(&amp;startB);\n\n\n    cudaEventCreate(&amp;stopB);\n\n    // Record the start event\n    cudaEventRecord(startB, NULL);\n    gradientSM &lt;&lt;&lt; gridDim, blockDim &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XModel_g.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel_g.zb, XModel_g.grad.dzsdx, XModel_g.grad.dzsdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Record the stop event\n    cudaEventRecord(stopB, NULL);\n\n    // Wait for the stop event to complete\n    cudaEventSynchronize(stopB);\n\n    float msecTotalSM = 0.0f;\n    cudaEventElapsedTime(&amp;msecTotalSM, startB, stopB);\n\n    cudaEventDestroy(startB);\n    cudaEventDestroy(stopB);\n\n\n    cudaEventCreate(&amp;startC);\n\n\n    cudaEventCreate(&amp;stopC);\n\n    // Record the start event\n    cudaEventRecord(startC, NULL);\n    gradientSMC &lt;&lt;&lt; gridDim, blockDim &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XModel_g.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel_g.zb, XModel_g.grad.dhdx, XModel_g.grad.dhdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Record the stop event\n    cudaEventRecord(stopC, NULL);\n\n    // Wait for the stop event to complete\n    cudaEventSynchronize(stopC);\n\n    float msecTotalSMB = 0.0f;\n    cudaEventElapsedTime(&amp;msecTotalSMB, startC, stopC);\n\n    cudaEventDestroy(startC);\n    cudaEventDestroy(stopC);\n\n\n\n\n    CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dudx, XModel_g.grad.dzbdx);\n    CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dudy, XModel_g.grad.dzbdy);\n\n    CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dzsdx, XModel_g.grad.dzsdx);\n    CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dzsdy, XModel_g.grad.dzsdy);\n\n    CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dhdx, XModel_g.grad.dhdx);\n    CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dhdy, XModel_g.grad.dhdy);\n\n    printf(\"Runtime : normal=%f, shared mem=%f, SharedmemB=%f in msec\\n\", msecTotalGrad, msecTotalSM, msecTotalSMB);\n\n    /*\n    creatncfileBUQ(XParam, XModel.blocks);\n\n    std::vector&lt;std::string&gt; varlist = { \"zb\", \"dzbdx\", \"dzbdy\" };\n\n    for (int ivar = 0; ivar &lt; varlist.size(); ivar++)\n    {\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, varlist[ivar], 3, XModel.OutputVarMap[varlist[ivar]], XModel.blocks.outZone[0]);\n    }\n\n    diffArray(XParam, XLoop, XModel.blocks, \"SMdx\", false, XModel.grad.dzbdx, XModel_g.grad.dzsdx, XModel.time.arrmax, XModel.grad.dzsdx);\n\n\n    diffArray(XParam, XLoop, XModel.blocks, \"SMBdx\", false, XModel.grad.dzbdx, XModel_g.grad.dhdx, XModel.time.arrmax, XModel.grad.dhdx);\n\n    diffArray(XParam, XLoop, XModel.blocks, \"SMBdy\", false, XModel.grad.dzbdy, XModel_g.grad.dhdy, XModel.time.arrmax, XModel.grad.dhdy);\n    diffArray(XParam, XLoop, XModel.blocks, \"SMdy\", false, XModel.grad.dzbdy, XModel_g.grad.dzsdy, XModel.time.arrmax, XModel.grad.dzsdy);\n    */\n    T maxdiffx, maxdiffy;\n    maxdiffx = T(0.0);\n    maxdiffy = T(0.0);\n    T maxdiffsmx, maxdiffsmy;\n    maxdiffsmx = T(0.0);\n    maxdiffsmy = T(0.0);\n    T maxdiffsmbx, maxdiffsmby;\n    maxdiffsmbx = T(0.0);\n    maxdiffsmby = T(0.0);\n    T diffsm, diffsmb;\n\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                diffsm = abs(XModel.grad.dzbdx[i] - XModel.grad.dudx[i]);\n\n                maxdiffx = max(maxdiffx, diffsm);\n\n                diffsm = abs(XModel.grad.dzbdy[i] - XModel.grad.dudy[i]);\n\n                maxdiffx = max(maxdiffx, diffsm);\n\n                diffsm = abs(XModel.grad.dzbdx[i] - XModel.grad.dzsdx[i]);\n\n                maxdiffsmx = max(maxdiffsmx, diffsm);\n\n                diffsm = abs(XModel.grad.dzbdy[i] - XModel.grad.dzsdy[i]);\n\n                maxdiffsmy = max(maxdiffsmy, diffsm);\n\n                diffsm = abs(XModel.grad.dzbdx[i] - XModel.grad.dhdx[i]);\n                maxdiffsmbx = max(maxdiffsmbx, diffsm);\n\n                diffsm = abs(XModel.grad.dzbdy[i] - XModel.grad.dhdy[i]);\n                maxdiffsmby = max(maxdiffsmby, diffsm);\n                //\n            }\n        }\n    }\n\n\n    printf(\"max error : normx=%e, normy=%e, smx=%e, smy=%e,  smbx=%e, smby=%e in m\\n\", maxdiffx, maxdiffy, maxdiffsmx, maxdiffsmy, maxdiffsmbx, maxdiffsmby);\n\n\n    gradientCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.zb);\n\n\n    cudaEventCreate(&amp;startG);\n\n\n    cudaEventCreate(&amp;stopG);\n\n    cudaEventRecord(startG, NULL);\n    gradientGPU(XParam, XModel_g.blocks, XModel_g.evolv, XModel_g.grad, XModel_g.zb);\n    cudaEventRecord(stopG, NULL);\n\n    // Wait for the stop event to complete\n    cudaEventSynchronize(stopG);\n\n    float msecTotalG = 0.0f;\n    cudaEventElapsedTime(&amp;msecTotalG, startG, stopG);\n\n    cudaEventDestroy(startG);\n    cudaEventDestroy(stopG);\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, { \"dhdx\",\"dhdy\", \"dzsdx\",\"dzsdy\",\"dudx\",\"dudy\",\"dvdx\",\"dvdy\" }, true);\n\n    //CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dzbdx, XModel_g.grad.dzbdx);\n    //CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dzbdy, XModel_g.grad.dzbdy);\n\n    //CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dzsdx, XModel_g.grad.dzsdx);\n    //CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dzsdy, XModel_g.grad.dzsdy);\n\n    //CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dhdx, XModel_g.grad.dhdx);\n    //CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dhdy, XModel_g.grad.dhdy);\n\n    cudaEventCreate(&amp;startGnew);\n\n\n    cudaEventCreate(&amp;stopGnew);\n\n    cudaEventRecord(startGnew, NULL);\n    gradientGPUnew(XParam, XModel_g.blocks, XModel_g.evolv, XModel_g.grad, XModel_g.zb);\n    cudaEventRecord(stopGnew, NULL);\n\n    // Wait for the stop event to complete\n    cudaEventSynchronize(stopGnew);\n\n    float msecTotalGnew = 0.0f;\n    cudaEventElapsedTime(&amp;msecTotalGnew, startGnew, stopGnew);\n\n    cudaEventDestroy(startGnew);\n    cudaEventDestroy(stopGnew);\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, { \"dhdx\",\"dhdy\", \"dzsdx\",\"dzsdy\",\"dudx\",\"dudy\",\"dvdx\",\"dvdy\" }, true);\n\n    printf(\"Runtime : old gradient=%f, new Gradient=%f in msec\\n\", msecTotalG, msecTotalGnew);\n\n    return fastest;\n\n}\n\ntemplate &lt;class T&gt; bool TestHaloSpeed(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    Forcing&lt;float&gt; XForcing;\n\n    XForcing = MakValleyBathy(XParam, T(0.4), true, true);\n\n    float maxtopo = std::numeric_limits&lt;float&gt;::min();\n    float mintopo = std::numeric_limits&lt;float&gt;::max();\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            maxtopo = max(XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx], maxtopo);\n            mintopo = min(XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx], mintopo);\n        }\n    }\n\n    // Overrule whatever may be set in the param file\n    XParam.xmax = XForcing.Bathy[0].xmax;\n    XParam.ymax = XForcing.Bathy[0].ymax;\n    XParam.xo = XForcing.Bathy[0].xo;\n    XParam.yo = XForcing.Bathy[0].yo;\n\n    XParam.dx = XForcing.Bathy[0].dx;\n\n    XParam.zsinit = mintopo + 0.5;// Had a small amount of water to avoid a huge first step that would surely break the setup\n    XParam.endtime = 20.0;\n\n    XParam.outputtimestep = XParam.endtime;\n\n    XParam.minlevel = 0;\n    XParam.maxlevel = 1;\n    XParam.initlevel = 0;\n\n    //coarse to fine\n    // Change arg 1 and 2 if the slope is changed\n    XParam.AdaptCrit = \"Inrange\";\n    XParam.Adapt_arg1 = \"0.0\";\n    XParam.Adapt_arg2 = \"2.0\";\n    XParam.Adapt_arg3 = \"zb\";\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n\n\n\n    // Copy zs from CPU to GPU ... again\n    CopytoGPU(XParam.nblkmem, XParam.blksize, XModel.evolv.zs, XModel_g.evolv_o.zs);\n    CopytoGPU(XParam.nblkmem, XParam.blksize, XModel.evolv.zs, XModel_g.evolv.zs);\n\n    cudaStream_t streams[2];\n    CUDA_CHECK(cudaStreamCreate(&amp;streams[0]));\n    CUDA_CHECK(cudaStreamCreate(&amp;streams[1]));\n\n\n    fillHaloC(XParam, XModel.blocks, XModel.evolv.zs);\n    fillHaloGPU(XParam, XModel_g.blocks, streams[0], XModel_g.evolv.zs);\n    fillHaloGPUnew(XParam, XModel_g.blocks, streams[1], XModel_g.evolv_o.zs);\n\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    cudaStreamDestroy(streams[0]);\n    cudaStreamDestroy(streams[1]);\n\n\n    //CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.evolv.u, XModel_g.evolv.zs);\n    //CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.evolv.v, XModel_g.evolvo.zs);\n\n    diffArray(XParam, XModel.blocks, \"GPU_old\", true, XModel.evolv.zs, XModel_g.evolv.zs, XModel.evolv.u, XModel.evolv_o.u);\n    diffArray(XParam, XModel.blocks, \"GPU_new\", true, XModel.evolv.zs, XModel_g.evolv_o.zs, XModel.evolv.v, XModel.evolv_o.v);\n\n    return true;\n}\n\ntemplate &lt;class T&gt; int TestInstability(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    Forcing&lt;float&gt; XForcing;\n\n    XForcing = MakValleyBathy(XParam, T(0.4), true, true);\n\n    XParam.conserveElevation = true;\n\n    float maxtopo = std::numeric_limits&lt;float&gt;::min();\n    float mintopo = std::numeric_limits&lt;float&gt;::max();\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            maxtopo = max(XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx], maxtopo);\n            mintopo = min(XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx], mintopo);\n        }\n    }\n\n    // Overrule whatever may be set in the param file\n    XParam.xmax = XForcing.Bathy[0].xmax;\n    XParam.ymax = XForcing.Bathy[0].ymax;\n    XParam.xo = XForcing.Bathy[0].xo;\n    XParam.yo = XForcing.Bathy[0].yo;\n\n    XParam.dx = XForcing.Bathy[0].dx;\n\n    XParam.zsinit = mintopo + 6.9;// Had a water level so that the wet and dry affects the \n    XParam.endtime = 20.0;\n\n    XParam.outputtimestep = XParam.endtime;\n\n    XParam.minlevel = 0;\n    XParam.maxlevel = 2;\n    XParam.initlevel = 0;\n\n    // coarse to fine\n    // Change arg 1 and 2 if the slope is changed\n    XParam.AdaptCrit = \"Targetlevel\";\n    XParam.Adapt_arg1 = \"\";\n    XParam.Adapt_arg2 = \"\";\n    XParam.Adapt_arg3 = \"\";\n\n    StaticForcingP&lt;int&gt; targetlevel;\n    XForcing.targetadapt.push_back(targetlevel);\n\n    XForcing.targetadapt[0].xo = 0.0;\n    XForcing.targetadapt[0].yo = 0.0;\n\n    XForcing.targetadapt[0].xmax = 31.0;\n    XForcing.targetadapt[0].ymax = 31.0;\n    XForcing.targetadapt[0].nx = 32;\n    XForcing.targetadapt[0].ny = 32;\n\n    XForcing.targetadapt[0].dx = 1.0;\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.targetadapt[0].val);\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            XForcing.targetadapt[0].val[i + j * XForcing.Bathy[0].nx] = 1;\n        }\n    }\n\n    XForcing.targetadapt[0].val[12 + 12 * XForcing.Bathy[0].nx] = 2;\n\n\n    // Setup Model(s)\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    // Run first full step (i.e. 2 half steps)\n\n    Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n\n    //FlowCPU(XParam, XLoop, XForcing, XModel);\n    HalfStepCPU(XParam, XLoop, XForcing, XModel);\n\n    T maxu = std::numeric_limits&lt;float&gt;::min();\n    T maxv = std::numeric_limits&lt;float&gt;::min();\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                maxu = max(maxu, abs(XModel.evolv.u[i]));\n                maxv = max(maxv, abs(XModel.evolv.v[i]));\n            }\n        }\n    }\n\n    bool test = false;\n\n    if (maxu &gt; T(std::numeric_limits&lt;T&gt;::epsilon() * T(1000.0)) || maxv &gt; T(std::numeric_limits&lt;T&gt;::epsilon() * T(1000.0)))\n    {\n        //test = true;\n        XParam.outvars = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"Su\", \"Sv\",\"dhdx\", \"dhdy\", \"dzsdx\", \"dzsdy\" };\n        InitSave2Netcdf(XParam, XModel);\n\n    }\n    else\n    {\n        test = true;\n    }\n\n\n    return test;\n\n}\n\n\n\n\n\n//TestMultiBathyRough(int gpu, T ref, int scenario)\ntemplate &lt;class T&gt; bool TestMultiBathyRough(int gpu, T ref, int scenario)\n{\n    T Z0 = ref + 0.0;\n    T Z1 = ref + 2.0;\n    T R0 = 0.000001;\n    T R1 = 0.1;\n    T IL = 8.6;\n    T CL = 7.2;\n    T eps;\n    int NX = 21;\n    int NY = 21;\n    double* xz;\n    double* yz;\n    double* map;\n    Param XParam;\n    Forcing&lt;float&gt; XForcing;\n    Model&lt;float&gt; XModel;\n    Model&lt;float&gt; XModel_g;\n    char* name_file_R1;\n\n\n    //Creation of a Bathy file\n\n    xz = (double*)malloc(sizeof(double) * NX);\n    yz = (double*)malloc(sizeof(double) * NY);\n    for (int i = 0; i &lt; NX; i++) { xz[i] = -1.0 + 0.1 * i; }\n    for (int j = 0; j &lt; NY; j++) { yz[j] = -1.0 + 0.1 * j; }\n\n    map = (double*)malloc(sizeof(double) * NY * NX);\n\n    for (int j = 0; j &lt; NY; j++)\n    {\n        for (int i = 0; i &lt; NX; i++)\n        {\n            map[j * NX + i] = Z0; //+ (yz[j] + 1) * 0.5;\n        }\n    }\n    create2dnc(\"Z0_map.nc\", NX, NY, xz, yz, map, \"z\");\n\n    //Creation of a smaller Bathy file\n\n    //xz = (double*)malloc(sizeof(double) * NX);\n    //yz = (double*)malloc(sizeof(double) * NY);\n    for (int i = 0; i &lt; NX; i++) { xz[i] = 0.0 + 0.05 * i; }\n    for (int j = 0; j &lt; NY; j++) { yz[j] = -1.0 + 0.05 * j; }\n\n    //map = (double*)malloc(sizeof(double) * NY * NX);\n\n    //Create the Losses forcing:\n    for (int j = 0; j &lt; NY; j++)\n    {\n        for (int i = 0; i &lt; NX; i++)\n        {\n            map[j * NX + i] = Z1; // -(yz[j] + 1) * 0.5;\n        }\n    }\n    create2dnc(\"Z1_map.nc\", NX, NY, xz, yz, map, \"z\");\n\n    //Creation of a roughness file\n    //xz = (double*)malloc(sizeof(double) * NX);\n    //yz = (double*)malloc(sizeof(double) * NY);\n    for (int i = 0; i &lt; NX; i++) { xz[i] = -1.0 + 0.1 * i; }\n    for (int j = 0; j &lt; NY; j++) { yz[j] = -1.0 + 0.1 * j; }\n\n    //map = (double*)malloc(sizeof(double) * NY * NX);\n\n    for (int j = 0; j &lt; NY; j++)\n    {\n        for (int i = 0; i &lt; NX; i++)\n        {\n            map[j * NX + i] = R0;\n        }\n    }\n    create2dnc(\"R0_map.nc\", NX, NY, xz, yz, map, \"z0\");\n\n    //Creation of a smaller Roughness file\n    //xz = (double*)malloc(sizeof(double) * NX);\n    //yz = (double*)malloc(sizeof(double) * NY);\n    for (int i = 0; i &lt; NX; i++) { xz[i] = 0.0 + 0.05 * i; }\n    for (int j = 0; j &lt; NY; j++) { yz[j] = 0.0 + 0.05 * j; }\n\n    //map = (double*)malloc(sizeof(double) * NY * NX);\n\n    //Create the Losses forcing:\n    for (int j = 0; j &lt; NY; j++)\n    {\n        for (int i = 0; i &lt; NX; i++)\n        {\n            map[j * NX + i] = R1;\n        }\n    }\n    if (scenario &lt; 0.5)\n    {\n        name_file_R1 = \"R1_map.nc\";\n    }\n    else\n    {\n        name_file_R1 = \"1R_map.nc\";\n    }\n    create2dnc(name_file_R1, NX, NY, xz, yz, map, \"z0\");\n\n    //Creation of a refinement file\n    //xz = (double*)malloc(sizeof(double) * NX);\n    //yz = (double*)malloc(sizeof(double) * NY);\n    for (int i = 0; i &lt; NX; i++) { xz[i] = -1.0 + 0.1 * i; }\n    for (int j = 0; j &lt; NY; j++) { yz[j] = -1.0 + 0.1 * j; }\n\n    //map = (double*)malloc(sizeof(double) * NY * NX);\n\n    for (int j = 0; j &lt; NY; j++)\n    {\n        for (int i = 0; i &lt; NX; i++)\n        {\n            map[j * NX + i] = 0;\n            if ((abs(xz[i]) &lt; 0.5) &amp;&amp; (abs(yz[j]) &lt; 0.5))\n            {\n                map[j * NX + i] = 1;\n            }\n        }\n    }\n    create2dnc(\"refinement.nc\", NX, NY, xz, yz, map, \"z\");\n\n    /*// Creation of a rain fall file\n    std::ofstream rain_file(\n        \"rainTest13.txt\", std::ios_base::out | std::ios_base::trunc);\n    rain_file &lt;&lt; \"0.000000\\t10.00\" &lt;&lt; std::endl;\n    rain_file &lt;&lt; \"1000.000\\t10.00\" &lt;&lt; std::endl;\n    rain_file.close();*/\n\n    // Creation of BG_param_test13.txt file\n    std::ofstream param_file(\n        \"BG_param_test13.txt\", std::ios_base::out | std::ios_base::trunc);\n    //Add Bathymetries to the file\n    param_file &lt;&lt; \"bathy = Z0_map.nc?z ;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"bathy = Z1_map.nc?z ;\" &lt;&lt; std::endl;\n    //Add Roughness to the file\n    if (scenario &gt; 1.5)\n    {\n        R1 = 3.56;\n        param_file &lt;&lt; \"cfmap = \" &lt;&lt; R1 &lt;&lt; std::endl;\n        R0 = 3.56;\n    }\n    else\n    {\n        param_file &lt;&lt; \"cfmap = R0_map.nc?z0 ;\" &lt;&lt; std::endl;\n        param_file &lt;&lt; \"cfmap = \" &lt;&lt; name_file_R1 &lt;&lt; \"?z0 ;\" &lt;&lt; std::endl;\n    }\n    //param_file &lt;&lt; \"cfmap = R1_map.nc?z0 ;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"frictionmodel=1 ;\" &lt;&lt; std::endl;\n    //Add refinement to the file\n    param_file &lt;&lt; \"Adaptation = Targetlevel,refinement.nc?z ;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"initlevel = 0; \" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"maxlevel = 1; \" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"minlevel = 0; \" &lt;&lt; std::endl;\n    //Add River forcing\n    //param_file &lt;&lt; \"rainfile = rainTest13.txt ;\" &lt;&lt; std::endl;\n    //Add endtime and outputvar\n    param_file &lt;&lt; \"endtime = 10.0 ;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"outvars = zs,h,u,v,zb,cf;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"dx = 0.01;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"zsinit = 0.1;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"smallnc = 0;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"doubleprecision = 1;\" &lt;&lt; std::endl;\n    if (scenario &gt; 2.5)\n    {\n        param_file &lt;&lt; \"il = \" &lt;&lt; IL &lt;&lt; std::endl;\n        param_file &lt;&lt; \"cl = \" &lt;&lt; CL &lt;&lt; std::endl;\n    }\n\n    param_file.close();\n\n    //read param file\n    Readparamfile(XParam, XForcing, \"BG_param_test13.txt\"); // \"BG_param_test13.txt\");\n\n    //readforcing\n    readforcing(XParam, XForcing);\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    // Run first full step (i.e. 2 half steps)\n\n    //Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n    MainLoop(XParam, XForcing, XModel, XModel_g);\n\n    //if XModel.cf[0]\n    //  XModel.zb\n\n    T maxz = T(-1.0) * std::numeric_limits&lt;float&gt;::max();\n    T minz = std::numeric_limits&lt;float&gt;::max();\n    T maxr = T(-1.0) * std::numeric_limits&lt;float&gt;::max();\n    T minr = std::numeric_limits&lt;float&gt;::max();\n\n\n    printf(\"min float=%f\\n\", std::numeric_limits&lt;float&gt;::min());\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                maxz = max(maxz, abs(XModel.zb[i]));\n                minz = min(minz, abs(XModel.zb[i]));\n                maxr = max(maxr, abs(XModel.cf[i]));\n                minr = min(minr, abs(XModel.cf[i]));\n            }\n        }\n    }\n\n    bool result = false;\n    eps = 0.0000001;\n\n    if ((abs(maxz - Z1) &lt; eps) &amp;&amp; (abs(maxr - R1) &lt; eps) &amp;&amp; (abs(minz - Z0) &lt; eps) &amp;&amp; (abs(minr - R0) &lt; eps))\n    {\n        result = true;\n    }\n    printf(\"\\t\\n\");\n    printf(\"\\t\\tZ max forced : %f, Z max obs :  %f\\n \", Z1, maxz);\n    printf(\"\\t\\tR max forced :  %f, R max obs:  %f\\n\", R1, maxr);\n    printf(\"\\t\\tZ min forced :  %f, Z min obs:  %f\\n\", Z0, minz);\n    printf(\"\\t\\tR min forced : %f, R min obs : %f\\n \", R0, minr);\n\n    if (scenario &gt; 2.5)\n    {\n        T maxil = T(-1.0) * std::numeric_limits&lt;float&gt;::max();\n        T minil = std::numeric_limits&lt;float&gt;::max();\n        T maxcl = T(-1.0) * std::numeric_limits&lt;float&gt;::max();\n        T mincl = std::numeric_limits&lt;float&gt;::max();\n\n\n        //printf(\"min float=%f\\n\", std::numeric_limits&lt;float&gt;::min());\n\n        for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n        {\n            int ib = XModel.blocks.active[ibl];\n            for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n            {\n                for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n                {\n                    int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                    maxil = max(maxil, abs(XModel.il[i]));\n                    minil = min(minil, abs(XModel.il[i]));\n                    maxcl = max(maxcl, abs(XModel.cl[i]));\n                    mincl = min(mincl, abs(XModel.cl[i]));\n                }\n            }\n        }\n\n        bool result = false;\n        eps = 0.0000001;\n        // IL is expected here to be value when dry and 0 where wet at the begining of the computation\n        if ((abs(maxil - IL) &lt; eps) &amp;&amp; (abs(maxcl - CL) &lt; eps) &amp;&amp; (abs(minil - T(0.0)) &lt; eps) &amp;&amp; (abs(mincl - CL) &lt; eps))\n        {\n            result = true;\n        }\n    }\n\n    return result;\n}\n\n\n\n//TestFlexibleOutputTimes(int gpu, T ref, int scenario)\ntemplate &lt;class T&gt; bool TestFlexibleOutputTimes(int gpu, T ref, int scenario)\n{\n    T Z0 = ref + 0.0;\n    T Z1 = ref + 2.0;\n    T eps;\n    int NX = 21;\n    int NY = 21;\n    double* xz;\n    double* yz;\n    double* map;\n    Param XParam;\n    Forcing&lt;float&gt; XForcing;\n    Model&lt;float&gt; XModel;\n    Model&lt;float&gt; XModel_g;\n    char* name_file_R1;\n\n\n    //Creation of a Bathy file\n\n    xz = (double*)malloc(sizeof(double) * NX);\n    yz = (double*)malloc(sizeof(double) * NY);\n    for (int i = 0; i &lt; NX; i++) { xz[i] = -1.0 + 0.1 * i; }\n    for (int j = 0; j &lt; NY; j++) { yz[j] = -1.0 + 0.1 * j; }\n\n    map = (double*)malloc(sizeof(double) * NY * NX);\n\n    for (int j = 0; j &lt; NY; j++)\n    {\n        for (int i = 0; i &lt; NX; i++)\n        {\n            map[j * NX + i] = Z0; //+ (yz[j] + 1) * 0.5;\n        }\n    }\n    create2dnc(\"Z0_map.nc\", NX, NY, xz, yz, map, \"z\");\n\n\n    // Creation of BG_param_test13.txt file\n    std::ofstream param_file(\n        \"BG_param_test15.txt\", std::ios_base::out | std::ios_base::trunc);\n    //Add Bathymetries to the file\n    param_file &lt;&lt; \"bathy = Z0_map.nc?z ;\" &lt;&lt; std::endl;\n\n    //Add endtime and outputvar\n    param_file &lt;&lt; \"endtime = 11.0 ;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"reftime = 2020-01-01T00:00:00 ;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"outvars = zs,h,u,v,zb;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"dx = 0.05;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"zsinit = 0.1;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"smallnc = 0;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"doubleprecision = 1;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"Toutput = 1|2|5, 2020-01-01T00:00:08,  9.5;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"outzone = Test15_zoom1.nc,0.2,0.6,-0.2,0.2, 2020-01-01T00:00:02|0.008min|2020-01-01T00:00:03, 5.6,6.9;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"outzone = Test15_zoom2.nc,0.2,0.6,-0.2,0.2, 8.1|0.7|, 5.6;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"outzone = Test15_zoom3.nc,0.2,0.6,-0.2,0.2, |0.8|2;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"outzone = Test15_zoom4.nc,0.2,0.6,-0.2,0.2, 8.2||9;\" &lt;&lt; std::endl; // Here the step in not given so assumed infinite\n    param_file &lt;&lt; \"outzone = Test15_zoom5.nc,0.2,0.6,-0.2,0.2;\" &lt;&lt; std::endl;\n    param_file.close();\n\n    //read param file\n    Readparamfile(XParam, XForcing, \"BG_param_test15.txt\"); // \"BG_param_test13.txt\");\n\n    //readforcing\n    readforcing(XParam, XForcing);\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    // Run first full step (i.e. 2 half steps)\n\n    //Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n    //MainLoop(XParam, XForcing, XModel, XModel_g);\n\n    //TEST 1: reading and default values check:\n    bool result = false;\n\n    if (XModel.OutputT.size()==20)\n    {\n        result = true;\n    }\n\n    /*\n    if (!XParam.Toutput.end == 11.0)\n        result = false;\n    if (!XParam.Toutput.val[1] == 9.5)\n        result = false;\n\n    if (!XParam.outzone[2].Toutput.init == 0.0)\n        result = false;\n    if (!XParam.outzone[3].Toutput.tstep == 11.0)\n        result = false;\n    if (!XParam.outzone[4].Toutput.tstep == 1.0)\n        result = false;\n        */\n\n\n\n    return result;\n}\n\n\n\n\n\n\ntemplate &lt;class T&gt; void TestFirsthalfstep(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n\n    // Setup Model(s)\n\n    XParam.outvars = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"Su\", \"Sv\",\"dhdx\", \"dhdy\", \"dzsdx\", \"dzsdy\", \"dzbdx\", \"dzbdy\" };\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    // Run first full step (i.e. 2 half steps)\n\n    Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n\n    if (XParam.GPUDEVICE &lt; 0)\n    {\n        //FlowCPU(XParam, XLoop, XForcing, XModel);\n        HalfStepCPU(XParam, XLoop, XForcing, XModel);\n    }\n    else\n    {\n        HalfStepGPU(XParam, XLoop, XForcing, XModel_g);\n\n        for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n        {\n            CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[XParam.outvars[ivar]], XModel_g.OutputVarMap[XParam.outvars[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n        }\n\n    }\n\n    T maxu = std::numeric_limits&lt;float&gt;::min();\n    T maxv = std::numeric_limits&lt;float&gt;::min();\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                maxu = max(maxu, abs(XModel.evolv.u[i]));\n                maxv = max(maxv, abs(XModel.evolv.v[i]));\n            }\n        }\n    }\n\n    bool test = false;\n\n    //test = true;\n\n    InitSave2Netcdf(XParam, XModel);\n\n}\n\n\ntemplate &lt;class T&gt; void Testzbinit(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n\n    // Setup Model(s)\n\n    XParam.outvars = { \"zb\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"Su\", \"Sv\",\"dhdx\", \"dhdy\", \"dzsdx\", \"dzsdy\", \"dzbdx\", \"dzbdy\" };\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    // Run first full step (i.e. 2 half steps)\n\n    Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n\n\n    //FlowCPU(XParam, XLoop, XForcing, XModel);\n    //HalfStepCPU(XParam, XLoop, XForcing, XModel);\n    if (XParam.conserveElevation)\n    {\n        refine_linear(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    }\n\n    //HalfStepGPU(XParam, XLoop, XForcing, XModel_g);\n\n    if (XParam.conserveElevation)\n    {\n        refine_linearGPU(XParam, XModel_g.blocks, XModel_g.zb, XModel_g.grad.dzbdx, XModel_g.grad.dzbdy);\n    }\n\n    //for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n    //{\n    //  CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[XParam.outvars[ivar]], XModel_g.OutputVarMap[XParam.outvars[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n    //}\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, XParam.outvars, true);\n\n    //T maxu = std::numeric_limits&lt;float&gt;::min();\n    //T maxv = std::numeric_limits&lt;float&gt;::min();\n    /*\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                maxu = max(maxu, abs(XModel.evolv.u[i]));\n                maxv = max(maxv, abs(XModel.evolv.v[i]));\n            }\n        }\n    }\n    */\n    bool test = false;\n\n    //test = true;\n\n    //InitSave2Netcdf(XParam, XModel);\n\n\n\n}\n\n\ntemplate &lt;class T&gt; int TestAIObnd(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g, bool bottop, bool flip, bool withaoi)\n{\n    Forcing&lt;float&gt; XForcing;\n\n    XForcing = MakValleyBathy(XParam, T(0.4), bottop, flip);\n\n    XParam.conserveElevation = true;\n\n    float maxtopo = std::numeric_limits&lt;float&gt;::min();\n    float mintopo = std::numeric_limits&lt;float&gt;::max();\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            maxtopo = max(XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx], maxtopo);\n            mintopo = min(XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx], mintopo);\n        }\n    }\n\n    // Overrule whatever may be set in the param file\n    XParam.xmax = XForcing.Bathy[0].xmax;\n    XParam.ymax = XForcing.Bathy[0].ymax;\n    XParam.xo = XForcing.Bathy[0].xo;\n    XParam.yo = XForcing.Bathy[0].yo;\n\n    XParam.dx = XForcing.Bathy[0].dx;\n\n    //XParam.zsinit = mintopo - 6.9;// Had a water level so that the wet and dry affects the \n    XParam.zsinit = mintopo - 9.9;// Had a water level so that the wet and dry affects the \n    XParam.endtime = 20.0;\n\n    XParam.dtmin = 0.00000001;\n    XParam.aoibnd = 0;\n\n    XParam.outputtimestep = XParam.endtime;\n\n    std::ofstream aoi_file(\n        \"testaoi.tmp\", std::ios_base::out | std::ios_base::trunc);\n    aoi_file &lt;&lt; \"5.0 3.0\" &lt;&lt; std::endl;\n    aoi_file &lt;&lt; \"27.0 3.0\" &lt;&lt; std::endl;\n    aoi_file &lt;&lt; \"27.0 27.0\" &lt;&lt; std::endl;\n    aoi_file &lt;&lt; \"5.0 27.0\" &lt;&lt; std::endl;\n    aoi_file &lt;&lt; \"5.0 3.0\" &lt;&lt; std::endl;\n    aoi_file.close(); //destructor implicitly does it\n\n    /*\n    std::ofstream aoi_file(\n        \"testaoi.tmp\", std::ios_base::out | std::ios_base::trunc);\n    aoi_file &lt;&lt; \"-5.0 -3.0\" &lt;&lt; std::endl;\n    aoi_file &lt;&lt; \"27.0 -3.0\" &lt;&lt; std::endl;\n    aoi_file &lt;&lt; \"27.0 270.0\" &lt;&lt; std::endl;\n    aoi_file &lt;&lt; \"-5.0 270.0\" &lt;&lt; std::endl;\n    aoi_file &lt;&lt; \"-5.0 -3.0\" &lt;&lt; std::endl;\n    aoi_file.close(); //destructor implicitly does it\n    */\n    if (withaoi)\n    {\n        XForcing.AOI.file = \"testaoi.tmp\";\n        XForcing.AOI.active = true;\n        XForcing.AOI.poly = readPolygon(XForcing.AOI.file);\n    }\n    /*\n    if (bottop==false &amp;&amp; flip==false)\n    {\n        XForcing.left.type = 0;\n    }\n    if (bottop == false &amp;&amp; flip == true)\n    {\n        XForcing.right.type = 0;\n    }\n    if (bottop == true &amp;&amp; flip == false)\n    {\n        XForcing.bot.type = 0;\n    }\n    if (bottop == true &amp;&amp; flip == true)\n    {\n        XForcing.top.type = 0;\n    }\n    */\n    XParam.minlevel = 3;\n    XParam.maxlevel = 3;\n    XParam.initlevel = 3;\n    /*\n    // coarse to fine\n    // Change arg 1 and 2 if the slope is changed\n    XParam.AdaptCrit = \"Targetlevel\";\n    XParam.Adapt_arg1 = \"\";\n    XParam.Adapt_arg2 = \"\";\n    XParam.Adapt_arg3 = \"\";\n\n    StaticForcingP&lt;int&gt; targetlevel;\n    XForcing.targetadapt.push_back(targetlevel);\n\n    XForcing.targetadapt[0].xo = 0.0;\n    XForcing.targetadapt[0].yo = 0.0;\n\n    XForcing.targetadapt[0].xmax = 31.0;\n    XForcing.targetadapt[0].ymax = 31.0;\n    XForcing.targetadapt[0].nx = 32;\n    XForcing.targetadapt[0].ny = 32;\n\n    XForcing.targetadapt[0].dx = 1.0;\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.targetadapt[0].val);\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            XForcing.targetadapt[0].val[i + j * XForcing.Bathy[0].nx] = 1;\n        }\n    }\n\n    XForcing.targetadapt[0].val[12 + 12 * XForcing.Bathy[0].nx] = 2;\n    */\n    // Add rain forcing\n    //Create a temporary file with river fluxes\n    float Q = 1;\n    std::ofstream river_file(\n        \"testriver.tmp\", std::ios_base::out | std::ios_base::trunc);\n    river_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file &lt;&lt; \"3600.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file.close(); //destructor implicitly does it\n\n    River thisriver;\n    thisriver.Riverflowfile = \"testriver.tmp\";\n    thisriver.xstart = 10;\n    thisriver.xend = 12;\n    thisriver.ystart = 10;\n    thisriver.yend = 12;\n\n    XForcing.rivers.push_back(thisriver);\n\n\n    XForcing.rivers[0].flowinput = readFlowfile(XForcing.rivers[0].Riverflowfile, XParam.reftime);\n\n\n    // Setup Model(s)\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n    T initVol = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.delta, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                initVol = initVol + XModel.evolv.h[i] * delta * delta;\n            }\n        }\n    }\n\n\n    MainLoop(XParam, XForcing, XModel, XModel_g);\n\n    T TheoryInput = Q * XParam.endtime;\n\n\n    T SimulatedVolume = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.delta, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                SimulatedVolume = SimulatedVolume + XModel.evolv.h[i] * delta * delta;\n\n            }\n        }\n    }\n\n    SimulatedVolume = SimulatedVolume - initVol;\n\n    T error = abs(SimulatedVolume - TheoryInput);\n\n    int modelgood = error / TheoryInput &lt; 0.001;\n\n    printf(\"\\nSim Vol = %f, theory=%f, Error = %f, (%f %%) \\n\", SimulatedVolume, TheoryInput, error, (error / TheoryInput) * 100);\n\n    //log(\"#####\");\n    return modelgood;\n}\n\n\ntemplate &lt;class T&gt; __global__ void vectoroffsetGPU(int nx, T offset, T* z)\n{\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (idx &lt; nx)\n    {\n        z[idx] = z[idx] + offset;\n    }\n}\n\ntemplate &lt;class T&gt; int TestPinMem(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    T* zf, *zf_g, * zf_recov;\n\n\n    int nx = 32;\n    int ny = 1;\n\n    int nelem = nx * ny;\n\n\n    AllocateMappedMemCPU(nx, ny, XParam.GPUDEVICE, zf);\n\n\n    AllocateCPU(nx, ny, zf_recov);\n\n    for (int i = 0; i &lt; nx; i++)\n    {\n        for (int j = 0; j &lt; ny; j++)\n        {\n            zf[i + j * nx] = i + j * nx +T(0.25);\n\n        }\n    }\n\n    T checkrem = T(0.0);\n\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        AllocateMappedMemGPU(nx, ny, XParam.GPUDEVICE, zf_g, zf);\n\n\n\n        dim3 block(16);\n        dim3 grid((unsigned int)ceil(nelem / (float)block.x));\n\n        vectoroffsetGPU &lt;&lt;&lt;grid, block &gt;&gt;&gt; (nelem, T(1.0), zf_g);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        CUDA_CHECK(cudaMemcpy(zf_recov, zf_g, nx * ny * sizeof(T), cudaMemcpyDeviceToHost));\n\n\n\n\n        for (int i = 0; i &lt; nx; i++)\n        {\n            for (int j = 0; j &lt; ny; j++)\n            {\n\n                checkrem = checkrem + abs(zf[i + j * nx] - zf_recov[i + j * nx]);\n            }\n        }\n    }\n    int modelgood = checkrem &lt; 1.e-6f;\n\n    if (checkrem &gt; 1.e-6f)\n    {\n        printf(\"\\n Test Failed error = %e \\n\", checkrem);\n        return modelgood;\n    }\n    else\n    {\n        printf(\"\\n Test Success error = %e \\n\", checkrem);\n    }\n\n\n\n    return modelgood;\n}\ntemplate int TestPinMem&lt;float&gt;(Param XParam, Model&lt;float&gt; XModel, Model&lt;float&gt; XModel_g);\ntemplate int TestPinMem&lt;double&gt;(Param XParam, Model&lt;double&gt; XModel, Model&lt;double&gt; XModel_g);\n\n\n\n\ntemplate &lt;class T&gt; Forcing&lt;float&gt; MakValleyBathy(Param XParam, T slope, bool bottop, bool flip)\n{\n    //\n\n    Forcing&lt;float&gt; XForcing;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    float* dummybathy;\n\n    XForcing.Bathy.push_back(bathy);\n\n    XForcing.Bathy[0].xo = 0.0;\n    XForcing.Bathy[0].yo = 0.0;\n\n    XForcing.Bathy[0].xmax = 31.0;\n    XForcing.Bathy[0].ymax = 31.0;\n    XForcing.Bathy[0].nx = 32;\n    XForcing.Bathy[0].ny = 32;\n\n    XForcing.Bathy[0].dx = 1.0;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n\n    T x, y;\n    T center = T(10.5);\n\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, dummybathy);\n\n\n    float maxtopo = std::numeric_limits&lt;float&gt;::min();\n    float mintopo = std::numeric_limits&lt;float&gt;::max();\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            x = T(XForcing.Bathy[0].xo + i * XForcing.Bathy[0].dx);\n            y = T(XForcing.Bathy[0].yo + j * XForcing.Bathy[0].dx);\n\n\n            dummybathy[i + j * XForcing.Bathy[0].nx] = float(ValleyBathy(y, x, slope, center));\n\n            maxtopo = max(dummybathy[i + j * XForcing.Bathy[0].nx], maxtopo);\n\n\n        }\n    }\n\n    // Make surrounding wall\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n\n        dummybathy[0 + j * XForcing.Bathy[0].nx] = maxtopo + 5.0f;\n        dummybathy[1 + j * XForcing.Bathy[0].nx] = maxtopo + 5.0f;\n\n        dummybathy[j + 0 * XForcing.Bathy[0].nx] = maxtopo + 5.0f;\n        dummybathy[j + 1 * XForcing.Bathy[0].nx] = maxtopo + 5.0f;\n\n        dummybathy[(XForcing.Bathy[0].nx - 1) + j * XForcing.Bathy[0].nx] = maxtopo + 5.0f;\n        dummybathy[(XForcing.Bathy[0].nx - 2) + j * XForcing.Bathy[0].nx] = maxtopo + 5.0f;\n\n        dummybathy[j + (XForcing.Bathy[0].ny - 1) * XForcing.Bathy[0].nx] = maxtopo + 5.0f;\n        dummybathy[j + (XForcing.Bathy[0].ny - 2) * XForcing.Bathy[0].nx] = maxtopo + 5.0f;\n\n\n    }\n\n    // make a specially elevated spot \n\n    dummybathy[(XForcing.Bathy[0].nx - 1) + 0 * XForcing.Bathy[0].nx] = maxtopo + 10.0f;\n    dummybathy[(XForcing.Bathy[0].nx - 2) + 0 * XForcing.Bathy[0].nx] = maxtopo + 10.0f;\n\n    dummybathy[(XForcing.Bathy[0].nx - 1) + 1 * XForcing.Bathy[0].nx] = maxtopo + 10.0f;\n    dummybathy[(XForcing.Bathy[0].nx - 2) + 1 * XForcing.Bathy[0].nx] = maxtopo + 10.0f;\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            mintopo = min(dummybathy[i + j * XForcing.Bathy[0].nx], mintopo);\n        }\n    }\n\n    // Flip or rotate the bathy according to what is requested\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            if (!flip &amp;&amp; !bottop)\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = dummybathy[i + j * XForcing.Bathy[0].nx];\n            }\n            else if (flip &amp;&amp; !bottop)\n            {\n                XForcing.Bathy[0].val[(XForcing.Bathy[0].nx - 1 - i) + j * XForcing.Bathy[0].nx] = dummybathy[i + j * XForcing.Bathy[0].nx];\n            }\n            else if (!flip &amp;&amp; bottop)\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = dummybathy[j + i * XForcing.Bathy[0].nx];\n            }\n            else if (flip &amp;&amp; bottop)\n            {\n                XForcing.Bathy[0].val[i + (XForcing.Bathy[0].ny - 1 - j) * XForcing.Bathy[0].nx] = dummybathy[j + i * XForcing.Bathy[0].nx];\n            }\n        }\n    }\n\n    free(dummybathy);\n\n    return XForcing;\n\n}\n\n\nvoid alloc_init2Darray(float** arr, int NX, int NY)\n{\n    int i, j;\n    //Allocation\n    arr = (float**)malloc(sizeof(float*) * NX);\n    for (i = 0; i &lt; NX; i++) {\n        arr[i] = (float*)malloc(sizeof(float) * NY);\n    }\n\n    //arr = (int **)malloc(sizeof(int *) * NX);\n    //for (i = 0; i &lt; NX; i++) {\n    //  arr[i] = (int *)malloc(sizeof(int) * NY);\n    //}\n    //Initialisation\n    for (i = 0; i &lt; NX; i++) {\n        for (j = 0; j &lt; NY; j++) {\n            arr[i][j] = 0;\n        }\n    }\n}\n\nvoid init3Darray(float*** arr, int rows, int cols, int depths)\n{\n    int i, j, k;\n    for (i = 0; i &lt; rows; i++) {\n        for (j = 0; j &lt; cols; j++) {\n            for (k = 0; k &lt; depths; k++)\n            {\n                arr[i][j][k] = 0;\n            }\n        }\n    }\n}\n\ntemplate &lt;class T&gt; void fillrandom(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int n = memloc(XParam, ix, iy, ib);\n                z[n] = T(rand()) / T(RAND_MAX);\n            }\n        }\n    }\n}\ntemplate void fillrandom&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z);\ntemplate void fillrandom&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z);\n\ntemplate &lt;class T&gt; void fillgauss(Param XParam, BlockP&lt;T&gt; XBlock, T amp, T* z)\n{\n    T delta, x, y;\n    T cc = T(0.05) * (XParam.xmax - XParam.xo);\n    T xorigin = XParam.xo + T(0.5) * (XParam.xmax - XParam.xo);\n    T yorigin = XParam.yo + T(0.5) * (XParam.ymax - XParam.yo);\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XBlock.active[ibl];\n        delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int n = memloc(XParam, ix, iy, ib);\n                x = T(XParam.xo + XBlock.xo[ib] + ix * delta);\n                y = T(XParam.yo + XBlock.yo[ib] + iy * delta);\n                z[n] = z[n] + amp * exp(T(-1.0) * T(((x - xorigin) * (x - xorigin) + (y - yorigin) * (y - yorigin)) / (2.0 * cc * cc)));\n\n\n            }\n        }\n    }\n}\ntemplate void fillgauss&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float amp, float* z);\ntemplate void fillgauss&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double amp, double* z);\n\ntemplate &lt;class T&gt;\nvoid TestingOutput(Param XParam, Model&lt;T&gt; XModel)\n{\n    std::string outvar;\n\n    Loop&lt;T&gt; XLoop;\n    // GPU stuff\n\n\n    XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    XLoop.totaltime = 0.0;\n\n    XLoop.nextoutputtime = 0.2;\n\n    Forcing&lt;float&gt; XForcing;\n\n    //FlowCPU(XParam, XLoop, XModel);\n\n    //log(std::to_string(XForcing.Bathy.val[50]));\n    creatncfileBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, XModel.blocks.outZone[0]);\n    outvar = \"h\";\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, 3, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n    outvar = \"u\";\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, 3, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n    outvar = \"v\";\n    //copyID2var(XParam, XModel.blocks, XModel.OutputVarMap[outvar]);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, 3, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n    outvar = \"zb\";\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, 3, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n    outvar = \"zs\";\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, 3, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n\n\n    FlowCPU(XParam, XLoop, XForcing, XModel);\n\n\n    //outvar = \"cf\";\n    //defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, 3, XModel.cf);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"dhdx\", 3, XModel.grad.dhdx, XModel.blocks.outZone[0]);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"dhdy\", 3, XModel.grad.dhdy, XModel.blocks.outZone[0]);\n\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"Fhv\", 3, XModel.flux.Fhv, XModel.blocks.outZone[0]);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"Fhu\", 3, XModel.flux.Fhu, XModel.blocks.outZone[0]);\n\n\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"Fqux\", 3, XModel.flux.Fqux, XModel.blocks.outZone[0]);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"Fquy\", 3, XModel.flux.Fquy, XModel.blocks.outZone[0]);\n\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"Fqvx\", 3, XModel.flux.Fqvx, XModel.blocks.outZone[0]);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"Fqvy\", 3, XModel.flux.Fqvy, XModel.blocks.outZone[0]);\n\n\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"Su\", 3, XModel.flux.Su, XModel.blocks.outZone[0]);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"Sv\", 3, XModel.flux.Sv, XModel.blocks.outZone[0]);\n\n\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"dh\", 3, XModel.adv.dh, XModel.blocks.outZone[0]);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"dhu\", 3, XModel.adv.dhu, XModel.blocks.outZone[0]);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"dhv\", 3, XModel.adv.dhv, XModel.blocks.outZone[0]);\n\n    writenctimestep(XParam.outfile, XLoop.totaltime + XLoop.dt);\n\n\n    outvar = \"h\";\n    writencvarstepBUQ(XParam, 3, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n\n    outvar = \"zs\";\n    writencvarstepBUQ(XParam, 3, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n    outvar = \"u\";\n    writencvarstepBUQ(XParam, 3, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n    outvar = \"v\";\n    writencvarstepBUQ(XParam, 3, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n\n}\n\ntemplate void TestingOutput&lt;float&gt;(Param XParam, Model&lt;float&gt; XModel);\ntemplate void TestingOutput&lt;double&gt;(Param XParam, Model&lt;double&gt; XModel);\n\ntemplate &lt;class T&gt; void copyID2var(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int n = memloc(XParam, ix, iy, ib);\n                z[n] = T(ib);\n            }\n        }\n    }\n\n}\n\ntemplate void copyID2var&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z);\ntemplate void copyID2var&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z);\n\n\ntemplate &lt;class T&gt; void copyBlockinfo2var(Param XParam, BlockP&lt;T&gt; XBlock, int* blkinfo, T* z)\n{\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        int info = blkinfo[ib];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int n = memloc(XParam, ix, iy, ib);\n                z[n] = T(info);\n            }\n        }\n    }\n\n}\ntemplate void copyBlockinfo2var&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, int* blkinfo, float* z);\ntemplate void copyBlockinfo2var&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, int* blkinfo, double* z);\n\n\ntemplate &lt;class T&gt; void CompareCPUvsGPU(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g, std::vector&lt;std::string&gt; varlist, bool checkhalo)\n{\n    Loop&lt;T&gt; XLoop;\n    // GPU stuff\n\n\n    XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    XLoop.totaltime = 0.0;\n\n    XLoop.nextoutputtime = 3600.0;\n\n\n    T* gpureceive;\n    T* diff;\n\n    //Forcing&lt;float&gt; XForcing;\n\n    AllocateCPU(XParam.nblkmem, XParam.blksize, gpureceive);\n    AllocateCPU(XParam.nblkmem, XParam.blksize, diff);\n\n\n    //============================================\n    // Compare gradients for evolving parameters\n\n    // calculate difference\n    //diffArray(XParam, XLoop, XModel.blocks, XModel.evolv.h, XModel_g.evolv.h, XModel.evolv_o.u);\n    /*\n    creatncfileBUQ(XParam, XModel.blocks);\n\n    for (int ivar = 0; ivar &lt; varlist.size(); ivar++)\n    {\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, varlist[ivar], 3, XModel.OutputVarMap[varlist[ivar]], XModel.blocks.outZone[0]);\n    }\n    */\n    /*\n    std::string varname = \"dt\";\n    if (abs(dtgpu - dtcpu) &lt; (XLoop.epsilon * 2))\n    {\n        log(varname + \" PASS\");\n    }\n    else\n    {\n        log(varname + \" FAIL: \" + \" GPU(\" + std::to_string(dtgpu) + \") - CPU(\"+std::to_string(dtcpu) +\") =  difference: \"+  std::to_string(abs(dtgpu - dtcpu)) + \" Eps: \" + std::to_string(XLoop.epsilon));\n\n    }\n    */\n    //Check variable\n    for (int ivar = 0; ivar &lt; varlist.size(); ivar++)\n    {\n        diffArray(XParam, XModel.blocks, varlist[ivar], checkhalo, XModel.OutputVarMap[varlist[ivar]], XModel_g.OutputVarMap[varlist[ivar]], gpureceive, diff);\n    }\n\n\n\n    free(gpureceive);\n    free(diff);\n\n}\ntemplate void CompareCPUvsGPU&lt;float&gt;(Param XParam, Model&lt;float&gt; XModel, Model&lt;float&gt; XModel_g, std::vector&lt;std::string&gt; varlist, bool checkhalo);\ntemplate void CompareCPUvsGPU&lt;double&gt;(Param XParam, Model&lt;double&gt; XModel, Model&lt;double&gt; XModel_g, std::vector&lt;std::string&gt; varlist, bool checkhalo);\n\n\ntemplate &lt;class T&gt; void diffdh(Param XParam, BlockP&lt;T&gt; XBlock, T* input, T* output, T* shuffle)\n{\n    int iright, itop;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XBlock.active[ibl];\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                iright = memloc(XParam.halowidth, XParam.blkmemwidth, ix + 1, iy, ib);\n                itop = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy + 1, ib);\n\n                output[i] = input[iright] - input[i];\n                shuffle[i] = input[iright];\n            }\n        }\n    }\n}\n\ntemplate &lt;class T&gt; void diffSource(Param XParam, BlockP&lt;T&gt; XBlock, T* Fqux, T* Su, T* output)\n{\n    int iright, itop;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XBlock.active[ibl];\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                iright = memloc(XParam.halowidth, XParam.blkmemwidth, ix + 1, iy, ib);\n                itop = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy + 1, ib);\n\n                output[i] = Fqux[i] - Su[iright];\n                //shuffle[i] = input[iright];\n            }\n        }\n    }\n}\n\ntemplate &lt;class T&gt; void diffArray(Param XParam, BlockP&lt;T&gt; XBlock, std::string varname, bool checkhalo, T* cpu, T* gpu, T* dummy, T* out)\n{\n    T diff, maxdiff, rmsdiff;\n    unsigned int nit = 0;\n    int ixmd, iymd, ibmd;\n    //copy GPU back to the CPU (store in dummy)\n    CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, dummy, gpu);\n\n\n    T hugeposval = std::numeric_limits&lt;T&gt;::max();\n    T hugenegval = T(-1.0) * hugeposval;\n    T epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    rmsdiff = T(0.0);\n    maxdiff = hugenegval;\n    ixmd = 0;\n    iymd = 0;\n    ibmd = 0;\n\n    // calculate difference\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XBlock.active[ibl];\n\n        int yst = checkhalo ? -1 : 0;\n        int ynd = checkhalo ? XParam.blkwidth + 1 : XParam.blkwidth;\n\n        int xst = checkhalo ? -1 : 0;\n        int xnd = checkhalo ? XParam.blkwidth + 1 : XParam.blkwidth;\n\n        for (int iy = yst; iy &lt; ynd; iy++)\n        {\n            for (int ix = xst; ix &lt; xnd; ix++)\n            {\n                int n = memloc(XParam, ix, iy, ib);\n                diff = dummy[n] - cpu[n];\n\n                if (abs(diff) &gt;= maxdiff)\n                {\n                    maxdiff = utils::max(abs(diff), maxdiff);\n                    ixmd = ix;\n                    iymd = iy;\n                    ibmd = ib;\n                }\n\n                rmsdiff = rmsdiff + utils::sq(diff);\n                nit++;\n                out[n] = diff;\n            }\n        }\n\n    }\n\n\n    rmsdiff = rmsdiff / nit;\n\n\n\n    if (maxdiff &lt;= T(10000.0) * (epsilon))\n    {\n        log(varname + \" PASS\");\n    }\n    else\n    {\n        creatncfileBUQ(XParam, XBlock);\n        log(varname + \" FAIL: \" + \" Max difference: \" + std::to_string(maxdiff) + \" (at: ix = \" + std::to_string(ixmd) + \" iy = \" + std::to_string(iymd) + \" ib = \" + std::to_string(ibmd) + \") RMS difference: \" + std::to_string(rmsdiff) + \" Eps: \" + std::to_string(epsilon));\n        defncvarBUQ(XParam, XBlock.active, XBlock.level, XBlock.xo, XBlock.yo, varname + \"_CPU\", 3, cpu, XBlock.outZone[0]);\n        defncvarBUQ(XParam, XBlock.active, XBlock.level, XBlock.xo, XBlock.yo, varname + \"_GPU\", 3, dummy, XBlock.outZone[0]);\n        defncvarBUQ(XParam, XBlock.active, XBlock.level, XBlock.xo, XBlock.yo, varname + \"_diff\", 3, out, XBlock.outZone[0]);\n    }\n\n\n\n\n}\n</code></pre>"},{"location":"BGFlood/Testing_8h/","title":"File Testing.h","text":""},{"location":"BGFlood/Testing_8h/#file-testingh","title":"File Testing.h","text":"<p>FileList &gt; src &gt; Testing.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"ReadInput.h\"</code></li> <li><code>#include \"ReadForcing.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Mesh.h\"</code></li> <li><code>#include \"Setup_GPU.h\"</code></li> <li><code>#include \"Mainloop.h\"</code></li> <li><code>#include \"FlowCPU.h\"</code></li> <li><code>#include \"FlowGPU.h\"</code></li> <li><code>#include \"Adaptation.h\"</code></li> <li><code>#include \"utctime.h\"</code></li> </ul>"},{"location":"BGFlood/Testing_8h/#public-functions","title":"Public Functions","text":"Type Name void CompareCPUvsGPU (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g, std::vector&lt; std::string &gt; varlist, bool checkhalo)  bool GaussianHumptest (T zsnit, int gpu, bool compare)  bool MassConserveSteepSlope (T zsnit, int gpu)  bool Rainlossestest (T zsnit, int gpu, float alpha)  bool Raintest (T zsnit, int gpu, float alpha, int engine)  bool Raintestinput (int gpu)  std::vector&lt; float &gt; Raintestmap (int gpu, int dimf, T zinit)  bool Rivertest (T zsnit, int gpu)  bool TestFlexibleOutputTimes (int gpu, T ref, int scenario)  bool TestMultiBathyRough (int gpu, T ref, int secnario)  bool Testing (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  void TestingOutput (Param XParam, Model&lt; T &gt; XModel)  bool ZoneOutputTest (int nzones, T zsinit)  void copyBlockinfo2var (Param XParam, BlockP&lt; T &gt; XBlock, int * blkinfo, T * z)  void copyID2var (Param XParam, BlockP&lt; T &gt; XBlock, T * z)  bool testboundaries (Param XParam, T maxslope)"},{"location":"BGFlood/Testing_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Testing_8h/#function-comparecpuvsgpu","title":"function CompareCPUvsGPU","text":"<pre><code>template&lt;class T&gt;\nvoid CompareCPUvsGPU (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g,\n    std::vector&lt; std::string &gt; varlist,\n    bool checkhalo\n) \n</code></pre> <p>This function compares the Valiables in a CPU model and a GPU models This function is quite useful when checking both are identical enough one needs to provide a list (vector&lt;string&gt;) of variable to check </p>"},{"location":"BGFlood/Testing_8h/#function-gaussianhumptest","title":"function GaussianHumptest","text":"<pre><code>template&lt;class T&gt;\nbool GaussianHumptest (\n    T zsnit,\n    int gpu,\n    bool compare\n) \n</code></pre> <p>This function tests the full hydrodynamics model and compares the results with pre-conmputed (Hard wired) values The function creates it own model setup and mesh independantly to what the user might want to do The setup consist of a centrally located gaussian hump radiating away The test stops at an arbitrary time to compare with 8 values extracted from a identical run in basilisk This function also compares the result of the GPU and CPU code (until they diverge) </p>"},{"location":"BGFlood/Testing_8h/#function-massconservesteepslope","title":"function MassConserveSteepSlope","text":"<pre><code>template&lt;class T&gt;\nbool MassConserveSteepSlope (\n    T zsnit,\n    int gpu\n) \n</code></pre> <p>This function tests the mass conservation of the vertical injection (used for rivers) The function creates it own model setup and mesh independantly to what the user might want to do This starts with a initial water level (zsnit=0 is dry) and runs for 0.1s before comparing results with zsnit=0.1 that is approx 20 steps </p>"},{"location":"BGFlood/Testing_8h/#function-rainlossestest","title":"function Rainlossestest","text":"<pre><code>template&lt;class T&gt;\nbool Rainlossestest (\n    T zsnit,\n    int gpu,\n    float alpha\n) \n</code></pre> <p>This function tests the Initial Losses and Continuous Losses implementation a plain domain, under constant rain. The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsinit=0.0 is dry) and runs for 1s comparing results every 0.1s (that is approx 20 steps) </p>"},{"location":"BGFlood/Testing_8h/#function-raintest","title":"function Raintest","text":"<pre><code>template&lt;class T&gt;\nbool Raintest (\n    T zsnit,\n    int gpu,\n    float alpha,\n    int engine\n) \n</code></pre> <p>This function tests the mass conservation of the spacial injection (used to model rain on grid) The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsnit=0.0 is dry) and runs for 0.1s before comparing results with zsnit=0.1 that is approx 20 steps </p>"},{"location":"BGFlood/Testing_8h/#function-raintestinput","title":"function Raintestinput","text":"<pre><code>bool Raintestinput (\n    int gpu\n) \n</code></pre> <p>This function tests the different inputs for rain forcing. This test is based on the paper Aureli2020, the 3 slopes test with regional rain. The experiment has been presented in Iwagaki1955. The first test compares a time varying rain input using a uniform time serie forcing and a time varying 2D field (with same value). The second test check the 3D rain forcing (comparing it to expected values). </p>"},{"location":"BGFlood/Testing_8h/#function-raintestmap","title":"function Raintestmap","text":"<pre><code>template&lt;class T&gt;\nstd::vector&lt; float &gt; Raintestmap (\n    int gpu,\n    int dimf,\n    T zinit\n) \n</code></pre> <p>\\fnstdvector&lt;float&gt; Raintestmap(int gpu, int dimf, T zinit)</p> <p>This function return the flux at the bottom of the 3 part slope for different types of rain forcings using the test case based on Iwagaki1955 </p>"},{"location":"BGFlood/Testing_8h/#function-rivertest","title":"function Rivertest","text":"<pre><code>template&lt;class T&gt;\nbool Rivertest (\n    T zsnit,\n    int gpu\n) \n</code></pre> <p>This function tests the mass conservation of the vertical injection (used for rivers) The function creates it own model setup and mesh independantly to what the user might want to do This starts with a initial water level (zsnit=0 is dry) and runs for 0.1s before comparing results with zsnit=0.1 that is approx 20 steps </p>"},{"location":"BGFlood/Testing_8h/#function-testflexibleoutputtimes","title":"function TestFlexibleOutputTimes","text":"<pre><code>template&lt;class T&gt;\nbool TestFlexibleOutputTimes (\n    int gpu,\n    T ref,\n    int scenario\n) \n</code></pre>"},{"location":"BGFlood/Testing_8h/#function-testmultibathyrough","title":"function TestMultiBathyRough","text":"<pre><code>template&lt;class T&gt;\nbool TestMultiBathyRough (\n    int gpu,\n    T ref,\n    int secnario\n) \n</code></pre>"},{"location":"BGFlood/Testing_8h/#function-testing","title":"function Testing","text":"<pre><code>template&lt;class T&gt;\nbool Testing (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Testing_8h/#function-testingoutput","title":"function TestingOutput","text":"<pre><code>template&lt;class T&gt;\nvoid TestingOutput (\n    Param XParam,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>OUTDATED? </p>"},{"location":"BGFlood/Testing_8h/#function-zoneoutputtest","title":"function ZoneOutputTest","text":"<pre><code>template&lt;class T&gt;\nbool ZoneOutputTest (\n    int nzones,\n    T zsinit\n) \n</code></pre> <p>This function test the zoned output for a basic configuration</p> <p>This function test the spped and accuracy of a new gradient function gradient are only calculated for zb but assigned to different gradient variable for storage </p>"},{"location":"BGFlood/Testing_8h/#function-copyblockinfo2var","title":"function copyBlockinfo2var","text":"<pre><code>template&lt;class T&gt;\nvoid copyBlockinfo2var (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    int * blkinfo,\n    T * z\n) \n</code></pre> <p>This function copies blick info to an output variable This function is somewhat useful when checking bugs in the mesh refinement or coarsening one needs to provide a pointer(z) allocated on the CPU to store the clockinfo This fonction only works on CPU </p>"},{"location":"BGFlood/Testing_8h/#function-copyid2var","title":"function copyID2var","text":"<pre><code>template&lt;class T&gt;\nvoid copyID2var (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>This function copies block info to an output variable This function is somewhat useful when checking bugs in the mesh refinement or coarsening one needs to provide a pointer(z) allocated on the CPU to store the clockinfo This fonction only works on CPU </p>"},{"location":"BGFlood/Testing_8h/#function-testboundaries","title":"function testboundaries","text":"<pre><code>template&lt;class T&gt;\nbool testboundaries (\n    Param XParam,\n    T maxslope\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Testing.h</code></p>"},{"location":"BGFlood/Testing_8h_source/","title":"File Testing.h","text":""},{"location":"BGFlood/Testing_8h_source/#file-testingh","title":"File Testing.h","text":"<p>File List &gt; src &gt; Testing.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef TESTING_H\n#define TESTING_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"ReadInput.h\"\n#include \"ReadForcing.h\"\n\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"Mesh.h\"\n\n#include \"Setup_GPU.h\"\n#include \"Mainloop.h\"\n#include \"FlowCPU.h\"\n#include \"FlowGPU.h\"\n\n#include \"Adaptation.h\"\n\n#include \"utctime.h\"\n\ntemplate &lt;class T&gt; bool Testing(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g);\n\ntemplate &lt;class T&gt; bool GaussianHumptest(T zsnit, int gpu,bool compare);\n\n\ntemplate &lt;class T&gt; void TestingOutput(Param XParam, Model&lt;T&gt; XModel);\ntemplate &lt;class T&gt; void copyID2var(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\ntemplate &lt;class T&gt; void copyBlockinfo2var(Param XParam, BlockP&lt;T&gt; XBlock, int* blkinfo, T* z);\ntemplate &lt;class T&gt; void CompareCPUvsGPU(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g, std::vector&lt;std::string&gt; varlist, bool checkhalo);\n//template &lt;class T&gt; void Gaussianhump(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g);\ntemplate &lt;class T&gt; std::vector&lt;float&gt; Raintestmap(int gpu, int dimf, T zinit);\nbool Raintestinput(int gpu);\ntemplate &lt;class T&gt; bool Rivertest(T zsnit, int gpu);\ntemplate &lt;class T&gt; bool MassConserveSteepSlope(T zsnit, int gpu);\ntemplate &lt;class T&gt; bool Raintest(T zsnit, int gpu, float alpha,int engine);\ntemplate &lt;class T&gt; bool testboundaries(Param XParam, T maxslope);\ntemplate &lt;class T&gt; bool ZoneOutputTest(int nzones, T zsinit);\ntemplate &lt;class T&gt; bool Rainlossestest(T zsnit, int gpu, float alpha);\ntemplate &lt;class T&gt; bool TestMultiBathyRough(int gpu, T ref, int secnario);\ntemplate &lt;class T&gt; bool TestFlexibleOutputTimes(int gpu, T ref, int scenario);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/","title":"File Updateforcing.cu","text":""},{"location":"BGFlood/Updateforcing_8cu/#file-updateforcingcu","title":"File Updateforcing.cu","text":"<p>FileList &gt; src &gt; Updateforcing.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Updateforcing.h\"</code></li> </ul>"},{"location":"BGFlood/Updateforcing_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ void AddDeformCPU (Param XParam, BlockP&lt; T &gt; XBlock, deformmap&lt; float &gt; defmap, EvolvingP&lt; T &gt; XEv, T scale, T * zb)  __global__ void AddDeformGPU (Param XParam, BlockP&lt; T &gt; XBlock, deformmap&lt; float &gt; defmap, EvolvingP&lt; T &gt; XEv, T scale, T * zb)  __host__ void AddPatmforcingCPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; PAtm, Model&lt; T &gt; XModel)  template __host__ void AddPatmforcingCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; PAtm, Model&lt; double &gt; XModel)  template __host__ void AddPatmforcingCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; PAtm, Model&lt; float &gt; XModel)  __global__ void AddPatmforcingGPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; PAtm, Model&lt; T &gt; XModel)  template __global__ void AddPatmforcingGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; PAtm, Model&lt; double &gt; XModel)  template __global__ void AddPatmforcingGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; PAtm, Model&lt; float &gt; XModel)  __host__ void AddRiverForcing (Param XParam, Loop&lt; T &gt; XLoop, std::vector&lt; River &gt; XRivers, Model&lt; T &gt; XModel)  template __host__ void AddRiverForcing&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, std::vector&lt; River &gt; XRivers, Model&lt; double &gt; XModel)  template __host__ void AddRiverForcing&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, std::vector&lt; River &gt; XRivers, Model&lt; float &gt; XModel)  __host__ void AddinfiltrationImplicitCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, T * il, T * cl, EvolvingP&lt; T &gt; XEv, T * hgw)  template __host__ void AddinfiltrationImplicitCPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, double * il, double * cl, EvolvingP&lt; double &gt; XEv, double * hgw)  template __host__ void AddinfiltrationImplicitCPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, float * il, float * cl, EvolvingP&lt; float &gt; XEv, float * hgw)  __global__ void AddinfiltrationImplicitGPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, T * il, T * cl, EvolvingP&lt; T &gt; XEv, T * hgw)  template __global__ void AddinfiltrationImplicitGPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, double * il, double * cl, EvolvingP&lt; double &gt; XEv, double * hgw)  template __global__ void AddinfiltrationImplicitGPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, float * il, float * cl, EvolvingP&lt; float &gt; XEv, float * hgw)  __host__ void AddrainforcingCPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Rain, AdvanceP&lt; T &gt; XAdv)  template __host__ void AddrainforcingCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; Rain, AdvanceP&lt; double &gt; XAdv)  template __host__ void AddrainforcingCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; Rain, AdvanceP&lt; float &gt; XAdv)  __global__ void AddrainforcingGPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Rain, AdvanceP&lt; T &gt; XAdv)  template __global__ void AddrainforcingGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; Rain, AdvanceP&lt; double &gt; XAdv)  template __global__ void AddrainforcingGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; Rain, AdvanceP&lt; float &gt; XAdv)  __host__ void AddrainforcingImplicitCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Rain, EvolvingP&lt; T &gt; XEv)  template __host__ void AddrainforcingImplicitCPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; Rain, EvolvingP&lt; double &gt; XEv)  template __host__ void AddrainforcingImplicitCPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; Rain, EvolvingP&lt; float &gt; XEv)  __global__ void AddrainforcingImplicitGPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Rain, EvolvingP&lt; T &gt; XEv)  template __global__ void AddrainforcingImplicitGPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; Rain, EvolvingP&lt; double &gt; XEv)  template __global__ void AddrainforcingImplicitGPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; Rain, EvolvingP&lt; float &gt; XEv)  __host__ void AddwindforcingCPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Uwind, DynForcingP&lt; float &gt; Vwind, AdvanceP&lt; T &gt; XAdv)  template __host__ void AddwindforcingCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; Uwind, DynForcingP&lt; float &gt; Vwind, AdvanceP&lt; double &gt; XAdv)  template __host__ void AddwindforcingCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; Uwind, DynForcingP&lt; float &gt; Vwind, AdvanceP&lt; float &gt; XAdv)  __global__ void AddwindforcingGPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Uwind, DynForcingP&lt; float &gt; Vwind, AdvanceP&lt; T &gt; XAdv)  template __global__ void AddwindforcingGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; Uwind, DynForcingP&lt; float &gt; Vwind, AdvanceP&lt; double &gt; XAdv)  template __global__ void AddwindforcingGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; Uwind, DynForcingP&lt; float &gt; Vwind, AdvanceP&lt; float &gt; XAdv)  void Forcingthisstep (Param XParam, double totaltime, DynForcingP&lt; float &gt; &amp; XDynForcing)  __global__ void InjectManyRiversGPU (Param XParam, int irib, RiverInfo&lt; T &gt; XRin, BlockP&lt; T &gt; XBlock, AdvanceP&lt; T &gt; XAdv)  __host__ void InjectRiverCPU (Param XParam, River XRiver, T qnow, int nblkriver, int * Riverblks, BlockP&lt; T &gt; XBlock, AdvanceP&lt; T &gt; XAdv)  template __host__ void InjectRiverCPU&lt; double &gt; (Param XParam, River XRiver, double qnow, int nblkriver, int * Riverblks, BlockP&lt; double &gt; XBlock, AdvanceP&lt; double &gt; XAdv)  template __host__ void InjectRiverCPU&lt; float &gt; (Param XParam, River XRiver, float qnow, int nblkriver, int * Riverblks, BlockP&lt; float &gt; XBlock, AdvanceP&lt; float &gt; XAdv)  __global__ void InjectRiverGPU (Param XParam, River XRiver, T qnow, int * Riverblks, BlockP&lt; T &gt; XBlock, AdvanceP&lt; T &gt; XAdv)  template __global__ void InjectRiverGPU&lt; double &gt; (Param XParam, River XRiver, double qnow, int * Riverblks, BlockP&lt; double &gt; XBlock, AdvanceP&lt; double &gt; XAdv)  template __global__ void InjectRiverGPU&lt; float &gt; (Param XParam, River XRiver, float qnow, int * Riverblks, BlockP&lt; float &gt; XBlock, AdvanceP&lt; float &gt; XAdv)  void deformstep (Param XParam, Loop&lt; T &gt; XLoop, std::vector&lt; deformmap&lt; float &gt; &gt; deform, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  void deformstep (Param XParam, Loop&lt; T &gt; XLoop, std::vector&lt; deformmap&lt; float &gt; &gt; deform, Model&lt; T &gt; XModel)  template void deformstep&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, std::vector&lt; deformmap&lt; float &gt; &gt; deform, Model&lt; double &gt; XModel, Model&lt; double &gt; XModel_g)  template void deformstep&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, std::vector&lt; deformmap&lt; float &gt; &gt; deform, Model&lt; float &gt; XModel, Model&lt; float &gt; XModel_g)  __device__ T interp2BUQ (T x, T y, TexSetP Forcing)  template __device__ double interp2BUQ&lt; double &gt; (double x, double y, TexSetP Forcing)  template __device__ float interp2BUQ&lt; float &gt; (float x, float y, TexSetP Forcing)  __device__ T interpDyn2BUQ (T x, T y, TexSetP Forcing)  template __device__ double interpDyn2BUQ&lt; double &gt; (double x, double y, TexSetP Forcing)  template __device__ float interpDyn2BUQ&lt; float &gt; (float x, float y, TexSetP Forcing)  void updateforcing (Param XParam, Loop&lt; T &gt; XLoop, Forcing&lt; float &gt; &amp; XForcing)  template void updateforcing&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, Forcing&lt; float &gt; &amp; XForcing)  template void updateforcing&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, Forcing&lt; float &gt; &amp; XForcing)"},{"location":"BGFlood/Updateforcing_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Updateforcing_8cu/#function-adddeformcpu","title":"function AddDeformCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AddDeformCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    deformmap &lt; float &gt; defmap,\n    EvolvingP &lt; T &gt; XEv,\n    T scale,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-adddeformgpu","title":"function AddDeformGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AddDeformGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    deformmap &lt; float &gt; defmap,\n    EvolvingP &lt; T &gt; XEv,\n    T scale,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addpatmforcingcpu","title":"function AddPatmforcingCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AddPatmforcingCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; PAtm,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addpatmforcingcpu-double","title":"function AddPatmforcingCPU&lt; double &gt;","text":"<pre><code>template __host__ void AddPatmforcingCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; PAtm,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addpatmforcingcpu-float","title":"function AddPatmforcingCPU&lt; float &gt;","text":"<pre><code>template __host__ void AddPatmforcingCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; PAtm,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addpatmforcinggpu","title":"function AddPatmforcingGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AddPatmforcingGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; PAtm,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addpatmforcinggpu-double","title":"function AddPatmforcingGPU&lt; double &gt;","text":"<pre><code>template __global__ void AddPatmforcingGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; PAtm,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addpatmforcinggpu-float","title":"function AddPatmforcingGPU&lt; float &gt;","text":"<pre><code>template __global__ void AddPatmforcingGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; PAtm,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addriverforcing","title":"function AddRiverForcing","text":"<pre><code>template&lt;class T&gt;\n__host__ void AddRiverForcing (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    std::vector&lt; River &gt; XRivers,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addriverforcing-double","title":"function AddRiverForcing&lt; double &gt;","text":"<pre><code>template __host__ void AddRiverForcing&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    std::vector&lt; River &gt; XRivers,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addriverforcing-float","title":"function AddRiverForcing&lt; float &gt;","text":"<pre><code>template __host__ void AddRiverForcing&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    std::vector&lt; River &gt; XRivers,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addinfiltrationimplicitcpu","title":"function AddinfiltrationImplicitCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AddinfiltrationImplicitCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    T * il,\n    T * cl,\n    EvolvingP &lt; T &gt; XEv,\n    T * hgw\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addinfiltrationimplicitcpu-double","title":"function AddinfiltrationImplicitCPU&lt; double &gt;","text":"<pre><code>template __host__ void AddinfiltrationImplicitCPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    double * il,\n    double * cl,\n    EvolvingP &lt; double &gt; XEv,\n    double * hgw\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addinfiltrationimplicitcpu-float","title":"function AddinfiltrationImplicitCPU&lt; float &gt;","text":"<pre><code>template __host__ void AddinfiltrationImplicitCPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    float * il,\n    float * cl,\n    EvolvingP &lt; float &gt; XEv,\n    float * hgw\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addinfiltrationimplicitgpu","title":"function AddinfiltrationImplicitGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AddinfiltrationImplicitGPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    T * il,\n    T * cl,\n    EvolvingP &lt; T &gt; XEv,\n    T * hgw\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addinfiltrationimplicitgpu-double","title":"function AddinfiltrationImplicitGPU&lt; double &gt;","text":"<pre><code>template __global__ void AddinfiltrationImplicitGPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    double * il,\n    double * cl,\n    EvolvingP &lt; double &gt; XEv,\n    double * hgw\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addinfiltrationimplicitgpu-float","title":"function AddinfiltrationImplicitGPU&lt; float &gt;","text":"<pre><code>template __global__ void AddinfiltrationImplicitGPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    float * il,\n    float * cl,\n    EvolvingP &lt; float &gt; XEv,\n    float * hgw\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addrainforcingcpu","title":"function AddrainforcingCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AddrainforcingCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addrainforcingcpu-double","title":"function AddrainforcingCPU&lt; double &gt;","text":"<pre><code>template __host__ void AddrainforcingCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    AdvanceP &lt; double &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addrainforcingcpu-float","title":"function AddrainforcingCPU&lt; float &gt;","text":"<pre><code>template __host__ void AddrainforcingCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    AdvanceP &lt; float &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addrainforcinggpu","title":"function AddrainforcingGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AddrainforcingGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addrainforcinggpu-double","title":"function AddrainforcingGPU&lt; double &gt;","text":"<pre><code>template __global__ void AddrainforcingGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    AdvanceP &lt; double &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addrainforcinggpu-float","title":"function AddrainforcingGPU&lt; float &gt;","text":"<pre><code>template __global__ void AddrainforcingGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    AdvanceP &lt; float &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addrainforcingimplicitcpu","title":"function AddrainforcingImplicitCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AddrainforcingImplicitCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    EvolvingP &lt; T &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addrainforcingimplicitcpu-double","title":"function AddrainforcingImplicitCPU&lt; double &gt;","text":"<pre><code>template __host__ void AddrainforcingImplicitCPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    EvolvingP &lt; double &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addrainforcingimplicitcpu-float","title":"function AddrainforcingImplicitCPU&lt; float &gt;","text":"<pre><code>template __host__ void AddrainforcingImplicitCPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    EvolvingP &lt; float &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addrainforcingimplicitgpu","title":"function AddrainforcingImplicitGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AddrainforcingImplicitGPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    EvolvingP &lt; T &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addrainforcingimplicitgpu-double","title":"function AddrainforcingImplicitGPU&lt; double &gt;","text":"<pre><code>template __global__ void AddrainforcingImplicitGPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    EvolvingP &lt; double &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addrainforcingimplicitgpu-float","title":"function AddrainforcingImplicitGPU&lt; float &gt;","text":"<pre><code>template __global__ void AddrainforcingImplicitGPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    EvolvingP &lt; float &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addwindforcingcpu","title":"function AddwindforcingCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AddwindforcingCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Uwind,\n    DynForcingP &lt; float &gt; Vwind,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addwindforcingcpu-double","title":"function AddwindforcingCPU&lt; double &gt;","text":"<pre><code>template __host__ void AddwindforcingCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; Uwind,\n    DynForcingP &lt; float &gt; Vwind,\n    AdvanceP &lt; double &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addwindforcingcpu-float","title":"function AddwindforcingCPU&lt; float &gt;","text":"<pre><code>template __host__ void AddwindforcingCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; Uwind,\n    DynForcingP &lt; float &gt; Vwind,\n    AdvanceP &lt; float &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addwindforcinggpu","title":"function AddwindforcingGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AddwindforcingGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Uwind,\n    DynForcingP &lt; float &gt; Vwind,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addwindforcinggpu-double","title":"function AddwindforcingGPU&lt; double &gt;","text":"<pre><code>template __global__ void AddwindforcingGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; Uwind,\n    DynForcingP &lt; float &gt; Vwind,\n    AdvanceP &lt; double &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-addwindforcinggpu-float","title":"function AddwindforcingGPU&lt; float &gt;","text":"<pre><code>template __global__ void AddwindforcingGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; Uwind,\n    DynForcingP &lt; float &gt; Vwind,\n    AdvanceP &lt; float &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-forcingthisstep","title":"function Forcingthisstep","text":"<pre><code>void Forcingthisstep (\n    Param XParam,\n    double totaltime,\n    DynForcingP &lt; float &gt; &amp; XDynForcing\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-injectmanyriversgpu","title":"function InjectManyRiversGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void InjectManyRiversGPU (\n    Param XParam,\n    int irib,\n    RiverInfo &lt; T &gt; XRin,\n    BlockP &lt; T &gt; XBlock,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-injectrivercpu","title":"function InjectRiverCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void InjectRiverCPU (\n    Param XParam,\n    River XRiver,\n    T qnow,\n    int nblkriver,\n    int * Riverblks,\n    BlockP &lt; T &gt; XBlock,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-injectrivercpu-double","title":"function InjectRiverCPU&lt; double &gt;","text":"<pre><code>template __host__ void InjectRiverCPU&lt; double &gt; (\n    Param XParam,\n    River XRiver,\n    double qnow,\n    int nblkriver,\n    int * Riverblks,\n    BlockP &lt; double &gt; XBlock,\n    AdvanceP &lt; double &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-injectrivercpu-float","title":"function InjectRiverCPU&lt; float &gt;","text":"<pre><code>template __host__ void InjectRiverCPU&lt; float &gt; (\n    Param XParam,\n    River XRiver,\n    float qnow,\n    int nblkriver,\n    int * Riverblks,\n    BlockP &lt; float &gt; XBlock,\n    AdvanceP &lt; float &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-injectrivergpu","title":"function InjectRiverGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void InjectRiverGPU (\n    Param XParam,\n    River XRiver,\n    T qnow,\n    int * Riverblks,\n    BlockP &lt; T &gt; XBlock,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-injectrivergpu-double","title":"function InjectRiverGPU&lt; double &gt;","text":"<pre><code>template __global__ void InjectRiverGPU&lt; double &gt; (\n    Param XParam,\n    River XRiver,\n    double qnow,\n    int * Riverblks,\n    BlockP &lt; double &gt; XBlock,\n    AdvanceP &lt; double &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-injectrivergpu-float","title":"function InjectRiverGPU&lt; float &gt;","text":"<pre><code>template __global__ void InjectRiverGPU&lt; float &gt; (\n    Param XParam,\n    River XRiver,\n    float qnow,\n    int * Riverblks,\n    BlockP &lt; float &gt; XBlock,\n    AdvanceP &lt; float &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-deformstep","title":"function deformstep","text":"<pre><code>template&lt;class T&gt;\nvoid deformstep (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    std::vector&lt; deformmap &lt; float &gt; &gt; deform,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-deformstep_1","title":"function deformstep","text":"<pre><code>template&lt;class T&gt;\nvoid deformstep (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    std::vector&lt; deformmap &lt; float &gt; &gt; deform,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-deformstep-double","title":"function deformstep&lt; double &gt;","text":"<pre><code>template void deformstep&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    std::vector&lt; deformmap &lt; float &gt; &gt; deform,\n    Model &lt; double &gt; XModel,\n    Model &lt; double &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-deformstep-float","title":"function deformstep&lt; float &gt;","text":"<pre><code>template void deformstep&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    std::vector&lt; deformmap &lt; float &gt; &gt; deform,\n    Model &lt; float &gt; XModel,\n    Model &lt; float &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-interp2buq","title":"function interp2BUQ","text":"<pre><code>template&lt;class T&gt;\n__device__ T interp2BUQ (\n    T x,\n    T y,\n    TexSetP Forcing\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-interp2buq-double","title":"function interp2BUQ&lt; double &gt;","text":"<pre><code>template __device__ double interp2BUQ&lt; double &gt; (\n    double x,\n    double y,\n    TexSetP Forcing\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-interp2buq-float","title":"function interp2BUQ&lt; float &gt;","text":"<pre><code>template __device__ float interp2BUQ&lt; float &gt; (\n    float x,\n    float y,\n    TexSetP Forcing\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-interpdyn2buq","title":"function interpDyn2BUQ","text":"<pre><code>template&lt;class T&gt;\n__device__ T interpDyn2BUQ (\n    T x,\n    T y,\n    TexSetP Forcing\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-interpdyn2buq-double","title":"function interpDyn2BUQ&lt; double &gt;","text":"<pre><code>template __device__ double interpDyn2BUQ&lt; double &gt; (\n    double x,\n    double y,\n    TexSetP Forcing\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-interpdyn2buq-float","title":"function interpDyn2BUQ&lt; float &gt;","text":"<pre><code>template __device__ float interpDyn2BUQ&lt; float &gt; (\n    float x,\n    float y,\n    TexSetP Forcing\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-updateforcing","title":"function updateforcing","text":"<pre><code>template&lt;class T&gt;\nvoid updateforcing (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-updateforcing-double","title":"function updateforcing&lt; double &gt;","text":"<pre><code>template void updateforcing&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8cu/#function-updateforcing-float","title":"function updateforcing&lt; float &gt;","text":"<pre><code>template void updateforcing&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Updateforcing.cu</code></p>"},{"location":"BGFlood/Updateforcing_8cu_source/","title":"File Updateforcing.cu","text":""},{"location":"BGFlood/Updateforcing_8cu_source/#file-updateforcingcu","title":"File Updateforcing.cu","text":"<p>File List &gt; src &gt; Updateforcing.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Updateforcing.h\"\n\ntemplate &lt;class T&gt; void updateforcing(Param XParam, Loop&lt;T&gt; XLoop, Forcing&lt;float&gt; &amp;XForcing)\n{\n    // Update forcing for all possible dynamic forcing. \n    //if a file is declared that implies that the dynamic forcing is applicable\n    if (!XForcing.Rain.inputfile.empty())\n    {\n        Forcingthisstep(XParam, double(XLoop.totaltime), XForcing.Rain);\n    }\n    if (!XForcing.Atmp.inputfile.empty())\n    {\n        Forcingthisstep(XParam, double(XLoop.totaltime), XForcing.Atmp);\n    }\n    if (!XForcing.UWind.inputfile.empty())//&amp;&amp; !XForcing.UWind.inputfile.empty()\n    {\n        Forcingthisstep(XParam, double(XLoop.totaltime), XForcing.UWind);\n        Forcingthisstep(XParam, double(XLoop.totaltime), XForcing.VWind);\n    }\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n        if (XForcing.bndseg[iseg].on &amp;&amp; !XForcing.bndseg[iseg].uniform)\n        {\n            Forcingthisstep(XParam, double(XLoop.totaltime), XForcing.bndseg[iseg].WLmap);\n        }\n    }\n\n\n}\ntemplate void updateforcing&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, Forcing&lt;float&gt;&amp; XForcing);\ntemplate void updateforcing&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, Forcing&lt;float&gt;&amp; XForcing);\n\n\n\n\nvoid Forcingthisstep(Param XParam, double totaltime, DynForcingP&lt;float&gt; &amp;XDynForcing)\n{\n    dim3 blockDimDF(16, 16, 1);\n    dim3 gridDimDF((int)ceil((float)XDynForcing.nx / (float)blockDimDF.x), (int)ceil((float)XDynForcing.ny / (float)blockDimDF.y), 1);\n\n\n\n    if (XDynForcing.uniform == 1)\n    {\n        //\n        int Rstepinbnd = 1;\n\n        // Do this for all the corners\n        //Needs limiter in case WLbnd is empty\n        double difft = XDynForcing.unidata[Rstepinbnd].time - totaltime;\n\n        while (difft &lt; 0.0)\n        {\n            Rstepinbnd++;\n            difft = XDynForcing.unidata[Rstepinbnd].time - totaltime;\n        }\n\n        XDynForcing.nowvalue =interptime(XDynForcing.unidata[Rstepinbnd].wspeed, XDynForcing.unidata[Rstepinbnd - 1].wspeed, XDynForcing.unidata[Rstepinbnd].time - XDynForcing.unidata[Rstepinbnd - 1].time, totaltime - XDynForcing.unidata[Rstepinbnd - 1].time);\n\n\n\n    }\n    else\n    {\n        int readfirststep = std::min(std::max((int)floor((totaltime - XDynForcing.to) / XDynForcing.dt), 0), XDynForcing.nt - 2);\n\n        if (readfirststep + 1 &gt; XDynForcing.instep)\n        {\n            // Need to read a new step from the file\n\n            // First copy the forward (aft) step to become the previous step\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                CUDA_CHECK(cudaMemcpy(XDynForcing.before_g, XDynForcing.after_g, XDynForcing.nx * XDynForcing.ny * sizeof(float), cudaMemcpyDeviceToDevice));\n            }\n            else\n            {\n                Copy2CartCPU(XDynForcing.nx, XDynForcing.ny, XDynForcing.before, XDynForcing.after);\n            }\n\n\n            //NextHDstep &lt;&lt;&lt;gridDimRain, blockDimRain, 0 &gt;&gt;&gt; (XParam.Rainongrid.nx, XParam.Rainongrid.ny, Rainbef_g, Rainaft_g);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n\n            // Read the actual file data\n\n            readvardata(XDynForcing.inputfile, XDynForcing.varname, readfirststep + 1, XDynForcing.after, XDynForcing.flipxx, XDynForcing.flipyy);\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                CUDA_CHECK(cudaMemcpy(XDynForcing.after_g, XDynForcing.after, XDynForcing.nx * XDynForcing.ny * sizeof(float), cudaMemcpyHostToDevice));\n            }\n\n            XDynForcing.instep = readfirststep + 1;\n        }\n\n        // Interpolate the forcing array to this time \n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            float bftime = float(XDynForcing.to+XDynForcing.dt*(XDynForcing.instep-1));\n            float aftime = float(XDynForcing.to + XDynForcing.dt * (XDynForcing.instep));\n            InterpstepGPU &lt;&lt;&lt;gridDimDF, blockDimDF, 0 &gt;&gt;&gt; (XDynForcing.nx, XDynForcing.ny, float(totaltime), bftime,aftime, XDynForcing.now_g, XDynForcing.before_g, XDynForcing.after_g);\n            CUDA_CHECK(cudaDeviceSynchronize());\n\n            CUDA_CHECK(cudaMemcpyToArray(XDynForcing.GPU.CudArr, 0, 0, XDynForcing.now_g, XDynForcing.nx * XDynForcing.ny * sizeof(float), cudaMemcpyDeviceToDevice));\n        }\n        else\n        {\n            InterpstepCPU(XDynForcing.nx, XDynForcing.ny, XDynForcing.instep - 1, totaltime, XDynForcing.dt, XDynForcing.val, XDynForcing.before, XDynForcing.after);\n        }\n        //InterpstepCPU(XParam.windU.nx, XParam.windU.ny, readfirststep, XParam.totaltime, XParam.windU.dt, Uwind, Uwbef, Uwaft);\n        //InterpstepCPU(XParam.windV.nx, XParam.windV.ny, readfirststep, XParam.totaltime, XParam.windV.dt, Vwind, Vwbef, Vwaft);\n\n\n\n    }\n\n    //return rainuni;\n}\n\ntemplate &lt;class T&gt; __host__ void AddRiverForcing(Param XParam, Loop&lt;T&gt; XLoop, std::vector&lt;River&gt; XRivers, Model&lt;T&gt; XModel)\n{\n    dim3 gridDimRiver(XModel.bndblk.Riverinfo.nburmax, 1, 1);\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    T qnow;\n    for (int Rin = 0; Rin &lt; XRivers.size(); Rin++)\n    {\n        //\n        int bndstep = 0;\n        double difft = XRivers[Rin].flowinput[bndstep].time - XLoop.totaltime;\n        while (difft &lt;= 0.0) // danger?\n        {\n            bndstep++;\n            difft = XRivers[Rin].flowinput[bndstep].time - XLoop.totaltime;\n        }\n\n        qnow = T(interptime(XRivers[Rin].flowinput[bndstep].q, XRivers[Rin].flowinput[max(bndstep - 1, 0)].q, XRivers[Rin].flowinput[bndstep].time - XRivers[Rin].flowinput[max(bndstep - 1, 0)].time, XLoop.totaltime - XRivers[Rin].flowinput[max(bndstep - 1, 0)].time));\n\n        XModel.bndblk.Riverinfo.qnow[Rin] = qnow / XRivers[Rin].disarea;\n\n    }\n\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        for (int irib = 0; irib &lt; XModel.bndblk.Riverinfo.nribmax; irib++)\n        {\n            //InjectRiverGPU &lt;&lt;&lt;gridDimRiver, blockDim, 0 &gt;&gt;&gt; (XParam, XRivers[Rin], qnow, XModel.bndblk.river, XModel.blocks, XModel.adv);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            InjectManyRiversGPU &lt;&lt;&lt;gridDimRiver, blockDim, 0 &gt;&gt;&gt; (XParam, irib, XModel.bndblk.Riverinfo, XModel.blocks, XModel.adv);\n            CUDA_CHECK(cudaDeviceSynchronize());\n        }\n\n    }\n    else\n    {\n        for (int Rin = 0; Rin &lt; XRivers.size(); Rin++)\n        {\n            InjectRiverCPU(XParam, XRivers[Rin], T(XModel.bndblk.Riverinfo.qnow[Rin]), XModel.bndblk.nblkriver, XModel.bndblk.river, XModel.blocks, XModel.adv);\n        }\n    }\n\n}\ntemplate __host__ void AddRiverForcing&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, std::vector&lt;River&gt; XRivers, Model&lt;float&gt; XModel);\ntemplate __host__ void AddRiverForcing&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, std::vector&lt;River&gt; XRivers, Model&lt;double&gt; XModel);\n\n\ntemplate &lt;class T&gt; __global__ void InjectRiverGPU(Param XParam,River XRiver, T qnow, int* Riverblks, BlockP&lt;T&gt; XBlock, AdvanceP&lt;T&gt; XAdv)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = Riverblks[ibl];\n\n\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n    T xl, yb, xr, yt, xllo, yllo;\n    xllo = XParam.xo + XBlock.xo[ib];\n    yllo = XParam.yo + XBlock.yo[ib];\n\n    xl = xllo + ix * delta - 0.5 * delta;\n    yb = yllo + iy * delta - 0.5 * delta;\n\n    xr = xllo + ix * delta + 0.5 * delta;\n    yt = yllo + iy * delta + 0.5 * delta;\n    // the conditions are that the discharge area as defined by the user have to include at least a model grid node\n    // This could be really annoying and there should be a better way to deal wiith this like polygon intersection\n    //if (xx &gt;= XForcing.rivers[Rin].xstart &amp;&amp; xx &lt;= XForcing.rivers[Rin].xend &amp;&amp; yy &gt;= XForcing.rivers[Rin].ystart &amp;&amp; yy &lt;= XForcing.rivers[Rin].yend)\n    if (OBBdetect(xl, xr, yb, yt, T(XRiver.xstart), T(XRiver.xend), T(XRiver.ystart), T(XRiver.yend)))\n    {\n\n        XAdv.dh[i] += qnow  / XRiver.disarea;\n\n    }\n\n\n\n}\ntemplate __global__ void InjectRiverGPU&lt;float&gt;(Param XParam, River XRiver, float qnow, int* Riverblks, BlockP&lt;float&gt; XBlock, AdvanceP&lt;float&gt; XAdv);\ntemplate __global__ void InjectRiverGPU&lt;double&gt;(Param XParam, River XRiver, double qnow, int* Riverblks, BlockP&lt;double&gt; XBlock, AdvanceP&lt;double&gt; XAdv);\n\ntemplate &lt;class T&gt; __global__ void InjectManyRiversGPU(Param XParam,int irib, RiverInfo&lt;T&gt; XRin, BlockP&lt;T&gt; XBlock, AdvanceP&lt;T&gt; XAdv)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.x + halowidth * 2;\n\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n\n    int indx = ibl + irib * XRin.nburmax;\n\n    int ib,rid,i;\n\n    T xllo, yllo, xl, yb, xr, yt, levdx;\n    T rxst, ryst, rxnd, rynd;\n\n    ib = XRin.Xbidir[indx];\n    if (ib &gt; -1)\n    {\n\n        i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n        rid = XRin.Xridib[indx];\n\n        levdx = calcres(T(XParam.dx), XBlock.level[ib]);\n\n        xllo = T(XParam.xo + XBlock.xo[ib]);\n        yllo = T(XParam.yo + XBlock.yo[ib]);\n\n\n        xl = xllo + ix * levdx - T(0.5) * levdx;\n        yb = yllo + iy * levdx - T(0.5) * levdx;\n\n        xr = xllo + ix * levdx + T(0.5) * levdx;\n        yt = yllo + iy * levdx + T(0.5) * levdx;\n\n        rxst = XRin.xstart[indx];\n        ryst = XRin.ystart[indx];\n        rxnd = XRin.xend[indx];\n        rynd = XRin.yend[indx];\n\n\n        T qnow = XRin.qnow_g[rid]; // here we use qnow_g because qnow is a CPU pointer\n        if (OBBdetect(xl, xr, yb, yt, rxst, rxnd, ryst, rynd))\n        {\n            XAdv.dh[i] += qnow; //was / T(XRiver.disarea) but this is done upstream now to be consistent with GPU Many river ops \n\n        }\n\n\n    }\n\n}\n\ntemplate &lt;class T&gt; __host__ void InjectRiverCPU(Param XParam, River XRiver, T qnow, int nblkriver, int* Riverblks, BlockP&lt;T&gt; XBlock, AdvanceP&lt;T&gt; XAdv)\n{\n    unsigned int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    T xllo, yllo, xl, yb, xr, yt, levdx;\n\n    for (int ibl = 0; ibl &lt; nblkriver; ibl++)\n    {\n        ib = Riverblks[ibl];\n\n        levdx = calcres(T(XParam.dx), XBlock.level[ib]);\n\n        xllo = T(XParam.xo + XBlock.xo[ib]);\n        yllo = T(XParam.yo + XBlock.yo[ib]);\n\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                //T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n                //T x = XParam.xo + XBlock.xo[ib] + ix * delta;\n                //T y = XParam.yo + XBlock.yo[ib] + iy * delta;\n\n                //if (x &gt;= XRiver.xstart &amp;&amp; x &lt;= XRiver.xend &amp;&amp; y &gt;= XRiver.ystart &amp;&amp; y &lt;= XRiver.yend)\n                xl = xllo + ix * levdx - T(0.5) * levdx;\n                yb = yllo + iy * levdx - T(0.5) * levdx;\n\n                xr = xllo + ix * levdx + T(0.5) * levdx;\n                yt = yllo + iy * levdx + T(0.5) * levdx;\n                // the conditions are that the discharge area as defined by the user have to include at least a model grid node\n                // This could be really annoying and there should be a better way to deal wiith this like polygon intersection\n                //if (xx &gt;= XForcing.rivers[Rin].xstart &amp;&amp; xx &lt;= XForcing.rivers[Rin].xend &amp;&amp; yy &gt;= XForcing.rivers[Rin].ystart &amp;&amp; yy &lt;= XForcing.rivers[Rin].yend)\n                if (OBBdetect(xl, xr, yb, yt, T(XRiver.xstart),T(XRiver.xend), T(XRiver.ystart), T(XRiver.yend)))\n                {\n                    XAdv.dh[i] += qnow ; //was / T(XRiver.disarea) but this is done upstream now to be consistent with GPU Many river ops \n\n                }\n            }\n        }\n    }\n\n\n}\ntemplate __host__ void InjectRiverCPU&lt;float&gt;(Param XParam, River XRiver, float qnow, int nblkriver, int* Riverblks, BlockP&lt;float&gt; XBlock, AdvanceP&lt;float&gt; XAdv);\ntemplate __host__ void InjectRiverCPU&lt;double&gt;(Param XParam, River XRiver, double qnow, int nblkriver, int* Riverblks, BlockP&lt;double&gt; XBlock, AdvanceP&lt;double&gt; XAdv);\n\ntemplate &lt;class T&gt; __global__ void AddrainforcingGPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Rain, AdvanceP&lt;T&gt; XAdv)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n    T Rainhh;\n\n    T x = XParam.xo + XBlock.xo[ib] + ix * delta;\n    T y = XParam.yo + XBlock.yo[ib] + iy * delta;\n    if (Rain.uniform)\n    {\n        Rainhh = Rain.nowvalue;\n    }\n    else\n    {\n        Rainhh = T(interpDyn2BUQ(x, y, Rain.GPU));\n    }\n\n\n    Rainhh = Rainhh / T(1000.0) / T(3600.0); // convert from mm/hrs to m/s\n\n    XAdv.dh[i] += Rainhh * XBlock.activeCell[i];\n}\ntemplate __global__ void AddrainforcingGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; Rain, AdvanceP&lt;float&gt; XAdv);\ntemplate __global__ void AddrainforcingGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; Rain, AdvanceP&lt;double&gt; XAdv);\n\n\ntemplate &lt;class T&gt; __global__ void AddrainforcingImplicitGPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Rain, EvolvingP&lt;T&gt; XEv)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n    T Rainhh;\n\n    T hi = XEv.h[i];\n\n    T x = XParam.xo + XBlock.xo[ib] + ix * delta;\n    T y = XParam.yo + XBlock.yo[ib] + iy * delta;\n    if (Rain.uniform)\n    {\n        Rainhh = Rain.nowvalue;\n    }\n    else\n    {\n        Rainhh = T(interpDyn2BUQ(x, y, Rain.GPU));\n    }\n\n\n    Rainhh = max(Rainhh / T(1000.0) / T(3600.0) * T(XLoop.dt), T(0.0)) * XBlock.activeCell[i]; // convert from mm/hrs to m/s and \n    //printf(\"%f\\n\", Rainhh);\n    T qvol = hi / (hi + Rainhh);\n\n    XEv.h[i] = hi + Rainhh;\n    XEv.zs[i] += Rainhh;\n    if (hi &gt; XParam.eps)\n    {\n        //XEv.u[i] = XEv.u[i] * qvol;\n        //XEv.v[i] = XEv.v[i] * qvol;\n    }\n}\ntemplate __global__ void AddrainforcingImplicitGPU&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; Rain, EvolvingP&lt;float&gt; XEv);\ntemplate __global__ void AddrainforcingImplicitGPU&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; Rain, EvolvingP&lt;double&gt; XEv);\n\n\ntemplate &lt;class T&gt; __host__ void AddrainforcingCPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Rain, AdvanceP&lt;T&gt; XAdv)\n{\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n                T Rainhh;\n\n                T x = T(XParam.xo) + XBlock.xo[ib] + ix * delta;\n                T y = T(XParam.yo) + XBlock.yo[ib] + iy * delta;\n\n                if (Rain.uniform)\n                {\n                    Rainhh = T(Rain.nowvalue);\n                }\n                else\n                {\n                    Rainhh = interp2BUQ(x, y, Rain);\n                }\n\n\n\n\n                Rainhh = Rainhh / T(1000.0) / T(3600.0); // convert from mm/hrs to m/s\n\n\n\n                XAdv.dh[i] += Rainhh * XBlock.activeCell[i];\n            }\n        }\n    }\n}\ntemplate __host__ void AddrainforcingCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; Rain, AdvanceP&lt;float&gt; XAdv);\ntemplate __host__ void AddrainforcingCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; Rain, AdvanceP&lt;double&gt; XAdv);\n\ntemplate &lt;class T&gt; __host__ void AddrainforcingImplicitCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Rain, EvolvingP&lt;T&gt; XEv)\n{\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n                T hi = XEv.h[i];\n\n                T Rainhh;\n\n                T x = T(XParam.xo) + XBlock.xo[ib] + ix * delta;\n                T y = T(XParam.yo) + XBlock.yo[ib] + iy * delta;\n\n                if (Rain.uniform)\n                {\n                    Rainhh = T(Rain.nowvalue);\n                }\n                else\n                {\n                    Rainhh = interp2BUQ(x, y, Rain);\n                }\n\n\n                Rainhh = max(Rainhh / T(1000.0) / T(3600.0) * T(XLoop.dt), T(0.0)) * XBlock.activeCell[i]; // convert from mm/hrs to m/s and \n\n                T qvol = hi/(hi + Rainhh);\n\n                XEv.h[i] = hi + Rainhh;\n                XEv.zs[i] += Rainhh;\n\n                if (hi &gt; XParam.eps)\n                {\n                    XEv.u[i] = XEv.u[i] * qvol;\n                    XEv.v[i] = XEv.v[i] * qvol;\n                }\n            }\n        }\n    }\n}\ntemplate __host__ void AddrainforcingImplicitCPU&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; Rain, EvolvingP&lt;float&gt; XEv);\ntemplate __host__ void AddrainforcingImplicitCPU&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; Rain, EvolvingP&lt;double&gt; XEv);\n\ntemplate &lt;class T&gt; __host__ void AddinfiltrationImplicitCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, T* il, T* cl, EvolvingP&lt;T&gt; XEv, T* hgw)\n{\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n    int p = 0;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                T waterOut = XEv.h[i];\n                T infiltrationLoc = 0.0;\n                T availinitialinfiltration;\n\n                if (waterOut &gt; 0)\n                {\n                    //Computation of the initial loss\n                    availinitialinfiltration = il[i] / T(1000.0) - hgw[i];\n                    infiltrationLoc = min(waterOut, availinitialinfiltration);\n                    waterOut -= infiltrationLoc;\n\n                    //Computation of the continuous loss\n                    T continuousloss = cl[i] / T(1000.0) / T(3600.0) * T(XLoop.dt); //convert from mm/hs to m/s\n                    infiltrationLoc += min(continuousloss, waterOut);\n\n                    hgw[i] += infiltrationLoc;\n\n                }\n\n                XEv.h[i] -= max(infiltrationLoc * XBlock.activeCell[i],T(0.0));\n                XEv.zs[i] -= max(infiltrationLoc * XBlock.activeCell[i],T(0.0));\n            }\n        }\n    }\n}\ntemplate __host__ void AddinfiltrationImplicitCPU&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, float* il, float* cl, EvolvingP&lt;float&gt; XEv, float* hgw);\ntemplate __host__ void AddinfiltrationImplicitCPU&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, double* il, double* cl, EvolvingP&lt;double&gt; XEv, double* hgw);\n\ntemplate &lt;class T&gt; __global__ void AddinfiltrationImplicitGPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, T* il, T* cl, EvolvingP&lt;T&gt; XEv, T* hgw)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    T waterOut = XEv.h[i];\n    T infiltrationLoc = 0.0;\n    T availinitialinfiltration;\n\n    if (waterOut &gt; 0)\n    {\n        //Computation of the initial loss\n        availinitialinfiltration = max(il[i] / T(1000.0) - hgw[i],T(0.0));\n        infiltrationLoc = min(waterOut, availinitialinfiltration);\n        waterOut -= infiltrationLoc;\n\n        //Computation of the continuous loss\n        T continuousloss = cl[i] / T(1000.0) / T(3600.0) * T(XLoop.dt); //convert from mm/hs to m\n        infiltrationLoc += min(continuousloss, waterOut);\n    }\n\n    hgw[i] += infiltrationLoc;\n\n    XEv.h[i] -= infiltrationLoc * XBlock.activeCell[i];\n    XEv.zs[i] -= infiltrationLoc * XBlock.activeCell[i];\n\n}\ntemplate __global__ void AddinfiltrationImplicitGPU&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, float* il, float* cl, EvolvingP&lt;float&gt; XEv, float* hgw);\ntemplate __global__ void AddinfiltrationImplicitGPU&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, double* il, double* cl, EvolvingP&lt;double&gt; XEv, double* hgw);\n\n\n\ntemplate &lt;class T&gt; __global__ void AddwindforcingGPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Uwind, DynForcingP&lt;float&gt; Vwind, AdvanceP&lt;T&gt; XAdv)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n    T uwindi, vwindi;\n\n    T x = XParam.xo + XBlock.xo[ib] + ix * delta;\n    T y = XParam.yo + XBlock.yo[ib] + iy * delta;\n\n    T rhoairrhowater = T(0.00121951); // density ratio rho(air)/rho(water) \n\n    if (Uwind.uniform)\n    {\n        uwindi = T(Uwind.nowvalue);\n    }\n    else\n    {\n        uwindi = interpDyn2BUQ(x, y, Uwind.GPU);\n    }\n    if (Vwind.uniform)\n    {\n        vwindi = T(Vwind.nowvalue);\n    }\n    else\n    {\n        vwindi = interpDyn2BUQ(x, y, Vwind.GPU);\n    }\n\n    XAdv.dhu[i] += rhoairrhowater * T(XParam.Cd) * uwindi * abs(uwindi);\n    XAdv.dhv[i] += rhoairrhowater * T(XParam.Cd) * vwindi * abs(vwindi);\n\n    //Rainhh = Rainhh / T(1000.0) / T(3600.0); // convert from mm/hrs to m/s\n\n    //XAdv.dh[i] += Rainhh;\n}\ntemplate __global__ void AddwindforcingGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; Uwind, DynForcingP&lt;float&gt; Vwind, AdvanceP&lt;float&gt; XAdv);\ntemplate __global__ void AddwindforcingGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; Uwind, DynForcingP&lt;float&gt; Vwind, AdvanceP&lt;double&gt; XAdv);\n\ntemplate &lt;class T&gt; __global__ void AddPatmforcingGPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; PAtm, Model&lt;T&gt; XModel)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n    T atmpi;\n\n    T x = XParam.xo + XBlock.xo[ib] + ix * delta;\n    T y = XParam.yo + XBlock.yo[ib] + iy * delta;\n\n\n\n    atmpi = interpDyn2BUQ(x, y, PAtm.GPU);\n\n\n    XModel.Patm[i] = atmpi - XParam.Paref;\n\n}\ntemplate __global__ void AddPatmforcingGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; PAtm, Model&lt;float&gt; XModel);\ntemplate __global__ void AddPatmforcingGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; PAtm, Model&lt;double&gt; XModel);\n\n\ntemplate &lt;class T&gt; __host__ void AddwindforcingCPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Uwind, DynForcingP&lt;float&gt; Vwind, AdvanceP&lt;T&gt; XAdv)\n{\n    //\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n                T uwindi, vwindi;\n\n                T x = T(XParam.xo) + XBlock.xo[ib] + ix * delta;\n                T y = T(XParam.yo) + XBlock.yo[ib] + iy * delta;\n\n                T rhoairrhowater = T(0.00121951); // density ratio rho(air)/rho(water) \n                if (Uwind.uniform)\n                {\n                    uwindi = T(Uwind.nowvalue);\n                }\n                else\n                {\n                    uwindi = interp2BUQ(x, y, Uwind);\n                }\n                if (Vwind.uniform)\n                {\n                    vwindi = T(Vwind.nowvalue);\n                }\n                else\n                {\n                    vwindi = interp2BUQ(x, y, Vwind);\n                }\n\n                XAdv.dhu[i] += rhoairrhowater * T(XParam.Cd) * uwindi * abs(uwindi);\n                XAdv.dhv[i] += rhoairrhowater * T(XParam.Cd) * vwindi * abs(vwindi);\n\n            }\n        }\n    }\n}\ntemplate __host__ void AddwindforcingCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; Uwind, DynForcingP&lt;float&gt; Vwind, AdvanceP&lt;float&gt; XAdv);\ntemplate __host__ void AddwindforcingCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; Uwind, DynForcingP&lt;float&gt; Vwind, AdvanceP&lt;double&gt; XAdv);\n\n\n\ntemplate &lt;class T&gt; __host__ void AddPatmforcingCPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; PAtm, Model&lt;T&gt; XModel)\n{\n    //\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n                T atmpi;\n\n                T x = XParam.xo + XBlock.xo[ib] + ix * delta;\n                T y = XParam.yo + XBlock.yo[ib] + iy * delta;\n\n\n                if (PAtm.uniform)\n                {\n                    atmpi = T(PAtm.nowvalue);\n                }\n                else\n                {\n                    atmpi = interp2BUQ(x, y, PAtm);\n                }\n\n\n                XModel.Patm[i] = atmpi;\n\n\n            }\n        }\n    }\n}\ntemplate __host__ void AddPatmforcingCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; PAtm, Model&lt;float&gt; XModel);\ntemplate __host__ void AddPatmforcingCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; PAtm, Model&lt;double&gt; XModel);\n\n\n\n\ntemplate &lt;class T&gt; __device__ T interpDyn2BUQ(T x, T y, TexSetP Forcing)\n{\n    T read;\n    if (Forcing.uniform)\n    {\n        read = T(Forcing.nowvalue);\n    }\n    else\n    {\n        read = interp2BUQ(x, y, Forcing);\n    }\n    return read;\n}\ntemplate __device__ float interpDyn2BUQ&lt;float&gt;(float x, float y, TexSetP Forcing);\ntemplate __device__ double interpDyn2BUQ&lt;double&gt;(double x, double y, TexSetP Forcing);\n\n\ntemplate &lt;class T&gt; __device__ T interp2BUQ(T x, T y, TexSetP Forcing)\n{\n    T read;\n\n    float ivw = float((x - T(Forcing.xo)) / T(Forcing.dx) + T(0.5));\n    float jvw = float((y - T(Forcing.yo)) / T(Forcing.dy) + T(0.5));\n    read = tex2D&lt;float&gt;(Forcing.tex, ivw, jvw);\n\n    return read;\n}\ntemplate __device__ float interp2BUQ&lt;float&gt;(float x, float y, TexSetP Forcing);\ntemplate __device__ double interp2BUQ&lt;double&gt;(double x, double y, TexSetP Forcing);\n\n\ntemplate &lt;class T&gt; void deformstep(Param XParam, Loop&lt;T&gt; XLoop, std::vector&lt;deformmap&lt;float&gt;&gt; deform, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    if (XParam.GPUDEVICE &lt; 0)\n    {\n        deformstep(XParam, XLoop, deform, XModel);\n        InitzbgradientCPU(XParam, XModel); // need to recalculate the zb halo and gradients to avoid blow up in topographic terms\n    }\n    else\n    {\n        deformstep(XParam, XLoop, deform, XModel_g);\n        InitzbgradientGPU(XParam, XModel_g);\n    }\n}\ntemplate void deformstep&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, std::vector&lt;deformmap&lt;float&gt;&gt; deform, Model&lt;float&gt; XModel, Model&lt;float&gt; XModel_g);\ntemplate void deformstep&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, std::vector&lt;deformmap&lt;float&gt;&gt; deform, Model&lt;double&gt; XModel, Model&lt;double&gt; XModel_g);\n\ntemplate &lt;class T&gt; void deformstep(Param XParam, Loop&lt;T&gt; XLoop, std::vector&lt;deformmap&lt;float&gt;&gt; deform, Model&lt;T&gt; XModel)\n{\n    dim3 gridDim(XParam.nblk, 1, 1);\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n\n    bool updatezbhalo = false;\n\n    for (int nd = 0; nd &lt; deform.size(); nd++)\n    {\n        // if deformation happend in the last computational step\n        if (((deform[nd].startime + deform[nd].duration) &gt;= (XLoop.totaltime - XLoop.dt)) &amp;&amp; (deform[nd].startime &lt; XLoop.totaltime))\n        {\n\n            updatezbhalo = true;\n\n            T dtdef = min(XLoop.dt, XLoop.totaltime - deform[nd].startime);\n            if (XLoop.totaltime &gt; deform[nd].startime + deform[nd].duration)\n            {\n                dtdef = (T)min(XLoop.dt, XLoop.totaltime - (deform[nd].startime + deform[nd].duration));\n            }\n\n\n            T scale = (deform[nd].duration &gt; 0.0) ? T(1.0 / deform[nd].duration * dtdef) : T(1.0);\n\n            //log(\"Applying deform: \" + std::to_string(scale));\n\n            if (XParam.GPUDEVICE &lt; 0)\n            {\n                AddDeformCPU(XParam, XModel.blocks, deform[nd], XModel.evolv, scale, XModel.zb);\n            }\n            else\n            {\n                AddDeformGPU &lt;&lt;&lt;gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, deform[nd], XModel.evolv, scale, XModel.zb);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n\n\n        }\n\n    }\n    //Redo the halo if needed\n    if (updatezbhalo)\n    {\n\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            CUDA_CHECK(cudaStreamCreate(&amp;XLoop.streams[0]));\n            fillHaloGPU(XParam, XModel.blocks, XLoop.streams[0], XModel.zb);\n\n            cudaStreamDestroy(XLoop.streams[0]);\n        }\n        else\n        {\n            fillHaloC(XParam, XModel.blocks, XModel.zb);\n        }\n    }\n\n\n}\n\n\ntemplate &lt;class T&gt; __global__ void AddDeformGPU(Param XParam, BlockP&lt;T&gt; XBlock, deformmap&lt;float&gt; defmap, EvolvingP&lt;T&gt; XEv, T scale, T* zb)\n{\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n    int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n    T zss, zbb;\n    T def;\n    T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n    T x = XParam.xo + XBlock.xo[ib] + ix * delta;\n    T y = XParam.yo + XBlock.yo[ib] + iy * delta;\n\n    def= interpDyn2BUQ(x, y, defmap.GPU);\n\n    //if (x &gt; 42000 &amp;&amp; x &lt; 43000 &amp;&amp; y&gt;7719000 &amp;&amp; y &lt; 7721000)\n    //{\n    //  printf(\"x=%f, y=%f, def=%f\\n \", x, y, def);\n    //}\n\n    zss = XEv.zs[i] + def * scale;\n    if (defmap.iscavity == true)\n    {\n        zbb = min(zss, zb[i]);\n    }\n    else\n    {\n        zbb = zb[i] + def * scale;\n    }\n\n    XEv.h[i] = zss - zbb;\n    XEv.zs[i] = zss;\n    zb[i] = zbb;\n\n    //zs[i] = zs[i] + def * scale;\n    //zb[i] = zb[i] + def * scale;\n\n\n\n}\n\ntemplate &lt;class T&gt; __host__ void AddDeformCPU(Param XParam, BlockP&lt;T&gt; XBlock, deformmap&lt;float&gt; defmap, EvolvingP&lt;T&gt; XEv, T scale, T* zb)\n{\n    int ib;\n\n    T zbb,zss;\n\n    T def;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n                T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n\n                T x = T(XParam.xo) + XBlock.xo[ib] + ix * delta;\n                T y = T(XParam.yo) + XBlock.yo[ib] + iy * delta;\n\n                def = interp2BUQ(x, y, defmap);\n\n                zss = XEv.zs[i] + def * scale;\n                if (defmap.iscavity == true)\n                {\n                    zbb = min(zss, zb[i]);\n                }\n                else\n                {\n                    zbb = zb[i] + def * scale;\n                }\n\n                XEv.zs[i] = zss;\n                XEv.h[i] = zss - zbb;\n                zb[i] = zbb;\n            }\n        }\n    }\n\n}\n</code></pre>"},{"location":"BGFlood/Updateforcing_8h/","title":"File Updateforcing.h","text":""},{"location":"BGFlood/Updateforcing_8h/#file-updateforcingh","title":"File Updateforcing.h","text":"<p>FileList &gt; src &gt; Updateforcing.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"InitialConditions.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"ReadForcing.h\"</code></li> <li><code>#include \"GridManip.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> </ul>"},{"location":"BGFlood/Updateforcing_8h/#public-functions","title":"Public Functions","text":"Type Name __global__ void AddDeformGPU (Param XParam, BlockP&lt; T &gt; XBlock, deformmap&lt; float &gt; defmap, EvolvingP&lt; T &gt; XEv, T scale, T * zb)  __host__ void AddPatmforcingCPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; PAtm, Model&lt; T &gt; XModel)  __global__ void AddPatmforcingGPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; PAtm, Model&lt; T &gt; XModel)  __host__ void AddRiverForcing (Param XParam, Loop&lt; T &gt; XLoop, std::vector&lt; River &gt; XRivers, Model&lt; T &gt; XModel)  __host__ void AddinfiltrationImplicitCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, T * il, T * cl, EvolvingP&lt; T &gt; XEv, T * hgw)  __global__ void AddinfiltrationImplicitGPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, T * il, T * cl, EvolvingP&lt; T &gt; XEv, T * hgw)  __host__ void AddrainforcingCPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Rain, AdvanceP&lt; T &gt; XAdv)  __global__ void AddrainforcingGPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Rain, AdvanceP&lt; T &gt; XAdv)  __host__ void AddrainforcingImplicitCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Rain, EvolvingP&lt; T &gt; XEv)  __global__ void AddrainforcingImplicitGPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Rain, EvolvingP&lt; T &gt; XEv)  __host__ void AddwindforcingCPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Uwind, DynForcingP&lt; float &gt; Vwind, AdvanceP&lt; T &gt; XAdv)  __global__ void AddwindforcingGPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Uwind, DynForcingP&lt; float &gt; Vwind, AdvanceP&lt; T &gt; XAdv)  void Forcingthisstep (Param XParam, double totaltime, DynForcingP&lt; float &gt; &amp; XDynForcing)  __global__ void InjectRiverGPU (Param XParam, River XRiver, T qnow, int * Riverblks, BlockP&lt; T &gt; XBlock, AdvanceP&lt; T &gt; XAdv)  void deformstep (Param XParam, Loop&lt; T &gt; XLoop, std::vector&lt; deformmap&lt; float &gt; &gt; deform, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  __device__ T interpDyn2BUQ (T x, T y, TexSetP Forcing)  void updateforcing (Param XParam, Loop&lt; T &gt; XLoop, Forcing&lt; float &gt; &amp; XForcing)"},{"location":"BGFlood/Updateforcing_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Updateforcing_8h/#function-adddeformgpu","title":"function AddDeformGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AddDeformGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    deformmap &lt; float &gt; defmap,\n    EvolvingP &lt; T &gt; XEv,\n    T scale,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8h/#function-addpatmforcingcpu","title":"function AddPatmforcingCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AddPatmforcingCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; PAtm,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8h/#function-addpatmforcinggpu","title":"function AddPatmforcingGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AddPatmforcingGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; PAtm,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8h/#function-addriverforcing","title":"function AddRiverForcing","text":"<pre><code>template&lt;class T&gt;\n__host__ void AddRiverForcing (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    std::vector&lt; River &gt; XRivers,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8h/#function-addinfiltrationimplicitcpu","title":"function AddinfiltrationImplicitCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AddinfiltrationImplicitCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    T * il,\n    T * cl,\n    EvolvingP &lt; T &gt; XEv,\n    T * hgw\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8h/#function-addinfiltrationimplicitgpu","title":"function AddinfiltrationImplicitGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AddinfiltrationImplicitGPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    T * il,\n    T * cl,\n    EvolvingP &lt; T &gt; XEv,\n    T * hgw\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8h/#function-addrainforcingcpu","title":"function AddrainforcingCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AddrainforcingCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8h/#function-addrainforcinggpu","title":"function AddrainforcingGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AddrainforcingGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8h/#function-addrainforcingimplicitcpu","title":"function AddrainforcingImplicitCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AddrainforcingImplicitCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    EvolvingP &lt; T &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8h/#function-addrainforcingimplicitgpu","title":"function AddrainforcingImplicitGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AddrainforcingImplicitGPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    EvolvingP &lt; T &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8h/#function-addwindforcingcpu","title":"function AddwindforcingCPU","text":"<pre><code>template&lt;class T&gt;\n__host__ void AddwindforcingCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Uwind,\n    DynForcingP &lt; float &gt; Vwind,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8h/#function-addwindforcinggpu","title":"function AddwindforcingGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void AddwindforcingGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Uwind,\n    DynForcingP &lt; float &gt; Vwind,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8h/#function-forcingthisstep","title":"function Forcingthisstep","text":"<pre><code>void Forcingthisstep (\n    Param XParam,\n    double totaltime,\n    DynForcingP &lt; float &gt; &amp; XDynForcing\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8h/#function-injectrivergpu","title":"function InjectRiverGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void InjectRiverGPU (\n    Param XParam,\n    River XRiver,\n    T qnow,\n    int * Riverblks,\n    BlockP &lt; T &gt; XBlock,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8h/#function-deformstep","title":"function deformstep","text":"<pre><code>template&lt;class T&gt;\nvoid deformstep (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    std::vector&lt; deformmap &lt; float &gt; &gt; deform,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8h/#function-interpdyn2buq","title":"function interpDyn2BUQ","text":"<pre><code>template&lt;class T&gt;\n__device__ T interpDyn2BUQ (\n    T x,\n    T y,\n    TexSetP Forcing\n) \n</code></pre>"},{"location":"BGFlood/Updateforcing_8h/#function-updateforcing","title":"function updateforcing","text":"<pre><code>template&lt;class T&gt;\nvoid updateforcing (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Updateforcing.h</code></p>"},{"location":"BGFlood/Updateforcing_8h_source/","title":"File Updateforcing.h","text":""},{"location":"BGFlood/Updateforcing_8h_source/#file-updateforcingh","title":"File Updateforcing.h","text":"<p>File List &gt; src &gt; Updateforcing.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef UPDATEFORCING_H\n#define UPDATEFORCING_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"InitialConditions.h\"\n#include \"MemManagement.h\"\n#include \"ReadForcing.h\"\n#include \"GridManip.h\"\n#include \"Util_CPU.h\"\n\ntemplate &lt;class T&gt; void updateforcing(Param XParam, Loop&lt;T&gt; XLoop, Forcing&lt;float&gt;&amp; XForcing);\n\nvoid Forcingthisstep(Param XParam, double totaltime, DynForcingP&lt;float&gt;&amp; XDynForcing);\n\ntemplate &lt;class T&gt; __device__ T interpDyn2BUQ(T x, T y, TexSetP Forcing);\n\ntemplate &lt;class T&gt; __host__ void AddwindforcingCPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Uwind, DynForcingP&lt;float&gt; Vwind, AdvanceP&lt;T&gt; XAdv);\ntemplate &lt;class T&gt; __global__ void AddwindforcingGPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Uwind, DynForcingP&lt;float&gt; Vwind, AdvanceP&lt;T&gt; XAdv);\n\ntemplate &lt;class T&gt; __host__ void AddrainforcingCPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Rain, AdvanceP&lt;T&gt; XAdv);\ntemplate &lt;class T&gt; __host__ void AddrainforcingImplicitCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Rain, EvolvingP&lt;T&gt; XEv);\ntemplate &lt;class T&gt; __global__ void AddrainforcingGPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Rain, AdvanceP&lt;T&gt; XAdv);\ntemplate &lt;class T&gt; __global__ void AddrainforcingImplicitGPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Rain, EvolvingP&lt;T&gt; XEv);\n\ntemplate &lt;class T&gt; __host__ void  AddinfiltrationImplicitCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, T* il, T* cl, EvolvingP&lt;T&gt; XEv, T* hgw);\ntemplate &lt;class T&gt; __global__ void AddinfiltrationImplicitGPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, T* il, T* cl, EvolvingP&lt;T&gt; XEv, T* hgw);\n\ntemplate &lt;class T&gt; __global__ void AddPatmforcingGPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; PAtm, Model&lt;T&gt; XModel);\ntemplate &lt;class T&gt; __host__ void AddPatmforcingCPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; PAtm, Model&lt;T&gt; XModel);\n\ntemplate &lt;class T&gt; __host__ void AddRiverForcing(Param XParam, Loop&lt;T&gt; XLoop, std::vector&lt;River&gt; XRivers, Model&lt;T&gt; XModel);\n\ntemplate &lt;class T&gt; void deformstep(Param XParam, Loop&lt;T&gt; XLoop, std::vector&lt;deformmap&lt;float&gt;&gt; deform, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g);\n\ntemplate &lt;class T&gt; __global__ void InjectRiverGPU(Param XParam, River XRiver, T qnow, int* Riverblks, BlockP&lt;T&gt; XBlock, AdvanceP&lt;T&gt; XAdv);\ntemplate &lt;class T&gt; __global__ void  AddDeformGPU(Param XParam, BlockP&lt;T&gt; XBlock, deformmap&lt;float&gt; defmap, EvolvingP&lt;T&gt; XEv, T scale, T* zb);\n\n\n#endif\n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/","title":"File Util_CPU.cu","text":""},{"location":"BGFlood/Util__CPU_8cu/#file-util_cpucu","title":"File Util_CPU.cu","text":"<p>FileList &gt; src &gt; Util_CPU.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Util_CPU.h\"</code></li> </ul>"},{"location":"BGFlood/Util__CPU_8cu/#namespaces","title":"Namespaces","text":"Type Name namespace utils"},{"location":"BGFlood/Util__CPU_8cu/#public-functions","title":"Public Functions","text":"Type Name T BarycentricInterpolation (T q1, T x1, T y1, T q2, T x2, T y2, T q3, T x3, T y3, T x, T y)  template float BarycentricInterpolation (float q1, float x1, float y1, float q2, float x2, float y2, float q3, float x3, float y3, float x, float y)  template double BarycentricInterpolation (double q1, double x1, double y1, double q2, double x2, double y2, double q3, double x3, double y3, double x, double y)  __host__ __device__ T BilinearInterpolation (T q11, T q12, T q21, T q22, T x1, T x2, T y1, T y2, T x, T y)  template __host__ __device__ double BilinearInterpolation&lt; double &gt; (double q11, double q12, double q21, double q22, double x1, double x2, double y1, double y2, double x, double y)  template __host__ __device__ float BilinearInterpolation&lt; float &gt; (float q11, float q12, float q21, float q22, float x1, float x2, float y1, float y2, float x, float y)  __host__ __device__ bool OBBdetect (T Axmin, T Axmax, T Aymin, T Aymax, T Bxmin, T Bxmax, T Bymin, T Bymax)  template __host__ __device__ bool OBBdetect (float Axmin, float Axmax, float Aymin, float Aymax, float Bxmin, float Bxmax, float Bymin, float Bymax)  template __host__ __device__ bool OBBdetect (double Axmin, double Axmax, double Aymin, double Aymax, double Bxmin, double Bxmax, double Bymin, double Bymax)  __host__ __device__ T calcres (T dx, int level)  __host__ __device__ T calcres (Param XParam, T dx, int level)  template __host__ __device__ double calcres&lt; double &gt; (double dx, int level)  template __host__ __device__ double calcres&lt; double &gt; (Param XParam, double dx, int level)  template __host__ __device__ float calcres&lt; float &gt; (float dx, int level)  template __host__ __device__ float calcres&lt; float &gt; (Param XParam, float dx, int level)  int ftoi (T value)  template int ftoi&lt; double &gt; (double value)  template int ftoi&lt; float &gt; (float value)  double interptime (double next, double prev, double timenext, double time)  __host__ __device__ T minmod2 (T theta, T s0, T s1, T s2)  template __host__ __device__ float minmod2 (float theta, float s0, float s1, float s2)  template __host__ __device__ double minmod2 (double theta, double s0, double s1, double s2)  unsigned int nextPow2 (unsigned int x)  __host__ __device__ T signof (T a)  template int signof (int a)  template float signof (float a)  template double signof (double a)"},{"location":"BGFlood/Util__CPU_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Util__CPU_8cu/#function-barycentricinterpolation","title":"function BarycentricInterpolation","text":"<pre><code>template&lt;class T&gt;\nT BarycentricInterpolation (\n    T q1,\n    T x1,\n    T y1,\n    T q2,\n    T x2,\n    T y2,\n    T q3,\n    T x3,\n    T y3,\n    T x,\n    T y\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-barycentricinterpolation_1","title":"function BarycentricInterpolation","text":"<pre><code>template float BarycentricInterpolation (\n    float q1,\n    float x1,\n    float y1,\n    float q2,\n    float x2,\n    float y2,\n    float q3,\n    float x3,\n    float y3,\n    float x,\n    float y\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-barycentricinterpolation_2","title":"function BarycentricInterpolation","text":"<pre><code>template double BarycentricInterpolation (\n    double q1,\n    double x1,\n    double y1,\n    double q2,\n    double x2,\n    double y2,\n    double q3,\n    double x3,\n    double y3,\n    double x,\n    double y\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-bilinearinterpolation","title":"function BilinearInterpolation","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T BilinearInterpolation (\n    T q11,\n    T q12,\n    T q21,\n    T q22,\n    T x1,\n    T x2,\n    T y1,\n    T y2,\n    T x,\n    T y\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-bilinearinterpolation-double","title":"function BilinearInterpolation&lt; double &gt;","text":"<pre><code>template __host__ __device__ double BilinearInterpolation&lt; double &gt; (\n    double q11,\n    double q12,\n    double q21,\n    double q22,\n    double x1,\n    double x2,\n    double y1,\n    double y2,\n    double x,\n    double y\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-bilinearinterpolation-float","title":"function BilinearInterpolation&lt; float &gt;","text":"<pre><code>template __host__ __device__ float BilinearInterpolation&lt; float &gt; (\n    float q11,\n    float q12,\n    float q21,\n    float q22,\n    float x1,\n    float x2,\n    float y1,\n    float y2,\n    float x,\n    float y\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-obbdetect","title":"function OBBdetect","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ bool OBBdetect (\n    T Axmin,\n    T Axmax,\n    T Aymin,\n    T Aymax,\n    T Bxmin,\n    T Bxmax,\n    T Bymin,\n    T Bymax\n) \n</code></pre> <p>Overlaping Bounding Box to detect which cell river falls into. It is the simplest version of the algorythm where the bounding box are paralle;l to the axis </p>"},{"location":"BGFlood/Util__CPU_8cu/#function-obbdetect_1","title":"function OBBdetect","text":"<pre><code>template __host__ __device__ bool OBBdetect (\n    float Axmin,\n    float Axmax,\n    float Aymin,\n    float Aymax,\n    float Bxmin,\n    float Bxmax,\n    float Bymin,\n    float Bymax\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-obbdetect_2","title":"function OBBdetect","text":"<pre><code>template __host__ __device__ bool OBBdetect (\n    double Axmin,\n    double Axmax,\n    double Aymin,\n    double Aymax,\n    double Bxmin,\n    double Bxmax,\n    double Bymin,\n    double Bymax\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-calcres","title":"function calcres","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T calcres (\n    T dx,\n    int level\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-calcres_1","title":"function calcres","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T calcres (\n    Param XParam,\n    T dx,\n    int level\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-calcres-double","title":"function calcres&lt; double &gt;","text":"<pre><code>template __host__ __device__ double calcres&lt; double &gt; (\n    double dx,\n    int level\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-calcres-double_1","title":"function calcres&lt; double &gt;","text":"<pre><code>template __host__ __device__ double calcres&lt; double &gt; (\n    Param XParam,\n    double dx,\n    int level\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-calcres-float","title":"function calcres&lt; float &gt;","text":"<pre><code>template __host__ __device__ float calcres&lt; float &gt; (\n    float dx,\n    int level\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-calcres-float_1","title":"function calcres&lt; float &gt;","text":"<pre><code>template __host__ __device__ float calcres&lt; float &gt; (\n    Param XParam,\n    float dx,\n    int level\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-ftoi","title":"function ftoi","text":"<pre><code>template&lt;class T&gt;\nint ftoi (\n    T value\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-ftoi-double","title":"function ftoi&lt; double &gt;","text":"<pre><code>template int ftoi&lt; double &gt; (\n    double value\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-ftoi-float","title":"function ftoi&lt; float &gt;","text":"<pre><code>template int ftoi&lt; float &gt; (\n    float value\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-interptime","title":"function interptime","text":"<pre><code>double interptime (\n    double next,\n    double prev,\n    double timenext,\n    double time\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-minmod2","title":"function minmod2","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T minmod2 (\n    T theta,\n    T s0,\n    T s1,\n    T s2\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-minmod2_1","title":"function minmod2","text":"<pre><code>template __host__ __device__ float minmod2 (\n    float theta,\n    float s0,\n    float s1,\n    float s2\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-minmod2_2","title":"function minmod2","text":"<pre><code>template __host__ __device__ double minmod2 (\n    double theta,\n    double s0,\n    double s1,\n    double s2\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-nextpow2","title":"function nextPow2","text":"<pre><code>unsigned int nextPow2 (\n    unsigned int x\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-signof","title":"function signof","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T signof (\n    T a\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-signof_1","title":"function signof","text":"<pre><code>template int signof (\n    int a\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-signof_2","title":"function signof","text":"<pre><code>template float signof (\n    float a\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8cu/#function-signof_3","title":"function signof","text":"<pre><code>template double signof (\n    double a\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Util_CPU.cu</code></p>"},{"location":"BGFlood/Util__CPU_8cu_source/","title":"File Util_CPU.cu","text":""},{"location":"BGFlood/Util__CPU_8cu_source/#file-util_cpucu","title":"File Util_CPU.cu","text":"<p>File List &gt; src &gt; Util_CPU.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n// This code contains an adaptation of the St Venant equation from Basilisk     //\n// See                                                                          //\n// http://basilisk.fr/src/saint-venant.h and                                    //\n// S. Popinet. Quadtree-adaptive tsunami modelling. Ocean Dynamics,             //\n// doi: 61(9) : 1261 - 1285, 2011                                               //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //\n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n\n#include \"Util_CPU.h\"\n\n\nnamespace utils {\n    template &lt;class T&gt; __host__ __device__ T sq(T a) {\n        return (a*a);\n    }\n\n    template &lt;class T&gt; __host__ __device__ const T&amp; max(const T&amp; a, const T&amp; b) {\n        return (a&lt;b) ? b : a;     // or: return comp(a,b)?b:a; for version (2)\n    }\n\n    template &lt;class T&gt; __host__ __device__ const T&amp; min(const T&amp; a, const T&amp; b) {\n        return !(b&lt;a) ? a : b;     // or: return comp(a,b)?b:a; for version (2)\n    }\n\n        template &lt;class T&gt; __host__ __device__ const T&amp; nearest(const T&amp; a, const T&amp; b, const T&amp; c) {\n        return abs(b - c) &gt; abs(a - c) ? a : b;     // Nearest element to c\n    }\n\n    template &lt;class T&gt; __host__ __device__ const T&amp; nearest(const T&amp; a, const T&amp; b) {\n        return abs(b) &gt; abs(a) ? a : b;     // Nearest element to 0.0\n    }\n/*\n    template &lt;class T&gt; __host__ __device__ const T&amp; floor(const T&amp; a) {\n        return abs(b) &gt; abs(a) ? a : b;\n    }\n*/\n\n    template __host__ __device__ const int&amp; min&lt;int&gt;(const int&amp; a, const int&amp; b);\n    template __host__ __device__ const float&amp; min&lt;float&gt;(const float&amp; a, const float&amp; b);\n    template __host__ __device__ const double&amp; min&lt;double&gt;(const double&amp; a, const double&amp; b);\n\n    template __host__ __device__ const int&amp; max&lt;int&gt;(const int&amp; a, const int&amp; b);\n    template __host__ __device__ const float&amp; max&lt;float&gt;(const float&amp; a, const float&amp; b);\n    template __host__ __device__ const double&amp; max&lt;double&gt;(const double&amp; a, const double&amp; b);\n\n    template int __host__ __device__ sq&lt;int&gt;(int a);\n    template float __host__ __device__ sq&lt;float&gt;(float a);\n    template double __host__ __device__ sq&lt;double&gt;(double a);\n\n    template __host__ __device__ const int&amp; nearest&lt;int&gt;(const int&amp; a, const int&amp; b, const int&amp; c);\n    template __host__ __device__ const float&amp; nearest&lt;float&gt;(const float&amp; a, const float&amp; b, const float&amp; c);\n    template __host__ __device__ const double&amp; nearest&lt;double&gt;(const double&amp; a, const double&amp; b, const double&amp; c);\n\n    template __host__ __device__ const int&amp; nearest&lt;int&gt;(const int&amp; a, const int&amp; b);\n    template __host__ __device__ const float&amp; nearest&lt;float&gt;(const float&amp; a, const float&amp; b);\n    template __host__ __device__ const double&amp; nearest&lt;double&gt;(const double&amp; a, const double&amp; b);\n\n}\n\nunsigned int nextPow2(unsigned int x)\n{\n    --x;\n    x |= x &gt;&gt; 1;\n    x |= x &gt;&gt; 2;\n    x |= x &gt;&gt; 4;\n    x |= x &gt;&gt; 8;\n    x |= x &gt;&gt; 16;\n    return ++x;\n}\n\n\ndouble interptime(double next, double prev, double timenext, double time)\n{\n    return prev + (time) / (timenext)*(next - prev);\n}\n\n\n\ntemplate &lt;class T&gt; __host__ __device__ T BilinearInterpolation(T q11, T q12, T q21, T q22, T x1, T x2, T y1, T y2, T x, T y)\n{\n    T x2x1, y2y1, x2x, y2y, yy1, xx1;\n    x2x1 = x2 - x1;\n    y2y1 = y2 - y1;\n    x2x = x2 - x;\n    y2y = y2 - y;\n    yy1 = y - y1;\n    xx1 = x - x1;\n    return (T)1.0 / (x2x1 * y2y1) * (\n        q11 * x2x * y2y +\n        q21 * xx1 * y2y +\n        q12 * x2x * yy1 +\n        q22 * xx1 * yy1\n        );\n}\n\ntemplate __host__ __device__ float BilinearInterpolation&lt;float&gt;(float q11, float q12, float q21, float q22, float x1, float x2, float y1, float y2, float x, float y);\ntemplate __host__ __device__ double BilinearInterpolation&lt;double&gt;(double q11, double q12, double q21, double q22, double x1, double x2, double y1, double y2, double x, double y);\n\n\ntemplate &lt;class T&gt; T BarycentricInterpolation(T q1, T x1, T y1, T q2, T x2, T y2, T q3, T x3, T y3, T x, T y)\n{\n    T w1, w2, w3, D;\n\n    D = (y2 - y3) * (x1 + x3) + (x3 - x2) * (y1 - y3);\n\n    w1 = ((y2 - y3) * (x - x3) + (x3 - x2) * (y - y3)) / D;\n    w2 = ((y3 - y1) * (x - x3) + (x1 - x3) * (y - y3)) / D;\n    w3 = 1 - w1 - w2;\n\n    return q1 * w1 + q2 * w2 + q3 * w3;\n}\n\ntemplate float BarycentricInterpolation(float q1, float x1, float y1, float q2, float x2, float y2, float q3, float x3, float y3, float x, float y);\ntemplate double BarycentricInterpolation(double q1, double x1, double y1, double q2, double x2, double y2, double q3, double x3, double y3, double x, double y);\n\n\n\ntemplate &lt;class T&gt;\n__host__ __device__ T calcres(T dx, int level)\n{\n    return  level &lt; 0 ? dx * (1 &lt;&lt; abs(level)) : dx / (1 &lt;&lt; level);\n    //should be 1&lt;&lt; -level\n}\ntemplate __host__ __device__ double calcres&lt;double&gt;(double dx, int level);\ntemplate __host__ __device__ float calcres&lt;float&gt;(float dx, int level);\n\ntemplate &lt;class T&gt;\n__host__ __device__ T calcres(Param XParam, T dx, int level)\n{\n    T ddx = calcres(dx, level); // here use dx as the cue for the compiler to use the float or double version of this function\n\n    if (XParam.spherical)\n    {\n        ddx = ddx * T(XParam.Radius * pi / 180.0);\n    }\n\n    return ddx;\n    //should be 1&lt;&lt; -level\n}\ntemplate __host__ __device__ double calcres&lt;double&gt;(Param XParam, double dx, int level);\ntemplate __host__ __device__ float calcres&lt;float&gt;(Param XParam, float dx, int level);\n\ntemplate &lt;class T&gt; __host__ __device__ T minmod2(T theta, T s0, T s1, T s2)\n{\n    //theta should be used as a global var\n    // can be used to tune the limiting (theta=1\n    //gives minmod, the most dissipative limiter and theta = 2 gives\n    //  superbee, the least dissipative).\n    //float theta = 1.3f;\n    if (s0 &lt; s1 &amp;&amp; s1 &lt; s2) {\n        T d1 = theta * (s1 - s0);\n        T d2 = (s2 - s0) / T(2.0);\n        T d3 = theta * (s2 - s1);\n        if (d2 &lt; d1) d1 = d2;\n        return min(d1, d3);\n    }\n    if (s0 &gt; s1 &amp;&amp; s1 &gt; s2) {\n        T d1 = theta * (s1 - s0), d2 = (s2 - s0) / T(2.0), d3 = theta * (s2 - s1);\n        if (d2 &gt; d1) d1 = d2;\n        return max(d1, d3);\n    }\n    return T(0.0);\n}\n\ntemplate __host__ __device__ float minmod2(float theta, float s0, float s1, float s2);\ntemplate __host__ __device__ double minmod2(double theta, double s0, double s1, double s2);\n\ntemplate &lt;class T&gt; __host__  __device__  bool OBBdetect(T Axmin, T Axmax, T Aymin, T Aymax, T Bxmin, T Bxmax, T Bymin, T Bymax)\n{\n    bool overlap = false;\n\n    bool testX = Bxmin &lt;= Axmax &amp;&amp; Bxmax &gt;= Axmin;\n    bool testY = Bymin &lt;= Aymax &amp;&amp; Bymax &gt;= Aymin;\n\n    overlap = testX &amp;&amp; testY;\n\n    return overlap;\n}\n\ntemplate __host__  __device__  bool OBBdetect(float Axmin, float Axmax, float Aymin, float Aymax, float Bxmin, float Bxmax, float Bymin, float Bymax);\ntemplate __host__  __device__  bool OBBdetect(double Axmin, double Axmax, double Aymin, double Aymax, double Bxmin, double Bxmax, double Bymin, double Bymax);\n\n\ntemplate &lt;class T&gt; int ftoi(T value) {\n    return (value &gt;= 0 ? static_cast&lt;int&gt;(value + 0.5)\n        : static_cast&lt;int&gt;(value - 0.5));\n}\ntemplate int ftoi&lt;float&gt;(float value);\ntemplate int ftoi&lt;double&gt;(double value);\n\ntemplate &lt;class T&gt; __host__ __device__ T signof(T a)\n{\n\n    return a &gt; T(0.0) ? T(1.0) : T(-1.0);\n}\ntemplate int signof(int a);\ntemplate float signof(float a);\ntemplate double signof(double a);\n</code></pre>"},{"location":"BGFlood/Util__CPU_8h/","title":"File Util_CPU.h","text":""},{"location":"BGFlood/Util__CPU_8h/#file-util_cpuh","title":"File Util_CPU.h","text":"<p>FileList &gt; src &gt; Util_CPU.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> </ul>"},{"location":"BGFlood/Util__CPU_8h/#namespaces","title":"Namespaces","text":"Type Name namespace utils"},{"location":"BGFlood/Util__CPU_8h/#public-functions","title":"Public Functions","text":"Type Name __host__ __device__ T BarycentricInterpolation (T q1, T x1, T y1, T q2, T x2, T y2, T q3, T x3, T y3, T x, T y)  __host__ __device__ T BilinearInterpolation (T q11, T q12, T q21, T q22, T x1, T x2, T y1, T y2, T x, T y)  __host__ __device__ bool OBBdetect (T Axmin, T Axmax, T Aymin, T Aymax, T Bxmin, T Bxmax, T Bymin, T Bymax)  __host__ __device__ T calcres (T dx, int level)  int ftoi (T value)  double interptime (double next, double prev, double timenext, double time)  __host__ __device__ T minmod2 (T theta, T s0, T s1, T s2)  unsigned int nextPow2 (unsigned int x)  __host__ __device__ T signof (T a)"},{"location":"BGFlood/Util__CPU_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Util__CPU_8h/#function-barycentricinterpolation","title":"function BarycentricInterpolation","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T BarycentricInterpolation (\n    T q1,\n    T x1,\n    T y1,\n    T q2,\n    T x2,\n    T y2,\n    T q3,\n    T x3,\n    T y3,\n    T x,\n    T y\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8h/#function-bilinearinterpolation","title":"function BilinearInterpolation","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T BilinearInterpolation (\n    T q11,\n    T q12,\n    T q21,\n    T q22,\n    T x1,\n    T x2,\n    T y1,\n    T y2,\n    T x,\n    T y\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8h/#function-obbdetect","title":"function OBBdetect","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ bool OBBdetect (\n    T Axmin,\n    T Axmax,\n    T Aymin,\n    T Aymax,\n    T Bxmin,\n    T Bxmax,\n    T Bymin,\n    T Bymax\n) \n</code></pre> <p>Overlaping Bounding Box to detect which cell river falls into. It is the simplest version of the algorythm where the bounding box are paralle;l to the axis </p>"},{"location":"BGFlood/Util__CPU_8h/#function-calcres","title":"function calcres","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T calcres (\n    T dx,\n    int level\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8h/#function-ftoi","title":"function ftoi","text":"<pre><code>template&lt;class T&gt;\nint ftoi (\n    T value\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8h/#function-interptime","title":"function interptime","text":"<pre><code>double interptime (\n    double next,\n    double prev,\n    double timenext,\n    double time\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8h/#function-minmod2","title":"function minmod2","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T minmod2 (\n    T theta,\n    T s0,\n    T s1,\n    T s2\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8h/#function-nextpow2","title":"function nextPow2","text":"<pre><code>unsigned int nextPow2 (\n    unsigned int x\n) \n</code></pre>"},{"location":"BGFlood/Util__CPU_8h/#function-signof","title":"function signof","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ T signof (\n    T a\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Util_CPU.h</code></p>"},{"location":"BGFlood/Util__CPU_8h_source/","title":"File Util_CPU.h","text":""},{"location":"BGFlood/Util__CPU_8h_source/#file-util_cpuh","title":"File Util_CPU.h","text":"<p>File List &gt; src &gt; Util_CPU.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef UTILCPU_H\n#define UTILCPU_H\n\n#include \"General.h\"\n#include \"Param.h\"\n\nnamespace utils {\n    template &lt;class T&gt; __host__ __device__ T sq(T a);\n    template &lt;class T&gt; __host__ __device__ const T&amp; max(const T&amp; a, const T&amp; b);\n    template &lt;class T&gt; __host__ __device__ const T&amp; min(const T&amp; a, const T&amp; b);\n    template &lt;class T&gt; __host__ __device__ const T&amp; nearest(const T&amp; a, const T&amp; b, const T&amp; c);\n    template &lt;class T&gt; __host__ __device__ const T&amp; nearest(const T&amp; a, const T&amp; b);\n\n    //template &lt;&gt;\n\n}\n\n\nunsigned int nextPow2(unsigned int x);\n\ndouble interptime(double next, double prev, double timenext, double time);\n\ntemplate &lt;class T&gt;  __host__ __device__ T BilinearInterpolation(T q11, T q12, T q21, T q22, T x1, T x2, T y1, T y2, T x, T y);\ntemplate &lt;class T&gt;  __host__ __device__ T BarycentricInterpolation(T q1, T x1, T y1, T q2, T x2, T y2, T q3, T x3, T y3, T x, T y);\n\ntemplate &lt;class T&gt; __host__ __device__ T calcres(T dx, int level);\ntemplate &lt;class T&gt; __host__ __device__ T minmod2(T theta, T s0, T s1, T s2);\n\ntemplate &lt;class T&gt; __host__  __device__  bool OBBdetect(T Axmin, T Axmax, T Aymin, T Aymax, T Bxmin, T Bxmax, T Bymin, T Bymax);\n\ntemplate &lt;class T&gt; __host__ __device__ T signof(T a);\n\ntemplate &lt;class T&gt; int ftoi(T value);\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/","title":"File Write_netcdf.cu","text":""},{"location":"BGFlood/Write__netcdf_8cu/#file-write_netcdfcu","title":"File Write_netcdf.cu","text":"<p>FileList &gt; src &gt; Write_netcdf.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Write_netcdf.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"General.h\"</code></li> </ul>"},{"location":"BGFlood/Write__netcdf_8cu/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; int &gt; Calcactiveblockzone (Param XParam, int * activeblk, outzoneB Xzone)  void Calcnxny (Param XParam, int level, int &amp; nx, int &amp; ny)  void Calcnxnyzone (Param XParam, int level, int &amp; nx, int &amp; ny, outzoneB Xzone)  void InitSave2Netcdf (Param &amp; XParam, Model&lt; T &gt; &amp; XModel)  template void InitSave2Netcdf&lt; double &gt; (Param &amp; XParam, Model&lt; double &gt; &amp; XModel)  template void InitSave2Netcdf&lt; float &gt; (Param &amp; XParam, Model&lt; float &gt; &amp; XModel)  void Save2Netcdf (Param XParam, Loop&lt; T &gt; XLoop, Model&lt; T &gt; &amp; XModel)  template void Save2Netcdf&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, Model&lt; double &gt; &amp; XModel)  template void Save2Netcdf&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, Model&lt; float &gt; &amp; XModel)  void create2dnc (char * filename, int nx, int ny, double * xx, double * yy, double * var, char * varname)  void create3dnc (char * name, int nx, int ny, int nt, double * xx, double * yy, double * theta, double * var, char * varname)  void creatncfileBUQ (Param &amp; XParam, int * activeblk, int * level, T * blockxo, T * blockyo, outzoneB &amp; Xzone)  void creatncfileBUQ (Param &amp; XParam, BlockP&lt; T &gt; &amp; XBlock)  template void creatncfileBUQ&lt; double &gt; (Param &amp; XParam, int * activeblk, int * level, double * blockxo, double * blockyo, outzoneB &amp; Xzone)  template void creatncfileBUQ&lt; double &gt; (Param &amp; XParam, BlockP&lt; double &gt; &amp; XBlock)  template void creatncfileBUQ&lt; float &gt; (Param &amp; XParam, int * activeblk, int * level, float * blockxo, float * blockyo, outzoneB &amp; Xzone)  template void creatncfileBUQ&lt; float &gt; (Param &amp; XParam, BlockP&lt; float &gt; &amp; XBlock)  void defncvarBUQ (Param XParam, int * activeblk, int * level, T * blockxo, T * blockyo, std::string varst, int vdim, T * var, outzoneB Xzone)  void defncvarBUQ (Param XParam, int * activeblk, int * level, T * blockxo, T * blockyo, std::string varst, std::string longname, std::string stdname, std::string unit, int vdim, T * var, outzoneB Xzone)  template void defncvarBUQ&lt; double &gt; (Param XParam, int * activeblk, int * level, double * blockxo, double * blockyo, std::string varst, int vdim, double * var, outzoneB Xzone)  template void defncvarBUQ&lt; float &gt; (Param XParam, int * activeblk, int * level, float * blockxo, float * blockyo, std::string varst, int vdim, float * var, outzoneB Xzone)  void defncvarBUQlev (Param XParam, int * activeblk, int * level, T * blockxo, T * blockyo, std::string varst, std::string longname, std::string stdname, std::string unit, int vdim, T * var, outzoneB Xzone)  void handle_ncerror (int status)  void write2dvarnc (int nx, int ny, double totaltime, double * var)  void write3dvarnc (int nx, int ny, int nt, double totaltime, double * var)  void writenctimestep (std::string outfile, double totaltime)  void writencvarstepBUQ (Param XParam, int vdim, int * activeblk, int * level, T * blockxo, T * blockyo, std::string varst, T * var, outzoneB Xzone)  template void writencvarstepBUQ&lt; double &gt; (Param XParam, int vdim, int * activeblk, int * level, double * blockxo, double * blockyo, std::string varst, double * var, outzoneB Xzone)  template void writencvarstepBUQ&lt; float &gt; (Param XParam, int vdim, int * activeblk, int * level, float * blockxo, float * blockyo, std::string varst, float * var, outzoneB Xzone)  void writencvarstepBUQlev (Param XParam, int vdim, int * activeblk, int * level, T * blockxo, T * blockyo, std::string varst, T * var, outzoneB Xzone)  template void writencvarstepBUQlev&lt; double &gt; (Param XParam, int vdim, int * activeblk, int * level, double * blockxo, double * blockyo, std::string varst, double * var, outzoneB Xzone)  template void writencvarstepBUQlev&lt; float &gt; (Param XParam, int vdim, int * activeblk, int * level, float * blockxo, float * blockyo, std::string varst, float * var, outzoneB Xzone)"},{"location":"BGFlood/Write__netcdf_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Write__netcdf_8cu/#function-calcactiveblockzone","title":"function Calcactiveblockzone","text":"<pre><code>std::vector&lt; int &gt; Calcactiveblockzone (\n    Param XParam,\n    int * activeblk,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-calcnxny","title":"function Calcnxny","text":"<pre><code>void Calcnxny (\n    Param XParam,\n    int level,\n    int &amp; nx,\n    int &amp; ny\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-calcnxnyzone","title":"function Calcnxnyzone","text":"<pre><code>void Calcnxnyzone (\n    Param XParam,\n    int level,\n    int &amp; nx,\n    int &amp; ny,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-initsave2netcdf","title":"function InitSave2Netcdf","text":"<pre><code>template&lt;class T&gt;\nvoid InitSave2Netcdf (\n    Param &amp; XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-initsave2netcdf-double","title":"function InitSave2Netcdf&lt; double &gt;","text":"<pre><code>template void InitSave2Netcdf&lt; double &gt; (\n    Param &amp; XParam,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-initsave2netcdf-float","title":"function InitSave2Netcdf&lt; float &gt;","text":"<pre><code>template void InitSave2Netcdf&lt; float &gt; (\n    Param &amp; XParam,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-save2netcdf","title":"function Save2Netcdf","text":"<pre><code>template&lt;class T&gt;\nvoid Save2Netcdf (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-save2netcdf-double","title":"function Save2Netcdf&lt; double &gt;","text":"<pre><code>template void Save2Netcdf&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-save2netcdf-float","title":"function Save2Netcdf&lt; float &gt;","text":"<pre><code>template void Save2Netcdf&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-create2dnc","title":"function create2dnc","text":"<pre><code>void create2dnc (\n    char * filename,\n    int nx,\n    int ny,\n    double * xx,\n    double * yy,\n    double * var,\n    char * varname\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-create3dnc","title":"function create3dnc","text":"<pre><code>void create3dnc (\n    char * name,\n    int nx,\n    int ny,\n    int nt,\n    double * xx,\n    double * yy,\n    double * theta,\n    double * var,\n    char * varname\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-creatncfilebuq","title":"function creatncfileBUQ","text":"<pre><code>template&lt;class T&gt;\nvoid creatncfileBUQ (\n    Param &amp; XParam,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    outzoneB &amp; Xzone\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-creatncfilebuq_1","title":"function creatncfileBUQ","text":"<pre><code>template&lt;class T&gt;\nvoid creatncfileBUQ (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-creatncfilebuq-double","title":"function creatncfileBUQ&lt; double &gt;","text":"<pre><code>template void creatncfileBUQ&lt; double &gt; (\n    Param &amp; XParam,\n    int * activeblk,\n    int * level,\n    double * blockxo,\n    double * blockyo,\n    outzoneB &amp; Xzone\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-creatncfilebuq-double_1","title":"function creatncfileBUQ&lt; double &gt;","text":"<pre><code>template void creatncfileBUQ&lt; double &gt; (\n    Param &amp; XParam,\n    BlockP &lt; double &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-creatncfilebuq-float","title":"function creatncfileBUQ&lt; float &gt;","text":"<pre><code>template void creatncfileBUQ&lt; float &gt; (\n    Param &amp; XParam,\n    int * activeblk,\n    int * level,\n    float * blockxo,\n    float * blockyo,\n    outzoneB &amp; Xzone\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-creatncfilebuq-float_1","title":"function creatncfileBUQ&lt; float &gt;","text":"<pre><code>template void creatncfileBUQ&lt; float &gt; (\n    Param &amp; XParam,\n    BlockP &lt; float &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-defncvarbuq","title":"function defncvarBUQ","text":"<pre><code>template&lt;class T&gt;\nvoid defncvarBUQ (\n    Param XParam,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    std::string varst,\n    int vdim,\n    T * var,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-defncvarbuq_1","title":"function defncvarBUQ","text":"<pre><code>template&lt;class T&gt;\nvoid defncvarBUQ (\n    Param XParam,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    std::string varst,\n    std::string longname,\n    std::string stdname,\n    std::string unit,\n    int vdim,\n    T * var,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-defncvarbuq-double","title":"function defncvarBUQ&lt; double &gt;","text":"<pre><code>template void defncvarBUQ&lt; double &gt; (\n    Param XParam,\n    int * activeblk,\n    int * level,\n    double * blockxo,\n    double * blockyo,\n    std::string varst,\n    int vdim,\n    double * var,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-defncvarbuq-float","title":"function defncvarBUQ&lt; float &gt;","text":"<pre><code>template void defncvarBUQ&lt; float &gt; (\n    Param XParam,\n    int * activeblk,\n    int * level,\n    float * blockxo,\n    float * blockyo,\n    std::string varst,\n    int vdim,\n    float * var,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-defncvarbuqlev","title":"function defncvarBUQlev","text":"<pre><code>template&lt;class T&gt;\nvoid defncvarBUQlev (\n    Param XParam,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    std::string varst,\n    std::string longname,\n    std::string stdname,\n    std::string unit,\n    int vdim,\n    T * var,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-handle_ncerror","title":"function handle_ncerror","text":"<pre><code>void handle_ncerror (\n    int status\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-write2dvarnc","title":"function write2dvarnc","text":"<pre><code>void write2dvarnc (\n    int nx,\n    int ny,\n    double totaltime,\n    double * var\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-write3dvarnc","title":"function write3dvarnc","text":"<pre><code>void write3dvarnc (\n    int nx,\n    int ny,\n    int nt,\n    double totaltime,\n    double * var\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-writenctimestep","title":"function writenctimestep","text":"<pre><code>void writenctimestep (\n    std::string outfile,\n    double totaltime\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-writencvarstepbuq","title":"function writencvarstepBUQ","text":"<pre><code>template&lt;class T&gt;\nvoid writencvarstepBUQ (\n    Param XParam,\n    int vdim,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    std::string varst,\n    T * var,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-writencvarstepbuq-double","title":"function writencvarstepBUQ&lt; double &gt;","text":"<pre><code>template void writencvarstepBUQ&lt; double &gt; (\n    Param XParam,\n    int vdim,\n    int * activeblk,\n    int * level,\n    double * blockxo,\n    double * blockyo,\n    std::string varst,\n    double * var,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-writencvarstepbuq-float","title":"function writencvarstepBUQ&lt; float &gt;","text":"<pre><code>template void writencvarstepBUQ&lt; float &gt; (\n    Param XParam,\n    int vdim,\n    int * activeblk,\n    int * level,\n    float * blockxo,\n    float * blockyo,\n    std::string varst,\n    float * var,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-writencvarstepbuqlev","title":"function writencvarstepBUQlev","text":"<pre><code>template&lt;class T&gt;\nvoid writencvarstepBUQlev (\n    Param XParam,\n    int vdim,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    std::string varst,\n    T * var,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-writencvarstepbuqlev-double","title":"function writencvarstepBUQlev&lt; double &gt;","text":"<pre><code>template void writencvarstepBUQlev&lt; double &gt; (\n    Param XParam,\n    int vdim,\n    int * activeblk,\n    int * level,\n    double * blockxo,\n    double * blockyo,\n    std::string varst,\n    double * var,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8cu/#function-writencvarstepbuqlev-float","title":"function writencvarstepBUQlev&lt; float &gt;","text":"<pre><code>template void writencvarstepBUQlev&lt; float &gt; (\n    Param XParam,\n    int vdim,\n    int * activeblk,\n    int * level,\n    float * blockxo,\n    float * blockyo,\n    std::string varst,\n    float * var,\n    outzoneB Xzone\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Write_netcdf.cu</code></p>"},{"location":"BGFlood/Write__netcdf_8cu_source/","title":"File Write_netcdf.cu","text":""},{"location":"BGFlood/Write__netcdf_8cu_source/#file-write_netcdfcu","title":"File Write_netcdf.cu","text":"<p>File List &gt; src &gt; Write_netcdf.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Write_netcdf.h\"\n#include \"Util_CPU.h\"\n#include \"General.h\"\n\nvoid handle_ncerror(int status) {\n\n\n    if (status != NC_NOERR) {\n        fprintf(stderr, \"Netcdf %s\\n\", nc_strerror(status));\n        std::ostringstream stringStream;\n        stringStream &lt;&lt; nc_strerror(status);\n        std::string copyOfStr = stringStream.str();\n        log(\"Netcdf error:\" + copyOfStr);\n        //fprintf(logfile, \"Netcdf: %s\\n\", nc_strerror(status));\n        exit(2);\n    }\n}\n\nvoid Calcnxny(Param XParam, int level, int&amp; nx, int&amp; ny)\n{\n    double ddx = calcres(XParam.dx, level);\n    double dxp = calcres(XParam.dx, level + 1);\n    double xxmax, xxmin, yymax, yymin;\n\n    xxmax = XParam.xmax - dxp;\n    yymax = XParam.ymax - dxp;\n\n    xxmin = XParam.xo + dxp;\n    yymin = XParam.yo + dxp;\n\n    nx = ftoi(round((xxmax - xxmin) / ddx + 1.0));\n    ny = ftoi(round((yymax - yymin) / ddx + 1.0));\n}\n\nvoid Calcnxnyzone(Param XParam, int level, int&amp; nx, int&amp; ny, outzoneB Xzone)\n{\n    double ddx = calcres(XParam.dx, level);\n    double xxmax, xxmin, yymax, yymin;\n\n    xxmax = Xzone.xmax;\n    yymax = Xzone.ymax;\n\n    xxmin = Xzone.xo;\n    yymin = Xzone.yo;\n\n    nx = ftoi((xxmax - xxmin) / ddx);\n    ny = ftoi((yymax - yymin) / ddx);\n}\n\nstd::vector&lt;int&gt; Calcactiveblockzone(Param XParam, int* activeblk, outzoneB Xzone)\n{\n    std::vector&lt;int&gt; actblkzone(Xzone.nblk, -1);\n    int* inactive, * inblock;\n\n    for (int ib = 0; ib &lt; Xzone.nblk; ib++)\n    {\n        //printf(\"loop=%i \\n\", Xzone.blk[ib]);\n        inactive = std::find(activeblk, activeblk + XParam.nblk, Xzone.blk[ib]);\n        inblock = std::find(Xzone.blk, Xzone.blk + Xzone.nblk, Xzone.blk[ib]);\n        //if ((inactive != activeblk + XParam.nblk) &amp;&amp; (inblock != Xzone.blk + Xzone.nblk))\n        if (inactive != activeblk + XParam.nblk)\n        {\n            //printf(\"active=%i \\n\", Xzone.blk[ib]);\n            if (inblock != Xzone.blk + Xzone.nblk)\n            {\n                actblkzone[ib] = Xzone.blk[ib];\n                //printf(\"block=%i \\n\", Xzone.blk[ib]);\n            }\n            else { actblkzone[ib] = -1; }\n        }\n        else\n        {\n            actblkzone[ib] = -1;\n        }\n    }\n    return(actblkzone);\n}\n\ntemplate&lt;class T&gt;\nvoid creatncfileBUQ(Param&amp; XParam, int* activeblk, int* level, T* blockxo, T* blockyo, outzoneB&amp; Xzone)\n{\n\n    int status;\n    int nx, ny;\n    //double dx = XParam.dx;\n    size_t nxx, nyy;\n    int ncid, xx_dim, yy_dim, time_dim, blockid_dim, nblk;\n    double* xval, * yval;\n\n    int BGFloodoutversion = 0;// integer to quickly identify the output as BG_flood or not\n\n    //const int minlevzone = XParam.minlevel;\n    //const int maxlevzone = XParam.maxlevel;\n\n    std::vector&lt;int&gt; activeblkzone = Calcactiveblockzone(XParam, activeblk, Xzone);\n    //Calclevelzone(XParam, minlevzone, maxlevzone, Xzone, level);\n    nblk = Xzone.nblk;\n\n\n    // create the netcdf dataset Xzone.outname.c_str()\n    status = nc_create(Xzone.outname.c_str(), NC_NOCLOBBER | NC_NETCDF4, &amp;ncid);\n    if (status != NC_NOERR)\n    {\n        if (status == NC_EEXIST) // File already exist so automatically rename the output file \n        {\n            //printf(\"Warning! Output file name already exist  \");\n            log(\"Warning! Output file name already exist   \");\n            int fileinc = 1;\n            std::vector&lt;std::string&gt; extvec = split(Xzone.outname, '.');\n            std::string bathyext = extvec.back();\n            std::string newname;\n\n            while (status == NC_EEXIST)\n            {\n                newname = extvec[0];\n                for (int nstin = 1; nstin &lt; extvec.size() - 1; nstin++)\n                {\n                    // This is in case there are \".\" in the file name that do not relate to the file extension\"\n                    newname = newname + \".\" + extvec[nstin];\n                }\n                newname = newname + \"_\" + std::to_string(fileinc) + \".\" + bathyext;\n                Xzone.outname = newname;\n                status = nc_create(Xzone.outname.c_str(), NC_NOCLOBBER | NC_NETCDF4, &amp;ncid);\n                fileinc++;\n            }\n            //printf(\"New file name: %s  \", Xzone.outname.c_str());\n            log(\"New file name: \" + Xzone.outname);\n\n        }\n        else\n        {\n            // Other error\n            handle_ncerror(status);\n        }\n    }\n\n    // status could be a new error after renaming the file\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    double initdx = calcres(XParam.dx, XParam.initlevel);\n    double xmin, xmax, ymin, ymax;\n\n    xmin = Xzone.xo;\n    xmax = Xzone.xmax;\n    ymin = Xzone.yo;\n    ymax = Xzone.ymax;\n\n\n\n    // Define global attributes\n    status = nc_put_att_int(ncid, NC_GLOBAL, \"maxlevel\", NC_INT, 1, &amp;Xzone.maxlevel);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_put_att_int(ncid, NC_GLOBAL, \"minlevel\", NC_INT, 1, &amp;Xzone.minlevel);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_put_att_double(ncid, NC_GLOBAL, \"xmin\", NC_DOUBLE, 1, &amp;xmin);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_put_att_double(ncid, NC_GLOBAL, \"xmax\", NC_DOUBLE, 1, &amp;xmax);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_put_att_double(ncid, NC_GLOBAL, \"ymin\", NC_DOUBLE, 1, &amp;ymin);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_put_att_double(ncid, NC_GLOBAL, \"ymax\", NC_DOUBLE, 1, &amp;ymax);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n    status = nc_put_att_text(ncid, NC_GLOBAL, \"Conventions\", 14,\"CF-1.11-draft\");\n\n    // Define global attribute for identifying BG_Flood\n    status = nc_put_att_int(ncid, NC_GLOBAL, \"BG_Flood\", NC_INT, 1, &amp;BGFloodoutversion);\n\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n    // Define time variable \n    status = nc_def_dim(ncid, \"time\", NC_UNLIMITED, &amp;time_dim);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    int time_id, xx_id, yy_id;\n    int tdim[] = { time_dim };\n\n    //########################\n    //static size_t tst[] = { 0 };\n    size_t blkstart[] = { 0 }; // Xzone.blk[0]};\n    size_t blkcount[] = { (size_t)Xzone.nblk };\n    size_t xcount[] = { 0 };\n    size_t ycount[] = { 0 };\n    static size_t xstart[] = { 0 }; // start at first value\n    static size_t ystart[] = { 0 };\n    status = nc_def_var(ncid, \"time\", NC_FLOAT, 1, tdim, &amp;time_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    static char txtname[] = \"time\";\n    status = nc_put_att_text(ncid, time_id, \"standard_name\", strlen(txtname), txtname);\n    //status = nc_put_att_string(ncid, time_id, \"standard_name\", 1, \"time\");\n    //units = \"days since 1990-1-1 0:0:0\";\n\n    std::string timestr = \"seconds since \" + XParam.reftime;\n    const char* timeunit = timestr.c_str();\n\n    status = nc_put_att_text(ncid, time_id, \"units\", strlen(timeunit), timeunit);\n\n    std::string timeaxis = \"T\";\n\n    status = nc_put_att_text(ncid, time_id, \"axis\", timeaxis.size(), timeaxis.c_str());\n\n    //static char calendarname[] = \"standard\";\n    //status = nc_put_att_text(ncid, time_id, \"calendar\", strlen(calendarname), calendarname);\n\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n    int crsid;\n    std::string crsname;\n    status = nc_def_var(ncid, \"crs\", NC_INT, 0, tdim, &amp;crsid);\n    if (XParam.spherical == 1)\n    {\n        crsname = \"latitude_longitude\";\n\n        float primemeridian = 0.0f;\n        float sma = 6378137.0f;\n        float iflat = 298.257223563f;\n        status = nc_put_att_text(ncid, crsid, \"grid_mapping_name\", crsname.size(), crsname.c_str());\n        status = nc_put_att_float(ncid, crsid, \"longitude_of_prime_meridian\", NC_FLOAT, 1, &amp;primemeridian);\n        status = nc_put_att_float(ncid, crsid, \"semi_major_axis\", NC_FLOAT, 1, &amp;sma);\n        status = nc_put_att_float(ncid, crsid, \"inverse_flattening\", NC_FLOAT, 1, &amp;iflat);\n    }\n    else\n    {\n        crsname = \"projected\";\n        std::string proj = XParam.crs_ref;\n        //\"+proj=tmerc +lat_0=0 +lon_0=173 +k=0.9996 +x_0=1600000 +y_0=10000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\";\n        status = nc_put_att_text(ncid, crsid, \"grid_mapping_name\", crsname.size(), crsname.c_str());\n        status = nc_put_att_text(ncid, crsid, \"crs_wkt\", proj.size(), proj.c_str());\n        status = nc_put_att_text(ncid, crsid, \"spatial_ref\", proj.size(), proj.c_str());\n        //status = nc_put_att_float(ncid, crsid, \"semi_major_axis\", NC_FLOAT, 1, 6378137.0);\n        //status = nc_put_att_float(ncid, crsid, \"inverse_flattening\", NC_FLOAT, 1, 298.257223563);\n    }\n\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    int bgfid;\n\n    // Model variable to store parameters\n    status = nc_def_var(ncid, \"BGFlood\", NC_INT, 0, tdim, &amp;bgfid);\n    saveparam2netCDF(ncid, bgfid, XParam);\n\n\n    // Define dimensions and variables to store block id, status, level xo, yo\n\n    status = nc_def_dim(ncid, \"blockid\", nblk, &amp;blockid_dim);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    int biddim[] = { blockid_dim };\n    int blkid_id, blkxo_id, blkyo_id, blklevel_id, blkwidth_id, blkstatus_id;\n\n    status = nc_def_var(ncid, \"blockid\", NC_INT, 1, biddim, &amp;blkid_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_def_var(ncid, \"blockxo\", NC_FLOAT, 1, biddim, &amp;blkxo_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_def_var(ncid, \"blockyo\", NC_FLOAT, 1, biddim, &amp;blkyo_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_def_var(ncid, \"blockwidth\", NC_FLOAT, 1, biddim, &amp;blkwidth_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_def_var(ncid, \"blocklevel\", NC_INT, 1, biddim, &amp;blklevel_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_def_var(ncid, \"blockstatus\", NC_INT, 1, biddim, &amp;blkstatus_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //int* levZone;\n    std::string xaxis = \"X\";\n    std::string yaxis = \"Y\";\n    // For each level Define xx yy \n    for (int lev = Xzone.minlevel; lev &lt;= Xzone.maxlevel; lev++)\n    {\n\n        Calcnxnyzone(XParam, lev, nx, ny, Xzone);\n\n        //printf(\"lev=%d;  xxmin=%f; xxmax=%f; nx=%d\\n\", lev, xmin, xmax, nx);\n        //printf(\"lev=%d;  yymin=%f; yymax=%f; ny=%d\\n\", lev,  ymin, ymax, ny);\n\n        //to change type from int to size_t\n        nxx = nx;\n        nyy = ny;\n\n        //Define dimensions: Name and length\n        std::string xxname, yyname, sign;\n\n        lev &lt; 0 ? sign = \"N\" : sign = \"P\";\n\n\n        xxname = \"xx_\" + sign + std::to_string(abs(lev));\n        yyname = \"yy_\" + sign + std::to_string(abs(lev));\n\n        //printf(\"lev=%d; xxname=%s; yyname=%s;\\n\", lev, xxname.c_str(), yyname.c_str());\n        //printf(\"ddx=%f; nxx=%d;\\n\", ddx, nxx);\n        status = nc_def_dim(ncid, xxname.c_str(), nxx, &amp;xx_dim);\n        if (status != NC_NOERR) handle_ncerror(status);\n        status = nc_def_dim(ncid, yyname.c_str(), nyy, &amp;yy_dim);\n        if (status != NC_NOERR) handle_ncerror(status);\n        //status = nc_def_dim(ncid, \"npart\",nnpart,&amp;p_dim);\n\n        int xdim[] = { xx_dim };\n        int ydim[] = { yy_dim };\n\n\n\n        status = nc_def_var(ncid, xxname.c_str(), NC_DOUBLE, 1, xdim, &amp;xx_id);\n        if (status != NC_NOERR) handle_ncerror(status);\n        status = nc_def_var(ncid, yyname.c_str(), NC_DOUBLE, 1, ydim, &amp;yy_id);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n\n\n\n        status = nc_put_att_text(ncid, xx_id, \"axis\", xaxis.size(), xaxis.c_str());\n        status = nc_put_att_text(ncid, yy_id, \"axis\", yaxis.size(), yaxis.c_str());\n        //End definitions: leave define mode\n    }\n    status = nc_enddef(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //status = nc_close(ncid);\n    //if (status != NC_NOERR) handle_ncerror(status);\n\n    float* blkwidth;\n    int* blkid;\n    int ibl;\n\n\n    AllocateCPU(1, nblk, blkwidth);\n    AllocateCPU(1, nblk, blkid);\n\n    //printf(\"blockId:\\n\");\n    for (int ib = 0; ib &lt; nblk; ib++)\n    {\n        //int ibl = activeblk[Xzone.blk[ib]];\n        ibl = activeblkzone[ib];\n        blkwidth[ib] = (float)calcres(XParam.dx, level[ibl]);\n        blkid[ib] = ibl;\n    }\n\n\n    status = nc_put_vara_int(ncid, blkid_id, blkstart, blkcount, blkid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //status = nc_put_vara_int(ncid, blkstatus_id, blkstart, blkcount, activeblk);\n    status = nc_put_vara_float(ncid, blkwidth_id, blkstart, blkcount, blkwidth);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n    // Reusing blkwidth/blkid for other array (for blkxo/blklevel and blkyo) to save memory space\n\n    // This is needed because the blockxo array may be shuffled to memory block beyond nblk\n    for (int ib = 0; ib &lt; nblk; ib++)\n    {\n        //int ibl = activeblk[Xzone.blk[ib]];\n        ibl = activeblkzone[ib];\n        blkwidth[ib] = float(T(XParam.xo) + blockxo[ibl]);\n        blkid[ib] = level[ibl];\n\n    }\n\n    status = nc_put_vara_float(ncid, blkxo_id, blkstart, blkcount, blkwidth);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_put_vara_int(ncid, blklevel_id, blkstart, blkcount, blkid);\n\n    for (int ib = 0; ib &lt; nblk; ib++)\n    {\n        //int ibl = activeblk[Xzone.blk[ib]];\n        ibl = activeblkzone[ib];\n        blkwidth[ib] = float(T(XParam.yo) + blockyo[ibl]);\n    }\n\n    status = nc_put_vara_float(ncid, blkyo_id, blkstart, blkcount, blkwidth);\n\n\n    free(blkid);\n    free(blkwidth);\n\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    std::string xxname, yyname, sign;\n\n    for (int lev = Xzone.minlevel; lev &lt;= Xzone.maxlevel; lev++)\n    {\n        Calcnxnyzone(XParam, lev, nx, ny, Xzone);\n\n        // start at first value\n        //static size_t thstart[] = { 0 };\n        xcount[0] = nx;\n        ycount[0] = ny;\n        //Recreat the x, y\n        xval = (double*)malloc(nx * sizeof(double));\n        yval = (double*)malloc(ny * sizeof(double));\n\n        double ddx = calcres(XParam.dx, lev);\n        double dxp = calcres(XParam.dx, lev + 1);\n        double  xxmin, yymin;\n        //doublle xxmax, yymax\n        //xxmax = Xzone.xmax - dxp;\n        //yymax = Xzone.ymax - dxp;\n\n        xxmin = Xzone.xo + dxp;\n        yymin = Xzone.yo + dxp;\n\n        for (int i = 0; i &lt; nx; i++)\n        {\n            xval[i] = xxmin + double(i) * ddx;\n        }\n\n        for (int i = 0; i &lt; ny; i++)\n        {\n            yval[i] = yymin + double(i) * ddx;\n        }\n\n\n        lev &lt; 0 ? sign = \"N\" : sign = \"P\";\n\n\n        xxname = \"xx_\" + sign + std::to_string(abs(lev));\n        yyname = \"yy_\" + sign + std::to_string(abs(lev));\n\n        //printf(\"lev=%d; xxname=%s; yyname=%s;\\n\", lev, xxname.c_str(), yyname.c_str());\n\n        status = nc_inq_varid(ncid, xxname.c_str(), &amp;xx_id);\n        if (status != NC_NOERR) handle_ncerror(status);\n        status = nc_inq_varid(ncid, yyname.c_str(), &amp;yy_id);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        //Provide values for variables\n\n        status = nc_put_vara_double(ncid, xx_id, xstart, xcount, xval);\n        if (status != NC_NOERR) handle_ncerror(status);\n        status = nc_put_vara_double(ncid, yy_id, ystart, ycount, yval);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n\n\n        free(xval);\n        free(yval);\n    }\n\n    //close and save new file\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n\n\n    //return XParam;void\n}\n\ntemplate void creatncfileBUQ&lt;float&gt;(Param&amp; XParam, int* activeblk, int* level, float* blockxo, float* blockyo, outzoneB&amp; Xzone);\ntemplate void creatncfileBUQ&lt;double&gt;(Param&amp; XParam, int* activeblk, int* level, double* blockxo, double* blockyo, outzoneB&amp; Xzone);\n\n\ntemplate&lt;class T&gt;\nvoid creatncfileBUQ(Param&amp; XParam, BlockP&lt;T&gt;&amp; XBlock)\n{\n    for (int o = 0; o &lt; XBlock.outZone.size(); o++)\n    {\n        creatncfileBUQ(XParam, XBlock.active, XBlock.level, XBlock.xo, XBlock.yo, XBlock.outZone[o]);\n    }\n}\ntemplate void creatncfileBUQ&lt;float&gt;(Param&amp; XParam, BlockP&lt;float&gt;&amp; XBlock);\ntemplate void creatncfileBUQ&lt;double&gt;(Param&amp; XParam, BlockP&lt;double&gt;&amp; XBlock);\n\ntemplate &lt;class T&gt; void defncvarBUQ(Param XParam, int* activeblk, int* level, T* blockxo, T* blockyo, std::string varst, int vdim, T* var, outzoneB Xzone)\n{\n    defncvarBUQ(XParam, activeblk, level, blockxo, blockyo, varst, \"\", \"\", \"\", vdim, var, Xzone);\n}\n\ntemplate &lt;class T&gt; void defncvarBUQ(Param XParam, int* activeblk, int* level, T* blockxo, T* blockyo, std::string varst, std::string longname, std::string stdname, std::string unit, int vdim, T* var, outzoneB Xzone)\n{\n\n    int smallnc = XParam.smallnc;\n    float scalefactor = XParam.scalefactor;\n    float addoffset = XParam.addoffset;\n    //int nx = ceil(XParam.nx / 16.0) * 16.0;\n    //int ny = ceil(XParam.ny / 16.0) * 16.0;\n    int status;\n    int ncid, var_id;\n    int  var_dimid2D[2];\n    int  var_dimid3D[3];\n    //int  var_dimid4D[4];\n\n    short* varblk_s;\n    float* varblk;\n    int recid, xid, yid;\n    int bl, ibl, lev;\n    //size_t ntheta;// nx and ny are stored in XParam not yet for ntheta\n\n    float fillval = 9.9692e+36f;\n    short fillval_s = (short)round((9.9692e+36f - addoffset) / scalefactor);\n    //short Sfillval = 32767;\n    //short fillval = 32767\n    static size_t start2D[] = { 0, 0 }; // start at first value \n    //static size_t count2D[] = { ny, nx };\n    static size_t count2D[] = { (size_t)XParam.blkwidth, (size_t)XParam.blkwidth };\n\n    static size_t start3D[] = { 0, 0, 0 }; // start at first value \n    //static size_t count3D[] = { 1, ny, nx };\n    static size_t count3D[] = { 1, (size_t)XParam.blkwidth, (size_t)XParam.blkwidth };\n    //size_t count3D[3];\n    //count3D[0] = 1;\n    //count3D[1] = XParam.blkwidth;\n    //count3D[2] = XParam.blkwidth;\n\n    //int minlevzone, maxlevzone;\n\n    std::string outfile = Xzone.outname;\n    std::vector&lt;int&gt; activeblkzone = Calcactiveblockzone(XParam, activeblk, Xzone);\n    //Calclevelzone(XParam, minlevzone, maxlevzone, Xzone, level);\n\n\n    nc_type VarTYPE;\n\n    if (smallnc &gt; 0)\n    {\n        VarTYPE = NC_SHORT;\n    }\n    else\n    {\n        VarTYPE = NC_FLOAT;\n    }\n\n    //printf(\"\\n ib=%d count3D=[%d,%d,%d]\\n\", count3D[0], count3D[1], count3D[2]);\n\n\n    status = nc_open(outfile.c_str(), NC_WRITE, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    status = nc_redef(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    //Inquire dimensions ids\n    status = nc_inq_unlimdim(ncid, &amp;recid);//time\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    varblk = (float*)malloc(XParam.blkwidth * XParam.blkwidth * sizeof(float));\n    if (smallnc &gt; 0)\n    {\n\n        varblk_s = (short*)malloc(XParam.blkwidth * XParam.blkwidth * sizeof(short));\n    }\n\n\n    std::string xxname, yyname, varname, sign;\n\n    //generate a different variable name for each level and add attribute as necessary\n    for (lev = Xzone.minlevel; lev &lt;= Xzone.maxlevel; lev++)\n    {\n\n        //std::string xxname, yyname, sign;\n\n        lev &lt; 0 ? sign = \"N\" : sign = \"P\";\n\n\n        xxname = \"xx_\" + sign + std::to_string(abs(lev));\n        yyname = \"yy_\" + sign + std::to_string(abs(lev));\n\n        varname = varst + \"_\" + sign + std::to_string(abs(lev));\n\n\n        //printf(\"lev=%d; xxname=%s; yyname=%s;\\n\", lev, xxname.c_str(), yyname.c_str());\n        status = nc_inq_dimid(ncid, xxname.c_str(), &amp;xid);\n        if (status != NC_NOERR) handle_ncerror(status);\n        status = nc_inq_dimid(ncid, yyname.c_str(), &amp;yid);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n\n        var_dimid2D[0] = yid;\n        var_dimid2D[1] = xid;\n\n        var_dimid3D[0] = recid;\n        var_dimid3D[1] = yid;\n        var_dimid3D[2] = xid;\n\n        if (vdim == 2)\n        {\n            status = nc_def_var(ncid, varname.c_str(), VarTYPE, vdim, var_dimid2D, &amp;var_id);\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n        else if (vdim == 3)\n        {\n            status = nc_def_var(ncid, varname.c_str(), VarTYPE, vdim, var_dimid3D, &amp;var_id);\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n\n        if (smallnc &gt; 0)\n        {\n\n            status = nc_put_att_short(ncid, var_id, \"_FillValue\", NC_SHORT, 1, &amp;fillval_s);\n            if (status != NC_NOERR) handle_ncerror(status);\n            status = nc_put_att_short(ncid, var_id, \"missingvalue\", NC_SHORT, 1, &amp;fillval_s);\n\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n        else\n        {\n            status = nc_put_att_float(ncid, var_id, \"_FillValue\", NC_FLOAT, 1, &amp;fillval);\n            if (status != NC_NOERR) handle_ncerror(status);\n            status = nc_put_att_float(ncid, var_id, \"missingvalue\", NC_FLOAT, 1, &amp;fillval);\n\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n\n\n        if (smallnc &gt; 0)\n        {\n\n            status = nc_put_att_float(ncid, var_id, \"scale_factor\", NC_FLOAT, 1, &amp;scalefactor);\n            if (status != NC_NOERR) handle_ncerror(status);\n            status = nc_put_att_float(ncid, var_id, \"add_offset\", NC_FLOAT, 1, &amp;addoffset);\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n\n\n        status = nc_put_att_text(ncid, var_id, \"standard_name\", stdname.size(), stdname.c_str());\n        status = nc_put_att_text(ncid, var_id, \"long_name\", longname.size(), longname.c_str());\n        status = nc_put_att_text(ncid, var_id, \"units\", unit.size(), unit.c_str());\n\n        std::string crsstrname = \"crs\";\n        status = nc_put_att_text(ncid, var_id, \"grid_mapping\", crsstrname.size(), crsstrname.c_str());\n\n\n        int shuffle = 1;\n        int deflate = 1;        // This switches compression on (1) or off (0).\n        int deflate_level = 5;  // This is the compression level in range 1 (less) - 9 (more).\n        nc_def_var_deflate(ncid, var_id, shuffle, deflate, deflate_level);\n\n    }\n    // End definition\n    status = nc_enddef(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //printf(\"\\n ib=%d count3D=[%d,%d,%d]\\n\", count3D[0], count3D[1], count3D[2]);\n\n    // Now write the initial value of the Variable out\n\n    //std::vector&lt;int&gt; activeblkzone = Calcactiveblockzone(XParam, activeblk, Xzone);\n\n    //####################\n    for (ibl = 0; ibl &lt; Xzone.nblk; ibl++)\n    {\n\n        //bl = activeblk[Xzone.blk[ibl]];\n        bl = activeblkzone[ibl];\n        lev = level[bl];\n\n\n        //double xxmax, yymax;\n        double xxmin, yymin;\n        double initdx = calcres(XParam.dx, XParam.initlevel);\n\n\n\n        //xxmax = Xzone.xmax - calcres(XParam.dx, lev) / 2.0;\n        //yymax = Xzone.ymax - calcres(XParam.dx, lev )/2.0;\n\n\n        xxmin = Xzone.xo + calcres(XParam.dx, lev) / 2.0;\n        yymin = Xzone.yo + calcres(XParam.dx, lev) / 2.0;\n        //printf(\"xxmin=%f, yymin=%f, lev=$d \\n\", xxmin, yymin, lev);\n\n        //std::string xxname, yyname, sign;\n\n        lev &lt; 0 ? sign = \"N\" : sign = \"P\";\n\n\n        xxname = \"xx_\" + sign + std::to_string(abs(lev));\n        yyname = \"yy_\" + sign + std::to_string(abs(lev));\n\n        varname = varst + \"_\" + sign + std::to_string(abs(lev));\n        status = nc_inq_dimid(ncid, xxname.c_str(), &amp;xid);\n        if (status != NC_NOERR) handle_ncerror(status);\n        status = nc_inq_dimid(ncid, yyname.c_str(), &amp;yid);\n        if (status != NC_NOERR) handle_ncerror(status);\n        status = nc_inq_varid(ncid, varname.c_str(), &amp;var_id);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = (i + XParam.halowidth + XParam.outishift) + (j + XParam.halowidth + XParam.outjshift) * XParam.blkmemwidth + bl * XParam.blksize;\n                int r = i + j * XParam.blkwidth;\n                if (smallnc &gt; 0)\n                {\n                    // packed_data_value = nint((unpacked_data_value - add_offset) / scale_factor)\n                    varblk_s[r] = (short)round((var[n] - addoffset) / scalefactor);\n                }\n                else\n                {\n                    varblk[r] = (float)var[n];\n                }\n            }\n        }\n        if (vdim == 2)\n        {\n            start2D[0] = (size_t)round((XParam.yo + blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n            start2D[1] = (size_t)round((XParam.xo + blockxo[bl] - xxmin) / calcres(XParam.dx, lev));\n\n            if (smallnc &gt; 0)\n            {\n                status = nc_put_vara_short(ncid, var_id, start2D, count2D, varblk_s);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n            else\n            {\n                status = nc_put_vara_float(ncid, var_id, start2D, count2D, varblk);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n        }\n        else if (vdim == 3)\n        {\n            //\n            start3D[1] = (size_t)round((XParam.yo + blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n            start3D[2] = (size_t)round((XParam.xo + blockxo[bl] - xxmin) / calcres(XParam.dx, lev));\n\n            if (smallnc &gt; 0)\n            {\n                status = nc_put_vara_short(ncid, var_id, start3D, count3D, varblk_s);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n            else\n            {\n                status = nc_put_vara_float(ncid, var_id, start3D, count3D, varblk);\n\n                if (status != NC_NOERR)\n                {\n                    printf(\"\\n ib=%d start=[%d,%d,%d]; initlevel=%d; initdx=%f; level=%d; xo=%f; yo=%f; blockxo[ib]=%f xxmin=%f blockyo[ib]=%f yymin=%f startfl=%f\\n\", bl, (int)start3D[0], (int)start3D[1], (int)start3D[2], XParam.initlevel, initdx, lev, Xzone.xo, Xzone.yo, blockxo[bl], xxmin, blockyo[bl], yymin, (blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n                    //printf(\"\\n varblk[0]=%f varblk[255]=%f\\n\", varblk[0], varblk[255]);\n                    handle_ncerror(status);\n                }\n            }\n\n        }\n\n    }\n\n\n    if (smallnc &gt; 0)\n    {\n\n        free(varblk_s);\n    }\n    free(varblk);\n    //close and save new file\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n}\n\ntemplate void defncvarBUQ&lt;float&gt;(Param XParam, int* activeblk, int* level, float* blockxo, float* blockyo, std::string varst, int vdim, float* var, outzoneB Xzone);\ntemplate void defncvarBUQ&lt;double&gt;(Param XParam, int* activeblk, int* level, double* blockxo, double* blockyo, std::string varst, int vdim, double* var, outzoneB Xzone);\n\n\ntemplate &lt;class T&gt; void defncvarBUQlev(Param XParam, int* activeblk, int* level, T* blockxo, T* blockyo, std::string varst, std::string longname, std::string stdname, std::string unit, int vdim, T* var, outzoneB Xzone)\n{\n\n    int smallnc = XParam.smallnc;\n    float scalefactor = XParam.scalefactor;\n    float addoffset = XParam.addoffset;\n    //int nx = ceil(XParam.nx / 16.0) * 16.0;\n    //int ny = ceil(XParam.ny / 16.0) * 16.0;\n    int status;\n    int ncid, var_id;\n    int  var_dimid2D[2];\n    int  var_dimid3D[3];\n    //int  var_dimid4D[4];\n\n    short* varblk_s;\n    float* varblk;\n    int recid, xid, yid;\n    int bl, ibl;\n    //size_t ntheta;// nx and ny are stored in XParam not yet for ntheta\n\n    float fillval = 9.9692e+36f;\n    short fillval_s = (short)round((9.9692e+36f - addoffset) / scalefactor);\n    //short Sfillval = 32767;\n    //short fillval = 32767\n    static size_t start2D[] = { 0, 0 }; // start at first value \n    //static size_t count2D[] = { ny, nx };\n    static size_t count2D[] = { (size_t)XParam.blkwidth, (size_t)XParam.blkwidth };\n\n    static size_t start3D[] = { 0, 0, 0 }; // start at first value \n    //static size_t count3D[] = { 1, ny, nx };\n    static size_t count3D[] = { 1, (size_t)XParam.blkwidth, (size_t)XParam.blkwidth };\n    //size_t count3D[3];\n    //count3D[0] = 1;\n    //count3D[1] = XParam.blkwidth;\n    //count3D[2] = XParam.blkwidth;\n\n    //int minlevzone, maxlevzone;\n\n    std::string outfile = Xzone.outname;\n    std::vector&lt;int&gt; activeblkzone = Calcactiveblockzone(XParam, activeblk, Xzone);\n    //Calclevelzone(XParam, minlevzone, maxlevzone, Xzone, level);\n\n\n    nc_type VarTYPE;\n\n    if (smallnc &gt; 0)\n    {\n        VarTYPE = NC_SHORT;\n    }\n    else\n    {\n        VarTYPE = NC_FLOAT;\n    }\n\n    //printf(\"\\n ib=%d count3D=[%d,%d,%d]\\n\", count3D[0], count3D[1], count3D[2]);\n\n\n    status = nc_open(outfile.c_str(), NC_WRITE, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    status = nc_redef(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    //Inquire dimensions ids\n    status = nc_inq_unlimdim(ncid, &amp;recid);//time\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    varblk = (float*)malloc(XParam.blkwidth * XParam.blkwidth * sizeof(float));\n    if (smallnc &gt; 0)\n    {\n\n        varblk_s = (short*)malloc(XParam.blkwidth * XParam.blkwidth * sizeof(short));\n    }\n\n\n    std::string xxname, yyname, varname, sign;\n\n    //generate a different variable name for each level and add attribute as necessary\n    for (int lev = Xzone.minlevel; lev &lt;= Xzone.maxlevel; lev++)\n    {\n\n        //std::string xxname, yyname, sign;\n\n        lev &lt; 0 ? sign = \"N\" : sign = \"P\";\n\n\n        xxname = \"xx_\" + sign + std::to_string(abs(lev));\n        yyname = \"yy_\" + sign + std::to_string(abs(lev));\n\n        varname = varst + \"_\" + sign + std::to_string(abs(lev));\n\n\n        //printf(\"lev=%d; xxname=%s; yyname=%s;\\n\", lev, xxname.c_str(), yyname.c_str());\n        status = nc_inq_dimid(ncid, xxname.c_str(), &amp;xid);\n        if (status != NC_NOERR) handle_ncerror(status);\n        status = nc_inq_dimid(ncid, yyname.c_str(), &amp;yid);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n\n        var_dimid2D[0] = yid;\n        var_dimid2D[1] = xid;\n\n        var_dimid3D[0] = recid;\n        var_dimid3D[1] = yid;\n        var_dimid3D[2] = xid;\n\n        if (vdim == 2)\n        {\n            status = nc_def_var(ncid, varname.c_str(), VarTYPE, vdim, var_dimid2D, &amp;var_id);\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n        else if (vdim == 3)\n        {\n            status = nc_def_var(ncid, varname.c_str(), VarTYPE, vdim, var_dimid3D, &amp;var_id);\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n\n        if (smallnc &gt; 0)\n        {\n\n            status = nc_put_att_short(ncid, var_id, \"_FillValue\", NC_SHORT, 1, &amp;fillval_s);\n            if (status != NC_NOERR) handle_ncerror(status);\n            status = nc_put_att_short(ncid, var_id, \"missingvalue\", NC_SHORT, 1, &amp;fillval_s);\n\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n        else\n        {\n            status = nc_put_att_float(ncid, var_id, \"_FillValue\", NC_FLOAT, 1, &amp;fillval);\n            if (status != NC_NOERR) handle_ncerror(status);\n            status = nc_put_att_float(ncid, var_id, \"missingvalue\", NC_FLOAT, 1, &amp;fillval);\n\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n\n\n        if (smallnc &gt; 0)\n        {\n\n            status = nc_put_att_float(ncid, var_id, \"scale_factor\", NC_FLOAT, 1, &amp;scalefactor);\n            if (status != NC_NOERR) handle_ncerror(status);\n            status = nc_put_att_float(ncid, var_id, \"add_offset\", NC_FLOAT, 1, &amp;addoffset);\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n\n\n        status = nc_put_att_text(ncid, var_id, \"standard_name\", stdname.size(), stdname.c_str());\n        status = nc_put_att_text(ncid, var_id, \"long_name\", longname.size(), longname.c_str());\n        status = nc_put_att_text(ncid, var_id, \"units\", unit.size(), unit.c_str());\n\n        std::string crsstrname = \"crs\";\n        status = nc_put_att_text(ncid, var_id, \"grid_mapping\", crsstrname.size(), crsstrname.c_str());\n\n\n        int shuffle = 1;\n        int deflate = 1;        // This switches compression on (1) or off (0).\n        int deflate_level = 5;  // This is the compression level in range 1 (less) - 9 (more).\n        nc_def_var_deflate(ncid, var_id, shuffle, deflate, deflate_level);\n\n    }\n    // End definition\n    status = nc_enddef(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //printf(\"\\n ib=%d count3D=[%d,%d,%d]\\n\", count3D[0], count3D[1], count3D[2]);\n\n    // Now write the initial value of the Variable out\n\n    //std::vector&lt;int&gt; activeblkzone = Calcactiveblockzone(XParam, activeblk, Xzone);\n\n    //####################\n    // Create empty array for each levels\n    std::vector&lt;outP&gt; varlayers;\n    int nx, ny;\n    for (int levi = Xzone.minlevel; levi &lt;= Xzone.maxlevel; levi++)\n    {\n        varlayers.push_back(outP());\n        int levindex = (levi - Xzone.minlevel);\n\n        Calcnxnyzone(XParam, levi, nx, ny, Xzone);\n        varlayers[levindex].z = (float*)malloc(nx * ny * sizeof(float));\n        if (smallnc &gt; 0)\n        {\n\n            varlayers[levindex].z_s = (short*)malloc(nx * ny * sizeof(short));\n        }\n        varlayers[levindex].level = levi;\n\n        for (int j = 0; j &lt; ny; j++)\n        {\n            for (int i = 0; i &lt; nx; i++)\n            {\n                int n = i + j * nx;\n\n                varlayers[levindex].z[n] = fillval;\n                if (smallnc &gt; 0)\n                {\n                    varlayers[levindex].z_s[n] = fillval_s;\n                }\n            }\n        }\n    }\n\n    //std::string xxname, yyname, varname, sign;\n    //std::vector&lt;int&gt; activeblkzone = Calcactiveblockzone(XParam, activeblk, Xzone);\n\n\n    //int lev, bl;\n    for (int ibl = 0; ibl &lt; Xzone.nblk; ibl++)\n    {\n        //bl = activeblk[Xzone.blk[ibl]];\n    //for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    //{\n        bl = activeblkzone[ibl];\n        int lev = level[bl];\n\n        double  xxmin, yymin;\n        int nxlev, nylev;\n        //double xxmax, yymax;\n        double initdx = calcres(XParam.dx, XParam.initlevel);\n\n        int io, jo;\n        //xxmax = Xzone.xmax - calcres(XParam.dx, lev) / 2.0;\n        //yymax = Xzone.ymax - calcres(XParam.dx, lev) / 2.0;\n\n        int levindex = (lev - Xzone.minlevel);\n\n        Calcnxnyzone(XParam, lev, nxlev, nylev, Xzone);\n        xxmin = Xzone.xo + calcres(XParam.dx, lev) / 2.0;\n        yymin = Xzone.yo + calcres(XParam.dx, lev) / 2.0;\n\n\n\n        jo = round((XParam.yo + blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n        io = round((XParam.xo + blockxo[bl] - xxmin) / calcres(XParam.dx, lev));\n\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = (i + XParam.halowidth + XParam.outishift) + (j + XParam.halowidth + XParam.outjshift) * XParam.blkmemwidth + bl * XParam.blksize;\n                int r = (io + i) + (jo + j) * nxlev;\n                if (smallnc &gt; 0)\n                {\n                    // packed_data_value = nint((unpacked_data_value - add_offset) / scale_factor)\n                    varlayers[levindex].z_s[r] = (short)round((var[n] - addoffset) / scalefactor);\n                }\n                else\n                {\n                    varlayers[levindex].z[r] = (float)var[n];\n                }\n            }\n        }\n\n    }\n\n\n    for (int levi = Xzone.minlevel; levi &lt;= Xzone.maxlevel; levi++)\n    {\n        int nxlev, nylev;\n        Calcnxnyzone(XParam, levi, nxlev, nylev, Xzone);\n        //double  xxmin, yymin;\n        levi &lt; 0 ? sign = \"N\" : sign = \"P\";\n        varname = varst + \"_\" + sign + std::to_string(abs(levi));\n\n        status = nc_inq_varid(ncid, varname.c_str(), &amp;var_id);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        //xxmin = Xzone.xo + calcres(XParam.dx, levi) / 2.0;\n        //yymin = Xzone.yo + calcres(XParam.dx, levi) / 2.0;\n\n        int levindex = (levi - Xzone.minlevel);\n\n        if (vdim == 2)\n        {\n\n\n            start2D[0] = 0; // (size_t)round((XParam.yo - yymin) / calcres(XParam.dx, levi));\n            start2D[1] = 0; // (size_t)round((XParam.xo - xxmin) / calcres(XParam.dx, levi));\n\n            count2D[0] = (size_t)nylev;\n            count2D[1] = (size_t)nxlev;\n\n            if (smallnc &gt; 0)\n            {\n\n                status = nc_put_vara_short(ncid, var_id, start2D, count2D, varlayers[levindex].z_s);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n            else\n            {\n                status = nc_put_vara_float(ncid, var_id, start2D, count2D, varlayers[levindex].z);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n        }\n        else if (vdim == 3)\n        {\n            start3D[1] = 0;// (size_t)round((XParam.yo - yymin) / calcres(XParam.dx, levi));\n            start3D[2] = 0;// (size_t)round((XParam.xo - xxmin) / calcres(XParam.dx, levi));\n\n            count3D[1] = (size_t)nylev;\n            count3D[2] = (size_t)nxlev;\n\n            if (smallnc &gt; 0)\n            {\n                status = nc_put_vara_short(ncid, var_id, start3D, count3D, varlayers[levindex].z_s);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n            else\n            {\n                status = nc_put_vara_float(ncid, var_id, start3D, count3D, varlayers[levindex].z);\n                if (status != NC_NOERR) handle_ncerror(status);\n                //printf(\"\\n ib=%d start=[%d,%d,%d]; initlevel=%d; initdx=%f; level=%d; xo=%f; yo=%f; blockxo[ib]=%f xxmin=%f blockyo[ib]=%f yymin=%f startfl=%f\\n\", bl, start3D[0], start3D[1], start3D[2], XParam.initlevel, initdx, lev, Xzone.xo, Xzone.yo, blockxo[bl], xxmin, blockyo[bl], yymin, (blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n                //printf(\"\\n varblk[0]=%f varblk[255]=%f\\n\", varblk[0], varblk[255]);\n                //printf(\"\\n ib=%d count3D=[%d,%d,%d]\\n\", count3D[0], count3D[1], count3D[2]);\n                //printf(\"\\n ib=%d; level=%d; blockxo[ib]=%f blockyo[ib]=%f \\n\", bl, lev, blockxo[bl], blockyo[bl]);\n            }\n\n        }\n\n    }\n\n    for (int levi = Xzone.minlevel; levi &lt;= Xzone.maxlevel; levi++)\n    {\n        int levindex = (levi - Xzone.minlevel);\n        if (smallnc &gt; 0)\n        {\n\n            free(varlayers[levindex].z_s);\n        }\n        free(varlayers[levindex].z);\n    }\n    //close and save new file\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n}\n\n\n\n\ntemplate &lt;class T&gt; void writencvarstepBUQ(Param XParam, int vdim, int* activeblk, int* level, T* blockxo, T* blockyo, std::string varst, T* var, outzoneB Xzone)\n{\n    int status, ncid, recid, var_id;\n    static size_t nrec;\n    short* varblk_s;\n    float* varblk;\n    //int nx, ny;\n    //int dimids[NC_MAX_VAR_DIMS];\n    //size_t  *ddim, *start, *count;\n    //XParam.outfile.c_str()\n\n    static size_t start2D[] = { 0, 0 }; // start at first value \n    //static size_t count2D[] = { ny, nx };\n    static size_t count2D[] = { (size_t)XParam.blkwidth, (size_t)XParam.blkwidth };\n\n    static size_t start3D[] = { 0, 0, 0 }; // start at first value // This is updated to nrec-1 further down\n    //static size_t count3D[] = { 1, ny, nx };\n    static size_t count3D[] = { 1, (size_t)XParam.blkwidth, (size_t)XParam.blkwidth };\n\n    int smallnc = XParam.smallnc;\n    float scalefactor = XParam.scalefactor;\n    float addoffset = XParam.addoffset;\n\n    status = nc_open(Xzone.outname.c_str(), NC_WRITE, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    //read id from time dimension\n    status = nc_inq_unlimdim(ncid, &amp;recid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    status = nc_inq_dimlen(ncid, recid, &amp;nrec);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    start3D[0] = nrec - 1;\n\n    varblk = (float*)malloc(XParam.blkwidth * XParam.blkwidth * sizeof(float));\n    if (smallnc &gt; 0)\n    {\n\n        varblk_s = (short*)malloc(XParam.blkwidth * XParam.blkwidth * sizeof(short));\n    }\n\n\n    std::string xxname, yyname, varname, sign;\n    std::vector&lt;int&gt; activeblkzone = Calcactiveblockzone(XParam, activeblk, Xzone);\n\n\n    int lev, bl;\n    for (int ibl = 0; ibl &lt; Xzone.nblk; ibl++)\n    {\n        //bl = activeblk[Xzone.blk[ibl]];\n    //for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    //{\n        bl = activeblkzone[ibl];\n        lev = level[bl];\n        lev &lt; 0 ? sign = \"N\" : sign = \"P\";\n        double  xxmin, yymin;\n        //double xxmax, yymax;\n        double initdx = calcres(XParam.dx, XParam.initlevel);\n\n\n        //xxmax = Xzone.xmax - calcres(XParam.dx, lev) / 2.0;\n        //yymax = Xzone.ymax - calcres(XParam.dx, lev) / 2.0;\n\n\n        xxmin = Xzone.xo + calcres(XParam.dx, lev) / 2.0;\n        yymin = Xzone.yo + calcres(XParam.dx, lev) / 2.0;\n\n        varname = varst + \"_\" + sign + std::to_string(abs(lev));\n\n\n        status = nc_inq_varid(ncid, varname.c_str(), &amp;var_id);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = (i + XParam.halowidth + XParam.outishift) + (j + XParam.halowidth + XParam.outjshift) * XParam.blkmemwidth + bl * XParam.blksize;\n                int r = i + j * XParam.blkwidth;\n                if (smallnc &gt; 0)\n                {\n                    // packed_data_value = nint((unpacked_data_value - add_offset) / scale_factor)\n                    varblk_s[r] = (short)round((var[n] - addoffset) / scalefactor);\n                }\n                else\n                {\n                    varblk[r] = (float)var[n];\n                }\n            }\n        }\n        if (vdim == 2)\n        {\n            start2D[0] = (size_t)round((XParam.yo + blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n            start2D[1] = (size_t)round((XParam.xo + blockxo[bl] - xxmin) / calcres(XParam.dx, lev));\n\n            if (smallnc &gt; 0)\n            {\n\n\n                status = nc_put_vara_short(ncid, var_id, start2D, count2D, varblk_s);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n            else\n            {\n                status = nc_put_vara_float(ncid, var_id, start2D, count2D, varblk);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n        }\n        else if (vdim == 3)\n        {\n            start3D[1] = (size_t)round((XParam.yo + blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n            start3D[2] = (size_t)round((XParam.xo + blockxo[bl] - xxmin) / calcres(XParam.dx, lev));\n            if (smallnc &gt; 0)\n            {\n                status = nc_put_vara_short(ncid, var_id, start3D, count3D, varblk_s);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n            else\n            {\n                status = nc_put_vara_float(ncid, var_id, start3D, count3D, varblk);\n                if (status != NC_NOERR) handle_ncerror(status);\n                //printf(\"\\n ib=%d start=[%d,%d,%d]; initlevel=%d; initdx=%f; level=%d; xo=%f; yo=%f; blockxo[ib]=%f xxmin=%f blockyo[ib]=%f yymin=%f startfl=%f\\n\", bl, start3D[0], start3D[1], start3D[2], XParam.initlevel, initdx, lev, Xzone.xo, Xzone.yo, blockxo[bl], xxmin, blockyo[bl], yymin, (blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n                //printf(\"\\n varblk[0]=%f varblk[255]=%f\\n\", varblk[0], varblk[255]);\n                //printf(\"\\n ib=%d count3D=[%d,%d,%d]\\n\", count3D[0], count3D[1], count3D[2]);\n                //printf(\"\\n ib=%d; level=%d; blockxo[ib]=%f blockyo[ib]=%f \\n\", bl, lev, blockxo[bl], blockyo[bl]);\n            }\n\n        }\n\n    }\n\n\n    if (smallnc &gt; 0)\n    {\n\n        free(varblk_s);\n    }\n    free(varblk);\n    //close and save new file\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n}\n\n// Scope for compiler to know what function to compile\n\ntemplate void writencvarstepBUQ&lt;float&gt;(Param XParam, int vdim, int* activeblk, int* level, float* blockxo, float* blockyo, std::string varst, float* var, outzoneB Xzone);\ntemplate void writencvarstepBUQ&lt;double&gt;(Param XParam, int vdim, int* activeblk, int* level, double* blockxo, double* blockyo, std::string varst, double* var, outzoneB Xzone);\n\nextern \"C\" void writenctimestep(std::string outfile, double totaltime)\n{\n    int status, ncid, recid, time_id;\n    status = nc_open(outfile.c_str(), NC_WRITE, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    static size_t nrec;\n    static size_t tst[] = { 0 };\n    //read id from time dimension\n    status = nc_inq_unlimdim(ncid, &amp;recid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    status = nc_inq_dimlen(ncid, recid, &amp;nrec);\n    if (status != NC_NOERR) handle_ncerror(status);\n    status = nc_inq_varid(ncid, \"time\", &amp;time_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n    tst[0] = nrec;\n    status = nc_put_var1_double(ncid, time_id, tst, &amp;totaltime);\n    if (status != NC_NOERR) handle_ncerror(status);\n    //close and save\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n}\n\n\ntemplate &lt;class T&gt; void writencvarstepBUQlev(Param XParam, int vdim, int* activeblk, int* level, T* blockxo, T* blockyo, std::string varst, T* var, outzoneB Xzone)\n{\n    int status, ncid, recid, var_id;\n    static size_t nrec;\n    short* varblk_s;\n    float* varblk;\n    //int nx, ny;\n    //int dimids[NC_MAX_VAR_DIMS];\n    //size_t  *ddim, *start, *count;\n    //XParam.outfile.c_str()\n\n\n    float fillval = 9.9692e+36f;\n    short fillval_s = (short)round((9.9692e+36f - XParam.addoffset) / XParam.scalefactor);\n\n    static size_t start2D[] = { 0, 0 }; // start at first value \n    //static size_t count2D[] = { ny, nx };\n    static size_t count2D[] = { (size_t)XParam.blkwidth, (size_t)XParam.blkwidth };\n\n    static size_t start3D[] = { 0, 0, 0 }; // start at first value // This is updated to nrec-1 further down\n    //static size_t count3D[] = { 1, ny, nx };\n    static size_t count3D[] = { 1, (size_t)XParam.blkwidth, (size_t)XParam.blkwidth };\n\n    int smallnc = XParam.smallnc;\n    float scalefactor = XParam.scalefactor;\n    float addoffset = XParam.addoffset;\n\n    status = nc_open(Xzone.outname.c_str(), NC_WRITE, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    //read id from time dimension\n    status = nc_inq_unlimdim(ncid, &amp;recid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    status = nc_inq_dimlen(ncid, recid, &amp;nrec);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    start3D[0] = nrec - 1;\n\n\n    // Create empty array for each levels\n    std::vector&lt;outP&gt; varlayers;\n    int nx, ny;\n    for (int levi = Xzone.minlevel; levi &lt;= Xzone.maxlevel; levi++)\n    {\n        varlayers.push_back(outP());\n        int levindex = (levi - Xzone.minlevel);\n\n        Calcnxnyzone(XParam, levi, nx, ny, Xzone);\n        varlayers[levindex].z = (float*)malloc(nx * ny * sizeof(float));\n        if (smallnc &gt; 0)\n        {\n\n            varlayers[levindex].z_s = (short*)malloc(nx * ny * sizeof(short));\n        }\n        varlayers[levindex].level = levi;\n\n        for (int j = 0; j &lt; ny; j++)\n        {\n            for (int i = 0; i &lt; nx; i++)\n            {\n                int n = i + j * nx;\n\n                varlayers[levindex].z[n] = fillval;\n                if (smallnc &gt; 0)\n                {\n                    varlayers[levindex].z_s[n] = fillval_s;\n                }\n            }\n        }\n    }\n\n    std::string xxname, yyname, varname, sign;\n    std::vector&lt;int&gt; activeblkzone = Calcactiveblockzone(XParam, activeblk, Xzone);\n\n\n    int lev, bl;\n    for (int ibl = 0; ibl &lt; Xzone.nblk; ibl++)\n    {\n        //bl = activeblk[Xzone.blk[ibl]];\n    //for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    //{\n        bl = activeblkzone[ibl];\n        lev = level[bl];\n\n        double  xxmin, yymin;\n        int nxlev, nylev;\n        //double xxmax, yymax;\n        double initdx = calcres(XParam.dx, XParam.initlevel);\n\n        int io, jo;\n        //xxmax = Xzone.xmax - calcres(XParam.dx, lev) / 2.0;\n        //yymax = Xzone.ymax - calcres(XParam.dx, lev) / 2.0;\n\n        int levindex = (lev - Xzone.minlevel);\n\n        Calcnxnyzone(XParam, lev, nxlev, nylev, Xzone);\n        xxmin = Xzone.xo + calcres(XParam.dx, lev) / 2.0;\n        yymin = Xzone.yo + calcres(XParam.dx, lev) / 2.0;\n\n\n\n        jo = round((XParam.yo + blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n        io = round((XParam.xo + blockxo[bl] - xxmin) / calcres(XParam.dx, lev));\n\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = (i + XParam.halowidth + XParam.outishift) + (j + XParam.halowidth + XParam.outjshift) * XParam.blkmemwidth + bl * XParam.blksize;\n                int r = (io + i) + (jo + j) * nxlev;\n                if (smallnc &gt; 0)\n                {\n                    // packed_data_value = nint((unpacked_data_value - add_offset) / scale_factor)\n                    varlayers[levindex].z_s[r] = (short)round((var[n] - addoffset) / scalefactor);\n                }\n                else\n                {\n                    varlayers[levindex].z[r] = (float)var[n];\n                }\n            }\n        }\n\n    }\n\n\n    for (int levi = Xzone.minlevel; levi &lt;= Xzone.maxlevel; levi++)\n    {\n        int nxlev, nylev;\n        Calcnxnyzone(XParam, levi, nxlev, nylev, Xzone);\n        //double  xxmin, yymin;\n        levi &lt; 0 ? sign = \"N\" : sign = \"P\";\n        varname = varst + \"_\" + sign + std::to_string(abs(levi));\n\n        status = nc_inq_varid(ncid, varname.c_str(), &amp;var_id);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        //xxmin = Xzone.xo + calcres(XParam.dx, levi) / 2.0;\n        //yymin = Xzone.yo + calcres(XParam.dx, levi) / 2.0;\n\n        int levindex = (levi - Xzone.minlevel);\n\n        if (vdim == 2)\n        {\n\n\n            start2D[0] = 0; // (size_t)round((XParam.yo - yymin) / calcres(XParam.dx, levi));\n            start2D[1] = 0; // (size_t)round((XParam.xo - xxmin) / calcres(XParam.dx, levi));\n\n            count2D[0] = (size_t)nylev;\n            count2D[1] = (size_t)nxlev;\n\n            if (smallnc &gt; 0)\n            {\n\n                status = nc_put_vara_short(ncid, var_id, start2D, count2D, varlayers[levindex].z_s);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n            else\n            {\n                status = nc_put_vara_float(ncid, var_id, start2D, count2D, varlayers[levindex].z);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n        }\n        else if (vdim == 3)\n        {\n            start3D[1] = 0;// (size_t)round((XParam.yo - yymin) / calcres(XParam.dx, levi));\n            start3D[2] = 0;// (size_t)round((XParam.xo - xxmin) / calcres(XParam.dx, levi));\n\n            count3D[1] = (size_t)nylev;\n            count3D[2] = (size_t)nxlev;\n\n            if (smallnc &gt; 0)\n            {\n                status = nc_put_vara_short(ncid, var_id, start3D, count3D, varlayers[levindex].z_s);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n            else\n            {\n                status = nc_put_vara_float(ncid, var_id, start3D, count3D, varlayers[levindex].z);\n                if (status != NC_NOERR) handle_ncerror(status);\n                //printf(\"\\n ib=%d start=[%d,%d,%d]; initlevel=%d; initdx=%f; level=%d; xo=%f; yo=%f; blockxo[ib]=%f xxmin=%f blockyo[ib]=%f yymin=%f startfl=%f\\n\", bl, start3D[0], start3D[1], start3D[2], XParam.initlevel, initdx, lev, Xzone.xo, Xzone.yo, blockxo[bl], xxmin, blockyo[bl], yymin, (blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n                //printf(\"\\n varblk[0]=%f varblk[255]=%f\\n\", varblk[0], varblk[255]);\n                //printf(\"\\n ib=%d count3D=[%d,%d,%d]\\n\", count3D[0], count3D[1], count3D[2]);\n                //printf(\"\\n ib=%d; level=%d; blockxo[ib]=%f blockyo[ib]=%f \\n\", bl, lev, blockxo[bl], blockyo[bl]);\n            }\n\n        }\n\n    }\n\n    for (int levi = Xzone.minlevel; levi &lt;= Xzone.maxlevel; levi++)\n    {\n        int levindex = (levi - Xzone.minlevel);\n        if (smallnc &gt; 0)\n        {\n\n            free(varlayers[levindex].z_s);\n        }\n        free(varlayers[levindex].z);\n    }\n    //close and save new file\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n}\n\n// Scope for compiler to know what function to compile\n\ntemplate void writencvarstepBUQlev&lt;float&gt;(Param XParam, int vdim, int* activeblk, int* level, float* blockxo, float* blockyo, std::string varst, float* var, outzoneB Xzone);\ntemplate void writencvarstepBUQlev&lt;double&gt;(Param XParam, int vdim, int* activeblk, int* level, double* blockxo, double* blockyo, std::string varst, double* var, outzoneB Xzone);\n\n\n\n//Initialise netcdf files\ntemplate &lt;class T&gt; void InitSave2Netcdf(Param&amp; XParam, Model&lt;T&gt;&amp; XModel)\n{\n    if (!XParam.outvars.empty())\n    {\n        log(\"Create netCDF output file...\");\n        creatncfileBUQ(XParam, XModel.blocks);\n        //creatncfileBUQ(XParam);\n        /*for (int o = 0; o &lt; XModel.blocks.outZone.size(); o++)\n        {\n            writenctimestep(XModel.blocks.outZone[o].outname, XParam.totaltime);\n            for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n            {\n                std::string varstr = XParam.outvars[ivar];\n                if (XParam.savebyblk)\n                {\n                    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, varstr, XModel.Outvarlongname[varstr], XModel.Outvarstdname[varstr], XModel.Outvarunits[varstr], 3, XModel.OutputVarMap[varstr], XModel.blocks.outZone[o]);\n\n                }\n                else\n                {\n                    defncvarBUQlev(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, varstr, XModel.Outvarlongname[varstr], XModel.Outvarstdname[varstr], XModel.Outvarunits[varstr], 3, XModel.OutputVarMap[varstr], XModel.blocks.outZone[o]);\n\n                }\n            }\n        }*/\n    }\n}\ntemplate void InitSave2Netcdf&lt;float&gt;(Param&amp; XParam, Model&lt;float&gt;&amp; XModel);\ntemplate void InitSave2Netcdf&lt;double&gt;(Param&amp; XParam, Model&lt;double&gt;&amp; XModel);\n\n//Save initialisation in maps outpout if require\n/*template &lt;class T&gt; void SaveInitialisation2Netcdf(Param&amp; XParam, Model&lt;T&gt;&amp; XModel)\n{\n    double NextZoneOutTime;\n\n    if (!XParam.outvars.empty())\n    {\n        for (int o = 0; o &lt; XModel.blocks.outZone.size(); o++)\n        {\n            NextZoneOutTime = XModel.blocks.outZone[o].OutputT[XModel.blocks.outZone[o].index_next_OutputT];\n            if (XParam.totaltime == NextZoneOutTime)\n            {\n                log(\"Output to map: \" + XModel.blocks.outZone[o].outname + \", Totaltime = \" + std::to_string(XParam.totaltime) + \" s; Initialisation\");\n\n                writenctimestep(XModel.blocks.outZone[o].outname, XParam.totaltime);\n                for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n                {\n                    std::string varstr = XParam.outvars[ivar];\n                    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, varstr, XModel.Outvarlongname[varstr], XModel.Outvarstdname[varstr], XModel.Outvarunits[varstr], 3, XModel.OutputVarMap[varstr], XModel.blocks.outZone[o]);\n                }\n                XModel.blocks.outZone[o].index_next_OutputT++;\n            }\n\n\n        }\n    }\n}\ntemplate void SaveInitialisation2Netcdf&lt;float&gt;(Param&amp; XParam, Model&lt;float&gt;&amp; XModel);\ntemplate void SaveInitialisation2Netcdf&lt;double&gt;(Param&amp; XParam, Model&lt;double&gt;&amp; XModel);\n*/\n\ntemplate &lt;class T&gt; void Save2Netcdf(Param XParam, Loop&lt;T&gt; XLoop, Model&lt;T&gt;&amp; XModel)\n{\n    double NextZoneOutTime;\n    double tiny = 0.0000001;\n\n    char buffer[256];\n    double meanTspeps = (XModel.OutputT[XLoop.indNextoutputtime] - XModel.OutputT[XLoop.indNextoutputtime - T(1)]) / XLoop.nstepout;\n    sprintf(buffer, \"%e\", meanTspeps);\n    std::string str(buffer);\n    //std::string maps;\n\n    if (!XParam.outvars.empty())\n    {\n        for (int o = 0; o &lt; XModel.blocks.outZone.size(); o++)\n        {\n            int indLoc = min(XModel.blocks.outZone[o].index_next_OutputT, (int(XModel.blocks.outZone[o].OutputT.size() - 1)));\n            NextZoneOutTime = XModel.blocks.outZone[o].OutputT[indLoc];\n            if (abs(XLoop.nextoutputtime - NextZoneOutTime) &lt; tiny)\n            {\n                log(\"Output to map: \" + XModel.blocks.outZone[o].outname + \", Totaltime = \" + std::to_string(XLoop.totaltime) + \" s; Mean dt = \" + str + \" s\");\n\n                writenctimestep(XModel.blocks.outZone[o].outname, XLoop.totaltime);\n                for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n                {\n                    if (XModel.blocks.outZone[o].index_next_OutputT == 0)//first time output\n                    {\n                        std::string varstr = XParam.outvars[ivar];\n                        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, varstr, XModel.Outvarlongname[varstr], XModel.Outvarstdname[varstr], XModel.Outvarunits[varstr], 3, XModel.OutputVarMap[varstr], XModel.blocks.outZone[o]);\n                    }\n                    else\n                    {\n                        if (XParam.savebyblk)\n                        {\n                            writencvarstepBUQ(XParam, 3, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, XParam.outvars[ivar], XModel.OutputVarMap[XParam.outvars[ivar]], XModel.blocks.outZone[o]);\n                        }\n                        else\n                        {\n                            writencvarstepBUQlev(XParam, 3, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, XParam.outvars[ivar], XModel.OutputVarMap[XParam.outvars[ivar]], XModel.blocks.outZone[o]);\n                        }\n                    }\n                }\n                XModel.blocks.outZone[o].index_next_OutputT++;\n            }\n        }\n    }\n    //maps.erase(maps.size() - 2);\n}\ntemplate void Save2Netcdf&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, Model&lt;float&gt;&amp; XModel);\ntemplate void Save2Netcdf&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, Model&lt;double&gt;&amp; XModel);\n\n\n//The following functions are tools to create 2D or 3D netcdf files (for testing for example)\n\n//\nextern \"C\" void create2dnc(char* filename, int nx, int ny, double* xx, double* yy, double* var, char* varname)\n{\n    int status;\n    int ncid, xx_dim, yy_dim, tvar_id;\n\n    size_t nxx, nyy;\n    static size_t start[] = { 0, 0 }; // start at first value\n    static size_t count[] = { (size_t)ny, (size_t)nx };\n    int xx_id, yy_id; //\n    nxx = nx;\n    nyy = ny;\n\n    //create the netcdf dataset\n    status = nc_create(filename, NC_CLOBBER, &amp;ncid);\n\n    //Define dimensions: Name and length\n\n    status = nc_def_dim(ncid, \"xx\", nxx, &amp;xx_dim);\n    status = nc_def_dim(ncid, \"yy\", nyy, &amp;yy_dim);\n    int xdim[] = { xx_dim };\n    int ydim[] = { yy_dim };\n\n    //define variables: Name, Type,...\n    int var_dimids[3];\n    var_dimids[0] = yy_dim;\n    var_dimids[1] = xx_dim;\n\n    status = nc_def_var(ncid, \"xx\", NC_DOUBLE, 1, xdim, &amp;xx_id);\n    status = nc_def_var(ncid, \"yy\", NC_DOUBLE, 1, ydim, &amp;yy_id);\n\n\n    status = nc_def_var(ncid, varname, NC_DOUBLE, 2, var_dimids, &amp;tvar_id);\n\n    status = nc_enddef(ncid);\n\n    static size_t xstart[] = { 0 }; // start at first value\n    static size_t xcount[] = { (size_t)nx };\n\n    static size_t ystart[] = { 0 }; // start at first value\n    static size_t ycount[] = { (size_t)ny };\n\n\n\n    //Provide values for variables\n    status = nc_put_vara_double(ncid, xx_id, xstart, xcount, xx);\n    status = nc_put_vara_double(ncid, yy_id, ystart, ycount, yy);\n\n    status = nc_put_vara_double(ncid, tvar_id, start, count, var);\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n}\n\n//Create a ncdf file containing a 3D variable (the file is overwritten if it was existing before)\nextern \"C\" void create3dnc(char* name, int nx, int ny, int nt, double* xx, double* yy, double* theta, double* var, char* varname)\n{\n    int status;\n    int ncid, xx_dim, yy_dim, tt_dim, tvar_id;\n    size_t nxx, nyy, ntt;\n    static size_t start[] = { 0, 0, 0 }; // start at first value\n    static size_t count[] = { (size_t)nt, (size_t)ny, (size_t)nx };\n    int xx_id, yy_id, tt_id; //\n    nxx = nx;\n    nyy = ny;\n    ntt = nt;\n\n    //create the netcdf dataset\n    status = nc_create(name, NC_CLOBBER, &amp;ncid);\n    //Define dimensions: Name and length\n    status = nc_def_dim(ncid, \"xx\", nxx, &amp;xx_dim);\n    status = nc_def_dim(ncid, \"yy\", nyy, &amp;yy_dim);\n    status = nc_def_dim(ncid, \"time\", ntt, &amp;tt_dim);\n    int xdim[] = { xx_dim };\n    int ydim[] = { yy_dim };\n    int tdim[] = { tt_dim };\n\n    //define variables: Name, Type,...\n    int var_dimids[3];\n    var_dimids[0] = tt_dim;\n    var_dimids[1] = yy_dim;\n    var_dimids[2] = xx_dim;\n\n    status = nc_def_var(ncid, \"time\", NC_DOUBLE, 1, tdim, &amp;tt_id);\n    status = nc_def_var(ncid, \"xx\", NC_DOUBLE, 1, xdim, &amp;xx_id);\n    status = nc_def_var(ncid, \"yy\", NC_DOUBLE, 1, ydim, &amp;yy_id);\n\n    status = nc_def_var(ncid, varname, NC_DOUBLE, 3, var_dimids, &amp;tvar_id);\n\n    status = nc_enddef(ncid);\n\n    //static size_t tst[] = { 0 };\n    static size_t xstart[] = { 0 }; // start at first value\n    static size_t xcount[] = { (size_t)nx };\n    static size_t ystart[] = { 0 }; // start at first value\n    static size_t ycount[] = { (size_t)ny };\n\n    static size_t tstart[] = { 0 }; // start at first value\n    static size_t tcount[] = { (size_t)nt };\n\n    //Provide values for variables\n    status = nc_put_vara_double(ncid, xx_id, xstart, xcount, xx);\n    status = nc_put_vara_double(ncid, yy_id, ystart, ycount, yy);\n    status = nc_put_vara_double(ncid, tt_id, tstart, tcount, theta);\n\n    status = nc_put_vara_double(ncid, tvar_id, start, count, var);\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n}\n\nextern \"C\" void write3dvarnc(int nx, int ny, int nt, double totaltime, double* var)\n{\n    int status;\n    int ncid, recid;\n    //size_t nxx, nyy;\n    static size_t start[] = { 0, 0, 0, 0 }; // start at first value\n    static size_t count[] = { 1, (size_t)nt, (size_t)ny, (size_t)nx };\n    static size_t tst[] = { 0 };\n    int time_id, var_id;\n\n    //nxx = nx;\n    //nyy = ny;\n\n    static size_t nrec;\n    status = nc_open(\"3Dvar.nc\", NC_WRITE, &amp;ncid);\n    //read id from time dimension\n    status = nc_inq_unlimdim(ncid, &amp;recid);\n    status = nc_inq_dimlen(ncid, recid, &amp;nrec);\n    //printf(\"nrec=%d\\n\",nrec);\n\n     //read file for variable ids\n    status = nc_inq_varid(ncid, \"time\", &amp;time_id);\n    status = nc_inq_varid(ncid, \"3Dvar\", &amp;var_id);\n    start[0] = nrec;//\n    tst[0] = nrec;\n\n    //Provide values for variables\n    status = nc_put_var1_double(ncid, time_id, tst, &amp;totaltime);\n    status = nc_put_vara_double(ncid, var_id, start, count, var);\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n}\n\nextern \"C\" void write2dvarnc(int nx, int ny, double totaltime, double* var)\n{\n    int status;\n    int ncid, recid;\n    //size_t nxx, nyy;\n    static size_t start[] = { 0, 0, 0 }; // start at first value\n    static size_t count[] = { 1, (size_t)ny, (size_t)nx };\n    static size_t tst[] = { 0 };\n    int time_id, var_id;\n\n    //nxx = nx;\n    //nyy = ny;\n\n    static size_t nrec;\n    status = nc_open(\"3Dvar.nc\", NC_WRITE, &amp;ncid);\n\n    //read id from time dimension\n    status = nc_inq_unlimdim(ncid, &amp;recid);\n    status = nc_inq_dimlen(ncid, recid, &amp;nrec);\n    //printf(\"nrec=%d\\n\",nrec);\n\n     //read file for variable ids\n    status = nc_inq_varid(ncid, \"time\", &amp;time_id);\n    status = nc_inq_varid(ncid, \"3Dvar\", &amp;var_id);\n\n    start[0] = nrec;//\n    tst[0] = nrec;\n\n    //Provide values for variables\n    status = nc_put_var1_double(ncid, time_id, tst, &amp;totaltime);\n    status = nc_put_vara_double(ncid, var_id, start, count, var);\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n}\n</code></pre>"},{"location":"BGFlood/Write__netcdf_8h/","title":"File Write_netcdf.h","text":""},{"location":"BGFlood/Write__netcdf_8h/#file-write_netcdfh","title":"File Write_netcdf.h","text":"<p>FileList &gt; src &gt; Write_netcdf.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"ReadInput.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> </ul>"},{"location":"BGFlood/Write__netcdf_8h/#public-functions","title":"Public Functions","text":"Type Name void InitSave2Netcdf (Param &amp; XParam, Model&lt; T &gt; &amp; XModel)  void Save2Netcdf (Param XParam, Loop&lt; T &gt; XLoop, Model&lt; T &gt; &amp; XModel)  void create2dnc (char * filename, int nx, int ny, double * xx, double * yy, double * var, char * varname)  void create3dnc (char * name, int nx, int ny, int nt, double * xx, double * yy, double * theta, double * var, char * varname)  void creatncfileBUQ (Param &amp; XParam, int * activeblk, int * level, T * blockxo, T * blockyo, outzoneB &amp; Xzone)  void creatncfileBUQ (Param &amp; XParam, BlockP&lt; T &gt; &amp; XBlock)  void defncvarBUQ (Param XParam, int * activeblk, int * level, T * blockxo, T * blockyo, std::string varst, int vdim, T * var, outzoneB Xzone)  void handle_ncerror (int status)  void write2dvarnc (int nx, int ny, double totaltime, double * var)  void write3dvarnc (int nx, int ny, int nt, double totaltime, double * var)  void writenctimestep (std::string outfile, double totaltime)  void writencvarstepBUQ (Param XParam, int vdim, int * activeblk, int * level, T * blockxo, T * blockyo, std::string varst, T * var, outzoneB Xzone)"},{"location":"BGFlood/Write__netcdf_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Write__netcdf_8h/#function-initsave2netcdf","title":"function InitSave2Netcdf","text":"<pre><code>template&lt;class T&gt;\nvoid InitSave2Netcdf (\n    Param &amp; XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8h/#function-save2netcdf","title":"function Save2Netcdf","text":"<pre><code>template&lt;class T&gt;\nvoid Save2Netcdf (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8h/#function-create2dnc","title":"function create2dnc","text":"<pre><code>void create2dnc (\n    char * filename,\n    int nx,\n    int ny,\n    double * xx,\n    double * yy,\n    double * var,\n    char * varname\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8h/#function-create3dnc","title":"function create3dnc","text":"<pre><code>void create3dnc (\n    char * name,\n    int nx,\n    int ny,\n    int nt,\n    double * xx,\n    double * yy,\n    double * theta,\n    double * var,\n    char * varname\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8h/#function-creatncfilebuq","title":"function creatncfileBUQ","text":"<pre><code>template&lt;class T&gt;\nvoid creatncfileBUQ (\n    Param &amp; XParam,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    outzoneB &amp; Xzone\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8h/#function-creatncfilebuq_1","title":"function creatncfileBUQ","text":"<pre><code>template&lt;class T&gt;\nvoid creatncfileBUQ (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8h/#function-defncvarbuq","title":"function defncvarBUQ","text":"<pre><code>template&lt;class T&gt;\nvoid defncvarBUQ (\n    Param XParam,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    std::string varst,\n    int vdim,\n    T * var,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8h/#function-handle_ncerror","title":"function handle_ncerror","text":"<pre><code>void handle_ncerror (\n    int status\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8h/#function-write2dvarnc","title":"function write2dvarnc","text":"<pre><code>void write2dvarnc (\n    int nx,\n    int ny,\n    double totaltime,\n    double * var\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8h/#function-write3dvarnc","title":"function write3dvarnc","text":"<pre><code>void write3dvarnc (\n    int nx,\n    int ny,\n    int nt,\n    double totaltime,\n    double * var\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8h/#function-writenctimestep","title":"function writenctimestep","text":"<pre><code>void writenctimestep (\n    std::string outfile,\n    double totaltime\n) \n</code></pre>"},{"location":"BGFlood/Write__netcdf_8h/#function-writencvarstepbuq","title":"function writencvarstepBUQ","text":"<pre><code>template&lt;class T&gt;\nvoid writencvarstepBUQ (\n    Param XParam,\n    int vdim,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    std::string varst,\n    T * var,\n    outzoneB Xzone\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Write_netcdf.h</code></p>"},{"location":"BGFlood/Write__netcdf_8h_source/","title":"File Write_netcdf.h","text":""},{"location":"BGFlood/Write__netcdf_8h_source/#file-write_netcdfh","title":"File Write_netcdf.h","text":"<p>File List &gt; src &gt; Write_netcdf.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef WRITENETCDF_H\n#define WRITENETCDF_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"ReadInput.h\"\n#include \"MemManagement.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n\nvoid handle_ncerror(int status);\ntemplate&lt;class T&gt; void creatncfileBUQ(Param &amp;XParam, int* activeblk, int* level, T* blockxo, T* blockyo, outzoneB &amp;Xzone);\ntemplate&lt;class T&gt; void creatncfileBUQ(Param &amp;XParam, BlockP&lt;T&gt; &amp;XBlock);\ntemplate &lt;class T&gt; void defncvarBUQ(Param XParam, int * activeblk, int * level, T * blockxo, T *blockyo, std::string varst, int vdim, T * var, outzoneB Xzone);\ntemplate &lt;class T&gt; void writencvarstepBUQ(Param XParam, int vdim, int * activeblk, int* level, T * blockxo, T *blockyo, std::string varst, T * var, outzoneB Xzone);\ntemplate &lt;class T&gt; void InitSave2Netcdf(Param &amp;XParam, Model&lt;T&gt; &amp;XModel);\n//template &lt;class T&gt; void SaveInitialisation2Netcdf(Param&amp; XParam, Model&lt;T&gt;&amp; XModel);\nextern \"C\" void writenctimestep(std::string outfile, double totaltime);\ntemplate &lt;class T&gt; void Save2Netcdf(Param XParam, Loop&lt;T&gt; XLoop, Model&lt;T&gt; &amp;XModel);\n\nextern \"C\" void create2dnc(char* filename, int nx, int ny, double* xx, double* yy, double* var, char* varname);\nextern \"C\" void create3dnc(char* name, int nx, int ny, int nt, double* xx, double* yy, double* theta, double* var, char* varname);\nextern \"C\" void write3dvarnc(int nx, int ny, int nt, double totaltime, double* var);\nextern \"C\" void write2dvarnc(int nx, int ny, double totaltime, double* var);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/Write__txtlog_8cpp/","title":"File Write_txtlog.cpp","text":""},{"location":"BGFlood/Write__txtlog_8cpp/#file-write_txtlogcpp","title":"File Write_txtlog.cpp","text":"<p>FileList &gt; src &gt; Write_txtlog.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Write_txtlog.h\"</code></li> </ul>"},{"location":"BGFlood/Write__txtlog_8cpp/#public-functions","title":"Public Functions","text":"Type Name void SaveParamtolog (Param XParam)  void create_logfile ()  void log (std::string text)  void saveparam2netCDF (int ncid, int bgfid, Param XParam)  void write_text_to_log_file (std::string text)"},{"location":"BGFlood/Write__txtlog_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Write__txtlog_8cpp/#function-saveparamtolog","title":"function SaveParamtolog","text":"<pre><code>void SaveParamtolog (\n    Param XParam\n) \n</code></pre>"},{"location":"BGFlood/Write__txtlog_8cpp/#function-create_logfile","title":"function create_logfile","text":"<pre><code>void create_logfile () \n</code></pre>"},{"location":"BGFlood/Write__txtlog_8cpp/#function-log","title":"function log","text":"<pre><code>void log (\n    std::string text\n) \n</code></pre>"},{"location":"BGFlood/Write__txtlog_8cpp/#function-saveparam2netcdf","title":"function saveparam2netCDF","text":"<pre><code>void saveparam2netCDF (\n    int ncid,\n    int bgfid,\n    Param XParam\n) \n</code></pre>"},{"location":"BGFlood/Write__txtlog_8cpp/#function-write_text_to_log_file","title":"function write_text_to_log_file","text":"<pre><code>void write_text_to_log_file (\n    std::string text\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Write_txtlog.cpp</code></p>"},{"location":"BGFlood/Write__txtlog_8cpp_source/","title":"File Write_txtlog.cpp","text":""},{"location":"BGFlood/Write__txtlog_8cpp_source/#file-write_txtlogcpp","title":"File Write_txtlog.cpp","text":"<p>File List &gt; src &gt; Write_txtlog.cpp</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //\n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n#include \"Write_txtlog.h\"\n\n\n\nvoid log(std::string text)\n{\n\n    std::cout &lt;&lt; text &lt;&lt; std::endl;\n    write_text_to_log_file(text);\n\n}\n\nvoid create_logfile()\n{\n    // Reset the log file\n    std::ofstream log_file(\n        \"BG_log.txt\", std::ios_base::out | std::ios_base::trunc);\n\n    log_file.close();\n\n    //Logfile header\n    //auto n = std::chrono::system_clock::now();\n    //auto in_time_t = std::chrono::system_clock::to_time_t(n);\n    //std::tm buf;\n    //localtime_s(&amp;buf, &amp;in_time_t);\n    //std::cout &lt;&lt; std::put_time(&amp;buf, \"%Y-%m-%d %X\") &lt;&lt; std::endl;\n/*\n    auto now = std::chrono::system_clock::now();\n    auto in_time_t = std::chrono::system_clock::to_time_t(now);\n\n     std::stringstream ss;\n     ss &lt;&lt; std::put_time(std::localtime(&amp;in_time_t), \"%Y-%m-%d %X\");\n     */\n/*\n    std::time_t now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());\n\n    std::string s(30, '\\0');\n    std::tm buf;\n    struct tm * timeinfo;\n    std::localtime_s(&amp;buf, &amp;now);\n    //std::time_t rawtime;\n    //timeinfo = localtime(&amp;rawtime);\n    std::strftime(&amp;s[0], s.size(), \"%Y-%m-%d %H:%M:%S\", &amp;timeinfo);\n*/\n    //strftime(buffer, 80, \"%d-%m-%Y %H:%M:%S\", timeinfo);\n    //std::string strtimenow(buffer);\n\n    time_t rawtime;\n    struct tm* timeinfo;\n    char buffer[80];\n\n    time(&amp;rawtime);\n    timeinfo = localtime(&amp;rawtime);\n\n    strftime(buffer, 80, \"%d-%m-%Y %H:%M:%S\", timeinfo);\n    std::string strtimenow(buffer);\n\n\n    log(\"#################################\");\n\n    log(\"BG_Flood v0.95\");\n\n    log(\"#################################\");\n    //log(\"model started at \" + ss.str());\n    log(\"#################################\");\n    log(\"#\");\n\n    write_text_to_log_file(\"model started at \" + strtimenow);\n}\n\nvoid write_text_to_log_file(std::string text)\n{\n    std::ofstream log_file(\n        \"BG_log.txt\", std::ios_base::out | std::ios_base::app);\n    log_file &lt;&lt; text &lt;&lt; std::endl;\n    log_file.close(); //destructor implicitly does it\n}\n\nvoid SaveParamtolog(Param XParam)// need to bring in Xforcing info too!\n{\n    write_text_to_log_file(\"\\n\");\n    write_text_to_log_file(\"###################################\");\n    write_text_to_log_file(\"### Summary of model parameters ###\");\n    write_text_to_log_file(\"###################################\");\n    write_text_to_log_file(\"# Bathymetry file\");\n    //write_text_to_log_file(\"bathy = \" + XParam.Bathymetry.inputfile + \";\");\n    write_text_to_log_file(\"posdown = \" + std::to_string(XParam.posdown) + \";\");\n    //write_text_to_log_file(\"nx = \" + std::to_string(XParam.nx) + \";\");\n    //write_text_to_log_file(\"ny = \" + std::to_string(XParam.ny) + \";\");\n    write_text_to_log_file(\"dx = \" + std::to_string(XParam.dx) + \";\");\n    write_text_to_log_file(\"delta = \" + std::to_string(XParam.delta) + \";\");\n    write_text_to_log_file(\"grdalpha = \" + std::to_string(XParam.grdalpha*180.0 / pi) + \";\");\n    write_text_to_log_file(\"xo = \" + std::to_string(XParam.xo) + \";\");\n    write_text_to_log_file(\"yo = \" + std::to_string(XParam.yo) + \";\");\n    write_text_to_log_file(\"xmax = \" + std::to_string(XParam.xo) + \";\");\n    write_text_to_log_file(\"ymax = \" + std::to_string(XParam.yo) + \";\");\n    write_text_to_log_file(\"\\n\");\n\n\n    write_text_to_log_file(\"gpudevice = \" + std::to_string(XParam.GPUDEVICE) + \";\");\n    write_text_to_log_file(\"\\n\");\n    write_text_to_log_file(\"# Flow parameters\");\n    write_text_to_log_file(\"eps = \" + std::to_string(XParam.eps) + \";\");\n    write_text_to_log_file(\"cf = \" + std::to_string(XParam.cf) + \";\");\n\n    write_text_to_log_file(\"theta = \" + std::to_string(XParam.theta) + \";\");\n\n\n    write_text_to_log_file(\"Cd = \" + std::to_string(XParam.Cd) + \";\");\n\n    write_text_to_log_file(\"\\n\");\n    write_text_to_log_file(\"# Timekeeping parameters\");\n    write_text_to_log_file(\"CFL = \" + std::to_string(XParam.CFL) + \";\");\n    write_text_to_log_file(\"totaltime = \" + std::to_string(XParam.totaltime) + \"; # Start time\");\n    write_text_to_log_file(\"endtime = \" + std::to_string(XParam.endtime) + \";\");\n    write_text_to_log_file(\"outputtimestep = \" + std::to_string(XParam.outputtimestep) + \";\");\n\n\n    std::string alloutvars = \"\";\n    for (int nvar = 0; nvar &lt; XParam.outvars.size(); nvar++)\n    {\n        if (nvar &gt; 0)\n        {\n            alloutvars = alloutvars + \", \";\n        }\n        alloutvars = alloutvars + XParam.outvars[nvar];\n    }\n    write_text_to_log_file(\"outvars = \" + alloutvars + \";\");\n\n\n\n    write_text_to_log_file(\"\\n\");\n    write_text_to_log_file(\"# Files\");\n    if (!XParam.outzone.empty())\n    {\n        for (int o = 0; o &lt; XParam.outzone.size(); o++)\n        {\n            write_text_to_log_file(\"outzonefile = \" + XParam.outzone[o].outname + \",\" + std::to_string(XParam.outzone[o].xstart) + \",\" + std::to_string(XParam.outzone[o].xend) + \",\" + std::to_string(XParam.outzone[o].ystart) + \",\" + std::to_string(XParam.outzone[o].yend) + \";\");\n        }\n    }\n    else\n    {\n        write_text_to_log_file(\"outfile = \" + XParam.outfile + \";\");\n    }\n\n    write_text_to_log_file(\"smallnc = \" + std::to_string(XParam.smallnc) + \"; #if smallnc==1 all Output are scaled and saved as a short int\");\n    if (XParam.smallnc == 1)\n    {\n        write_text_to_log_file(\"scalefactor = \" + std::to_string(XParam.scalefactor) + \";\");\n        write_text_to_log_file(\"addoffset = \" + std::to_string(XParam.addoffset) + \";\");\n    }\n\n    if (!XParam.TSnodesout.empty())\n    {\n        for (int o = 0; o &lt; XParam.TSnodesout.size(); o++)\n        {\n            write_text_to_log_file(\"TSOfile = \" + XParam.TSnodesout[o].outname + \",\" + std::to_string(XParam.TSnodesout[o].x) + \",\" + std::to_string(XParam.TSnodesout[o].y)+\";\");\n            //write_text_to_log_file(\"TSnode = \" + std::to_string(XParam.TSnodesout[o].i) + \",\" + std::to_string(XParam.TSnodesout[o].j) + \";\");\n        }\n    }\n    write_text_to_log_file(\"\\n\");\n    write_text_to_log_file(\"# Boundaries\");\n    write_text_to_log_file(\"# 0:wall; 1: Neumann (Default); 2:Dirichlet (zs); 3: abs1d \");\n    /*\n    //write_text_to_log_file(\"right = \" + std::to_string(XParam.rightbnd.type) + \";\");\n    //write_text_to_log_file(\"left = \" + std::to_string(XParam.leftbnd.type) + \";\");\n    //write_text_to_log_file(\"top = \" + std::to_string(XParam.topbnd.type) + \";\");\n    //write_text_to_log_file(\"bot = \" + std::to_string(XParam.botbnd.type) + \";\");\n\n    if (!XParam.rightbnd.inputfile.empty())\n        write_text_to_log_file(\"rightbndfile = \" + XParam.rightbnd.inputfile + \";\");\n    if (!XParam.leftbnd.inputfile.empty())\n        write_text_to_log_file(\"leftbndfile = \" + XParam.leftbnd.inputfile + \";\");\n    if (!XParam.topbnd.inputfile.empty())\n        write_text_to_log_file(\"topbndfile = \" + XParam.topbnd.inputfile + \";\");\n    if (!XParam.botbnd.inputfile.empty())\n        write_text_to_log_file(\"botbndfile = \" + XParam.botbnd.inputfile + \";\");\n*/\n    /*\n    std::string rightbndfile;\n    std::string leftbndfile;\n    std::string topbndfile;\n    std::string botbndfile;\n    */\n    //hot start\n    if (!XParam.hotstartfile.empty())\n    {\n        write_text_to_log_file(\"hotstartfile = \" + XParam.hotstartfile + \";\");\n        write_text_to_log_file(\"hotstep = \" + std::to_string(XParam.hotstep) + \";\");\n    }\n\n\n    write_text_to_log_file(\"\\n\");\n    write_text_to_log_file(\"# Others\");\n    write_text_to_log_file(\"g = \" + std::to_string(XParam.g) + \";\");\n    write_text_to_log_file(\"rho = \" + std::to_string(XParam.rho) + \";\");\n    write_text_to_log_file(\"\\n\");\n}\n\n\n\nvoid saveparam2netCDF(int ncid, int bgfid, Param XParam)\n{\n    int status, boolanswer;\n    //status = nc_put_att_text(ncid, bgfid, \"grid_mapping_name\", crsname.size(), crsname.c_str());\n    //status = nc_put_att_float(ncid, bgfid, \"longitude_of_prime_meridian\", NC_FLOAT, 1, &amp;primemeridian);\n\n    status = nc_put_att_int(ncid, bgfid, \"test\", NC_INT, 1, &amp;XParam.test);\n    status = nc_put_att_double(ncid, bgfid, \"g\", NC_DOUBLE, 1, &amp;XParam.g);\n    status = nc_put_att_double(ncid, bgfid, \"rho\", NC_DOUBLE, 1, &amp;XParam.rho);\n    status = nc_put_att_double(ncid, bgfid, \"eps\", NC_DOUBLE, 1, &amp;XParam.eps);\n    status = nc_put_att_double(ncid, bgfid, \"CFL\", NC_DOUBLE, 1, &amp;XParam.CFL);\n    status = nc_put_att_double(ncid, bgfid, \"theta\", NC_DOUBLE, 1, &amp;XParam.theta);\n    status = nc_put_att_double(ncid, bgfid, \"VelThreshold\", NC_DOUBLE, 1, &amp;XParam.VelThreshold);\n\n    status = nc_put_att_int(ncid, bgfid, \"frictionmodel\", NC_INT, 1, &amp;XParam.frictionmodel);\n\n    status = nc_put_att_double(ncid, bgfid, \"Cd\", NC_DOUBLE, 1, &amp;XParam.Cd);\n    status = nc_put_att_double(ncid, bgfid, \"Pa2m\", NC_DOUBLE, 1, &amp;XParam.Pa2m);\n    status = nc_put_att_double(ncid, bgfid, \"Paref\", NC_DOUBLE, 1, &amp;XParam.Paref);\n    status = nc_put_att_double(ncid, bgfid, \"lat\", NC_DOUBLE, 1, &amp;XParam.lat);\n\n    boolanswer = XParam.windforcing;\n    status = nc_put_att_int(ncid, bgfid, \"windforcing\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.atmpforcing;\n    status = nc_put_att_int(ncid, bgfid, \"atmpforcing\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.rainforcing;\n    status = nc_put_att_int(ncid, bgfid, \"rainforcing\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.infiltration;\n    status = nc_put_att_int(ncid, bgfid, \"infiltration\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.conserveElevation;\n    status = nc_put_att_int(ncid, bgfid, \"conserveElevation\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.wetdryfix;\n    status = nc_put_att_int(ncid, bgfid, \"wetdryfix\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.leftbnd;\n    status = nc_put_att_int(ncid, bgfid, \"leftbnd\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.rightbnd;\n    status = nc_put_att_int(ncid, bgfid, \"rightbnd\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.topbnd;\n    status = nc_put_att_int(ncid, bgfid, \"topbnd\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.botbnd;\n    status = nc_put_att_int(ncid, bgfid, \"botbnd\", NC_INT, 1, &amp;boolanswer);\n\n\n\n\n\n    double cf = 0.0001; // Bottom friction coefficient for flow model (if constant)\n\n\n    status = nc_put_att_int(ncid, bgfid, \"GPUDEVICE\", NC_INT, 1, &amp;XParam.GPUDEVICE);\n\n    status = nc_put_att_int(ncid, bgfid, \"doubleprecision\", NC_INT, 1, &amp;XParam.doubleprecision);\n\n    status = nc_put_att_int(ncid, bgfid, \"engine\", NC_INT, 1, &amp;XParam.engine);\n\n    status = nc_put_att_double(ncid, bgfid, \"dx\", NC_DOUBLE, 1, &amp;XParam.dx);\n    status = nc_put_att_double(ncid, bgfid, \"delta\", NC_DOUBLE, 1, &amp;XParam.delta);\n\n    status = nc_put_att_double(ncid, bgfid, \"xo\", NC_DOUBLE, 1, &amp;XParam.xo);\n    status = nc_put_att_double(ncid, bgfid, \"yo\", NC_DOUBLE, 1, &amp;XParam.yo);\n    status = nc_put_att_double(ncid, bgfid, \"xmax\", NC_DOUBLE, 1, &amp;XParam.xmax);\n    status = nc_put_att_double(ncid, bgfid, \"ymax\", NC_DOUBLE, 1, &amp;XParam.ymax);\n\n    status = nc_put_att_double(ncid, bgfid, \"grdalpha\", NC_DOUBLE, 1, &amp;XParam.grdalpha);\n\n    status = nc_put_att_int(ncid, bgfid, \"nx\", NC_INT, 1, &amp;XParam.nx);\n    status = nc_put_att_int(ncid, bgfid, \"ny\", NC_INT, 1, &amp;XParam.ny);\n    status = nc_put_att_int(ncid, bgfid, \"nblk\", NC_INT, 1, &amp;XParam.nblk);\n\n    status = nc_put_att_int(ncid, bgfid, \"blkwidth\", NC_INT, 1, &amp;XParam.blkwidth);\n    status = nc_put_att_int(ncid, bgfid, \"blkmemwidth\", NC_INT, 1, &amp;XParam.blkmemwidth);\n    status = nc_put_att_int(ncid, bgfid, \"blksize\", NC_INT, 1, &amp;XParam.blksize);\n    status = nc_put_att_int(ncid, bgfid, \"halowidth\", NC_INT, 1, &amp;XParam.halowidth);\n    status = nc_put_att_int(ncid, bgfid, \"posdown\", NC_INT, 1, &amp;XParam.posdown);\n\n    boolanswer = XParam.spherical;\n    status = nc_put_att_int(ncid, bgfid, \"spherical\", NC_INT, 1, &amp;boolanswer);\n    status = nc_put_att_double(ncid, bgfid, \"Radius\", NC_DOUBLE, 1, &amp;XParam.Radius);\n    status = nc_put_att_double(ncid, bgfid, \"mask\", NC_DOUBLE, 1, &amp;XParam.mask);\n\n    status = nc_put_att_int(ncid, bgfid, \"initlevel\", NC_INT, 1, &amp;XParam.initlevel);\n    status = nc_put_att_int(ncid, bgfid, \"maxlevel\", NC_INT, 1, &amp;XParam.maxlevel);\n    status = nc_put_att_int(ncid, bgfid, \"minlevel\", NC_INT, 1, &amp;XParam.minlevel);\n    status = nc_put_att_int(ncid, bgfid, \"nblkmem\", NC_INT, 1, &amp;XParam.nblkmem);\n    status = nc_put_att_int(ncid, bgfid, \"navailblk\", NC_INT, 1, &amp;XParam.navailblk);\n    status = nc_put_att_double(ncid, bgfid, \"membuffer\", NC_DOUBLE, 1, &amp;XParam.membuffer);\n\n    status = nc_put_att_double(ncid, bgfid, \"outputtimestep\", NC_DOUBLE, 1, &amp;XParam.outputtimestep);\n    status = nc_put_att_double(ncid, bgfid, \"endtime\", NC_DOUBLE, 1, &amp;XParam.endtime);\n    status = nc_put_att_double(ncid, bgfid, \"totaltime\", NC_DOUBLE, 1, &amp;XParam.totaltime);\n    status = nc_put_att_double(ncid, bgfid, \"dtinit\", NC_DOUBLE, 1, &amp;XParam.dtinit);\n    status = nc_put_att_double(ncid, bgfid, \"dtmin\", NC_DOUBLE, 1, &amp;XParam.dtmin);\n\n    status = nc_put_att_double(ncid, bgfid, \"zsinit\", NC_DOUBLE, 1, &amp;XParam.zsinit);\n    status = nc_put_att_double(ncid, bgfid, \"zsoffset\", NC_DOUBLE, 1, &amp;XParam.zsoffset);\n\n    status = nc_put_att_text(ncid, bgfid, \"hotstartfile\", XParam.hotstartfile.size(), XParam.hotstartfile.c_str());\n    status = nc_put_att_int(ncid, bgfid, \"hotstep\", NC_INT, 1, &amp;XParam.hotstep);\n\n    status = nc_put_att_double(ncid, bgfid, \"wet_threshold \", NC_DOUBLE, 1, &amp;XParam.wet_threshold);\n\n    status = nc_put_att_int(ncid, bgfid, \"maxTSstorage\", NC_INT, 1, &amp;XParam.maxTSstorage);\n\n    boolanswer = XParam.resetmax;\n    status = nc_put_att_int(ncid, bgfid, \"resetmax\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.outmax;\n    status = nc_put_att_int(ncid, bgfid, \"outmax\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.outmean;\n    status = nc_put_att_int(ncid, bgfid, \"outmean\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.outtwet;\n    status = nc_put_att_int(ncid, bgfid, \"outtwet\", NC_INT, 1, &amp;boolanswer);\n\n    status = nc_put_att_int(ncid, bgfid, \"outishift\", NC_INT, 1, &amp;XParam.outishift);\n\n    status = nc_put_att_int(ncid, bgfid, \"outjshift\", NC_INT, 1, &amp;XParam.outjshift);\n\n    status = nc_put_att_int(ncid, bgfid, \"nrivers\", NC_INT, 1, &amp;XParam.nrivers);\n\n    status = nc_put_att_int(ncid, bgfid, \"nblkriver\", NC_INT, 1, &amp;XParam.nblkriver);\n\n    status = nc_put_att_int(ncid, bgfid, \"nbndblkleft\", NC_INT, 1, &amp;XParam.nbndblkleft);\n    status = nc_put_att_int(ncid, bgfid, \"nbndblkright\", NC_INT, 1, &amp;XParam.nbndblkright);\n    status = nc_put_att_int(ncid, bgfid, \"nbndblktop\", NC_INT, 1, &amp;XParam.nbndblktop);\n    status = nc_put_att_int(ncid, bgfid, \"nbndblkbot\", NC_INT, 1, &amp;XParam.nbndblkbot);\n\n    status = nc_put_att_int(ncid, bgfid, \"nmaskblk\", NC_INT, 1, &amp;XParam.nmaskblk);\n\n    status = nc_put_att_int(ncid, bgfid, \"smallnc\", NC_INT, 1, &amp;XParam.smallnc);\n\n    status = nc_put_att_float(ncid, bgfid, \"scalefactor\", NC_FLOAT, 1, &amp;XParam.scalefactor);\n\n    status = nc_put_att_float(ncid, bgfid, \"addoffset\", NC_FLOAT, 1, &amp;XParam.addoffset);\n\n    status = nc_put_att_double(ncid, bgfid, \"deformmaxtime\", NC_DOUBLE, 1, &amp;XParam.deformmaxtime);\n\n    boolanswer = XParam.rainbnd;\n    status = nc_put_att_int(ncid, bgfid, \"rainbnd\", NC_INT, 1, &amp;boolanswer);\n\n    status = nc_put_att_text(ncid, bgfid, \"AdaptCrit\", XParam.AdaptCrit.size(), XParam.AdaptCrit.c_str());\n\n    status = nc_put_att_text(ncid, bgfid, \"Adapt_arg1\", XParam.Adapt_arg1.size(), XParam.Adapt_arg1.c_str());\n    status = nc_put_att_text(ncid, bgfid, \"Adapt_arg2\", XParam.Adapt_arg2.size(), XParam.Adapt_arg2.c_str());\n    status = nc_put_att_text(ncid, bgfid, \"Adapt_arg3\", XParam.Adapt_arg3.size(), XParam.Adapt_arg3.c_str());\n    status = nc_put_att_text(ncid, bgfid, \"Adapt_arg4\", XParam.Adapt_arg4.size(), XParam.Adapt_arg4.c_str());\n    status = nc_put_att_text(ncid, bgfid, \"Adapt_arg5\", XParam.Adapt_arg5.size(), XParam.Adapt_arg5.c_str());\n\n    status = nc_put_att_int(ncid, bgfid, \"adaptmaxiteration\", NC_INT, 1, &amp;XParam.adaptmaxiteration);\n\n    status = nc_put_att_text(ncid, bgfid, \"reftime\", XParam.reftime.size(), XParam.reftime.c_str());\n\n\n    std::string allouvars;\n    for (int i = 0; i &lt; XParam.outvars.size(); i++)\n    {\n        allouvars = allouvars + XParam.outvars[i];\n        if (i &lt; (XParam.outvars.size() - 1))\n        {\n            allouvars = allouvars + \", \";\n        }\n    }\n\n    status = nc_put_att_text(ncid, bgfid, \"outvars\", allouvars.size(), allouvars.c_str());\n\n    status = nc_put_att_text(ncid, bgfid, \"outfile\", XParam.outfile.size(), XParam.outfile.c_str());\n\n\n\n\n\n    /*\n\n    std::vector&lt;TSoutnode&gt; TSnodesout;\n\n\n\n\n\n    std::vector&lt;outzoneP&gt; outzone;\n\n    // deformation forcing for tsunami generation\n    //std::vector&lt;deformmap&gt; deform;\n\n\n    std::string AdaptCrit;\n    int* AdaptCrit_funct_pointer;\n\n\n    */\n}\n</code></pre>"},{"location":"BGFlood/Write__txtlog_8h/","title":"File Write_txtlog.h","text":""},{"location":"BGFlood/Write__txtlog_8h/#file-write_txtlogh","title":"File Write_txtlog.h","text":"<p>FileList &gt; src &gt; Write_txtlog.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> </ul>"},{"location":"BGFlood/Write__txtlog_8h/#public-functions","title":"Public Functions","text":"Type Name void SaveParamtolog (Param XParam)  void create_logfile ()  void log (std::string text)  void saveparam2netCDF (int ncid, int bgfid, Param XParam)  void write_text_to_log_file (std::string text)"},{"location":"BGFlood/Write__txtlog_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/Write__txtlog_8h/#function-saveparamtolog","title":"function SaveParamtolog","text":"<pre><code>void SaveParamtolog (\n    Param XParam\n) \n</code></pre>"},{"location":"BGFlood/Write__txtlog_8h/#function-create_logfile","title":"function create_logfile","text":"<pre><code>void create_logfile () \n</code></pre>"},{"location":"BGFlood/Write__txtlog_8h/#function-log","title":"function log","text":"<pre><code>void log (\n    std::string text\n) \n</code></pre>"},{"location":"BGFlood/Write__txtlog_8h/#function-saveparam2netcdf","title":"function saveparam2netCDF","text":"<pre><code>void saveparam2netCDF (\n    int ncid,\n    int bgfid,\n    Param XParam\n) \n</code></pre>"},{"location":"BGFlood/Write__txtlog_8h/#function-write_text_to_log_file","title":"function write_text_to_log_file","text":"<pre><code>void write_text_to_log_file (\n    std::string text\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Write_txtlog.h</code></p>"},{"location":"BGFlood/Write__txtlog_8h_source/","title":"File Write_txtlog.h","text":""},{"location":"BGFlood/Write__txtlog_8h_source/#file-write_txtlogh","title":"File Write_txtlog.h","text":"<p>File List &gt; src &gt; Write_txtlog.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef WRITETXTLOG_H\n#define WRITETXTLOG_H\n\n#include \"General.h\"\n#include \"Param.h\"\n\nvoid log(std::string text);\nvoid create_logfile();\nvoid write_text_to_log_file(std::string text);\nvoid SaveParamtolog(Param XParam);\nvoid saveparam2netCDF(int ncid, int bgfid, Param XParam);\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/utctime_8cu/","title":"File utctime.cu","text":""},{"location":"BGFlood/utctime_8cu/#file-utctimecu","title":"File utctime.cu","text":"<p>FileList &gt; src &gt; utctime.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"utctime.h\"</code></li> </ul>"},{"location":"BGFlood/utctime_8cu/#public-functions","title":"Public Functions","text":"Type Name double date_string_to_s (std::string datetime, std::string refdate)  long long date_string_to_time (std::string date)  int days_from_epoch (int y, int m, int d)  struct tm * gmtime_r (const time_t * timep, struct tm * tm)  double readinputtimetxt (std::string input, std::string &amp; refdate)  bool testime1 (int hour)  bool testime2 (int hour)  long long timegm (struct tm const * t)"},{"location":"BGFlood/utctime_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/utctime_8cu/#function-date_string_to_s","title":"function date_string_to_s","text":"<pre><code>double date_string_to_s (\n    std::string datetime,\n    std::string refdate\n) \n</code></pre>"},{"location":"BGFlood/utctime_8cu/#function-date_string_to_time","title":"function date_string_to_time","text":"<pre><code>long long date_string_to_time (\n    std::string date\n) \n</code></pre>"},{"location":"BGFlood/utctime_8cu/#function-days_from_epoch","title":"function days_from_epoch","text":"<pre><code>int days_from_epoch (\n    int y,\n    int m,\n    int d\n) \n</code></pre>"},{"location":"BGFlood/utctime_8cu/#function-gmtime_r","title":"function gmtime_r","text":"<pre><code>struct tm * gmtime_r (\n    const time_t * timep,\n    struct tm * tm\n) \n</code></pre>"},{"location":"BGFlood/utctime_8cu/#function-readinputtimetxt","title":"function readinputtimetxt","text":"<pre><code>double readinputtimetxt (\n    std::string input,\n    std::string &amp; refdate\n) \n</code></pre>"},{"location":"BGFlood/utctime_8cu/#function-testime1","title":"function testime1","text":"<pre><code>bool testime1 (\n    int hour\n) \n</code></pre>"},{"location":"BGFlood/utctime_8cu/#function-testime2","title":"function testime2","text":"<pre><code>bool testime2 (\n    int hour\n) \n</code></pre>"},{"location":"BGFlood/utctime_8cu/#function-timegm","title":"function timegm","text":"<pre><code>long long timegm (\n    struct tm const * t\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/utctime.cu</code></p>"},{"location":"BGFlood/utctime_8cu_source/","title":"File utctime.cu","text":""},{"location":"BGFlood/utctime_8cu_source/#file-utctimecu","title":"File utctime.cu","text":"<p>File List &gt; src &gt; utctime.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"utctime.h\"\n\nnamespace chrono = std::chrono;\nusing chrono::duration_cast;\nusing chrono::time_point_cast; \n/*\nnamespace {\n\nstd::time_t to_time_t(const UTCClock::time_point &amp;tp) noexcept\n{\n  return std::time_t(\n      duration_cast&lt;chrono::seconds&gt;(tp.time_since_epoch()).count());\n}\n\nUTCClock::time_point from_time_t(std::time_t tt) noexcept\n{\n  return time_point_cast&lt;UTCClock::duration&gt;(\n     chrono::time_point&lt;UTCClock,chrono::seconds&gt;(chrono::seconds(tt)));\n}\n\n} // namespace\n*/\n// Algorithm: http://howardhinnant.github.io/date_algorithms.html\nint days_from_epoch(int y, int m, int d)\n{\n    y -= m &lt;= 2;\n    int era = y / 400;\n    int yoe = y - era * 400;                                   // [0, 399]\n    int doy = (153 * (m + (m &gt; 2 ? -3 : 9)) + 2) / 5 + d - 1;  // [0, 365]\n    int doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;           // [0, 146096]\n    return era * 146097 + doe - 719468;\n}\n/* Converts a Unix timestamp (number of seconds since the beginning of 1970\n * CE) to a Gregorian civil date-time tuple in GMT (UTC) time zone.\n *\n * This conforms to C89 (and C99...) and POSIX.\n *\n * This implementation works, and doesn't overflow for any sizeof(time_t).\n * It doesn't check for overflow/underflow in tm-&gt;tm_year output. Other than\n * that, it never overflows or underflows. It assumes that that time_t is\n * signed.\n *\n * This implements the inverse of the POSIX formula\n * (http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15)\n * for all time_t values, no matter the size, as long as tm-&gt;tm_year doesn't\n * overflow or underflow. The formula is: tm_sec + tm_min*60 + tm_hour*3600\n * + tm_yday*86400 + (tm_year-70)*31536000 + ((tm_year-69)/4)*86400 -\n * ((tm_year-1)/100)*86400 + ((tm_year+299)/400)*86400.\n */\nstruct tm* gmtime_r(const time_t* timep, struct tm* tm) {\n    const time_t ts = *timep;\n    time_t t = ts / 86400;\n    unsigned hms = ts % 86400;  /* -86399 &lt;= hms &lt;= 86399. This needs sizeof(int) &gt;= 4. */\n    time_t c, f;\n    unsigned yday;  /* 0 &lt;= yday &lt;= 426. Also fits to an `unsigned short', but `int' is faster. */\n    unsigned a;  /* 0 &lt;= a &lt;= 2133. Also fits to an `unsigned short', but `int' is faster. */\n    if ((int)hms &lt; 0) { --t; hms += 86400; }  /* Fix quotient and negative remainder if ts was negative (i.e. before year 1970 CE). */\n    /* Now: -24856 &lt;= t &lt;= 24855. */\n    tm-&gt;tm_sec = hms % 60;\n    hms /= 60;\n    tm-&gt;tm_min = hms % 60;\n    tm-&gt;tm_hour = hms / 60;\n    if (sizeof(time_t) &gt; 4) {  /* Optimization. For int32_t, this would keep t intact, so we won't have to do it. This produces unreachable code. */\n        f = (t + 4) % 7;\n        if (f &lt; 0) f += 7;  /* Fix negative remainder if (t + 4) was negative. */\n        /* Now 0 &lt;= f &lt;= 6. */\n        tm-&gt;tm_wday = f;\n        c = (t &lt;&lt; 2) + 102032;\n        f = c / 146097;\n        if (c % 146097 &lt; 0) --f;  /* Fix negative remainder if c was negative. */\n        --f;\n        t += f;\n        f &gt;&gt;= 2;\n        t -= f;\n        f = (t &lt;&lt; 2) + 102035;\n        c = f / 1461;\n        if (f % 1461 &lt; 0) --c;  /* Fix negative remainder if f was negative. */\n    }\n    else {\n        tm-&gt;tm_wday = (t + 24861) % 7;  /* t + 24861 &gt;= 0. */\n        /* Now: -24856 &lt;= t &lt;= 24855. */\n        c = ((t &lt;&lt; 2) + 102035) / 1461;\n    }\n    yday = t - 365 * c - (c &gt;&gt; 2) + 25568;\n    /* Now: 0 &lt;= yday &lt;= 425. */\n    a = yday * 5 + 8;\n    /* Now: 8 &lt;= a &lt;= 2133. */\n    tm-&gt;tm_mon = a / 153;\n    a %= 153;  /* No need to fix if a &lt; 0, because a cannot be negative here. */\n    /* Now: 2 &lt;= tm-&gt;tm_mon &lt;= 13. */\n    /* Now: 0 &lt;= a &lt;= 152. */\n    tm-&gt;tm_mday = 1 + a / 5;  /* No need to fix if a &lt; 0, because a cannot be negative here. */\n    /* Now: 1 &lt;= tm-&gt;tm_mday &lt;= 31. */\n    if (tm-&gt;tm_mon &gt;= 12) {\n        tm-&gt;tm_mon -= 12;\n        /* Now: 0 &lt;= tm-&gt;tm_mon &lt;= 1. */\n        ++c;\n        yday -= 366;\n    }\n    else {  /* Check for leap year (in c). */\n   /* Now: 2 &lt;= tm-&gt;tm_mon &lt;= 11. */\n   /* 1903: not leap; 1904: leap, 1900: not leap; 2000: leap */\n   /* With sizeof(time_t) == 4, we have 1901 &lt;= year &lt;= 2038; of these\n    * years only 2000 is divisble by 100, and that's a leap year, no we\n    * optimize the check to `(c &amp; 3) == 0' only.\n    */\n        if (!((c &amp; 3) == 0 &amp;&amp; (sizeof(time_t) &lt;= 4 || c % 100 != 0 || (c + 300) % 400 == 0))) --yday;  /* These `== 0' comparisons work even if c &lt; 0. */\n    }\n    tm-&gt;tm_year = c;  /* This assignment may overflow or underflow, we don't check it. Example: time_t is a huge int64_t, tm-&gt;tm_year is int32_t. */\n    /* Now: 0 &lt;= tm-&gt;tm_mon &lt;= 11. */\n    /* Now: 0 &lt;= yday &lt;= 365. */\n    tm-&gt;tm_yday = yday;\n    tm-&gt;tm_isdst = 0;\n    return tm;\n}\n\n\n// It  does not modify broken-down time\nlong long timegm(struct tm const* t)\n{\n    int year = t-&gt;tm_year + 1900;\n    int month = t-&gt;tm_mon;          // 0-11\n    if (month &gt; 11)\n    {\n        year += month / 12;\n        month %= 12;\n    }\n    else if (month &lt; 0)\n    {\n        int years_diff = (11 - month) / 12;\n        year -= years_diff;\n        month += 12 * years_diff;\n    }\n    int days_since_epoch = days_from_epoch(year, month + 1, t-&gt;tm_mday);\n\n    return 60LL * (60LL * (24LL * days_since_epoch + (long long)t-&gt;tm_hour) + (long long)t-&gt;tm_min) + (long long)t-&gt;tm_sec;\n}\n/*\nUTCClock::time_point UTCClock::fromDate(\n    int year, int month, int day, int hour, int min, int sec, int usec)\n{\n  std::tm tm     = {0};\n  tm.tm_year     = year - 1900;\n  tm.tm_mon      = month - 1;\n  tm.tm_mday     = day;\n  tm.tm_hour     = hour;\n  tm.tm_min      = min;\n  tm.tm_sec      = sec;\n  tm.tm_isdst    = -1;\n  std::time_t tt = timegm(&amp;tm);\n  return from_time_t(tt) + chrono::microseconds(usec);\n}\n\n\nvoid UTCClock::toDate(const UTCClock::time_point &amp;tp,\n                      int &amp;year,\n                      int &amp;month,\n                      int &amp;day,\n                      int &amp;hour,\n                      int &amp;min,\n                      int &amp;sec,\n                      int &amp;usec)\n{\n  std::time_t tt = to_time_t(tp);\n  std::tm tm;\n  gmtime_r(&amp;tt, &amp;tm);\n  year  = tm.tm_year + 1900;\n  month = tm.tm_mon + 1;\n  day   = tm.tm_mday;\n  hour  = tm.tm_hour;\n  min   = tm.tm_min;\n  chrono::microseconds leftover =\n      tp - from_time_t(tt) + chrono::seconds(tm.tm_sec);\n  sec = duration_cast&lt;chrono::seconds&gt;(leftover).count();\n  usec = (leftover-chrono::seconds(sec)).count();\n}\n*/\n\n\nlong long date_string_to_time(std::string date)\n{\n    struct tm tm = { 0 }; // Important, initialize all members\n    //int n = 0;\n    //int year, mon, day, hour, min, sec;\n    std::vector&lt;std::string&gt;  datetime, ddd, ttt;\n    datetime = split(date, 'T');\n    if (datetime.size() &lt; 2)\n    {\n        datetime.clear();\n        datetime = split(date, ' ');\n    }\n\n    ddd = split(datetime[0], '-');\n    if (ddd.size() &lt; 3)\n    {\n        ddd = split(datetime[0], '/');\n    }\n    // index for the year and mday\n    //by default we assume date is written as yyyy-mm-ddTHH:MM:SS\n    int indexyear = 0;\n    int indexmday = 2;\n\n    if (ddd[0].length() &lt; 4 &amp;&amp; ddd[2].length() == 4)//i.e. date is written as dd-mm-yyyy\n    {\n        int indexyear = 2;\n        int indexmday = 0;\n    }\n    // If you write date like an American (mm-dd-yyyy). it wont work and I can't help\n\n    tm.tm_year = std::stoi(ddd[indexyear]);\n\n    tm.tm_mon = std::stoi(ddd[1]);\n\n    tm.tm_mday = std::stoi(ddd[indexmday]);\n\n    if (datetime.size() &gt; 1)\n    {\n\n        ttt = split(datetime[1], ':');\n\n        tm.tm_hour = std::stoi(ttt[0]);\n        tm.tm_min = std::stoi(ttt[1]);\n        if (ttt.size() == 3)\n        {\n            tm.tm_sec = std::stoi(ttt[2]);\n        }\n        else\n        {\n            tm.tm_sec = 0;\n        }\n    }\n    else\n    {\n        tm.tm_hour = 0;\n        tm.tm_min = 0;\n        tm.tm_sec = 0;\n    }\n\n\n\n\n    //sscanf(date, \"%d-%d-%dT%d:%d:%d %n\", &amp;tm.tm_year, &amp;tm.tm_mon, &amp;tm.tm_mday,\n    //  &amp;tm.tm_hour, &amp;tm.tm_min, &amp;tm.tm_sec, &amp;n);\n    // If scan did not completely succeed or extra junk\n    //if (n == 0 || date[n]) {\n    //  return (time_t)-1;\n    //}\n    //tm.tm_isdst = 0; // Eforce output to be standard time. \n    tm.tm_mon--;      // Months since January\n    // Assume 2 digit year if in the range 2000-2099, else assume year as given\n    if (tm.tm_year &gt;= 0 &amp;&amp; tm.tm_year &lt; 100) {\n        tm.tm_year += 2000;\n    }\n    tm.tm_year -= 1900; // Years since 1900\n    //UTCTime t1 = UTCClock::fromDate(year, mon, day, hour, min, sec, 0);\n    long long t1 = timegm(&amp;tm);\n    return t1;\n}\n\ndouble date_string_to_s(std::string datetime, std::string refdate)\n{\n    //testime1(1);\n    //testime2(2);\n\n    //UTCTime ttime = date_string_to_time(datetime);\n    //UTCTime reftime = date_string_to_time(refdate);\n\n    double diff;\n\n    std::string::size_type n = datetime.find('T');\n    if (std::string::npos == n)\n    {\n        diff = std::stod(datetime);\n    }\n    else\n    {\n\n        long long ttime = date_string_to_time(datetime);\n        long long reftime = date_string_to_time(refdate);\n\n        //double diff = difftime(ttime, reftime);\n\n        //std::chrono::microseconds timeDiff = ttime - reftime;\n\n        //double diff = ((double) duration_cast&lt;std::chrono::milliseconds&gt;(ttime - reftime).count())/1000.0;\n\n        diff = (double)(ttime - reftime);\n    }\n\n    return diff;\n}\n\n// Read time string. If it is a valid datetime string return s from reftime otherwise return a foat of seconds \ndouble readinputtimetxt(std::string input, std::string &amp; refdate)\n{\n    std::string date = trim(input, \" \");\n    double timeinsec;\n    //check if string contains a T a marker of \n    std::vector&lt;std::string&gt;  datetime = split(date, 'T');\n\n    if (datetime.size() &gt; 1)\n    {\n        //likely a datetime\n        if (refdate.empty())\n        {\n            refdate = date;\n        }\n        timeinsec = date_string_to_s(date, refdate);\n\n\n    }\n    else\n    {\n        //Likely a float\n        timeinsec = std::stod(datetime[0]);\n    }\n\n    return timeinsec;\n}\n\n\nbool testime1(int hour)\n{\n    bool test = false;\n    double eps = 1e-7;\n\n    for (int iy = 1400; iy &lt;= 2800; iy++)\n    {\n        tm tm1, tm2;\n\n        tm1.tm_year = iy;\n        tm2.tm_year = iy;\n\n        tm1.tm_mday = 1;\n        tm2.tm_mday = 1;\n\n        tm1.tm_mon = 0;\n        tm2.tm_mon = 0;\n\n        tm1.tm_hour = 0;\n        tm2.tm_hour = hour;\n\n        tm1.tm_min = 0;\n        tm2.tm_min = 0;\n\n        tm1.tm_sec = 0;\n        tm2.tm_sec = 0;\n\n        //UTCTime t1 = UTCClock::fromDate(iy, 1, 1, 0, 0, 0, 0);\n        //UTCTime t2 = UTCClock::fromDate(iy, 1, 1, hour, 0, 0, 0);\n\n        long long t1 = timegm(&amp;tm1);\n        long long t2 = timegm(&amp;tm2);\n\n\n\n\n        //double dt12 = ((double)duration_cast&lt;std::chrono::milliseconds&gt;(t2 - t1).count()) / 1000.0;\n        double dt12 = (double)(t2 - t1);\n        test = abs(dt12 - (hour * 3600.0)) &lt; eps;\n        if (!test)\n        {\n            printf(\"Failed datetime calculation: year=%d\\n\", iy);\n            break;\n        }\n    }\n\n\n    return test;\n}\nbool testime2(int hour)\n{\n    bool test = false;\n\n\n    for (int iy = 1970; iy &lt;= 2400; iy++)\n    {\n        //UTCTime t1 = UTCClock::fromDate(1970, 1, 1, 0, 0, 0, 0);\n        //UTCTime t2 = UTCClock::fromDate(iy, 1, 1, hour, 0, 0, 0);\n        tm tm1, tm2;\n\n        tm1.tm_year = 1970;\n        tm2.tm_year = iy;\n\n        tm1.tm_mday = 1;\n        tm2.tm_mday = 1;\n\n        tm1.tm_mon = 0;\n        tm2.tm_mon = 0;\n\n        tm1.tm_hour = 0;\n        tm2.tm_hour = hour;\n\n        tm1.tm_min = 0;\n        tm2.tm_min = 0;\n\n        tm1.tm_sec = 0;\n        tm2.tm_sec = 0;\n\n        //UTCTime t1 = UTCClock::fromDate(iy, 1, 1, 0, 0, 0, 0);\n        //UTCTime t2 = UTCClock::fromDate(iy, 1, 1, hour, 0, 0, 0);\n\n        long long t1 = timegm(&amp;tm1);\n        long long t2 = timegm(&amp;tm2);\n\n\n\n        //double dt12 = ((double)duration_cast&lt;std::chrono::milliseconds&gt;(t2 - t1).count()) / 1000.0;\n\n        test = t2&gt;t1;\n        if (!test)\n        {\n\n            int dse = days_from_epoch(tm2.tm_year, tm2.tm_mon + 1, tm2.tm_mday);\n            printf(\"Failed datetime calculation greater than: year=%d\\n\", iy);\n            printf(\"dse=%d\\nt1 = %lld;\\n t2=%lld\\n\",dse, t1, t2);\n            break;\n        }\n    }\n\n\n    return test;\n}\n</code></pre>"},{"location":"BGFlood/utctime_8h/","title":"File utctime.h","text":""},{"location":"BGFlood/utctime_8h/#file-utctimeh","title":"File utctime.h","text":"<p>FileList &gt; src &gt; utctime.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"ReadInput.h\"</code></li> </ul>"},{"location":"BGFlood/utctime_8h/#public-functions","title":"Public Functions","text":"Type Name double date_string_to_s (std::string datetime, std::string refdate)  long long date_string_to_time (std::string date)  double readinputtimetxt (std::string input, std::string &amp; refdate)  bool testime1 (int hour)  bool testime2 (int hour)"},{"location":"BGFlood/utctime_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/utctime_8h/#function-date_string_to_s","title":"function date_string_to_s","text":"<pre><code>double date_string_to_s (\n    std::string datetime,\n    std::string refdate\n) \n</code></pre>"},{"location":"BGFlood/utctime_8h/#function-date_string_to_time","title":"function date_string_to_time","text":"<pre><code>long long date_string_to_time (\n    std::string date\n) \n</code></pre>"},{"location":"BGFlood/utctime_8h/#function-readinputtimetxt","title":"function readinputtimetxt","text":"<pre><code>double readinputtimetxt (\n    std::string input,\n    std::string &amp; refdate\n) \n</code></pre>"},{"location":"BGFlood/utctime_8h/#function-testime1","title":"function testime1","text":"<pre><code>bool testime1 (\n    int hour\n) \n</code></pre>"},{"location":"BGFlood/utctime_8h/#function-testime2","title":"function testime2","text":"<pre><code>bool testime2 (\n    int hour\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/utctime.h</code></p>"},{"location":"BGFlood/utctime_8h_source/","title":"File utctime.h","text":""},{"location":"BGFlood/utctime_8h_source/#file-utctimeh","title":"File utctime.h","text":"<p>File List &gt; src &gt; utctime.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef UTCTIME_H\n#define UTCTIME_H\n\n#include \"General.h\"\n#include \"ReadInput.h\"\n/*\nstruct UTCClock\n{\n    typedef std::chrono::microseconds duration;\n    typedef duration::rep rep;\n    typedef duration::period period;\n    typedef std::chrono::time_point&lt;UTCClock, duration&gt; time_point;\n    static const bool is_steady = true;\n\n    //      \n    // every time_point will be generated from here\n    //\n    static time_point fromDate(int year = 0, int month = 0, int day = 0,\n        int hour = 0, int min = 0, int sec = 0,\n        int usec = 0);\n    //\n    // convert time_point to a date/time representation\n    //\n    static void toDate(const time_point&amp; tp,\n        int&amp; year, int&amp; month, int&amp; day,\n        int&amp; hour, int&amp; min, int&amp; sec,\n        int&amp; usec);\n\n    // NOT Supported, we don't need current time. We only\n    // want to represent UTC DateTime\n    // static time_point now(); \n};\n*/\n//using UTCTime = std::chrono::time_point&lt;UTCClock, std::chrono::microseconds&gt;;\n\nlong long date_string_to_time(std::string date);\ndouble date_string_to_s(std::string datetime, std::string refdate);\ndouble readinputtimetxt(std::string input, std::string &amp; refdate);\nbool testime1(int hour);\nbool testime2(int hour);\n\n#endif\n</code></pre>"},{"location":"BGFlood/namespaces/","title":"List","text":""},{"location":"BGFlood/namespaces/#namespace-list","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace utils </li> </ul>"},{"location":"BGFlood/classes/","title":"Index","text":""},{"location":"BGFlood/classes/#class-index","title":"Class Index","text":""},{"location":"BGFlood/classes/#a","title":"a","text":"<ul> <li>AdaptP</li> <li>AdvanceP</li> <li>AOIinfo</li> </ul>"},{"location":"BGFlood/classes/#b","title":"b","text":"<ul> <li>BlockP</li> <li>BndblockP</li> <li>bndparam</li> <li>bndsegment</li> <li>bndsegmentside</li> <li>bndTexP</li> </ul>"},{"location":"BGFlood/classes/#d","title":"d","text":"<ul> <li>deformmap</li> <li>DynForcingP</li> </ul>"},{"location":"BGFlood/classes/#e","title":"e","text":"<ul> <li>EvolvingMLP</li> <li>EvolvingP</li> <li>EvolvingP_M</li> </ul>"},{"location":"BGFlood/classes/#f","title":"f","text":"<ul> <li>Flowin</li> <li>FluxMLP</li> <li>FluxP</li> <li>Forcing</li> <li>forcingmap</li> </ul>"},{"location":"BGFlood/classes/#g","title":"g","text":"<ul> <li>GradientsMLP</li> <li>GradientsP</li> </ul>"},{"location":"BGFlood/classes/#i","title":"i","text":"<ul> <li>inputmap</li> </ul>"},{"location":"BGFlood/classes/#l","title":"l","text":"<ul> <li>Loop</li> </ul>"},{"location":"BGFlood/classes/#m","title":"m","text":"<ul> <li>Mapparam</li> <li>maskinfo</li> <li>Model</li> </ul>"},{"location":"BGFlood/classes/#o","title":"o","text":"<ul> <li>outP</li> <li>outzoneB</li> <li>outzoneP</li> </ul>"},{"location":"BGFlood/classes/#p","title":"p","text":"<ul> <li>Param</li> <li>Pointout</li> <li>Polygon</li> </ul>"},{"location":"BGFlood/classes/#r","title":"r","text":"<ul> <li>River</li> <li>RiverBlk</li> <li>RiverInfo</li> </ul>"},{"location":"BGFlood/classes/#s","title":"s","text":"<ul> <li>SharedMemory</li> <li>SharedMemory&lt; double &gt;</li> <li>SLTS</li> <li>StaticForcingP</li> </ul>"},{"location":"BGFlood/classes/#t","title":"t","text":"<ul> <li>T_output</li> <li>TexSetP</li> <li>TimeP</li> <li>TSoutnode</li> </ul>"},{"location":"BGFlood/classes/#v","title":"v","text":"<ul> <li>Vertex</li> </ul>"},{"location":"BGFlood/classes/#w","title":"w","text":"<ul> <li>Windin</li> </ul>"},{"location":"BGFlood/hierarchy/","title":"Hierarchy","text":""},{"location":"BGFlood/hierarchy/#class-hierarchy","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class AOIinfo </li> <li>class Flowin </li> <li>class Mapparam </li> <li>class Param </li> <li>class Pointout </li> <li>class Polygon </li> <li>class River </li> <li>class SLTS </li> <li>class TSoutnode </li> <li>class T_output </li> <li>class Vertex </li> <li>class Windin </li> <li>class bndparam </li> <li>class bndsegment </li> <li>class bndsegmentside </li> <li>class inputmap <ul> <li>struct StaticForcingP </li> <li>class deformmap </li> <li>class forcingmap <ul> <li>struct DynForcingP </li> <li>struct DynForcingP </li> </ul> </li> </ul> </li> <li>class outzoneP </li> <li>struct AdaptP </li> <li>struct AdvanceP </li> <li>struct BlockP </li> <li>struct BndblockP </li> <li>struct EvolvingMLP </li> <li>struct EvolvingP <ul> <li>struct EvolvingP_M </li> </ul> </li> <li>struct FluxMLP </li> <li>struct FluxP </li> <li>struct Forcing </li> <li>struct GradientsMLP </li> <li>struct GradientsP </li> <li>struct Loop </li> <li>struct Model </li> <li>struct RiverBlk </li> <li>struct RiverInfo </li> <li>struct SharedMemory </li> <li>struct SharedMemory&lt; double &gt; </li> <li>struct TexSetP </li> <li>struct TimeP </li> <li>struct bndTexP </li> <li>struct maskinfo </li> <li>struct outP </li> <li>struct outzoneB </li> </ul>"},{"location":"BGFlood/modules/","title":"Modules","text":""},{"location":"BGFlood/modules/#modules","title":"Modules","text":"<p>No modules found.</p>"},{"location":"BGFlood/pages/","title":"Related Pages","text":""},{"location":"BGFlood/pages/#related-pages","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"BGFlood/class_members/","title":"Members","text":""},{"location":"BGFlood/class_members/#class-members","title":"Class Members","text":""},{"location":"BGFlood/class_members/#a","title":"a","text":"<ul> <li>active (AOIinfo, BlockP)</li> <li>availblk (AdaptP)</li> <li>activeCell (BlockP)</li> <li>after (DynForcingP)</li> <li>after_g (DynForcingP)</li> <li>AOI (Forcing)</li> <li>Atmp (Forcing)</li> <li>atmpstep (Loop)</li> <li>atmpuni (Loop)</li> <li>atmpuniform (Loop)</li> <li>adapt (Model)</li> <li>adv (Model)</li> <li>AdaptCrit (Param)</li> <li>AdaptCrit_funct_pointer (Param)</li> <li>Adapt_arg1 (Param)</li> <li>Adapt_arg2 (Param)</li> <li>Adapt_arg3 (Param)</li> <li>Adapt_arg4 (Param)</li> <li>Adapt_arg5 (Param)</li> <li>adaptmaxiteration (Param)</li> <li>addoffset (Param)</li> <li>aoibnd (Param)</li> <li>atmpforcing (Param)</li> <li>arrmax (TimeP)</li> <li>arrmin (TimeP)</li> </ul>"},{"location":"BGFlood/class_members/#b","title":"b","text":"<ul> <li>BotLeft (BlockP)</li> <li>BotRight (BlockP)</li> <li>bot (BndblockP, Forcing, bndsegment)</li> <li>before (DynForcingP)</li> <li>before_g (DynForcingP)</li> <li>Bathy (Forcing)</li> <li>bndseg (Forcing)</li> <li>blockDim (Loop)</li> <li>blocks (Model)</li> <li>bndblk (Model)</li> <li>blkmemwidth (Param)</li> <li>blksize (Param)</li> <li>blkwidth (Param)</li> <li>bndfiltertime (Param)</li> <li>bndrelaxtime (Param)</li> <li>bndtaper (Param)</li> <li>botbnd (Param)</li> <li>block (River, RiverBlk, TSoutnode)</li> <li>blks (bndparam, maskinfo)</li> <li>blks_g (bndparam)</li> <li>blk (bndsegmentside, outzoneB)</li> <li>blk_g (bndsegmentside)</li> </ul>"},{"location":"BGFlood/class_members/#c","title":"c","text":"<ul> <li>coarsen (AdaptP)</li> <li>csumblk (AdaptP)</li> <li>clampedge (DynForcingP, deformmap)</li> <li>cf (Forcing, Model, Param)</li> <li>cl (Forcing, Model, Param)</li> <li>CFL (Param)</li> <li>Cd (Param)</li> <li>conserveElevation (Param)</li> <li>crs_ref (Param)</li> <li>CudArr (TexSetP)</li> <li>channelDesc (TexSetP)</li> </ul>"},{"location":"BGFlood/class_members/#d","title":"d","text":"<ul> <li>dh (AdvanceP)</li> <li>dhu (AdvanceP)</li> <li>dhv (AdvanceP)</li> <li>deform (Forcing)</li> <li>dhdx (GradientsMLP, GradientsP)</li> <li>dhdy (GradientsMLP, GradientsP)</li> <li>dudx (GradientsMLP, GradientsP)</li> <li>dudy (GradientsMLP, GradientsP)</li> <li>dvdx (GradientsMLP, GradientsP)</li> <li>dvdy (GradientsMLP, GradientsP)</li> <li>dzbdx (GradientsP)</li> <li>dzbdy (GradientsP)</li> <li>dzsdx (GradientsP)</li> <li>dzsdy (GradientsP)</li> <li>dt (Loop, Param, TimeP, forcingmap)</li> <li>dtmax (Loop, TimeP)</li> <li>datmpdx (Model)</li> <li>datmpdy (Model)</li> <li>deformmaxtime (Param)</li> <li>delta (Param)</li> <li>doubleprecision (Param)</li> <li>dtinit (Param)</li> <li>dtmin (Param)</li> <li>dx (Param, TexSetP, inputmap)</li> <li>disarea (River)</li> <li>dy (TexSetP, inputmap)</li> <li>data (bndparam, bndsegment)</li> <li>duration (deformmap)</li> <li>denanval (inputmap)</li> </ul>"},{"location":"BGFlood/class_members/#e","title":"e","text":"<ul> <li>epsilon (Loop)</li> <li>evmax (Model)</li> <li>evmean (Model)</li> <li>evolv (Model)</li> <li>evolv_o (Model)</li> <li>endcputime (Param)</li> <li>endtime (Param)</li> <li>engine (Param)</li> <li>eps (Param)</li> <li>end (T_output)</li> <li>extension (inputmap)</li> </ul>"},{"location":"BGFlood/class_members/#f","title":"f","text":"<ul> <li>file (AOIinfo)</li> <li>Fux (FluxMLP)</li> <li>Fuy (FluxMLP)</li> <li>Fvx (FluxMLP)</li> <li>Fvy (FluxMLP)</li> <li>Fhu (FluxP)</li> <li>Fhv (FluxP)</li> <li>Fqux (FluxP)</li> <li>Fquy (FluxP)</li> <li>Fqvx (FluxP)</li> <li>Fqvy (FluxP)</li> <li>flux (Model)</li> <li>fluxml (Model)</li> <li>ForceMassConserve (Param)</li> <li>frictionmodel (Param)</li> <li>flowinput (River)</li> <li>flipxx (inputmap)</li> <li>flipyy (inputmap)</li> </ul>"},{"location":"BGFlood/class_members/#g","title":"g","text":"<ul> <li>gridDim (Loop)</li> <li>grad (Model)</li> <li>GPUDEVICE (Param)</li> <li>GPU_initmem_byte (Param)</li> <li>GPU_totalmem_byte (Param)</li> <li>g (Param)</li> <li>grdalpha (Param, inputmap)</li> <li>GPU (bndparam, deformmap, forcingmap)</li> </ul>"},{"location":"BGFlood/class_members/#h","title":"h","text":"<ul> <li>h (EvolvingMLP, EvolvingP, Pointout)</li> <li>hU (EvolvingP_M)</li> <li>hau (FluxMLP)</li> <li>hav (FluxMLP)</li> <li>hfu (FluxMLP)</li> <li>hfv (FluxMLP)</li> <li>hu (FluxMLP)</li> <li>hv (FluxMLP)</li> <li>hugenegval (Loop)</li> <li>hugeposval (Loop)</li> <li>hgw (Model)</li> <li>halowidth (Param)</li> <li>hotstartfile (Param)</li> <li>hotstep (Param)</li> </ul>"},{"location":"BGFlood/class_members/#i","title":"i","text":"<ul> <li>invactive (AdaptP)</li> <li>il (Forcing, Model, Param)</li> <li>indNextoutputtime (Loop)</li> <li>infiltration (Param)</li> <li>initlevel (Param)</li> <li>inittime (Param)</li> <li>i (River, TSoutnode)</li> <li>init (T_output)</li> <li>inputstr (T_output)</li> <li>inputfile (bndparam, bndsegment, forcingmap, inputmap)</li> <li>isright (bndparam, bndsegmentside)</li> <li>istop (bndparam, bndsegmentside)</li> <li>iscavity (deformmap)</li> <li>instep (forcingmap)</li> <li>index_next_OutputT (outzoneB)</li> </ul>"},{"location":"BGFlood/class_members/#j","title":"j","text":"<ul> <li>j (River, TSoutnode)</li> </ul>"},{"location":"BGFlood/class_members/#l","title":"l","text":"<ul> <li>LeftBot (BlockP)</li> <li>LeftTop (BlockP)</li> <li>level (BlockP, outP)</li> <li>left (BndblockP, Forcing, bndsegment)</li> <li>lat (Param)</li> <li>leftbnd (Param)</li> </ul>"},{"location":"BGFlood/class_members/#m","title":"m","text":"<ul> <li>mask (BlockP, Param)</li> <li>maxTSstorage (Param)</li> <li>maxlevel (Param, outzoneB)</li> <li>membuffer (Param)</li> <li>minlevel (Param, outzoneB)</li> </ul>"},{"location":"BGFlood/class_members/#n","title":"n","text":"<ul> <li>newlevel (AdaptP)</li> <li>nblkTs (BndblockP)</li> <li>nblkriver (BndblockP, Param)</li> <li>nbndblkbot (BndblockP, Param)</li> <li>nbndblkleft (BndblockP, Param)</li> <li>nbndblkright (BndblockP, Param)</li> <li>nbndblktop (BndblockP, Param)</li> <li>now (DynForcingP)</li> <li>now_g (DynForcingP)</li> <li>nTSsteps (Loop)</li> <li>nextoutputtime (Loop)</li> <li>nstep (Loop)</li> <li>nstepout (Loop)</li> <li>num_streams (Loop)</li> <li>navailblk (Param)</li> <li>nblk (Param, bndparam, bndsegment, bndsegmentside, maskinfo, outzoneB)</li> <li>nblkmem (Param)</li> <li>nmaskblk (Param)</li> <li>nrivers (Param)</li> <li>nx (Param, inputmap)</li> <li>ny (Param, inputmap)</li> <li>nbir (RiverInfo)</li> <li>nburmax (RiverInfo)</li> <li>nribmax (RiverInfo)</li> <li>nowvalue (TexSetP, forcingmap)</li> <li>nbnd (bndparam, bndsegment)</li> <li>nt (forcingmap)</li> </ul>"},{"location":"BGFlood/class_members/#o","title":"o","text":"<ul> <li>outZone (BlockP)</li> <li>OutputT (Model, outzoneB)</li> <li>OutputVarMap (Model)</li> <li>Outvarlongname (Model)</li> <li>Outvarstdname (Model)</li> <li>Outvarunits (Model)</li> <li>outfile (Param)</li> <li>outishift (Param)</li> <li>outjshift (Param)</li> <li>outmax (Param)</li> <li>outmean (Param)</li> <li>outputtimestep (Param)</li> <li>outtwet (Param)</li> <li>outvars (Param)</li> <li>outzone (Param)</li> <li>operator T* (SharedMemory)</li> <li>operator const T * (SharedMemory)</li> <li>operator const double * (SharedMemory&lt; double &gt;)</li> <li>operator double * (SharedMemory&lt; double &gt;)</li> <li>outname (TSoutnode, outzoneB, outzoneP)</li> <li>on (bndparam, bndsegment)</li> </ul>"},{"location":"BGFlood/class_members/#p","title":"p","text":"<ul> <li>poly (AOIinfo, bndsegment)</li> <li>Patm (Model)</li> <li>Pa2m (Param)</li> <li>Paref (Param)</li> <li>posdown (Param)</li> <li>polyfile (bndsegment)</li> </ul>"},{"location":"BGFlood/class_members/#q","title":"q","text":"<ul> <li>q (Flowin)</li> <li>qnow (RiverInfo)</li> <li>qnow_g (RiverInfo)</li> <li>qmean (bndparam, bndsegmentside)</li> <li>qmean_g (bndparam, bndsegmentside)</li> </ul>"},{"location":"BGFlood/class_members/#r","title":"r","text":"<ul> <li>refine (AdaptP)</li> <li>RightBot (BlockP)</li> <li>RightTop (BlockP)</li> <li>Riverinfo (BndblockP)</li> <li>right (BndblockP, Forcing, bndsegment)</li> <li>river (BndblockP)</li> <li>Rain (Forcing)</li> <li>rivers (Forcing)</li> <li>rainstep (Loop)</li> <li>rainuni (Loop)</li> <li>rainuniform (Loop)</li> <li>Radius (Param)</li> <li>rainbnd (Param)</li> <li>rainforcing (Param)</li> <li>reftime (Param)</li> <li>resetmax (Param)</li> <li>rho (Param)</li> <li>rightbnd (Param)</li> <li>Riverflowfile (River)</li> <li>resDesc (TexSetP)</li> </ul>"},{"location":"BGFlood/class_members/#s","title":"s","text":"<ul> <li>Su (FluxP)</li> <li>Sv (FluxP)</li> <li>streams (Loop)</li> <li>savebyblk (Param)</li> <li>scalefactor (Param)</li> <li>setupcputime (Param)</li> <li>smallnc (Param)</li> <li>spherical (Param)</li> <li>startcputime (Param)</li> <li>side (bndparam, maskinfo)</li> <li>startime (deformmap)</li> </ul>"},{"location":"BGFlood/class_members/#t","title":"t","text":"<ul> <li>TopLeft (BlockP)</li> <li>TopRight (BlockP)</li> <li>Tsout (BndblockP)</li> <li>top (BndblockP, Forcing, bndsegment)</li> <li>time (Flowin, Model, Pointout, SLTS, Windin)</li> <li>targetadapt (Forcing)</li> <li>TSAllout (Loop)</li> <li>totaltime (Loop, Param, TimeP)</li> <li>TSstore (Model)</li> <li>TSnodesout (Param)</li> <li>Toutput (Param, outzoneP)</li> <li>test (Param)</li> <li>theta (Param)</li> <li>topbnd (Param)</li> <li>tmax (River, forcingmap)</li> <li>to (River, forcingmap)</li> <li>tstep (T_output)</li> <li>tex (TexSetP)</li> <li>texDesc (TexSetP)</li> <li>type (bndparam, bndsegment, maskinfo)</li> </ul>"},{"location":"BGFlood/class_members/#u","title":"u","text":"<ul> <li>u (EvolvingMLP, EvolvingP, Pointout)</li> <li>U (EvolvingP_M)</li> <li>UWind (Forcing)</li> <li>uwinduni (Loop)</li> <li>uuvel (SLTS)</li> <li>uniform (TexSetP, bndsegment, forcingmap)</li> <li>uwind (Windin)</li> <li>Uvel (bndTexP)</li> <li>unidata (forcingmap)</li> </ul>"},{"location":"BGFlood/class_members/#v","title":"v","text":"<ul> <li>val (DynForcingP, StaticForcingP, T_output, deformmap)</li> <li>v (EvolvingMLP, EvolvingP, Pointout)</li> <li>VWind (Forcing)</li> <li>vwinduni (Loop)</li> <li>VelThreshold (Param)</li> <li>vertices (Polygon)</li> <li>vvvel (SLTS)</li> <li>vwind (Windin)</li> <li>Vvel (bndTexP)</li> <li>varname (inputmap)</li> </ul>"},{"location":"BGFlood/class_members/#w","title":"w","text":"<ul> <li>windstep (Loop)</li> <li>winduniform (Loop)</li> <li>wettime (Model)</li> <li>wet_threshold (Param)</li> <li>wetdryfix (Param)</li> <li>windforcing (Param)</li> <li>wlevs (SLTS)</li> <li>wdirection (Windin)</li> <li>wspeed (Windin)</li> <li>WLS (bndTexP)</li> <li>WLmap (bndsegment)</li> </ul>"},{"location":"BGFlood/class_members/#x","title":"x","text":"<ul> <li>xo (BlockP, Param, TexSetP, inputmap, outzoneB)</li> <li>xmax (Param, Polygon, inputmap, outP, outzoneB)</li> <li>xmin (Polygon, outP)</li> <li>xend (River, RiverInfo, outzoneP)</li> <li>xstart (River, RiverInfo, outzoneP)</li> <li>Xbidir (RiverInfo)</li> <li>Xridib (RiverInfo)</li> <li>x (TSoutnode, Vertex)</li> </ul>"},{"location":"BGFlood/class_members/#y","title":"y","text":"<ul> <li>yo (BlockP, Param, TexSetP, inputmap, outzoneB)</li> <li>ymax (Param, Polygon, inputmap, outP, outzoneB)</li> <li>ymin (Polygon, outP)</li> <li>yend (River, RiverInfo, outzoneP)</li> <li>ystart (River, RiverInfo, outzoneP)</li> <li>y (TSoutnode, Vertex)</li> </ul>"},{"location":"BGFlood/class_members/#z","title":"z","text":"<ul> <li>zs (EvolvingP, Pointout)</li> <li>zb (Model)</li> <li>zsinit (Param)</li> <li>zsoffset (Param)</li> <li>z (outP)</li> <li>z_s (outP)</li> </ul>"},{"location":"BGFlood/class_member_functions/","title":"Member Functions","text":""},{"location":"BGFlood/class_member_functions/#class-member-functions","title":"Class Member Functions","text":""},{"location":"BGFlood/class_member_functions/#o","title":"o","text":"<ul> <li>operator T* (SharedMemory)</li> <li>operator const T * (SharedMemory)</li> <li>operator const double * (SharedMemory&lt; double &gt;)</li> <li>operator double * (SharedMemory&lt; double &gt;)</li> </ul>"},{"location":"BGFlood/class_member_variables/","title":"Member Variables","text":""},{"location":"BGFlood/class_member_variables/#class-member-variables","title":"Class Member Variables","text":""},{"location":"BGFlood/class_member_variables/#a","title":"a","text":"<ul> <li>active (AOIinfo, BlockP)</li> <li>availblk (AdaptP)</li> <li>activeCell (BlockP)</li> <li>after (DynForcingP)</li> <li>after_g (DynForcingP)</li> <li>AOI (Forcing)</li> <li>Atmp (Forcing)</li> <li>atmpstep (Loop)</li> <li>atmpuni (Loop)</li> <li>atmpuniform (Loop)</li> <li>adapt (Model)</li> <li>adv (Model)</li> <li>AdaptCrit (Param)</li> <li>AdaptCrit_funct_pointer (Param)</li> <li>Adapt_arg1 (Param)</li> <li>Adapt_arg2 (Param)</li> <li>Adapt_arg3 (Param)</li> <li>Adapt_arg4 (Param)</li> <li>Adapt_arg5 (Param)</li> <li>adaptmaxiteration (Param)</li> <li>addoffset (Param)</li> <li>aoibnd (Param)</li> <li>atmpforcing (Param)</li> <li>arrmax (TimeP)</li> <li>arrmin (TimeP)</li> </ul>"},{"location":"BGFlood/class_member_variables/#b","title":"b","text":"<ul> <li>BotLeft (BlockP)</li> <li>BotRight (BlockP)</li> <li>bot (BndblockP, Forcing, bndsegment)</li> <li>before (DynForcingP)</li> <li>before_g (DynForcingP)</li> <li>Bathy (Forcing)</li> <li>bndseg (Forcing)</li> <li>blockDim (Loop)</li> <li>blocks (Model)</li> <li>bndblk (Model)</li> <li>blkmemwidth (Param)</li> <li>blksize (Param)</li> <li>blkwidth (Param)</li> <li>bndfiltertime (Param)</li> <li>bndrelaxtime (Param)</li> <li>bndtaper (Param)</li> <li>botbnd (Param)</li> <li>block (River, RiverBlk, TSoutnode)</li> <li>blks (bndparam, maskinfo)</li> <li>blks_g (bndparam)</li> <li>blk (bndsegmentside, outzoneB)</li> <li>blk_g (bndsegmentside)</li> </ul>"},{"location":"BGFlood/class_member_variables/#c","title":"c","text":"<ul> <li>coarsen (AdaptP)</li> <li>csumblk (AdaptP)</li> <li>clampedge (DynForcingP, deformmap)</li> <li>cf (Forcing, Model, Param)</li> <li>cl (Forcing, Model, Param)</li> <li>CFL (Param)</li> <li>Cd (Param)</li> <li>conserveElevation (Param)</li> <li>crs_ref (Param)</li> <li>CudArr (TexSetP)</li> <li>channelDesc (TexSetP)</li> </ul>"},{"location":"BGFlood/class_member_variables/#d","title":"d","text":"<ul> <li>dh (AdvanceP)</li> <li>dhu (AdvanceP)</li> <li>dhv (AdvanceP)</li> <li>deform (Forcing)</li> <li>dhdx (GradientsMLP, GradientsP)</li> <li>dhdy (GradientsMLP, GradientsP)</li> <li>dudx (GradientsMLP, GradientsP)</li> <li>dudy (GradientsMLP, GradientsP)</li> <li>dvdx (GradientsMLP, GradientsP)</li> <li>dvdy (GradientsMLP, GradientsP)</li> <li>dzbdx (GradientsP)</li> <li>dzbdy (GradientsP)</li> <li>dzsdx (GradientsP)</li> <li>dzsdy (GradientsP)</li> <li>dt (Loop, Param, TimeP, forcingmap)</li> <li>dtmax (Loop, TimeP)</li> <li>datmpdx (Model)</li> <li>datmpdy (Model)</li> <li>deformmaxtime (Param)</li> <li>delta (Param)</li> <li>doubleprecision (Param)</li> <li>dtinit (Param)</li> <li>dtmin (Param)</li> <li>dx (Param, TexSetP, inputmap)</li> <li>disarea (River)</li> <li>dy (TexSetP, inputmap)</li> <li>data (bndparam, bndsegment)</li> <li>duration (deformmap)</li> <li>denanval (inputmap)</li> </ul>"},{"location":"BGFlood/class_member_variables/#e","title":"e","text":"<ul> <li>epsilon (Loop)</li> <li>evmax (Model)</li> <li>evmean (Model)</li> <li>evolv (Model)</li> <li>evolv_o (Model)</li> <li>endcputime (Param)</li> <li>endtime (Param)</li> <li>engine (Param)</li> <li>eps (Param)</li> <li>end (T_output)</li> <li>extension (inputmap)</li> </ul>"},{"location":"BGFlood/class_member_variables/#f","title":"f","text":"<ul> <li>file (AOIinfo)</li> <li>Fux (FluxMLP)</li> <li>Fuy (FluxMLP)</li> <li>Fvx (FluxMLP)</li> <li>Fvy (FluxMLP)</li> <li>Fhu (FluxP)</li> <li>Fhv (FluxP)</li> <li>Fqux (FluxP)</li> <li>Fquy (FluxP)</li> <li>Fqvx (FluxP)</li> <li>Fqvy (FluxP)</li> <li>flux (Model)</li> <li>fluxml (Model)</li> <li>ForceMassConserve (Param)</li> <li>frictionmodel (Param)</li> <li>flowinput (River)</li> <li>flipxx (inputmap)</li> <li>flipyy (inputmap)</li> </ul>"},{"location":"BGFlood/class_member_variables/#g","title":"g","text":"<ul> <li>gridDim (Loop)</li> <li>grad (Model)</li> <li>GPUDEVICE (Param)</li> <li>GPU_initmem_byte (Param)</li> <li>GPU_totalmem_byte (Param)</li> <li>g (Param)</li> <li>grdalpha (Param, inputmap)</li> <li>GPU (bndparam, deformmap, forcingmap)</li> </ul>"},{"location":"BGFlood/class_member_variables/#h","title":"h","text":"<ul> <li>h (EvolvingMLP, EvolvingP, Pointout)</li> <li>hU (EvolvingP_M)</li> <li>hau (FluxMLP)</li> <li>hav (FluxMLP)</li> <li>hfu (FluxMLP)</li> <li>hfv (FluxMLP)</li> <li>hu (FluxMLP)</li> <li>hv (FluxMLP)</li> <li>hugenegval (Loop)</li> <li>hugeposval (Loop)</li> <li>hgw (Model)</li> <li>halowidth (Param)</li> <li>hotstartfile (Param)</li> <li>hotstep (Param)</li> </ul>"},{"location":"BGFlood/class_member_variables/#i","title":"i","text":"<ul> <li>invactive (AdaptP)</li> <li>il (Forcing, Model, Param)</li> <li>indNextoutputtime (Loop)</li> <li>infiltration (Param)</li> <li>initlevel (Param)</li> <li>inittime (Param)</li> <li>i (River, TSoutnode)</li> <li>init (T_output)</li> <li>inputstr (T_output)</li> <li>inputfile (bndparam, bndsegment, forcingmap, inputmap)</li> <li>isright (bndparam, bndsegmentside)</li> <li>istop (bndparam, bndsegmentside)</li> <li>iscavity (deformmap)</li> <li>instep (forcingmap)</li> <li>index_next_OutputT (outzoneB)</li> </ul>"},{"location":"BGFlood/class_member_variables/#j","title":"j","text":"<ul> <li>j (River, TSoutnode)</li> </ul>"},{"location":"BGFlood/class_member_variables/#l","title":"l","text":"<ul> <li>LeftBot (BlockP)</li> <li>LeftTop (BlockP)</li> <li>level (BlockP, outP)</li> <li>left (BndblockP, Forcing, bndsegment)</li> <li>lat (Param)</li> <li>leftbnd (Param)</li> </ul>"},{"location":"BGFlood/class_member_variables/#m","title":"m","text":"<ul> <li>mask (BlockP, Param)</li> <li>maxTSstorage (Param)</li> <li>maxlevel (Param, outzoneB)</li> <li>membuffer (Param)</li> <li>minlevel (Param, outzoneB)</li> </ul>"},{"location":"BGFlood/class_member_variables/#n","title":"n","text":"<ul> <li>newlevel (AdaptP)</li> <li>nblkTs (BndblockP)</li> <li>nblkriver (BndblockP, Param)</li> <li>nbndblkbot (BndblockP, Param)</li> <li>nbndblkleft (BndblockP, Param)</li> <li>nbndblkright (BndblockP, Param)</li> <li>nbndblktop (BndblockP, Param)</li> <li>now (DynForcingP)</li> <li>now_g (DynForcingP)</li> <li>nTSsteps (Loop)</li> <li>nextoutputtime (Loop)</li> <li>nstep (Loop)</li> <li>nstepout (Loop)</li> <li>num_streams (Loop)</li> <li>navailblk (Param)</li> <li>nblk (Param, bndparam, bndsegment, bndsegmentside, maskinfo, outzoneB)</li> <li>nblkmem (Param)</li> <li>nmaskblk (Param)</li> <li>nrivers (Param)</li> <li>nx (Param, inputmap)</li> <li>ny (Param, inputmap)</li> <li>nbir (RiverInfo)</li> <li>nburmax (RiverInfo)</li> <li>nribmax (RiverInfo)</li> <li>nowvalue (TexSetP, forcingmap)</li> <li>nbnd (bndparam, bndsegment)</li> <li>nt (forcingmap)</li> </ul>"},{"location":"BGFlood/class_member_variables/#o","title":"o","text":"<ul> <li>outZone (BlockP)</li> <li>OutputT (Model, outzoneB)</li> <li>OutputVarMap (Model)</li> <li>Outvarlongname (Model)</li> <li>Outvarstdname (Model)</li> <li>Outvarunits (Model)</li> <li>outfile (Param)</li> <li>outishift (Param)</li> <li>outjshift (Param)</li> <li>outmax (Param)</li> <li>outmean (Param)</li> <li>outputtimestep (Param)</li> <li>outtwet (Param)</li> <li>outvars (Param)</li> <li>outzone (Param)</li> <li>outname (TSoutnode, outzoneB, outzoneP)</li> <li>on (bndparam, bndsegment)</li> </ul>"},{"location":"BGFlood/class_member_variables/#p","title":"p","text":"<ul> <li>poly (AOIinfo, bndsegment)</li> <li>Patm (Model)</li> <li>Pa2m (Param)</li> <li>Paref (Param)</li> <li>posdown (Param)</li> <li>polyfile (bndsegment)</li> </ul>"},{"location":"BGFlood/class_member_variables/#q","title":"q","text":"<ul> <li>q (Flowin)</li> <li>qnow (RiverInfo)</li> <li>qnow_g (RiverInfo)</li> <li>qmean (bndparam, bndsegmentside)</li> <li>qmean_g (bndparam, bndsegmentside)</li> </ul>"},{"location":"BGFlood/class_member_variables/#r","title":"r","text":"<ul> <li>refine (AdaptP)</li> <li>RightBot (BlockP)</li> <li>RightTop (BlockP)</li> <li>Riverinfo (BndblockP)</li> <li>right (BndblockP, Forcing, bndsegment)</li> <li>river (BndblockP)</li> <li>Rain (Forcing)</li> <li>rivers (Forcing)</li> <li>rainstep (Loop)</li> <li>rainuni (Loop)</li> <li>rainuniform (Loop)</li> <li>Radius (Param)</li> <li>rainbnd (Param)</li> <li>rainforcing (Param)</li> <li>reftime (Param)</li> <li>resetmax (Param)</li> <li>rho (Param)</li> <li>rightbnd (Param)</li> <li>Riverflowfile (River)</li> <li>resDesc (TexSetP)</li> </ul>"},{"location":"BGFlood/class_member_variables/#s","title":"s","text":"<ul> <li>Su (FluxP)</li> <li>Sv (FluxP)</li> <li>streams (Loop)</li> <li>savebyblk (Param)</li> <li>scalefactor (Param)</li> <li>setupcputime (Param)</li> <li>smallnc (Param)</li> <li>spherical (Param)</li> <li>startcputime (Param)</li> <li>side (bndparam, maskinfo)</li> <li>startime (deformmap)</li> </ul>"},{"location":"BGFlood/class_member_variables/#t","title":"t","text":"<ul> <li>TopLeft (BlockP)</li> <li>TopRight (BlockP)</li> <li>Tsout (BndblockP)</li> <li>top (BndblockP, Forcing, bndsegment)</li> <li>time (Flowin, Model, Pointout, SLTS, Windin)</li> <li>targetadapt (Forcing)</li> <li>TSAllout (Loop)</li> <li>totaltime (Loop, Param, TimeP)</li> <li>TSstore (Model)</li> <li>TSnodesout (Param)</li> <li>Toutput (Param, outzoneP)</li> <li>test (Param)</li> <li>theta (Param)</li> <li>topbnd (Param)</li> <li>tmax (River, forcingmap)</li> <li>to (River, forcingmap)</li> <li>tstep (T_output)</li> <li>tex (TexSetP)</li> <li>texDesc (TexSetP)</li> <li>type (bndparam, bndsegment, maskinfo)</li> </ul>"},{"location":"BGFlood/class_member_variables/#u","title":"u","text":"<ul> <li>u (EvolvingMLP, EvolvingP, Pointout)</li> <li>U (EvolvingP_M)</li> <li>UWind (Forcing)</li> <li>uwinduni (Loop)</li> <li>uuvel (SLTS)</li> <li>uniform (TexSetP, bndsegment, forcingmap)</li> <li>uwind (Windin)</li> <li>Uvel (bndTexP)</li> <li>unidata (forcingmap)</li> </ul>"},{"location":"BGFlood/class_member_variables/#v","title":"v","text":"<ul> <li>val (DynForcingP, StaticForcingP, T_output, deformmap)</li> <li>v (EvolvingMLP, EvolvingP, Pointout)</li> <li>VWind (Forcing)</li> <li>vwinduni (Loop)</li> <li>VelThreshold (Param)</li> <li>vertices (Polygon)</li> <li>vvvel (SLTS)</li> <li>vwind (Windin)</li> <li>Vvel (bndTexP)</li> <li>varname (inputmap)</li> </ul>"},{"location":"BGFlood/class_member_variables/#w","title":"w","text":"<ul> <li>windstep (Loop)</li> <li>winduniform (Loop)</li> <li>wettime (Model)</li> <li>wet_threshold (Param)</li> <li>wetdryfix (Param)</li> <li>windforcing (Param)</li> <li>wlevs (SLTS)</li> <li>wdirection (Windin)</li> <li>wspeed (Windin)</li> <li>WLS (bndTexP)</li> <li>WLmap (bndsegment)</li> </ul>"},{"location":"BGFlood/class_member_variables/#x","title":"x","text":"<ul> <li>xo (BlockP, Param, TexSetP, inputmap, outzoneB)</li> <li>xmax (Param, Polygon, inputmap, outP, outzoneB)</li> <li>xmin (Polygon, outP)</li> <li>xend (River, RiverInfo, outzoneP)</li> <li>xstart (River, RiverInfo, outzoneP)</li> <li>Xbidir (RiverInfo)</li> <li>Xridib (RiverInfo)</li> <li>x (TSoutnode, Vertex)</li> </ul>"},{"location":"BGFlood/class_member_variables/#y","title":"y","text":"<ul> <li>yo (BlockP, Param, TexSetP, inputmap, outzoneB)</li> <li>ymax (Param, Polygon, inputmap, outP, outzoneB)</li> <li>ymin (Polygon, outP)</li> <li>yend (River, RiverInfo, outzoneP)</li> <li>ystart (River, RiverInfo, outzoneP)</li> <li>y (TSoutnode, Vertex)</li> </ul>"},{"location":"BGFlood/class_member_variables/#z","title":"z","text":"<ul> <li>zs (EvolvingP, Pointout)</li> <li>zb (Model)</li> <li>zsinit (Param)</li> <li>zsoffset (Param)</li> <li>z (outP)</li> <li>z_s (outP)</li> </ul>"},{"location":"BGFlood/class_member_typedefs/","title":"Member Typedefs","text":""},{"location":"BGFlood/class_member_typedefs/#class-member-typedefs","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"BGFlood/class_member_enums/","title":"Member Enumerations","text":""},{"location":"BGFlood/class_member_enums/#class-member-enums","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"BGFlood/namespace_members/","title":"Members","text":""},{"location":"BGFlood/namespace_members/#namespace-members","title":"Namespace Members","text":""},{"location":"BGFlood/namespace_members/#m","title":"m","text":"<ul> <li>max (utils)</li> <li>max&lt; double &gt; (utils)</li> <li>max&lt; float &gt; (utils)</li> <li>max&lt; int &gt; (utils)</li> <li>min (utils)</li> <li>min&lt; double &gt; (utils)</li> <li>min&lt; float &gt; (utils)</li> <li>min&lt; int &gt; (utils)</li> </ul>"},{"location":"BGFlood/namespace_members/#n","title":"n","text":"<ul> <li>nearest (utils)</li> <li>nearest&lt; double &gt; (utils)</li> <li>nearest&lt; float &gt; (utils)</li> <li>nearest&lt; int &gt; (utils)</li> </ul>"},{"location":"BGFlood/namespace_members/#s","title":"s","text":"<ul> <li>sq (utils)</li> <li>sq&lt; double &gt; (utils)</li> <li>sq&lt; float &gt; (utils)</li> <li>sq&lt; int &gt; (utils)</li> </ul>"},{"location":"BGFlood/namespace_member_functions/","title":"Member Functions","text":""},{"location":"BGFlood/namespace_member_functions/#namespace-member-functions","title":"Namespace Member Functions","text":""},{"location":"BGFlood/namespace_member_functions/#m","title":"m","text":"<ul> <li>max (utils)</li> <li>max&lt; double &gt; (utils)</li> <li>max&lt; float &gt; (utils)</li> <li>max&lt; int &gt; (utils)</li> <li>min (utils)</li> <li>min&lt; double &gt; (utils)</li> <li>min&lt; float &gt; (utils)</li> <li>min&lt; int &gt; (utils)</li> </ul>"},{"location":"BGFlood/namespace_member_functions/#n","title":"n","text":"<ul> <li>nearest (utils)</li> <li>nearest&lt; double &gt; (utils)</li> <li>nearest&lt; float &gt; (utils)</li> <li>nearest&lt; int &gt; (utils)</li> </ul>"},{"location":"BGFlood/namespace_member_functions/#s","title":"s","text":"<ul> <li>sq (utils)</li> <li>sq&lt; double &gt; (utils)</li> <li>sq&lt; float &gt; (utils)</li> <li>sq&lt; int &gt; (utils)</li> </ul>"},{"location":"BGFlood/namespace_member_variables/","title":"Member Variables","text":""},{"location":"BGFlood/namespace_member_variables/#namespace-member-variables","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"BGFlood/namespace_member_typedefs/","title":"Member Typedefs","text":""},{"location":"BGFlood/namespace_member_typedefs/#namespace-member-typedefs","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"BGFlood/namespace_member_enums/","title":"Member Enumerations","text":""},{"location":"BGFlood/namespace_member_enums/#namespace-member-enums","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"BGFlood/functions/","title":"Functions","text":""},{"location":"BGFlood/functions/#functions","title":"Functions","text":""},{"location":"BGFlood/functions/#a","title":"a","text":"<ul> <li>AdaptCriteria (AdaptCriteria.cu, AdaptCriteria.h)</li> <li>AdaptCriteria&lt; double &gt; (AdaptCriteria.cu)</li> <li>AdaptCriteria&lt; float &gt; (AdaptCriteria.cu)</li> <li>Adapt (Adaptation.cu, Adaptation.h)</li> <li>Adaptation (Adaptation.cu, Adaptation.h)</li> <li>Adaptation&lt; double &gt; (Adaptation.cu)</li> <li>Adaptation&lt; float &gt; (Adaptation.cu)</li> <li>Adaptationcleanup (Adaptation.cu, Adaptation.h)</li> <li>Adaptationcleanup&lt; double &gt; (Adaptation.cu)</li> <li>Adaptationcleanup&lt; float &gt; (Adaptation.cu)</li> <li>AddBlocks (Adaptation.cu, Adaptation.h)</li> <li>AddBlocks&lt; double &gt; (Adaptation.cu)</li> <li>AddBlocks&lt; float &gt; (Adaptation.cu)</li> <li>AdvkernelCPU (Advection.cu, Advection.h)</li> <li>AdvkernelCPU&lt; double &gt; (Advection.cu)</li> <li>AdvkernelCPU&lt; float &gt; (Advection.cu)</li> <li>AdvkernelGPU (Advection.cu, Advection.h)</li> <li>AdvkernelGPU&lt; double &gt; (Advection.cu)</li> <li>AdvkernelGPU&lt; float &gt; (Advection.cu)</li> <li>ABS1D (Boundary.cu, Boundary.h)</li> <li>ABS1DQ (Boundary.cu, Boundary.h)</li> <li>AddZSoffset (InitEvolv.cu, InitEvolv.h)</li> <li>AddSlopeSourceXCPU (Kurganov.cu, Kurganov.h)</li> <li>AddSlopeSourceXCPU&lt; double &gt; (Kurganov.cu)</li> <li>AddSlopeSourceXCPU&lt; float &gt; (Kurganov.cu)</li> <li>AddSlopeSourceXGPU (Kurganov.cu, Kurganov.h)</li> <li>AddSlopeSourceXGPU&lt; double &gt; (Kurganov.cu)</li> <li>AddSlopeSourceXGPU&lt; float &gt; (Kurganov.cu)</li> <li>AddSlopeSourceYCPU (Kurganov.cu, Kurganov.h)</li> <li>AddSlopeSourceYCPU&lt; double &gt; (Kurganov.cu)</li> <li>AddSlopeSourceYCPU&lt; float &gt; (Kurganov.cu)</li> <li>AddSlopeSourceYGPU (Kurganov.cu, Kurganov.h)</li> <li>AddSlopeSourceYGPU&lt; double &gt; (Kurganov.cu)</li> <li>AddSlopeSourceYGPU&lt; float &gt; (Kurganov.cu)</li> <li>addUandhU_CPU (Meanmax.cu)</li> <li>addUandhU_GPU (Meanmax.cu, Meanmax.h)</li> <li>addavg_varCPU (Meanmax.cu)</li> <li>addavg_varGPU (Meanmax.cu, Meanmax.h)</li> <li>addwettime_CPU (Meanmax.cu)</li> <li>addwettime_GPU (Meanmax.cu, Meanmax.h)</li> <li>AllocateCPU (MemManagement.cu, MemManagement.h)</li> <li>AllocateCPU&lt; double &gt; (MemManagement.cu)</li> <li>AllocateCPU&lt; float &gt; (MemManagement.cu)</li> <li>AllocateCPU&lt; int &gt; (MemManagement.cu)</li> <li>AllocateGPU (MemManagement.cu, MemManagement.h)</li> <li>AllocateGPU&lt; double &gt; (MemManagement.cu)</li> <li>AllocateGPU&lt; float &gt; (MemManagement.cu)</li> <li>AllocateGPU&lt; int &gt; (MemManagement.cu)</li> <li>AllocateMappedMemCPU (MemManagement.cu, MemManagement.h)</li> <li>AllocateMappedMemCPU&lt; double &gt; (MemManagement.cu)</li> <li>AllocateMappedMemCPU&lt; float &gt; (MemManagement.cu)</li> <li>AllocateMappedMemCPU&lt; int &gt; (MemManagement.cu)</li> <li>AllocateMappedMemGPU (MemManagement.cu, MemManagement.h)</li> <li>AllocateMappedMemGPU&lt; double &gt; (MemManagement.cu)</li> <li>AllocateMappedMemGPU&lt; float &gt; (MemManagement.cu)</li> <li>AllocateMappedMemGPU&lt; int &gt; (MemManagement.cu)</li> <li>AdvecEv (Multilayer.cu, Multilayer.h)</li> <li>AdvecEv&lt; double &gt; (Multilayer.cu)</li> <li>AdvecEv&lt; float &gt; (Multilayer.cu)</li> <li>AdvecFluxML (Multilayer.cu, Multilayer.h)</li> <li>AdvecFluxML&lt; double &gt; (Multilayer.cu)</li> <li>AdvecFluxML&lt; float &gt; (Multilayer.cu)</li> <li>AllocateBndTEX (Setup_GPU.cu, Setup_GPU.h)</li> <li>AllocateTEX (Setup_GPU.cu, Setup_GPU.h)</li> <li>alloc_init2Darray (Testing.cu)</li> <li>AddDeformCPU (Updateforcing.cu)</li> <li>AddDeformGPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddPatmforcingCPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddPatmforcingCPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddPatmforcingCPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddPatmforcingGPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddPatmforcingGPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddPatmforcingGPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddRiverForcing (Updateforcing.cu, Updateforcing.h)</li> <li>AddRiverForcing&lt; double &gt; (Updateforcing.cu)</li> <li>AddRiverForcing&lt; float &gt; (Updateforcing.cu)</li> <li>AddinfiltrationImplicitCPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddinfiltrationImplicitCPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddinfiltrationImplicitCPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddinfiltrationImplicitGPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddinfiltrationImplicitGPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddinfiltrationImplicitGPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddrainforcingCPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddrainforcingCPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddrainforcingCPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddrainforcingGPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddrainforcingGPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddrainforcingGPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddrainforcingImplicitCPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddrainforcingImplicitCPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddrainforcingImplicitCPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddrainforcingImplicitGPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddrainforcingImplicitGPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddrainforcingImplicitGPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddwindforcingCPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddwindforcingCPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddwindforcingCPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddwindforcingGPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddwindforcingGPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddwindforcingGPU&lt; float &gt; (Updateforcing.cu)</li> </ul>"},{"location":"BGFlood/functions/#b","title":"b","text":"<ul> <li>bndCPU (Boundary.cu, Boundary.h)</li> <li>bndCPU&lt; double &gt; (Boundary.cu)</li> <li>bndCPU&lt; float &gt; (Boundary.cu)</li> <li>bndFluxGPUSide (Boundary.cu, Boundary.h)</li> <li>bndFluxGPUSideCPU (Boundary.cu)</li> <li>bndGPU (Boundary.cu, Boundary.h)</li> <li>bndGPU&lt; double &gt; (Boundary.cu)</li> <li>bndGPU&lt; float &gt; (Boundary.cu)</li> <li>bottomfrictionCPU (Friction.cu, Friction.h)</li> <li>bottomfrictionCPU&lt; double &gt; (Friction.cu)</li> <li>bottomfrictionCPU&lt; float &gt; (Friction.cu)</li> <li>bottomfrictionGPU (Friction.cu, Friction.h)</li> <li>bottomfrictionGPU&lt; double &gt; (Friction.cu)</li> <li>bottomfrictionGPU&lt; float &gt; (Friction.cu)</li> <li>blockmean (GridManip.cu)</li> <li>bndmaskGPU (Halo.cu, Halo.h)</li> <li>bndmaskGPU&lt; double &gt; (Halo.cu)</li> <li>bndmaskGPU&lt; float &gt; (Halo.cu)</li> <li>blockinpoly (Poly.cu, Poly.h)</li> <li>blockinpoly&lt; double &gt; (Poly.cu)</li> <li>blockinpoly&lt; float &gt; (Poly.cu)</li> <li>BarycentricInterpolation (Util_CPU.cu, Util_CPU.h)</li> <li>BilinearInterpolation (Util_CPU.cu, Util_CPU.h)</li> <li>BilinearInterpolation&lt; double &gt; (Util_CPU.cu)</li> <li>BilinearInterpolation&lt; float &gt; (Util_CPU.cu)</li> </ul>"},{"location":"BGFlood/functions/#c","title":"c","text":"<ul> <li>CalcAvailblk (Adaptation.cu, Adaptation.h)</li> <li>CalcAvailblk&lt; double &gt; (Adaptation.cu)</li> <li>CalcAvailblk&lt; float &gt; (Adaptation.cu)</li> <li>checkBUQsanity (Adaptation.cu, Adaptation.h)</li> <li>checkBUQsanity&lt; double &gt; (Adaptation.cu)</li> <li>checkBUQsanity&lt; float &gt; (Adaptation.cu)</li> <li>checklevel (Adaptation.cu, Adaptation.h)</li> <li>checkneighbourdistance (Adaptation.cu, Adaptation.h)</li> <li>checkneighbourrefine (Adaptation.cu, Adaptation.h)</li> <li>coarsen (Adaptation.cu, Adaptation.h)</li> <li>coarsen&lt; double &gt; (Adaptation.cu)</li> <li>coarsen&lt; float &gt; (Adaptation.cu)</li> <li>CalctimestepCPU (Advection.cu, Advection.h)</li> <li>CalctimestepCPU&lt; double &gt; (Advection.cu)</li> <li>CalctimestepCPU&lt; float &gt; (Advection.cu)</li> <li>CalctimestepGPU (Advection.cu, Advection.h)</li> <li>CalctimestepGPU&lt; double &gt; (Advection.cu)</li> <li>CalctimestepGPU&lt; float &gt; (Advection.cu)</li> <li>cleanupCPU (Advection.cu, Advection.h)</li> <li>cleanupCPU&lt; double &gt; (Advection.cu)</li> <li>cleanupCPU&lt; float &gt; (Advection.cu)</li> <li>cleanupGPU (Advection.cu, Advection.h)</li> <li>cleanupGPU&lt; double &gt; (Advection.cu)</li> <li>cleanupGPU&lt; float &gt; (Advection.cu)</li> <li>conserveElevation (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevation&lt; double &gt; (ConserveElevation.cu)</li> <li>conserveElevation&lt; float &gt; (ConserveElevation.cu)</li> <li>conserveElevationBot (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationGHBot (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationGHLeft (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationGHRight (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationGHTop (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationGPU (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationGPU&lt; double &gt; (ConserveElevation.cu)</li> <li>conserveElevationGPU&lt; float &gt; (ConserveElevation.cu)</li> <li>conserveElevationGradHalo (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationGradHalo&lt; double &gt; (ConserveElevation.cu)</li> <li>conserveElevationGradHalo&lt; float &gt; (ConserveElevation.cu)</li> <li>conserveElevationGradHaloA (ConserveElevation.cu)</li> <li>conserveElevationGradHaloB (ConserveElevation.cu)</li> <li>conserveElevationGradHaloGPU (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationGradHaloGPU&lt; double &gt; (ConserveElevation.cu)</li> <li>conserveElevationGradHaloGPU&lt; float &gt; (ConserveElevation.cu)</li> <li>conserveElevationLeft (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationRight (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationTop (ConserveElevation.cu, ConserveElevation.h)</li> <li>Copy2CartCPU (GridManip.cu, GridManip.h)</li> <li>Copy2CartCPU&lt; bool &gt; (GridManip.cu)</li> <li>Copy2CartCPU&lt; double &gt; (GridManip.cu)</li> <li>Copy2CartCPU&lt; float &gt; (GridManip.cu)</li> <li>Copy2CartCPU&lt; int &gt; (GridManip.cu)</li> <li>CopyArrayBUQ (GridManip.cu, GridManip.h)</li> <li>CopyArrayBUQ&lt; bool, double &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; bool, float &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; double &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; double, double &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; double, float &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; float &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; float, double &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; float, float &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; int, double &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; int, float &gt; (GridManip.cu)</li> <li>coldstart (InitEvolv.cu, InitEvolv.h)</li> <li>Calcbndblks (InitialConditions.cu, InitialConditions.h)</li> <li>calcactiveCellCPU (InitialConditions.cu, InitialConditions.h)</li> <li>calcactiveCellGPU (InitialConditions.cu)</li> <li>CalcInitdtCPU (Mainloop.cu)</li> <li>CalcInitdtGPU (Mainloop.cu)</li> <li>CrashDetection (Mainloop.cu)</li> <li>Calcmeanmax (Meanmax.cu, Meanmax.h)</li> <li>Calcmeanmax&lt; double &gt; (Meanmax.cu)</li> <li>Calcmeanmax&lt; float &gt; (Meanmax.cu)</li> <li>CalcInitnblk (Mesh.cu, Mesh.h)</li> <li>CalcMaskblk (Mesh.cu, Mesh.h)</li> <li>CalcMaskblk&lt; double &gt; (Mesh.cu)</li> <li>CalcMaskblk&lt; float &gt; (Mesh.cu)</li> <li>CalcfaceValX (Multilayer.cu, Multilayer.h)</li> <li>CalcfaceValX&lt; double &gt; (Multilayer.cu)</li> <li>CalcfaceValX&lt; float &gt; (Multilayer.cu)</li> <li>CalcfaceValY (Multilayer.cu, Multilayer.h)</li> <li>CalcfaceValY&lt; double &gt; (Multilayer.cu)</li> <li>CalcfaceValY&lt; float &gt; (Multilayer.cu)</li> <li>CheckadvecMLX (Multilayer.cu, Multilayer.h)</li> <li>CheckadvecMLX&lt; double &gt; (Multilayer.cu)</li> <li>CheckadvecMLX&lt; float &gt; (Multilayer.cu)</li> <li>CheckadvecMLY (Multilayer.cu, Multilayer.h)</li> <li>CheckadvecMLY&lt; double &gt; (Multilayer.cu)</li> <li>CheckadvecMLY&lt; float &gt; (Multilayer.cu)</li> <li>CleanupML (Multilayer.cu, Multilayer.h)</li> <li>CleanupML&lt; double &gt; (Multilayer.cu)</li> <li>CleanupML&lt; float &gt; (Multilayer.cu)</li> <li>CounterCWPoly (Poly.cu, Poly.h)</li> <li>cn_PnPoly (Poly.cu)</li> <li>clampedges (ReadForcing.cu, ReadForcing.h)</li> <li>case_insensitive_compare (ReadInput.cu, ReadInput.h)</li> <li>checkparamsanity (ReadInput.cu, ReadInput.h)</li> <li>checkncvarname (Read_netcdf.cu, Read_netcdf.h)</li> <li>CUDA_CHECK (Setup_GPU.cu, Setup_GPU.h)</li> <li>CopyGPUtoCPU (Setup_GPU.cu, Setup_GPU.h)</li> <li>CopyGPUtoCPU&lt; bool &gt; (Setup_GPU.cu)</li> <li>CopyGPUtoCPU&lt; double &gt; (Setup_GPU.cu)</li> <li>CopyGPUtoCPU&lt; float &gt; (Setup_GPU.cu)</li> <li>CopyGPUtoCPU&lt; int &gt; (Setup_GPU.cu)</li> <li>CopytoGPU (Setup_GPU.cu, Setup_GPU.h)</li> <li>CopytoGPU&lt; bool &gt; (Setup_GPU.cu)</li> <li>CopytoGPU&lt; double &gt; (Setup_GPU.cu)</li> <li>CopytoGPU&lt; float &gt; (Setup_GPU.cu)</li> <li>CopytoGPU&lt; int &gt; (Setup_GPU.cu)</li> <li>calcCM (Spherical.cu, Spherical.h)</li> <li>calcFM (Spherical.cu, Spherical.h)</li> <li>CPUGPUtest (Testing.cu)</li> <li>CompareCPUvsGPU (Testing.cu, Testing.h)</li> <li>CompareCPUvsGPU&lt; double &gt; (Testing.cu)</li> <li>CompareCPUvsGPU&lt; float &gt; (Testing.cu)</li> <li>copyBlockinfo2var (Testing.cu, Testing.h)</li> <li>copyBlockinfo2var&lt; double &gt; (Testing.cu)</li> <li>copyBlockinfo2var&lt; float &gt; (Testing.cu)</li> <li>copyID2var (Testing.cu, Testing.h)</li> <li>copyID2var&lt; double &gt; (Testing.cu)</li> <li>copyID2var&lt; float &gt; (Testing.cu)</li> <li>calcres (Util_CPU.cu, Util_CPU.h)</li> <li>calcres&lt; double &gt; (Util_CPU.cu)</li> <li>calcres&lt; float &gt; (Util_CPU.cu)</li> <li>Calcactiveblockzone (Write_netcdf.cu)</li> <li>Calcnxny (Write_netcdf.cu)</li> <li>Calcnxnyzone (Write_netcdf.cu)</li> <li>create2dnc (Write_netcdf.cu, Write_netcdf.h)</li> <li>create3dnc (Write_netcdf.cu, Write_netcdf.h)</li> <li>creatncfileBUQ (Write_netcdf.cu, Write_netcdf.h)</li> <li>creatncfileBUQ&lt; double &gt; (Write_netcdf.cu)</li> <li>creatncfileBUQ&lt; float &gt; (Write_netcdf.cu)</li> <li>create_logfile (Write_txtlog.cpp, Write_txtlog.h)</li> </ul>"},{"location":"BGFlood/functions/#d","title":"d","text":"<ul> <li>densify (Advection.cu, Advection.h)</li> <li>Dirichlet1D (Boundary.cu, Boundary.h)</li> <li>Dirichlet1Q (Boundary.cu, Boundary.h)</li> <li>DebugLoop (Mainloop.cu, Mainloop.h)</li> <li>DebugLoop&lt; double &gt; (Mainloop.cu)</li> <li>DebugLoop&lt; float &gt; (Mainloop.cu)</li> <li>divavg_varCPU (Meanmax.cu)</li> <li>divavg_varGPU (Meanmax.cu, Meanmax.h)</li> <li>dotprod (Poly.cu)</li> <li>DelimLine (ReadForcing.cu, ReadForcing.h)</li> <li>denan (ReadForcing.cu, ReadForcing.h)</li> <li>denan&lt; double &gt; (ReadForcing.cu)</li> <li>denan&lt; float &gt; (ReadForcing.cu)</li> <li>diffArray (Testing.cu)</li> <li>diffSource (Testing.cu)</li> <li>diffdh (Testing.cu)</li> <li>deformstep (Updateforcing.cu, Updateforcing.h)</li> <li>deformstep&lt; double &gt; (Updateforcing.cu)</li> <li>deformstep&lt; float &gt; (Updateforcing.cu)</li> <li>defncvarBUQ (Write_netcdf.cu, Write_netcdf.h)</li> <li>defncvarBUQ&lt; double &gt; (Write_netcdf.cu)</li> <li>defncvarBUQ&lt; float &gt; (Write_netcdf.cu)</li> <li>defncvarBUQlev (Write_netcdf.cu)</li> <li>date_string_to_s (utctime.cu, utctime.h)</li> <li>date_string_to_time (utctime.cu, utctime.h)</li> <li>days_from_epoch (utctime.cu)</li> </ul>"},{"location":"BGFlood/functions/#f","title":"f","text":"<ul> <li>Flowbnd (Boundary.cu, Boundary.h)</li> <li>Flowbnd&lt; double &gt; (Boundary.cu)</li> <li>Flowbnd&lt; float &gt; (Boundary.cu)</li> <li>FlowbndFlux (Boundary.cu, Boundary.h)</li> <li>FlowbndFlux&lt; double &gt; (Boundary.cu)</li> <li>FlowbndFlux&lt; float &gt; (Boundary.cu)</li> <li>FlowbndFluxML (Boundary.cu, Boundary.h)</li> <li>FlowbndFluxML&lt; double &gt; (Boundary.cu)</li> <li>FlowbndFluxML&lt; float &gt; (Boundary.cu)</li> <li>FlowbndFluxold (Boundary.cu)</li> <li>FlowbndFluxold&lt; double &gt; (Boundary.cu)</li> <li>FlowbndFluxold&lt; float &gt; (Boundary.cu)</li> <li>findmaskside (Boundary.cu, Boundary.h)</li> <li>FlowCPU (FlowCPU.cu, FlowCPU.h)</li> <li>FlowCPU&lt; double &gt; (FlowCPU.cu)</li> <li>FlowCPU&lt; float &gt; (FlowCPU.cu)</li> <li>FlowGPU (FlowGPU.cu, FlowGPU.h)</li> <li>FlowGPU&lt; double &gt; (FlowGPU.cu)</li> <li>FlowGPU&lt; float &gt; (FlowGPU.cu)</li> <li>FlowMLGPU (FlowMLGPU.cu, FlowMLGPU.h)</li> <li>FlowMLGPU&lt; double &gt; (FlowMLGPU.cu)</li> <li>FlowMLGPU&lt; float &gt; (FlowMLGPU.cu)</li> <li>fillBot (Halo.cu, Halo.h)</li> <li>fillBot&lt; double &gt; (Halo.cu)</li> <li>fillBot&lt; float &gt; (Halo.cu)</li> <li>fillBotFlux (Halo.cu)</li> <li>fillBotnew (Halo.cu, Halo.h)</li> <li>fillBotnew&lt; double &gt; (Halo.cu)</li> <li>fillBotnew&lt; float &gt; (Halo.cu)</li> <li>fillCorners (Halo.cu, Halo.h)</li> <li>fillCorners&lt; double &gt; (Halo.cu)</li> <li>fillCorners&lt; float &gt; (Halo.cu)</li> <li>fillCornersGPU (Halo.cu, Halo.h)</li> <li>fillCornersGPU&lt; double &gt; (Halo.cu)</li> <li>fillCornersGPU&lt; float &gt; (Halo.cu)</li> <li>fillHalo (Halo.cu, Halo.h)</li> <li>fillHalo&lt; double &gt; (Halo.cu)</li> <li>fillHalo&lt; float &gt; (Halo.cu)</li> <li>fillHaloBTFluxC (Halo.cu)</li> <li>fillHaloBTFluxC&lt; double &gt; (Halo.cu)</li> <li>fillHaloBTFluxC&lt; float &gt; (Halo.cu)</li> <li>fillHaloBotTopGPU (Halo.cu)</li> <li>fillHaloBotTopGPU&lt; double &gt; (Halo.cu)</li> <li>fillHaloBotTopGPU&lt; float &gt; (Halo.cu)</li> <li>fillHaloBotTopGPUnew (Halo.cu)</li> <li>fillHaloBotTopGPUnew&lt; double &gt; (Halo.cu)</li> <li>fillHaloBotTopGPUnew&lt; float &gt; (Halo.cu)</li> <li>fillHaloC (Halo.cu, Halo.h)</li> <li>fillHaloC&lt; double &gt; (Halo.cu)</li> <li>fillHaloC&lt; float &gt; (Halo.cu)</li> <li>fillHaloD (Halo.cu)</li> <li>fillHaloD&lt; double &gt; (Halo.cu)</li> <li>fillHaloD&lt; float &gt; (Halo.cu)</li> <li>fillHaloF (Halo.cu, Halo.h)</li> <li>fillHaloF&lt; double &gt; (Halo.cu)</li> <li>fillHaloF&lt; float &gt; (Halo.cu)</li> <li>fillHaloGPU (Halo.cu, Halo.h)</li> <li>fillHaloGPU&lt; double &gt; (Halo.cu)</li> <li>fillHaloGPU&lt; float &gt; (Halo.cu)</li> <li>fillHaloGPUnew (Halo.cu, Halo.h)</li> <li>fillHaloGPUnew&lt; double &gt; (Halo.cu)</li> <li>fillHaloGPUnew&lt; float &gt; (Halo.cu)</li> <li>fillHaloLRFluxC (Halo.cu)</li> <li>fillHaloLRFluxC&lt; double &gt; (Halo.cu)</li> <li>fillHaloLRFluxC&lt; float &gt; (Halo.cu)</li> <li>fillHaloLeftRightGPU (Halo.cu)</li> <li>fillHaloLeftRightGPU&lt; double &gt; (Halo.cu)</li> <li>fillHaloLeftRightGPU&lt; float &gt; (Halo.cu)</li> <li>fillHaloLeftRightGPUnew (Halo.cu)</li> <li>fillHaloLeftRightGPUnew&lt; double &gt; (Halo.cu)</li> <li>fillHaloLeftRightGPUnew&lt; float &gt; (Halo.cu)</li> <li>fillHaloTopRightC (Halo.cu, Halo.h)</li> <li>fillHaloTopRightC&lt; double &gt; (Halo.cu)</li> <li>fillHaloTopRightC&lt; float &gt; (Halo.cu)</li> <li>fillHaloTopRightGPU (Halo.cu, Halo.h)</li> <li>fillHaloTopRightGPU&lt; double &gt; (Halo.cu)</li> <li>fillHaloTopRightGPU&lt; float &gt; (Halo.cu)</li> <li>fillLeft (Halo.cu, Halo.h)</li> <li>fillLeft&lt; double &gt; (Halo.cu)</li> <li>fillLeft&lt; float &gt; (Halo.cu)</li> <li>fillLeftFlux (Halo.cu)</li> <li>fillLeftnew (Halo.cu, Halo.h)</li> <li>fillLeftnew&lt; double &gt; (Halo.cu)</li> <li>fillLeftnew&lt; float &gt; (Halo.cu)</li> <li>fillRight (Halo.cu, Halo.h)</li> <li>fillRight&lt; double &gt; (Halo.cu)</li> <li>fillRight&lt; float &gt; (Halo.cu)</li> <li>fillRightFlux (Halo.cu, Halo.h)</li> <li>fillRightFlux&lt; double &gt; (Halo.cu)</li> <li>fillRightFlux&lt; float &gt; (Halo.cu)</li> <li>fillRightnew (Halo.cu, Halo.h)</li> <li>fillRightnew&lt; double &gt; (Halo.cu)</li> <li>fillRightnew&lt; float &gt; (Halo.cu)</li> <li>fillTop (Halo.cu, Halo.h)</li> <li>fillTop&lt; double &gt; (Halo.cu)</li> <li>fillTop&lt; float &gt; (Halo.cu)</li> <li>fillTopFlux (Halo.cu, Halo.h)</li> <li>fillTopFlux&lt; double &gt; (Halo.cu)</li> <li>fillTopFlux&lt; float &gt; (Halo.cu)</li> <li>fillTopnew (Halo.cu, Halo.h)</li> <li>fillTopnew&lt; double &gt; (Halo.cu)</li> <li>fillTopnew&lt; float &gt; (Halo.cu)</li> <li>FindTSoutNodes (InitialConditions.cu, InitialConditions.h)</li> <li>FindTSoutNodes&lt; double &gt; (InitialConditions.cu)</li> <li>FindTSoutNodes&lt; float &gt; (InitialConditions.cu)</li> <li>Findbndblks (InitialConditions.cu, InitialConditions.h)</li> <li>Findoutzoneblks (InitialConditions.cu)</li> <li>Findoutzoneblks&lt; double &gt; (InitialConditions.cu)</li> <li>Findoutzoneblks&lt; float &gt; (InitialConditions.cu)</li> <li>FillCPU (MemManagement.cu, MemManagement.h)</li> <li>FillCPU&lt; double &gt; (MemManagement.cu)</li> <li>FillCPU&lt; float &gt; (MemManagement.cu)</li> <li>FillCPU&lt; int &gt; (MemManagement.cu)</li> <li>FindMaskblk (Mesh.cu, Mesh.h)</li> <li>FindMaskblk&lt; double &gt; (Mesh.cu)</li> <li>FindMaskblk&lt; float &gt; (Mesh.cu)</li> <li>findparameter (ReadInput.cu, ReadInput.h)</li> <li>fillgauss (Testing.cu)</li> <li>fillgauss&lt; double &gt; (Testing.cu)</li> <li>fillgauss&lt; float &gt; (Testing.cu)</li> <li>fillrandom (Testing.cu)</li> <li>fillrandom&lt; double &gt; (Testing.cu)</li> <li>fillrandom&lt; float &gt; (Testing.cu)</li> <li>Forcingthisstep (Updateforcing.cu, Updateforcing.h)</li> <li>ftoi (Util_CPU.cu, Util_CPU.h)</li> <li>ftoi&lt; double &gt; (Util_CPU.cu)</li> <li>ftoi&lt; float &gt; (Util_CPU.cu)</li> </ul>"},{"location":"BGFlood/functions/#g","title":"g","text":"<ul> <li>gradient (Gradients.cu, Gradients.h)</li> <li>gradient&lt; double &gt; (Gradients.cu)</li> <li>gradient&lt; float &gt; (Gradients.cu)</li> <li>gradientC (Gradients.cu, Gradients.h)</li> <li>gradientC&lt; double &gt; (Gradients.cu)</li> <li>gradientC&lt; float &gt; (Gradients.cu)</li> <li>gradientCPU (Gradients.cu, Gradients.h)</li> <li>gradientCPU&lt; double &gt; (Gradients.cu)</li> <li>gradientCPU&lt; float &gt; (Gradients.cu)</li> <li>gradientGPU (Gradients.cu, Gradients.h)</li> <li>gradientGPU&lt; double &gt; (Gradients.cu)</li> <li>gradientGPU&lt; float &gt; (Gradients.cu)</li> <li>gradientGPUnew (Gradients.cu, Gradients.h)</li> <li>gradientGPUnew&lt; double &gt; (Gradients.cu)</li> <li>gradientGPUnew&lt; float &gt; (Gradients.cu)</li> <li>gradientHalo (Gradients.cu, Gradients.h)</li> <li>gradientHaloBot (Gradients.cu)</li> <li>gradientHaloBotGPU (Gradients.cu, Gradients.h)</li> <li>gradientHaloBotGPUnew (Gradients.cu, Gradients.h)</li> <li>gradientHaloGPU (Gradients.cu, Gradients.h)</li> <li>gradientHaloGPUnew (Gradients.cu)</li> <li>gradientHaloLeft (Gradients.cu)</li> <li>gradientHaloLeftGPU (Gradients.cu, Gradients.h)</li> <li>gradientHaloLeftGPUnew (Gradients.cu, Gradients.h)</li> <li>gradientHaloRight (Gradients.cu)</li> <li>gradientHaloRightGPU (Gradients.cu, Gradients.h)</li> <li>gradientHaloRightGPUnew (Gradients.cu, Gradients.h)</li> <li>gradientHaloTop (Gradients.cu)</li> <li>gradientHaloTopGPU (Gradients.cu, Gradients.h)</li> <li>gradientHaloTopGPUnew (Gradients.cu, Gradients.h)</li> <li>gradientSM (Gradients.cu, Gradients.h)</li> <li>gradientSM&lt; double &gt; (Gradients.cu)</li> <li>gradientSM&lt; float &gt; (Gradients.cu)</li> <li>gradientSMB (Gradients.cu, Gradients.h)</li> <li>gradientSMB&lt; double &gt; (Gradients.cu)</li> <li>gradientSMB&lt; float &gt; (Gradients.cu)</li> <li>gradientSMC (Gradients.cu, Gradients.h)</li> <li>gradientSMC&lt; double &gt; (Gradients.cu)</li> <li>gradientSMC&lt; float &gt; (Gradients.cu)</li> <li>gradientedgeX (Gradients.cu, Gradients.h)</li> <li>gradientedgeX&lt; double &gt; (Gradients.cu)</li> <li>gradientedgeX&lt; float &gt; (Gradients.cu)</li> <li>gradientedgeY (Gradients.cu, Gradients.h)</li> <li>gradientedgeY&lt; double &gt; (Gradients.cu)</li> <li>gradientedgeY&lt; float &gt; (Gradients.cu)</li> <li>GetTimeOutput (InitialConditions.cu)</li> <li>GaussianHumptest (Testing.cu, Testing.h)</li> <li>GaussianHumptest&lt; double &gt; (Testing.cu)</li> <li>GaussianHumptest&lt; float &gt; (Testing.cu)</li> <li>gmtime_r (utctime.cu)</li> </ul>"},{"location":"BGFlood/functions/#h","title":"h","text":"<ul> <li>halowall (Boundary.cu, Boundary.h)</li> <li>HalfStepCPU (FlowCPU.cu, FlowCPU.h)</li> <li>HalfStepCPU&lt; double &gt; (FlowCPU.cu)</li> <li>HalfStepCPU&lt; float &gt; (FlowCPU.cu)</li> <li>HalfStepGPU (FlowGPU.cu, FlowGPU.h)</li> <li>HalfStepGPU&lt; double &gt; (FlowGPU.cu)</li> <li>HalfStepGPU&lt; float &gt; (FlowGPU.cu)</li> <li>HaloFluxCPUBT (Halo.cu)</li> <li>HaloFluxCPULR (Halo.cu)</li> <li>HaloFluxGPUBT (Halo.cu, Halo.h)</li> <li>HaloFluxGPUBTnew (Halo.cu, Halo.h)</li> <li>HaloFluxGPULR (Halo.cu, Halo.h)</li> <li>HaloFluxGPULRnew (Halo.cu, Halo.h)</li> <li>hllc (Reimann.cu, Reimann.h)</li> <li>haversin (Spherical.cu)</li> <li>handle_ncerror (Write_netcdf.cu, Write_netcdf.h)</li> </ul>"},{"location":"BGFlood/functions/#i","title":"i","text":"<ul> <li>inrangecriteria (AdaptCriteria.cu, AdaptCriteria.h)</li> <li>inrangecriteria&lt; double &gt; (AdaptCriteria.cu)</li> <li>inrangecriteria&lt; float &gt; (AdaptCriteria.cu)</li> <li>InitialAdaptation (Adaptation.cu, Adaptation.h)</li> <li>InitialAdaptation&lt; double &gt; (Adaptation.cu)</li> <li>InitialAdaptation&lt; float &gt; (Adaptation.cu)</li> <li>Inside (Boundary.cu, Boundary.h)</li> <li>isbnd (Boundary.cu, Boundary.h)</li> <li>InitArrayBUQ (GridManip.cu, GridManip.h)</li> <li>InitArrayBUQ&lt; bool, double &gt; (GridManip.cu)</li> <li>InitArrayBUQ&lt; bool, float &gt; (GridManip.cu)</li> <li>InitArrayBUQ&lt; double, double &gt; (GridManip.cu)</li> <li>InitArrayBUQ&lt; double, float &gt; (GridManip.cu)</li> <li>InitArrayBUQ&lt; float, double &gt; (GridManip.cu)</li> <li>InitArrayBUQ&lt; float, float &gt; (GridManip.cu)</li> <li>InitArrayBUQ&lt; int, double &gt; (GridManip.cu)</li> <li>InitArrayBUQ&lt; int, float &gt; (GridManip.cu)</li> <li>InitBlkBUQ (GridManip.cu, GridManip.h)</li> <li>InitBlkBUQ&lt; bool, double &gt; (GridManip.cu)</li> <li>InitBlkBUQ&lt; bool, float &gt; (GridManip.cu)</li> <li>InitBlkBUQ&lt; double, double &gt; (GridManip.cu)</li> <li>InitBlkBUQ&lt; double, float &gt; (GridManip.cu)</li> <li>InitBlkBUQ&lt; float, double &gt; (GridManip.cu)</li> <li>InitBlkBUQ&lt; float, float &gt; (GridManip.cu)</li> <li>InitBlkBUQ&lt; int, double &gt; (GridManip.cu)</li> <li>InitBlkBUQ&lt; int, float &gt; (GridManip.cu)</li> <li>InterpstepCPU (GridManip.cu, GridManip.h, ReadForcing.h)</li> <li>InterpstepCPU&lt; double, double &gt; (GridManip.cu)</li> <li>InterpstepCPU&lt; double, float &gt; (GridManip.cu)</li> <li>InterpstepCPU&lt; float, double &gt; (GridManip.cu)</li> <li>InterpstepCPU&lt; float, float &gt; (GridManip.cu)</li> <li>InterpstepCPU&lt; int, double &gt; (GridManip.cu)</li> <li>InterpstepCPU&lt; int, float &gt; (GridManip.cu)</li> <li>InterpstepGPU (GridManip.cu, GridManip.h)</li> <li>InterpstepGPU&lt; double &gt; (GridManip.cu)</li> <li>InterpstepGPU&lt; float &gt; (GridManip.cu)</li> <li>interp2BUQ (GridManip.cu, GridManip.h, Updateforcing.cu)</li> <li>interp2BUQ&lt; double &gt; (GridManip.cu, Updateforcing.cu)</li> <li>interp2BUQ&lt; double, DynForcingP&lt; float &gt; &gt; (GridManip.cu)</li> <li>interp2BUQ&lt; double, StaticForcingP&lt; float &gt; &gt; (GridManip.cu)</li> <li>interp2BUQ&lt; double, StaticForcingP&lt; int &gt; &gt; (GridManip.cu)</li> <li>interp2BUQ&lt; double, deformmap&lt; float &gt; &gt; (GridManip.cu)</li> <li>interp2BUQ&lt; float &gt; (GridManip.cu, Updateforcing.cu)</li> <li>interp2BUQ&lt; float, DynForcingP&lt; float &gt; &gt; (GridManip.cu)</li> <li>interp2BUQ&lt; float, StaticForcingP&lt; float &gt; &gt; (GridManip.cu)</li> <li>interp2BUQ&lt; float, StaticForcingP&lt; int &gt; &gt; (GridManip.cu)</li> <li>interp2BUQ&lt; float, deformmap&lt; float &gt; &gt; (GridManip.cu)</li> <li>initevolv (InitEvolv.cu, InitEvolv.h)</li> <li>initevolv&lt; double &gt; (InitEvolv.cu)</li> <li>initevolv&lt; float &gt; (InitEvolv.cu)</li> <li>InitRivers (InitialConditions.cu, InitialConditions.h)</li> <li>InitRivers&lt; double &gt; (InitialConditions.cu)</li> <li>InitRivers&lt; float &gt; (InitialConditions.cu)</li> <li>InitTSOutput (InitialConditions.cu, InitialConditions.h)</li> <li>Initbndblks (InitialConditions.cu)</li> <li>InitialConditions (InitialConditions.cu, InitialConditions.h)</li> <li>InitialConditions&lt; double &gt; (InitialConditions.cu)</li> <li>InitialConditions&lt; float &gt; (InitialConditions.cu)</li> <li>Initmaparray (InitialConditions.cu, InitialConditions.h)</li> <li>Initmaparray&lt; double &gt; (InitialConditions.cu)</li> <li>Initmaparray&lt; float &gt; (InitialConditions.cu)</li> <li>Initoutzone (InitialConditions.cu, InitialConditions.h)</li> <li>Initoutzone&lt; double &gt; (InitialConditions.cu)</li> <li>Initoutzone&lt; float &gt; (InitialConditions.cu)</li> <li>InitzbgradientCPU (InitialConditions.cu, InitialConditions.h)</li> <li>InitzbgradientCPU&lt; double &gt; (InitialConditions.cu)</li> <li>InitzbgradientCPU&lt; float &gt; (InitialConditions.cu)</li> <li>InitzbgradientGPU (InitialConditions.cu, InitialConditions.h)</li> <li>InitzbgradientGPU&lt; double &gt; (InitialConditions.cu)</li> <li>InitzbgradientGPU&lt; float &gt; (InitialConditions.cu)</li> <li>initOutputTimes (InitialConditions.cu, InitialConditions.h)</li> <li>initinfiltration (InitialConditions.cu)</li> <li>initoutput (InitialConditions.cu, InitialConditions.h)</li> <li>InitLoop (Mainloop.cu, Mainloop.h)</li> <li>initdt (Mainloop.cu, Mainloop.h)</li> <li>initdt&lt; double &gt; (Mainloop.cu)</li> <li>initdt&lt; float &gt; (Mainloop.cu)</li> <li>Initmeanmax (Meanmax.cu, Meanmax.h)</li> <li>Initmeanmax&lt; double &gt; (Meanmax.cu)</li> <li>Initmeanmax&lt; float &gt; (Meanmax.cu)</li> <li>InitBlockInfo (Mesh.cu, Mesh.h)</li> <li>InitBlockadapt (Mesh.cu, Mesh.h)</li> <li>InitBlockadapt&lt; double &gt; (Mesh.cu)</li> <li>InitBlockadapt&lt; float &gt; (Mesh.cu)</li> <li>InitBlockneighbours (Mesh.cu, Mesh.h)</li> <li>InitBlockneighbours&lt; double &gt; (Mesh.cu)</li> <li>InitBlockneighbours&lt; float &gt; (Mesh.cu)</li> <li>InitBlockxoyo (Mesh.cu, Mesh.h)</li> <li>InitBlockxoyo&lt; double &gt; (Mesh.cu)</li> <li>InitBlockxoyo&lt; float &gt; (Mesh.cu)</li> <li>InitMesh (Mesh.cu, Mesh.h)</li> <li>InitMesh&lt; double &gt; (Mesh.cu)</li> <li>InitMesh&lt; float &gt; (Mesh.cu)</li> <li>isLeft (Poly.cu)</li> <li>InitDynforcing (ReadForcing.cu, ReadForcing.h)</li> <li>InitialiseToutput (ReadInput.cu, ReadInput.h)</li> <li>init3Darray (Testing.cu)</li> <li>InjectManyRiversGPU (Updateforcing.cu)</li> <li>InjectRiverCPU (Updateforcing.cu)</li> <li>InjectRiverCPU&lt; double &gt; (Updateforcing.cu)</li> <li>InjectRiverCPU&lt; float &gt; (Updateforcing.cu)</li> <li>InjectRiverGPU (Updateforcing.cu, Updateforcing.h)</li> <li>InjectRiverGPU&lt; double &gt; (Updateforcing.cu)</li> <li>InjectRiverGPU&lt; float &gt; (Updateforcing.cu)</li> <li>interpDyn2BUQ (Updateforcing.cu, Updateforcing.h)</li> <li>interpDyn2BUQ&lt; double &gt; (Updateforcing.cu)</li> <li>interpDyn2BUQ&lt; float &gt; (Updateforcing.cu)</li> <li>interptime (Util_CPU.cu, Util_CPU.h)</li> <li>InitSave2Netcdf (Write_netcdf.cu, Write_netcdf.h)</li> <li>InitSave2Netcdf&lt; double &gt; (Write_netcdf.cu)</li> <li>InitSave2Netcdf&lt; float &gt; (Write_netcdf.cu)</li> </ul>"},{"location":"BGFlood/functions/#k","title":"k","text":"<ul> <li>KurgSolver (Kurganov.cu, Kurganov.h)</li> </ul>"},{"location":"BGFlood/functions/#l","title":"l","text":"<ul> <li>LakeAtRest (Testing.cu)</li> <li>log (Write_txtlog.cpp, Write_txtlog.h)</li> </ul>"},{"location":"BGFlood/functions/#m","title":"m","text":"<ul> <li>main (BG_Flood.cu)</li> <li>mainwork (BG_Flood.cu, BG_Flood.h)</li> <li>maskbnd (Boundary.cu, Boundary.h)</li> <li>maskbnd&lt; double &gt; (Boundary.cu)</li> <li>maskbnd&lt; float &gt; (Boundary.cu)</li> <li>maskbndGPUFluxbot (Boundary.cu, Boundary.h)</li> <li>maskbndGPUFluxbot&lt; double &gt; (Boundary.cu)</li> <li>maskbndGPUFluxbot&lt; float &gt; (Boundary.cu)</li> <li>maskbndGPUFluxleft (Boundary.cu, Boundary.h)</li> <li>maskbndGPUFluxleft&lt; double &gt; (Boundary.cu)</li> <li>maskbndGPUFluxleft&lt; float &gt; (Boundary.cu)</li> <li>maskbndGPUFluxright (Boundary.cu, Boundary.h)</li> <li>maskbndGPUFluxright&lt; double &gt; (Boundary.cu)</li> <li>maskbndGPUFluxright&lt; float &gt; (Boundary.cu)</li> <li>maskbndGPUFluxtop (Boundary.cu, Boundary.h)</li> <li>maskbndGPUFluxtop&lt; double &gt; (Boundary.cu)</li> <li>maskbndGPUFluxtop&lt; float &gt; (Boundary.cu)</li> <li>maskbndGPUbot (Boundary.cu, Boundary.h)</li> <li>maskbndGPUbot&lt; double &gt; (Boundary.cu)</li> <li>maskbndGPUbot&lt; float &gt; (Boundary.cu)</li> <li>maskbndGPUleft (Boundary.cu, Boundary.h)</li> <li>maskbndGPUleft&lt; double &gt; (Boundary.cu)</li> <li>maskbndGPUleft&lt; float &gt; (Boundary.cu)</li> <li>maskbndGPUright (Boundary.cu, Boundary.h)</li> <li>maskbndGPUright&lt; double &gt; (Boundary.cu)</li> <li>maskbndGPUright&lt; float &gt; (Boundary.cu)</li> <li>maskbndGPUtop (Boundary.cu, Boundary.h)</li> <li>maskbndGPUtop&lt; double &gt; (Boundary.cu)</li> <li>maskbndGPUtop&lt; float &gt; (Boundary.cu)</li> <li>manningfriction (Friction.cu, Friction.h)</li> <li>MainLoop (Mainloop.cu, Mainloop.h)</li> <li>MainLoop&lt; double &gt; (Mainloop.cu)</li> <li>MainLoop&lt; float &gt; (Mainloop.cu)</li> <li>mapoutput (Mainloop.cu)</li> <li>max_Norm_CPU (Meanmax.cu)</li> <li>max_Norm_GPU (Meanmax.cu, Meanmax.h)</li> <li>max_hU_CPU (Meanmax.cu)</li> <li>max_hU_GPU (Meanmax.cu, Meanmax.h)</li> <li>max_varCPU (Meanmax.cu)</li> <li>max_varGPU (Meanmax.cu, Meanmax.h)</li> <li>memloc (MemManagement.cu, MemManagement.h)</li> <li>MakValleyBathy (Testing.cu)</li> <li>MassConserveSteepSlope (Testing.cu, Testing.h)</li> <li>MassConserveSteepSlope&lt; double &gt; (Testing.cu)</li> <li>MassConserveSteepSlope&lt; float &gt; (Testing.cu)</li> <li>minmod2 (Util_CPU.cu, Util_CPU.h)</li> </ul>"},{"location":"BGFlood/functions/#n","title":"n","text":"<ul> <li>noslipbnd (Boundary.cu, Boundary.h)</li> <li>noslipbndQ (Boundary.cu, Boundary.h)</li> <li>nc_get_var1_T (Read_netcdf.cu, Read_netcdf.h)</li> <li>nc_get_var_T (Read_netcdf.cu, Read_netcdf.h)</li> <li>nc_get_vara_T (Read_netcdf.cu, Read_netcdf.h)</li> <li>nextPow2 (Util_CPU.cu, Util_CPU.h)</li> </ul>"},{"location":"BGFlood/functions/#o","title":"o","text":"<ul> <li>OBBdetect (Util_CPU.cu, Util_CPU.h)</li> </ul>"},{"location":"BGFlood/functions/#p","title":"p","text":"<ul> <li>ProlongationElevation (ConserveElevation.cu, ConserveElevation.h)</li> <li>ProlongationElevationGH (ConserveElevation.cu)</li> <li>pointoutputstep (Mainloop.cu)</li> <li>printstatus (Mainloop.cu, Mainloop.h)</li> <li>pressureML (Multilayer.cu, Multilayer.h)</li> <li>pressureML&lt; double &gt; (Multilayer.cu)</li> <li>pressureML&lt; float &gt; (Multilayer.cu)</li> <li>PolygonIntersect (Poly.cu)</li> </ul>"},{"location":"BGFlood/functions/#r","title":"r","text":"<ul> <li>refine (Adaptation.cu, Adaptation.h)</li> <li>refine&lt; double &gt; (Adaptation.cu)</li> <li>refine&lt; float &gt; (Adaptation.cu)</li> <li>refinesanitycheck (Adaptation.cu, Adaptation.h)</li> <li>reducemin3 (Advection.cu, Advection.h)</li> <li>RevertProlongationElevation (ConserveElevation.cu)</li> <li>reset_var (FlowGPU.cu, FlowGPU.h)</li> <li>reset_var&lt; double &gt; (FlowGPU.cu)</li> <li>reset_var&lt; float &gt; (FlowGPU.cu)</li> <li>RecalculateZs (Halo.cu, Halo.h)</li> <li>RecalculateZs&lt; double &gt; (Halo.cu)</li> <li>RecalculateZs&lt; float &gt; (Halo.cu)</li> <li>RecalculateZsGPU (Halo.cu, Halo.h)</li> <li>RecalculateZsGPU&lt; double &gt; (Halo.cu)</li> <li>RecalculateZsGPU&lt; float &gt; (Halo.cu)</li> <li>Recalculatehh (Halo.cu, Halo.h)</li> <li>Recalculatehh&lt; double &gt; (Halo.cu)</li> <li>Recalculatehh&lt; float &gt; (Halo.cu)</li> <li>refine_linear (Halo.cu, Halo.h)</li> <li>refine_linear&lt; double &gt; (Halo.cu)</li> <li>refine_linear&lt; float &gt; (Halo.cu)</li> <li>refine_linearGPU (Halo.cu, Halo.h)</li> <li>refine_linearGPU&lt; double &gt; (Halo.cu)</li> <li>refine_linearGPU&lt; float &gt; (Halo.cu)</li> <li>refine_linear_Bot (Halo.cu, Halo.h)</li> <li>refine_linear_Bot&lt; double &gt; (Halo.cu)</li> <li>refine_linear_Bot&lt; float &gt; (Halo.cu)</li> <li>refine_linear_BotGPU (Halo.cu)</li> <li>refine_linear_BotGPU&lt; double &gt; (Halo.cu)</li> <li>refine_linear_BotGPU&lt; float &gt; (Halo.cu)</li> <li>refine_linear_Left (Halo.cu, Halo.h)</li> <li>refine_linear_Left&lt; double &gt; (Halo.cu)</li> <li>refine_linear_Left&lt; float &gt; (Halo.cu)</li> <li>refine_linear_LeftGPU (Halo.cu)</li> <li>refine_linear_LeftGPU&lt; double &gt; (Halo.cu)</li> <li>refine_linear_LeftGPU&lt; float &gt; (Halo.cu)</li> <li>refine_linear_Right (Halo.cu, Halo.h)</li> <li>refine_linear_Right&lt; double &gt; (Halo.cu)</li> <li>refine_linear_Right&lt; float &gt; (Halo.cu)</li> <li>refine_linear_RightGPU (Halo.cu)</li> <li>refine_linear_RightGPU&lt; double &gt; (Halo.cu)</li> <li>refine_linear_RightGPU&lt; float &gt; (Halo.cu)</li> <li>refine_linear_Top (Halo.cu, Halo.h)</li> <li>refine_linear_Top&lt; double &gt; (Halo.cu)</li> <li>refine_linear_Top&lt; float &gt; (Halo.cu)</li> <li>refine_linear_TopGPU (Halo.cu)</li> <li>refine_linear_TopGPU&lt; double &gt; (Halo.cu)</li> <li>refine_linear_TopGPU&lt; float &gt; (Halo.cu)</li> <li>readhotstartfile (InitEvolv.cu, InitEvolv.h)</li> <li>readhotstartfile&lt; double &gt; (InitEvolv.cu)</li> <li>readhotstartfile&lt; float &gt; (InitEvolv.cu)</li> <li>readhotstartfileBG (InitEvolv.cu)</li> <li>RectCornerBlk (InitialConditions.cu)</li> <li>resetmaxCPU (Meanmax.cu)</li> <li>resetmaxGPU (Meanmax.cu)</li> <li>resetmeanCPU (Meanmax.cu)</li> <li>resetmeanCPU&lt; double &gt; (Meanmax.cu)</li> <li>resetmeanCPU&lt; float &gt; (Meanmax.cu)</li> <li>resetmeanGPU (Meanmax.cu)</li> <li>resetmeanGPU&lt; double &gt; (Meanmax.cu)</li> <li>resetmeanGPU&lt; float &gt; (Meanmax.cu)</li> <li>resetmeanmax (Meanmax.cu, Meanmax.h)</li> <li>resetmeanmax&lt; double &gt; (Meanmax.cu)</li> <li>resetmeanmax&lt; float &gt; (Meanmax.cu)</li> <li>resetvalCPU (Meanmax.cu)</li> <li>resetvalCPU&lt; double &gt; (Meanmax.cu)</li> <li>resetvalCPU&lt; float &gt; (Meanmax.cu)</li> <li>resetvalGPU (Meanmax.cu, Meanmax.h)</li> <li>resetvalGPU&lt; double &gt; (Meanmax.cu)</li> <li>resetvalGPU&lt; float &gt; (Meanmax.cu)</li> <li>ReallocArray (MemManagement.cu, MemManagement.h)</li> <li>ReallocArray&lt; double &gt; (MemManagement.cu)</li> <li>ReallocArray&lt; float &gt; (MemManagement.cu)</li> <li>ReallocArray&lt; int &gt; (MemManagement.cu)</li> <li>readCRSfrombathy (ReadForcing.cu)</li> <li>readDynforcing (ReadForcing.cu, ReadForcing.h)</li> <li>readFlowfile (ReadForcing.cu, ReadForcing.h)</li> <li>readINfileUNI (ReadForcing.cu, ReadForcing.h)</li> <li>readNestfile (ReadForcing.cu, ReadForcing.h)</li> <li>readPolygon (ReadForcing.cu, ReadForcing.h)</li> <li>readWLfile (ReadForcing.cu, ReadForcing.h)</li> <li>readWNDfileUNI (ReadForcing.cu, ReadForcing.h)</li> <li>readXBbathy (ReadForcing.cu, ReadForcing.h)</li> <li>readXBbathy&lt; float &gt; (ReadForcing.cu)</li> <li>readXBbathy&lt; int &gt; (ReadForcing.cu)</li> <li>readbathyASCHead (ReadForcing.cu, ReadForcing.h)</li> <li>readbathyASCzb (ReadForcing.cu, ReadForcing.h)</li> <li>readbathyASCzb&lt; float &gt; (ReadForcing.cu)</li> <li>readbathyASCzb&lt; int &gt; (ReadForcing.cu)</li> <li>readbathyHeadMD (ReadForcing.cu, ReadForcing.h)</li> <li>readbathyMD (ReadForcing.cu, ReadForcing.h)</li> <li>readbathyMD&lt; float &gt; (ReadForcing.cu)</li> <li>readbathyMD&lt; int &gt; (ReadForcing.cu)</li> <li>readbathydata (ReadForcing.cu)</li> <li>readbndfile (ReadForcing.cu, ReadForcing.h)</li> <li>readbndpolysegment (ReadForcing.cu, ReadForcing.h)</li> <li>readforcing (ReadForcing.cu, ReadForcing.h)</li> <li>readforcing&lt; float &gt; (ReadForcing.cu)</li> <li>readforcingdata (ReadForcing.cu, ReadForcing.h)</li> <li>readforcingdata&lt; StaticForcingP&lt; float &gt; &gt; (ReadForcing.cu)</li> <li>readforcingdata&lt; StaticForcingP&lt; int &gt; &gt; (ReadForcing.cu)</li> <li>readforcingdata&lt; deformmap&lt; float &gt; &gt; (ReadForcing.cu)</li> <li>readforcinghead (ReadForcing.cu, ReadForcing.h)</li> <li>readforcinghead&lt; StaticForcingP&lt; float &gt; &gt; (ReadForcing.cu)</li> <li>readforcinghead&lt; forcingmap &gt; (ReadForcing.cu)</li> <li>readforcinghead&lt; inputmap &gt; (ReadForcing.cu)</li> <li>readstaticforcing (ReadForcing.cu, ReadForcing.h)</li> <li>readstaticforcing&lt; StaticForcingP&lt; float &gt; &gt; (ReadForcing.cu)</li> <li>readstaticforcing&lt; StaticForcingP&lt; int &gt; &gt; (ReadForcing.cu)</li> <li>readstaticforcing&lt; deformmap&lt; float &gt; &gt; (ReadForcing.cu)</li> <li>ReadTRangestr (ReadInput.cu, ReadInput.h)</li> <li>ReadToutSTR (ReadInput.cu, ReadInput.h)</li> <li>ReadToutput (ReadInput.cu, ReadInput.h)</li> <li>ReadTvalstr (ReadInput.cu, ReadInput.h)</li> <li>Readparamfile (ReadInput.cu, ReadInput.h)</li> <li>readApproxtimestr (ReadInput.cu, ReadInput.h)</li> <li>readbndline (ReadInput.cu, ReadInput.h)</li> <li>readbndlineside (ReadInput.cu, ReadInput.h)</li> <li>readfileinfo (ReadInput.cu, ReadInput.h)</li> <li>readfileinfo&lt; DynForcingP&lt; float &gt; &gt; (ReadInput.cu)</li> <li>readfileinfo&lt; StaticForcingP&lt; float &gt; &gt; (ReadInput.cu)</li> <li>readfileinfo&lt; deformmap&lt; float &gt; &gt; (ReadInput.cu)</li> <li>readfileinfo&lt; forcingmap &gt; (ReadInput.cu)</li> <li>readfileinfo&lt; inputmap &gt; (ReadInput.cu)</li> <li>readparambool (ReadInput.cu, ReadInput.h)</li> <li>readparamstr (ReadInput.cu, ReadInput.h)</li> <li>read2Dnc (Read_netcdf.cu, Read_netcdf.h)</li> <li>read3Dnc (Read_netcdf.cu, Read_netcdf.h)</li> <li>readATMstep (Read_netcdf.cu, Read_netcdf.h)</li> <li>readWNDstep (Read_netcdf.cu, Read_netcdf.h)</li> <li>readgridncsize (Read_netcdf.cu, Read_netcdf.h)</li> <li>readgridncsize&lt; DynForcingP&lt; float &gt; &gt; (Read_netcdf.cu)</li> <li>readgridncsize&lt; StaticForcingP&lt; float &gt; &gt; (Read_netcdf.cu)</li> <li>readgridncsize&lt; StaticForcingP&lt; int &gt; &gt; (Read_netcdf.cu)</li> <li>readgridncsize&lt; deformmap&lt; float &gt; &gt; (Read_netcdf.cu)</li> <li>readgridncsize&lt; forcingmap &gt; (Read_netcdf.cu)</li> <li>readgridncsize&lt; inputmap &gt; (Read_netcdf.cu)</li> <li>readncslev1 (Read_netcdf.cu, Read_netcdf.h)</li> <li>readncslev1&lt; double &gt; (Read_netcdf.cu)</li> <li>readncslev1&lt; float &gt; (Read_netcdf.cu)</li> <li>readnctime (Read_netcdf.cu, Read_netcdf.h)</li> <li>readnctime2 (Read_netcdf.cu, Read_netcdf.h)</li> <li>readnczb (Read_netcdf.cu, Read_netcdf.h)</li> <li>readvardata (Read_netcdf.cu, Read_netcdf.h)</li> <li>readvardata&lt; double &gt; (Read_netcdf.cu)</li> <li>readvardata&lt; float &gt; (Read_netcdf.cu)</li> <li>readvardata&lt; int &gt; (Read_netcdf.cu)</li> <li>readvarinfo (Read_netcdf.cu, Read_netcdf.h)</li> <li>Rainlossestest (Testing.cu, Testing.h)</li> <li>Raintest (Testing.cu, Testing.h)</li> <li>Raintestinput (Testing.cu, Testing.h)</li> <li>Raintestmap (Testing.cu, Testing.h)</li> <li>Raintestmap&lt; double &gt; (Testing.cu)</li> <li>Raintestmap&lt; float &gt; (Testing.cu)</li> <li>RiverOnBoundary (Testing.cu)</li> <li>RiverVolumeAdapt (Testing.cu)</li> <li>Rivertest (Testing.cu, Testing.h)</li> <li>Rivertest&lt; double &gt; (Testing.cu)</li> <li>Rivertest&lt; float &gt; (Testing.cu)</li> <li>reductiontest (Testing.cu)</li> <li>reductiontest&lt; double &gt; (Testing.cu)</li> <li>reductiontest&lt; float &gt; (Testing.cu)</li> <li>readinputtimetxt (utctime.cu, utctime.h)</li> </ul>"},{"location":"BGFlood/functions/#s","title":"s","text":"<ul> <li>smartfriction (Friction.cu, Friction.h)</li> <li>setedges (GridManip.cu, GridManip.h)</li> <li>setedges&lt; double &gt; (GridManip.cu)</li> <li>setedges&lt; float &gt; (GridManip.cu)</li> <li>setedgessideBT (GridManip.cu)</li> <li>setedgessideLR (GridManip.cu)</li> <li>storeTSout (Mainloop.cu, Mainloop.h)</li> <li>SegmentIntersect (Poly.cu)</li> <li>setendtime (ReadInput.cu, ReadInput.h)</li> <li>split (ReadInput.cu, ReadInput.h)</li> <li>split_full (ReadInput.cu, ReadInput.h)</li> <li>SetupGPU (Setup_GPU.cu, Setup_GPU.h)</li> <li>SetupGPU&lt; double &gt; (Setup_GPU.cu)</li> <li>SetupGPU&lt; float &gt; (Setup_GPU.cu)</li> <li>spharea (Spherical.cu, Spherical.h)</li> <li>signof (Util_CPU.cu, Util_CPU.h)</li> <li>Save2Netcdf (Write_netcdf.cu, Write_netcdf.h)</li> <li>Save2Netcdf&lt; double &gt; (Write_netcdf.cu)</li> <li>Save2Netcdf&lt; float &gt; (Write_netcdf.cu)</li> <li>SaveParamtolog (Write_txtlog.cpp, Write_txtlog.h)</li> <li>saveparam2netCDF (Write_txtlog.cpp, Write_txtlog.h)</li> </ul>"},{"location":"BGFlood/functions/#t","title":"t","text":"<ul> <li>Thresholdcriteria (AdaptCriteria.cu, AdaptCriteria.h)</li> <li>Thresholdcriteria&lt; double &gt; (AdaptCriteria.cu)</li> <li>Thresholdcriteria&lt; float &gt; (AdaptCriteria.cu)</li> <li>targetlevelcriteria (AdaptCriteria.cu)</li> <li>targetlevelcriteria&lt; double &gt; (AdaptCriteria.cu)</li> <li>targetlevelcriteria&lt; float &gt; (AdaptCriteria.cu)</li> <li>timestepreductionCPU (Advection.cu, Advection.h)</li> <li>TheresholdVelCPU (Friction.cu, Friction.h)</li> <li>TheresholdVelCPU&lt; double &gt; (Friction.cu)</li> <li>TheresholdVelCPU&lt; float &gt; (Friction.cu)</li> <li>TheresholdVelGPU (Friction.cu, Friction.h)</li> <li>TheresholdVelGPU&lt; double &gt; (Friction.cu)</li> <li>TheresholdVelGPU&lt; float &gt; (Friction.cu)</li> <li>ThresholdVelocity (Friction.cu, Friction.h)</li> <li>test_SegmentIntersect (Poly.cu)</li> <li>test_intersectpoly (Poly.cu)</li> <li>test_wninpoly (Poly.cu)</li> <li>trim (ReadInput.cu, ReadInput.h)</li> <li>TestAIObnd (Testing.cu)</li> <li>TestFirsthalfstep (Testing.cu)</li> <li>TestFlexibleOutputTimes (Testing.cu, Testing.h)</li> <li>TestGradientSpeed (Testing.cu)</li> <li>TestHaloSpeed (Testing.cu)</li> <li>TestInstability (Testing.cu)</li> <li>TestMultiBathyRough (Testing.cu, Testing.h)</li> <li>TestPinMem (Testing.cu)</li> <li>TestPinMem&lt; double &gt; (Testing.cu)</li> <li>TestPinMem&lt; float &gt; (Testing.cu)</li> <li>Testing (Testing.cu, Testing.h)</li> <li>Testing&lt; double &gt; (Testing.cu)</li> <li>Testing&lt; float &gt; (Testing.cu)</li> <li>TestingOutput (Testing.cu, Testing.h)</li> <li>TestingOutput&lt; double &gt; (Testing.cu)</li> <li>TestingOutput&lt; float &gt; (Testing.cu)</li> <li>Testzbinit (Testing.cu)</li> <li>ThackerBathy (Testing.cu)</li> <li>ThackerLakeAtRest (Testing.cu)</li> <li>ThackerLakeAtRest&lt; double &gt; (Testing.cu)</li> <li>ThackerLakeAtRest&lt; float &gt; (Testing.cu)</li> <li>testButtingerX (Testing.cu)</li> <li>testboundaries (Testing.cu, Testing.h)</li> <li>testkurganovX (Testing.cu)</li> <li>testime1 (utctime.cu, utctime.h)</li> <li>testime2 (utctime.cu, utctime.h)</li> <li>timegm (utctime.cu)</li> </ul>"},{"location":"BGFlood/functions/#u","title":"u","text":"<ul> <li>updateEVCPU (Advection.cu, Advection.h)</li> <li>updateEVCPU&lt; double &gt; (Advection.cu)</li> <li>updateEVCPU&lt; float &gt; (Advection.cu)</li> <li>updateEVGPU (Advection.cu, Advection.h)</li> <li>updateEVGPU&lt; double &gt; (Advection.cu)</li> <li>updateEVGPU&lt; float &gt; (Advection.cu)</li> <li>updateKurgXATMCPU (Kurganov.cu, Kurganov.h)</li> <li>updateKurgXATMCPU&lt; double &gt; (Kurganov.cu)</li> <li>updateKurgXATMCPU&lt; float &gt; (Kurganov.cu)</li> <li>updateKurgXATMGPU (Kurganov.cu, Kurganov.h)</li> <li>updateKurgXATMGPU&lt; double &gt; (Kurganov.cu)</li> <li>updateKurgXATMGPU&lt; float &gt; (Kurganov.cu)</li> <li>updateKurgXCPU (Kurganov.cu, Kurganov.h)</li> <li>updateKurgXCPU&lt; double &gt; (Kurganov.cu)</li> <li>updateKurgXCPU&lt; float &gt; (Kurganov.cu)</li> <li>updateKurgXGPU (Kurganov.cu, Kurganov.h)</li> <li>updateKurgXGPU&lt; double &gt; (Kurganov.cu)</li> <li>updateKurgXGPU&lt; float &gt; (Kurganov.cu)</li> <li>updateKurgYATMCPU (Kurganov.cu, Kurganov.h)</li> <li>updateKurgYATMCPU&lt; double &gt; (Kurganov.cu)</li> <li>updateKurgYATMCPU&lt; float &gt; (Kurganov.cu)</li> <li>updateKurgYATMGPU (Kurganov.cu, Kurganov.h)</li> <li>updateKurgYATMGPU&lt; double &gt; (Kurganov.cu)</li> <li>updateKurgYATMGPU&lt; float &gt; (Kurganov.cu)</li> <li>updateKurgYCPU (Kurganov.cu, Kurganov.h)</li> <li>updateKurgYCPU&lt; double &gt; (Kurganov.cu)</li> <li>updateKurgYCPU&lt; float &gt; (Kurganov.cu)</li> <li>updateKurgYGPU (Kurganov.cu, Kurganov.h)</li> <li>updateKurgYGPU&lt; double &gt; (Kurganov.cu)</li> <li>updateKurgYGPU&lt; float &gt; (Kurganov.cu)</li> <li>updateBnd (Mainloop.cu)</li> <li>UpdateButtingerXCPU (Reimann.cu, Reimann.h)</li> <li>UpdateButtingerXGPU (Reimann.cu, Reimann.h)</li> <li>UpdateButtingerYCPU (Reimann.cu, Reimann.h)</li> <li>UpdateButtingerYGPU (Reimann.cu, Reimann.h)</li> <li>updateforcing (Updateforcing.cu, Updateforcing.h)</li> <li>updateforcing&lt; double &gt; (Updateforcing.cu)</li> <li>updateforcing&lt; float &gt; (Updateforcing.cu)</li> </ul>"},{"location":"BGFlood/functions/#v","title":"v","text":"<ul> <li>VertAdd (Poly.cu)</li> <li>VertSub (Poly.cu)</li> <li>ValleyBathy (Testing.cu)</li> <li>vectoroffsetGPU (Testing.cu)</li> </ul>"},{"location":"BGFlood/functions/#w","title":"w","text":"<ul> <li>WetDryProlongation (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryProlongation&lt; double &gt; (ConserveElevation.cu)</li> <li>WetDryProlongation&lt; float &gt; (ConserveElevation.cu)</li> <li>WetDryProlongationGPU (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryProlongationGPU&lt; double &gt; (ConserveElevation.cu)</li> <li>WetDryProlongationGPU&lt; float &gt; (ConserveElevation.cu)</li> <li>WetDryProlongationGPUBot (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryProlongationGPULeft (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryProlongationGPURight (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryProlongationGPUTop (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryRestriction (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryRestriction&lt; double &gt; (ConserveElevation.cu)</li> <li>WetDryRestriction&lt; float &gt; (ConserveElevation.cu)</li> <li>WetDryRestrictionGPU (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryRestrictionGPU&lt; double &gt; (ConserveElevation.cu)</li> <li>WetDryRestrictionGPU&lt; float &gt; (ConserveElevation.cu)</li> <li>WetDryRestrictionGPUBot (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryRestrictionGPULeft (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryRestrictionGPURight (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryRestrictionGPUTop (ConserveElevation.cu, ConserveElevation.h)</li> <li>wetdryrestriction (ConserveElevation.cu, ConserveElevation.h)</li> <li>wetdryrestriction&lt; double &gt; (ConserveElevation.cu)</li> <li>wetdryrestriction&lt; float &gt; (ConserveElevation.cu)</li> <li>WetsloperesetCPU (Gradients.cu)</li> <li>WetsloperesetHaloBotCPU (Gradients.cu)</li> <li>WetsloperesetHaloBotGPU (Gradients.cu, Gradients.h)</li> <li>WetsloperesetHaloLeftCPU (Gradients.cu)</li> <li>WetsloperesetHaloLeftGPU (Gradients.cu, Gradients.h)</li> <li>WetsloperesetHaloRightCPU (Gradients.cu)</li> <li>WetsloperesetHaloRightGPU (Gradients.cu, Gradients.h)</li> <li>WetsloperesetHaloTopCPU (Gradients.cu)</li> <li>WetsloperesetHaloTopGPU (Gradients.cu, Gradients.h)</li> <li>WetsloperesetXGPU (Gradients.cu, Gradients.h)</li> <li>WetsloperesetYGPU (Gradients.cu, Gradients.h)</li> <li>warmstart (InitEvolv.cu, InitEvolv.h)</li> <li>warmstartold (InitEvolv.cu)</li> <li>wn_PnPoly (Poly.cu, Poly.h)</li> <li>wn_PnPoly&lt; double &gt; (Poly.cu)</li> <li>wn_PnPoly&lt; float &gt; (Poly.cu)</li> <li>write2dvarnc (Write_netcdf.cu, Write_netcdf.h)</li> <li>write3dvarnc (Write_netcdf.cu, Write_netcdf.h)</li> <li>writenctimestep (Write_netcdf.cu, Write_netcdf.h)</li> <li>writencvarstepBUQ (Write_netcdf.cu, Write_netcdf.h)</li> <li>writencvarstepBUQ&lt; double &gt; (Write_netcdf.cu)</li> <li>writencvarstepBUQ&lt; float &gt; (Write_netcdf.cu)</li> <li>writencvarstepBUQlev (Write_netcdf.cu)</li> <li>writencvarstepBUQlev&lt; double &gt; (Write_netcdf.cu)</li> <li>writencvarstepBUQlev&lt; float &gt; (Write_netcdf.cu)</li> <li>write_text_to_log_file (Write_txtlog.cpp, Write_txtlog.h)</li> </ul>"},{"location":"BGFlood/functions/#x","title":"x","text":"<ul> <li>XiafrictionCPU (Friction.cu, Friction.h)</li> <li>XiafrictionCPU&lt; double &gt; (Friction.cu)</li> <li>XiafrictionCPU&lt; float &gt; (Friction.cu)</li> <li>XiafrictionGPU (Friction.cu, Friction.h)</li> <li>XiafrictionGPU&lt; double &gt; (Friction.cu)</li> <li>XiafrictionGPU&lt; float &gt; (Friction.cu)</li> <li>xprod (Poly.cu)</li> </ul>"},{"location":"BGFlood/functions/#z","title":"z","text":"<ul> <li>ZoneOutputTest (Testing.cu, Testing.h)</li> <li>ZoneOutputTest&lt; double &gt; (Testing.cu)</li> <li>ZoneOutputTest&lt; float &gt; (Testing.cu)</li> </ul>"},{"location":"BGFlood/macros/","title":"Macros","text":""},{"location":"BGFlood/macros/#macros","title":"Macros","text":""},{"location":"BGFlood/macros/#a","title":"a","text":"<ul> <li>ALIGN_UP (MemManagement.cu)</li> </ul>"},{"location":"BGFlood/macros/#m","title":"m","text":"<ul> <li>MEMORY_ALIGNMENT (MemManagement.cu)</li> </ul>"},{"location":"BGFlood/macros/#p","title":"p","text":"<ul> <li>pi (General.h)</li> </ul>"},{"location":"BGFlood/variables/","title":"Variables","text":""},{"location":"BGFlood/variables/#variables","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"BGFlood/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}