<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="_gradients_8cu" kind="file" language="C++">
    <compoundname>Gradients.cu</compoundname>
    <includes refid="_gradients_8h" local="yes">Gradients.h</includes>
    <incdepgraph>
      <node id="42">
        <label>ReadForcing.h</label>
        <link refid="_read_forcing_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="39" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="28" relation="include">
        </childnode>
        <childnode refid="34" relation="include">
        </childnode>
      </node>
      <node id="43">
        <label>Write_netcdf.h</label>
        <link refid="_write__netcdf_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="40" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
      </node>
      <node id="18">
        <label>iomanip</label>
      </node>
      <node id="21">
        <label>limits</label>
      </node>
      <node id="46">
        <label>ConserveElevation.h</label>
        <link refid="_conserve_elevation_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
      </node>
      <node id="5">
        <label>device_launch_parameters.h</label>
      </node>
      <node id="7">
        <label>stdlib.h</label>
      </node>
      <node id="4">
        <label>cuda_runtime.h</label>
      </node>
      <node id="9">
        <label>cmath</label>
      </node>
      <node id="30">
        <label>Halo.h</label>
        <link refid="_halo_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="32" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="35" relation="include">
        </childnode>
        <childnode refid="46" relation="include">
        </childnode>
      </node>
      <node id="41">
        <label>utctime.h</label>
        <link refid="utctime_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="40" relation="include">
        </childnode>
      </node>
      <node id="35">
        <label>Boundary.h</label>
        <link refid="_boundary_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="36" relation="include">
        </childnode>
      </node>
      <node id="26">
        <label>Forcing.h</label>
        <link refid="_forcing_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
      </node>
      <node id="38">
        <label>InitEvolv.h</label>
        <link refid="_init_evolv_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="39" relation="include">
        </childnode>
        <childnode refid="42" relation="include">
        </childnode>
        <childnode refid="36" relation="include">
        </childnode>
      </node>
      <node id="15">
        <label>netcdf.h</label>
      </node>
      <node id="12">
        <label>string</label>
      </node>
      <node id="36">
        <label>Updateforcing.h</label>
        <link refid="_updateforcing_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="42" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
      </node>
      <node id="14">
        <label>map</label>
      </node>
      <node id="27">
        <label>Util_CPU.h</label>
        <link refid="_util___c_p_u_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
      </node>
      <node id="31">
        <label>Write_txtlog.h</label>
        <link refid="_write__txtlog_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>Gradients.h</label>
        <link refid="_gradients_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="28" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
      </node>
      <node id="19">
        <label>fstream</label>
      </node>
      <node id="1">
        <label>src/Gradients.cu</label>
        <link refid="_gradients_8cu"/>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
      <node id="24">
        <label>Input.h</label>
        <link refid="_input_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="40">
        <label>ReadInput.h</label>
        <link refid="_read_input_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="42" relation="include">
        </childnode>
      </node>
      <node id="23">
        <label>Param.h</label>
        <link refid="_param_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
      </node>
      <node id="34">
        <label>Poly.h</label>
        <link refid="_poly_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
      </node>
      <node id="11">
        <label>ctime</label>
      </node>
      <node id="28">
        <label>Setup_GPU.h</label>
        <link refid="_setup___g_p_u_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
      </node>
      <node id="45">
        <label>Kurganov.h</label>
        <link refid="_kurganov_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="44" relation="include">
        </childnode>
      </node>
      <node id="13">
        <label>vector</label>
      </node>
      <node id="37">
        <label>InitialConditions.h</label>
        <link refid="_initial_conditions_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="44" relation="include">
        </childnode>
      </node>
      <node id="20">
        <label>sstream</label>
      </node>
      <node id="8">
        <label>math.h</label>
      </node>
      <node id="33">
        <label>GridManip.h</label>
        <link refid="_grid_manip_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
      </node>
      <node id="32">
        <label>Mesh.h</label>
        <link refid="_mesh_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="34" relation="include">
        </childnode>
      </node>
      <node id="17">
        <label>iostream</label>
      </node>
      <node id="3">
        <label>General.h</label>
        <link refid="_general_8h_source"/>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
        <childnode refid="16" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
        <childnode refid="19" relation="include">
        </childnode>
        <childnode refid="20" relation="include">
        </childnode>
        <childnode refid="21" relation="include">
        </childnode>
        <childnode refid="22" relation="include">
        </childnode>
      </node>
      <node id="25">
        <label>Arrays.h</label>
        <link refid="_arrays_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
      </node>
      <node id="10">
        <label>chrono</label>
      </node>
      <node id="22">
        <label>thread</label>
      </node>
      <node id="16">
        <label>algorithm</label>
      </node>
      <node id="6">
        <label>stdio.h</label>
      </node>
      <node id="29">
        <label>MemManagement.h</label>
        <link refid="_mem_management_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="28" relation="include">
        </childnode>
      </node>
      <node id="39">
        <label>Read_netcdf.h</label>
        <link refid="_read__netcdf_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="40" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="43" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
      </node>
      <node id="44">
        <label>Spherical.h</label>
        <link refid="_spherical_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="45" relation="include">
        </childnode>
      </node>
    </incdepgraph>
      <sectiondef kind="func">
      <memberdef kind="function" id="_gradients_8cu_1a7f2beb9e797cc636e9de13e498fbd417" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void gradientGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T *zb)</argsstring>
        <name>gradientGPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>Entry point for gradient of evolving variables calculation on the GPU. </para>
        </briefdescription>
        <detaileddescription>
<para>Calculates gradients of evolving variables using CUDA kernels and synchronizes device operations. Handles halo filling and elevation conservation if required.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XEv</parametername>
</parameternamelist>
<parameterdescription>
<para>Evolving variables </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XGrad</parametername>
</parameternamelist>
<parameterdescription>
<para>Gradient variables </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>Bed elevation array</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Wrapping function to calculate gradien of evolving variables on GPU This function is the entry point to the gradient functions on the GPU </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="21" column="18" bodyfile="src/Gradients.cu" bodystart="21" bodyend="196"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a38c0a6f411faa981cca59ab0479e02c1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void gradientGPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt;XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, float *zb)</argsstring>
        <name>gradientGPU&lt; float &gt;</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; float &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="197" column="10" declfile="src/Gradients.cu" declline="197" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a6c37c6ac9aee8e88c80e99455c76f394" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void gradientGPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt;XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, double *zb)</argsstring>
        <name>gradientGPU&lt; double &gt;</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; double &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="198" column="10" declfile="src/Gradients.cu" declline="198" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a2db5efcf678989f6a5ba98b90e105c6a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void gradientGPUnew</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T *zb)</argsstring>
        <name>gradientGPUnew</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>Alternative GPU gradient calculation using shared memory kernels and CUDA streams. </para>
        </briefdescription>
        <detaileddescription>
<para>Uses gradientSMC kernels and handles halo filling, elevation conservation, and wet/dry prolongation.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XEv</parametername>
</parameternamelist>
<parameterdescription>
<para>Evolving variables </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XGrad</parametername>
</parameternamelist>
<parameterdescription>
<para>Gradient variables </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>Bed elevation array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="212" column="18" bodyfile="src/Gradients.cu" bodystart="212" bodyend="405"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a37e454a132725a8c0916f23ba9baffe4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void gradientGPUnew&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt;XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, float *zb)</argsstring>
        <name>gradientGPUnew&lt; float &gt;</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; float &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="406" column="10" declfile="src/Gradients.cu" declline="406" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1af037aaa5f124147cc4486fe11e92dcc9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void gradientGPUnew&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt;XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, double *zb)</argsstring>
        <name>gradientGPUnew&lt; double &gt;</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; double &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="407" column="10" declfile="src/Gradients.cu" declline="407" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1aa82a51988edcdf18dc9bd1904d2c0011" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void gradient</definition>
        <argsstring>(int halowidth, int *active, int *level, T theta, T dx, T *a, T *dadx, T *dady)</argsstring>
        <name>gradient</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>T</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>T</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>Device kernel for calculating gradients for an evolving parameter using the minmod limiter. </para>
        </briefdescription>
        <detaileddescription>
<para>Computes spatial derivatives in x and y directions for a given variable.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>halowidth</parametername>
</parameternamelist>
<parameterdescription>
<para>Width of halo region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>active</parametername>
</parameternamelist>
<parameterdescription>
<para>Active block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>Block refinement levels </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>theta</parametername>
</parameternamelist>
<parameterdescription>
<para>Limiter parameter </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dx</parametername>
</parameternamelist>
<parameterdescription>
<para>Grid spacing </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input variable array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Output gradient in x </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Output gradient in y </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="425" column="29" bodyfile="src/Gradients.cu" bodystart="425" bodyend="472"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1ad7c86648280e1cfc37f49a0d4d70898f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void gradient&lt; float &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, float theta, float dx, float *a, float *dadx, float *dady)</argsstring>
        <name>gradient&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>float</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>float</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="473" column="21" declfile="src/Gradients.cu" declline="473" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1ae638a97e2dd0dac8fda854e7141bfbd9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void gradient&lt; double &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, double theta, double dx, double *a, double *dadx, double *dady)</argsstring>
        <name>gradient&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>double</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>double</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="474" column="21" declfile="src/Gradients.cu" declline="474" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a05d6a4a718eb7b36a5eca8b647547cd5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void gradientSM</definition>
        <argsstring>(int halowidth, int *active, int *level, T theta, T dx, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientSM</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>T</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>T</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>Deprecated shared memory device kernel for gradient calculation. </para>
        </briefdescription>
        <detaileddescription>
<para>Uses shared memory for stencil operations; slower than the standard kernel.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>halowidth</parametername>
</parameternamelist>
<parameterdescription>
<para>Width of halo region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>active</parametername>
</parameternamelist>
<parameterdescription>
<para>Active block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>Block refinement levels </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>theta</parametername>
</parameternamelist>
<parameterdescription>
<para>Limiter parameter </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dx</parametername>
</parameternamelist>
<parameterdescription>
<para>Grid spacing </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input variable array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Output gradient in x </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Output gradient in y </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="493" column="29" bodyfile="src/Gradients.cu" bodystart="493" bodyend="568"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a37929adb5ef6b99f7ea3872be0aeb841" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void gradientSM&lt; float &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, float theta, float dx, float *a, float *dadx, float *dady)</argsstring>
        <name>gradientSM&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>float</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>float</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="569" column="21" declfile="src/Gradients.cu" declline="569" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1ac23e6fd07a1d26c1f77ff947a9da2eeb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void gradientSM&lt; double &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, double theta, double dx, double *a, double *dadx, double *dady)</argsstring>
        <name>gradientSM&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>double</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>double</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="570" column="21" declfile="src/Gradients.cu" declline="570" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a266623c018aceee689a33a07775e3511" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void gradientSMB</definition>
        <argsstring>(int halowidth, int *active, int *level, T theta, T dx, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientSMB</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>T</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>T</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>Shared memory device kernel for gradient calculation (variant B). </para>
        </briefdescription>
        <detaileddescription>
<para>Uses a fixed shared memory tile for stencil operations; only computes gradients for interior points.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>halowidth</parametername>
</parameternamelist>
<parameterdescription>
<para>Width of halo region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>active</parametername>
</parameternamelist>
<parameterdescription>
<para>Active block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>Block refinement levels </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>theta</parametername>
</parameternamelist>
<parameterdescription>
<para>Limiter parameter </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dx</parametername>
</parameternamelist>
<parameterdescription>
<para>Grid spacing </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input variable array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Output gradient in x </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Output gradient in y </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="589" column="29" bodyfile="src/Gradients.cu" bodystart="589" bodyend="640"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1acb2f0f7f05441db4a73ad65d2234afd3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void gradientSMB&lt; float &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, float theta, float dx, float *a, float *dadx, float *dady)</argsstring>
        <name>gradientSMB&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>float</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>float</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="641" column="21" declfile="src/Gradients.cu" declline="641" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1aa42b970ac31ef0f759e3edff751d7f21" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void gradientSMB&lt; double &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, double theta, double dx, double *a, double *dadx, double *dady)</argsstring>
        <name>gradientSMB&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>double</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>double</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="642" column="21" declfile="src/Gradients.cu" declline="642" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a7617abb8f56283a3d59c3fd1ab77bcf8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void gradientSMC</definition>
        <argsstring>(int halowidth, int *active, int *level, T theta, T dx, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientSMC</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>T</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>T</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>Shared memory device kernel for gradient calculation (variant C). </para>
        </briefdescription>
        <detaileddescription>
<para>Uses a flat shared memory array for stencil operations; computes gradients for all points.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>halowidth</parametername>
</parameternamelist>
<parameterdescription>
<para>Width of halo region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>active</parametername>
</parameternamelist>
<parameterdescription>
<para>Active block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>Block refinement levels </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>theta</parametername>
</parameternamelist>
<parameterdescription>
<para>Limiter parameter </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dx</parametername>
</parameternamelist>
<parameterdescription>
<para>Grid spacing </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input variable array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Output gradient in x </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Output gradient in y </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="659" column="29" bodyfile="src/Gradients.cu" bodystart="659" bodyend="751"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a87492515acb70fe468c266f632eb1e54" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void gradientSMC&lt; float &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, float theta, float dx, float *a, float *dadx, float *dady)</argsstring>
        <name>gradientSMC&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>float</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>float</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="752" column="21" declfile="src/Gradients.cu" declline="752" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a6727bec5b9e3792836c581a3bec6d7c2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void gradientSMC&lt; double &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, double theta, double dx, double *a, double *dadx, double *dady)</argsstring>
        <name>gradientSMC&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>double</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>double</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="753" column="21" declfile="src/Gradients.cu" declline="753" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a046d584e94545ba2b3745dfdd93fa563" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void gradientedgeX</definition>
        <argsstring>(int halowidth, int *active, int *level, T theta, T dx, T *a, T *dadx)</argsstring>
        <name>gradientedgeX</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>T</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>T</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <briefdescription>
<para>Device kernel for calculating gradients for an evolving parameter using the minmod limiter only at a fixed column (i.e. fixed ix). </para>
        </briefdescription>
        <detaileddescription>
<para>Computes x-derivative for a specific column using the minmod limiter.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>halowidth</parametername>
</parameternamelist>
<parameterdescription>
<para>Width of halo region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>active</parametername>
</parameternamelist>
<parameterdescription>
<para>Active block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>Block refinement levels </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>theta</parametername>
</parameternamelist>
<parameterdescription>
<para>Limiter parameter </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dx</parametername>
</parameternamelist>
<parameterdescription>
<para>Grid spacing </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input variable array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Output gradient in x </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="771" column="29" bodyfile="src/Gradients.cu" bodystart="771" bodyend="829"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1acc445d6a318cd8359a75ce28eda9da9d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void gradientedgeX&lt; float &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, float theta, float dx, float *a, float *dadx)</argsstring>
        <name>gradientedgeX&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>float</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>float</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dadx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="830" column="21" declfile="src/Gradients.cu" declline="830" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1aba6b875ac3ab3539464a06294d4c8fef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void gradientedgeX&lt; double &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, double theta, double dx, double *a, double *dadx)</argsstring>
        <name>gradientedgeX&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>double</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>double</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dadx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="831" column="21" declfile="src/Gradients.cu" declline="831" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a8bca137115303b2d6d368e2a5fd06f68" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void gradientedgeY</definition>
        <argsstring>(int halowidth, int *active, int *level, T theta, T dx, T *a, T *dady)</argsstring>
        <name>gradientedgeY</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>T</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>T</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>Device kernel for calculating gradients for an evolving parameter using the minmod limiter only at a fixed row (i.e. fixed iy). </para>
        </briefdescription>
        <detaileddescription>
<para>Computes y-derivative for a specific row using the minmod limiter.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>halowidth</parametername>
</parameternamelist>
<parameterdescription>
<para>Width of halo region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>active</parametername>
</parameternamelist>
<parameterdescription>
<para>Active block indices </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>Block refinement levels </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>theta</parametername>
</parameternamelist>
<parameterdescription>
<para>Limiter parameter </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dx</parametername>
</parameternamelist>
<parameterdescription>
<para>Grid spacing </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input variable array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Output gradient in y </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="849" column="29" bodyfile="src/Gradients.cu" bodystart="849" bodyend="906"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a0c111c7acf9b1671940e983a92c64176" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void gradientedgeY&lt; float &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, float theta, float dx, float *a, float *dady)</argsstring>
        <name>gradientedgeY&lt; float &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>float</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>float</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="907" column="21" declfile="src/Gradients.cu" declline="907" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a16523d226560bd4c3c13f29182d46600" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template __global__ void</type>
        <definition>template __global__ void gradientedgeY&lt; double &gt;</definition>
        <argsstring>(int halowidth, int *active, int *level, double theta, double dx, double *a, double *dady)</argsstring>
        <name>gradientedgeY&lt; double &gt;</name>
        <param>
          <type>int</type>
          <declname>halowidth</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>active</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>level</declname>
        </param>
        <param>
          <type>double</type>
          <declname>theta</declname>
        </param>
        <param>
          <type>double</type>
          <declname>dx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="908" column="21" declfile="src/Gradients.cu" declline="908" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a0c7974442e46cbd7b6b79601238c171b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void gradientC</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt; XBlock, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientC</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>CPU function for calculating gradients using the minmod limiter. Computes spatial derivatives in x and y directions for a given variable. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Input variable array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Output gradient in x </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Output gradient in y </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="921" column="18" bodyfile="src/Gradients.cu" bodystart="921" bodyend="957"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1ab2cbe57c612e3d7a744753dab3b50576" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void gradientC&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt; XBlock, float *a, float *dadx, float *dady)</argsstring>
        <name>gradientC&lt; float &gt;</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="958" column="10" declfile="src/Gradients.cu" declline="958" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a1e7975ff52811b24ba9464c0ed9885f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void gradientC&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt; XBlock, double *a, double *dadx, double *dady)</argsstring>
        <name>gradientC&lt; double &gt;</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="959" column="10" declfile="src/Gradients.cu" declline="959" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a7967ede28d1cd668fcb23acde55ff39c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void gradientCPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T *zb)</argsstring>
        <name>gradientCPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>CPU function to compute gradients for all evolving parameters, handle halo regions, and apply wet-dry fixes. Calculates spatial derivatives for height, surface elevation, and velocity components. Also manages halo regions and applies wet-dry fixes if necessary. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XEv</parametername>
</parameternamelist>
<parameterdescription>
<para>Evolving parameters (height, surface elevation, velocities) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XGrad</parametername>
</parameternamelist>
<parameterdescription>
<para>Gradient storage for the evolving parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>Bathymetry array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="971" column="18" bodyfile="src/Gradients.cu" bodystart="971" bodyend="1054"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a95f91665ff637d7021da0dc7a4d2340b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void gradientCPU&lt; float &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; float &gt;XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, float *zb)</argsstring>
        <name>gradientCPU&lt; float &gt;</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; float &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; float &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; float &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="1055" column="10" declfile="src/Gradients.cu" declline="1055" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a4e775a3665d7d2200a3af320b8a71621" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void gradientCPU&lt; double &gt;</definition>
        <argsstring>(Param XParam, BlockP&lt; double &gt;XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, double *zb)</argsstring>
        <name>gradientCPU&lt; double &gt;</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; double &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; double &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; double &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="1056" column="10" declfile="src/Gradients.cu" declline="1056" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a0ee2fbb85c446eb13d77e83dbdaa5b60" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void WetsloperesetCPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T *zb)</argsstring>
        <name>WetsloperesetCPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>CPU function to apply wet slope limiters to gradients of surface elevation. Adjusts gradients to prevent non-physical slopes in wet-dry transition zones. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XEv</parametername>
</parameternamelist>
<parameterdescription>
<para>Evolving parameters (height, surface elevation, velocities) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XGrad</parametername>
</parameternamelist>
<parameterdescription>
<para>Gradient storage for the evolving parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>Bathymetry array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="1067" column="18" bodyfile="src/Gradients.cu" bodystart="1067" bodyend="1128"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a6ae01f915306c5e879362b72ab606a12" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void WetsloperesetXGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T *zb)</argsstring>
        <name>WetsloperesetXGPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>Device kernel to apply wet slope limiters to gradients of surface elevation in the x-direction. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XEv</parametername>
</parameternamelist>
<parameterdescription>
<para>Evolving parameters (height, surface elevation, velocities) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XGrad</parametername>
</parameternamelist>
<parameterdescription>
<para>Gradient storage for the evolving parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>Bathymetry array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="1141" column="29" bodyfile="src/Gradients.cu" bodystart="1141" bodyend="1178"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a4ea8993cfb8a689cb422ff0be9705082" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void WetsloperesetYGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T *zb)</argsstring>
        <name>WetsloperesetYGPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>Device kernel to apply wet slope limiters to gradients of surface elevation in the y-direction. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XEv</parametername>
</parameternamelist>
<parameterdescription>
<para>Evolving parameters (height, surface elevation, velocities) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XGrad</parametername>
</parameternamelist>
<parameterdescription>
<para>Gradient storage for the evolving parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>Bathymetry array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="1190" column="29" bodyfile="src/Gradients.cu" bodystart="1190" bodyend="1227"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1aab8d8daad2d438b36040377b418ed165" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void WetsloperesetHaloLeftGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T *zb)</argsstring>
        <name>WetsloperesetHaloLeftGPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>Device kernel to apply wet slope limiters to gradients of surface elevation at the left halo boundary. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XEv</parametername>
</parameternamelist>
<parameterdescription>
<para>Evolving parameters (height, surface elevation, velocities) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XGrad</parametername>
</parameternamelist>
<parameterdescription>
<para>Gradient storage for the evolving parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>Bathymetry array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This kernel specifically handles the left halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the left surface elevation needed for the wet slope limiter. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="1241" column="29" bodyfile="src/Gradients.cu" bodystart="1241" bodyend="1386"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a8a32852a75031a62bb3bcc8f6b5248d0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void WetsloperesetHaloLeftCPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T *zb)</argsstring>
        <name>WetsloperesetHaloLeftCPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>CPU function to apply wet slope limiters to gradients of surface elevation at the left halo boundary. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XEv</parametername>
</parameternamelist>
<parameterdescription>
<para>Evolving parameters (height, surface elevation, velocities) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XGrad</parametername>
</parameternamelist>
<parameterdescription>
<para>Gradient storage for the evolving parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>Bathymetry array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function specifically handles the left halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the left surface elevation needed for </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="1399" column="18" bodyfile="src/Gradients.cu" bodystart="1399" bodyend="1552"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1ac34df08b1165f2b4ec98734903c010ef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void WetsloperesetHaloRightGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T *zb)</argsstring>
        <name>WetsloperesetHaloRightGPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>Device kernel to apply wet slope limiters to gradients of surface elevation at the right halo boundary. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XEv</parametername>
</parameternamelist>
<parameterdescription>
<para>Evolving parameters (height, surface elevation, velocities) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XGrad</parametername>
</parameternamelist>
<parameterdescription>
<para>Gradient storage for the evolving parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>Bathymetry array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This kernel specifically handles the right halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the right surface elevation needed for the wet slope limiter. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="1567" column="29" bodyfile="src/Gradients.cu" bodystart="1567" bodyend="1719"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a42f16938e6f734b74985bef0f8d1fb9f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void WetsloperesetHaloRightCPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T *zb)</argsstring>
        <name>WetsloperesetHaloRightCPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>CPU function to apply wet slope limiters to gradients of surface elevation at the right halo boundary. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XEv</parametername>
</parameternamelist>
<parameterdescription>
<para>Evolving parameters (height, surface elevation, velocities) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XGrad</parametername>
</parameternamelist>
<parameterdescription>
<para>Gradient storage for the evolving parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>Bathymetry array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function specifically handles the right halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the right surface elevation needed for the wet slope limiter. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="1733" column="18" bodyfile="src/Gradients.cu" bodystart="1733" bodyend="1894"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1aa401976be4b1145820238f5affa6b003" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void WetsloperesetHaloBotGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T *zb)</argsstring>
        <name>WetsloperesetHaloBotGPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>GPU kernel to reset the wet slope limiter at the bottom halo boundary. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XEv</parametername>
</parameternamelist>
<parameterdescription>
<para>Evolving parameters (height, surface elevation, velocities) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XGrad</parametername>
</parameternamelist>
<parameterdescription>
<para>Gradient storage for the evolving parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>Bathymetry array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This kernel specifically handles the bottom halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the bottom surface elevation needed for the wet slope limiter. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="1908" column="29" bodyfile="src/Gradients.cu" bodystart="1908" bodyend="2057"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1aa0e85c8acb5e024b2bc79df03bb46d7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void WetsloperesetHaloBotCPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T *zb)</argsstring>
        <name>WetsloperesetHaloBotCPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>CPU function to reset the wet slope limiter at the bottom halo boundary. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XEv</parametername>
</parameternamelist>
<parameterdescription>
<para>Evolving parameters (height, surface elevation, velocities) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XGrad</parametername>
</parameternamelist>
<parameterdescription>
<para>Gradient storage for the evolving parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>Bathymetry array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function specifically handles the bottom halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the bottom surface elevation needed for the wet slope limiter. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="2070" column="18" bodyfile="src/Gradients.cu" bodystart="2070" bodyend="2230"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a3929e8eea743f07ca888804c9b58fc74" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void WetsloperesetHaloTopGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T *zb)</argsstring>
        <name>WetsloperesetHaloTopGPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>GPU kernel to reset the wet slope limiter at the top halo boundary. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Data type (float or double) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XEv</parametername>
</parameternamelist>
<parameterdescription>
<para>Evolving parameters (height, surface elevation, velocities) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XGrad</parametername>
</parameternamelist>
<parameterdescription>
<para>Gradient storage for the evolving parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>Bathymetry array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This kernel specifically handles the top halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the top surface elevation needed for the wet slope limiter. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="2245" column="29" bodyfile="src/Gradients.cu" bodystart="2245" bodyend="2395"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a58d4d07c15119a0e5b5b293f7462d52a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void WetsloperesetHaloTopCPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T *zb)</argsstring>
        <name>WetsloperesetHaloTopCPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_evolving_p" kindref="compound">EvolvingP</ref>&lt; T &gt;</type>
          <declname>XEv</declname>
        </param>
        <param>
          <type><ref refid="struct_gradients_p" kindref="compound">GradientsP</ref>&lt; T &gt;</type>
          <declname>XGrad</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>CPU function to reset the wet slope limiter at the top halo boundary. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XEv</parametername>
</parameternamelist>
<parameterdescription>
<para>Evolving parameters (height, surface elevation, velocities) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XGrad</parametername>
</parameternamelist>
<parameterdescription>
<para>Gradient storage for the evolving parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>Bathymetry array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function specifically handles the top halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the top surface elevation needed for the wet slope limiter. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="2410" column="19" bodyfile="src/Gradients.cu" bodystart="2410" bodyend="2566"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1ace865c08d4d7671dec06b28afede9cd8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void gradientHalo</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientHalo</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>CPU function to compute gradients at the halo boundaries of all active blocks. This function iterates over all active blocks and computes the gradients at their halo boundaries using finite difference approximations. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Array containing the variable for which gradients are to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed x-derivative gradients </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed y-derivative gradients </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function calls specific functions to handle each of the four halo boundaries (left, right, bottom, top) for each block. It ensures that gradients are accurately computed at the edges of the computational domain, which is crucial for maintaining solution accuracy and stability. The function assumes that the input arrays are properly allocated and sized according to the simulation parameters. The gradient computations are performed using central differences where possible, and one-sided differences at the boundaries. The function is templated to support different data types (e.g., float, double). </para>
</simplesect>
<simplesect kind="see"><para>gradientHaloLeft, gradientHaloRight, gradientHaloBot, gradientHaloTop </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="2584" column="18" bodyfile="src/Gradients.cu" bodystart="2584" bodyend="2605"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a723f58c6d0e2c05a1aacabe22a3469a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void gradientHaloGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientHaloGPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>GPU function to compute gradients at the halo boundaries of all active blocks. This function launches CUDA kernels to compute the gradients at the halo boundaries of all active blocks using parallel processing. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Array containing the variable for which gradients are to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed x-derivative gradients </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed y-derivative gradients </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function sets up the CUDA grid and block dimensions and launches specific kernels to handle each of the four halo boundaries (left, right, bottom, top) for all active blocks. It ensures that gradients are accurately computed at the edges of the computational domain, which is crucial for maintaining solution accuracy and stability. The function assumes that the input arrays are properly allocated and sized according to the simulation parameters. The gradient computations are performed using central differences where possible, and one-sided differences at the boundaries. The function is templated to support different data types (e.g., float, double). </para>
</simplesect>
<simplesect kind="see"><para>gradientHaloLeftGPU, gradientHaloRightGPU, gradientHaloBotGPU, gradientHaloTopGPU </para>
</simplesect>
<simplesect kind="see"><para>gradientHaloLeft, gradientHaloRight, gradientHaloBot, gradientHaloTop </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="2624" column="18" bodyfile="src/Gradients.cu" bodystart="2624" bodyend="2644"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a0edd5d08ada0cbdd7ca84c0166e179c0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void gradientHaloGPUnew</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientHaloGPUnew</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>GPU function to compute gradients at the halo boundaries of all active blocks using multiple CUDA streams. This function launches CUDA kernels in separate streams to compute the gradients at the halo boundaries of all active blocks, allowing for concurrent execution and improved performance. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Array containing the variable for which gradients are to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed x-derivative gradients </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed y-derivative gradients </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function sets up multiple CUDA streams and launches specific kernels to handle each of the four halo boundaries (left, right, bottom, top) for all active blocks in separate streams. It ensures that gradients are accurately computed at the edges of the computational domain, which is crucial for maintaining solution accuracy and stability. The function assumes that the input arrays are properly allocated and sized according to the simulation parameters. The gradient computations are performed using central differences where possible, and one-sided differences at the boundaries. The function is templated to support different data types (e.g., float, double). </para>
</simplesect>
<simplesect kind="see"><para>gradientHaloLeftGPUnew, gradientHaloRightGPUnew, gradientHaloBotGPUnew, gradientHaloTopGPUnew </para>
</simplesect>
<simplesect kind="see"><para>gradientHaloLeft, gradientHaloRight, gradientHaloBot, gradientHaloTop </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="2663" column="18" bodyfile="src/Gradients.cu" bodystart="2663" bodyend="2698"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a84ab8b542cb94c7d6f9bb8d57c265111" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void gradientHaloLeft</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, int ib, int iy, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientHaloLeft</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type>int</type>
          <declname>iy</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>CPU function to compute the gradient at the left halo boundary of a specific block. This function calculates the x and y derivatives at the left edge of the block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the block for which the left halo gradient is to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>iy</parametername>
</parameternamelist>
<parameterdescription>
<para>y-index within the block </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Array containing the variable for which gradients are to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed x-derivative gradients </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed y-derivative gradients </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="2713" column="18" bodyfile="src/Gradients.cu" bodystart="2713" bodyend="2843"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1abe38e35fea0852cfc6562ee539545530" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void gradientHaloRight</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, int ib, int iy, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientHaloRight</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type>int</type>
          <declname>iy</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>CPU function to compute the gradient at the left halo boundary of a specific block. This function calculates the x and y derivatives at the left edge of the block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the block for which the left halo gradient is to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>iy</parametername>
</parameternamelist>
<parameterdescription>
<para>y-index within the block </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Array containing the variable for which gradients are to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed x-derivative gradients </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed y-derivative gradients </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="2858" column="18" bodyfile="src/Gradients.cu" bodystart="2858" bodyend="2987"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1adf5383fb97d5eb2464d058abec38004b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void gradientHaloBot</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, int ib, int ix, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientHaloBot</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ix</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>CPU function to compute the gradient at the bottom halo boundary of a specific block. This function calculates the x and y derivatives at the bottom edge of the block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the block for which the bottom halo gradient is to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ix</parametername>
</parameternamelist>
<parameterdescription>
<para>x-index within the block </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Array containing the variable for which gradients are to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed x-derivative gradients </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed y-derivative gradients </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="3002" column="18" bodyfile="src/Gradients.cu" bodystart="3002" bodyend="3134"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a38a09d30be84b2e011be0e8a740fdc49" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void gradientHaloTop</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, int ib, int ix, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientHaloTop</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ib</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ix</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>CPU function to compute the gradient at the top halo boundary of a specific block. This function calculates the x and y derivatives at the top edge of the block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ib</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the block for which the top halo gradient is to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ix</parametername>
</parameternamelist>
<parameterdescription>
<para>x-index within the block </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Array containing the variable for which gradients are to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed x-derivative gradients </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed y-derivative gradients </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="3149" column="18" bodyfile="src/Gradients.cu" bodystart="3149" bodyend="3281"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a1ba99b42df344924b15644366879a908" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void gradientHaloLeftGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientHaloLeftGPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>GPU kernel to compute the gradient at the left halo boundary of blocks. This kernel calculates the x and y derivatives at the left edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Array containing the variable for which gradients are to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed x-derivative gradients </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed y-derivative gradients </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="3295" column="29" bodyfile="src/Gradients.cu" bodystart="3295" bodyend="3430"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a1146d278c18b9361212a1ed2bcedbf0c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void gradientHaloLeftGPUnew</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientHaloLeftGPUnew</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>GPU kernel to compute the gradient at the left halo boundary of blocks. This kernel calculates the x and y derivatives at the left edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Array containing the variable for which gradients are to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed x-derivative gradients </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed y-derivative gradients </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="3443" column="29" bodyfile="src/Gradients.cu" bodystart="3443" bodyend="3582"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a0683993ce23fd434f18ed081861f2f4e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void gradientHaloRightGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientHaloRightGPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>GPU kernel to compute the gradient at the right halo boundary of blocks. This kernel calculates the x and y derivatives at the right edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Array containing the variable for which gradients are to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed x-derivative gradients </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed y-derivative gradients </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="3595" column="29" bodyfile="src/Gradients.cu" bodystart="3595" bodyend="3730"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1aced9e7fa188d827a0603b5b652d16b93" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void gradientHaloRightGPUnew</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientHaloRightGPUnew</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>GPU kernel to compute the gradient at the right halo boundary of blocks. This kernel calculates the x and y derivatives at the right edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Array containing the variable for which gradients are to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed x-derivative gradients </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed y-derivative gradients </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="3743" column="29" bodyfile="src/Gradients.cu" bodystart="3743" bodyend="3880"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1ac38cf6d668a6dcb8842f3f899e211856" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void gradientHaloBotGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientHaloBotGPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>GPU kernel to compute the gradient at the bottom halo boundary of blocks. This kernel calculates the x and y derivatives at the bottom edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Array containing the variable for which gradients are to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed x-derivative gradients </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed y-derivative gradients </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="3893" column="29" bodyfile="src/Gradients.cu" bodystart="3893" bodyend="4034"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1a6ad537d3b5fec89bc00c43011c3e9f49" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void gradientHaloBotGPUnew</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientHaloBotGPUnew</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>GPU kernel to compute the gradient at the bottom halo boundary of blocks. This kernel calculates the x and y derivatives at the bottom edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Array containing the variable for which gradients are to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed x-derivative gradients </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed y-derivative gradients </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="4047" column="29" bodyfile="src/Gradients.cu" bodystart="4047" bodyend="4190"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1ab6a1fa866c793d6d480dce63d1093cc1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void gradientHaloTopGPU</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientHaloTopGPU</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>GPU kernel to compute the gradient at the top halo boundary of blocks. This kernel calculates the x and y derivatives at the top edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Array containing the variable for which gradients are to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed x-derivative gradients </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed y-derivative gradients </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="4203" column="29" bodyfile="src/Gradients.cu" bodystart="4203" bodyend="4344"/>
      </memberdef>
      <memberdef kind="function" id="_gradients_8cu_1af240b026ec1496b35b8d28042abbd34a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void gradientHaloTopGPUnew</definition>
        <argsstring>(Param XParam, BlockP&lt; T &gt;XBlock, T *a, T *dadx, T *dady)</argsstring>
        <name>gradientHaloTopGPUnew</name>
        <param>
          <type><ref refid="class_param" kindref="compound">Param</ref></type>
          <declname>XParam</declname>
        </param>
        <param>
          <type><ref refid="struct_block_p" kindref="compound">BlockP</ref>&lt; T &gt;</type>
          <declname>XBlock</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dadx</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>dady</declname>
        </param>
        <briefdescription>
<para>GPU kernel to compute the gradient at the top halo boundary of blocks. This kernel calculates the x and y derivatives at the top edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>XParam</parametername>
</parameternamelist>
<parameterdescription>
<para>Simulation parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>XBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Block information </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Array containing the variable for which gradients are to be computed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dadx</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed x-derivative gradients </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dady</parametername>
</parameternamelist>
<parameterdescription>
<para>Array to store the computed y-derivative gradients </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/Gradients.cu" line="4357" column="29" bodyfile="src/Gradients.cu" bodystart="4357" bodyend="4502"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="preprocessor">#include<sp/>&quot;Gradients.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientGPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>XGrad,T*<sp/>zb)</highlight></codeline>
<codeline lineno="22"><highlight class="normal">{</highlight></codeline>
<codeline lineno="23"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//const<sp/>int<sp/>num_streams<sp/>=<sp/>4;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="25"><highlight class="comment"><sp/><sp/><sp/><sp/>cudaStream_t<sp/>streams[num_streams];</highlight></codeline>
<codeline lineno="26"><highlight class="comment"></highlight></codeline>
<codeline lineno="27"><highlight class="comment"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="28"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="29"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));</highlight></codeline>
<codeline lineno="30"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="31"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDim(XParam.blkwidth,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="33"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimLR(1,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="34"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimBT(XParam.blkwidth,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="35"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimLR2(2,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="36"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimBT2(XParam.blkwidth,<sp/>2,<sp/>1);</highlight></codeline>
<codeline lineno="37"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimfull(XParam.blkmemwidth,<sp/>XParam.blkmemwidth,<sp/>1);</highlight></codeline>
<codeline lineno="38"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="39"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="40"><highlight class="normal"></highlight></codeline>
<codeline lineno="41"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[1]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.h,<sp/>XGrad.dhdx,<sp/>XGrad.dhdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="42"><highlight class="normal"><sp/><sp/><sp/><sp/>gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>);</highlight></codeline>
<codeline lineno="43"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="44"><highlight class="normal"></highlight></codeline>
<codeline lineno="45"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[2]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.zs,<sp/>XGrad.dzsdx,<sp/>XGrad.dzsdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="46"><highlight class="normal"><sp/><sp/><sp/><sp/>gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="48"><highlight class="normal"></highlight></codeline>
<codeline lineno="49"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[3]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.u,<sp/>XGrad.dudx,<sp/>XGrad.dudy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="50"><highlight class="normal"><sp/><sp/><sp/><sp/>gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.<ref refid="struct_evolving_p_1addf0f1e2e0672ff7d32890c1867d1586" kindref="member">u</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a031883fc1cf8682f6eb513f6dd46f47e" kindref="member">dudx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ac700564ea6800deeed698502ab8a15eb" kindref="member">dudy</ref>);</highlight></codeline>
<codeline lineno="51"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="52"><highlight class="normal"></highlight></codeline>
<codeline lineno="53"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[0]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.v,<sp/>XGrad.dvdx,<sp/>XGrad.dvdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="54"><highlight class="normal"><sp/><sp/><sp/><sp/>gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.<ref refid="struct_evolving_p_1a5f61fdbd33ae88a62d35dd5235d8f375" kindref="member">v</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa5192b823cd1b71e7622d3e3c90ff163" kindref="member">dvdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aebefd731d1813ab1af3f7c282a5ba2e5" kindref="member">dvdy</ref>);</highlight></codeline>
<codeline lineno="55"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="56"><highlight class="normal"></highlight></codeline>
<codeline lineno="57"><highlight class="normal"></highlight></codeline>
<codeline lineno="58"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="59"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="60"><highlight class="comment"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="61"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="62"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStreamDestroy(streams[i]);</highlight></codeline>
<codeline lineno="63"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="64"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="65"><highlight class="normal"></highlight></codeline>
<codeline lineno="66"><highlight class="normal"></highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillHaloGPU(XParam,<sp/>XBlock,<sp/>XGrad);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>);</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1addf0f1e2e0672ff7d32890c1867d1586" kindref="member">u</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a031883fc1cf8682f6eb513f6dd46f47e" kindref="member">dudx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ac700564ea6800deeed698502ab8a15eb" kindref="member">dudy</ref>);</highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a5f61fdbd33ae88a62d35dd5235d8f375" kindref="member">v</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa5192b823cd1b71e7622d3e3c90ff163" kindref="member">dvdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aebefd731d1813ab1af3f7c282a5ba2e5" kindref="member">dvdy</ref>);</highlight></codeline>
<codeline lineno="72"><highlight class="normal"></highlight></codeline>
<codeline lineno="73"><highlight class="normal"></highlight></codeline>
<codeline lineno="74"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.conserveElevation)</highlight></codeline>
<codeline lineno="75"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="76"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>conserveElevationGradHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>,<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>,<sp/>zb,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="77"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="78"><highlight class="normal"></highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.maxlevel<sp/>&gt;<sp/>XParam.minlevel)</highlight></codeline>
<codeline lineno="82"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refine_linearGPU(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>);</highlight></codeline>
<codeline lineno="84"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//refine_linearGPU(XParam,<sp/>XBlock,<sp/>XEv.zs,<sp/>XGrad.dzsdx,<sp/>XGrad.dzsdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refine_linearGPU(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1addf0f1e2e0672ff7d32890c1867d1586" kindref="member">u</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a031883fc1cf8682f6eb513f6dd46f47e" kindref="member">dudx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ac700564ea6800deeed698502ab8a15eb" kindref="member">dudy</ref>);</highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refine_linearGPU(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a5f61fdbd33ae88a62d35dd5235d8f375" kindref="member">v</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa5192b823cd1b71e7622d3e3c90ff163" kindref="member">dvdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aebefd731d1813ab1af3f7c282a5ba2e5" kindref="member">dvdy</ref>);</highlight></codeline>
<codeline lineno="87"><highlight class="normal"></highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.conserveElevation)</highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>conserveElevationGPU(XParam,<sp/>XBlock,<sp/>XEv,<sp/>zb);</highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>RecalculateZsGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimfull,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>XEv,<sp/>zb);</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="95"><highlight class="normal"></highlight></codeline>
<codeline lineno="96"><highlight class="normal"></highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[1]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.h,<sp/>XGrad.dhdx,<sp/>XGrad.dhdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.h,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>);</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="101"><highlight class="normal"></highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[2]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.zs,<sp/>XGrad.dzsdx,<sp/>XGrad.dzsdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.zs,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="105"><highlight class="normal"></highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[3]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.u,<sp/>XGrad.dudx,<sp/>XGrad.dudy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.u,<sp/>XGrad.<ref refid="struct_gradients_p_1a031883fc1cf8682f6eb513f6dd46f47e" kindref="member">dudx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ac700564ea6800deeed698502ab8a15eb" kindref="member">dudy</ref>);</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="109"><highlight class="normal"></highlight></codeline>
<codeline lineno="110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[0]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.v,<sp/>XGrad.dvdx,<sp/>XGrad.dvdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.v,<sp/>XGrad.<ref refid="struct_gradients_p_1aa5192b823cd1b71e7622d3e3c90ff163" kindref="member">dvdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aebefd731d1813ab1af3f7c282a5ba2e5" kindref="member">dvdy</ref>);</highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="113"><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="normal"></highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="116"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientedgeX<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.h,<sp/>XGrad.dhdx);</highlight></codeline>
<codeline lineno="117"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="118"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//gradientedgeX<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.blkwidth-1,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.h,<sp/>XGrad.dhdx);</highlight></codeline>
<codeline lineno="119"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="120"><highlight class="comment"></highlight></codeline>
<codeline lineno="121"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientedgeY<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.h,<sp/>XGrad.dhdy);</highlight></codeline>
<codeline lineno="122"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="123"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//gradientedgeY<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT,<sp/>0&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.blkwidth-1,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.h,<sp/>XGrad.dhdy);</highlight></codeline>
<codeline lineno="124"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="125"><highlight class="comment"></highlight></codeline>
<codeline lineno="126"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientedgeX<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.zs,<sp/>XGrad.dzsdx);</highlight></codeline>
<codeline lineno="127"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="128"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//gradientedgeX<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.zs,<sp/>XGrad.dzsdx);</highlight></codeline>
<codeline lineno="129"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="130"><highlight class="comment"></highlight></codeline>
<codeline lineno="131"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientedgeY<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.zs,<sp/>XGrad.dzsdy);</highlight></codeline>
<codeline lineno="132"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="133"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//gradientedgeY<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.zs,<sp/>XGrad.dzsdy);</highlight></codeline>
<codeline lineno="134"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="135"><highlight class="comment"></highlight></codeline>
<codeline lineno="136"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientedgeX<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.u,<sp/>XGrad.dudx);</highlight></codeline>
<codeline lineno="137"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="138"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//gradientedgeX<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.u,<sp/>XGrad.dudx);</highlight></codeline>
<codeline lineno="139"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="140"><highlight class="comment"></highlight></codeline>
<codeline lineno="141"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientedgeY<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.u,<sp/>XGrad.dudy);</highlight></codeline>
<codeline lineno="142"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="143"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//gradientedgeY<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.u,<sp/>XGrad.dudy);</highlight></codeline>
<codeline lineno="144"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="145"><highlight class="comment"></highlight></codeline>
<codeline lineno="146"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientedgeX<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.v,<sp/>XGrad.dvdx);</highlight></codeline>
<codeline lineno="147"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="148"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//gradientedgeX<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.v,<sp/>XGrad.dvdx);</highlight></codeline>
<codeline lineno="149"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="150"><highlight class="comment"></highlight></codeline>
<codeline lineno="151"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientedgeY<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.v,<sp/>XGrad.dvdy);</highlight></codeline>
<codeline lineno="152"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="153"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//gradientedgeY<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.v,<sp/>XGrad.dvdy);</highlight></codeline>
<codeline lineno="154"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="155"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="156"><highlight class="normal"></highlight></codeline>
<codeline lineno="157"><highlight class="normal"></highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.h,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>);</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.zs,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.u,<sp/>XGrad.<ref refid="struct_gradients_p_1a031883fc1cf8682f6eb513f6dd46f47e" kindref="member">dudx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ac700564ea6800deeed698502ab8a15eb" kindref="member">dudy</ref>);</highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.v,<sp/>XGrad.<ref refid="struct_gradients_p_1aa5192b823cd1b71e7622d3e3c90ff163" kindref="member">dvdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aebefd731d1813ab1af3f7c282a5ba2e5" kindref="member">dvdy</ref>);</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.conserveElevation)</highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>conserveElevationGradHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.h,<sp/>XEv.zs,<sp/>zb,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.engine<sp/>==<sp/>1)</highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>wet<sp/>slope<sp/>limiter</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetsloperesetXGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>XEv,<sp/>XGrad,<sp/>zb);</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="172"><highlight class="normal"></highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetsloperesetYGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>XEv,<sp/>XGrad,<sp/>zb);</highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="175"><highlight class="normal"></highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>ALso<sp/>do<sp/>the<sp/>slope<sp/>limiter<sp/>on<sp/>the<sp/>halo</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetsloperesetHaloLeftGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>XEv,<sp/>XGrad,<sp/>zb);</highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="179"><highlight class="normal"></highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetsloperesetHaloRightGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>XEv,<sp/>XGrad,<sp/>zb);</highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="182"><highlight class="normal"></highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetsloperesetHaloBotGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>XEv,<sp/>XGrad,<sp/>zb);</highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="185"><highlight class="normal"></highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetsloperesetHaloTopGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>XEv,<sp/>XGrad,<sp/>zb);</highlight></codeline>
<codeline lineno="187"><highlight class="normal"></highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="190"><highlight class="normal"></highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//conserveElevationGradHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.zs,<sp/>XGrad.dzsdx,<sp/>XGrad.dzsdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//conserveElevationGradHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.u,<sp/>XGrad.dudx,<sp/>XGrad.dudy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//conserveElevationGradHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.v,<sp/>XGrad.dvdx,<sp/>XGrad.dvdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="195"><highlight class="normal"></highlight></codeline>
<codeline lineno="196"><highlight class="normal">}</highlight></codeline>
<codeline lineno="197"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientGPU&lt;float&gt;(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;float&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;float&gt;</ref><sp/>XGrad,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>zb);</highlight></codeline>
<codeline lineno="198"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientGPU&lt;double&gt;(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;double&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;double&gt;</ref><sp/>XGrad,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*<sp/>zb);</highlight></codeline>
<codeline lineno="199"><highlight class="normal"></highlight></codeline>
<codeline lineno="212"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientGPUnew(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>XGrad,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="213"><highlight class="normal">{</highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDim(XParam.blkwidth,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimLR(1,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimBT(XParam.blkwidth,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimLR2(2,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimBT2(XParam.blkwidth,<sp/>2,<sp/>1);</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimfull(XParam.blkmemwidth,<sp/>XParam.blkmemwidth,<sp/>1);</highlight></codeline>
<codeline lineno="221"><highlight class="normal"></highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="223"><highlight class="normal"></highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_streams<sp/>=<sp/>4;</highlight></codeline>
<codeline lineno="225"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="226"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaStream_t<sp/>streams[num_streams];</highlight></codeline>
<codeline lineno="227"><highlight class="normal"></highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));</highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="232"><highlight class="normal"></highlight></codeline>
<codeline lineno="233"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[1]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.h,<sp/>XGrad.dhdx,<sp/>XGrad.dhdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="234"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientSMC<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[0]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>);</highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="236"><highlight class="normal"></highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[2]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.zs,<sp/>XGrad.dzsdx,<sp/>XGrad.dzsdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientSMC<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[1]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="240"><highlight class="normal"></highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[3]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.u,<sp/>XGrad.dudx,<sp/>XGrad.dudy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientSMC<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[2]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.<ref refid="struct_evolving_p_1addf0f1e2e0672ff7d32890c1867d1586" kindref="member">u</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a031883fc1cf8682f6eb513f6dd46f47e" kindref="member">dudx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ac700564ea6800deeed698502ab8a15eb" kindref="member">dudy</ref>);</highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="244"><highlight class="normal"></highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[0]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.v,<sp/>XGrad.dvdx,<sp/>XGrad.dvdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientSMC<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[3]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.<ref refid="struct_evolving_p_1a5f61fdbd33ae88a62d35dd5235d8f375" kindref="member">v</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa5192b823cd1b71e7622d3e3c90ff163" kindref="member">dvdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aebefd731d1813ab1af3f7c282a5ba2e5" kindref="member">dvdy</ref>);</highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="248"><highlight class="normal"></highlight></codeline>
<codeline lineno="249"><highlight class="normal"></highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="252"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStreamDestroy(streams[i]);</highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="256"><highlight class="normal"></highlight></codeline>
<codeline lineno="257"><highlight class="normal"></highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillHaloGPU(XParam,<sp/>XBlock,<sp/>XGrad);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHaloGPUnew(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>);</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHaloGPUnew(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHaloGPUnew(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1addf0f1e2e0672ff7d32890c1867d1586" kindref="member">u</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a031883fc1cf8682f6eb513f6dd46f47e" kindref="member">dudx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ac700564ea6800deeed698502ab8a15eb" kindref="member">dudy</ref>);</highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHaloGPUnew(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a5f61fdbd33ae88a62d35dd5235d8f375" kindref="member">v</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa5192b823cd1b71e7622d3e3c90ff163" kindref="member">dvdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aebefd731d1813ab1af3f7c282a5ba2e5" kindref="member">dvdy</ref>);</highlight></codeline>
<codeline lineno="263"><highlight class="normal"></highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.maxlevel<sp/>&gt;<sp/>XParam.minlevel)</highlight></codeline>
<codeline lineno="265"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="266"><highlight class="normal"></highlight></codeline>
<codeline lineno="267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.conserveElevation)</highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>conserveElevationGradHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>,<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>,<sp/>zb,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="271"><highlight class="normal"></highlight></codeline>
<codeline lineno="272"><highlight class="normal"></highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refine_linearGPU(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>);</highlight></codeline>
<codeline lineno="274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//refine_linearGPU(XParam,<sp/>XBlock,<sp/>XEv.zs,<sp/>XGrad.dzsdx,<sp/>XGrad.dzsdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refine_linearGPU(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1addf0f1e2e0672ff7d32890c1867d1586" kindref="member">u</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a031883fc1cf8682f6eb513f6dd46f47e" kindref="member">dudx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ac700564ea6800deeed698502ab8a15eb" kindref="member">dudy</ref>);</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refine_linearGPU(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a5f61fdbd33ae88a62d35dd5235d8f375" kindref="member">v</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa5192b823cd1b71e7622d3e3c90ff163" kindref="member">dvdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aebefd731d1813ab1af3f7c282a5ba2e5" kindref="member">dvdy</ref>);</highlight></codeline>
<codeline lineno="277"><highlight class="normal"></highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.conserveElevation)</highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>conserveElevationGPU(XParam,<sp/>XBlock,<sp/>XEv,<sp/>zb);</highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.wetdryfix)</highlight></codeline>
<codeline lineno="283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetDryProlongationGPU(XParam,<sp/>XBlock,<sp/>XEv,<sp/>zb);</highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="286"><highlight class="normal"></highlight></codeline>
<codeline lineno="287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RecalculateZsGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimfull,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>XEv,<sp/>zb);</highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="289"><highlight class="normal"></highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="291"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[1]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.h,<sp/>XGrad.dhdx,<sp/>XGrad.dhdy);</highlight></codeline>
<codeline lineno="292"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientSM<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.h,<sp/>XGrad.dhdx,<sp/>XGrad.dhdy);</highlight></codeline>
<codeline lineno="293"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="294"><highlight class="comment"></highlight></codeline>
<codeline lineno="295"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[2]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.zs,<sp/>XGrad.dzsdx,<sp/>XGrad.dzsdy);</highlight></codeline>
<codeline lineno="296"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientSM<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.zs,<sp/>XGrad.dzsdx,<sp/>XGrad.dzsdy);</highlight></codeline>
<codeline lineno="297"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="298"><highlight class="comment"></highlight></codeline>
<codeline lineno="299"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[3]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.u,<sp/>XGrad.dudx,<sp/>XGrad.dudy);</highlight></codeline>
<codeline lineno="300"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientSM<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.u,<sp/>XGrad.dudx,<sp/>XGrad.dudy);</highlight></codeline>
<codeline lineno="301"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="302"><highlight class="comment"></highlight></codeline>
<codeline lineno="303"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//gradient<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0,<sp/>streams[0]<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.v,<sp/>XGrad.dvdx,<sp/>XGrad.dvdy);</highlight></codeline>
<codeline lineno="304"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientSM<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.v,<sp/>XGrad.dvdx,<sp/>XGrad.dvdy);</highlight></codeline>
<codeline lineno="305"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="306"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="308"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int<sp/>num_streams<sp/>=<sp/>16;</highlight></codeline>
<codeline lineno="309"><highlight class="comment"></highlight></codeline>
<codeline lineno="310"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStream_t<sp/>streams[num_streams];</highlight></codeline>
<codeline lineno="311"><highlight class="comment"></highlight></codeline>
<codeline lineno="312"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="313"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="314"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));</highlight></codeline>
<codeline lineno="315"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="316"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="317"><highlight class="normal"></highlight></codeline>
<codeline lineno="318"><highlight class="normal"></highlight></codeline>
<codeline lineno="319"><highlight class="normal"></highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientedgeX<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.h,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>);</highlight></codeline>
<codeline lineno="321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradientedgeX<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.blkwidth-1,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.h,<sp/>XGrad.dhdx);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="324"><highlight class="normal"></highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientedgeY<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.h,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>);</highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradientedgeY<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT,<sp/>0&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.blkwidth-1,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.h,<sp/>XGrad.dhdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="329"><highlight class="normal"></highlight></codeline>
<codeline lineno="330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientedgeX<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.zs,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>);</highlight></codeline>
<codeline lineno="331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradientedgeX<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.zs,<sp/>XGrad.dzsdx);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="334"><highlight class="normal"></highlight></codeline>
<codeline lineno="335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientedgeY<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.zs,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradientedgeY<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.zs,<sp/>XGrad.dzsdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="339"><highlight class="normal"></highlight></codeline>
<codeline lineno="340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientedgeX<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.u,<sp/>XGrad.<ref refid="struct_gradients_p_1a031883fc1cf8682f6eb513f6dd46f47e" kindref="member">dudx</ref>);</highlight></codeline>
<codeline lineno="341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradientedgeX<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.u,<sp/>XGrad.dudx);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="344"><highlight class="normal"></highlight></codeline>
<codeline lineno="345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientedgeY<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.u,<sp/>XGrad.<ref refid="struct_gradients_p_1ac700564ea6800deeed698502ab8a15eb" kindref="member">dudy</ref>);</highlight></codeline>
<codeline lineno="346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="347"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradientedgeY<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.u,<sp/>XGrad.dudy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="349"><highlight class="normal"></highlight></codeline>
<codeline lineno="350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientedgeX<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.v,<sp/>XGrad.<ref refid="struct_gradients_p_1aa5192b823cd1b71e7622d3e3c90ff163" kindref="member">dvdx</ref>);</highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradientedgeX<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.v,<sp/>XGrad.dvdx);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="354"><highlight class="normal"></highlight></codeline>
<codeline lineno="355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientedgeY<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT2,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.delta,<sp/>XEv.v,<sp/>XGrad.<ref refid="struct_gradients_p_1aebefd731d1813ab1af3f7c282a5ba2e5" kindref="member">dvdy</ref>);</highlight></codeline>
<codeline lineno="356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gradientedgeY<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam.halowidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>XBlock.active,<sp/>XBlock.level,<sp/>(T)XParam.theta,<sp/>(T)XParam.dx,<sp/>XEv.v,<sp/>XGrad.dvdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="359"><highlight class="normal"></highlight></codeline>
<codeline lineno="360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="361"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="362"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="363"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStreamDestroy(streams[i]);</highlight></codeline>
<codeline lineno="364"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="365"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientHaloGPUnew(XParam,<sp/>XBlock,<sp/>XEv.h,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>);</highlight></codeline>
<codeline lineno="367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientHaloGPUnew(XParam,<sp/>XBlock,<sp/>XEv.zs,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="368"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientHaloGPUnew(XParam,<sp/>XBlock,<sp/>XEv.u,<sp/>XGrad.<ref refid="struct_gradients_p_1a031883fc1cf8682f6eb513f6dd46f47e" kindref="member">dudx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ac700564ea6800deeed698502ab8a15eb" kindref="member">dudy</ref>);</highlight></codeline>
<codeline lineno="369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientHaloGPUnew(XParam,<sp/>XBlock,<sp/>XEv.v,<sp/>XGrad.<ref refid="struct_gradients_p_1aa5192b823cd1b71e7622d3e3c90ff163" kindref="member">dvdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aebefd731d1813ab1af3f7c282a5ba2e5" kindref="member">dvdy</ref>);</highlight></codeline>
<codeline lineno="370"><highlight class="normal"></highlight></codeline>
<codeline lineno="371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.conserveElevation)</highlight></codeline>
<codeline lineno="372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>conserveElevationGradHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.h,<sp/>XEv.zs,<sp/>zb,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="375"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="376"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.engine<sp/>==<sp/>1)</highlight></codeline>
<codeline lineno="377"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>wet<sp/>slope<sp/>limiter</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetsloperesetXGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>XEv,<sp/>XGrad,<sp/>zb);</highlight></codeline>
<codeline lineno="380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="381"><highlight class="normal"></highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetsloperesetYGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDim,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>XEv,<sp/>XGrad,<sp/>zb);</highlight></codeline>
<codeline lineno="383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="384"><highlight class="normal"></highlight></codeline>
<codeline lineno="385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>ALso<sp/>do<sp/>the<sp/>slope<sp/>limiter<sp/>on<sp/>the<sp/>halo</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetsloperesetHaloLeftGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>XEv,<sp/>XGrad,<sp/>zb);</highlight></codeline>
<codeline lineno="387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="388"><highlight class="normal"></highlight></codeline>
<codeline lineno="389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetsloperesetHaloRightGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimLR,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>XEv,<sp/>XGrad,<sp/>zb);</highlight></codeline>
<codeline lineno="390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="391"><highlight class="normal"></highlight></codeline>
<codeline lineno="392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetsloperesetHaloBotGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>XEv,<sp/>XGrad,<sp/>zb);</highlight></codeline>
<codeline lineno="393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="394"><highlight class="normal"></highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetsloperesetHaloTopGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimBT,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>XEv,<sp/>XGrad,<sp/>zb);</highlight></codeline>
<codeline lineno="396"><highlight class="normal"></highlight></codeline>
<codeline lineno="397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="398"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="399"><highlight class="normal"></highlight></codeline>
<codeline lineno="400"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="401"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//conserveElevationGradHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.zs,<sp/>XGrad.dzsdx,<sp/>XGrad.dzsdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="402"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//conserveElevationGradHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.u,<sp/>XGrad.dudx,<sp/>XGrad.dudy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="403"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//conserveElevationGradHaloGPU(XParam,<sp/>XBlock,<sp/>XEv.v,<sp/>XGrad.dvdx,<sp/>XGrad.dvdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="404"><highlight class="normal"></highlight></codeline>
<codeline lineno="405"><highlight class="normal">}</highlight></codeline>
<codeline lineno="406"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientGPUnew&lt;float&gt;(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;float&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;float&gt;</ref><sp/>XGrad,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>zb);</highlight></codeline>
<codeline lineno="407"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientGPUnew&lt;double&gt;(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;double&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;double&gt;</ref><sp/>XGrad,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>zb);</highlight></codeline>
<codeline lineno="408"><highlight class="normal"></highlight></codeline>
<codeline lineno="409"><highlight class="normal"></highlight></codeline>
<codeline lineno="425"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradient(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/>T<sp/>theta,<sp/>T<sp/>dx,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="426"><highlight class="normal">{</highlight></codeline>
<codeline lineno="427"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>*leftblk,int<sp/>*rightblk,int*<sp/>topblk,<sp/>int<sp/>*<sp/>botblk,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="428"><highlight class="normal"></highlight></codeline>
<codeline lineno="429"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>ix<sp/>=<sp/>threadIdx.x+1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="430"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>iy<sp/>=<sp/>threadIdx.y+1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="431"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="432"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="433"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="434"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="435"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="436"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="437"><highlight class="normal"></highlight></codeline>
<codeline lineno="438"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="439"><highlight class="normal"></highlight></codeline>
<codeline lineno="440"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta<sp/>=<sp/>calcres(dx,<sp/>lev);</highlight></codeline>
<codeline lineno="441"><highlight class="normal"></highlight></codeline>
<codeline lineno="442"><highlight class="normal"></highlight></codeline>
<codeline lineno="443"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="444"><highlight class="normal"></highlight></codeline>
<codeline lineno="445"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>iright,<sp/>ileft,<sp/>ibot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="446"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>shared<sp/>array<sp/>index<sp/>to<sp/>make<sp/>the<sp/>code<sp/>bit<sp/>more<sp/>readable</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="447"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>sx<sp/>=<sp/>ix<sp/>+<sp/>halowidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="448"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>sy<sp/>=<sp/>iy<sp/>+<sp/>halowidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="449"><highlight class="normal"></highlight></codeline>
<codeline lineno="450"><highlight class="normal"></highlight></codeline>
<codeline lineno="451"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>a_l,<sp/>a_t,<sp/>a_r,<sp/>a_b,a_i;</highlight></codeline>
<codeline lineno="452"><highlight class="normal"></highlight></codeline>
<codeline lineno="453"><highlight class="normal"><sp/><sp/><sp/><sp/>a_i<sp/>=<sp/>a[i];</highlight></codeline>
<codeline lineno="454"><highlight class="normal"></highlight></codeline>
<codeline lineno="455"><highlight class="normal"></highlight></codeline>
<codeline lineno="456"><highlight class="normal"><sp/><sp/><sp/><sp/>a_l<sp/>=<sp/>a[memloc(halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>-<sp/>1,<sp/>iy,<sp/>ib)];</highlight></codeline>
<codeline lineno="457"><highlight class="normal"><sp/><sp/><sp/><sp/>a_t<sp/>=<sp/>a[memloc(halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>,<sp/>iy<sp/>+<sp/>1,<sp/>ib)];</highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/>a_r<sp/>=<sp/>a[memloc(halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>+<sp/>1,<sp/>iy,<sp/>ib)];</highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/>a_b<sp/>=<sp/>a[memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy<sp/>-<sp/>1,<sp/>ib)];</highlight></codeline>
<codeline lineno="460"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//__shared__<sp/>T<sp/>a_s[18][18];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="461"><highlight class="normal"></highlight></codeline>
<codeline lineno="462"><highlight class="normal"></highlight></codeline>
<codeline lineno="463"><highlight class="normal"></highlight></codeline>
<codeline lineno="464"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//__syncthreads();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="465"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//__syncwarp;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="466"><highlight class="normal"></highlight></codeline>
<codeline lineno="467"><highlight class="normal"><sp/><sp/><sp/><sp/>dadx[i]<sp/>=<sp/>minmod2(theta,<sp/>a_l,<sp/>a_i,<sp/>a_r)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="468"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="469"><highlight class="normal"><sp/><sp/><sp/><sp/>dady[i]<sp/>=<sp/>minmod2(theta,<sp/>a_b,<sp/>a_i,<sp/>a_t)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="470"><highlight class="normal"></highlight></codeline>
<codeline lineno="471"><highlight class="normal"></highlight></codeline>
<codeline lineno="472"><highlight class="normal">}</highlight></codeline>
<codeline lineno="473"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradient&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>theta,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>dx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dadx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dady);</highlight></codeline>
<codeline lineno="474"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradient&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>theta,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dadx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dady);</highlight></codeline>
<codeline lineno="475"><highlight class="normal"></highlight></codeline>
<codeline lineno="476"><highlight class="normal"></highlight></codeline>
<codeline lineno="477"><highlight class="normal"></highlight></codeline>
<codeline lineno="493"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientSM(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/>T<sp/>theta,<sp/>T<sp/>dx,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="494"><highlight class="normal">{</highlight></codeline>
<codeline lineno="495"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>*leftblk,int<sp/>*rightblk,int*<sp/>topblk,<sp/>int<sp/>*<sp/>botblk,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="496"><highlight class="normal"></highlight></codeline>
<codeline lineno="497"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>ix<sp/>=<sp/>threadIdx.x+1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="498"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>iy<sp/>=<sp/>threadIdx.y+1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="499"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="500"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight></codeline>
<codeline lineno="501"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="502"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="503"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="504"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="505"><highlight class="normal"></highlight></codeline>
<codeline lineno="506"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="507"><highlight class="normal"></highlight></codeline>
<codeline lineno="508"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta<sp/>=<sp/>calcres(dx,<sp/>lev);</highlight></codeline>
<codeline lineno="509"><highlight class="normal"></highlight></codeline>
<codeline lineno="510"><highlight class="normal"></highlight></codeline>
<codeline lineno="511"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="512"><highlight class="normal"></highlight></codeline>
<codeline lineno="513"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iright,<sp/>ileft,<sp/>itop,<sp/>ibot;</highlight></codeline>
<codeline lineno="514"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>shared<sp/>array<sp/>index<sp/>to<sp/>make<sp/>the<sp/>code<sp/>bit<sp/>more<sp/>readable</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="515"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>sx<sp/>=<sp/>ix<sp/>+<sp/>halowidth;</highlight></codeline>
<codeline lineno="516"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>sy<sp/>=<sp/>iy<sp/>+<sp/>halowidth;</highlight></codeline>
<codeline lineno="517"><highlight class="normal"></highlight></codeline>
<codeline lineno="518"><highlight class="normal"></highlight></codeline>
<codeline lineno="519"><highlight class="normal"></highlight></codeline>
<codeline lineno="520"><highlight class="normal"><sp/><sp/><sp/><sp/>__shared__<sp/>T<sp/>a_s[18][18];</highlight></codeline>
<codeline lineno="521"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="522"><highlight class="normal"></highlight></codeline>
<codeline lineno="523"><highlight class="normal"></highlight></codeline>
<codeline lineno="524"><highlight class="normal"><sp/><sp/><sp/><sp/>a_s[sx][sy]<sp/>=<sp/>a[i];</highlight></codeline>
<codeline lineno="525"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="526"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//syncthread<sp/>is<sp/>needed<sp/>here<sp/>?</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="528"><highlight class="normal"></highlight></codeline>
<codeline lineno="529"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>read<sp/>the<sp/>halo<sp/>around<sp/>the<sp/>tile</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="530"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(threadIdx.x<sp/>==<sp/>blockDim.x<sp/>-<sp/>1)</highlight></codeline>
<codeline lineno="531"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iright<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>+<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_s[sx<sp/>+<sp/>1][sy]<sp/>=<sp/>a[iright];</highlight></codeline>
<codeline lineno="534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="535"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="536"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="537"><highlight class="normal"></highlight></codeline>
<codeline lineno="538"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(threadIdx.x<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="539"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ileft<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>-<sp/>1,<sp/>iy,<sp/>ib);;</highlight></codeline>
<codeline lineno="541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_s[sx<sp/>-<sp/>1][sy]<sp/>=<sp/>a[ileft];</highlight></codeline>
<codeline lineno="542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="543"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="544"><highlight class="normal"></highlight></codeline>
<codeline lineno="545"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(threadIdx.y<sp/>==<sp/>blockDim.y<sp/>-<sp/>1)</highlight></codeline>
<codeline lineno="546"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itop<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy<sp/>+<sp/>1,<sp/>ib);;</highlight></codeline>
<codeline lineno="548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_s[sx][sy<sp/>+<sp/>1]<sp/>=<sp/>a[itop];</highlight></codeline>
<codeline lineno="549"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="550"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="551"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="552"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(threadIdx.y<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="553"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ibot<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="555"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_s[sx][sy<sp/>-<sp/>1]<sp/>=<sp/>a[ibot];</highlight></codeline>
<codeline lineno="556"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="557"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="558"><highlight class="normal"></highlight></codeline>
<codeline lineno="559"><highlight class="normal"><sp/><sp/><sp/><sp/>__syncthreads();</highlight></codeline>
<codeline lineno="560"><highlight class="normal"></highlight></codeline>
<codeline lineno="561"><highlight class="normal"></highlight></codeline>
<codeline lineno="562"><highlight class="normal"></highlight></codeline>
<codeline lineno="563"><highlight class="normal"><sp/><sp/><sp/><sp/>dadx[i]<sp/>=<sp/>minmod2(theta,<sp/>a_s[sx<sp/>-<sp/>1][sy],<sp/>a_s[sx][sy],<sp/>a_s[sx<sp/>+<sp/>1][sy])<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="564"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="565"><highlight class="normal"><sp/><sp/><sp/><sp/>dady[i]<sp/>=<sp/>minmod2(theta,<sp/>a_s[sx][sy<sp/>-<sp/>1],<sp/>a_s[sx][sy],<sp/>a_s[sx][sy<sp/>+<sp/>1])<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="566"><highlight class="normal"></highlight></codeline>
<codeline lineno="567"><highlight class="normal"></highlight></codeline>
<codeline lineno="568"><highlight class="normal">}</highlight></codeline>
<codeline lineno="569"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientSM&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>theta,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>dx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dadx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dady);</highlight></codeline>
<codeline lineno="570"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientSM&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>theta,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dadx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dady);</highlight></codeline>
<codeline lineno="571"><highlight class="normal"></highlight></codeline>
<codeline lineno="572"><highlight class="normal"></highlight></codeline>
<codeline lineno="573"><highlight class="normal"></highlight></codeline>
<codeline lineno="589"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientSMB(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/>T<sp/>theta,<sp/>T<sp/>dx,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="590"><highlight class="normal">{</highlight></codeline>
<codeline lineno="591"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>*leftblk,int<sp/>*rightblk,int*<sp/>topblk,<sp/>int<sp/>*<sp/>botblk,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="592"><highlight class="normal"></highlight></codeline>
<codeline lineno="593"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>ix<sp/>=<sp/>threadIdx.x+1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="594"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>iy<sp/>=<sp/>threadIdx.y+1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="595"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>18;</highlight></codeline>
<codeline lineno="596"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight></codeline>
<codeline lineno="597"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x-1;</highlight></codeline>
<codeline lineno="598"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y-1;</highlight></codeline>
<codeline lineno="599"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="600"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="601"><highlight class="normal"></highlight></codeline>
<codeline lineno="602"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="603"><highlight class="normal"></highlight></codeline>
<codeline lineno="604"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta<sp/>=<sp/>calcres(dx,<sp/>lev);</highlight></codeline>
<codeline lineno="605"><highlight class="normal"></highlight></codeline>
<codeline lineno="606"><highlight class="normal"></highlight></codeline>
<codeline lineno="607"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="608"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iright,<sp/>ileft,<sp/>itop,<sp/>ibot;</highlight></codeline>
<codeline lineno="609"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>shared<sp/>array<sp/>index<sp/>to<sp/>make<sp/>the<sp/>code<sp/>bit<sp/>more<sp/>readable</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="610"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>sx<sp/>=<sp/>ix<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="611"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>sy<sp/>=<sp/>iy<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="612"><highlight class="normal"></highlight></codeline>
<codeline lineno="613"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="614"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>o<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>sx,<sp/>sy,<sp/>ib);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="615"><highlight class="normal"></highlight></codeline>
<codeline lineno="616"><highlight class="normal"><sp/><sp/><sp/><sp/>__shared__<sp/>T<sp/>a_s[18][18];</highlight></codeline>
<codeline lineno="617"><highlight class="normal"></highlight></codeline>
<codeline lineno="618"><highlight class="normal"></highlight></codeline>
<codeline lineno="619"><highlight class="normal"></highlight></codeline>
<codeline lineno="620"><highlight class="normal"></highlight></codeline>
<codeline lineno="621"><highlight class="normal"><sp/><sp/><sp/><sp/>a_s[sx][sy]<sp/>=<sp/>a[i];</highlight></codeline>
<codeline lineno="622"><highlight class="normal"><sp/><sp/><sp/><sp/>__syncthreads();</highlight></codeline>
<codeline lineno="623"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//syncthread<sp/>is<sp/>needed<sp/>here<sp/>?</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="624"><highlight class="normal"></highlight></codeline>
<codeline lineno="625"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>aleft,<sp/>aright,<sp/>atop,<sp/>abot;</highlight></codeline>
<codeline lineno="626"><highlight class="normal"><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>a_s[sx<sp/>-<sp/>1][sy];</highlight></codeline>
<codeline lineno="627"><highlight class="normal"><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>a_s[sx<sp/>+<sp/>1][sy];</highlight></codeline>
<codeline lineno="628"><highlight class="normal"><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>a_s[sx][sy<sp/>+<sp/>1];</highlight></codeline>
<codeline lineno="629"><highlight class="normal"><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>a_s[sx][sy<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="630"><highlight class="normal"></highlight></codeline>
<codeline lineno="631"><highlight class="normal"></highlight></codeline>
<codeline lineno="632"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>0<sp/>&amp;&amp;<sp/>ix<sp/>&lt;<sp/>16<sp/>&amp;&amp;<sp/>iy<sp/>&gt;=0<sp/>&amp;&amp;<sp/>iy<sp/>&lt;<sp/>16)</highlight></codeline>
<codeline lineno="633"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="634"><highlight class="normal"></highlight></codeline>
<codeline lineno="635"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dadx[i]<sp/>=<sp/>minmod2(theta,<sp/>aleft,<sp/>a_s[sx][sy],<sp/>aright)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="636"><highlight class="normal"></highlight></codeline>
<codeline lineno="637"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dady[i]<sp/>=<sp/>minmod2(theta,<sp/>abot,<sp/>a_s[sx][sy],<sp/>atop)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="638"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="639"><highlight class="normal"></highlight></codeline>
<codeline lineno="640"><highlight class="normal">}</highlight></codeline>
<codeline lineno="641"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientSMB&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>theta,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>dx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dadx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dady);</highlight></codeline>
<codeline lineno="642"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientSMB&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>theta,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dadx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dady);</highlight></codeline>
<codeline lineno="643"><highlight class="normal"></highlight></codeline>
<codeline lineno="659"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientSMC(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/>T<sp/>theta,<sp/>T<sp/>dx,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="660"><highlight class="normal">{</highlight></codeline>
<codeline lineno="661"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>*leftblk,int<sp/>*rightblk,int*<sp/>topblk,<sp/>int<sp/>*<sp/>botblk,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="662"><highlight class="normal"></highlight></codeline>
<codeline lineno="663"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>ix<sp/>=<sp/>threadIdx.x+1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="664"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>iy<sp/>=<sp/>threadIdx.y+1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="665"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="666"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>flatenwidth<sp/>=<sp/>blockDim.x<sp/>*<sp/>blockDim.y;</highlight></codeline>
<codeline lineno="667"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight></codeline>
<codeline lineno="668"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="669"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="670"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="671"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="672"><highlight class="normal"></highlight></codeline>
<codeline lineno="673"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="674"><highlight class="normal"></highlight></codeline>
<codeline lineno="675"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta<sp/>=<sp/>calcres(dx,<sp/>lev);</highlight></codeline>
<codeline lineno="676"><highlight class="normal"></highlight></codeline>
<codeline lineno="677"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ism<sp/>=ix<sp/>+<sp/>iy<sp/>*<sp/>blockDim.x;</highlight></codeline>
<codeline lineno="678"><highlight class="normal"></highlight></codeline>
<codeline lineno="679"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>istore<sp/>=<sp/>ism<sp/>+<sp/>ib<sp/>*<sp/>(blkmemwidth<sp/>*<sp/>blkmemwidth);</highlight></codeline>
<codeline lineno="680"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//(i<sp/>+<sp/>halowidth)<sp/>+<sp/>(j<sp/>+<sp/>halowidth)<sp/>*<sp/>blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>(blkmemwidth<sp/>*<sp/>blkmemwidth);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="681"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="682"><highlight class="normal"></highlight></codeline>
<codeline lineno="683"><highlight class="normal"></highlight></codeline>
<codeline lineno="684"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ileft,<sp/>iright,<sp/>itop,<sp/>ibot,<sp/>i,<sp/>iwrite;</highlight></codeline>
<codeline lineno="685"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="686"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="687"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>shared<sp/>array<sp/>index<sp/>to<sp/>make<sp/>the<sp/>code<sp/>bit<sp/>more<sp/>readable</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="688"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>sx<sp/>=<sp/>ix<sp/>+<sp/>halowidth;</highlight></codeline>
<codeline lineno="689"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>sy<sp/>=<sp/>iy<sp/>+<sp/>halowidth;</highlight></codeline>
<codeline lineno="690"><highlight class="normal"></highlight></codeline>
<codeline lineno="691"><highlight class="normal"></highlight></codeline>
<codeline lineno="692"><highlight class="normal"></highlight></codeline>
<codeline lineno="693"><highlight class="normal"><sp/><sp/><sp/><sp/>__shared__<sp/>T<sp/>a_s[324];</highlight></codeline>
<codeline lineno="694"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//__shared__<sp/>T<sp/>dadx_out[18<sp/>*<sp/>18];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="695"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//__shared__<sp/>T<sp/>dady_out[18<sp/>*<sp/>18];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="696"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//__shared__<sp/>T<sp/>a_s[324];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="697"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//__shared__<sp/>T<sp/>a_left[324];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="698"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//__shared__<sp/>T<sp/>a_right[324];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="699"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//__shared__<sp/>T<sp/>a_top[324];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="700"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//__shared__<sp/>T<sp/>a_bot[324];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="701"><highlight class="normal"></highlight></codeline>
<codeline lineno="702"><highlight class="normal"></highlight></codeline>
<codeline lineno="703"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="704"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//(i<sp/>+<sp/>halowidth)<sp/>+<sp/>(j<sp/>+<sp/>halowidth)<sp/>*<sp/>blkmemwidth<sp/>+<sp/>ib<sp/>*<sp/>(blkmemwidth<sp/>*<sp/>blkmemwidth);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="705"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="706"><highlight class="normal"></highlight></codeline>
<codeline lineno="707"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="708"><highlight class="normal"><sp/><sp/><sp/><sp/>a_s[ism]<sp/>=<sp/>a[istore];</highlight></codeline>
<codeline lineno="709"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="710"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ism<sp/>&lt;<sp/>(324<sp/>-<sp/>(flatenwidth)))</highlight></codeline>
<codeline lineno="711"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a_s[ism<sp/>+<sp/>flatenwidth]<sp/>=<sp/>a[istore<sp/>+<sp/>flatenwidth];</highlight></codeline>
<codeline lineno="713"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="714"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="715"><highlight class="normal"></highlight></codeline>
<codeline lineno="716"><highlight class="normal"><sp/><sp/><sp/><sp/>__syncthreads();</highlight></codeline>
<codeline lineno="717"><highlight class="normal"><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>0);</highlight></codeline>
<codeline lineno="718"><highlight class="normal"><sp/><sp/><sp/><sp/>ileft<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>-<sp/>1,<sp/>iy,<sp/>0);</highlight></codeline>
<codeline lineno="719"><highlight class="normal"><sp/><sp/><sp/><sp/>iright<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>+<sp/>1,<sp/>iy,<sp/>0);</highlight></codeline>
<codeline lineno="720"><highlight class="normal"><sp/><sp/><sp/><sp/>itop<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy<sp/>+<sp/>1,<sp/>0);</highlight></codeline>
<codeline lineno="721"><highlight class="normal"><sp/><sp/><sp/><sp/>ibot<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy<sp/>-<sp/>1,<sp/>0);</highlight></codeline>
<codeline lineno="722"><highlight class="normal"><sp/><sp/><sp/><sp/>iwrite<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="723"><highlight class="normal"></highlight></codeline>
<codeline lineno="724"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//a_left[i]<sp/>=<sp/>a_s[ileft];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="725"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//a_right[i]<sp/>=<sp/>a_s[iright];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="726"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//a_top[i]<sp/>=<sp/>a_s[itop];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="727"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//a_bot[i]<sp/>=<sp/>a_s[ibot];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="728"><highlight class="normal"></highlight></codeline>
<codeline lineno="729"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dadx[iwrite]<sp/>=<sp/>minmod2(theta,<sp/>a_left[i],<sp/>a_s[i],<sp/>a_right[i])<sp/>/<sp/>delta;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="730"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dady[iwrite]<sp/>=<sp/>minmod2(theta,<sp/>a_bot[i],<sp/>a_s[i],<sp/>a_top[i])<sp/>/<sp/>delta;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="731"><highlight class="normal"><sp/><sp/><sp/><sp/>dadx[iwrite]<sp/>=<sp/>minmod2(theta,<sp/>a_s[ileft],<sp/>a_s[i],<sp/>a_s[iright])<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="732"><highlight class="normal"></highlight></codeline>
<codeline lineno="733"><highlight class="normal"><sp/><sp/><sp/><sp/>dady[iwrite]<sp/>=<sp/>minmod2(theta,<sp/>a_s[ibot],<sp/>a_s[i],<sp/>a_s[itop])<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="734"><highlight class="normal"></highlight></codeline>
<codeline lineno="735"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="736"><highlight class="comment"><sp/><sp/><sp/><sp/>dadx_out[i]<sp/>=<sp/>minmod2(theta,<sp/>a_s[ileft],<sp/>a_s[i],<sp/>a_s[iright])<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="737"><highlight class="comment"><sp/><sp/><sp/><sp/>dady_out[i]<sp/>=<sp/>minmod2(theta,<sp/>a_s[ibot],<sp/>a_s[i],<sp/>a_s[itop])<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="738"><highlight class="comment"></highlight></codeline>
<codeline lineno="739"><highlight class="comment"></highlight></codeline>
<codeline lineno="740"><highlight class="comment"><sp/><sp/><sp/><sp/>dadx[istore]<sp/>=<sp/>dadx_out[ism];//<sp/>=<sp/>a[istore];</highlight></codeline>
<codeline lineno="741"><highlight class="comment"><sp/><sp/><sp/><sp/>dady[istore]<sp/>=<sp/>dady_out[ism];</highlight></codeline>
<codeline lineno="742"><highlight class="comment"></highlight></codeline>
<codeline lineno="743"><highlight class="comment"><sp/><sp/><sp/><sp/>if<sp/>(ism<sp/>&lt;<sp/>(324<sp/>-<sp/>(flatenwidth)))</highlight></codeline>
<codeline lineno="744"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="745"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dadx[istore<sp/>+<sp/>flatenwidth]<sp/>=<sp/>dadx_out[ism<sp/>+<sp/>flatenwidth];</highlight></codeline>
<codeline lineno="746"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dady[istore<sp/>+<sp/>flatenwidth]<sp/>=<sp/>dady_out[ism<sp/>+<sp/>flatenwidth];</highlight></codeline>
<codeline lineno="747"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="748"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="749"><highlight class="normal"></highlight></codeline>
<codeline lineno="750"><highlight class="normal"></highlight></codeline>
<codeline lineno="751"><highlight class="normal">}</highlight></codeline>
<codeline lineno="752"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientSMC&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>theta,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>dx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dadx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dady);</highlight></codeline>
<codeline lineno="753"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientSMC&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>theta,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dadx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dady);</highlight></codeline>
<codeline lineno="754"><highlight class="normal"></highlight></codeline>
<codeline lineno="755"><highlight class="normal"></highlight></codeline>
<codeline lineno="756"><highlight class="normal"></highlight></codeline>
<codeline lineno="771"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientedgeX(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/>T<sp/>theta,<sp/>T<sp/>dx,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx)</highlight></codeline>
<codeline lineno="772"><highlight class="normal">{</highlight></codeline>
<codeline lineno="773"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>*leftblk,int<sp/>*rightblk,int*<sp/>topblk,<sp/>int<sp/>*<sp/>botblk,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="774"><highlight class="normal"></highlight></codeline>
<codeline lineno="775"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>ix<sp/>=<sp/>threadIdx.x+1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="776"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>iy<sp/>=<sp/>threadIdx.y+1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="777"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.y<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="778"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="779"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>ix<sp/>=<sp/>threadIdx.x;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="780"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix;</highlight></codeline>
<codeline lineno="781"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="782"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="783"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="784"><highlight class="normal"></highlight></codeline>
<codeline lineno="785"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(threadIdx.x<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="786"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ix<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="788"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="789"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="790"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="791"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ix<sp/>=<sp/>blockDim.y<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="792"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="793"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="794"><highlight class="normal"></highlight></codeline>
<codeline lineno="795"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="796"><highlight class="normal"></highlight></codeline>
<codeline lineno="797"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta<sp/>=<sp/>calcres(dx,<sp/>lev);</highlight></codeline>
<codeline lineno="798"><highlight class="normal"></highlight></codeline>
<codeline lineno="799"><highlight class="normal"></highlight></codeline>
<codeline lineno="800"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="801"><highlight class="normal"></highlight></codeline>
<codeline lineno="802"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>iright,<sp/>ileft,<sp/>ibot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="803"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>shared<sp/>array<sp/>index<sp/>to<sp/>make<sp/>the<sp/>code<sp/>bit<sp/>more<sp/>readable</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="804"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>sx<sp/>=<sp/>ix<sp/>+<sp/>halowidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="805"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>sy<sp/>=<sp/>iy<sp/>+<sp/>halowidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="806"><highlight class="normal"></highlight></codeline>
<codeline lineno="807"><highlight class="normal"></highlight></codeline>
<codeline lineno="808"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>a_l,<sp/>a_r,<sp/>a_i;</highlight></codeline>
<codeline lineno="809"><highlight class="normal"></highlight></codeline>
<codeline lineno="810"><highlight class="normal"><sp/><sp/><sp/><sp/>a_i<sp/>=<sp/>a[i];</highlight></codeline>
<codeline lineno="811"><highlight class="normal"></highlight></codeline>
<codeline lineno="812"><highlight class="normal"></highlight></codeline>
<codeline lineno="813"><highlight class="normal"><sp/><sp/><sp/><sp/>a_l<sp/>=<sp/>a[memloc(halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>-<sp/>1,<sp/>iy,<sp/>ib)];</highlight></codeline>
<codeline lineno="814"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//a_t<sp/>=<sp/>a[memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy<sp/>+<sp/>1,<sp/>ib)];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="815"><highlight class="normal"><sp/><sp/><sp/><sp/>a_r<sp/>=<sp/>a[memloc(halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>+<sp/>1,<sp/>iy,<sp/>ib)];</highlight></codeline>
<codeline lineno="816"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//a_b<sp/>=<sp/>a[memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy<sp/>-<sp/>1,<sp/>ib)];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="817"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//__shared__<sp/>T<sp/>a_s[18][18];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="818"><highlight class="normal"></highlight></codeline>
<codeline lineno="819"><highlight class="normal"></highlight></codeline>
<codeline lineno="820"><highlight class="normal"></highlight></codeline>
<codeline lineno="821"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//__syncthreads();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="822"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//__syncwarp;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="823"><highlight class="normal"></highlight></codeline>
<codeline lineno="824"><highlight class="normal"><sp/><sp/><sp/><sp/>dadx[i]<sp/>=<sp/>minmod2(theta,<sp/>a_l,<sp/>a_i,<sp/>a_r)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="825"><highlight class="normal"></highlight></codeline>
<codeline lineno="826"><highlight class="normal"></highlight></codeline>
<codeline lineno="827"><highlight class="normal"></highlight></codeline>
<codeline lineno="828"><highlight class="normal"></highlight></codeline>
<codeline lineno="829"><highlight class="normal">}</highlight></codeline>
<codeline lineno="830"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientedgeX&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>theta,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>dx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dadx);</highlight></codeline>
<codeline lineno="831"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientedgeX&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>theta,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dadx);</highlight></codeline>
<codeline lineno="832"><highlight class="normal"></highlight></codeline>
<codeline lineno="833"><highlight class="normal"></highlight></codeline>
<codeline lineno="834"><highlight class="normal"></highlight></codeline>
<codeline lineno="849"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientedgeY(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/>T<sp/>theta,<sp/>T<sp/>dx,<sp/>T*<sp/>a,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="850"><highlight class="normal">{</highlight></codeline>
<codeline lineno="851"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>*leftblk,int<sp/>*rightblk,int*<sp/>topblk,<sp/>int<sp/>*<sp/>botblk,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="852"><highlight class="normal"></highlight></codeline>
<codeline lineno="853"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>ix<sp/>=<sp/>threadIdx.x+1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="854"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>iy<sp/>=<sp/>threadIdx.y+1;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="855"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="856"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="857"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="858"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy;</highlight></codeline>
<codeline lineno="859"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>iy<sp/>=<sp/>threadIdx.y;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="860"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="861"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>active[ibl];</highlight></codeline>
<codeline lineno="862"><highlight class="normal"></highlight></codeline>
<codeline lineno="863"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>level[ib];</highlight></codeline>
<codeline lineno="864"><highlight class="normal"></highlight></codeline>
<codeline lineno="865"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta<sp/>=<sp/>calcres(dx,<sp/>lev);</highlight></codeline>
<codeline lineno="866"><highlight class="normal"></highlight></codeline>
<codeline lineno="867"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(threadIdx.y<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="868"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iy<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="870"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="871"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="872"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="873"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iy<sp/>=<sp/>blockDim.x<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="874"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="875"><highlight class="normal"></highlight></codeline>
<codeline lineno="876"><highlight class="normal"></highlight></codeline>
<codeline lineno="877"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="878"><highlight class="normal"></highlight></codeline>
<codeline lineno="879"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>iright,<sp/>ileft,<sp/>ibot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="880"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>shared<sp/>array<sp/>index<sp/>to<sp/>make<sp/>the<sp/>code<sp/>bit<sp/>more<sp/>readable</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="881"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>sx<sp/>=<sp/>ix<sp/>+<sp/>halowidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="882"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>sy<sp/>=<sp/>iy<sp/>+<sp/>halowidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="883"><highlight class="normal"></highlight></codeline>
<codeline lineno="884"><highlight class="normal"></highlight></codeline>
<codeline lineno="885"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/><sp/>a_t,<sp/>a_b,<sp/>a_i;</highlight></codeline>
<codeline lineno="886"><highlight class="normal"></highlight></codeline>
<codeline lineno="887"><highlight class="normal"><sp/><sp/><sp/><sp/>a_i<sp/>=<sp/>a[i];</highlight></codeline>
<codeline lineno="888"><highlight class="normal"></highlight></codeline>
<codeline lineno="889"><highlight class="normal"></highlight></codeline>
<codeline lineno="890"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//a_l<sp/>=<sp/>a[memloc(halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>-<sp/>1,<sp/>iy,<sp/>ib)];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="891"><highlight class="normal"><sp/><sp/><sp/><sp/>a_t<sp/>=<sp/>a[memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy<sp/>+<sp/>1,<sp/>ib)];</highlight></codeline>
<codeline lineno="892"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//a_r<sp/>=<sp/>a[memloc(halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>+<sp/>1,<sp/>iy,<sp/>ib)];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="893"><highlight class="normal"><sp/><sp/><sp/><sp/>a_b<sp/>=<sp/>a[memloc(halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy<sp/>-<sp/>1,<sp/>ib)];</highlight></codeline>
<codeline lineno="894"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//__shared__<sp/>T<sp/>a_s[18][18];</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="895"><highlight class="normal"></highlight></codeline>
<codeline lineno="896"><highlight class="normal"></highlight></codeline>
<codeline lineno="897"><highlight class="normal"></highlight></codeline>
<codeline lineno="898"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//__syncthreads();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="899"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//__syncwarp;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="900"><highlight class="normal"></highlight></codeline>
<codeline lineno="901"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dadx[i]<sp/>=<sp/>minmod2(theta,<sp/>a_l,<sp/>a_i,<sp/>a_r)<sp/>/<sp/>delta;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="902"><highlight class="normal"></highlight></codeline>
<codeline lineno="903"><highlight class="normal"><sp/><sp/><sp/><sp/>dady[i]<sp/>=<sp/>minmod2(theta,<sp/>a_b,<sp/>a_i,<sp/>a_t)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="904"><highlight class="normal"></highlight></codeline>
<codeline lineno="905"><highlight class="normal"></highlight></codeline>
<codeline lineno="906"><highlight class="normal">}</highlight></codeline>
<codeline lineno="907"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientedgeY&lt;float&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>theta,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>dx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dady);</highlight></codeline>
<codeline lineno="908"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientedgeY&lt;double&gt;(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>halowidth,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>active,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>level,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>theta,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dady);</highlight></codeline>
<codeline lineno="909"><highlight class="normal"></highlight></codeline>
<codeline lineno="910"><highlight class="normal"></highlight></codeline>
<codeline lineno="911"><highlight class="normal"></highlight></codeline>
<codeline lineno="921"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientC(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref><sp/>XBlock,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="922"><highlight class="normal">{</highlight></codeline>
<codeline lineno="923"><highlight class="normal"></highlight></codeline>
<codeline lineno="924"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,ib;</highlight></codeline>
<codeline lineno="925"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>xplus,<sp/>xminus,<sp/>yplus,<sp/>yminus;</highlight></codeline>
<codeline lineno="926"><highlight class="normal"></highlight></codeline>
<codeline lineno="927"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta;</highlight></codeline>
<codeline lineno="928"><highlight class="normal"></highlight></codeline>
<codeline lineno="929"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="930"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="931"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="932"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delta<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib]);</highlight></codeline>
<codeline lineno="933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>0;<sp/>iy<sp/>&lt;<sp/>XParam.blkwidth;<sp/>iy++)</highlight></codeline>
<codeline lineno="934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="935"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>0;<sp/>ix<sp/>&lt;<sp/>XParam.blkwidth;<sp/>ix++)</highlight></codeline>
<codeline lineno="936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>ix,iy,ib);</highlight></codeline>
<codeline lineno="938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xplus<sp/>=<sp/>memloc(XParam,<sp/>ix+1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xminus<sp/>=<sp/>memloc(XParam,<sp/>ix-1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>yplus<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>iy+1,<sp/>ib);</highlight></codeline>
<codeline lineno="943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>yminus<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>iy-1,<sp/>ib);</highlight></codeline>
<codeline lineno="944"><highlight class="normal"></highlight></codeline>
<codeline lineno="945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dadx[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>a[xminus],<sp/>a[i],<sp/>a[xplus])<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="946"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dady[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>a[yminus],<sp/>a[i],<sp/>a[yplus])<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="947"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="948"><highlight class="normal"></highlight></codeline>
<codeline lineno="949"><highlight class="normal"></highlight></codeline>
<codeline lineno="950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="951"><highlight class="normal"></highlight></codeline>
<codeline lineno="952"><highlight class="normal"></highlight></codeline>
<codeline lineno="953"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="954"><highlight class="normal"></highlight></codeline>
<codeline lineno="955"><highlight class="normal"></highlight></codeline>
<codeline lineno="956"><highlight class="normal"></highlight></codeline>
<codeline lineno="957"><highlight class="normal">}</highlight></codeline>
<codeline lineno="958"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientC&lt;float&gt;(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;float&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>a,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dadx,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">*<sp/>dady);</highlight></codeline>
<codeline lineno="959"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientC&lt;double&gt;(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;double&gt;</ref><sp/>XBlock,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>a,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dadx,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>dady);</highlight></codeline>
<codeline lineno="960"><highlight class="normal"></highlight></codeline>
<codeline lineno="971"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientCPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>XGrad,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="972"><highlight class="normal">{</highlight></codeline>
<codeline lineno="973"><highlight class="normal"></highlight></codeline>
<codeline lineno="974"><highlight class="normal"></highlight></codeline>
<codeline lineno="975"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t0(&amp;gradientC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>);</highlight></codeline>
<codeline lineno="976"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t1(&amp;gradientC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="977"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t2(&amp;gradientC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1addf0f1e2e0672ff7d32890c1867d1586" kindref="member">u</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a031883fc1cf8682f6eb513f6dd46f47e" kindref="member">dudx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ac700564ea6800deeed698502ab8a15eb" kindref="member">dudy</ref>);</highlight></codeline>
<codeline lineno="978"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t3(&amp;gradientC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a5f61fdbd33ae88a62d35dd5235d8f375" kindref="member">v</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa5192b823cd1b71e7622d3e3c90ff163" kindref="member">dvdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aebefd731d1813ab1af3f7c282a5ba2e5" kindref="member">dvdy</ref>);</highlight></codeline>
<codeline lineno="979"><highlight class="normal"></highlight></codeline>
<codeline lineno="980"><highlight class="normal"><sp/><sp/><sp/><sp/>t0.join();</highlight></codeline>
<codeline lineno="981"><highlight class="normal"><sp/><sp/><sp/><sp/>t1.join();</highlight></codeline>
<codeline lineno="982"><highlight class="normal"><sp/><sp/><sp/><sp/>t2.join();</highlight></codeline>
<codeline lineno="983"><highlight class="normal"><sp/><sp/><sp/><sp/>t3.join();</highlight></codeline>
<codeline lineno="984"><highlight class="normal"></highlight></codeline>
<codeline lineno="985"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//fillHalo(XParam,<sp/>XBlock,<sp/>XGrad);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="986"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="987"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHalo(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>);</highlight></codeline>
<codeline lineno="988"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHalo(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="989"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHalo(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1addf0f1e2e0672ff7d32890c1867d1586" kindref="member">u</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a031883fc1cf8682f6eb513f6dd46f47e" kindref="member">dudx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ac700564ea6800deeed698502ab8a15eb" kindref="member">dudy</ref>);</highlight></codeline>
<codeline lineno="990"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHalo(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a5f61fdbd33ae88a62d35dd5235d8f375" kindref="member">v</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa5192b823cd1b71e7622d3e3c90ff163" kindref="member">dvdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aebefd731d1813ab1af3f7c282a5ba2e5" kindref="member">dvdy</ref>);</highlight></codeline>
<codeline lineno="991"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="992"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.conserveElevation)</highlight></codeline>
<codeline lineno="993"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="994"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>conserveElevationGradHalo(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>,<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>,<sp/>zb,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="995"><highlight class="normal"></highlight></codeline>
<codeline lineno="996"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="997"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="998"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="999"><highlight class="normal"><sp/><sp/><sp/><sp/>refine_linear(XParam,XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>);</highlight></codeline>
<codeline lineno="1000"><highlight class="normal"><sp/><sp/><sp/><sp/>refine_linear(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1addf0f1e2e0672ff7d32890c1867d1586" kindref="member">u</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a031883fc1cf8682f6eb513f6dd46f47e" kindref="member">dudx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ac700564ea6800deeed698502ab8a15eb" kindref="member">dudy</ref>);</highlight></codeline>
<codeline lineno="1001"><highlight class="normal"><sp/><sp/><sp/><sp/>refine_linear(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a5f61fdbd33ae88a62d35dd5235d8f375" kindref="member">v</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa5192b823cd1b71e7622d3e3c90ff163" kindref="member">dvdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aebefd731d1813ab1af3f7c282a5ba2e5" kindref="member">dvdy</ref>);</highlight></codeline>
<codeline lineno="1002"><highlight class="normal"></highlight></codeline>
<codeline lineno="1003"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.conserveElevation)</highlight></codeline>
<codeline lineno="1004"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>conserveElevation(XParam,<sp/>XBlock,<sp/>XEv,<sp/>zb);</highlight></codeline>
<codeline lineno="1006"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1007"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.wetdryfix)</highlight></codeline>
<codeline lineno="1008"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetDryProlongation(XParam,<sp/>XBlock,<sp/>XEv,<sp/>zb);</highlight></codeline>
<codeline lineno="1010"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1011"><highlight class="normal"></highlight></codeline>
<codeline lineno="1012"><highlight class="normal"><sp/><sp/><sp/><sp/>RecalculateZs(XParam,<sp/>XBlock,<sp/>XEv,<sp/>zb);</highlight></codeline>
<codeline lineno="1013"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1014"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t4(&amp;gradientC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>);</highlight></codeline>
<codeline lineno="1015"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t5(&amp;gradientC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="1016"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t6(&amp;gradientC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1addf0f1e2e0672ff7d32890c1867d1586" kindref="member">u</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a031883fc1cf8682f6eb513f6dd46f47e" kindref="member">dudx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ac700564ea6800deeed698502ab8a15eb" kindref="member">dudy</ref>);</highlight></codeline>
<codeline lineno="1017"><highlight class="normal"><sp/><sp/><sp/><sp/>std::thread<sp/>t7(&amp;gradientC&lt;T&gt;,<sp/>XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a5f61fdbd33ae88a62d35dd5235d8f375" kindref="member">v</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa5192b823cd1b71e7622d3e3c90ff163" kindref="member">dvdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aebefd731d1813ab1af3f7c282a5ba2e5" kindref="member">dvdy</ref>);</highlight></codeline>
<codeline lineno="1018"><highlight class="normal"></highlight></codeline>
<codeline lineno="1019"><highlight class="normal"><sp/><sp/><sp/><sp/>t4.join();</highlight></codeline>
<codeline lineno="1020"><highlight class="normal"><sp/><sp/><sp/><sp/>t5.join();</highlight></codeline>
<codeline lineno="1021"><highlight class="normal"><sp/><sp/><sp/><sp/>t6.join();</highlight></codeline>
<codeline lineno="1022"><highlight class="normal"><sp/><sp/><sp/><sp/>t7.join();</highlight></codeline>
<codeline lineno="1023"><highlight class="normal"></highlight></codeline>
<codeline lineno="1024"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHalo(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>);</highlight></codeline>
<codeline lineno="1025"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHalo(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="1026"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHalo(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1addf0f1e2e0672ff7d32890c1867d1586" kindref="member">u</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1a031883fc1cf8682f6eb513f6dd46f47e" kindref="member">dudx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ac700564ea6800deeed698502ab8a15eb" kindref="member">dudy</ref>);</highlight></codeline>
<codeline lineno="1027"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHalo(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a5f61fdbd33ae88a62d35dd5235d8f375" kindref="member">v</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa5192b823cd1b71e7622d3e3c90ff163" kindref="member">dvdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aebefd731d1813ab1af3f7c282a5ba2e5" kindref="member">dvdy</ref>);</highlight></codeline>
<codeline lineno="1028"><highlight class="normal"></highlight></codeline>
<codeline lineno="1029"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.conserveElevation)</highlight></codeline>
<codeline lineno="1030"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>conserveElevationGradHalo(XParam,<sp/>XBlock,<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>,<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>,<sp/>zb,<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>,<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>);</highlight></codeline>
<codeline lineno="1032"><highlight class="normal"></highlight></codeline>
<codeline lineno="1033"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1034"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1035"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XParam.engine<sp/>==<sp/>1)</highlight></codeline>
<codeline lineno="1036"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetsloperesetCPU(XParam,<sp/>XBlock,<sp/>XEv,<sp/>XGrad,<sp/>zb);</highlight></codeline>
<codeline lineno="1038"><highlight class="normal"></highlight></codeline>
<codeline lineno="1039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetsloperesetHaloLeftCPU(XParam,<sp/>XBlock,<sp/>XEv,<sp/>XGrad,<sp/>zb);</highlight></codeline>
<codeline lineno="1040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetsloperesetHaloRightCPU(XParam,<sp/>XBlock,<sp/>XEv,<sp/>XGrad,<sp/>zb);</highlight></codeline>
<codeline lineno="1041"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetsloperesetHaloBotCPU(XParam,<sp/>XBlock,<sp/>XEv,<sp/>XGrad,<sp/>zb);</highlight></codeline>
<codeline lineno="1042"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WetsloperesetHaloTopCPU(XParam,<sp/>XBlock,<sp/>XEv,<sp/>XGrad,<sp/>zb);</highlight></codeline>
<codeline lineno="1043"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1044"><highlight class="normal"></highlight></codeline>
<codeline lineno="1045"><highlight class="normal"></highlight></codeline>
<codeline lineno="1046"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1047"><highlight class="normal"></highlight></codeline>
<codeline lineno="1048"><highlight class="normal"></highlight></codeline>
<codeline lineno="1049"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//conserveElevationGradHalo(XParam,<sp/>XBlock,<sp/>XEv.zs,<sp/>XGrad.dzsdx,<sp/>XGrad.dzsdy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1050"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//conserveElevationGradHalo(XParam,<sp/>XBlock,<sp/>XEv.u,<sp/>XGrad.dudx,<sp/>XGrad.dudy);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1051"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//conserveElevationGradHalo(XParam,<sp/>XBlock,<sp/>XEv.v,<sp/>XGrad.dvdx,<sp/>XGrad.dvdyythhhhhhhhhg);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1052"><highlight class="normal"></highlight></codeline>
<codeline lineno="1053"><highlight class="normal"></highlight></codeline>
<codeline lineno="1054"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1055"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientCPU&lt;float&gt;(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;float&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;float&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;float&gt;</ref><sp/>XGrad,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>zb);</highlight></codeline>
<codeline lineno="1056"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientCPU&lt;double&gt;(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;double&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;double&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;double&gt;</ref><sp/>XGrad,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*<sp/>zb);</highlight></codeline>
<codeline lineno="1057"><highlight class="normal"></highlight></codeline>
<codeline lineno="1067"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>WetsloperesetCPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>XGrad,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="1068"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1069"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>ib;</highlight></codeline>
<codeline lineno="1070"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>xplus,<sp/>xminus,<sp/>yminus;</highlight></codeline>
<codeline lineno="1071"><highlight class="normal"></highlight></codeline>
<codeline lineno="1072"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta;</highlight></codeline>
<codeline lineno="1073"><highlight class="normal"></highlight></codeline>
<codeline lineno="1074"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="1075"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1076"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1077"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delta<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib]);</highlight></codeline>
<codeline lineno="1078"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>0;<sp/>iy<sp/>&lt;<sp/>XParam.blkwidth;<sp/>iy++)</highlight></codeline>
<codeline lineno="1079"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1080"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>0;<sp/>ix<sp/>&lt;<sp/>XParam.blkwidth;<sp/>ix++)</highlight></codeline>
<codeline lineno="1081"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1082"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1083"><highlight class="normal"></highlight></codeline>
<codeline lineno="1084"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1085"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xplus<sp/>=<sp/>memloc(XParam,<sp/>ix<sp/>+<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1086"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xminus<sp/>=<sp/>memloc(XParam,<sp/>ix<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1087"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//yplus<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>iy<sp/>+<sp/>1,<sp/>ib);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1088"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>yminus<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>iy<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="1089"><highlight class="normal"></highlight></codeline>
<codeline lineno="1090"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>dzsdxi<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>[i];</highlight></codeline>
<codeline lineno="1091"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>dzsdyi<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>[i];</highlight></codeline>
<codeline lineno="1092"><highlight class="normal"></highlight></codeline>
<codeline lineno="1093"><highlight class="normal"></highlight></codeline>
<codeline lineno="1094"><highlight class="normal"></highlight></codeline>
<codeline lineno="1095"><highlight class="normal"></highlight></codeline>
<codeline lineno="1096"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Do<sp/>X<sp/>axis</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1097"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(utils::sq(dzsdxi)<sp/>&gt;<sp/>utils::sq(XGrad.<ref refid="struct_gradients_p_1a83a24485386c83f86ad6530c936e194e" kindref="member">dzbdx</ref>[i]))</highlight></codeline>
<codeline lineno="1098"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1099"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>leftzs,<sp/>rightzs;</highlight></codeline>
<codeline lineno="1100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>leftzs<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[i]<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>-<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdxi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]);</highlight></codeline>
<codeline lineno="1101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rightzs<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[i]<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>+<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdxi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]);</highlight></codeline>
<codeline lineno="1102"><highlight class="normal"></highlight></codeline>
<codeline lineno="1103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(leftzs<sp/>&gt;<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[xminus]<sp/>||<sp/>rightzs<sp/>&gt;<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[xplus])</highlight></codeline>
<codeline lineno="1104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>[i]<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]<sp/>+<sp/>XGrad.<ref refid="struct_gradients_p_1a83a24485386c83f86ad6530c936e194e" kindref="member">dzbdx</ref>[i];</highlight></codeline>
<codeline lineno="1106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1107"><highlight class="normal"></highlight></codeline>
<codeline lineno="1108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1109"><highlight class="normal"></highlight></codeline>
<codeline lineno="1110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Do<sp/>Y<sp/>axis</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(utils::sq(dzsdyi)<sp/>&gt;<sp/>utils::sq(XGrad.<ref refid="struct_gradients_p_1af9686c22fbc669c58c288b74549edb98" kindref="member">dzbdy</ref>[i]))</highlight></codeline>
<codeline lineno="1112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>botzs,<sp/>topzs;</highlight></codeline>
<codeline lineno="1114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>botzs<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[i]<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>-<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdyi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]);</highlight></codeline>
<codeline lineno="1115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topzs<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[i]<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>+<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdyi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]);</highlight></codeline>
<codeline lineno="1116"><highlight class="normal"></highlight></codeline>
<codeline lineno="1117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(botzs<sp/>&gt;<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[yminus]<sp/>||<sp/>topzs<sp/>&gt;<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[yminus])</highlight></codeline>
<codeline lineno="1118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>[i]<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]<sp/>+<sp/>XGrad.<ref refid="struct_gradients_p_1af9686c22fbc669c58c288b74549edb98" kindref="member">dzbdy</ref>[i];</highlight></codeline>
<codeline lineno="1120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1121"><highlight class="normal"></highlight></codeline>
<codeline lineno="1122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1123"><highlight class="normal"></highlight></codeline>
<codeline lineno="1124"><highlight class="normal"></highlight></codeline>
<codeline lineno="1125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1127"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1128"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1129"><highlight class="normal"></highlight></codeline>
<codeline lineno="1141"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>WetsloperesetXGPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>XGrad,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="1142"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1143"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1144"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1145"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="1146"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="1147"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="1148"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1149"><highlight class="normal"></highlight></codeline>
<codeline lineno="1150"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>XBlock.level[ib];</highlight></codeline>
<codeline lineno="1151"><highlight class="normal"></highlight></codeline>
<codeline lineno="1152"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta<sp/>=<sp/>calcres(XParam.delta,<sp/>lev);</highlight></codeline>
<codeline lineno="1153"><highlight class="normal"></highlight></codeline>
<codeline lineno="1154"><highlight class="normal"></highlight></codeline>
<codeline lineno="1155"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1156"><highlight class="normal"></highlight></codeline>
<codeline lineno="1157"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iright,<sp/>ileft;</highlight></codeline>
<codeline lineno="1158"><highlight class="normal"><sp/><sp/><sp/><sp/>iright<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>+<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1159"><highlight class="normal"><sp/><sp/><sp/><sp/>ileft<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1160"><highlight class="normal"></highlight></codeline>
<codeline lineno="1161"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>dzsdxi<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>[i];</highlight></codeline>
<codeline lineno="1162"><highlight class="normal"></highlight></codeline>
<codeline lineno="1163"><highlight class="normal"></highlight></codeline>
<codeline lineno="1164"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(utils::sq(dzsdxi)<sp/>&gt;<sp/>utils::sq(XGrad.<ref refid="struct_gradients_p_1a83a24485386c83f86ad6530c936e194e" kindref="member">dzbdx</ref>[i]))</highlight></codeline>
<codeline lineno="1165"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>leftzs,<sp/>rightzs;</highlight></codeline>
<codeline lineno="1167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>leftzs<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[i]<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>-<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdxi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]);</highlight></codeline>
<codeline lineno="1168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rightzs<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[i]<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>+<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdxi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]);</highlight></codeline>
<codeline lineno="1169"><highlight class="normal"></highlight></codeline>
<codeline lineno="1170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(leftzs<sp/>&gt;<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ileft]<sp/>||<sp/>rightzs<sp/>&gt;<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[iright])</highlight></codeline>
<codeline lineno="1171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>[i]<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]<sp/>+<sp/>XGrad.<ref refid="struct_gradients_p_1a83a24485386c83f86ad6530c936e194e" kindref="member">dzbdx</ref>[i];</highlight></codeline>
<codeline lineno="1173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1174"><highlight class="normal"></highlight></codeline>
<codeline lineno="1175"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1176"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1177"><highlight class="normal"></highlight></codeline>
<codeline lineno="1178"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1179"><highlight class="normal"></highlight></codeline>
<codeline lineno="1190"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>WetsloperesetYGPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>XGrad,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="1191"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1192"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>blockDim.x<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1193"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>blkmemwidth<sp/>*<sp/>blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1194"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="1195"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="1196"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="1197"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1198"><highlight class="normal"></highlight></codeline>
<codeline lineno="1199"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>XBlock.level[ib];</highlight></codeline>
<codeline lineno="1200"><highlight class="normal"></highlight></codeline>
<codeline lineno="1201"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta<sp/>=<sp/>calcres(XParam.delta,<sp/>lev);</highlight></codeline>
<codeline lineno="1202"><highlight class="normal"></highlight></codeline>
<codeline lineno="1203"><highlight class="normal"></highlight></codeline>
<codeline lineno="1204"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1205"><highlight class="normal"></highlight></codeline>
<codeline lineno="1206"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>itop,<sp/>ibot;</highlight></codeline>
<codeline lineno="1207"><highlight class="normal"><sp/><sp/><sp/><sp/>itop<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy<sp/>+<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="1208"><highlight class="normal"><sp/><sp/><sp/><sp/>ibot<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="1209"><highlight class="normal"></highlight></codeline>
<codeline lineno="1210"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>dzsdyi<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>[i];</highlight></codeline>
<codeline lineno="1211"><highlight class="normal"></highlight></codeline>
<codeline lineno="1212"><highlight class="normal"></highlight></codeline>
<codeline lineno="1213"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(utils::sq(dzsdyi)<sp/>&gt;<sp/>utils::sq(XGrad.<ref refid="struct_gradients_p_1af9686c22fbc669c58c288b74549edb98" kindref="member">dzbdy</ref>[i]))</highlight></codeline>
<codeline lineno="1214"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>botzs,<sp/>topzs;</highlight></codeline>
<codeline lineno="1216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>botzs<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[i]<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>-<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdyi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]);</highlight></codeline>
<codeline lineno="1217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topzs<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[i]<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>+<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdyi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]);</highlight></codeline>
<codeline lineno="1218"><highlight class="normal"></highlight></codeline>
<codeline lineno="1219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(botzs<sp/>&gt;<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ibot]<sp/>||<sp/>topzs<sp/>&gt;<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itop])</highlight></codeline>
<codeline lineno="1220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>[i]<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]<sp/>+<sp/>XGrad.<ref refid="struct_gradients_p_1af9686c22fbc669c58c288b74549edb98" kindref="member">dzbdy</ref>[i];</highlight></codeline>
<codeline lineno="1222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1223"><highlight class="normal"></highlight></codeline>
<codeline lineno="1224"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1225"><highlight class="normal"></highlight></codeline>
<codeline lineno="1226"><highlight class="normal"></highlight></codeline>
<codeline lineno="1227"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1228"><highlight class="normal"></highlight></codeline>
<codeline lineno="1241"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>WetsloperesetHaloLeftGPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>XGrad,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="1242"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1243"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1244"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>XParam.blkmemwidth<sp/>*<sp/>XParam.blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1245"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>-1;</highlight></codeline>
<codeline lineno="1246"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="1247"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="1248"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1249"><highlight class="normal"></highlight></codeline>
<codeline lineno="1250"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>XBlock.level[ib];</highlight></codeline>
<codeline lineno="1251"><highlight class="normal"></highlight></codeline>
<codeline lineno="1252"><highlight class="normal"></highlight></codeline>
<codeline lineno="1253"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta<sp/>=<sp/>calcres(XParam.delta,<sp/>lev);</highlight></codeline>
<codeline lineno="1254"><highlight class="normal"></highlight></codeline>
<codeline lineno="1255"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>zsi,<sp/>zsright,<sp/>zsleft;</highlight></codeline>
<codeline lineno="1256"><highlight class="normal"></highlight></codeline>
<codeline lineno="1257"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>iright;</highlight></codeline>
<codeline lineno="1258"><highlight class="normal"><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1259"><highlight class="normal"><sp/><sp/><sp/><sp/>iright<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>+<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1260"><highlight class="normal"></highlight></codeline>
<codeline lineno="1261"><highlight class="normal"><sp/><sp/><sp/><sp/>zsi<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[i];</highlight></codeline>
<codeline lineno="1262"><highlight class="normal"><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[iright];</highlight></codeline>
<codeline lineno="1263"><highlight class="normal"></highlight></codeline>
<codeline lineno="1264"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="1265"><highlight class="normal"></highlight></codeline>
<codeline lineno="1266"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1267"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1270"><highlight class="normal"></highlight></codeline>
<codeline lineno="1271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1272"><highlight class="normal"></highlight></codeline>
<codeline lineno="1273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="1274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1275"><highlight class="normal"></highlight></codeline>
<codeline lineno="1276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1281"><highlight class="normal"></highlight></codeline>
<codeline lineno="1282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1283"><highlight class="normal"></highlight></codeline>
<codeline lineno="1284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="1285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1289"><highlight class="normal"></highlight></codeline>
<codeline lineno="1290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1292"><highlight class="normal"></highlight></codeline>
<codeline lineno="1293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1298"><highlight class="normal"></highlight></codeline>
<codeline lineno="1299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="1300"><highlight class="normal"></highlight></codeline>
<codeline lineno="1301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1303"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1304"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.LeftBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1305"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1306"><highlight class="normal"></highlight></codeline>
<codeline lineno="1307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>iy,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="1309"><highlight class="normal"></highlight></codeline>
<codeline lineno="1310"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1311"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="1312"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1313"><highlight class="normal"></highlight></codeline>
<codeline lineno="1314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1316"><highlight class="normal"></highlight></codeline>
<codeline lineno="1317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.LeftBot[ib];</highlight></codeline>
<codeline lineno="1319"><highlight class="normal"></highlight></codeline>
<codeline lineno="1320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="1321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="1322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="1323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="1324"><highlight class="normal"></highlight></codeline>
<codeline lineno="1325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="1326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="1329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1333"><highlight class="normal"></highlight></codeline>
<codeline lineno="1334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1335"><highlight class="normal"></highlight></codeline>
<codeline lineno="1336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="1337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1347"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1349"><highlight class="normal"></highlight></codeline>
<codeline lineno="1350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="1351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1353"><highlight class="normal"></highlight></codeline>
<codeline lineno="1354"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1355"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1356"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.RightBot[XBlock.LeftBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="1358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="1359"><highlight class="normal"></highlight></codeline>
<codeline lineno="1360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1364"><highlight class="normal"></highlight></codeline>
<codeline lineno="1365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>BilinearInterpolation(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.75),<sp/>jr);</highlight></codeline>
<codeline lineno="1366"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1367"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1368"><highlight class="normal"></highlight></codeline>
<codeline lineno="1369"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>dzsdxi<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>[i];</highlight></codeline>
<codeline lineno="1370"><highlight class="normal"></highlight></codeline>
<codeline lineno="1371"><highlight class="normal"></highlight></codeline>
<codeline lineno="1372"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(utils::sq(dzsdxi)<sp/>&gt;<sp/>utils::sq(XGrad.<ref refid="struct_gradients_p_1a83a24485386c83f86ad6530c936e194e" kindref="member">dzbdx</ref>[i]))</highlight></codeline>
<codeline lineno="1373"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>leftzs,<sp/>rightzs;</highlight></codeline>
<codeline lineno="1375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>leftzs<sp/>=<sp/>zsi<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>-<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdxi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]);</highlight></codeline>
<codeline lineno="1376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rightzs<sp/>=<sp/>zsi<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>+<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdxi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]);</highlight></codeline>
<codeline lineno="1377"><highlight class="normal"></highlight></codeline>
<codeline lineno="1378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(leftzs<sp/>&gt;<sp/>zsleft<sp/>||<sp/>rightzs<sp/>&gt;<sp/>zsright)</highlight></codeline>
<codeline lineno="1379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>[i]<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]<sp/>+<sp/>XGrad.<ref refid="struct_gradients_p_1a83a24485386c83f86ad6530c936e194e" kindref="member">dzbdx</ref>[i];</highlight></codeline>
<codeline lineno="1381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1382"><highlight class="normal"></highlight></codeline>
<codeline lineno="1383"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1384"><highlight class="normal"></highlight></codeline>
<codeline lineno="1385"><highlight class="normal"></highlight></codeline>
<codeline lineno="1386"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1387"><highlight class="normal"></highlight></codeline>
<codeline lineno="1399"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>WetsloperesetHaloLeftCPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>XGrad,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="1400"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1401"><highlight class="normal"></highlight></codeline>
<codeline lineno="1402"><highlight class="normal"></highlight></codeline>
<codeline lineno="1403"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1404"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>XParam.blkmemwidth<sp/>*<sp/>XParam.blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1405"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>-1;</highlight></codeline>
<codeline lineno="1406"><highlight class="normal"></highlight></codeline>
<codeline lineno="1407"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="1408"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1409"><highlight class="normal"></highlight></codeline>
<codeline lineno="1410"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1411"><highlight class="normal"></highlight></codeline>
<codeline lineno="1412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>XBlock.level[ib];</highlight></codeline>
<codeline lineno="1413"><highlight class="normal"></highlight></codeline>
<codeline lineno="1414"><highlight class="normal"></highlight></codeline>
<codeline lineno="1415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>delta<sp/>=<sp/>calcres(XParam.delta,<sp/>lev);</highlight></codeline>
<codeline lineno="1416"><highlight class="normal"></highlight></codeline>
<codeline lineno="1417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>zsi,<sp/>zsright,<sp/>zsleft;</highlight></codeline>
<codeline lineno="1418"><highlight class="normal"></highlight></codeline>
<codeline lineno="1419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>0;<sp/>iy<sp/>&lt;=<sp/>XParam.blkwidth;<sp/>iy++)</highlight></codeline>
<codeline lineno="1420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1421"><highlight class="normal"></highlight></codeline>
<codeline lineno="1422"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>iright;</highlight></codeline>
<codeline lineno="1423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iright<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>+<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1425"><highlight class="normal"></highlight></codeline>
<codeline lineno="1426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsi<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[i];</highlight></codeline>
<codeline lineno="1427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[iright];</highlight></codeline>
<codeline lineno="1428"><highlight class="normal"></highlight></codeline>
<codeline lineno="1429"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="1430"><highlight class="normal"></highlight></codeline>
<codeline lineno="1431"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1434"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1435"><highlight class="normal"></highlight></codeline>
<codeline lineno="1436"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1437"><highlight class="normal"></highlight></codeline>
<codeline lineno="1438"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="1439"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1440"><highlight class="normal"></highlight></codeline>
<codeline lineno="1441"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1442"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1443"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1445"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1446"><highlight class="normal"></highlight></codeline>
<codeline lineno="1447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1448"><highlight class="normal"></highlight></codeline>
<codeline lineno="1449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="1450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1454"><highlight class="normal"></highlight></codeline>
<codeline lineno="1455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1457"><highlight class="normal"></highlight></codeline>
<codeline lineno="1458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1463"><highlight class="normal"></highlight></codeline>
<codeline lineno="1464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="1465"><highlight class="normal"></highlight></codeline>
<codeline lineno="1466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.LeftBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1471"><highlight class="normal"></highlight></codeline>
<codeline lineno="1472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>iy,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="1474"><highlight class="normal"></highlight></codeline>
<codeline lineno="1475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="1477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1478"><highlight class="normal"></highlight></codeline>
<codeline lineno="1479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1481"><highlight class="normal"></highlight></codeline>
<codeline lineno="1482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.LeftBot[ib];</highlight></codeline>
<codeline lineno="1484"><highlight class="normal"></highlight></codeline>
<codeline lineno="1485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="1486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="1487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="1488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="1489"><highlight class="normal"></highlight></codeline>
<codeline lineno="1490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="1491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="1494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1496"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1497"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1498"><highlight class="normal"></highlight></codeline>
<codeline lineno="1499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1500"><highlight class="normal"></highlight></codeline>
<codeline lineno="1501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="1502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1513"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="1514"><highlight class="normal"></highlight></codeline>
<codeline lineno="1515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="1516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1518"><highlight class="normal"></highlight></codeline>
<codeline lineno="1519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.RightBot[XBlock.LeftBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(iy<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="1523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="1524"><highlight class="normal"></highlight></codeline>
<codeline lineno="1525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="1529"><highlight class="normal"></highlight></codeline>
<codeline lineno="1530"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>BilinearInterpolation(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.75),<sp/>jr);</highlight></codeline>
<codeline lineno="1531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1532"><highlight class="normal"></highlight></codeline>
<codeline lineno="1533"><highlight class="normal"></highlight></codeline>
<codeline lineno="1534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>dzsdxi<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>[i];</highlight></codeline>
<codeline lineno="1535"><highlight class="normal"></highlight></codeline>
<codeline lineno="1536"><highlight class="normal"></highlight></codeline>
<codeline lineno="1537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(utils::sq(dzsdxi)<sp/>&gt;<sp/>utils::sq(XGrad.<ref refid="struct_gradients_p_1a83a24485386c83f86ad6530c936e194e" kindref="member">dzbdx</ref>[i]))</highlight></codeline>
<codeline lineno="1538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>leftzs,<sp/>rightzs;</highlight></codeline>
<codeline lineno="1540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>leftzs<sp/>=<sp/>zsi<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>-<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdxi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]);</highlight></codeline>
<codeline lineno="1541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rightzs<sp/>=<sp/>zsi<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>+<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdxi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]);</highlight></codeline>
<codeline lineno="1542"><highlight class="normal"></highlight></codeline>
<codeline lineno="1543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(leftzs<sp/>&gt;<sp/>zsleft<sp/>||<sp/>rightzs<sp/>&gt;<sp/>zsright)</highlight></codeline>
<codeline lineno="1544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>[i]<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]<sp/>+<sp/>XGrad.<ref refid="struct_gradients_p_1a83a24485386c83f86ad6530c936e194e" kindref="member">dzbdx</ref>[i];</highlight></codeline>
<codeline lineno="1546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1547"><highlight class="normal"></highlight></codeline>
<codeline lineno="1548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1549"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1550"><highlight class="normal"></highlight></codeline>
<codeline lineno="1551"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1552"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1553"><highlight class="normal"></highlight></codeline>
<codeline lineno="1567"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>WetsloperesetHaloRightGPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>XGrad,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="1568"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1569"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1570"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>XParam.blkmemwidth<sp/>*<sp/>XParam.blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1571"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>XParam.blkwidth;</highlight></codeline>
<codeline lineno="1572"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="1573"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="1574"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1575"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="1576"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="1577"><highlight class="normal"></highlight></codeline>
<codeline lineno="1578"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>XBlock.level[ib];</highlight></codeline>
<codeline lineno="1579"><highlight class="normal"></highlight></codeline>
<codeline lineno="1580"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta<sp/>=<sp/>calcres(XParam.delta,<sp/>lev);</highlight></codeline>
<codeline lineno="1581"><highlight class="normal"></highlight></codeline>
<codeline lineno="1582"><highlight class="normal"></highlight></codeline>
<codeline lineno="1583"><highlight class="normal"><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1584"><highlight class="normal"></highlight></codeline>
<codeline lineno="1585"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ileft;</highlight></codeline>
<codeline lineno="1586"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1587"><highlight class="normal"><sp/><sp/><sp/><sp/>ileft<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1588"><highlight class="normal"></highlight></codeline>
<codeline lineno="1589"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>zsi,<sp/>zsleft,<sp/>zsright;</highlight></codeline>
<codeline lineno="1590"><highlight class="normal"></highlight></codeline>
<codeline lineno="1591"><highlight class="normal"><sp/><sp/><sp/><sp/>zsi<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[i];</highlight></codeline>
<codeline lineno="1592"><highlight class="normal"><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ileft];</highlight></codeline>
<codeline lineno="1593"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1594"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>dzsdxi<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>[i];</highlight></codeline>
<codeline lineno="1595"><highlight class="normal"></highlight></codeline>
<codeline lineno="1596"><highlight class="normal"></highlight></codeline>
<codeline lineno="1597"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1598"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1600"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1601"><highlight class="normal"></highlight></codeline>
<codeline lineno="1602"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1603"><highlight class="normal"></highlight></codeline>
<codeline lineno="1604"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];;</highlight></codeline>
<codeline lineno="1605"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1606"><highlight class="normal"></highlight></codeline>
<codeline lineno="1607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1608"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1609"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1610"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1611"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1612"><highlight class="normal"></highlight></codeline>
<codeline lineno="1613"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1614"><highlight class="normal"></highlight></codeline>
<codeline lineno="1615"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="1616"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1617"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1618"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1619"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1620"><highlight class="normal"></highlight></codeline>
<codeline lineno="1621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1623"><highlight class="normal"></highlight></codeline>
<codeline lineno="1624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1625"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1626"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1629"><highlight class="normal"></highlight></codeline>
<codeline lineno="1630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="1631"><highlight class="normal"></highlight></codeline>
<codeline lineno="1632"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1633"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1634"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1635"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.RightBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1636"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1637"><highlight class="normal"></highlight></codeline>
<codeline lineno="1638"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>iy,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1639"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="1640"><highlight class="normal"></highlight></codeline>
<codeline lineno="1641"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1642"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="1643"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1644"><highlight class="normal"></highlight></codeline>
<codeline lineno="1645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1647"><highlight class="normal"></highlight></codeline>
<codeline lineno="1648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.RightBot[ib];</highlight></codeline>
<codeline lineno="1650"><highlight class="normal"></highlight></codeline>
<codeline lineno="1651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="1652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="1653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="1654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="1655"><highlight class="normal"></highlight></codeline>
<codeline lineno="1656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="1657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="1660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1663"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1664"><highlight class="normal"></highlight></codeline>
<codeline lineno="1665"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1666"><highlight class="normal"></highlight></codeline>
<codeline lineno="1667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="1668"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1670"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1671"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1672"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1674"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1675"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1676"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1678"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1679"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1680"><highlight class="normal"></highlight></codeline>
<codeline lineno="1681"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="1682"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1683"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1684"><highlight class="normal"></highlight></codeline>
<codeline lineno="1685"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1686"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1687"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.LeftBot[XBlock.RightBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="1689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="1690"><highlight class="normal"></highlight></codeline>
<codeline lineno="1691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1693"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1695"><highlight class="normal"></highlight></codeline>
<codeline lineno="1696"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>BilinearInterpolation(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.25),<sp/>jr);</highlight></codeline>
<codeline lineno="1697"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1698"><highlight class="normal"></highlight></codeline>
<codeline lineno="1699"><highlight class="normal"></highlight></codeline>
<codeline lineno="1700"><highlight class="normal"></highlight></codeline>
<codeline lineno="1701"><highlight class="normal"></highlight></codeline>
<codeline lineno="1702"><highlight class="normal"></highlight></codeline>
<codeline lineno="1703"><highlight class="normal"></highlight></codeline>
<codeline lineno="1704"><highlight class="normal"></highlight></codeline>
<codeline lineno="1705"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(utils::sq(dzsdxi)<sp/>&gt;<sp/>utils::sq(XGrad.<ref refid="struct_gradients_p_1a83a24485386c83f86ad6530c936e194e" kindref="member">dzbdx</ref>[i]))</highlight></codeline>
<codeline lineno="1706"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1707"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>leftzs,<sp/>rightzs;</highlight></codeline>
<codeline lineno="1708"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>leftzs<sp/>=<sp/>zsi<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>-<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdxi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]);</highlight></codeline>
<codeline lineno="1709"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rightzs<sp/>=<sp/>zsi<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>+<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdxi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]);</highlight></codeline>
<codeline lineno="1710"><highlight class="normal"></highlight></codeline>
<codeline lineno="1711"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(leftzs<sp/>&gt;<sp/>zsleft<sp/>||<sp/>rightzs<sp/>&gt;<sp/>zsright)</highlight></codeline>
<codeline lineno="1712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>[i]<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]<sp/>+<sp/>XGrad.<ref refid="struct_gradients_p_1a83a24485386c83f86ad6530c936e194e" kindref="member">dzbdx</ref>[i];</highlight></codeline>
<codeline lineno="1714"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1715"><highlight class="normal"></highlight></codeline>
<codeline lineno="1716"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1717"><highlight class="normal"></highlight></codeline>
<codeline lineno="1718"><highlight class="normal"></highlight></codeline>
<codeline lineno="1719"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1720"><highlight class="normal"></highlight></codeline>
<codeline lineno="1733"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>WetsloperesetHaloRightCPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>XGrad,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="1734"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1735"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1736"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>XParam.blkmemwidth<sp/>*<sp/>XParam.blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1737"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>XParam.blkwidth;</highlight></codeline>
<codeline lineno="1738"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1739"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="1740"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1741"><highlight class="normal"></highlight></codeline>
<codeline lineno="1742"><highlight class="normal"></highlight></codeline>
<codeline lineno="1743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>0;<sp/>iy<sp/>&lt;<sp/>XParam.blkwidth;<sp/>iy++)</highlight></codeline>
<codeline lineno="1744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1745"><highlight class="normal"></highlight></codeline>
<codeline lineno="1746"><highlight class="normal"></highlight></codeline>
<codeline lineno="1747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1748"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1749"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="1750"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>read;</highlight></codeline>
<codeline lineno="1751"><highlight class="normal"></highlight></codeline>
<codeline lineno="1752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>XBlock.level[ib];</highlight></codeline>
<codeline lineno="1753"><highlight class="normal"></highlight></codeline>
<codeline lineno="1754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>delta<sp/>=<sp/>calcres(XParam.delta,<sp/>lev);</highlight></codeline>
<codeline lineno="1755"><highlight class="normal"></highlight></codeline>
<codeline lineno="1756"><highlight class="normal"></highlight></codeline>
<codeline lineno="1757"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1758"><highlight class="normal"></highlight></codeline>
<codeline lineno="1759"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/>ileft;</highlight></codeline>
<codeline lineno="1760"><highlight class="normal"></highlight></codeline>
<codeline lineno="1761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ileft<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1762"><highlight class="normal"></highlight></codeline>
<codeline lineno="1763"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>zsi,<sp/>zsleft,<sp/>zsright;</highlight></codeline>
<codeline lineno="1764"><highlight class="normal"></highlight></codeline>
<codeline lineno="1765"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsi<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[i];</highlight></codeline>
<codeline lineno="1766"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsleft<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ileft];</highlight></codeline>
<codeline lineno="1767"><highlight class="normal"></highlight></codeline>
<codeline lineno="1768"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>dzsdxi<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>[i];</highlight></codeline>
<codeline lineno="1769"><highlight class="normal"></highlight></codeline>
<codeline lineno="1770"><highlight class="normal"></highlight></codeline>
<codeline lineno="1771"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1773"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1775"><highlight class="normal"></highlight></codeline>
<codeline lineno="1776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1777"><highlight class="normal"></highlight></codeline>
<codeline lineno="1778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];;</highlight></codeline>
<codeline lineno="1779"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1780"><highlight class="normal"></highlight></codeline>
<codeline lineno="1781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1783"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1784"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1785"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1786"><highlight class="normal"></highlight></codeline>
<codeline lineno="1787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1788"><highlight class="normal"></highlight></codeline>
<codeline lineno="1789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="1790"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1791"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1792"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1793"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1794"><highlight class="normal"></highlight></codeline>
<codeline lineno="1795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1797"><highlight class="normal"></highlight></codeline>
<codeline lineno="1798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1803"><highlight class="normal"></highlight></codeline>
<codeline lineno="1804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="1805"><highlight class="normal"></highlight></codeline>
<codeline lineno="1806"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1807"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1809"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.RightBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1810"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1811"><highlight class="normal"></highlight></codeline>
<codeline lineno="1812"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>iy,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="1814"><highlight class="normal"></highlight></codeline>
<codeline lineno="1815"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1816"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="1817"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1818"><highlight class="normal"></highlight></codeline>
<codeline lineno="1819"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1820"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1821"><highlight class="normal"></highlight></codeline>
<codeline lineno="1822"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1823"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.RightBot[ib];</highlight></codeline>
<codeline lineno="1824"><highlight class="normal"></highlight></codeline>
<codeline lineno="1825"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="1826"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="1827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="1828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="1829"><highlight class="normal"></highlight></codeline>
<codeline lineno="1830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="1831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1833"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="1834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1838"><highlight class="normal"></highlight></codeline>
<codeline lineno="1839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1840"><highlight class="normal"></highlight></codeline>
<codeline lineno="1841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="1842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1853"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="1854"><highlight class="normal"></highlight></codeline>
<codeline lineno="1855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="1856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1857"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1858"><highlight class="normal"></highlight></codeline>
<codeline lineno="1859"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1861"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1862"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.LeftBot[XBlock.RightBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(iy<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="1863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="1864"><highlight class="normal"></highlight></codeline>
<codeline lineno="1865"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="1869"><highlight class="normal"></highlight></codeline>
<codeline lineno="1870"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsright<sp/>=<sp/>BilinearInterpolation(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.25),<sp/>jr);</highlight></codeline>
<codeline lineno="1871"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1872"><highlight class="normal"></highlight></codeline>
<codeline lineno="1873"><highlight class="normal"></highlight></codeline>
<codeline lineno="1874"><highlight class="normal"></highlight></codeline>
<codeline lineno="1875"><highlight class="normal"></highlight></codeline>
<codeline lineno="1876"><highlight class="normal"></highlight></codeline>
<codeline lineno="1877"><highlight class="normal"></highlight></codeline>
<codeline lineno="1878"><highlight class="normal"></highlight></codeline>
<codeline lineno="1879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(utils::sq(dzsdxi)<sp/>&gt;<sp/>utils::sq(XGrad.<ref refid="struct_gradients_p_1a83a24485386c83f86ad6530c936e194e" kindref="member">dzbdx</ref>[i]))</highlight></codeline>
<codeline lineno="1880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1881"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>leftzs,<sp/>rightzs;</highlight></codeline>
<codeline lineno="1882"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>leftzs<sp/>=<sp/>zsi<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>-<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdxi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]);</highlight></codeline>
<codeline lineno="1883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rightzs<sp/>=<sp/>zsi<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>+<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdxi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]);</highlight></codeline>
<codeline lineno="1884"><highlight class="normal"></highlight></codeline>
<codeline lineno="1885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(leftzs<sp/>&gt;<sp/>zsleft<sp/>||<sp/>rightzs<sp/>&gt;<sp/>zsright)</highlight></codeline>
<codeline lineno="1886"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1887"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>XGrad.<ref refid="struct_gradients_p_1ad43d1bb081c2d44b832b8cdcfd544347" kindref="member">dzsdx</ref>[i]<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1a3a9cb7fe4a455a7f5aeb9a82d4ff0703" kindref="member">dhdx</ref>[i]<sp/>+<sp/>XGrad.<ref refid="struct_gradients_p_1a83a24485386c83f86ad6530c936e194e" kindref="member">dzbdx</ref>[i];</highlight></codeline>
<codeline lineno="1888"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1889"><highlight class="normal"></highlight></codeline>
<codeline lineno="1890"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1891"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1892"><highlight class="normal"></highlight></codeline>
<codeline lineno="1893"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1894"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1895"><highlight class="normal"></highlight></codeline>
<codeline lineno="1908"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>WetsloperesetHaloBotGPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>XGrad,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="1909"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1910"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1911"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>XParam.blkmemwidth<sp/>*<sp/>XParam.blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1912"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>-1;</highlight></codeline>
<codeline lineno="1913"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="1914"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="1915"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="1916"><highlight class="normal"></highlight></codeline>
<codeline lineno="1917"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="1918"><highlight class="normal"></highlight></codeline>
<codeline lineno="1919"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>XBlock.level[ib];</highlight></codeline>
<codeline lineno="1920"><highlight class="normal"></highlight></codeline>
<codeline lineno="1921"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta<sp/>=<sp/>calcres(XParam.delta,<sp/>lev);</highlight></codeline>
<codeline lineno="1922"><highlight class="normal"></highlight></codeline>
<codeline lineno="1923"><highlight class="normal"></highlight></codeline>
<codeline lineno="1924"><highlight class="normal"><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="1925"><highlight class="normal"></highlight></codeline>
<codeline lineno="1926"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>itop,read;</highlight></codeline>
<codeline lineno="1927"><highlight class="normal"><sp/><sp/><sp/><sp/>itop<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy<sp/>+<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="1928"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1929"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>zsi,<sp/>zstop,<sp/>zsbot;</highlight></codeline>
<codeline lineno="1930"><highlight class="normal"></highlight></codeline>
<codeline lineno="1931"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>dzsdyi<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>[i];</highlight></codeline>
<codeline lineno="1932"><highlight class="normal"></highlight></codeline>
<codeline lineno="1933"><highlight class="normal"><sp/><sp/><sp/><sp/>zsi<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[i];</highlight></codeline>
<codeline lineno="1934"><highlight class="normal"><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itop];</highlight></codeline>
<codeline lineno="1935"><highlight class="normal"></highlight></codeline>
<codeline lineno="1936"><highlight class="normal"></highlight></codeline>
<codeline lineno="1937"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1938"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1941"><highlight class="normal"></highlight></codeline>
<codeline lineno="1942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1943"><highlight class="normal"></highlight></codeline>
<codeline lineno="1944"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="1945"><highlight class="normal"></highlight></codeline>
<codeline lineno="1946"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1947"><highlight class="normal"></highlight></codeline>
<codeline lineno="1948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1949"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1952"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1953"><highlight class="normal"></highlight></codeline>
<codeline lineno="1954"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="1955"><highlight class="normal"></highlight></codeline>
<codeline lineno="1956"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="1957"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1958"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1959"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1960"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1961"><highlight class="normal"></highlight></codeline>
<codeline lineno="1962"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1963"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1964"><highlight class="normal"></highlight></codeline>
<codeline lineno="1965"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1966"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="1967"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="1968"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="1969"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="1970"><highlight class="normal"></highlight></codeline>
<codeline lineno="1971"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="1972"><highlight class="normal"></highlight></codeline>
<codeline lineno="1973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1975"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1976"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.BotLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1977"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1978"><highlight class="normal"></highlight></codeline>
<codeline lineno="1979"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="1980"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="1981"><highlight class="normal"></highlight></codeline>
<codeline lineno="1982"><highlight class="normal"></highlight></codeline>
<codeline lineno="1983"><highlight class="normal"></highlight></codeline>
<codeline lineno="1984"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1985"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="1986"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1987"><highlight class="normal"></highlight></codeline>
<codeline lineno="1988"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="1989"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1990"><highlight class="normal"></highlight></codeline>
<codeline lineno="1991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="1992"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.BotLeft[ib];</highlight></codeline>
<codeline lineno="1993"><highlight class="normal"></highlight></codeline>
<codeline lineno="1994"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>bb);</highlight></codeline>
<codeline lineno="1995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>bb);</highlight></codeline>
<codeline lineno="1996"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>bb);</highlight></codeline>
<codeline lineno="1997"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>bb);</highlight></codeline>
<codeline lineno="1998"><highlight class="normal"></highlight></codeline>
<codeline lineno="1999"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="2000"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2001"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2002"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2007"><highlight class="normal"></highlight></codeline>
<codeline lineno="2008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="2009"><highlight class="normal"></highlight></codeline>
<codeline lineno="2010"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="2011"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2012"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2013"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2014"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2015"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2016"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2017"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2018"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2019"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="2020"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="2021"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="2022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="2023"><highlight class="normal"></highlight></codeline>
<codeline lineno="2024"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="2025"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2026"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2027"><highlight class="normal"></highlight></codeline>
<codeline lineno="2028"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2029"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2030"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.TopLeft[XBlock.BotLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="2032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="2033"><highlight class="normal"></highlight></codeline>
<codeline lineno="2034"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="2035"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="2036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="2037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="2038"><highlight class="normal"></highlight></codeline>
<codeline lineno="2039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>BilinearInterpolation(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>jr,<sp/>T(0.75));</highlight></codeline>
<codeline lineno="2040"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2041"><highlight class="normal"></highlight></codeline>
<codeline lineno="2042"><highlight class="normal"></highlight></codeline>
<codeline lineno="2043"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(utils::sq(dzsdyi)<sp/>&gt;<sp/>utils::sq(XGrad.<ref refid="struct_gradients_p_1af9686c22fbc669c58c288b74549edb98" kindref="member">dzbdy</ref>[i]))</highlight></codeline>
<codeline lineno="2044"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>botzs,<sp/>topzs;</highlight></codeline>
<codeline lineno="2046"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>botzs<sp/>=<sp/>zsi<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>-<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdyi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]);</highlight></codeline>
<codeline lineno="2047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topzs<sp/>=<sp/>zsi<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>+<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdyi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]);</highlight></codeline>
<codeline lineno="2048"><highlight class="normal"></highlight></codeline>
<codeline lineno="2049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(botzs<sp/>&gt;<sp/>zsbot<sp/>||<sp/>topzs<sp/>&gt;<sp/>zstop)</highlight></codeline>
<codeline lineno="2050"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2051"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>[i]<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]<sp/>+<sp/>XGrad.<ref refid="struct_gradients_p_1af9686c22fbc669c58c288b74549edb98" kindref="member">dzbdy</ref>[i];</highlight></codeline>
<codeline lineno="2052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2053"><highlight class="normal"></highlight></codeline>
<codeline lineno="2054"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2055"><highlight class="normal"></highlight></codeline>
<codeline lineno="2056"><highlight class="normal"></highlight></codeline>
<codeline lineno="2057"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2058"><highlight class="normal"></highlight></codeline>
<codeline lineno="2070"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>WetsloperesetHaloBotCPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>XGrad,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="2071"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2072"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2073"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>XParam.blkmemwidth<sp/>*<sp/>XParam.blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2074"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>-1;</highlight></codeline>
<codeline lineno="2075"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2076"><highlight class="normal"></highlight></codeline>
<codeline lineno="2077"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="2078"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2079"><highlight class="normal"></highlight></codeline>
<codeline lineno="2080"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2081"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="2082"><highlight class="normal"></highlight></codeline>
<codeline lineno="2083"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2084"><highlight class="normal"></highlight></codeline>
<codeline lineno="2085"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="2086"><highlight class="normal"></highlight></codeline>
<codeline lineno="2087"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>XBlock.level[ib];</highlight></codeline>
<codeline lineno="2088"><highlight class="normal"></highlight></codeline>
<codeline lineno="2089"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>delta<sp/>=<sp/>calcres(XParam.delta,<sp/>lev);</highlight></codeline>
<codeline lineno="2090"><highlight class="normal"></highlight></codeline>
<codeline lineno="2091"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>0;<sp/>ix<sp/>&lt;<sp/>XParam.blkwidth;<sp/>ix++)</highlight></codeline>
<codeline lineno="2092"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2093"><highlight class="normal"></highlight></codeline>
<codeline lineno="2094"><highlight class="normal"></highlight></codeline>
<codeline lineno="2095"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2096"><highlight class="normal"></highlight></codeline>
<codeline lineno="2097"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>itop,<sp/>read;</highlight></codeline>
<codeline lineno="2098"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itop<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy<sp/>+<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="2099"><highlight class="normal"></highlight></codeline>
<codeline lineno="2100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>zsi,<sp/>zstop,<sp/>zsbot;</highlight></codeline>
<codeline lineno="2101"><highlight class="normal"></highlight></codeline>
<codeline lineno="2102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>dzsdyi<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>[i];</highlight></codeline>
<codeline lineno="2103"><highlight class="normal"></highlight></codeline>
<codeline lineno="2104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsi<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[i];</highlight></codeline>
<codeline lineno="2105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itop];</highlight></codeline>
<codeline lineno="2106"><highlight class="normal"></highlight></codeline>
<codeline lineno="2107"><highlight class="normal"></highlight></codeline>
<codeline lineno="2108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2112"><highlight class="normal"></highlight></codeline>
<codeline lineno="2113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2114"><highlight class="normal"></highlight></codeline>
<codeline lineno="2115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="2116"><highlight class="normal"></highlight></codeline>
<codeline lineno="2117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2118"><highlight class="normal"></highlight></codeline>
<codeline lineno="2119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2124"><highlight class="normal"></highlight></codeline>
<codeline lineno="2125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="2126"><highlight class="normal"></highlight></codeline>
<codeline lineno="2127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="2128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2132"><highlight class="normal"></highlight></codeline>
<codeline lineno="2133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2135"><highlight class="normal"></highlight></codeline>
<codeline lineno="2136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="2138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="2139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="2140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="2141"><highlight class="normal"></highlight></codeline>
<codeline lineno="2142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="2143"><highlight class="normal"></highlight></codeline>
<codeline lineno="2144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.BotLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2149"><highlight class="normal"></highlight></codeline>
<codeline lineno="2150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="2151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="2152"><highlight class="normal"></highlight></codeline>
<codeline lineno="2153"><highlight class="normal"></highlight></codeline>
<codeline lineno="2154"><highlight class="normal"></highlight></codeline>
<codeline lineno="2155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="2157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2158"><highlight class="normal"></highlight></codeline>
<codeline lineno="2159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2161"><highlight class="normal"></highlight></codeline>
<codeline lineno="2162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.BotLeft[ib];</highlight></codeline>
<codeline lineno="2164"><highlight class="normal"></highlight></codeline>
<codeline lineno="2165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>bb);</highlight></codeline>
<codeline lineno="2166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>bb);</highlight></codeline>
<codeline lineno="2167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>bb);</highlight></codeline>
<codeline lineno="2168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>bb);</highlight></codeline>
<codeline lineno="2169"><highlight class="normal"></highlight></codeline>
<codeline lineno="2170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="2171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2178"><highlight class="normal"></highlight></codeline>
<codeline lineno="2179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="2180"><highlight class="normal"></highlight></codeline>
<codeline lineno="2181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="2182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="2191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="2192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="2193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="2194"><highlight class="normal"></highlight></codeline>
<codeline lineno="2195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="2196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2198"><highlight class="normal"></highlight></codeline>
<codeline lineno="2199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.TopLeft[XBlock.BotLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(ix<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="2203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="2204"><highlight class="normal"></highlight></codeline>
<codeline lineno="2205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="2206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="2207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="2208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="2209"><highlight class="normal"></highlight></codeline>
<codeline lineno="2210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>BilinearInterpolation(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>jr,<sp/>T(0.75));</highlight></codeline>
<codeline lineno="2211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2212"><highlight class="normal"></highlight></codeline>
<codeline lineno="2213"><highlight class="normal"></highlight></codeline>
<codeline lineno="2214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(utils::sq(dzsdyi)<sp/>&gt;<sp/>utils::sq(XGrad.<ref refid="struct_gradients_p_1af9686c22fbc669c58c288b74549edb98" kindref="member">dzbdy</ref>[i]))</highlight></codeline>
<codeline lineno="2215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>botzs,<sp/>topzs;</highlight></codeline>
<codeline lineno="2217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>botzs<sp/>=<sp/>zsi<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>-<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdyi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]);</highlight></codeline>
<codeline lineno="2218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topzs<sp/>=<sp/>zsi<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>+<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdyi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]);</highlight></codeline>
<codeline lineno="2219"><highlight class="normal"></highlight></codeline>
<codeline lineno="2220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(botzs<sp/>&gt;<sp/>zsbot<sp/>||<sp/>topzs<sp/>&gt;<sp/>zstop)</highlight></codeline>
<codeline lineno="2221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>[i]<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]<sp/>+<sp/>XGrad.<ref refid="struct_gradients_p_1af9686c22fbc669c58c288b74549edb98" kindref="member">dzbdy</ref>[i];</highlight></codeline>
<codeline lineno="2223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2224"><highlight class="normal"></highlight></codeline>
<codeline lineno="2225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2227"><highlight class="normal"></highlight></codeline>
<codeline lineno="2228"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2229"><highlight class="normal"></highlight></codeline>
<codeline lineno="2230"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2231"><highlight class="normal"></highlight></codeline>
<codeline lineno="2245"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>WetsloperesetHaloTopGPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>XGrad,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="2246"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2247"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2248"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>XParam.blkmemwidth<sp/>*<sp/>XParam.blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2249"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>XParam.blkwidth;</highlight></codeline>
<codeline lineno="2250"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="2251"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="2252"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="2253"><highlight class="normal"></highlight></codeline>
<codeline lineno="2254"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="2255"><highlight class="normal"></highlight></codeline>
<codeline lineno="2256"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>XBlock.level[ib];</highlight></codeline>
<codeline lineno="2257"><highlight class="normal"></highlight></codeline>
<codeline lineno="2258"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta<sp/>=<sp/>calcres(XParam.delta,<sp/>lev);</highlight></codeline>
<codeline lineno="2259"><highlight class="normal"></highlight></codeline>
<codeline lineno="2260"><highlight class="normal"></highlight></codeline>
<codeline lineno="2261"><highlight class="normal"><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2262"><highlight class="normal"></highlight></codeline>
<codeline lineno="2263"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibot,<sp/>read;</highlight></codeline>
<codeline lineno="2264"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2265"><highlight class="normal"><sp/><sp/><sp/><sp/>ibot<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="2266"><highlight class="normal"></highlight></codeline>
<codeline lineno="2267"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>zsi,<sp/>zstop,<sp/>zsbot;</highlight></codeline>
<codeline lineno="2268"><highlight class="normal"></highlight></codeline>
<codeline lineno="2269"><highlight class="normal"><sp/><sp/><sp/><sp/>zsi<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[i];</highlight></codeline>
<codeline lineno="2270"><highlight class="normal"><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ibot];</highlight></codeline>
<codeline lineno="2271"><highlight class="normal"></highlight></codeline>
<codeline lineno="2272"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>dzsdyi<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>[i];</highlight></codeline>
<codeline lineno="2273"><highlight class="normal"></highlight></codeline>
<codeline lineno="2274"><highlight class="normal"></highlight></codeline>
<codeline lineno="2275"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2276"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2279"><highlight class="normal"></highlight></codeline>
<codeline lineno="2280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2281"><highlight class="normal"></highlight></codeline>
<codeline lineno="2282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="2283"><highlight class="normal"></highlight></codeline>
<codeline lineno="2284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2285"><highlight class="normal"></highlight></codeline>
<codeline lineno="2286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2291"><highlight class="normal"></highlight></codeline>
<codeline lineno="2292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="2293"><highlight class="normal"></highlight></codeline>
<codeline lineno="2294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="2295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2299"><highlight class="normal"></highlight></codeline>
<codeline lineno="2300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2302"><highlight class="normal"></highlight></codeline>
<codeline lineno="2303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2308"><highlight class="normal"></highlight></codeline>
<codeline lineno="2309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="2310"><highlight class="normal"></highlight></codeline>
<codeline lineno="2311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2313"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2314"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.TopLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2315"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2316"><highlight class="normal"></highlight></codeline>
<codeline lineno="2317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>1,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="2318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="2319"><highlight class="normal"></highlight></codeline>
<codeline lineno="2320"><highlight class="normal"></highlight></codeline>
<codeline lineno="2321"><highlight class="normal"></highlight></codeline>
<codeline lineno="2322"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2323"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="2324"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2325"><highlight class="normal"></highlight></codeline>
<codeline lineno="2326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2328"><highlight class="normal"></highlight></codeline>
<codeline lineno="2329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.TopLeft[ib];;</highlight></codeline>
<codeline lineno="2331"><highlight class="normal"></highlight></codeline>
<codeline lineno="2332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>3,<sp/>bb);</highlight></codeline>
<codeline lineno="2333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>2,<sp/>bb);</highlight></codeline>
<codeline lineno="2334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>3,<sp/>bb);</highlight></codeline>
<codeline lineno="2335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>2,<sp/>bb);</highlight></codeline>
<codeline lineno="2336"><highlight class="normal"></highlight></codeline>
<codeline lineno="2337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="2338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2345"><highlight class="normal"></highlight></codeline>
<codeline lineno="2346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="2347"><highlight class="normal"></highlight></codeline>
<codeline lineno="2348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="2349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2361"><highlight class="normal"></highlight></codeline>
<codeline lineno="2362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="2363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2365"><highlight class="normal"></highlight></codeline>
<codeline lineno="2366"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2367"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2368"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.BotLeft[XBlock.TopLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="2370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="2371"><highlight class="normal"></highlight></codeline>
<codeline lineno="2372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="2373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="2374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="2375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>1,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="2376"><highlight class="normal"></highlight></codeline>
<codeline lineno="2377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>BilinearInterpolation(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>jr,<sp/>T(0.25));</highlight></codeline>
<codeline lineno="2378"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2379"><highlight class="normal"></highlight></codeline>
<codeline lineno="2380"><highlight class="normal"></highlight></codeline>
<codeline lineno="2381"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(utils::sq(dzsdyi)<sp/>&gt;<sp/>utils::sq(XGrad.<ref refid="struct_gradients_p_1af9686c22fbc669c58c288b74549edb98" kindref="member">dzbdy</ref>[i]))</highlight></codeline>
<codeline lineno="2382"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>botzs,<sp/>topzs;</highlight></codeline>
<codeline lineno="2384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>botzs<sp/>=<sp/>zsi<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>-<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdyi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]);</highlight></codeline>
<codeline lineno="2385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topzs<sp/>=<sp/>zsi<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>+<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdyi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]);</highlight></codeline>
<codeline lineno="2386"><highlight class="normal"></highlight></codeline>
<codeline lineno="2387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(botzs<sp/>&gt;<sp/>zsbot<sp/>||<sp/>topzs<sp/>&gt;<sp/>zstop)</highlight></codeline>
<codeline lineno="2388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>[i]<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]<sp/>+<sp/>XGrad.<ref refid="struct_gradients_p_1af9686c22fbc669c58c288b74549edb98" kindref="member">dzbdy</ref>[i];</highlight></codeline>
<codeline lineno="2390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2391"><highlight class="normal"></highlight></codeline>
<codeline lineno="2392"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2393"><highlight class="normal"></highlight></codeline>
<codeline lineno="2394"><highlight class="normal"></highlight></codeline>
<codeline lineno="2395"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2396"><highlight class="normal"></highlight></codeline>
<codeline lineno="2397"><highlight class="normal"></highlight></codeline>
<codeline lineno="2410"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>WetsloperesetHaloTopCPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/><ref refid="struct_evolving_p" kindref="compound">EvolvingP&lt;T&gt;</ref><sp/>XEv,<sp/><ref refid="struct_gradients_p" kindref="compound">GradientsP&lt;T&gt;</ref><sp/>XGrad,<sp/>T*<sp/>zb)</highlight></codeline>
<codeline lineno="2411"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2412"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2413"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>XParam.blkmemwidth<sp/>*<sp/>XParam.blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2414"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>XParam.blkwidth;</highlight></codeline>
<codeline lineno="2415"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2416"><highlight class="normal"></highlight></codeline>
<codeline lineno="2417"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="2418"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="2420"><highlight class="normal"></highlight></codeline>
<codeline lineno="2421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="2422"><highlight class="normal"></highlight></codeline>
<codeline lineno="2423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lev<sp/>=<sp/>XBlock.level[ib];</highlight></codeline>
<codeline lineno="2424"><highlight class="normal"></highlight></codeline>
<codeline lineno="2425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>delta<sp/>=<sp/>calcres(XParam.delta,<sp/>lev);</highlight></codeline>
<codeline lineno="2426"><highlight class="normal"></highlight></codeline>
<codeline lineno="2427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>0;<sp/>ix<sp/>&lt;<sp/>XParam.blkwidth;<sp/>ix++)</highlight></codeline>
<codeline lineno="2428"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2429"><highlight class="normal"></highlight></codeline>
<codeline lineno="2430"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2431"><highlight class="normal"></highlight></codeline>
<codeline lineno="2432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibot,<sp/>read;</highlight></codeline>
<codeline lineno="2433"><highlight class="normal"></highlight></codeline>
<codeline lineno="2434"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ibot<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="2435"><highlight class="normal"></highlight></codeline>
<codeline lineno="2436"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>zsi,<sp/>zstop,<sp/>zsbot;</highlight></codeline>
<codeline lineno="2437"><highlight class="normal"></highlight></codeline>
<codeline lineno="2438"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsi<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[i];</highlight></codeline>
<codeline lineno="2439"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zsbot<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ibot];</highlight></codeline>
<codeline lineno="2440"><highlight class="normal"></highlight></codeline>
<codeline lineno="2441"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>dzsdyi<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>[i];</highlight></codeline>
<codeline lineno="2442"><highlight class="normal"></highlight></codeline>
<codeline lineno="2443"><highlight class="normal"></highlight></codeline>
<codeline lineno="2444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2445"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2448"><highlight class="normal"></highlight></codeline>
<codeline lineno="2449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2450"><highlight class="normal"></highlight></codeline>
<codeline lineno="2451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="2452"><highlight class="normal"></highlight></codeline>
<codeline lineno="2453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2454"><highlight class="normal"></highlight></codeline>
<codeline lineno="2455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2460"><highlight class="normal"></highlight></codeline>
<codeline lineno="2461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="2462"><highlight class="normal"></highlight></codeline>
<codeline lineno="2463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="2464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2468"><highlight class="normal"></highlight></codeline>
<codeline lineno="2469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2471"><highlight class="normal"></highlight></codeline>
<codeline lineno="2472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2477"><highlight class="normal"></highlight></codeline>
<codeline lineno="2478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="2479"><highlight class="normal"></highlight></codeline>
<codeline lineno="2480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.TopLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2485"><highlight class="normal"></highlight></codeline>
<codeline lineno="2486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>1,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="2487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="2488"><highlight class="normal"></highlight></codeline>
<codeline lineno="2489"><highlight class="normal"></highlight></codeline>
<codeline lineno="2490"><highlight class="normal"></highlight></codeline>
<codeline lineno="2491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="2493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2494"><highlight class="normal"></highlight></codeline>
<codeline lineno="2495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2496"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2497"><highlight class="normal"></highlight></codeline>
<codeline lineno="2498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.TopLeft[ib];;</highlight></codeline>
<codeline lineno="2500"><highlight class="normal"></highlight></codeline>
<codeline lineno="2501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>3,<sp/>bb);</highlight></codeline>
<codeline lineno="2502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>2,<sp/>bb);</highlight></codeline>
<codeline lineno="2503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>3,<sp/>bb);</highlight></codeline>
<codeline lineno="2504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>2,<sp/>bb);</highlight></codeline>
<codeline lineno="2505"><highlight class="normal"></highlight></codeline>
<codeline lineno="2506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="2507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2513"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2514"><highlight class="normal"></highlight></codeline>
<codeline lineno="2515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="2516"><highlight class="normal"></highlight></codeline>
<codeline lineno="2517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[read];</highlight></codeline>
<codeline lineno="2518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="2530"><highlight class="normal"></highlight></codeline>
<codeline lineno="2531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>T(0.25)<sp/>*<sp/>(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it]<sp/>+<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr]);</highlight></codeline>
<codeline lineno="2532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2534"><highlight class="normal"></highlight></codeline>
<codeline lineno="2535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.BotLeft[XBlock.TopLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(ix<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="2539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="2540"><highlight class="normal"></highlight></codeline>
<codeline lineno="2541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="2542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="2543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="2544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>1,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="2545"><highlight class="normal"></highlight></codeline>
<codeline lineno="2546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>zstop<sp/>=<sp/>BilinearInterpolation(XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[it],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[itr],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ii],<sp/>XEv.<ref refid="struct_evolving_p_1ad46731077e87059e9409024374f47639" kindref="member">zs</ref>[ir],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>jr,<sp/>T(0.25));</highlight></codeline>
<codeline lineno="2547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2548"><highlight class="normal"></highlight></codeline>
<codeline lineno="2549"><highlight class="normal"></highlight></codeline>
<codeline lineno="2550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(utils::sq(dzsdyi)<sp/>&gt;<sp/>utils::sq(XGrad.<ref refid="struct_gradients_p_1af9686c22fbc669c58c288b74549edb98" kindref="member">dzbdy</ref>[i]))</highlight></codeline>
<codeline lineno="2551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2552"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>botzs,<sp/>topzs;</highlight></codeline>
<codeline lineno="2553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>botzs<sp/>=<sp/>zsi<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>-<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdyi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]);</highlight></codeline>
<codeline lineno="2554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topzs<sp/>=<sp/>zsi<sp/>-<sp/>XEv.<ref refid="struct_evolving_p_1a350d5a1cef103428b6f3292acf5f7dd9" kindref="member">h</ref>[i]<sp/>+<sp/>delta<sp/>*<sp/>T(0.5)<sp/>*<sp/>(dzsdyi<sp/>-<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]);</highlight></codeline>
<codeline lineno="2555"><highlight class="normal"></highlight></codeline>
<codeline lineno="2556"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(botzs<sp/>&gt;<sp/>zsbot<sp/>||<sp/>topzs<sp/>&gt;<sp/>zstop)</highlight></codeline>
<codeline lineno="2557"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2558"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>XGrad.<ref refid="struct_gradients_p_1aa29b0cab0dc36dbf955633abfdb4de1c" kindref="member">dzsdy</ref>[i]<sp/>=<sp/>XGrad.<ref refid="struct_gradients_p_1abe2a881d2d1caeb44146412f5b765b64" kindref="member">dhdy</ref>[i]<sp/>+<sp/>XGrad.<ref refid="struct_gradients_p_1af9686c22fbc669c58c288b74549edb98" kindref="member">dzbdy</ref>[i];</highlight></codeline>
<codeline lineno="2559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2560"><highlight class="normal"></highlight></codeline>
<codeline lineno="2561"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2562"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2563"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2564"><highlight class="normal"></highlight></codeline>
<codeline lineno="2565"><highlight class="normal"></highlight></codeline>
<codeline lineno="2566"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2567"><highlight class="normal"></highlight></codeline>
<codeline lineno="2584"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientHalo(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="2585"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2586"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib;</highlight></codeline>
<codeline lineno="2587"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//int<sp/>xplus;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2588"><highlight class="normal"></highlight></codeline>
<codeline lineno="2589"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//T<sp/>delta;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2590"><highlight class="normal"></highlight></codeline>
<codeline lineno="2591"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>0;<sp/>ibl<sp/>&lt;<sp/>XParam.nblk;<sp/>ibl++)</highlight></codeline>
<codeline lineno="2592"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="2594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>0;<sp/>iy<sp/>&lt;<sp/>XParam.blkwidth;<sp/>iy++)</highlight></codeline>
<codeline lineno="2595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientHaloLeft(XParam,<sp/>XBlock,<sp/>ib,<sp/>iy,<sp/>a,<sp/>dadx,<sp/>dady);</highlight></codeline>
<codeline lineno="2597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientHaloRight(XParam,<sp/>XBlock,<sp/>ib,<sp/>iy,<sp/>a,<sp/>dadx,<sp/>dady);</highlight></codeline>
<codeline lineno="2598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>0;<sp/>ix<sp/>&lt;<sp/>XParam.blkwidth;<sp/>ix++)</highlight></codeline>
<codeline lineno="2600"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2601"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientHaloBot(XParam,<sp/>XBlock,<sp/>ib,<sp/>ix,<sp/>a,<sp/>dadx,<sp/>dady);</highlight></codeline>
<codeline lineno="2602"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gradientHaloTop(XParam,<sp/>XBlock,<sp/>ib,<sp/>ix,<sp/>a,<sp/>dadx,<sp/>dady);</highlight></codeline>
<codeline lineno="2603"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2604"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2605"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2606"><highlight class="normal"></highlight></codeline>
<codeline lineno="2624"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientHaloGPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="2625"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2626"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimL(1,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="2627"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimB(XParam.blkwidth,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="2628"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(XParam.nblk,<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="2629"><highlight class="normal"></highlight></codeline>
<codeline lineno="2630"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2631"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHaloLeftGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimL,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>a,<sp/>dadx,<sp/>dady);</highlight></codeline>
<codeline lineno="2632"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="2633"><highlight class="normal"></highlight></codeline>
<codeline lineno="2634"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHaloRightGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimL,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>a,<sp/>dadx,<sp/>dady);</highlight></codeline>
<codeline lineno="2635"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="2636"><highlight class="normal"></highlight></codeline>
<codeline lineno="2637"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHaloBotGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimB,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>a,<sp/>dadx,<sp/>dady);</highlight></codeline>
<codeline lineno="2638"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="2639"><highlight class="normal"></highlight></codeline>
<codeline lineno="2640"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHaloTopGPU<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimB,<sp/>0<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>a,<sp/>dadx,<sp/>dady);</highlight></codeline>
<codeline lineno="2641"><highlight class="normal"><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaDeviceSynchronize());</highlight></codeline>
<codeline lineno="2642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2643"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2644"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2645"><highlight class="normal"></highlight></codeline>
<codeline lineno="2663"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientHaloGPUnew(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="2664"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2665"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_streams<sp/>=<sp/>4;</highlight></codeline>
<codeline lineno="2666"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2667"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaStream_t<sp/>streams[num_streams];</highlight></codeline>
<codeline lineno="2668"><highlight class="normal"></highlight></codeline>
<codeline lineno="2669"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="2670"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2671"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));</highlight></codeline>
<codeline lineno="2672"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2673"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2674"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimL(2,<sp/>XParam.blkwidth,<sp/>1);</highlight></codeline>
<codeline lineno="2675"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>blockDimB(XParam.blkwidth,<sp/>2,<sp/>1);</highlight></codeline>
<codeline lineno="2676"><highlight class="normal"><sp/><sp/><sp/><sp/>dim3<sp/>gridDim(ceil(XParam.nblk/2),<sp/>1,<sp/>1);</highlight></codeline>
<codeline lineno="2677"><highlight class="normal"></highlight></codeline>
<codeline lineno="2678"><highlight class="normal"></highlight></codeline>
<codeline lineno="2679"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHaloLeftGPUnew<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimL,<sp/>0,<sp/>streams[0]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>a,<sp/>dadx,<sp/>dady);</highlight></codeline>
<codeline lineno="2680"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2681"><highlight class="normal"></highlight></codeline>
<codeline lineno="2682"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHaloRightGPUnew<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimL,<sp/>0,<sp/>streams[1]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>a,<sp/>dadx,<sp/>dady);</highlight></codeline>
<codeline lineno="2683"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2684"><highlight class="normal"></highlight></codeline>
<codeline lineno="2685"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHaloBotGPUnew<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimB,<sp/>0,<sp/>streams[2]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>a,<sp/>dadx,<sp/>dady);</highlight></codeline>
<codeline lineno="2686"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2687"><highlight class="normal"></highlight></codeline>
<codeline lineno="2688"><highlight class="normal"><sp/><sp/><sp/><sp/>gradientHaloTopGPUnew<sp/>&lt;&lt;&lt;<sp/>gridDim,<sp/>blockDimB,<sp/>0,<sp/>streams[3]<sp/>&gt;&gt;&gt;<sp/>(XParam,<sp/>XBlock,<sp/>a,<sp/>dadx,<sp/>dady);</highlight></codeline>
<codeline lineno="2689"><highlight class="normal"></highlight></codeline>
<codeline lineno="2690"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//CUDA_CHECK(cudaDeviceSynchronize());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2691"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2692"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_streams;<sp/>i++)</highlight></codeline>
<codeline lineno="2693"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStreamDestroy(streams[i]);</highlight></codeline>
<codeline lineno="2695"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2696"><highlight class="normal"></highlight></codeline>
<codeline lineno="2697"><highlight class="normal"></highlight></codeline>
<codeline lineno="2698"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2699"><highlight class="normal"></highlight></codeline>
<codeline lineno="2713"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientHaloLeft(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="2714"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2715"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>ix,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="2716"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>xplus,<sp/>read;</highlight></codeline>
<codeline lineno="2717"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2718"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta,<sp/>aright,<sp/>aleft;</highlight></codeline>
<codeline lineno="2719"><highlight class="normal"></highlight></codeline>
<codeline lineno="2720"><highlight class="normal"><sp/><sp/><sp/><sp/>ix<sp/>=<sp/>-1;</highlight></codeline>
<codeline lineno="2721"><highlight class="normal"></highlight></codeline>
<codeline lineno="2722"><highlight class="normal"><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2723"><highlight class="normal"><sp/><sp/><sp/><sp/>xplus<sp/>=<sp/>memloc(XParam,<sp/>ix<sp/>+<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2724"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2725"><highlight class="normal"></highlight></codeline>
<codeline lineno="2726"><highlight class="normal"><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>a[xplus];</highlight></codeline>
<codeline lineno="2727"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2728"><highlight class="normal"></highlight></codeline>
<codeline lineno="2729"><highlight class="normal"></highlight></codeline>
<codeline lineno="2730"><highlight class="normal"><sp/><sp/><sp/><sp/>delta<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib]);</highlight></codeline>
<codeline lineno="2731"><highlight class="normal"></highlight></codeline>
<codeline lineno="2732"><highlight class="normal"></highlight></codeline>
<codeline lineno="2733"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2734"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2737"><highlight class="normal"></highlight></codeline>
<codeline lineno="2738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>iy,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2742"><highlight class="normal"></highlight></codeline>
<codeline lineno="2743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2748"><highlight class="normal"></highlight></codeline>
<codeline lineno="2749"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2750"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2753"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2756"><highlight class="normal"></highlight></codeline>
<codeline lineno="2757"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2758"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2759"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="2762"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="2763"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="2764"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="2765"><highlight class="normal"></highlight></codeline>
<codeline lineno="2766"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2767"><highlight class="normal"></highlight></codeline>
<codeline lineno="2768"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2769"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2770"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2771"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.LeftBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2772"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2773"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>iy,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="2775"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2777"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2778"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="2779"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2780"><highlight class="normal"></highlight></codeline>
<codeline lineno="2781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2783"><highlight class="normal"></highlight></codeline>
<codeline lineno="2784"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2785"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.LeftBot[ib];</highlight></codeline>
<codeline lineno="2786"><highlight class="normal"></highlight></codeline>
<codeline lineno="2787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2788"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2790"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2791"><highlight class="normal"></highlight></codeline>
<codeline lineno="2792"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2793"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2794"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2797"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2800"><highlight class="normal"></highlight></codeline>
<codeline lineno="2801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2803"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2805"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2806"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2807"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2809"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2810"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2811"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2812"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="2813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="2814"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="2815"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="2816"><highlight class="normal"></highlight></codeline>
<codeline lineno="2817"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2818"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2819"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2820"><highlight class="normal"></highlight></codeline>
<codeline lineno="2821"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2822"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2823"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2824"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.RightBot[XBlock.LeftBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(iy<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="2825"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//T<sp/>jr<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.75)<sp/>:<sp/>T(0.25);//<sp/>This<sp/>is<sp/>the<sp/>wrong<sp/>way<sp/>around</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2826"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);<sp/></highlight><highlight class="comment">//<sp/>This<sp/>is<sp/>right<sp/>(e.g.<sp/>at<sp/>iy==0<sp/>use<sp/>0.75<sp/>at<sp/>iy==1<sp/>use<sp/>0.25)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2827"><highlight class="normal"></highlight></codeline>
<codeline lineno="2828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="2829"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="2830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="2831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="2832"><highlight class="normal"></highlight></codeline>
<codeline lineno="2833"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>BilinearInterpolation(a[itr],<sp/>a[ir],<sp/>a[it],<sp/>a[ii],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.75),<sp/>jr);</highlight></codeline>
<codeline lineno="2834"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2835"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2836"><highlight class="normal"></highlight></codeline>
<codeline lineno="2837"><highlight class="normal"></highlight></codeline>
<codeline lineno="2838"><highlight class="normal"></highlight></codeline>
<codeline lineno="2839"><highlight class="normal"></highlight></codeline>
<codeline lineno="2840"><highlight class="normal"><sp/><sp/><sp/><sp/>dadx[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>aleft,<sp/>a[i],<sp/>aright)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="2841"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dady[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>abot,<sp/>a[i],<sp/>atop)<sp/>/<sp/>delta;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2842"><highlight class="normal"></highlight></codeline>
<codeline lineno="2843"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2844"><highlight class="normal"></highlight></codeline>
<codeline lineno="2858"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientHaloRight(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="2859"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2860"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>ix,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="2861"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>xminus,<sp/>read;</highlight></codeline>
<codeline lineno="2862"><highlight class="normal"></highlight></codeline>
<codeline lineno="2863"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta,<sp/>aright,<sp/>aleft;</highlight></codeline>
<codeline lineno="2864"><highlight class="normal"></highlight></codeline>
<codeline lineno="2865"><highlight class="normal"><sp/><sp/><sp/><sp/>ix<sp/>=<sp/>16;</highlight></codeline>
<codeline lineno="2866"><highlight class="normal"></highlight></codeline>
<codeline lineno="2867"><highlight class="normal"><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2868"><highlight class="normal"><sp/><sp/><sp/><sp/>xminus<sp/>=<sp/>memloc(XParam,<sp/>ix<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2869"><highlight class="normal"></highlight></codeline>
<codeline lineno="2870"><highlight class="normal"></highlight></codeline>
<codeline lineno="2871"><highlight class="normal"><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>a[xminus];</highlight></codeline>
<codeline lineno="2872"><highlight class="normal"></highlight></codeline>
<codeline lineno="2873"><highlight class="normal"></highlight></codeline>
<codeline lineno="2874"><highlight class="normal"></highlight></codeline>
<codeline lineno="2875"><highlight class="normal"><sp/><sp/><sp/><sp/>delta<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib]);</highlight></codeline>
<codeline lineno="2876"><highlight class="normal"></highlight></codeline>
<codeline lineno="2877"><highlight class="normal"></highlight></codeline>
<codeline lineno="2878"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2879"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2881"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2882"><highlight class="normal"></highlight></codeline>
<codeline lineno="2883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-1,<sp/>iy,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2884"><highlight class="normal"></highlight></codeline>
<codeline lineno="2885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2886"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2887"><highlight class="normal"></highlight></codeline>
<codeline lineno="2888"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2889"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2890"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2891"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2892"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2893"><highlight class="normal"></highlight></codeline>
<codeline lineno="2894"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2895"><highlight class="normal"></highlight></codeline>
<codeline lineno="2896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2897"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2898"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2899"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>righttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2900"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2901"><highlight class="normal"></highlight></codeline>
<codeline lineno="2902"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2903"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2904"><highlight class="normal"></highlight></codeline>
<codeline lineno="2905"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2906"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>3,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="2907"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>2,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="2908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>3,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="2909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>2,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="2910"><highlight class="normal"></highlight></codeline>
<codeline lineno="2911"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2912"><highlight class="normal"></highlight></codeline>
<codeline lineno="2913"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2914"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2915"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2916"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.RightBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2917"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2918"><highlight class="normal"></highlight></codeline>
<codeline lineno="2919"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>iy,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="2920"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2921"><highlight class="normal"></highlight></codeline>
<codeline lineno="2922"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2923"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="2924"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2925"><highlight class="normal"></highlight></codeline>
<codeline lineno="2926"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2927"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2928"><highlight class="normal"></highlight></codeline>
<codeline lineno="2929"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2930"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.RightBot[ib];</highlight></codeline>
<codeline lineno="2931"><highlight class="normal"></highlight></codeline>
<codeline lineno="2932"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>3,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>2,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="2934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>3,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2935"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>2,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="2936"><highlight class="normal"></highlight></codeline>
<codeline lineno="2937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="2941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2944"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2945"><highlight class="normal"></highlight></codeline>
<codeline lineno="2946"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="2947"><highlight class="normal"></highlight></codeline>
<codeline lineno="2948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="2949"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2952"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2953"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="2954"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2955"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2956"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="2957"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>3,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="2958"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>2,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="2959"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>3,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="2960"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>2,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="2961"><highlight class="normal"></highlight></codeline>
<codeline lineno="2962"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="2963"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2965"><highlight class="normal"></highlight></codeline>
<codeline lineno="2966"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2967"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2968"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2969"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.LeftBot[XBlock.RightBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(iy<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="2970"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="2971"><highlight class="normal"></highlight></codeline>
<codeline lineno="2972"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="2973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="2974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>0,<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="2975"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>1,<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="2976"><highlight class="normal"></highlight></codeline>
<codeline lineno="2977"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>BilinearInterpolation(a[it],<sp/>a[ii],<sp/>a[itr],<sp/>a[ir],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.25),<sp/>jr);</highlight></codeline>
<codeline lineno="2978"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2979"><highlight class="normal"></highlight></codeline>
<codeline lineno="2980"><highlight class="normal"></highlight></codeline>
<codeline lineno="2981"><highlight class="normal"></highlight></codeline>
<codeline lineno="2982"><highlight class="normal"></highlight></codeline>
<codeline lineno="2983"><highlight class="normal"></highlight></codeline>
<codeline lineno="2984"><highlight class="normal"><sp/><sp/><sp/><sp/>dadx[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>aleft,<sp/>a[i],<sp/>aright)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="2985"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dady[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>abot,<sp/>a[i],<sp/>atop)<sp/>/<sp/>delta;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2986"><highlight class="normal"></highlight></codeline>
<codeline lineno="2987"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2988"><highlight class="normal"></highlight></codeline>
<codeline lineno="3002"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientHaloBot(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="3003"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3004"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>iy,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="3005"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>yplus,<sp/>read;</highlight></codeline>
<codeline lineno="3006"><highlight class="normal"></highlight></codeline>
<codeline lineno="3007"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta,<sp/>atop,<sp/>abot;</highlight></codeline>
<codeline lineno="3008"><highlight class="normal"></highlight></codeline>
<codeline lineno="3009"><highlight class="normal"><sp/><sp/><sp/><sp/>iy<sp/>=<sp/>-1;</highlight></codeline>
<codeline lineno="3010"><highlight class="normal"></highlight></codeline>
<codeline lineno="3011"><highlight class="normal"><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3012"><highlight class="normal"><sp/><sp/><sp/><sp/>yplus<sp/>=<sp/>memloc(XParam,<sp/>ix<sp/>,<sp/>iy<sp/>+<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="3013"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3014"><highlight class="normal"></highlight></codeline>
<codeline lineno="3015"><highlight class="normal"></highlight></codeline>
<codeline lineno="3016"><highlight class="normal"></highlight></codeline>
<codeline lineno="3017"><highlight class="normal"><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>a[yplus];</highlight></codeline>
<codeline lineno="3018"><highlight class="normal"></highlight></codeline>
<codeline lineno="3019"><highlight class="normal"></highlight></codeline>
<codeline lineno="3020"><highlight class="normal"></highlight></codeline>
<codeline lineno="3021"><highlight class="normal"><sp/><sp/><sp/><sp/>delta<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib]);</highlight></codeline>
<codeline lineno="3022"><highlight class="normal"></highlight></codeline>
<codeline lineno="3023"><highlight class="normal"></highlight></codeline>
<codeline lineno="3024"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3025"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3026"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3027"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3028"><highlight class="normal"></highlight></codeline>
<codeline lineno="3029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>0,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3030"><highlight class="normal"></highlight></codeline>
<codeline lineno="3031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3033"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3034"><highlight class="normal"></highlight></codeline>
<codeline lineno="3035"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3040"><highlight class="normal"></highlight></codeline>
<codeline lineno="3041"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3042"><highlight class="normal"></highlight></codeline>
<codeline lineno="3043"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3046"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3048"><highlight class="normal"></highlight></codeline>
<codeline lineno="3049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3050"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3051"><highlight class="normal"></highlight></codeline>
<codeline lineno="3052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3053"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3057"><highlight class="normal"></highlight></codeline>
<codeline lineno="3058"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3059"><highlight class="normal"></highlight></codeline>
<codeline lineno="3060"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3061"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3062"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3063"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.BotLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3064"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3065"><highlight class="normal"></highlight></codeline>
<codeline lineno="3066"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="3067"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3068"><highlight class="normal"></highlight></codeline>
<codeline lineno="3069"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3070"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="3071"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3072"><highlight class="normal"></highlight></codeline>
<codeline lineno="3073"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3074"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3075"><highlight class="normal"></highlight></codeline>
<codeline lineno="3076"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3077"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.BotLeft[ib];</highlight></codeline>
<codeline lineno="3078"><highlight class="normal"></highlight></codeline>
<codeline lineno="3079"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>bb);</highlight></codeline>
<codeline lineno="3080"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>bb);</highlight></codeline>
<codeline lineno="3081"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>bb);</highlight></codeline>
<codeline lineno="3082"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>bb);</highlight></codeline>
<codeline lineno="3083"><highlight class="normal"></highlight></codeline>
<codeline lineno="3084"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3085"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3086"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3087"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3088"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3089"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3090"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3091"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3092"><highlight class="normal"></highlight></codeline>
<codeline lineno="3093"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3094"><highlight class="normal"></highlight></codeline>
<codeline lineno="3095"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3096"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3097"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3098"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3099"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3108"><highlight class="normal"></highlight></codeline>
<codeline lineno="3109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3112"><highlight class="normal"></highlight></codeline>
<codeline lineno="3113"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3114"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3115"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.TopLeft[XBlock.BotLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(ix<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="3117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="3118"><highlight class="normal"></highlight></codeline>
<codeline lineno="3119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="3120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="3121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>-<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="3122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>-<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="3123"><highlight class="normal"></highlight></codeline>
<codeline lineno="3124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>BilinearInterpolation(a[itr],<sp/>a[it],<sp/>a[ir],<sp/>a[ii],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>jr,<sp/>T(0.75));</highlight></codeline>
<codeline lineno="3125"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3126"><highlight class="normal"></highlight></codeline>
<codeline lineno="3127"><highlight class="normal"></highlight></codeline>
<codeline lineno="3128"><highlight class="normal"></highlight></codeline>
<codeline lineno="3129"><highlight class="normal"></highlight></codeline>
<codeline lineno="3130"><highlight class="normal"></highlight></codeline>
<codeline lineno="3131"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dadx[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>aleft,<sp/>a[i],<sp/>aright)<sp/>/<sp/>delta;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3132"><highlight class="normal"><sp/><sp/><sp/><sp/>dady[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>abot,<sp/>a[i],<sp/>atop)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="3133"><highlight class="normal"></highlight></codeline>
<codeline lineno="3134"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3135"><highlight class="normal"></highlight></codeline>
<codeline lineno="3149"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientHaloTop(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="3150"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3151"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>iy,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="3152"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>yminus,<sp/>read;</highlight></codeline>
<codeline lineno="3153"><highlight class="normal"></highlight></codeline>
<codeline lineno="3154"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta,<sp/>atop,<sp/>abot;</highlight></codeline>
<codeline lineno="3155"><highlight class="normal"></highlight></codeline>
<codeline lineno="3156"><highlight class="normal"><sp/><sp/><sp/><sp/>iy<sp/>=<sp/>XParam.blkwidth;</highlight></codeline>
<codeline lineno="3157"><highlight class="normal"></highlight></codeline>
<codeline lineno="3158"><highlight class="normal"><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3159"><highlight class="normal"><sp/><sp/><sp/><sp/>yminus<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>XParam.blkwidth-1,<sp/>ib);</highlight></codeline>
<codeline lineno="3160"><highlight class="normal"></highlight></codeline>
<codeline lineno="3161"><highlight class="normal"></highlight></codeline>
<codeline lineno="3162"><highlight class="normal"></highlight></codeline>
<codeline lineno="3163"><highlight class="normal"></highlight></codeline>
<codeline lineno="3164"><highlight class="normal"><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>a[yminus];</highlight></codeline>
<codeline lineno="3165"><highlight class="normal"></highlight></codeline>
<codeline lineno="3166"><highlight class="normal"></highlight></codeline>
<codeline lineno="3167"><highlight class="normal"></highlight></codeline>
<codeline lineno="3168"><highlight class="normal"><sp/><sp/><sp/><sp/>delta<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib]);</highlight></codeline>
<codeline lineno="3169"><highlight class="normal"></highlight></codeline>
<codeline lineno="3170"><highlight class="normal"></highlight></codeline>
<codeline lineno="3171"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3172"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3175"><highlight class="normal"></highlight></codeline>
<codeline lineno="3176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3177"><highlight class="normal"></highlight></codeline>
<codeline lineno="3178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3179"><highlight class="normal"></highlight></codeline>
<codeline lineno="3180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3181"><highlight class="normal"></highlight></codeline>
<codeline lineno="3182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3187"><highlight class="normal"></highlight></codeline>
<codeline lineno="3188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="3189"><highlight class="normal"></highlight></codeline>
<codeline lineno="3190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3195"><highlight class="normal"></highlight></codeline>
<codeline lineno="3196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3198"><highlight class="normal"></highlight></codeline>
<codeline lineno="3199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="3201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="3202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="3203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="3204"><highlight class="normal"></highlight></codeline>
<codeline lineno="3205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3206"><highlight class="normal"></highlight></codeline>
<codeline lineno="3207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3209"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3210"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.TopLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3211"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3212"><highlight class="normal"></highlight></codeline>
<codeline lineno="3213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>1,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="3214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3215"><highlight class="normal"></highlight></codeline>
<codeline lineno="3216"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3217"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="3218"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3219"><highlight class="normal"></highlight></codeline>
<codeline lineno="3220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3222"><highlight class="normal"></highlight></codeline>
<codeline lineno="3223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.TopLeft[ib];</highlight></codeline>
<codeline lineno="3225"><highlight class="normal"></highlight></codeline>
<codeline lineno="3226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>3,<sp/>bb);</highlight></codeline>
<codeline lineno="3227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>2,<sp/>bb);</highlight></codeline>
<codeline lineno="3228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>3,<sp/>bb);</highlight></codeline>
<codeline lineno="3229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>2,<sp/>bb);</highlight></codeline>
<codeline lineno="3230"><highlight class="normal"></highlight></codeline>
<codeline lineno="3231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3239"><highlight class="normal"></highlight></codeline>
<codeline lineno="3240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam,<sp/>ix,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="3241"><highlight class="normal"></highlight></codeline>
<codeline lineno="3242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="3252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="3253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="3254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>+<sp/>1,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="3255"><highlight class="normal"></highlight></codeline>
<codeline lineno="3256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3259"><highlight class="normal"></highlight></codeline>
<codeline lineno="3260"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3261"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3262"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.BotLeft[XBlock.TopLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ftoi(ceil(ix<sp/>*<sp/>(T)0.5))<sp/>:<sp/>ftoi(ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="3264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="3265"><highlight class="normal"></highlight></codeline>
<codeline lineno="3266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="3267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam,<sp/>jj,<sp/>1,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="3268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>-<sp/>1,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="3269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam,<sp/>jj<sp/>-<sp/>1,<sp/>1,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="3270"><highlight class="normal"></highlight></codeline>
<codeline lineno="3271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>BilinearInterpolation(a[it],<sp/>a[itr],<sp/>a[ii],<sp/>a[ir],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>jr,<sp/>T(0.25));</highlight></codeline>
<codeline lineno="3272"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3273"><highlight class="normal"></highlight></codeline>
<codeline lineno="3274"><highlight class="normal"></highlight></codeline>
<codeline lineno="3275"><highlight class="normal"></highlight></codeline>
<codeline lineno="3276"><highlight class="normal"></highlight></codeline>
<codeline lineno="3277"><highlight class="normal"></highlight></codeline>
<codeline lineno="3278"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dadx[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>aleft,<sp/>a[i],<sp/>aright)<sp/>/<sp/>delta;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3279"><highlight class="normal"><sp/><sp/><sp/><sp/>dady[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>abot,<sp/>a[i],<sp/>atop)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="3280"><highlight class="normal"></highlight></codeline>
<codeline lineno="3281"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3282"><highlight class="normal"></highlight></codeline>
<codeline lineno="3283"><highlight class="normal"></highlight></codeline>
<codeline lineno="3295"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientHaloLeftGPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="3296"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3297"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3298"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>XParam.blkmemwidth<sp/>*<sp/>XParam.blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3299"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>-1;</highlight></codeline>
<codeline lineno="3300"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="3301"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="3302"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="3303"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="3304"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>xplus,<sp/>read;</highlight></codeline>
<codeline lineno="3305"><highlight class="normal"></highlight></codeline>
<codeline lineno="3306"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta,<sp/>aright,<sp/>aleft;</highlight></codeline>
<codeline lineno="3307"><highlight class="normal"></highlight></codeline>
<codeline lineno="3308"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3309"><highlight class="normal"></highlight></codeline>
<codeline lineno="3310"><highlight class="normal"><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3311"><highlight class="normal"><sp/><sp/><sp/><sp/>xplus<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>+<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3312"><highlight class="normal"></highlight></codeline>
<codeline lineno="3313"><highlight class="normal"></highlight></codeline>
<codeline lineno="3314"><highlight class="normal"><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>a[xplus];</highlight></codeline>
<codeline lineno="3315"><highlight class="normal"></highlight></codeline>
<codeline lineno="3316"><highlight class="normal"></highlight></codeline>
<codeline lineno="3317"><highlight class="normal"></highlight></codeline>
<codeline lineno="3318"><highlight class="normal"><sp/><sp/><sp/><sp/>delta<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib]);</highlight></codeline>
<codeline lineno="3319"><highlight class="normal"></highlight></codeline>
<codeline lineno="3320"><highlight class="normal"></highlight></codeline>
<codeline lineno="3321"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3322"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3325"><highlight class="normal"></highlight></codeline>
<codeline lineno="3326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3327"><highlight class="normal"></highlight></codeline>
<codeline lineno="3328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3330"><highlight class="normal"></highlight></codeline>
<codeline lineno="3331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3336"><highlight class="normal"></highlight></codeline>
<codeline lineno="3337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3338"><highlight class="normal"></highlight></codeline>
<codeline lineno="3339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3344"><highlight class="normal"></highlight></codeline>
<codeline lineno="3345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3347"><highlight class="normal"></highlight></codeline>
<codeline lineno="3348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="3350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="3351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="3352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="3353"><highlight class="normal"></highlight></codeline>
<codeline lineno="3354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3355"><highlight class="normal"></highlight></codeline>
<codeline lineno="3356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3358"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3359"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.LeftBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3360"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3361"><highlight class="normal"></highlight></codeline>
<codeline lineno="3362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>iy,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="3363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3364"><highlight class="normal"></highlight></codeline>
<codeline lineno="3365"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3366"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="3367"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3368"><highlight class="normal"></highlight></codeline>
<codeline lineno="3369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3371"><highlight class="normal"></highlight></codeline>
<codeline lineno="3372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.LeftBot[ib];</highlight></codeline>
<codeline lineno="3374"><highlight class="normal"></highlight></codeline>
<codeline lineno="3375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="3376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="3377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="3378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="3379"><highlight class="normal"></highlight></codeline>
<codeline lineno="3380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3388"><highlight class="normal"></highlight></codeline>
<codeline lineno="3389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3390"><highlight class="normal"></highlight></codeline>
<codeline lineno="3391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3394"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3398"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="3401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="3402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="3403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="3404"><highlight class="normal"></highlight></codeline>
<codeline lineno="3405"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3408"><highlight class="normal"></highlight></codeline>
<codeline lineno="3409"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3410"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3411"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.RightBot[XBlock.LeftBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="3413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="3414"><highlight class="normal"></highlight></codeline>
<codeline lineno="3415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="3416"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="3417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="3418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="3419"><highlight class="normal"></highlight></codeline>
<codeline lineno="3420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>BilinearInterpolation(a[itr],<sp/>a[ir],<sp/>a[it],<sp/>a[ii],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.75),<sp/>jr);</highlight></codeline>
<codeline lineno="3421"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3422"><highlight class="normal"></highlight></codeline>
<codeline lineno="3423"><highlight class="normal"></highlight></codeline>
<codeline lineno="3424"><highlight class="normal"></highlight></codeline>
<codeline lineno="3425"><highlight class="normal"></highlight></codeline>
<codeline lineno="3426"><highlight class="normal"></highlight></codeline>
<codeline lineno="3427"><highlight class="normal"><sp/><sp/><sp/><sp/>dadx[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>aleft,<sp/>a[i],<sp/>aright)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="3428"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dady[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>abot,<sp/>a[i],<sp/>atop)<sp/>/<sp/>delta;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3429"><highlight class="normal"></highlight></codeline>
<codeline lineno="3430"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3431"><highlight class="normal"></highlight></codeline>
<codeline lineno="3443"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientHaloLeftGPUnew(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="3444"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3445"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3446"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>XParam.blkmemwidth<sp/>*<sp/>XParam.blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3447"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>-1;</highlight></codeline>
<codeline lineno="3448"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="3449"><highlight class="normal"></highlight></codeline>
<codeline lineno="3450"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;;</highlight></codeline>
<codeline lineno="3451"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ibl<sp/>&lt;<sp/>XParam.nblk)</highlight></codeline>
<codeline lineno="3452"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3453"><highlight class="normal"></highlight></codeline>
<codeline lineno="3454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="3455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="3456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>xplus,<sp/>read;</highlight></codeline>
<codeline lineno="3457"><highlight class="normal"></highlight></codeline>
<codeline lineno="3458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>delta,<sp/>aright,<sp/>aleft;</highlight></codeline>
<codeline lineno="3459"><highlight class="normal"></highlight></codeline>
<codeline lineno="3460"><highlight class="normal"></highlight></codeline>
<codeline lineno="3461"><highlight class="normal"></highlight></codeline>
<codeline lineno="3462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xplus<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>+<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3464"><highlight class="normal"></highlight></codeline>
<codeline lineno="3465"><highlight class="normal"></highlight></codeline>
<codeline lineno="3466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>a[xplus];</highlight></codeline>
<codeline lineno="3467"><highlight class="normal"></highlight></codeline>
<codeline lineno="3468"><highlight class="normal"></highlight></codeline>
<codeline lineno="3469"><highlight class="normal"></highlight></codeline>
<codeline lineno="3470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delta<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib]);</highlight></codeline>
<codeline lineno="3471"><highlight class="normal"></highlight></codeline>
<codeline lineno="3472"><highlight class="normal"></highlight></codeline>
<codeline lineno="3473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3477"><highlight class="normal"></highlight></codeline>
<codeline lineno="3478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3479"><highlight class="normal"></highlight></codeline>
<codeline lineno="3480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3482"><highlight class="normal"></highlight></codeline>
<codeline lineno="3483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3488"><highlight class="normal"></highlight></codeline>
<codeline lineno="3489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3490"><highlight class="normal"></highlight></codeline>
<codeline lineno="3491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3496"><highlight class="normal"></highlight></codeline>
<codeline lineno="3497"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3499"><highlight class="normal"></highlight></codeline>
<codeline lineno="3500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="3502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="3503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="3504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="3505"><highlight class="normal"></highlight></codeline>
<codeline lineno="3506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3507"><highlight class="normal"></highlight></codeline>
<codeline lineno="3508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.LeftBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3513"><highlight class="normal"></highlight></codeline>
<codeline lineno="3514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>iy,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="3515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3516"><highlight class="normal"></highlight></codeline>
<codeline lineno="3517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="3519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3520"><highlight class="normal"></highlight></codeline>
<codeline lineno="3521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3523"><highlight class="normal"></highlight></codeline>
<codeline lineno="3524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.LeftBot[ib];</highlight></codeline>
<codeline lineno="3526"><highlight class="normal"></highlight></codeline>
<codeline lineno="3527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="3528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="3529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="3530"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="3531"><highlight class="normal"></highlight></codeline>
<codeline lineno="3532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.LeftTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3540"><highlight class="normal"></highlight></codeline>
<codeline lineno="3541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3542"><highlight class="normal"></highlight></codeline>
<codeline lineno="3543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3549"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3552"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="3553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="3554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="3555"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.LeftTop[ib]);</highlight></codeline>
<codeline lineno="3556"><highlight class="normal"></highlight></codeline>
<codeline lineno="3557"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3558"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3560"><highlight class="normal"></highlight></codeline>
<codeline lineno="3561"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3562"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.LeftBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3563"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3564"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.RightBot[XBlock.LeftBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="3565"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="3566"><highlight class="normal"></highlight></codeline>
<codeline lineno="3567"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="3568"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="3569"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="3570"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.LeftBot[ib]);</highlight></codeline>
<codeline lineno="3571"><highlight class="normal"></highlight></codeline>
<codeline lineno="3572"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>BilinearInterpolation(a[itr],<sp/>a[ir],<sp/>a[it],<sp/>a[ii],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.75),<sp/>jr);</highlight></codeline>
<codeline lineno="3573"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3574"><highlight class="normal"></highlight></codeline>
<codeline lineno="3575"><highlight class="normal"></highlight></codeline>
<codeline lineno="3576"><highlight class="normal"></highlight></codeline>
<codeline lineno="3577"><highlight class="normal"></highlight></codeline>
<codeline lineno="3578"><highlight class="normal"></highlight></codeline>
<codeline lineno="3579"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dadx[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>aleft,<sp/>a[i],<sp/>aright)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="3580"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dady[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>abot,<sp/>a[i],<sp/>atop)<sp/>/<sp/>delta;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3581"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3582"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3583"><highlight class="normal"></highlight></codeline>
<codeline lineno="3595"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientHaloRightGPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="3596"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3597"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3598"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>XParam.blkmemwidth<sp/>*<sp/>XParam.blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3599"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>XParam.blkwidth;</highlight></codeline>
<codeline lineno="3600"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="3601"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="3602"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="3603"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="3604"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>xminus,<sp/>read;</highlight></codeline>
<codeline lineno="3605"><highlight class="normal"></highlight></codeline>
<codeline lineno="3606"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta,<sp/>aright,<sp/>aleft;</highlight></codeline>
<codeline lineno="3607"><highlight class="normal"></highlight></codeline>
<codeline lineno="3608"><highlight class="normal"></highlight></codeline>
<codeline lineno="3609"><highlight class="normal"></highlight></codeline>
<codeline lineno="3610"><highlight class="normal"><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3611"><highlight class="normal"><sp/><sp/><sp/><sp/>xminus<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3612"><highlight class="normal"></highlight></codeline>
<codeline lineno="3613"><highlight class="normal"></highlight></codeline>
<codeline lineno="3614"><highlight class="normal"><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>a[xminus];</highlight></codeline>
<codeline lineno="3615"><highlight class="normal"></highlight></codeline>
<codeline lineno="3616"><highlight class="normal"></highlight></codeline>
<codeline lineno="3617"><highlight class="normal"></highlight></codeline>
<codeline lineno="3618"><highlight class="normal"><sp/><sp/><sp/><sp/>delta<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib]);</highlight></codeline>
<codeline lineno="3619"><highlight class="normal"></highlight></codeline>
<codeline lineno="3620"><highlight class="normal"></highlight></codeline>
<codeline lineno="3621"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3622"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3623"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3625"><highlight class="normal"></highlight></codeline>
<codeline lineno="3626"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3627"><highlight class="normal"></highlight></codeline>
<codeline lineno="3628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>a[read];;</highlight></codeline>
<codeline lineno="3629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3630"><highlight class="normal"></highlight></codeline>
<codeline lineno="3631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3632"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3633"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3634"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3635"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3636"><highlight class="normal"></highlight></codeline>
<codeline lineno="3637"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3638"><highlight class="normal"></highlight></codeline>
<codeline lineno="3639"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3644"><highlight class="normal"></highlight></codeline>
<codeline lineno="3645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3647"><highlight class="normal"></highlight></codeline>
<codeline lineno="3648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3653"><highlight class="normal"></highlight></codeline>
<codeline lineno="3654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3655"><highlight class="normal"></highlight></codeline>
<codeline lineno="3656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3658"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3659"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.RightBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3660"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3661"><highlight class="normal"></highlight></codeline>
<codeline lineno="3662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>iy,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="3663"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3664"><highlight class="normal"></highlight></codeline>
<codeline lineno="3665"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3666"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="3667"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3668"><highlight class="normal"></highlight></codeline>
<codeline lineno="3669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3670"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3671"><highlight class="normal"></highlight></codeline>
<codeline lineno="3672"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.RightBot[ib];</highlight></codeline>
<codeline lineno="3674"><highlight class="normal"></highlight></codeline>
<codeline lineno="3675"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="3676"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="3677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="3678"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="3679"><highlight class="normal"></highlight></codeline>
<codeline lineno="3680"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3681"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3682"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3683"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3684"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3685"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3686"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3688"><highlight class="normal"></highlight></codeline>
<codeline lineno="3689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3690"><highlight class="normal"></highlight></codeline>
<codeline lineno="3691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3693"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3696"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3697"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3699"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3700"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3701"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3704"><highlight class="normal"></highlight></codeline>
<codeline lineno="3705"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3706"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3707"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3708"><highlight class="normal"></highlight></codeline>
<codeline lineno="3709"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3710"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3711"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.LeftBot[XBlock.RightBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="3713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="3714"><highlight class="normal"></highlight></codeline>
<codeline lineno="3715"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="3716"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="3717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="3718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="3719"><highlight class="normal"></highlight></codeline>
<codeline lineno="3720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>BilinearInterpolation(a[it],<sp/>a[ii],<sp/>a[itr],<sp/>a[ir],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.25),<sp/>jr);</highlight></codeline>
<codeline lineno="3721"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3722"><highlight class="normal"></highlight></codeline>
<codeline lineno="3723"><highlight class="normal"></highlight></codeline>
<codeline lineno="3724"><highlight class="normal"></highlight></codeline>
<codeline lineno="3725"><highlight class="normal"></highlight></codeline>
<codeline lineno="3726"><highlight class="normal"></highlight></codeline>
<codeline lineno="3727"><highlight class="normal"><sp/><sp/><sp/><sp/>dadx[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>aleft,<sp/>a[i],<sp/>aright)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="3728"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dady[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>abot,<sp/>a[i],<sp/>atop)<sp/>/<sp/>delta;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3729"><highlight class="normal"></highlight></codeline>
<codeline lineno="3730"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3731"><highlight class="normal"></highlight></codeline>
<codeline lineno="3743"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientHaloRightGPUnew(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="3744"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3745"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3746"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>XParam.blkmemwidth<sp/>*<sp/>XParam.blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3747"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>XParam.blkwidth;</highlight></codeline>
<codeline lineno="3748"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>threadIdx.y;</highlight></codeline>
<codeline lineno="3749"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;;</highlight></codeline>
<codeline lineno="3750"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ibl<sp/>&lt;<sp/>XParam.nblk)</highlight></codeline>
<codeline lineno="3751"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="3753"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="3754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>xminus,<sp/>read;</highlight></codeline>
<codeline lineno="3755"><highlight class="normal"></highlight></codeline>
<codeline lineno="3756"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>delta,<sp/>aright,<sp/>aleft;</highlight></codeline>
<codeline lineno="3757"><highlight class="normal"></highlight></codeline>
<codeline lineno="3758"><highlight class="normal"></highlight></codeline>
<codeline lineno="3759"><highlight class="normal"></highlight></codeline>
<codeline lineno="3760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xminus<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3762"><highlight class="normal"></highlight></codeline>
<codeline lineno="3763"><highlight class="normal"></highlight></codeline>
<codeline lineno="3764"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aleft<sp/>=<sp/>a[xminus];</highlight></codeline>
<codeline lineno="3765"><highlight class="normal"></highlight></codeline>
<codeline lineno="3766"><highlight class="normal"></highlight></codeline>
<codeline lineno="3767"><highlight class="normal"></highlight></codeline>
<codeline lineno="3768"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delta<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib]);</highlight></codeline>
<codeline lineno="3769"><highlight class="normal"></highlight></codeline>
<codeline lineno="3770"><highlight class="normal"></highlight></codeline>
<codeline lineno="3771"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightBot[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3773"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3775"><highlight class="normal"></highlight></codeline>
<codeline lineno="3776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3777"><highlight class="normal"></highlight></codeline>
<codeline lineno="3778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>a[read];;</highlight></codeline>
<codeline lineno="3779"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3780"><highlight class="normal"></highlight></codeline>
<codeline lineno="3781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3783"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3784"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3785"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3786"><highlight class="normal"></highlight></codeline>
<codeline lineno="3787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3788"><highlight class="normal"></highlight></codeline>
<codeline lineno="3789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3790"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3791"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3792"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3793"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3794"><highlight class="normal"></highlight></codeline>
<codeline lineno="3795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3797"><highlight class="normal"></highlight></codeline>
<codeline lineno="3798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3803"><highlight class="normal"></highlight></codeline>
<codeline lineno="3804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3805"><highlight class="normal"></highlight></codeline>
<codeline lineno="3806"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3807"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3809"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.RightBot[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3810"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3811"><highlight class="normal"></highlight></codeline>
<codeline lineno="3812"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>iy,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="3813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3814"><highlight class="normal"></highlight></codeline>
<codeline lineno="3815"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3816"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="3817"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3818"><highlight class="normal"></highlight></codeline>
<codeline lineno="3819"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3820"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3821"><highlight class="normal"></highlight></codeline>
<codeline lineno="3822"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>iy<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3823"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.RightBot[ib];</highlight></codeline>
<codeline lineno="3824"><highlight class="normal"></highlight></codeline>
<codeline lineno="3825"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="3826"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj,<sp/>bb);</highlight></codeline>
<codeline lineno="3827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="3828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj<sp/>+<sp/>1,<sp/>bb);</highlight></codeline>
<codeline lineno="3829"><highlight class="normal"></highlight></codeline>
<codeline lineno="3830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3833"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.RightTop[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3838"><highlight class="normal"></highlight></codeline>
<codeline lineno="3839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3840"><highlight class="normal"></highlight></codeline>
<codeline lineno="3841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iy<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(iy<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>3,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3853"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>2,<sp/>jj<sp/>+<sp/>1,<sp/>XBlock.RightTop[ib]);</highlight></codeline>
<codeline lineno="3854"><highlight class="normal"></highlight></codeline>
<codeline lineno="3855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3857"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3858"><highlight class="normal"></highlight></codeline>
<codeline lineno="3859"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.RightBot[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3861"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3862"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.LeftBot[XBlock.RightBot[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="3863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(iy<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>iy<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="3864"><highlight class="normal"></highlight></codeline>
<codeline lineno="3865"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="3866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="3867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>0,<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="3868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>1,<sp/>jj<sp/>-<sp/>1,<sp/>XBlock.RightBot[ib]);</highlight></codeline>
<codeline lineno="3869"><highlight class="normal"></highlight></codeline>
<codeline lineno="3870"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aright<sp/>=<sp/>BilinearInterpolation(a[it],<sp/>a[ii],<sp/>a[itr],<sp/>a[ir],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.25),<sp/>jr);</highlight></codeline>
<codeline lineno="3871"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3872"><highlight class="normal"></highlight></codeline>
<codeline lineno="3873"><highlight class="normal"></highlight></codeline>
<codeline lineno="3874"><highlight class="normal"></highlight></codeline>
<codeline lineno="3875"><highlight class="normal"></highlight></codeline>
<codeline lineno="3876"><highlight class="normal"></highlight></codeline>
<codeline lineno="3877"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dadx[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>aleft,<sp/>a[i],<sp/>aright)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="3878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dady[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>abot,<sp/>a[i],<sp/>atop)<sp/>/<sp/>delta;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3879"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3880"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3881"><highlight class="normal"></highlight></codeline>
<codeline lineno="3893"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientHaloBotGPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="3894"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3895"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3896"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>XParam.blkmemwidth<sp/>*<sp/>XParam.blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3897"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>-1;</highlight></codeline>
<codeline lineno="3898"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="3899"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="3900"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="3901"><highlight class="normal"></highlight></codeline>
<codeline lineno="3902"><highlight class="normal"></highlight></codeline>
<codeline lineno="3903"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="3904"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>yplus,<sp/>read;</highlight></codeline>
<codeline lineno="3905"><highlight class="normal"></highlight></codeline>
<codeline lineno="3906"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta,<sp/>atop,<sp/>abot;</highlight></codeline>
<codeline lineno="3907"><highlight class="normal"></highlight></codeline>
<codeline lineno="3908"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3909"><highlight class="normal"><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="3910"><highlight class="normal"><sp/><sp/><sp/><sp/>yplus<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy<sp/>+<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="3911"><highlight class="normal"></highlight></codeline>
<codeline lineno="3912"><highlight class="normal"></highlight></codeline>
<codeline lineno="3913"><highlight class="normal"></highlight></codeline>
<codeline lineno="3914"><highlight class="normal"></highlight></codeline>
<codeline lineno="3915"><highlight class="normal"><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>a[yplus];</highlight></codeline>
<codeline lineno="3916"><highlight class="normal"></highlight></codeline>
<codeline lineno="3917"><highlight class="normal"></highlight></codeline>
<codeline lineno="3918"><highlight class="normal"></highlight></codeline>
<codeline lineno="3919"><highlight class="normal"><sp/><sp/><sp/><sp/>delta<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib]);</highlight></codeline>
<codeline lineno="3920"><highlight class="normal"></highlight></codeline>
<codeline lineno="3921"><highlight class="normal"></highlight></codeline>
<codeline lineno="3922"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3923"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3924"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3925"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3926"><highlight class="normal"></highlight></codeline>
<codeline lineno="3927"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3928"><highlight class="normal"></highlight></codeline>
<codeline lineno="3929"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3930"><highlight class="normal"></highlight></codeline>
<codeline lineno="3931"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3932"><highlight class="normal"></highlight></codeline>
<codeline lineno="3933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3935"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3938"><highlight class="normal"></highlight></codeline>
<codeline lineno="3939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3940"><highlight class="normal"></highlight></codeline>
<codeline lineno="3941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3944"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3946"><highlight class="normal"></highlight></codeline>
<codeline lineno="3947"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3949"><highlight class="normal"></highlight></codeline>
<codeline lineno="3950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3952"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3953"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3954"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="3955"><highlight class="normal"></highlight></codeline>
<codeline lineno="3956"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3957"><highlight class="normal"></highlight></codeline>
<codeline lineno="3958"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3959"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3960"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3961"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.BotLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3962"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3963"><highlight class="normal"></highlight></codeline>
<codeline lineno="3964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="3965"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3966"><highlight class="normal"></highlight></codeline>
<codeline lineno="3967"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="3968"><highlight class="normal"></highlight></codeline>
<codeline lineno="3969"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3970"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="3971"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3972"><highlight class="normal"></highlight></codeline>
<codeline lineno="3973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3975"><highlight class="normal"></highlight></codeline>
<codeline lineno="3976"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="3977"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.BotLeft[ib];</highlight></codeline>
<codeline lineno="3978"><highlight class="normal"></highlight></codeline>
<codeline lineno="3979"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>bb);</highlight></codeline>
<codeline lineno="3980"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>bb);</highlight></codeline>
<codeline lineno="3981"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>bb);</highlight></codeline>
<codeline lineno="3982"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>bb);</highlight></codeline>
<codeline lineno="3983"><highlight class="normal"></highlight></codeline>
<codeline lineno="3984"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="3985"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3986"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3987"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="3988"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3989"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="3990"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3992"><highlight class="normal"></highlight></codeline>
<codeline lineno="3993"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="3994"><highlight class="normal"></highlight></codeline>
<codeline lineno="3995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="3996"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3997"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3998"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3999"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4000"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4001"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4002"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="4005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="4006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="4007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="4008"><highlight class="normal"></highlight></codeline>
<codeline lineno="4009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4010"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4011"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4012"><highlight class="normal"></highlight></codeline>
<codeline lineno="4013"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4014"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4015"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4016"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.TopLeft[XBlock.BotLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="4017"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="4018"><highlight class="normal"></highlight></codeline>
<codeline lineno="4019"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="4020"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="4021"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="4022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="4023"><highlight class="normal"></highlight></codeline>
<codeline lineno="4024"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>BilinearInterpolation(a[itr],<sp/>a[it],<sp/>a[ir],<sp/>a[ii],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>jr,<sp/>T(0.75));</highlight></codeline>
<codeline lineno="4025"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4026"><highlight class="normal"></highlight></codeline>
<codeline lineno="4027"><highlight class="normal"></highlight></codeline>
<codeline lineno="4028"><highlight class="normal"></highlight></codeline>
<codeline lineno="4029"><highlight class="normal"></highlight></codeline>
<codeline lineno="4030"><highlight class="normal"></highlight></codeline>
<codeline lineno="4031"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dadx[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>aleft,<sp/>a[i],<sp/>aright)<sp/>/<sp/>delta;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4032"><highlight class="normal"><sp/><sp/><sp/><sp/>dady[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>abot,<sp/>a[i],<sp/>atop)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="4033"><highlight class="normal"></highlight></codeline>
<codeline lineno="4034"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4035"><highlight class="normal"></highlight></codeline>
<codeline lineno="4047"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientHaloBotGPUnew(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="4048"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4049"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4050"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>XParam.blkmemwidth<sp/>*<sp/>XParam.blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4051"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>-1;</highlight></codeline>
<codeline lineno="4052"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="4053"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>threadIdx.y<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.y;</highlight></codeline>
<codeline lineno="4054"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ibl<sp/>&lt;<sp/>XParam.nblk)</highlight></codeline>
<codeline lineno="4055"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="4057"><highlight class="normal"></highlight></codeline>
<codeline lineno="4058"><highlight class="normal"></highlight></codeline>
<codeline lineno="4059"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="4060"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>yplus,<sp/>read;</highlight></codeline>
<codeline lineno="4061"><highlight class="normal"></highlight></codeline>
<codeline lineno="4062"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>delta,<sp/>atop,<sp/>abot;</highlight></codeline>
<codeline lineno="4063"><highlight class="normal"></highlight></codeline>
<codeline lineno="4064"><highlight class="normal"></highlight></codeline>
<codeline lineno="4065"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="4066"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>yplus<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy<sp/>+<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4067"><highlight class="normal"></highlight></codeline>
<codeline lineno="4068"><highlight class="normal"></highlight></codeline>
<codeline lineno="4069"><highlight class="normal"></highlight></codeline>
<codeline lineno="4070"><highlight class="normal"></highlight></codeline>
<codeline lineno="4071"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>a[yplus];</highlight></codeline>
<codeline lineno="4072"><highlight class="normal"></highlight></codeline>
<codeline lineno="4073"><highlight class="normal"></highlight></codeline>
<codeline lineno="4074"><highlight class="normal"></highlight></codeline>
<codeline lineno="4075"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delta<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib]);</highlight></codeline>
<codeline lineno="4076"><highlight class="normal"></highlight></codeline>
<codeline lineno="4077"><highlight class="normal"></highlight></codeline>
<codeline lineno="4078"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4079"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4080"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4081"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4082"><highlight class="normal"></highlight></codeline>
<codeline lineno="4083"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4084"><highlight class="normal"></highlight></codeline>
<codeline lineno="4085"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4086"><highlight class="normal"></highlight></codeline>
<codeline lineno="4087"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4088"><highlight class="normal"></highlight></codeline>
<codeline lineno="4089"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4090"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4091"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4092"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4093"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4094"><highlight class="normal"></highlight></codeline>
<codeline lineno="4095"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="4096"><highlight class="normal"></highlight></codeline>
<codeline lineno="4097"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4098"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4099"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4102"><highlight class="normal"></highlight></codeline>
<codeline lineno="4103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4105"><highlight class="normal"></highlight></codeline>
<codeline lineno="4106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="4108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="4109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="4110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="4111"><highlight class="normal"></highlight></codeline>
<codeline lineno="4112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4113"><highlight class="normal"></highlight></codeline>
<codeline lineno="4114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.BotLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4119"><highlight class="normal"></highlight></codeline>
<codeline lineno="4120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="4121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4122"><highlight class="normal"></highlight></codeline>
<codeline lineno="4123"><highlight class="normal"></highlight></codeline>
<codeline lineno="4124"><highlight class="normal"></highlight></codeline>
<codeline lineno="4125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4128"><highlight class="normal"></highlight></codeline>
<codeline lineno="4129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4131"><highlight class="normal"></highlight></codeline>
<codeline lineno="4132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.BotLeft[ib];</highlight></codeline>
<codeline lineno="4134"><highlight class="normal"></highlight></codeline>
<codeline lineno="4135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>bb);</highlight></codeline>
<codeline lineno="4136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>bb);</highlight></codeline>
<codeline lineno="4137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>bb);</highlight></codeline>
<codeline lineno="4138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>bb);</highlight></codeline>
<codeline lineno="4139"><highlight class="normal"></highlight></codeline>
<codeline lineno="4140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.BotRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4148"><highlight class="normal"></highlight></codeline>
<codeline lineno="4149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>0,<sp/>ib);</highlight></codeline>
<codeline lineno="4150"><highlight class="normal"></highlight></codeline>
<codeline lineno="4151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="4161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="4162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>3),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="4163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>4),<sp/>XBlock.BotRight[ib]);</highlight></codeline>
<codeline lineno="4164"><highlight class="normal"></highlight></codeline>
<codeline lineno="4165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4168"><highlight class="normal"></highlight></codeline>
<codeline lineno="4169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.BotLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.TopLeft[XBlock.BotLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="4173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="4174"><highlight class="normal"></highlight></codeline>
<codeline lineno="4175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="4176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="4177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>1),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="4178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>(XParam.blkwidth<sp/>-<sp/>2),<sp/>XBlock.BotLeft[ib]);</highlight></codeline>
<codeline lineno="4179"><highlight class="normal"></highlight></codeline>
<codeline lineno="4180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>BilinearInterpolation(a[itr],<sp/>a[it],<sp/>a[ir],<sp/>a[ii],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>jr,<sp/>T(0.75));</highlight></codeline>
<codeline lineno="4181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4182"><highlight class="normal"></highlight></codeline>
<codeline lineno="4183"><highlight class="normal"></highlight></codeline>
<codeline lineno="4184"><highlight class="normal"></highlight></codeline>
<codeline lineno="4185"><highlight class="normal"></highlight></codeline>
<codeline lineno="4186"><highlight class="normal"></highlight></codeline>
<codeline lineno="4187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dadx[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>aleft,<sp/>a[i],<sp/>aright)<sp/>/<sp/>delta;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dady[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>abot,<sp/>a[i],<sp/>atop)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="4189"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4190"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4191"><highlight class="normal"></highlight></codeline>
<codeline lineno="4203"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientHaloTopGPU(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="4204"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4205"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4206"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>XParam.blkmemwidth<sp/>*<sp/>XParam.blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4207"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>XParam.blkwidth;</highlight></codeline>
<codeline lineno="4208"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="4209"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline lineno="4210"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="4211"><highlight class="normal"></highlight></codeline>
<codeline lineno="4212"><highlight class="normal"></highlight></codeline>
<codeline lineno="4213"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="4214"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>yminus,<sp/>read;</highlight></codeline>
<codeline lineno="4215"><highlight class="normal"></highlight></codeline>
<codeline lineno="4216"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>delta,<sp/>atop,<sp/>abot;</highlight></codeline>
<codeline lineno="4217"><highlight class="normal"></highlight></codeline>
<codeline lineno="4218"><highlight class="normal"></highlight></codeline>
<codeline lineno="4219"><highlight class="normal"><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="4220"><highlight class="normal"><sp/><sp/><sp/><sp/>yminus<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4221"><highlight class="normal"></highlight></codeline>
<codeline lineno="4222"><highlight class="normal"></highlight></codeline>
<codeline lineno="4223"><highlight class="normal"></highlight></codeline>
<codeline lineno="4224"><highlight class="normal"></highlight></codeline>
<codeline lineno="4225"><highlight class="normal"><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>a[yminus];</highlight></codeline>
<codeline lineno="4226"><highlight class="normal"></highlight></codeline>
<codeline lineno="4227"><highlight class="normal"></highlight></codeline>
<codeline lineno="4228"><highlight class="normal"></highlight></codeline>
<codeline lineno="4229"><highlight class="normal"><sp/><sp/><sp/><sp/>delta<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib]);</highlight></codeline>
<codeline lineno="4230"><highlight class="normal"></highlight></codeline>
<codeline lineno="4231"><highlight class="normal"></highlight></codeline>
<codeline lineno="4232"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4233"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4236"><highlight class="normal"></highlight></codeline>
<codeline lineno="4237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4238"><highlight class="normal"></highlight></codeline>
<codeline lineno="4239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4240"><highlight class="normal"></highlight></codeline>
<codeline lineno="4241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4242"><highlight class="normal"></highlight></codeline>
<codeline lineno="4243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4248"><highlight class="normal"></highlight></codeline>
<codeline lineno="4249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4250"><highlight class="normal"></highlight></codeline>
<codeline lineno="4251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4256"><highlight class="normal"></highlight></codeline>
<codeline lineno="4257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4259"><highlight class="normal"></highlight></codeline>
<codeline lineno="4260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4265"><highlight class="normal"></highlight></codeline>
<codeline lineno="4266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4267"><highlight class="normal"></highlight></codeline>
<codeline lineno="4268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4270"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4271"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.TopLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4272"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4273"><highlight class="normal"></highlight></codeline>
<codeline lineno="4274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>1,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="4275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4276"><highlight class="normal"></highlight></codeline>
<codeline lineno="4277"><highlight class="normal"></highlight></codeline>
<codeline lineno="4278"><highlight class="normal"></highlight></codeline>
<codeline lineno="4279"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4280"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4281"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4282"><highlight class="normal"></highlight></codeline>
<codeline lineno="4283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4285"><highlight class="normal"></highlight></codeline>
<codeline lineno="4286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.TopLeft[ib];;</highlight></codeline>
<codeline lineno="4288"><highlight class="normal"></highlight></codeline>
<codeline lineno="4289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>3,<sp/>bb);</highlight></codeline>
<codeline lineno="4290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>2,<sp/>bb);</highlight></codeline>
<codeline lineno="4291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>3,<sp/>bb);</highlight></codeline>
<codeline lineno="4292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>2,<sp/>bb);</highlight></codeline>
<codeline lineno="4293"><highlight class="normal"></highlight></codeline>
<codeline lineno="4294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4302"><highlight class="normal"></highlight></codeline>
<codeline lineno="4303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4304"><highlight class="normal"></highlight></codeline>
<codeline lineno="4305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4318"><highlight class="normal"></highlight></codeline>
<codeline lineno="4319"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4322"><highlight class="normal"></highlight></codeline>
<codeline lineno="4323"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4324"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4325"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.BotLeft[XBlock.TopLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="4327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="4328"><highlight class="normal"></highlight></codeline>
<codeline lineno="4329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="4330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="4331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="4332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>1,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="4333"><highlight class="normal"></highlight></codeline>
<codeline lineno="4334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>BilinearInterpolation(a[it],<sp/>a[itr],<sp/>a[ii],<sp/>a[ir],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>jr,<sp/>T(0.25));</highlight></codeline>
<codeline lineno="4335"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4336"><highlight class="normal"></highlight></codeline>
<codeline lineno="4337"><highlight class="normal"></highlight></codeline>
<codeline lineno="4338"><highlight class="normal"></highlight></codeline>
<codeline lineno="4339"><highlight class="normal"></highlight></codeline>
<codeline lineno="4340"><highlight class="normal"></highlight></codeline>
<codeline lineno="4341"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dadx[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>aleft,<sp/>a[i],<sp/>aright)<sp/>/<sp/>delta;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4342"><highlight class="normal"><sp/><sp/><sp/><sp/>dady[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>abot,<sp/>a[i],<sp/>atop)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="4343"><highlight class="normal"></highlight></codeline>
<codeline lineno="4344"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4345"><highlight class="normal"></highlight></codeline>
<codeline lineno="4357"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>T&gt;<sp/>__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>gradientHaloTopGPUnew(<ref refid="class_param" kindref="compound">Param</ref><sp/>XParam,<sp/><ref refid="struct_block_p" kindref="compound">BlockP&lt;T&gt;</ref>XBlock,<sp/>T*<sp/>a,<sp/>T*<sp/>dadx,<sp/>T*<sp/>dady)</highlight></codeline>
<codeline lineno="4358"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4359"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>blkmemwidth<sp/>=<sp/>XParam.blkwidth<sp/>+<sp/>XParam.halowidth<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4360"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//unsigned<sp/>int<sp/>blksize<sp/>=<sp/>XParam.blkmemwidth<sp/>*<sp/>XParam.blkmemwidth;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4361"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iy<sp/>=<sp/>XParam.blkwidth;</highlight></codeline>
<codeline lineno="4362"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ix<sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline lineno="4363"><highlight class="normal"></highlight></codeline>
<codeline lineno="4364"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="4365"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ibl<sp/>=<sp/>threadIdx.y<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.y;</highlight></codeline>
<codeline lineno="4366"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ibl<sp/>&lt;<sp/>XParam.nblk)</highlight></codeline>
<codeline lineno="4367"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4368"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ib<sp/>=<sp/>XBlock.active[ibl];</highlight></codeline>
<codeline lineno="4369"><highlight class="normal"></highlight></codeline>
<codeline lineno="4370"><highlight class="normal"></highlight></codeline>
<codeline lineno="4371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>jj,<sp/>ii,<sp/>ir,<sp/>it,<sp/>itr;</highlight></codeline>
<codeline lineno="4372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>yminus,<sp/>read;</highlight></codeline>
<codeline lineno="4373"><highlight class="normal"></highlight></codeline>
<codeline lineno="4374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>delta,<sp/>atop,<sp/>abot;</highlight></codeline>
<codeline lineno="4375"><highlight class="normal"></highlight></codeline>
<codeline lineno="4376"><highlight class="normal"></highlight></codeline>
<codeline lineno="4377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>iy,<sp/>ib);</highlight></codeline>
<codeline lineno="4378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>yminus<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4379"><highlight class="normal"></highlight></codeline>
<codeline lineno="4380"><highlight class="normal"></highlight></codeline>
<codeline lineno="4381"><highlight class="normal"></highlight></codeline>
<codeline lineno="4382"><highlight class="normal"></highlight></codeline>
<codeline lineno="4383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abot<sp/>=<sp/>a[yminus];</highlight></codeline>
<codeline lineno="4384"><highlight class="normal"></highlight></codeline>
<codeline lineno="4385"><highlight class="normal"></highlight></codeline>
<codeline lineno="4386"><highlight class="normal"></highlight></codeline>
<codeline lineno="4387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delta<sp/>=<sp/>calcres(T(XParam.delta),<sp/>XBlock.level[ib]);</highlight></codeline>
<codeline lineno="4388"><highlight class="normal"></highlight></codeline>
<codeline lineno="4389"><highlight class="normal"></highlight></codeline>
<codeline lineno="4390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopLeft[ib]<sp/>==<sp/>ib)</highlight><highlight class="comment">//The<sp/>lower<sp/>half<sp/>is<sp/>a<sp/>boundary<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4394"><highlight class="normal"></highlight></codeline>
<codeline lineno="4395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight><highlight class="comment">//<sp/>or<sp/>memloc(XParam,<sp/>-1,<sp/>j,<sp/>ib)<sp/>but<sp/>they<sp/>should<sp/>be<sp/>the<sp/>same</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4396"><highlight class="normal"></highlight></codeline>
<codeline lineno="4397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4398"><highlight class="normal"></highlight></codeline>
<codeline lineno="4399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4400"><highlight class="normal"></highlight></codeline>
<codeline lineno="4401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>on<sp/>the<sp/>top<sp/>half<sp/>too</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4404"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4405"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4406"><highlight class="normal"></highlight></codeline>
<codeline lineno="4407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4408"><highlight class="normal"></highlight></codeline>
<codeline lineno="4409"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4410"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4411"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>is<sp/>only<sp/>on<sp/>the<sp/>bottom<sp/>half<sp/>and<sp/>implicitely<sp/>level<sp/>of<sp/>lefttopib<sp/>is<sp/>levelib+1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4414"><highlight class="normal"></highlight></codeline>
<codeline lineno="4415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4416"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4417"><highlight class="normal"></highlight></codeline>
<codeline lineno="4418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4422"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4423"><highlight class="normal"></highlight></codeline>
<codeline lineno="4424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4425"><highlight class="normal"></highlight></codeline>
<codeline lineno="4426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4428"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4429"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[ib]<sp/>==<sp/>XBlock.level[XBlock.TopLeft[ib]])<sp/></highlight><highlight class="comment">//<sp/>LeftTop<sp/>block<sp/>does<sp/>not<sp/>exist</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4430"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4431"><highlight class="normal"></highlight></codeline>
<codeline lineno="4432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>1,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="4433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4434"><highlight class="normal"></highlight></codeline>
<codeline lineno="4435"><highlight class="normal"></highlight></codeline>
<codeline lineno="4436"><highlight class="normal"></highlight></codeline>
<codeline lineno="4437"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4438"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&gt;<sp/>XBlock.level[ib])</highlight></codeline>
<codeline lineno="4439"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4440"><highlight class="normal"></highlight></codeline>
<codeline lineno="4441"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&lt;<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4442"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4443"><highlight class="normal"></highlight></codeline>
<codeline lineno="4444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>ix<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4445"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bb<sp/>=<sp/>XBlock.TopLeft[ib];;</highlight></codeline>
<codeline lineno="4446"><highlight class="normal"></highlight></codeline>
<codeline lineno="4447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>3,<sp/>bb);</highlight></codeline>
<codeline lineno="4448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>2,<sp/>bb);</highlight></codeline>
<codeline lineno="4449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>3,<sp/>bb);</highlight></codeline>
<codeline lineno="4450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>2,<sp/>bb);</highlight></codeline>
<codeline lineno="4451"><highlight class="normal"></highlight></codeline>
<codeline lineno="4452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//now<sp/>find<sp/>out<sp/>aboy<sp/>lefttop<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.TopRight[ib]<sp/>==<sp/>ib)</highlight></codeline>
<codeline lineno="4456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4460"><highlight class="normal"></highlight></codeline>
<codeline lineno="4461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>read<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>ix,<sp/>XParam.blkwidth<sp/>-<sp/>1,<sp/>ib);</highlight></codeline>
<codeline lineno="4462"><highlight class="normal"></highlight></codeline>
<codeline lineno="4463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>a[read];</highlight></codeline>
<codeline lineno="4464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ix<sp/>&gt;=<sp/>(XParam.blkwidth<sp/>/<sp/>2))</highlight></codeline>
<codeline lineno="4469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>(ix<sp/>-<sp/>XParam.blkwidth<sp/>/<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="4472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>3,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>+<sp/>1,<sp/>2,<sp/>XBlock.TopRight[ib]);</highlight></codeline>
<codeline lineno="4476"><highlight class="normal"></highlight></codeline>
<codeline lineno="4477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>T(0.25)<sp/>*<sp/>(a[ii]<sp/>+<sp/>a[ir]<sp/>+<sp/>a[it]<sp/>+<sp/>a[itr]);</highlight></codeline>
<codeline lineno="4478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4480"><highlight class="normal"></highlight></codeline>
<codeline lineno="4481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(XBlock.level[XBlock.TopLeft[ib]]<sp/>&lt;<sp/>XBlock.level[ib])<sp/></highlight><highlight class="comment">//<sp/>Neighbour<sp/>is<sp/>coarser;<sp/>using<sp/>barycentric<sp/>interpolation<sp/>(weights<sp/>are<sp/>precalculated)<sp/>for<sp/>the<sp/>Halo<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jj<sp/>=<sp/>XBlock.BotLeft[XBlock.TopLeft[ib]]<sp/>==<sp/>ib<sp/>?<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>:<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>+<sp/>XParam.blkwidth<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="4485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>jr<sp/>=<sp/>ceil(ix<sp/>*<sp/>(T)0.5)<sp/>*<sp/>2<sp/>&gt;<sp/>ix<sp/>?<sp/>T(0.25)<sp/>:<sp/>T(0.75);</highlight></codeline>
<codeline lineno="4486"><highlight class="normal"></highlight></codeline>
<codeline lineno="4487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ii<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="4488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ir<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj,<sp/>1,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="4489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>0,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="4490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itr<sp/>=<sp/>memloc(XParam.halowidth,<sp/>blkmemwidth,<sp/>jj<sp/>-<sp/>1,<sp/>1,<sp/>XBlock.TopLeft[ib]);</highlight></codeline>
<codeline lineno="4491"><highlight class="normal"></highlight></codeline>
<codeline lineno="4492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atop<sp/>=<sp/>BilinearInterpolation(a[it],<sp/>a[itr],<sp/>a[ii],<sp/>a[ir],<sp/>T(0.0),<sp/>T(1.0),<sp/>T(0.0),<sp/>T(1.0),<sp/>jr,<sp/>T(0.25));</highlight></codeline>
<codeline lineno="4493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4494"><highlight class="normal"></highlight></codeline>
<codeline lineno="4495"><highlight class="normal"></highlight></codeline>
<codeline lineno="4496"><highlight class="normal"></highlight></codeline>
<codeline lineno="4497"><highlight class="normal"></highlight></codeline>
<codeline lineno="4498"><highlight class="normal"></highlight></codeline>
<codeline lineno="4499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//dadx[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>aleft,<sp/>a[i],<sp/>aright)<sp/>/<sp/>delta;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dady[i]<sp/>=<sp/>minmod2(T(XParam.theta),<sp/>abot,<sp/>a[i],<sp/>atop)<sp/>/<sp/>delta;</highlight></codeline>
<codeline lineno="4501"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4502"><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="src/Gradients.cu"/>
  </compounddef>
</doxygen>
