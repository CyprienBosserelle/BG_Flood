{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mkdoc-material set-up!","text":""},{"location":"#mkdoc-material-set-up","title":"Mkdoc-material set-up!","text":""},{"location":"#welcome-to-mkdocs-by-alice","title":"Welcome to MkDocs by Alice","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"#test-of-mkdoc-functionnalities","title":"Test of mkdoc functionnalities","text":""},{"location":"#admonitions-link","title":"Admonitions (link):","text":"<p>Phasellus posuere in sem ut cursus</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"#latex","title":"Latex:","text":"<p>Latex is working : \\(d_n\\) or  $$ d_n={$rac{10}{5}} $$</p>"},{"location":"#pictures","title":"Pictures:","text":"Image caption <p>based on @10.1016/j.envsoft.2016.11.012</p>"},{"location":"#references","title":"References","text":"<p>$full_bibliography</p>"},{"location":"#adding-nice-videos","title":"Adding nice videos","text":"<p>see Home!</p>"},{"location":"Home/","title":"Home","text":""},{"location":"Home/#welcome-to-the-bg_flood-documentation","title":"Welcome to the BG_Flood documentation !","text":"<p>BG-Flood is a Shallow Water Equation (SWE) model based on the St Venant formulation of Basilisk but applied to a Block Uniform Quadtree memory structure on the GPU (based on Vacondio et al.).</p> <p>The model is designed to simulate flood/inundation caused by tsunami, river, rain, tide or storm surge (from wind stress or atmospherique pressure differential) or any combination of these. The model does not (yet) include the effect of wind waves. The model is not restricted to simulating inundation hazard and can also be used for depth averaged circulation simulation. </p> <p>Info</p> <p>This wiki is to help users getting started on using the model.  This is work in progress... If you have any issue/question post it on the issue board. While the model is fairly user friendly, it was designed for users with a basic understanding of hydrodynamics and some experience in modelling. The wiki (and the model) expect that users have some experience in basic file manipulations and are comfortable with handling NetCDF files for input and output.</p> <p>This code is an open-source shallow water solver. Designed to be fast, it run on GPUs and generate its own adaptative mesh. It is mainly used in a context of flooding:</p> <ul> <li>Fresh water flooding (fluvial and pluvial)</li> <li>Tides and storm-surges</li> <li>Dam break</li> <li>Tsunami propagation and inundation</li> </ul> <p></p> <p></p>"},{"location":"Home/#model-development-stage","title":"Model development stage","text":"<p>BG-Flood has now reach the first release stage but some further development are already ongoing or planned.       </p> <p>The master branch is at stage 4 of development with 5 stage planned as below:</p> <ul> <li> Block Uniform formulation at constant level with masked blocks (with a full swing of user friendly capabilities)</li> <li> Static Block uniform Quad-tree formulation (i.e. adapted mesh at the first step only), grid self-generated</li> <li> Set of core solvers:<ul> <li> Reimann</li> <li> Kurganov</li> </ul> </li> <li> Multi-forcings<ul> <li> River input</li> <li> Tidal forcing (complex polygon and forcing maps to allow nesting)</li> <li> Rain-on-grid</li> <li> Atmospheric pressure and wind forcing</li> <li> Bottom friction</li> <li> Ground infiltration (basic ILCL model)</li> <li> Ground deformation (along the simulation but not flow induced)</li> </ul> </li> </ul> <p>Future developments:</p> <ul> <li> Multi-layer solver (on-going)</li> <li> Flood structures modelling (on-going)</li> <li> Wave forcing / storm surge</li> <li> fully adaptive Block uniform Quad-tree formulation  (i.e. basilisk style wavelet refine)</li> </ul> <p></p> <p>Testing CI test (development branch): </p>"},{"location":"Install/","title":"Installation","text":""},{"location":"Install/#installation-of-bg_flood","title":"Installation of BG_Flood","text":"<p>Warning</p> <p>BG_Flood has been written in CUDA language, C++ based language created by NVIDIA to interact directly with their GPUs.  Even if the code can run on CPU (for testing purposes for example), it will be performant on NVIDIA GPUs. The best performances  are observed on large NVIDIA GPUs on supercomputers.</p> <p>The code has only two dependencies:</p> <ul> <li>CUDA</li> <li>netcdf</li> </ul>"},{"location":"Install/#windows-10-11","title":"Windows 10 - 11","text":"<p>On windows OS you should be able to use the binaries/executable we make available in each release. Simply download and unzip the file in a suitable directory and either add the folder to your PATH or move the dlls and .exe around where you want to run (you might need to unblock it before first use). </p>"},{"location":"Install/#build-from-source","title":"Build from source","text":"<p>To build BG_Flood from source on Windows you will need to have pre-install:</p> <ul> <li>Visual Studio Community with C++ component installed</li> <li>Compatible (Cuda toolkit)[https://developer.nvidia.com/cuda-toolkit]</li> <li>Downloaded/cloned/forked source of the repo</li> <li>Netcdf developer install (i.e. netcdf.h and netcdf.lib)</li> </ul> <p>Setup on Visual Studio</p> <ul> <li>start a new empty project</li> <li>add CUDA build dependencies to the project</li> <li>add NetCDF folder(s) to the include and library directories in the project properties</li> <li>add \"netcdf.lib\" to the input (Properties -&gt; Linker -&gt; Input)</li> <li>switch the \"Generate Relocatable device code\" to Yes (Properties -&gt; CUDA C/C++ -&gt; Common)</li> <li>disable deprecation add _CRT_SECURE_NO_WARNINGS to preprocessor definition (Properties -&gt; C/C++ -&gt; Preprocessor)</li> </ul>"},{"location":"Install/#linux","title":"Linux","text":"<p>Make sure you have latest CUDA Toolkit, g++ and NetCDF libraries installed.</p> <pre><code>sudo apt-get install nvidia-cuda-dev\nsudo apt-get install g++\nsudo apt-get install libnetcdf-dev\n</code></pre> <p>Note</p> <p>Make sure the GPU driver being used is the Nvidia driver!</p> <p>Do a quick comand line test to see if nvcc (CUDA compiler) is available from here.</p> <p>If not, you may need to modify the cuda path in the makefile (line 155) : </p><pre><code>NVCC          := nvcc -ccbin $(HOST_COMPILER)\n</code></pre> <p>Warning</p> <p>The code can compile for multiple GPU architecture but later compiler do not support old GPU (2.0 is no longer supported). If needed, remove unsupported architecture in line 213 of the makefile.</p> <p>Then just type  </p><pre><code>make\n</code></pre> <p>Success</p> <p>Many warning will show up but that is OK...</p>"},{"location":"Install/#supercomputers","title":"Supercomputers","text":"<p>The code can be run on local machines with NVIDIA GPU but it will get better performance by running on large GPU.Below are example of installation and running procedures on HPC the develloper used.</p>"},{"location":"Install/#esnz-supercomputer-cascade","title":"ESNZ supercomputer: Cascade","text":"<p>This machine is set-up using stack and all tools need to be install through it before compiling/running the code. The PBS job manager is used (see <code>man pbs</code> for more information).</p>"},{"location":"Install/#compiling-the-code","title":"Compiling the code","text":"<pre><code>. $(ls /opt/niwa/profile/spack_* | tail -1)\nspack load netcdf-c@4.9.2%gcc@11.5.0 cuda@12.8.0\nnclib=`nc-config --libdir`\nexport LD_LIBRARY_PATH=\"${nclib}:$LD_LIBRARY_PATH\"\n</code></pre> Go in the folder where BG_Flood sources have been cloned and compile: <pre><code>cd BG_Flood\n\nmake -j 10\n</code></pre> <p>Note</p> <p>The executable is copied to a bin two folders up: <code>cp BG_Flood ../../bin/x86_64/linux/release</code>. Check that you have writing right there! </p> <p>Note</p> <p>Spack load doesn't set LD_LIBRARY_PATH so running executable won't find libnetcdf.  Also it doesn't set LDFLAGS=-Wl,-rpath (and Makefile doesn't honour LDFLAGS anyway), so libnetcdf path isn't linked in.  So hack this in for now.</p>"},{"location":"Install/#running-the-code","title":"Running the code","text":"<pre><code>#!/bin/bash\n\n#PBS -N *my_pbs_job_name*\n#PBS -l select=1:ncpus=1:ngpus=1:mem=32gb:nodepool=a100p\n#PBS -l walltime=01:00:00\n#PBS -q a100q\n#PBS -W umask=027\n\n# Change to running directory if required\ncd *my_case_dir*\n\n# Loading needed packages\n. $(ls /opt/niwa/profile/spack_* | tail -1)\nspack load netcdf-c@4.9.2%gcc@11.5.0 cuda@12.8.0\nnclib=`nc-config --libdir`\nexport LD_LIBRARY_PATH=\"${nclib}:$LD_LIBRARY_PATH\"\n\n# Launch of the solver\n./BG_Flood BG_param.txt\n</code></pre>"},{"location":"Install/#basic-pbs-commands","title":"Basic PBS commands","text":"Based on NASA, hecc website <p>Link to initial documentation</p> <p>The four most commonly used PBS commands, <code>qsub</code>, <code>qstat</code>, <code>qdel</code>, and <code>qhold</code>, are briefly described below. See man pbs for a list of all PBS commands.</p>"},{"location":"Install/#qsub","title":"qsub","text":"<p>To submit a batch job to the specified queue using a script: </p><pre><code>%qsub -q queue_name job_script \n</code></pre> Only one queue for GPUs for the moment. When queue_name is omitted, the job is routed to the default queue, which is the normal queue. <p>The resource_list typically specifies the number of nodes, CPUs, amount of memory and wall time needed for this job. </p> <p>See <code>man pbs_resources</code> for more information on what resources can be specified.</p> <p>Note</p> <p>If <code>-l resource_list</code> is omitted, the default resources for the specified queue is used. When <code>queue_name</code> is omitted, the job is routed to the default queue, which is the normal queue.</p>"},{"location":"Install/#qstat","title":"qstat","text":"<p>To display queue information: </p><pre><code>%qstat -Q queue_name\n%qstat -q queue_name\n%qstat -fQ queue_name \n</code></pre> Each option uses a different format to display all of the queues available, and their constraints and status. The <code>queue_name</code> is optional. <p>To display job status:</p> Flag Description a Display all jobs in any status (running, queued, held) r Display all running or suspended jobs n Display the execution hosts of the running jobs i Display all queued, held or waiting jobs u username Display jobs that belong to the specified user s Display any comment added by the administrator or scheduler. This option is typically used to find clues of why a job has not started running. f job_id Display detailed information about a specific job xf job_id / xu user_id Display status information for finished jobs (within the past 7 days). <p>Tip</p> <p>Some of these flags can be combined when you are checking the job status.</p>"},{"location":"Install/#qdel","title":"qdel","text":"<p>To delete (cancel) a job: </p><pre><code>%qdel job_id \n</code></pre>"},{"location":"Install/#qhold","title":"qhold","text":"<p>To hold a job: </p><pre><code>%qhold job_id \n</code></pre> Only the job owner or a system administrator with \"su\" or \"root\" privilege can place a hold on a job. The hold can be released using the <code>qrls</code> command. <p>For more detailed information on each command, see their corresponding man pages.</p>"},{"location":"Install/#nesi-maui-mahuika","title":"NESI (Maui-Mahuika)","text":"<p>Depreciated</p> <p>NESI supercomputer has now been closed and replaced by REANZ new generation of machines.</p> <p>The code is actually running on New Zealand eScience Infrastructure (NeSI). This national center uses a module systems associated to the slurm job manager.</p>"},{"location":"Install/#compiling-the-code_1","title":"Compiling the code","text":"<p>The Code needs to be compile on the machine, using the sources from the github repository. Due to the code dependency to CUDA and netCDF, two modules need to be loaded:</p> <ul> <li> <p>On Maui: </p><pre><code>module load CUDA\\11.4.1\nmodule load netCDF-C++4/4.3.0-GCC-7.1.0\n</code></pre> </li> <li> <p>On Mahuika: </p><pre><code>module load CUDA/11.4.1\nmodule load netCDF-C++4/4.3.1-gimpi-2020a\n</code></pre> </li> </ul>"},{"location":"Install/#running-the-code_1","title":"Running the code","text":"<ul> <li> <p>Example of a slurm file on Maui: </p><pre><code>#!/bin/bash\n#SBATCH --job-name=MY-TEST-NAME\n#SBATCH --time=8:00:00\n#SBATCH --account=MY-NESI-ACCOUNT\n#SBATCH --partition=nesi_gpu\n#SBATCH --gres=gpu\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=2\n#SBATCH --mem=5GB\n\n#Running directory (to be completed)\nBGFLOOD=/nesi/project/XXXXXXXXXXXXXXX\n\ncd ${BGFLOOD}\n\nmodule load CUDA/11.4.1\nmodule load netCDF-C++4/4.3.0-GCC-7.1.0\n\n# Launching the executable\nsrun ./BG_Flood_Maui\n\necho \"output_file = Output/${testname}/BGoutput-${reftime}.nc\"\n\necho \"end of setup_run_BG.sh\"\n</code></pre> </li> <li> <p>Example of a slurm file on Mahuika: </p><pre><code>#!/bin/bash\n#SBATCH --job-name=MY-TEST-NAME\n#SBATCH --time=05:00:00\n#SBATCH --account=MY-NESI-ACCOUNT\n#SBATCH --gpus-per-node=1\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=1\n#SBATCH --mem=1GB\n\n#Running directory (to be completed)\nBGFLOOD=/nesi/project/XXXXXXXXXXXXXXX\n\ncd ${BGFLOOD}\n\n#module load netCDF-C++4/4.3.0-gimkl-2017a\nmodule load netCDF-C++4/4.3.1-gimpi-2020a\nmodule load CUDA/11.4.1\n\n# Launching the executable\nsrun ./BG_Flood_Mahuika\n\necho \"output_file = Output/${testname}/BGoutput-${reftime}.nc\"\n\necho \"end of setup_run_BG.sh\"\n</code></pre> </li> </ul>"},{"location":"Manual/","title":"Manual","text":""},{"location":"Manual/#manual","title":"Manual","text":"<p>BG_Flood is a hydrodynamics model for simulating 2D depth-averaged flow. The following manual describes how to use the model but does not go into details about the model equations.</p> <p>Warning</p> <p>This manual is under revision and not up-to-date with the last version of the code. Please, use the Parameters and Forcings list as a reference</p>"},{"location":"Manual/#model-controls","title":"Model controls","text":"<p>BG_Flood model reads an instruction file (or param file) that tells the model what to do and what forcing files to read. when instructions are not explicitely given the model will use the default value. How to use the param file is important for making BG_Flood do what you want it to do.</p> <p>By default this instruction file is called <code>BG_param.txt</code>and is the file BG_Flood will be looking for if it is launched without aregument. You can specify any filename you like if you launch BG_Flood this way:</p> <pre><code>./BG_Flood my_param_file.txt\n</code></pre>"},{"location":"Manual/#bg_paramtxt","title":"BG_param.txt","text":"<p>All the model inputs are controlled by the <code>BG_param.txt</code> file. It is a simple text file that contains the parameters of the model that the user wishes to change. While it is easy to build such file manually but also it is easy to use script and/or programming language to generate and modify text file to automatically to build and run many simulations.</p>"},{"location":"Manual/#how-to-use-the-bg_paramtxt-file","title":"How to use the BG_param.txt file","text":"<p>Model parameters can be modified in the file by specifying the parameter name, the equal sign, the desired value(s) for the parameter and optionally a semi-column : </p><pre><code>#My Dummy BG_param files\n#Any lines starting with the Hash tag will be ignored\n#You can also leave blank lines\n\n# Parameter order does not really matter but if you specify a parameter twice the first value will be overwritten\n\n# You can only put one parameter per line\nbathy = mybathyfile.nc\n\n#Any number of leading space or space between the parameter name and the equal sign will be accepted. Tabs are not acceptable\n    theta       =      1.0\n#Obviously you have to put the right name down (spelling and not case sensitive) otherwise the line will be ignored without warning\ntteettaa = 1.22\n\n#If you want to add a comment at the end of a line with a parameter you can do it after putting a semi column e.g.:\nCFL = 9; Was 0.5 but I don't know what I'm doing\n\n#The model has only one required parameter and that is the (level 0) bathymetry grid name\n</code></pre>"},{"location":"Manual/#general-comment-about-input-files","title":"General comment about input files","text":"<p>Some parameters expect a filename (e.g. <code>bathy</code>). While the model will accept any extension there are a couple of requirement. For spatially varying inputs, the extension controls how the file is read. You can use ESRI ascii grids <code>.asc</code>, mid-depth files <code>.md</code> or NetCDF <code>.nc</code>. NetCDF files are recommended and expected to have the <code>.nc</code> extension. Since NetCDF files can have several variables you can enforce (recommended) the variable being read by appending <code>?var</code> to the file name (e.g. <code>bathy = mybathyfile.nc?z</code>).</p> <p>For spatially and temporally varying input (e.g. wind or atmospheric pressure) a/multiple NetCDF file with a 3D variable is expected (see here).</p> <p>Where the file input is a timeserie (e.g. boundary forcing), then the file extension is ignored but a text file is expected.</p>"},{"location":"Manual/#list-of-parameters","title":"List of Parameters","text":"<p>Remember that the only required parameter to run the model is the bathymetry file. But if you want to run something fun you will need to specify boundary conditions, initial conditions and/or some forcings.</p> <p>Full list of the parameters</p>"},{"location":"Manual/#bathymetrytopography-files","title":"Bathymetry/topography files","text":"<p>Input bathymetry data as a regular grid using <code>.asc</code>, <code>.nc</code>, <code>.md</code>. This is a required parameter that ultimately also defines the extend of the model domain and model resolution (if not defined by the user).</p> <p><code>bathy = My_bathy_file.asc</code></p> <p>The correct way of reading the file will be dedicated by the file extension. For <code>.nc</code> (netcdf) files you can specify the name of the variable in the file as: <code>mybathyfile.nc?myvar</code> (will look for <code>zb</code> if none are specified). </p> <p>This input file is critical as it defines the extent of the model grid and the base resolution in the model, see below for details.</p> <p>Note: </p> <p>Note</p> <p>Different files can be provided to the code (using the instruction line multiple times). The code will use the last one having information at a given location when interpolating the data to create the bottom elevation (<code>zb</code>) variable.</p>"},{"location":"Manual/#computational-mesh","title":"Computational mesh","text":"<p>BG_Flood generates its own mesh</p> <p>BG_Flood generates its own mesh based on the a referrence point, size and resolution ( by default extracted from the DEM (Digital Elevation Model) extent and resolution).  The extent of the mesh and resolution of the mesh can be overridden by the user via several options. The mesh can also be refined/coarsen in areas or following patterns prescribed by the user.</p> <p>The mesh is a Block Uniform Quadtree. Meaning that it is a domain similar to a quadtree except that each element of the quadtree is a regular cartesian grid of 16x16 elements.</p> <p></p>"},{"location":"Manual/#mesh-domainextent","title":"Mesh domain/extent","text":"<p>By default, the mesh origin, extent, and resolution are read from the DEM. when several DEMs are used (see #Bathymetry/topography files) the model domain is extracted from the first(closer to the top of the file) dem specified.</p> <p>THe domain can be adjusted by specifying (one or more) coordinates of the bounding box of the domain such as:</p> <pre><code>xo = 1.0;\nyo = 0.0;\nxmax = 6.0;\nymax = 5.0;\n</code></pre> <p>In the case above BG_Flood will create a grid that has a bottom left corner at the <code>(xo,yo)</code> coordinate and extend at least all the way to coordinate <code>(xmax,ymax)</code>.</p>"},{"location":"Manual/#resolution","title":"Resolution","text":"<p>The base (or reference) resolution is specified by `dx. By default it is the same as the DEM but can be overule. This is useful when testing the model with a coarser mesh for a quick run.</p> <p>BG_Flood can build a refine mesh. In this case <code>dx</code> is the resolution of the reference level of refinement (level 0). Level 1 of refinement has a resolution of <code>0.5*dx</code>, level 2 is <code>0.25*dx</code>, level -1 is <code>2*dx</code> etc...</p> <p>BG_Flood will automatically calculate the topography values at each mesh nodes from the DEM. This step can require interpolation (when DEM is coarser or out of phase with the DEM) or averaging (when the mesh is coarser than the DEM). </p> <p>Beware of aliasing</p> <p>interpolating and averaging can lead to aliasing so </p>"},{"location":"Manual/#top-and-right-domain-extend-will-not-necessarily-be-what-you-specify","title":"top and right domain extend will not necessarily be what you specify","text":"<p>The <code>(xmax,ymax)</code> is at least reached because the final extent of the domain depends on what resolution (<code>dx</code>) is specified and the mesh block size so that the domain covers a round number of blocks. The mesh requires strictly compatible extent, resolution and round number of block in both <code>x</code> and <code>y</code> directions. While this is sometimes confusing to acheive exactly, BG_Flood automatically adjust <code>xmax</code> and <code>ymax</code> to produce the mesh domain compatible with <code>dx</code> and the block size. Thus <code>xo</code>, <code>yo</code> and <code>dx</code> are always enforced.</p> <p>Beware</p> <p>When specifying <code>xo</code>, <code>yo</code>, <code>xmax</code>, <code>ymax</code> outside of the DEM extent, BG_Flood will extrapolate the values of forcing and DEM by repeating the values on the edge of the DEM domain. </p>"},{"location":"Manual/#example","title":"Example","text":""},{"location":"Manual/#area-of-interest-polygonal-extent","title":"Area of Interest: polygonal extent","text":"<p>Instsead of a rectangular extent BG_Flood can build a mesh based on a polygon domain.</p> <p>By specifying <code>aoi = mydomain.xy</code> BG_Flood will first build a virtual mesh but only keep the block that are inside or intersect the specified polygon.</p> <p>Note</p> <p><code>xo</code> and <code>yo</code> are still used as reference origin of the mesh using either the default DEM values or the ones specified by the user.  Since they are not trivially know at the start of the mesh generation <code>xmax</code> and <code>ymax</code> are also used to define the maximum extent but this is only noticeable by the user in the extent of the output layers.</p>"},{"location":"Manual/#topography-masking","title":"Topography masking","text":"<p>Parts of the input bathymetry can be masked and excluded from the computation. The model extent (and locations of side boundaries) will remain the same but entire blocks can be removed from the computational memory. These area will appear as NaN in the output file. The input grid is first devided in blocks of 16x16. If all the value within a block exceed the mask value (9999 as default) then that block is excluded from memory and no computation will occur there. An \"area of interest\" (AOI) can also be used to select a part of the domain. If none of the cells of a block is located in this area, that block will be excluded from memory. The AOI is prefered other the mask method as the later can create waterfalls on the borders of the domain, specially if the rain-on-grid method is used.</p> <p>There are no fancy treatment of the boundaries of masked blocks so it is safer to select a mask threshold (<code>mask</code>) to keep most of the masked are dry. If water tries to cross to a masked block, The boundary of blocks are treated as Neumann (no gradient) boundaries so the bathymetry of the 2 cells adjacent to a masked block are set to the same value (the value of the second cell removed from the masked block). </p>"},{"location":"Manual/#example_1","title":"Example","text":"<p>Below is an example of di</p>"},{"location":"Manual/#boundaries","title":"Boundaries","text":"<p>Four type of boundaries can be applied at the edge of the model. By default neumann (no perpendicular gradient) is applied. </p> <ul> <li>0: No slip (wall)</li> <li>1: Neumann</li> <li>2: dirichlets (water level )</li> <li>3: Absorbing (only 1D/perpendicular absorbion is implemented)</li> <li>(4: 2D Absorbing (Not implemented yet))</li> </ul> <p>For Boundary type 2 and 3 (Dirichlet and Absorbing) the level at the boundary level is imposed from a file so a file needs to be sepcified: </p><pre><code>    left = 1;\n    right = mybndfile.txt,3;\n    top = mybndfile.txt,3;\n</code></pre> You can also specify boundary segments."},{"location":"Manual/#boundary-file-for-type-2-or-3","title":"Boundary file (for type 2 or 3)","text":"<p>Water level boundary file are needed to type 2 and 3 boundaries. The files are 2 (or more) columns, one with time in the first column and water level is the other(s). Note that the time step in the file doesn't need to be constant. The model will linearly interpolated between steps in the file. The file can be either comma separated or tab separated. This is automatically detected.</p>"},{"location":"Manual/#uniform-boundary-file","title":"Uniform boundary file","text":"<p>For uniform boundary condition (along the boundary axis) the files needs to be 2 column: </p><pre><code>    # Water level boundary\n    0.0  1.2\n    3600.0  1.2\n    36000.0  1.22\n    36060.0  1.25\n    36120.0  1.24\n</code></pre>"},{"location":"Manual/#variable-boundary-file","title":"Variable boundary file","text":"<p>For Variable boundary condition (along the boundary axis) the files needs to be 3+ columns. The boundary axis is then divided by the number of boundary column and the water level is interpolated between location, for example: </p><pre><code>    # Water level boundary\n    0.0  1.2 0.0\n    3600.0  1.2 0.0\n    36000.0  1.22 0.0\n    36060.0  1.25 0.0\n    36120.0  1.24 0.0\n</code></pre> <p>Here the the water level on the near-end of the boundary (left for bottom and top bnds; bottom for left and right bnds) axis will vary between 1.2 and 1.25 but the far-end (right for bottom and top bnd and top for left and right bnds) will remain constant at 0.0.</p> <p>Here is an example with 3 water level column: </p><pre><code>     # Water level boundary\n    0.0 0.0 1.2 0.0\n    3600.0 0.0 1.2 0.0\n    36000.0 0.0 1.2 0.0\n    36060.0 0.0 1.2 0.0\n    36120.0 0.0 1.2 0.0 \n</code></pre> <p>In this case both near and far end of the boundary axis will remain zero and the center of the boundary axis will be 1.2m. </p> <p>There is no restriction in the number of columns. These values from each column will be forced uniformly spaced on the boundary and forcing in between will be linearly interpolated.</p>"},{"location":"Manual/#bottom-friction","title":"Bottom friction","text":"<p>Bottom friction is applied implicitly in the model (applied to velocities after momentum and continuity equations are solved).  There are 3 friction equations implemented defined in <code>BG_param.txt</code> as:</p> <ul> <li><code>frictionmodel = 0</code>: Basic Quadratic friction law (expecting the non-dimensional friction coefficient \\(c_f\\) )</li> <li><code>frictionmodel = 1</code>: Roughtness length model from Smart (expecting a \\(z_0\\) parameter in \\(c_f\\))</li> <li><code>frictionmodel = -1</code>: Manning's friction model (expecting a Manning n parameter \\(c_f\\)) Quadratic friction is the default, with a uniform friction coefficient:</li> </ul> <p></p><pre><code>  frictionmodel = 0\n  cf = 0.001\n</code></pre> If a uniform friction is required add <code>cf=</code> to your <code>BG_param.txt</code> with the desired value. <code>cf</code> keyword is also used for the \\(z0\\) of Smart formulation and \\(n\\) of the Manning formulation.  <p>For non-uniform friction parameter use the keyword  <code>cfmap</code> or <code>roughnessmap</code> and assign an <code>.asc</code> or <code>.nc</code> file. For nc files you may need to supply the netcdf variable name: e.g. <code>cfmap=final_rough.nc?zo</code>. The roughness grid does not need to match the model grid dimension and coarser friction grid will be interpolated to the model grid cells and model cells outside of the forcing domain will be extrapolated (nearest value).</p>"},{"location":"Manual/#rivers-and-area-discharge","title":"Rivers and Area discharge","text":"<p>At this stage river can only be added to the model as a vertical discharge where the water is added to a rectangle on the model with no velocity. To add rivers add a line per river with the parameters: <code>river = Fluxfile,xstart,xend,ystart,yend;</code> where <code>Fluxfile</code> is a 2 column text file containing time and dicharge in \\(m^3/s\\); <code>xstart</code> is the left coordinate of the rectangle where the vertical discharge is applied, <code>xend</code> is the right coordinate of the rectangle, <code>ystart</code> is the bottom coordinate of the rectangle and <code>yend</code> is the top coordinate of the rectangle.  Example: </p><pre><code>    river = Votualevu_R.txt,1867430,1867455,3914065,3914090;\n    river = Mulomulo_R.txt,1867052,1867072,3911853,3911873;\n</code></pre>"},{"location":"Manual/#wind-atm-pressure-forcing","title":"Wind atm pressure forcing","text":""},{"location":"Manual/#wind-forcing-may-contain-bugs","title":"Wind forcing (may contain bugs)","text":"<p>The hydrodynamics can be forced using a linear wind drag. the linear drag can be influenced with the keyword <code>Cd</code>. Wind input is defined with the keyword <code>windfiles</code>. There are several ways to use the keyword.</p>"},{"location":"Manual/#spatially-uniform-txt-file","title":"spatially uniform txt file:","text":"<pre><code>windfiles=mywind.txt\n</code></pre> where <code>mywind.txt</code> is a text file with 3 column (time (\\(s\\)), wind speed (\\(m/s\\)) and wind direction (\\(\\,^{{\\circ}}\\) North)). If the grid is in acoordinate system rotated from the north and a <code>grdalpha</code> is specified, the wind will be automatically rotated to the grid orientation."},{"location":"Manual/#spatially-and-time-varying-input","title":"Spatially and time varying input","text":"<pre><code>windfiles=mywind.nc?uw,mywind.nc?vw\n</code></pre> Here two arguments separated with a comma are expected. The first argument is the netcdf file and variable name containing the U component of the wind (along the X axis) and the second argument is the netcdf file and variable name containing the V component of the wind (along the Y axis). Both can be in the same netcdf file as in the example or in separate netcdf files (add the variable name with a <code>?</code> similarly to other netcdf input options). The dimension of the wind forcing grid does not need to match the model grid dimension and coarser forcing will be interpolated to the model grid cells and model cells outside of the forcing domain will be extrapolated (nearest value)."},{"location":"Manual/#atmospheric-pressure-forcing","title":"Atmospheric pressure forcing","text":"<p>Spatially constant atmospheric pressure forcing is not relevant so only spatially varying forcing is feasable. Like for the wind this is done through a netcdf file: </p><pre><code>atmpfile=myncfile.nc?atmpres\n</code></pre> The forcing pressure is expected to be in Pa and the effect of the atmospheric pressure gradient is calculated as the difference to a reference pressure <code>Paref=101300.0</code> converted to a height using <code>Pa2m=0.00009916</code>. If using hPa your will need to also change the reference pressure to <code>Paref=1013.0</code> and the conversion parameter to <code>Pa2m=0.009916</code>. As with the  wind forcing, the forcing grid does not need to match the model grid dimension and coarser forcing will be interpolated to the model grid cells and model cells outside of the forcing domain will be extrapolated (nearest value)."},{"location":"Manual/#outputs","title":"Outputs","text":"<p>There is two types of outputs:  - map outputs of 2D variables regularly through time.  - time-series output of basic values, at a chosen position, at each time step.</p>"},{"location":"Manual/#map-outputs","title":"Map outputs","text":"<p>These maps are output as a nc file, with information on coordinates and blocks.</p> <p>The map output can be modify by: - defining a timestep (in \\(s\\)) for these outputs: </p><pre><code>outputtimestep = 3600.0;\n</code></pre> - changing the set of variables in the output file (from the list given in the manual) <pre><code>outvars = zs,h,u,v,zb,hmax,Umax,hUmax,twet;\n</code></pre> - changing the name of the output file: <pre><code>outfile = Results_tuto_basicRun.nc;\n</code></pre> <ul> <li>choosing one or more zones to outputs (by default, the full domain is output):  <code>{txt} outzone=MyZoneName.nc,x1,x2,y1,y2; outzone=MyZoneNameb.nc,x1b,x2b,y1b,y2b;</code> </li> <li>saving the output as float (variables are saved as short integer by default.): <pre><code>smallnc = 0;\n</code></pre></li> </ul> <p>By default, the variables outputs are the one listed in the following paragraph: Default snapshot outputs.</p>"},{"location":"Manual/#default-snapshot-outputs","title":"Default snapshot outputs","text":"Parameter Definition Unit u U  velocity (at cell center) zonal velocity positive right [m/s] v V  velocity (at cell center) meridional velocity positive right [m/s] h water depth at cell center [m] zs Water level elevation above datum [m] zb Topography elevation above datum [m]"},{"location":"Manual/#complementary-variables","title":"Complementary variables","text":"Parameter Definition Unit vort Vorticity [rotation/s] cf Bottom friction coefficient (Manning n or z0) varies with model used"},{"location":"Manual/#meanaveraged-output-between-output-steps","title":"Mean/averaged output between output steps","text":"<p>This is for averaging variables in between output steps, useful for mean tidal flow calculation that averages out vortices. The average time is <code>outtimestep</code>.</p> Parameter Definition Unit umean Averaged u  velocity (at cell center) zonal velocity positive right [m/s] vmean Averaged v  velocity (at cell center) meridional velocity positive right [m/s] hmean Averaged water depth at cell center [m] zsmean Averaged Water level elevation above datum [m]"},{"location":"Manual/#max-output","title":"Max output","text":"<p>The max can be calculated for the overall simulation (default) or between output steps ( if <code>resetmax = 1;</code>)</p> Parameter Definition Unit umax Maximum u  velocity (at cell center) zonal velocity positive right [m/s] vmax Maximum v  velocity (at cell center) meridional velocity positive right [m/s] hmax Maximum water depth at cell center [m] zsmax Maximum Water level elevation above datum [m]"},{"location":"Manual/#risk-assesment-related-output","title":"Risk assesment related output","text":"<p>These variables are used to evaluate the damage resulting from the innundation (as a complement to hmax for example).</p> Parameter Definition Unit hUmax Maximum of h time the velocity (U for amplitude of (u,v)) [m2/s] Umax Maximum of the velocity (U for amplitude of (u,v)) [m/s] twet Duration innundation of the cell in s (h&gt;0.1m) [s]"},{"location":"Manual/#model-related-outputs","title":"Model related outputs","text":"<p>These outputs  will be produce only if the associated model/forcing is used.</p> <p>If an atmospheric forcing is used:</p> Parameter Definition Unit Patm Atmospheric pressure [Pa] datmpdx/datmpdy Gradients of atmospheric pressure [Pa/m] <p>If the infiltration model (ILCL) is used, the quantity of water that infiltrate in the ground is saved, as a cumulated value in hgw.</p> Parameter Definition Unit il Initial loss coefficient [mm] cl Continuous loss coefficient [mm/hr] hgw Cumulated height of infiltrated water in the ground [m]"},{"location":"Manual/#other-gradients-and-intermediate-terms-of-the-equations","title":"Other gradients and intermediate terms of the equations","text":"<p>Terms of the equation can also been output such as the gradients (for error tracking mainly):</p> Parameter Definition Unit dhdx / dhdy Gradient of water elevation (h) in the x and y direction respectively [] dzsdx / dzsdy Gradient of the water surface (zs) in the x and y direction respectively [] dudx / dudy Gradient of x-velocity (u) in the x and y direction respectively [s-1] dvdx / dvdy Gradient of y-velocity (v) in the x and y direction respectively [s-1] Fhu / Fhv Flux of h time u in the x and y direction respectively [m2/s2] Fqux / Fqvx XXXXXXXXXXXX [XXX] Su / Sv Topographic source term [XXX] dh Variation in elevation [m] du / dv Variation of the x- and y-velocity respectively [m/s]"},{"location":"Manual/#point-or-time-serie-output","title":"Point or Time-Serie output","text":"<p>For each Time-Serie output needed, a line with the destination file and the postition is needed:</p> <p></p><pre><code>TSnodesout=Offshore.txt,xloc,yloc;\n</code></pre> The file contains 5 colums \\((t, zs, h, u,v)\\) with the value at the nearest grid point (to the position defined by the user)."},{"location":"Manual/#adaptative-grid","title":"Adaptative grid","text":"<p>At the stage of development, the code will adapt the grid only before the computation but not along the calcul.</p> <p>The code is based on a Block-uniform quadtree mesh. Each block, actually a 16 by 16 cells, is one unit of computation in the GPU. These blocks can have different resolutions (but the resolution does not change during the computation at this stage).</p> <p>By default, the initial resolution of the grid is the resolution of the bathymetry/topographic data. To refine or coarsen the grid, you can weather use the <code>dx</code> key word and choose a new resolution for the whole domain; wether use different levels of resolution.  The reference level, correponding to the bathymetry resolution or \\(dx\\) if defined by the user, will be the level 0. Levels of resolution are then defined in relation to the reference levels using positive integers to increase the resolution or refine and negative integer to coarsen the grid by a multiple of two. For a given level  \\(n\\) , the resolution  \\(dx_n\\)   will be: $$ dx_n=$rac{dx_0}{2^n} $$</p> <p>with  \\(dx_0\\) the resolution at level 0. </p> <p>When refinning using the level implementation, different key words are expected:</p> <ul> <li><code>Initlevel</code>: level used to create the first mesh created by the code in the mesh refinement process (only a technical information)</li> <li><code>Maxlevel</code>: maximim level of refinement (over-ruling other commands)</li> <li><code>Minlevel</code>: minimum level of refinement (over-ruling other commands)</li> </ul> <p>The grid can also be unregular with an adaptition of the grid to the model (variables at initialisation step or user-defined refinement map). In this case, the cells will be devided in 4 cells for refinement, or 4 cells merged in one for coarsening. The code will ensure a progressive change of resolution (no cell should have a neighbour with more than 1 level of resolution of difference.)</p> <p>The different methods of refinement available in the code are called using the key word \"Adaptation\". The refinement can be based on a classical input variable or a variable calculated during the initialisation:</p> <ul> <li><code>Threshold</code>: impose a threshold for a different level of resolution</li> <li><code>Inrange</code>: impose a range for a different level of resolution</li> <li><code>Targetlevel</code>: the levels of resolution will be targeted but will be overruled by the maxlevel, minlevel entrance.</li> </ul> <p>For example, for the adaptation with targeted levels: </p><pre><code>initlevel = init ;\nmaxlevel =  max ;\nminlevel = min ;\nAdaptation = Targetlevel,MyLevelMap.nc?levels ;\n</code></pre> Where max and min represent the range of level expected, and init is a number in this range (it is advice to use the min level). MyLevelMap is a netcdf 2D map of levels, that can have a different resolution and dimension from the computational grid. The amplitude of the levels on the map can also be larger than than min/max. All these levels are positive or negative integer. <p>For a bathymetry map of \\(10\\)m resolution ( or <code>dx=10</code>), we can use <code>minlevel=-3</code>, <code>maxlevel=2</code> and <code>initlevel=-3</code> to create a grid where coarser cell will be \\(10/2^{-3}=80\\)m and the thinner \\(10/2^2=2.5\\)m. The level file would contains a 2D map with integer values from -3 to 2.</p>"},{"location":"ParametersList-py/","title":"Parameters list","text":""},{"location":"ParametersList-py/#ParameterList","title":"Paramters and Forcings list","text":"<p>BG_flood user interface consists in a text file, associating key words to user chosen parameters and forcings.</p>"},{"location":"ParametersList-py/#list-of-the-parameters-input","title":"List of the Parameters' input","text":""},{"location":"ParametersList-py/#general-parameters","title":"General parameters","text":"Reference Keys default Explanation test test -1 -1: no test, 99: run all independent tests, X: run test X g g 9.81 Gravity in m.s-2 rho rho 1025.0 Fluid density in kg.m-3 eps eps 0.0001 Drying height in m (if h&lt;eps, the surface is concidered dry) dt dt 0.0 Model time step in s. CFL CFL 0.5 Current Freidrich Limiter theta theta 1.3 Minmod limiter parameter, theta in [1,2]. Can be used to tune the momentum dissipation (theta=1 gives minmod the most dissipative limiter and theta = 2 gives superbee, the least dissipative). VelThreshold VelThreshold , vthresh , vmax , velmax -1.0 Using Velocity threshold if the the velocuity exceeds that threshold. Advice value of 16.0 to use or negative value (-1) to turn off frictionmodel frictionmodel 0 Bottom friction model (-1: Manning model, 0: quadratic, 1: Smart model) cf cf , roughness , cfmap 0.0001 Bottom friction coefficient for flow model (if constant) Cd Cd 0.002 Wind drag coefficient conserveElevation conserveElevation false Switch to force the conservation of h Pa2m Pa2m 0.00009916 Conversion between atmospheric pressure changes to water level changes in Pa (if unit is hPa then user should use 0.009916) Paref Paref 101300.0 Reference pressure in Pa (if unit is hPa then user should use 1013.0) GPUDEVICE GPUDEVICE , gpu 0 0: first available GPU, -1: CPU single core, 2+: other GPU doubleprecision doubleprecision 0 0: float precision, 1: double precision engine engine 1 1: Buttinger, 2: Kurganov, 3: KurganovATMP"},{"location":"ParametersList-py/#grid-parameters","title":"Grid parameters","text":"Reference Keys default Explanation dx dx nan(\"\") Grid resolution in the coordinate system unit in m. nx nx 0 Initial grid size in x direction ny ny 0 Initial grid size in y direction xo xo , xmin nan(\"\") Grid x origin (if not alter by the user, will be defined based on the topography/bathymetry input map) yo yo , ymin nan(\"\") Grid y origin (if not alter by the user, will be defined based on the topography/bathymetry input map) ymax ymax nan(\"\") Grid ymax (if not alter by the user, will be defined based on the topography/bathymetry input map) xmax xmax nan(\"\") Grid xmax (if not alter by the user, will be defined based on the topography/bathymetry input map) grdalpha grdalpha nan(\"\") Grid rotation Y axis from the North input in degrees but later converted to rad posdown posdown 0 Flag for bathy input. Model requirement is positive up  so if posdown ==1 then zb=zb*-1.0f spherical spherical 0 Flag for sperical coordinate (still in development) Radius Radius 6371220. Earth radius [m] mask mask 9999.0 Mask any zb above this value. If the entire Block is masked then it is not allocated in the memory"},{"location":"ParametersList-py/#adaptation","title":"Adaptation","text":"Reference Keys default Explanation initlevel initlevel 0 Initial level of grid adaptation (based on dx if defined by the user or on the resolution of the topography/bathymetry input) maxlevel maxlevel 0 Maximum level for grid adaptation (overwrite the adaptation map if use) minlevel minlevel 0 Minumim level for grid adaptation (overwrite the adaptation map if use) membuffer membuffer 1.05 Needs to allocate more memory than initially needed so adaptation can happen without memory reallocation"},{"location":"ParametersList-py/#timekeeping","title":"Timekeeping","text":"Reference Keys default Explanation outputtimestep outputtimestep , outtimestep , outputstep 0.0 Number of seconds between netCDF outputs, 0.0 for none endtime endtime 0.0 Total runtime in s, will be calculated based on bnd input as min(length of the shortest time series, user defined) and should be shorter than any time-varying forcing totaltime totaltime , inittime 0.0 Total simulation time in s dtinit dtinit -1 Maximum initial time steps in s (should be positive, advice 0.1 if dry domain initialement)"},{"location":"ParametersList-py/#initialisation","title":"Initialisation","text":"Reference Keys default Explanation zsinit zsinit , initzs nan(\"\") Init zs for cold start in m. If not specified by user and no bnd file = 1 then sanity check will set it to 0.0 zsoffset zsoffset nan(\"\") Add a water level offset in m to initial conditions and boundaries (0.0 by default) hotstartfile hotstartfile None Allow to hotstart (or restart) the computation providing a netcdf file containing at least zb, h or zs, u and v hotstep hotstep 0 Step to read if hotstart file has multiple steps (step and not (computation) time)"},{"location":"ParametersList-py/#outputs","title":"Outputs","text":"Reference Keys default Explanation outfile outfile \"Output.nc\" netcdf output file name TSnodesout TSnodesout , TSOutput None Time serie output, giving a file name and a (x,y) position (which will be converted to nearest grid position). This keyword can be used multiple times to extract time series at different locations.The data is stocked for each timestep and written by flocs.The resulting file contains (t,zs,h,u,v)Example: \"TSnodesout: Offshore.txt,3101.00,4982.57\" (filename,x,y) outvars outvars \"zb\", \"zs\", \"u\", \"v\", \"h\" List of names of the variables to output (for 2D maps)Supported variables = \"zb\", \"zs\", \"u\", \"v\", \"h\", \"hmean\", \"zsmean\", \"umean\", \"vmean\", \"hmax\", \"zsmax\", \"umax\", \"vmax\" ,\"vort\",\"dhdx\",\"dhdy\",\"dzsdx\",\"dzsdy\",\"dudx\",\"dudy\",\"dvdx\",\"dvdy\",\"Fhu\",\"Fhv\",\"Fqux\",\"Fqvy\",\"Fquy\",\"Fqvx\",\"Su\",\"Sv\",\"dh\",\"dhu\",\"dhv\",\"cf\" resetmax resetmax false Switch to reset the \"max\" outputs after each output outishift outishift 0 DEBUGGING ONLY: allow cell shift (1 or -1) in x direction to visualise the halo around blocks in the output outjshift outjshift 0 DEBUGGING ONLY: allow cell shift (1 or -1) in y direction to visualise the halo around blocks in the output"},{"location":"ParametersList-py/#netcdf-parameters","title":"Netcdf parameters","text":"Reference Keys default Explanation smallnc smallnc 1 Short integer conversion for netcdf outputs. 1: save as short integer for the netcdf file, if 0 then save all variables as float scalefactor scalefactor 0.01f Scale factor used for the short integer conversion for netcdf outputs addoffset addoffset 0.0f Offset add during the short integer conversion for netcdf outputs"},{"location":"ParametersList-py/#paraview-catalyst-parameters-special-use-with-paraview","title":"ParaView Catalyst parameters (SPECIAL USE WITH PARAVIEW)","text":"Reference Keys default Explanation use_catalyst use_catalyst 0 Switch to use ParaView Catalyst catalyst_python_pipeline catalyst_python_pipeline 0 Pipeline to use ParaView Catalyst vtk_output_frequency vtk_output_frequency 0 Output frequency for ParaView Catalyst vtk_output_time_interval vtk_output_time_interval 1.0 Output time step for ParaView Catalyst vtk_outputfile_root vtk_outputfile_root \"bg_out\" output file name for ParaView Catalyst python_pipeline python_pipeline \"coproc.py\" python pipeline for ParaView Catalyst"},{"location":"ParametersList-py/#list-of-the-forcings-inputs","title":"List of the Forcings' inputs","text":"Reference Keys default Example Explanation cf cf , roughness , cfmap (see constant in parameters) cf=0.001;cf=bottom_friction.nc?bfc; Bottom friction coefficient map (associated to the chosen bottom friction model) Bathy Bathy , bathyfile , bathymetry , depfile , depthfile , topofile , topo , DEM None but input NECESSARY bathy=Westport_DEM_2020.nc?ztopo=Westport_DEM_2020.asc Bathymetry/Topography input, ONLY NECESSARY INPUTDifferent format are accepted: .asc, .nc, .md. , the grid must be regular with growing coordinate.This grid will define the extend of the model domain and model resolution (if not inform by the user).The coordinate can be cartesian or spherical (still in development).A list of file can also be use to provide a thiner resolution localy by using the key word each time on a different line.The first file will be use to define the domain area and base resolution but the following filewill be used during the refinement process. left left , leftbndfile , leftbnd 1 left = 0;left = leftBnd.txt,2; 0:Wall (no slip); 1:neumann (zeros gradient) [Default]; 2:sealevel dirichlet; 3: Absorbing 1D 4: Absorbing 2D (not yet implemented)For type 2 and 3 boundary, a file need to be added to determine the vaules at the boundary. This file will consist in a first column containing time (with possibly variable time steps) and forcing values in the following columns (1 column of values corresponding to a constant value along the boundary, 2 columns correspond to values at boundary edges with linear evolution in between, n columns correspond to n regularly spaced values applied along the boundary) right right , rightbndfile , rightbnd 1 right = 0;right = rightBnd.txt,2; Same as left boundary top top , topbndfile , topbnd 1 top = 0;top = topBnd.txt,2; Same as left boundary bot bot , botbndfile , botbnd , bottom 1 bot = 0;bot = botBnd.txt,2; Same as left boundary deform deform None deform = myDeform.nc?z_def,3.0,10.0;deform = filename, time of initial rupture, rising time; Deform are maps to apply to both zs and zb; this is often co-seismic vertical deformation used to generate tsunami initial waveHere you can spread the deformation across a certain amount of time and apply it at any point in the model. rivers rivers , river None river = Votualevu_R.txt,1867430,1867455,3914065,3914090;river = Fluxfile, xstart, xend, ystart, yend; The river is added as a vertical discharge on a chosen area (the user input consisting in a Time serie and a rectangular area definition).The whole cells containing the corners of the area will be included in the area, no horizontal velocity is applied.To add multiple rivers, just add different lines in the input file (one by river). Wind Wind , windfiles None Wind = mywind.nc?uw,mywind.nc?vwWind = MyWind.txt Spacially varying: 2 files are given, 1st file is U wind and second is V wind ( no rotation of the data is performed)Spacially uniform: 1 file is given then a 3 column file is expected, showing time, windspeed and direction.Wind direction is rotated (later) to the grid direction (using grdalpha input parameter) Atmp Atmp , atmpfile None Atmp=AtmosphericPressure.nc?p The forcing pressure is expected to be in Pa and the effect of the atmospheric pressure gradient is calculated as the difference to a reference pressure Paref, converted to a height using Pa2. Rain Rain , rainfile None rain=rain_forcing.txt rain=rain_forcing.nc?RainIntensity This allow to force a time varying, space varying rain intensity on the model, in mm/h.Spacially varrying (rain map), a netcdf file is expected (with the variable associated to the rain after \"?\").Spacially uniform: the rain is forced using a time serie using a 2 column values table containing time (not necessary unformly distributed) and rain."},{"location":"ParametersList-py/#list-of-the-non-identified-inputs","title":"List of the non-identified inputs","text":"Reference Keys Adaptation Adaptation <p>Note : The keys are not case sensitive.</p>"},{"location":"README_doc/","title":"Documentation Generation","text":""},{"location":"README_doc/#documentation-generation","title":"Documentation Generation","text":"<p>The documentation is generated using: - Doxygen to extract the code information (from .cu, .h and *.cpp files) - Mkdocs-material to generate the markdown part of the documentation - mkdoxy pluggin is added convert XML files generated by doxygen in markdown and include them in the documentation.</p> <p>The documentation is located in the \"docs\" folder. Mkdocs documentation is configured using the mkdocs.yml file (located in root folder). The documentation set-up (librarys...) is saved in the pyproject.toml.</p> <p>The documentation is then deployed directly from the github page of the code, using a workflow action. When this action is triggered, the documentation pages are updated and pushed in a special branch: \"gh-page\" and deplyed from there.</p> <p>Different pluggins have been added to improve the documentation: - mkdocs-awesome-nav : to improve the navigation and use of glob type notation to get for example all the md files in a folder</p>"},{"location":"References/","title":"References","text":""},{"location":"References/#references","title":"References","text":"<p>Prefered BG_Flood citation</p> <p><sup>1</sup>Cyprien Bosserelle, Emily Lane, and Alice Harang. Coastal flooding and port infrastructure: a case study of apia, samoa. Coasts and Ports, 2022.</p>"},{"location":"References/#acknowledgments","title":"Acknowledgments","text":"<ul> <li>Basilisk and its teams from where this code originate</li> <li>ESNZ (previously NIWA)</li> <li> </li></ul>"},{"location":"References/#list-of-references","title":"List of references","text":"<p>Full reference list from work used in the development of BG_Flood and produced using the code.</p> <ol> <li> <p>Cyprien Bosserelle, Emily Lane, and Alice Harang. Coastal flooding and port infrastructure: a case study of apia, samoa. Coasts and Ports, 2022.\u00a0\u21a9</p> </li> <li> <p>Renato Vacondio, Alessandro Dal Pal\u00f9, Alessia Ferrari, Paolo Mignosa, Francesca Aureli, and Susanna Dazzi. A non-uniform efficient grid type for gpu-parallel shallow water equations models. Environ. Model. Softw., 88(C):119\u2013137, February 2017. URL: https://doi.org/10.1016/j.envsoft.2016.11.012, doi:10.1016/j.envsoft.2016.11.012.\u00a0\u21a9</p> </li> <li> <p>Rebecca Welsh, Shaun Williams, Cyprien Bosserelle, Ryan Paulik, Josephina Chan Ting, Alec Wild, and Lameko Talia. Sea-level rise effects on changing hazard exposure to far-field tsunamis in a volcanic pacific island. Journal of Marine Science and Engineering, 2023. URL: https://www.mdpi.com/2077-1312/11/5/945, doi:10.3390/jmse11050945.\u00a0\u21a9</p> </li> <li> <p>Alexander Kurganov and Doron Levy. Central-upwind schemes for the Saint-Venant system. ESAIM: Mod\u00e9lisation math\u00e9matique et analyse num\u00e9rique, 36(3):397\u2013425, 2002. URL: https://www.numdam.org/articles/10.1051/m2an:2002019/, doi:10.1051/m2an:2002019.\u00a0\u21a9</p> </li> <li> <p>G. Kirstetter, O. Delestre, P.-Y. Lagr\u00e9e, S. Popinet, and C. Josserand. B-flood 1.0: an open-source saint-venant model for flash-flood simulation using adaptive refinement. Geoscientific Model Development, 14(11):7117\u20137132, 2021. URL: https://gmd.copernicus.org/articles/14/7117/2021/, doi:10.5194/gmd-14-7117-2021.\u00a0\u21a9</p> </li> <li> <p>Andreas Buttinger-Kreuzhuber, Zsolt Horv\u00e1th, Sebastian Noelle, G\u00fcnter Bl\u00f6schl, and J\u00fcrgen Waser. A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography. Advances in Water Resources, 127:89\u2013108, 2019. URL: https://www.sciencedirect.com/science/article/pii/S0309170818305335, doi:https://doi.org/10.1016/j.advwatres.2019.03.010.\u00a0\u21a9</p> </li> <li> <p>Alexander Kurganov and Guergana Petrova. A second-order well-balanced positivity preserving central-upwind scheme for the saint-venant system. Communications in Mathematical Sciences, 5(1):133\u2013160, 2007. URL: https://www.aimsciences.org/article/doi/10.4310/CMS.2007.v5.n1.a7, doi:10.4310/CMS.2007.v5.n1.a7.\u00a0\u21a9</p> </li> <li> <p>Xilin Xia and Qiuhua Liang. A new efficient implicit scheme for discretising the stiff friction terms in the shallow water equations. Advances in Water Resources, 117:87\u201397, 2018. URL: https://www.sciencedirect.com/science/article/pii/S0309170818302124, doi:https://doi.org/10.1016/j.advwatres.2018.05.004.\u00a0\u21a9</p> </li> <li> <p>Yuichi IWAGAKI. Fundamental studies on the runoff by characteristics. Bulletins - Disaster Prevention Research Institute, Kyoto University, 10:1\u201325, 12 1955. URL: https://repository.kulib.kyoto-u.ac.jp/items/645aa8f5-f0c1-4aef-8ba7-4cddc2f589e1.\u00a0\u21a9</p> </li> <li> <p>St\u00e9phane Popinet. Quadtree-adaptive tsunami modelling. Ocean Dynamics, 61:1261\u20131285, 09 2011. URL: https://doi.org/10.1007/s10236-011-0438-z, doi:10.1007/s10236-011-0438-z.\u00a0\u21a9</p> </li> <li> <p>Francesca Aureli, Federico Prost, Renato Vacondio, Susanna Dazzi, and Alessia Ferrari. A gpu-accelerated shallow-water scheme for surface runoff simulations. Water, 2020. URL: https://www.mdpi.com/2073-4441/12/3/637, doi:10.3390/w12030637.\u00a0\u21a9</p> </li> <li> <p>Luis Cea, Jer\u00f3nimo Puertas, Luis Pena, and Marta Garrido. Hydrologic forecasting of fast flood events in small catchments with a 2d-swe model. numerical model and experimental validation. Proceedings of the 6th World Congress on Water Resources and Environment (IWRA 2008), 2008. URL: https://iwra.org/congress/2008/resource/authors/abs478_article.pdf.\u00a0\u21a9</p> </li> </ol>"},{"location":"Tutorial_intro/","title":"Introduction","text":""},{"location":"Tutorial_intro/#tutorials","title":"Tutorials","text":"<p>Two differents types of tutorial are proposed, some are benchmark configurations, with basics inputs generated during the tutorials, the other ones are more realistic cases with inputs provided (to download).</p>"},{"location":"Tutorial_intro/#benchmark-tutorials","title":"Benchmark tutorials","text":"<p>Here is a list of all the available tutorials:</p> <ul> <li> <p>Jet tutorial (Julia): Simple tutorial presenting a jet simulation in BG_Flood. All imputs files are generated manually or with Julia.</p> </li> <li> <p>Gaussian wave: Simple tutoral presenting a Gaussian wave propagation</p> </li> <li> <p>Transpacific tsunami: Simple tutorial presenting a transpacific tsunami propagation</p> </li> <li> <p>Monia tutorial (Julia) (still in construction)</p> </li> </ul>"},{"location":"Tutorial_intro/#real-configuration-tutorials","title":"Real configuration tutorials","text":"<ul> <li> <p>River flooding tutorial: Simple tutorial that go through the construction of a simple <code>BG_param.txt</code> file for fluvial and pluvial flooding. Some realistic input files are provided.</p> </li> <li> <p>Tsunami propagation  (still in construction)</p> </li> </ul>"},{"location":"Tutorial_jet_Julia2/","title":"Tutorial jet Julia2","text":"<p>@page TutorialJetJulia Jet tutorial with Julia</p> <p>This is a very simple example that shows the model stability in transitional flows.</p>"},{"location":"Tutorial_jet_Julia2/#make-a-bathymetry","title":"Make a bathymetry","text":"<p>Below is a Julia script to make the bathymetry.</p> <pre><code>using GMT\n\nny=16*16;\nnx=16*32;\n\ndx=5.0;\n\nxmin=0;\nxmax=nx*dx;\n\nymin=0;\nymax=ny*dx;\n\nBathy=zeros(nx,ny);\n\nBathy.=-5.0;\n\nBathy[170:172,:].=5.0;\nBathy[170:172,127:129].=-5.0;\n\nBathy[:,1:2].=5.0;\nBathy[:,(end-1):end].=5.0;\n\nG = mat2grid(transpose(Bathy), 1,[xmin xmax ymin ymax -5.0 5.0 1 dx dx])\ncmap = grd2cpt(G);      # Compute a colormap with the grid's data range\ngrdimage(G, lw=:thinnest, color=cmap, fmt=:png, show=true)\n\ngmtwrite(\"bathy.asc\", G; id=\"ef\");\n</code></pre> <p>The result is a grid domain looking like this:  You can also use the bathy.asc file in the example folder.</p>"},{"location":"Tutorial_jet_Julia2/#make-bnd-files","title":"Make Bnd files","text":"<p>We are going to set the water level to 0.0m on the right and 1.0 on the left and keep it constant. To dio that we create 2 files <code>right.txt</code> and <code>left.bnd</code></p>"},{"location":"Tutorial_jet_Julia2/#rightbnd","title":"<code>right.bnd</code>","text":"<pre><code># This is the right boundary\n0.0 0.0\n3600.0 0.0\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#leftbnd","title":"<code>left.bnd</code>","text":"<pre><code># This is the right boundary\n0.0 1.0\n3600.0 1.0\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#set-up-the-bg_paramtxt-file","title":"Set up the <code>BG_param.txt</code> file","text":"<p>First it is good practice to document your parameter file:</p> <pre><code>##############################\n## Jet demo\n# CB 04/05/2019\n</code></pre> <p>Then specify the bathymetry file to use. We will use the entire domain and resolution of the file so no need for other parameter for specifying the domain.</p> <pre><code>bathy=bathy.asc\n</code></pre> <p>Specify the parameter theta to control the numerical diffusion of the model. but first let's leave it to the default.</p> <pre><code>theta=1.3;\n</code></pre> <p>This is a relatively small model so we can force the netcdf variable to be saved as floats.</p> <pre><code>smallnc=0\n</code></pre> <p>Sepcify the model duration, output timestep and output file name and variables</p> <pre><code>endtime=1800\nouttimestep=10\noutfile=Jet_demo.nc\noutvars=zb,uu,vv,zs,vort;\n</code></pre> <p>Specify absorbing boundaries for left and right (There is a wal at the top and bottom so no need to specify any boundary there).</p> <pre><code>right = 3; # Absorbing bnd\nrightbndfile = right.bnd\n\nleft=3; # Absorbing bnd\nleftbndfile = left.txt\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#run-the-model","title":"Run the model","text":"<p>If you are on windows simply double-click on the executable and in linux launch the binary.</p> <p>Vorticity output should look like this:</p> <p>Video</p>"},{"location":"Tutorial_jet_Julia2/#things-to-try","title":"Things to try","text":"<ul> <li>What happens when using a different value for theta (1-2.0)</li> <li>What happens when specifying a different type of boundary on the right </li> <li>What happens when you bring the boundary close to the jet</li> <li>Why is the jet so unstable/asymmetrical? (what are the initial condition like?)</li> </ul>"},{"location":"Tutorial_jet_Julia2/#gaussian-wave","title":"Gaussian Wave","text":"<p>This is a great example to test whether there are bugs in the model and how the boundary work.</p>"},{"location":"Tutorial_jet_Julia2/#bathymetry","title":"Bathymetry","text":"<p>We start with a flat bathymetry with 0.0 everywhere. You still need a file for that!</p> <p>Here a couple of suggestion on making the file: Using GMT: <code>grdmath -R-5/5/-5/5 -I0.03921 0 MUL = bathy.nc</code></p> <p>Using Julia: See section below with the hotstart file.</p> <p>In any case you can pick up the file in the example folder.</p>"},{"location":"Tutorial_jet_Julia2/#hortstart","title":"Hortstart","text":"<p>We want to setup a bump in the water level centered in the middle of the bathy. IN the example below this is done using Julia, but it should be easily done in Matlab or Python. Note that the script below also generates a bathymetry file.</p> <pre><code>using GMT\n\nxo=-5;\nyo=-5;\n\nnx=16*16;\nny=16*16;\n\nlen=10.0;\n\ndx=len/(nx-1);\n\nxx=collect(xo:len/(nx-1):(len+xo));\nyy=collect(yo:len/(ny-1):(len+yo));\n\n# Make a bathy file\nzb=zeros(nx,ny);\nG = mat2grid(transpose(zb), 1,[xx[1] xx[end] yy[1] yy[end] minimum(zb) maximum(zb) 1 dx dx])\ngmtwrite(\"bathy.asc\", G; id=\"ef\");\n\n#make the hotstart file\nhh=zeros(nx,ny);\nfor i=1:nx\n    for j=1:ny\n        hh[i,j] = 1.0.+ 1.0.*exp.(-1.0*(xx[i].*xx[i] .+ yy[j].*yy[j]));\n        #hh[i,j] =\n    end\nend\n\nG = mat2grid(transpose(hh), 1,[xx[1] xx[end] yy[1] yy[end] minimum(hh) maximum(hh) 1 dx dx])\ncmap = grd2cpt(G);      # Compute a colormap with the grid's data range\ngrdimage(G, lw=:thinnest, color=cmap, fmt=:png, show=true)\n\ngmtwrite(\"gauss.asc\", G; id=\"ef\");\ngmtwrite(\"gauss.nc\", G);\n# GMT netcdf variable is \"z\" by default but the hotstart file needs \"zs\" for water surface\ngmt(\"grdmath gauss.nc 1.0 MUL = gauss_zs.nc?zs\");\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#make-bnd-files_1","title":"Make Bnd files","text":"<p>We are going to set the water level to 0.0m on all 4 sides and keep it constant. To do that we create 1 files <code>zero.txt</code>:</p> <pre><code># This is the a boundary\n0.0 0.0\n3600.0 0.0\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#set-up-the-bg_paramtxt-file_1","title":"Set up the <code>BG_param.txt</code> file","text":"<p>First it is good practice to document your parameter file:</p> <pre><code>##############################\n## Gaussian bump demo\n# CB 04/05/2019\n</code></pre> <p>Then specify the bathymetry file to use. We will use the entire domain and resolution of the file so no need for other parameter for specifying the domain.</p> <pre><code>bathy=bathy.asc\n</code></pre> <p>This is a relatively small model so we can force the netcdf variable to be saved as floats.</p> <pre><code>smallnc=0\n</code></pre> <p>Specify the hotstart file:</p> <pre><code>hotstartfile=gauss_zs.nc;\n</code></pre> <p>Boundary conditions are all the same :</p> <pre><code>right = 3; # Absorbing bnd\nrightbndfile = zeros.txt\n\ntop = 3; # Absorbing bnd\ntopbndfile = zeros.txt\n\nbot = 3; # Absorbing bnd\nbotbndfile = zeros.txt\n\nleft=3; # Absorbing bnd\nleftbndfile=zeros.txt\n</code></pre> <p>Time keeping:</p> <pre><code>endtime=20;\nouttimestep=1;\n</code></pre> <p>Output parameters:</p> <pre><code># Netcdf file for snapshot of the model domain\noutfile=Gauss_demo.nc\noutvars=zb,uu,vv,zs,vort;\n\n# Outpout a single txt file with all the model steps at the nearest node to location x=0.0, y=-4.0\n# This file will contain 5 column: time,zs,hh,uu,vv\nTSOfile=Southside.txt;\nTSnode=0.0,-4.0;\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#run-the-model_1","title":"Run the model","text":"<p>Plot Southside.txt in your favorite tool.</p>"},{"location":"Tutorial_jet_Julia2/#things-to-try_1","title":"Things to try:","text":"<ul> <li>What happens with different boundary types</li> <li>Try running with double precision. What is the difference?</li> </ul>"},{"location":"Tutorial_jet_Julia2/#transpacific-tsunami","title":"Transpacific tsunami","text":"<p>This tutorial is the next stat from the Gaussian wave. Here we produce a realistic tsunami and let it propagate across the Pacific.</p>"},{"location":"Tutorial_jet_Julia2/#bathy-and-domain-definition","title":"Bathy and domain definition","text":"<p>The bathymetry file we are using was extracted from the GEBCO gobal bathymetry using GMT command grdcut / grdsample. This section needs a tutorial of its own. Here in the <code>BG_param.txt</code> we specify the file name and that it is a spherical model domain.</p> <pre><code># Bathymetry file\nbathy = Tpac_big.asc;\nspherical = 1;\n</code></pre> <p>The file covers a bigger area than we want to use for the simulation so we restict the domain:</p> <pre><code>ymin=-78.0\nymax=14.32\n\ndx=0.08;\n</code></pre> <p>Also we do not want to simulate Blocks that are entirely covered in land where the elevation is bigger than say 30.0m above the datum</p> <pre><code>mask = 30.0;\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#initial-tsunami-wave","title":"Initial tsunami wave","text":"<p>See matlab file in the folder or simply use:</p> <pre><code>hotstartfile=Maule_zs_init_simpleflt.nc;\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#boundary","title":"Boundary","text":"<p>In the previous tutorial you have seen how different boundary type let's wave through with minimal reflection. You choose.</p>"},{"location":"Tutorial_jet_Julia2/#time-keeping","title":"Time Keeping","text":"<pre><code>totaltime = 0.000000; # Start time\nendtime = 54000.000000;\noutputtimestep = 600.000000;\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#outputs","title":"Outputs","text":"<pre><code>outvars = hh,zs,zsmax;\n# Files\noutfile = Output_simple_fault.nc;\nsmallnc = 0; #if smallnc==1 all Output are scaled and saved as a short int\n\nTSnode = -86.374,-17.984\nTSOfile = SW_Lima.txt\n</code></pre>"},{"location":"Tutorial_jet_Julia2/#things-to-try_2","title":"Things to try","text":"<ul> <li>Try changing the model domain and resolution. What happens if part of the domain is outside of the area covered by the bathymetry?</li> <li>Try outputing a time series near Christchurch</li> </ul>"},{"location":"Tutorial_jet_Julia2/#river-rain-waikanae-example","title":"River + Rain = Waikanae example","text":"<p>Here we setup a model of the Waikanae Catchment (on the Kapiti Coast in New Zealand) force the tide on one of the open boundary </p>"},{"location":"paper/","title":"'BG_Flood: Adaptive GPU-capable hydrodynamics model for flood and inundation '","text":"<ul> <li>C++</li> <li>CUDA</li> <li>flood</li> <li>inundation</li> <li>tsunami</li> <li>storm-surge</li> <li>adaptive mesh refinement</li> <li>GPU</li> </ul> <p>authors:   - name: Cyprien Bosserelle  q  corresponding: true # (This is how to denote the corresponding author)     orcid: 0000-0000-0000-0000     equal-contrib: true     affiliation: 1   - name: Alice Harang     equal-contrib: true # (This is how you can denote equal contributions between multiple authors)     orcid: 0000-0000-0000-0000     affiliation: 1   - name: Emily Lane     affiliation: 1 affiliations:  - name: Earth Sciences New Zealand    index: 1</p> <p>date: 1 July 2025 bibliography: paper.bib</p>"},{"location":"paper/#summary","title":"Summary","text":"<p>Flood hazard assessment and forecasting aften require physics-based simulations. These simulation are often completted using hydrodynamics models using high resolution to capture small landscape and flow features (e.g. small drains, hydraulic jump), but also capture large scale domain where the hazard forms and or amplifies (e.g. river catchment, continental shelf). this is only acheivable with unstructured and adaptive mesh. Unfortunatly most available open-source codes only provide unstructured mest that rely heavily on user's input for generating a suitable mesh. These model also do not generally offer a flexibility in reverting mesh generation. Most available open-source model also do not offer GPU enabled code that is well optimised and instead for the few that can offer  </p> <p>Enabling GPU and semi-automatic mesh refinement is critical to enable rapid devlopement of flood assessment that doesn't compromise physics simulated.     </p>"},{"location":"paper/#statement-of-need","title":"Statement of need","text":"<p>BG_Flood is a numerical model for simulating shallow water hydrodynamics on the GPU using an Adaptive Mesh Refinment type grid. The model was designed with the goal of simulating inundation (River, Storm surge or tsunami). The model uses a Block Uniform Quadtree approach that runs on the GPU with adaptive mesh being generated at the start of tee simulation.</p> <p>The core SWE engines and adaptivity has been inspired and taken from St Venant solver from Basilisk (Popinet XXXX) and the CUDA GPU memory model has been inspired by the work from (Vacondio et al. 2017). The rest of the implementation</p>"},{"location":"examples/GaussianWave/","title":"GaussianWave","text":"<p>@page GaussianWave Gaussian wave verification</p>"},{"location":"examples/GaussianWave/#intro","title":"Intro","text":"<p>This is a basic but common test to verify the integrity of the model equations. This test is also good to show different type of boundaries reflect waves. </p>"},{"location":"examples/GaussianWave/#goal","title":"Goal","text":"<ul> <li>Check that the solution produces symmetrical results</li> <li>Test hotstart condition</li> <li>Show how different boundary formulation absorb wave</li> </ul>"},{"location":"examples/GaussianWave/#settings","title":"Settings","text":""},{"location":"examples/GaussianWave/#you-will-need","title":"You will need:","text":"<ul> <li>Flat bottom bathymetry file. (See below) </li> <li>Hotstart file. here only water level is needed to hotstart the water surface (zs)</li> </ul>"},{"location":"examples/GaussianWave/#bathy","title":"Bathy","text":""},{"location":"examples/GaussianWave/#initial-conditon","title":"Initial conditon","text":"<p>Here we follow a similar initial condition as in Basilisk</p>"},{"location":"examples/GaussianWave/#bg_paramtxt","title":"BG_param.txt","text":"<pre><code>bathy = bathy.nc?z;\n# Model controls\ngpudevice = 0;\nspherical = 0;\ntheta=1.3;\ndoubleprecision=1\nzsinit=0.0\nhotstartfile=zsinit.nc\n# Flow parameters\neps = 0.00010000;\ncf=0.0000;\nfrictionmodel = 0\n# Timekeeping parameters\nCFL = 0.500000;\noutputtimestep = 600.0;\noutvars = zb, hh, uu, vv, hhmax, zs, zsmax;\nendtime = 18000.0;\nleft=2;\nright=2;\ntop=2;\nbot=2;\ntopbndfile=bnbzero.txt;\nbotbndfile=bnbzero.txt;\nrightbndfile=bnbzero.txt;\nleftbndfile=bnbzero.txt;\nsmallnc=0;\noutfile = Testbed-Gaussian.nc;\n</code></pre>"},{"location":"examples/GaussianWave/#result","title":"Result","text":""},{"location":"examples/GaussianWave/#run-times","title":"Run times","text":""},{"location":"examples/Monai/","title":"Monai","text":"<p>@page Monai Monai test Case</p>"},{"location":"examples/Monai/#goals","title":"Goals","text":"<ul> <li>Check Boundary forcing</li> <li>Check wave propagation and runup on complex topography against experimental data</li> </ul>"},{"location":"examples/Monai/#status","title":"Status","text":"<p>Success</p>"},{"location":"examples/Monai/#settings","title":"Settings","text":""},{"location":"examples/Monai/#results","title":"Results","text":"<p>Model behaves similar to other codes and ca reproduce the bulk of the tsunami waves. Results are comparable to the same class of models. The double precision simulation is virtually identical to the Double precision run confirming that in this case there is not much point on using the Double precision.</p> <p>skill assessment: Single precision</p> ------------- RMS error (m) Will-corr BSS Gauge 1 0.003391 0.978040 0.910979 Gauge 2 0.003735 0.965899 0.870943 Gauge 3 0.003284 0.976699 0.884080 <p>Double precision</p> ------------- RMS error (m) Will-corr BSS Gauge 1 0.003391 0.978039 0.910981 Gauge 2 0.003733 0.965948 0.871093 Gauge 3 0.003283 0.976704 0.884097 <p> Figure 1. Measured and simulated timeseries for the Monai benchmark</p>"},{"location":"examples/Monai/#run-times","title":"Run times","text":"GPU Quadro K620 GeForce GTS 450 other GPU Single Precision (s) 27 20 XX Double Precision (s) XX 34 XX"},{"location":"examples/RainOnGrid/","title":"RainOnGrid","text":"<p>@page RainOnGrid Rain on grid</p>"},{"location":"examples/RainOnGrid/#rain-on-grid","title":"Rain-on-grid","text":""},{"location":"examples/RainOnGrid/#goals","title":"Goals","text":"<ul> <li>Check rainfall forcing</li> <li>Check model mass conservation</li> <li>Compare model performance to experimental data</li> </ul>"},{"location":"examples/RainOnGrid/#settings","title":"Settings","text":""},{"location":"examples/RainOnGrid/#results","title":"Results","text":""},{"location":"modules/NewGradient/","title":"New Gradient Method","text":"<p>Halo and gradient</p> <p>Using multi-resolution in BG_Flood, we need to keep track of how blocks with different resolutions talk to each other. This page tries to explain how this is done.</p>"},{"location":"modules/NewGradient/#why-halo","title":"Why halo","text":"<p>In BUQ grid we keep track of a ring of cells (halo) on every edge of the block. These cells store the information corresponding to the neighbor cells on the neighbor block. If the neighbor block is at the same level of refinement, the values in the halo are a simple copy otherwise they are calculated using the operations described below. The point of the halo is that, when doing operations on a block, the model doesn't need to look at other blocks. It also makes it cleaner and avoid repeating the costly calculation needed when two blocks are at a different levels of refinment.</p> <p>The halo cells exist for all variables including gradients so, even when looking at immediate neighbor cells we can make 2nd order calculations. </p> <p>Here is a diagram for a block of 16x16 cells:</p> <p></p>"},{"location":"modules/NewGradient/#restriction-and-prolongation","title":"Restriction and prolongation","text":"<p>In Basilisk the operation to calculate a value from one level to another are called restriction and prolongation depending whether you calculate from coarse to fine or fine to coarse.</p> <p>If the two blocks are the same level of refinement:</p> <p></p> <p>otherwise:</p> <p></p>"},{"location":"modules/NewGradient/#prolongation","title":"Prolongation","text":"<p>Prolongation is the action of extending a value from a coarse cell to a finer cell. Often this is done by using the gradient value.  e.g.:</p> \\[ HaloB = A + Gradient(A) * dx * 0.5 \\]"},{"location":"modules/NewGradient/#restriction","title":"Restriction","text":"<p>Restriction is where we calculate the value of a coarse cell from values of fine cells. This is usually done with cell average.</p> \\[ HaloA = 0.25*(B1+B2+B3+B4) \\]"},{"location":"modules/NewGradient/#filling-the-halo-the-chicken-and-the-egg","title":"Filling the Halo: The chicken and the egg.","text":"<p>When doing a prolongation operation one needs the gradient of the variable but to calculate gradient the halo needs to be filled. This is a chicken and egg situation.</p> <p>The naive way of doing this is to first do restiction, calculate a gradient (everywhere), then doing the prolongation and then recalculating the gradient (everywhere) to fix the gradient in the cell neighboring prologation cells. This is inefficient!</p> <p>Instead we first fill the halo for straight copy cells and restriction cells. Then calculate gradient (everywhere) and then do the prolongation where needed and then recalculating the gradient on cells near halo only.</p>"},{"location":"modules/NewGradient/#conserving-elevation","title":"Conserving elevation","text":"<p>Using prolongation at the wet/dry interface can lead to inconsistencies between \\(h\\) and \\(zs\\). To limit the inconsistency \\(zs\\) is calculated from \\(h\\) after a prolongation calculation (see refine_linear). While this conserves mass, it, however, leads to a violation of the lake-at-rest resulting in (small) spurious velocity at that interface. To remove the instability and preserve the elevation of the water (rather than its mass) we use a conserve elevation option (conserveelevation = true). This gets rid of the instability and preserves the elevation of the water level but then violates the mass conservation.</p>"},{"location":"modules/NewGradient/#fluxes-halo-are-a-bit-different","title":"Fluxes halo are a bit different","text":""},{"location":"modules/RainLoss_ILCL-model/","title":"Ground infiltration","text":"<p>Ground infiltration: Initial Loss - Continuous Loss</p> <p>Rainfall is often absorbed in soil and leaf litter before joining surface flow.The default behaviour of BG_Flood is to assume the rainfall given as input is actually runoff (i.e. rainfall exess that will make the surface flows). Instead a basic initial - continuous loss model can be apply to approximate runoff. </p>"},{"location":"modules/RainLoss_ILCL-model/#model-implemented","title":"Model implemented","text":"<p>The Initial Loss - Continuous Loss (ILCL) is a very basic model for infiltration of surface water in the soil. It requires the input of two maps, based on the soil properties: one containing an initial loss coefficient \\(il\\) in mm, the second containing a continuous loss coefficient \\(cl\\) in mm/hr.</p> <p>In this model, the initial and continuous losses are applied directly on the water elevation computed on each cell (and not by modifying the rain input). The value of the initial loss \\(il\\) is estimated to be the total of water infiltrating in the ground before the beginning of the surface runoff, whereas the continuous loss \\(cl\\) is the loss that occurs, on wet cells, from the begining of the surface runoff to the end of the simulation. The water absorbed in the ground will be tracked using the ground water elevation variable \\(hgw\\) but wont be reintroduced to the surface flow through the computation process.</p> <p>On each cell, at each simulation step, we can express the quantity of water absorbed in the ground \\(ha_{t}\\) using:</p> \\[ ha_{t} = \\begin{cases}   h_{t} &amp; \\text{if} \\;\\; hgw_{t-1} + h_{t} &lt; il\\\\      cl &amp; \\text{if}\\;\\; hgw_{t-1} &gt; il\\\\      \\min(il - hgw_{t-1} + cl\\,,\\, h_{t}) &amp; \\text{otherwise} \\end{cases} \\] <p>where \\(il\\) and \\(cl\\) are respectively the initial loss and continuous loss coefficient at a given cell location, and \\(hgw_{t}\\) is the accumulated ground water at this cell location since the begining of the simulation.</p> <p>The water absorbed is then added to the ground water tracking variable:</p> \\[ hgw_{t}=hgw_{t-1} + ha_{t} \\] <p>and removed from the surface water height and the surface water elevation (not shown here):</p> \\[ h_{t \\;final} = h_{t} - ha_{t} \\] <p>The following figure shows a representation of the initial loss - continuing loss model with \\(il = 10 mm\\) and \\(cl = 1 mm/s\\) :</p> <p></p> <p>Initial loss and continuing loss reprensentation during a cell-wetting event</p> <p>Note</p> <p>All cells that are initially wet at the begining of the simulation (\\(h &gt; XParam.eps\\)) will have their initial loss (\\(il\\)) set to 0.0, in order to be consistent with the physic of the model.</p> <p>Warning</p> <p>This model is meant to be used with the rain on grid feature. The model is applied indistinctively to water from any source and can cause unexpected results if misused.</p>"},{"location":"modules/RainLoss_ILCL-model/#testcase-for-the-ilcl-model","title":"Testcase for the ILCL model","text":"<p>The ILCL model is tested in the Westport (ANZ) area, on the Orowaiti river (with a uniform 5m grid). A 20mm/hr rain is uniformly applied on the domain during 30 minutes. An initial loss of 5mm and an continuous loss of 5mm/h are used to define infiltration uniformly on the domain. The results, compared to a reference case without infiltration, are presented in the following figure. </p>"},{"location":"modules/RainLoss_ILCL-model/#reference-values","title":"Reference values","text":"<p>Some reference values for the \\(il\\) and \\(cl\\) coefficients can be found in the literature. Some relate to entire subcatchment and are estimated from hydrology, other can be defined using local information (type of soil, rain antecedents, soil layer depth, ...). Whatever you select, be mindfull the model is likely to be very sensitive to rainfall loss.</p> <p>The Initial loss is usually defined based on the antecedent moisture conditions and the soil layer depth and range from 0 to 50mm. The Australian Rainfall &amp; Runoff project concidere the initial loss value at a catchemnt scale and observed a low mean value of 1.1mm in urban catchments; in rural catchment, the initial loss is highly variable with a mean of 32mm and a standard deviation of 17mm.</p> <p>The Constant loss rate can typically be related to the saturated hydraulic conductivity. The following table as been produced by Rawls, Brakensiek, and Miller (1983) using mesurements on soil samples from the USA.</p> Soil texture class Hydraulic conductivity or continuous loss (mm/h) Sand 117.8 Loamy sand 29.9 Sandy loam 10.9 Loam 3.4 Silt loam 6.5 Sandy clay loam 1.5 Clay loam 1.0 Silty clay loam 1.0 Sandy clay 0.6 Silty clay 0.5 Clay 0.3 <p>Below is the ARR 2016 Rainfall Loss Parameters for Urban area, depending of the surface type: | Urban Surface | Burst Initial loss (mm) | Continuing loss (mm/hr) | | :-------------: | ----------------------- | ----------------------- | | Effective Impervious Area | 0.4 | 0.0 | | Indirectly Connected Area | 16.1 | 1.6 | | Urban Pervious Area | 26.9 |1.6|</p> <p>Below is an other example of compilation of some of these values from https://help.innovyze.com/display/xprafts/Initial+and+Continuing+Loss+Model.</p> <p></p>"},{"location":"modules/Wetdryfix-Conservelevation/","title":"Wet-dry fix","text":""},{"location":"modules/Wetdryfix-Conservelevation/#conserve-elevation","title":"Conserve Elevation","text":"<p>At the interface of coarse and fine blocks we often cannot strictly conserve both mass (h) and water elevation. The difference in most cases is relatively small but near the wet/dry interface, trying to conserve mass leads to instabilities. Since these instabilities are a bit annoying by default BG_Flood enforces the conservation of elevation at the interface between coarse and fine blocks where wet and dry cells are present. This might lead to a mismatch between the expected volume and actual volume when simulating rain or river flooding. Similarly, ignoring the conserve elevation requirement when simulating a tsunami can lead to a underestimate of the tsunami. The impact of these switch is small and we can show how small they are below.</p> <p>Below are two examples of basic flood model to test the impact of the wet/dry instability fix (hereafter wetdryfix) on mass conservation. Further below is to test the impact of the wetdryfix and conserve elevation routimne (hereafter conserveElevation) on a tsunami wave propagating on a real steep bathymetry (Samoa).</p>"},{"location":"modules/Wetdryfix-Conservelevation/#mass-conservation-implication","title":"Mass conservation implication","text":"<p>Using the Waikanae topo with cst rain at 50mm/h for 1 hour. using the rainbnd option and wall bnd on all side. Results are undestinguishable from each other and after 1 hr the model has 100.48% of the theoretical volume of water in both with and without the wetdryfix.  </p> <p>For comparison the current Dev branch has 100.19% of the theoretical volume. While this is somehow better it does not really undermine the new branch (i.e. the dev branch might get closer to the theory for the wrong raisons), the bugfixes and instability improvement of this branch are totally justified. </p> <p>results:</p> % of theoretical volume runtime Wetdry fix 100.48% 97s NO Wetdryfix 100.48% 96s"},{"location":"modules/Wetdryfix-Conservelevation/#tsumani-test-results","title":"Tsumani test results","text":"<p>The impact of the wet/dry fix should be much more obvious in tsunami simulation but here conserve elevation should be used in most tsunami cases.</p>"},{"location":"modules/Wetdryfix-Conservelevation/#no-wetdryfix","title":"No wetdryfix","text":"<p>switching off the wetdryfix causes instability that really have an impact on tsunami wave. Here the instability are clearly visible in the map and in the comparison are seen as 0.01 m waves before the tsunami wave arrive.</p> <p></p>"},{"location":"modules/Wetdryfix-Conservelevation/#wetdryfix","title":"Wetdryfix","text":"<p>When using the wetdryfix the instabilities disappear and the solution is smoother.</p> <p></p>"},{"location":"modules/Wetdryfix-Conservelevation/#comparison-wetdryfix-vs-no-wetdryfix","title":"Comparison Wetdryfix vs no Wetdryfix","text":"<p>The instabilities are more obvious when we look at a transect diagonally from the plot above. These instabilities have a notable affect the height of the tsunami wave... a lot! This justifies that we should have the wetdryfix switched on by default.</p> <p></p>"},{"location":"modules/Wetdryfix-Conservelevation/#conserve-elevation_1","title":"Conserve Elevation","text":"<p>When running tsunami/storm surge simulation without rivers or rain then the conserve elevation should be switched on. This doesn't make a considerable impact on the tsunami wave (see transect above the red and blue line are indistinguishable) I'm not sure why the difference is so small but there is a difference. Below is the difference between the wetdryfix and conservelevation routine. it produces a difference of O(10-5).</p> <p></p>"},{"location":"tools/Compile-under-linux/","title":"Compile under linux","text":"<p>@page Compile-under-linux Compilation on Linux</p> <p>Make sure you have latest CUDA Toolkit, g++ and NetCDF libraries installed.</p> <pre><code>sudo apt-get install nvidia-cuda-dev\nsudo apt-get install g++\nsudo apt-get install libnetcdf-dev\n</code></pre> <p>Also make sure the GPU driver being used is the Nvidia driver!</p> <p>Do a quick comand line test to see if nvcc (CUDA compiler) is available from here. If not, You may need to modify the cuda path in the makefile (line 155) </p><pre><code>NVCC          := nvcc -ccbin $(HOST_COMPILER)\n</code></pre> <p>The code can compile for multiple GPU architecture but later compiler do not support old GPU (2.0 is no longer supported) Remove unsupported architecture in line 213 of the makefile</p> <p>Then just type  <code>{.bash}  make</code></p> <p>Many warning will show up but that is OK.</p>"},{"location":"tools/Use-On-SuperComputer/","title":"Use On SuperComputer","text":"<p>@page Use-On-SuperComputer Use on SuperComputer</p> <p>The code can be run on local machines with NVIDIA GPU but it will get better performance by running on large GPU.</p> <p>The code is actually running on New Zealand eScience Infrastructure (NeSI).</p>"},{"location":"tools/Use-On-SuperComputer/#compiling-the-code","title":"Compiling the code","text":"<p>The Code needs to be compile on the machine, using the sources grom the github repository. Due to the code dependency to CUDA and netCDF, two modules need to be loaded: * On Maui:  <code>{bash}  module load CUDA\\11.4.1 module load netCDF-C++4/4.3.0-GCC-7.1.0</code> * On Mahuika:  <code>{bash} module load CUDA/11.4.1 module load netCDF-C++4/4.3.1-gimpi-2020a</code></p>"},{"location":"tools/Use-On-SuperComputer/#running-the-code","title":"Running the code","text":"<ul> <li> <p>Example of a slurm file on Maui: </p><pre><code>#!/bin/bash\n#SBATCH --job-name=MY-TEST-NAME\n#SBATCH --time=8:00:00\n#SBATCH --account=MY-NESI-ACCOUNT\n#SBATCH --partition=nesi_gpu\n#SBATCH --gres=gpu\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=2\n#SBATCH --mem=5GB\n\n#Running directory (to be completed)\nBGFLOOD=/nesi/project/XXXXXXXXXXXXXXX\n\ncd ${BGFLOOD}\n\nmodule load CUDA/11.4.1\nmodule load netCDF-C++4/4.3.0-GCC-7.1.0\n\n# Launching the executable\nsrun ./BG_Flood_Maui\n\necho \"output_file = Output/${testname}/BGoutput-${reftime}.nc\"\n\necho \"end of setup_run_BG.sh\"\n</code></pre> </li> <li> <p>Example of a slurm file on Mahuika: </p><pre><code>#!/bin/bash\n#SBATCH --job-name=MY-TEST-NAME\n#SBATCH --time=05:00:00\n#SBATCH --account=MY-NESI-ACCOUNT\n#SBATCH --gpus-per-node=1\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=1\n#SBATCH --mem=1GB\n\n#Running directory (to be completed)\nBGFLOOD=/nesi/project/XXXXXXXXXXXXXXX\n\ncd ${BGFLOOD}\n\n#module load netCDF-C++4/4.3.0-gimkl-2017a\nmodule load netCDF-C++4/4.3.1-gimpi-2020a\nmodule load CUDA/11.4.1\n\n# Launching the executable\nsrun ./BG_Flood_Mahuika\n\necho \"output_file = Output/${testname}/BGoutput-${reftime}.nc\"\n\necho \"end of setup_run_BG.sh\"\n</code></pre> </li> </ul>"},{"location":"tutorial/Gaussian_Wave_Julia/","title":"Gaussian wave","text":""},{"location":"tutorial/Gaussian_Wave_Julia/#gaussian-wave","title":"Gaussian Wave","text":"<p>This is a great example to test whether there are bugs in the model and how the boundary work.</p>"},{"location":"tutorial/Gaussian_Wave_Julia/#bathymetry","title":"Bathymetry","text":"<p>We start with a flat bathymetry with 0.0 everywhere. You still need a file for that!</p> <p>Here a couple of suggestion on making the file:</p> <ul> <li>Using GMT: <pre><code>grdmath -R-5/5/-5/5 -I0.03921 0 MUL = bathy.nc\n</code></pre></li> </ul> <p>Using Julia: See section below with the hotstart file.</p> <p>In any case you can pick up the file in the example folder.</p>"},{"location":"tutorial/Gaussian_Wave_Julia/#hortstart","title":"Hortstart","text":"<p>We want to setup a bump in the water level centered in the middle of the bathy. IN the example below this is done using Julia, but it should be easily done in Matlab or Python. Note that the script below also generates a bathymetry file.</p> <pre><code>    using GMT\n\n    xo=-5;\n    yo=-5;\n\n    nx=16*16;\n    ny=16*16;\n\n    len=10.0;\n\n    dx=len/(nx-1);\n\n    xx=collect(xo:len/(nx-1):(len+xo));\n    yy=collect(yo:len/(ny-1):(len+yo));\n\n    # Make a bathy file\n    zb=zeros(nx,ny);\n    G = mat2grid(transpose(zb), 1,[xx[1] xx[end] yy[1] yy[end] minimum(zb) maximum(zb) 1 dx dx])\n    gmtwrite(\"bathy.asc\", G; id=\"ef\");\n\n    #make the hotstart file\n    hh=zeros(nx,ny);\n    for i=1:nx\n        for j=1:ny\n            hh[i,j] = 1.0.+ 1.0.*exp.(-1.0*(xx[i].*xx[i] .+ yy[j].*yy[j]));\n            #hh[i,j] =\n        end\n    end\n\n    G = mat2grid(transpose(hh), 1,[xx[1] xx[end] yy[1] yy[end] minimum(hh) maximum(hh) 1 dx dx])\n    cmap = grd2cpt(G);      # Compute a colormap with the grid's data range\n    grdimage(G, lw=:thinnest, color=cmap, fmt=:png, show=true)\n\n    gmtwrite(\"gauss.asc\", G; id=\"ef\");\n    gmtwrite(\"gauss.nc\", G);\n    # GMT netcdf variable is \"z\" by default but the hotstart file needs \"zs\" for water surface\n    gmt(\"grdmath gauss.nc 1.0 MUL = gauss_zs.nc?zs\");\n</code></pre>"},{"location":"tutorial/Gaussian_Wave_Julia/#make-bnd-files","title":"Make Bnd files","text":"<p>We are going to set the water level to 0.0m on all 4 sides and keep it constant. To do that we create 1 files <code>zero.txt</code>: </p><pre><code>    # This is the a boundary\n    0.0 0.0\n    3600.0 0.0\n</code></pre>"},{"location":"tutorial/Gaussian_Wave_Julia/#set-up-the-bg_paramtxt-file","title":"Set up the <code>BG_param.txt</code> file","text":"<p>First it is good practice to document your parameter file: </p>BG_param.txt<pre><code>    ##############################\n    ## Gaussian bump demo\n    # CB 04/05/2019\n</code></pre> Then specify the bathymetry file to use. We will use the entire domain and resolution of the file so no need for other parameter for specifying the domain. <pre><code>    bathy=bathy.asc\n</code></pre> This is a relatively small model so we can force the netcdf variable to be saved as floats. <pre><code>    smallnc=0\n</code></pre> Specify the hotstart file: <pre><code>    hotstartfile=gauss_zs.nc;\n</code></pre> Boundary conditions are all the same : <pre><code>    right = 3; # Absorbing bnd\n    rightbndfile = zeros.txt\n\n    top = 3; # Absorbing bnd\n    topbndfile = zeros.txt\n\n    bot = 3; # Absorbing bnd\n    botbndfile = zeros.txt\n\n    left=3; # Absorbing bnd\n    leftbndfile=zeros.txt\n</code></pre> Time keeping: <pre><code>    endtime=20;\n    outtimestep=1;\n</code></pre> Output parameters: <pre><code>    # Netcdf file for snapshot of the model domain\n    outfile=Gauss_demo.nc\n    outvars=zb,uu,vv,zs,vort;\n\n    # Outpout a single txt file with all the model steps at the nearest node to location x=0.0, y=-4.0\n    # This file will contain 5 column: time,zs,hh,uu,vv\n    TSOfile=Southside.txt;\n    TSnode=0.0,-4.0;\n</code></pre>"},{"location":"tutorial/Gaussian_Wave_Julia/#run-the-model","title":"Run the model","text":"<p>Plot Southside.txt in your favorite tool.</p>"},{"location":"tutorial/Gaussian_Wave_Julia/#things-to-try","title":"Things to try","text":"<ul> <li>What happens with different boundary types</li> <li>Try running with double precision. What is the difference?</li> </ul>"},{"location":"tutorial/RainMap_Aureli2020/","title":"RainMap Aureli2020","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\nfrom matplotlib.patches import Rectangle\nfrom scipy import interpolate\nfrom scipy.interpolate import LinearNDInterpolator\nfrom subprocess import Popen, PIPE\n\nimport xarray as xr\nimport os\nimport shutil\nfrom netCDF4 import Dataset\nimport netCDF4 as nc4\nimport utm\n\n## Read text file given its name (and path), number of columns, number of header lines\ndef readCSV_Ncol(name,n_col,n_pass):\n    X=[]\n    for i in range(n_col):\n        X.append([])\n\n    f=open(name,'r')\n    n_line=0\n    for line in f.readlines():\n        if n_line&lt;n_pass:\n            n_line = n_line+1\n        else:\n            sline=line.split(',')\n            for i in range(n_col):\n                X[i].append(float(sline[i]))\n    f.close()\n    return(X)\n</pre> import numpy as np import matplotlib.pyplot as plt from matplotlib.colors import ListedColormap from matplotlib.patches import Rectangle from scipy import interpolate from scipy.interpolate import LinearNDInterpolator from subprocess import Popen, PIPE  import xarray as xr import os import shutil from netCDF4 import Dataset import netCDF4 as nc4 import utm  ## Read text file given its name (and path), number of columns, number of header lines def readCSV_Ncol(name,n_col,n_pass):     X=[]     for i in range(n_col):         X.append([])      f=open(name,'r')     n_line=0     for line in f.readlines():         if n_line In\u00a0[2]: Copied! <pre>myDir='auto_Aureli2020_RainMap2'\n\ncodeDir = r\"C:\\Users\\haranga\\BG-Flood\\Test_Cases_Alice\\CodeDir\"\nexecDir = r\"C:\\Users\\haranga\\BG-Flood\\VS_BG-flood\\BG_flood\\x64\\Release\"\n\nif not os.path.isdir (myDir):\n    os.mkdir(myDir)\nos.chdir(myDir)\nMyDir = os.getcwd()\nMyDir\n</pre> myDir='auto_Aureli2020_RainMap2'  codeDir = r\"C:\\Users\\haranga\\BG-Flood\\Test_Cases_Alice\\CodeDir\" execDir = r\"C:\\Users\\haranga\\BG-Flood\\VS_BG-flood\\BG_flood\\x64\\Release\"  if not os.path.isdir (myDir):     os.mkdir(myDir) os.chdir(myDir) MyDir = os.getcwd() MyDir Out[2]: <pre>'C:\\\\Users\\\\haranga\\\\BG-Flood\\\\Test_Cases_Alice\\\\auto_Aureli2020_RainMap2'</pre> In\u00a0[3]: Copied! <pre>xo=0\nyo=0\nxf_min=28.0\nyf=0.196\nny = 16\ndx=(yf-yo)/ny\ny=np.linspace(yo, yf, ny);\nxf=xo + (16*dx) * np.ceil((xf_min - xo) / (16*dx));\nnx=int((xf-xo)/dx)\nx=np.linspace(xo, xf, nx);\ndx\n</pre> xo=0 yo=0 xf_min=28.0 yf=0.196 ny = 16 dx=(yf-yo)/ny y=np.linspace(yo, yf, ny); xf=xo + (16*dx) * np.ceil((xf_min - xo) / (16*dx)); nx=int((xf-xo)/dx) x=np.linspace(xo, xf, nx); dx Out[3]: <pre>0.01225</pre> In\u00a0[4]: Copied! <pre>xi=5.0;\nyi=1.52/2;\nslope_d=8;\nbase_r=0.75/2;\ntop_r=0.05/2;\nhi=0.049;\n\nz= np.zeros((ny,nx))\n\nfor i in range(nx):\n    for j in range (ny):\n        if x[i]&lt;8:\n            z[j,i] = 0.2 + (8.0 - x[i]) * 2.0 / 100.0\n        elif x[i]&lt;16:\n            z[j,i] = 0.08 + (16.0 - x[i]) * 1.5 / 100.0\n        else:\n            z[j,i] = 0.0 + (24.0 - x[i]) * 1.0 / 100.0\n</pre> xi=5.0; yi=1.52/2; slope_d=8; base_r=0.75/2; top_r=0.05/2; hi=0.049;  z= np.zeros((ny,nx))  for i in range(nx):     for j in range (ny):         if x[i]&lt;8:             z[j,i] = 0.2 + (8.0 - x[i]) * 2.0 / 100.0         elif x[i]&lt;16:             z[j,i] = 0.08 + (16.0 - x[i]) * 1.5 / 100.0         else:             z[j,i] = 0.0 + (24.0 - x[i]) * 1.0 / 100.0 In\u00a0[5]: Copied! <pre>Zinit = z[0,np.where(x&gt;27)[0]][0]\nZinit\n</pre> Zinit = z[0,np.where(x&gt;27)[0]][0] Zinit Out[5]: <pre>-0.03010805421950156</pre> In\u00a0[6]: Copied! <pre>X,Y = np.meshgrid(x,y)\nplt.pcolormesh(X,Y,z, shading='auto')\nplt.colorbar()\nplt.xlabel(\"x(m)\")\nplt.ylabel(\"y(m)\")\nplt.savefig('bathymetry.png')\nfig1=plt.gcf()\nplt.show()\n</pre> X,Y = np.meshgrid(x,y) plt.pcolormesh(X,Y,z, shading='auto') plt.colorbar() plt.xlabel(\"x(m)\") plt.ylabel(\"y(m)\") plt.savefig('bathymetry.png') fig1=plt.gcf() plt.show() In\u00a0[7]: Copied! <pre>plt.plot(x,z[1,:],'-')\nplt.xlabel(\"x(m)\")\nplt.ylabel(\"z(m)\")\nplt.show()\n</pre> plt.plot(x,z[1,:],'-') plt.xlabel(\"x(m)\") plt.ylabel(\"z(m)\") plt.show() <p>Saving it in a netcdf file</p> In\u00a0[8]: Copied! <pre>ds = xr.Dataset(\n      {\"z\": ((\"y\", \"x\"), z)},\n      coords={\n          \"x\": x,\n          \"y\": y,\n      },\n  )\n\nds.to_netcdf(\"bathy.nc\")\n</pre> ds = xr.Dataset(       {\"z\": ((\"y\", \"x\"), z)},       coords={           \"x\": x,           \"y\": y,       },   )  ds.to_netcdf(\"bathy.nc\") In\u00a0[9]: Copied! <pre>#Tr=[0.0,10.0,10.0001,20.0]; #Rain duration of 10s\n#not working yet\n\nTr=np.linspace(0.0, 80.0, 801);\n\n\nRz = [3888, 2296.8, 2880]; #mm/hr\n#Rz = [3888, 3888, 3888]; #mm/hr : for uniform rain test\n\n\nr= np.zeros((len(Tr),ny,nx))\nfor tt in range(len(Tr)):\n    for i in range(nx):\n        for j in range (ny):\n            if Tr[tt]&lt;=10.0:\n                if x[i]&lt;8:\n                    r[tt,j,i] = Rz[0]\n                elif x[i]&lt;16:\n                    r[tt,j,i] = Rz[1]\n                else:\n                    r[tt,j,i] = Rz[2]\n            else:\n                r[tt,j,i] = 0.0\n\nds = xr.Dataset(\n      {\"rain\": ((\"t\",\"y\", \"x\"), r)},\n      coords={\n          \"x\": x,\n          \"y\": y,\n          \"t\": Tr,\n      },\n  )\nds.to_netcdf(\"rain_forcing.nc\")                \n\nX,Y = np.meshgrid(x,y)\nplt.pcolormesh(X,Y,r[1,:,:], shading='auto')\nplt.colorbar()\nplt.xlabel(\"x(m)\")\nplt.ylabel(\"y(m)\")\nplt.title(\"Rain forcing (mm/h)\")\nplt.savefig('rain_forcing.png')\nfig1=plt.gcf()\nplt.show()\n</pre> #Tr=[0.0,10.0,10.0001,20.0]; #Rain duration of 10s #not working yet  Tr=np.linspace(0.0, 80.0, 801);   Rz = [3888, 2296.8, 2880]; #mm/hr #Rz = [3888, 3888, 3888]; #mm/hr : for uniform rain test   r= np.zeros((len(Tr),ny,nx)) for tt in range(len(Tr)):     for i in range(nx):         for j in range (ny):             if Tr[tt]&lt;=10.0:                 if x[i]&lt;8:                     r[tt,j,i] = Rz[0]                 elif x[i]&lt;16:                     r[tt,j,i] = Rz[1]                 else:                     r[tt,j,i] = Rz[2]             else:                 r[tt,j,i] = 0.0  ds = xr.Dataset(       {\"rain\": ((\"t\",\"y\", \"x\"), r)},       coords={           \"x\": x,           \"y\": y,           \"t\": Tr,       },   ) ds.to_netcdf(\"rain_forcing.nc\")                  X,Y = np.meshgrid(x,y) plt.pcolormesh(X,Y,r[1,:,:], shading='auto') plt.colorbar() plt.xlabel(\"x(m)\") plt.ylabel(\"y(m)\") plt.title(\"Rain forcing (mm/h)\") plt.savefig('rain_forcing.png') fig1=plt.gcf() plt.show() In\u00a0[10]: Copied! <pre>key=[]\nvalue=[]\n</pre> key=[] value=[] <ul> <li>name of the bathymetry file (and variable name associated to altitude (here z) if the format is netCDF)</li> </ul> In\u00a0[40]: Copied! <pre>key.append('topofile')\nvalue.append('bathy.nc?z')\n</pre> key.append('topofile') value.append('bathy.nc?z') <ul> <li>Timekeeping parameters<ul> <li>\"totaltime\"  : Start time for the simulation</li> <li>\"endtime\" : End of simulation (in s)</li> </ul> </li> </ul> In\u00a0[41]: Copied! <pre>key.append('totaltime')\nvalue.append(Tr[0])\nkey.append('endtime')\nvalue.append(Tr[-1])\n</pre> key.append('totaltime') value.append(Tr[0]) key.append('endtime') value.append(Tr[-1]) <ul> <li>Resolution of the simulation (by default, the resolution of the bathy/topo file is used)</li> </ul> In\u00a0[42]: Copied! <pre>#key.append('dx')\n#value.append('0.005')\n</pre> #key.append('dx') #value.append('0.005') <ul> <li>Choice of the GPU/CPU mode (-1 if no GPU else 0 for GPU, by default) and precison of the model</li> </ul> In\u00a0[43]: Copied! <pre>#key.append('gpudevice')\n#value.append(0)\nkey.append('doubleprecision')\nvalue.append('1')\n</pre> #key.append('gpudevice') #value.append(0) key.append('doubleprecision') value.append('1') <ul> <li>Flow and models parameters<ul> <li>\"frictionmodel\": bottom friction model (-1: Manning model, 0:, 1: Smart model (default, REF))</li> <li>\"cf\": friction coefficient</li> <li>\"eps\": minimum water elevation</li> <li>\"theta\": minmod limiter that can be used to tune the momentum dissipation (theta=1 gives minmod, the most dissipative limiter and theta = 2 gives superbee, the least dissipative) (by default 1.3).</li> </ul> </li> </ul> In\u00a0[44]: Copied! <pre>key.append('frictionmodel')\nvalue.append('-1')\nkey.append('cf')\nvalue.append('0.009')\n#key.append('eps')\n#value.append('0.00000100')\nkey.append('theta')\nvalue.append('1.14')\n</pre> key.append('frictionmodel') value.append('-1') key.append('cf') value.append('0.009') #key.append('eps') #value.append('0.00000100') key.append('theta') value.append('1.14') <ul> <li>Boundaries condition</li> </ul> <p>Boundaries are refered by their position, using \"top/bottom/right/left\" keywords. They are associated to a boundary type ( 0:wall; 1: Neumann (Default); 2:Dirichlet (zs); 3: abs1d) and possibly a file containing a time serie. In this case, the file name is placed before the type, coma-separated. Here, the by-default Neumann type boundary conditions are conserved, but on the left side (top of the slope), where we impose a wall boundary condition.</p> In\u00a0[45]: Copied! <pre>key.append('left')\nvalue.append('0')\n</pre> key.append('left') value.append('0') <ul> <li>Exterior forcings</li> </ul> <p>Different forcinds are available (river, rain, atmospherique pressure...). In this example, we will use the rain forcing. This can be a time serie in a text file if the forcing is uniform on all the domain (like in this case) or a netcdf file if the forcing is space dependent (and time dependent).</p> In\u00a0[46]: Copied! <pre>key.append('rainfile')\nvalue.append('rain_forcing.nc?rain')\n</pre> key.append('rainfile') value.append('rain_forcing.nc?rain') <ul> <li>Initial conditions<ul> <li>\"zinit\" : initial water level</li> </ul> </li> </ul> In\u00a0[47]: Copied! <pre>key.append('zsinit')\nvalue.append(Zinit)\n</pre> key.append('zsinit') value.append(Zinit) <ul> <li>Outputs The code can output 2D map of 2D fields in netCDF format and time series of water elevation (not used here).<ul> <li>\"outputtimestep\" : Time step for 2D fields outputs</li> <li>\"smallnc\": to scaled and saved 2D fields as a short integer if 1 (default value)</li> <li>\"outvars\": to choose the variable to output (by default:hh, uu, vv, zb, zs)</li> </ul> </li> </ul> In\u00a0[48]: Copied! <pre>key.append('outputtimestep')\nvalue.append('0.2')\nkey.append('smallnc')\nvalue.append('0')\nkey.append('outvars')\nvalue.append('zs,h,u,v,zb,hmax,zsmax')\nkey.append('outfile')\nvalue.append('output.nc')\n</pre> key.append('outputtimestep') value.append('0.2') key.append('smallnc') value.append('0') key.append('outvars') value.append('zs,h,u,v,zb,hmax,zsmax') key.append('outfile') value.append('output.nc') In\u00a0[49]: Copied! <pre>key\n</pre> key Out[49]: <pre>['topofile',\n 'totaltime',\n 'endtime',\n 'doubleprecision',\n 'frictionmodel',\n 'cf',\n 'theta',\n 'left',\n 'rainfile',\n 'zsinit',\n 'outputtimestep',\n 'smallnc',\n 'outvars',\n 'outfile']</pre> In\u00a0[50]: Copied! <pre>value\n</pre> value Out[50]: <pre>['bathy.nc?z',\n 0.0,\n 80.0,\n '1',\n '-1',\n '0.009',\n '1.14',\n '0',\n 'rain_forcing.nc?rain',\n -0.03010805421950156,\n '0.2',\n '0',\n 'zs,h,u,v,zb,hmax,zsmax',\n 'output.nc']</pre> <p>These data are then saved in a BG_Param.txt file.</p> In\u00a0[22]: Copied! <pre>data = np.column_stack([key, value])\ndatafile_path = \"BG_param.txt\"\nnp.savetxt(datafile_path , data, fmt=['%s ',' %s ;'], delimiter='=')\n</pre> data = np.column_stack([key, value]) datafile_path = \"BG_param.txt\" np.savetxt(datafile_path , data, fmt=['%s ',' %s ;'], delimiter='=') In\u00a0[23]: Copied! <pre>myFiles=[f for f in os.listdir(codeDir) if f.endswith(\".dll\")]\n#myFiles.append('BG_flood.exe')\nfor f in myFiles:\n    origin=os.path.join(codeDir,f)\n    destination=os.path.join(MyDir,f)\n    shutil.copy(origin, destination)\n</pre> myFiles=[f for f in os.listdir(codeDir) if f.endswith(\".dll\")] #myFiles.append('BG_flood.exe') for f in myFiles:     origin=os.path.join(codeDir,f)     destination=os.path.join(MyDir,f)     shutil.copy(origin, destination) In\u00a0[24]: Copied! <pre>BG_cmd=os.path.join(execDir,'BG_flood.exe')\ndestination=os.path.join(MyDir,'BG_flood.exe')\n\ntry:\n    shutil.copy(BG_cmd, destination)\n    print(\"File copied successfully.\")\n \n# If source and destination are same\nexcept shutil.SameFileError:\n    print(\"Source and destination represents the same file.\")\n \n# If there is any permission issue\nexcept PermissionError:\n    print(\"Permission denied.\")\n \n# For other errors\nexcept:\n    print(\"Error occurred while copying file.\")\n</pre> BG_cmd=os.path.join(execDir,'BG_flood.exe') destination=os.path.join(MyDir,'BG_flood.exe')  try:     shutil.copy(BG_cmd, destination)     print(\"File copied successfully.\")   # If source and destination are same except shutil.SameFileError:     print(\"Source and destination represents the same file.\")   # If there is any permission issue except PermissionError:     print(\"Permission denied.\")   # For other errors except:     print(\"Error occurred while copying file.\")  <pre>File copied successfully.\n</pre> <p>Launch of the code</p> In\u00a0[25]: Copied! <pre>#os.system('BG_flood.exe &gt;&gt; BG_out.txt')\n</pre> #os.system('BG_flood.exe &gt;&gt; BG_out.txt') In\u00a0[11]: Copied! <pre>n_Manning=[0.004,0.0045,0.005,0.006,0.007,0.009,0.0095,0.01,0.0105];\n\nfor n in n_Manning:\n    strName='n' + str(n)[2:] \n    \n    #Modify the BG_param file\n    value[key.index('cf')] = n;\n    value[key.index('outfile')]='Output_' + strName + '.nc'\n\n    #Save it\n    data = np.column_stack([key, value])\n    datafile_path = 'BG_param_' + strName + '.txt'\n    np.savetxt(datafile_path , data, fmt=['%s ',' %s ;'], delimiter='=')\n    \n    #run BG_Flood for the appropriate BG_param file\n    shutil.copy(datafile_path,'BG_param.txt')\n    #process=Popen('BG_flood.exe', stdout=PIPE, stderr=PIPE)\n    #stdout, stderr = process.communicate()\n</pre> n_Manning=[0.004,0.0045,0.005,0.006,0.007,0.009,0.0095,0.01,0.0105];  for n in n_Manning:     strName='n' + str(n)[2:]           #Modify the BG_param file     value[key.index('cf')] = n;     value[key.index('outfile')]='Output_' + strName + '.nc'      #Save it     data = np.column_stack([key, value])     datafile_path = 'BG_param_' + strName + '.txt'     np.savetxt(datafile_path , data, fmt=['%s ',' %s ;'], delimiter='=')          #run BG_Flood for the appropriate BG_param file     shutil.copy(datafile_path,'BG_param.txt')     #process=Popen('BG_flood.exe', stdout=PIPE, stderr=PIPE)     #stdout, stderr = process.communicate() <pre>---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n~\\AppData\\Local\\Temp/ipykernel_15172/1980761473.py in &lt;module&gt;\n      5 \n      6     #Modify the BG_param file\n----&gt; 7     value[key.index('cf')] = n;\n      8     value[key.index('outfile')]='Output_' + strName + '.nc'\n      9 \n\nValueError: 'cf' is not in list</pre> <p>$$ F_{out}(t) = \\sum \\limits _{C_s} h \\,  v \\, dx$$</p> <p>This will be calculated at each steps where the 2D fields have been outputted in the netCDF file.</p> In\u00a0[12]: Copied! <pre>#[t10,t10,t20,f20,t30,f30]=readCSV_Ncol('Iwagaki_Data_3slopes.csv',6,2)\n[t10,f10]=readCSV_Ncol('Iwagaki1955_t_10s.csv',2,0)\n[tm10,fm10]=readCSV_Ncol('Iwagaki1955_theo_t_10s.csv',2,0)\nax1=plt.subplot(1,1,1)\nP1,=ax1.plot(t10,f10,'o', label='Experiment')\nP1,=ax1.plot(tm10,fm10,'o', label='model')\nax1.set_ylabel('Flux ($cm^3$/s)')\nax1.set_xlabel('Time ($s$)')\n</pre> #[t10,t10,t20,f20,t30,f30]=readCSV_Ncol('Iwagaki_Data_3slopes.csv',6,2) [t10,f10]=readCSV_Ncol('Iwagaki1955_t_10s.csv',2,0) [tm10,fm10]=readCSV_Ncol('Iwagaki1955_theo_t_10s.csv',2,0) ax1=plt.subplot(1,1,1) P1,=ax1.plot(t10,f10,'o', label='Experiment') P1,=ax1.plot(tm10,fm10,'o', label='model') ax1.set_ylabel('Flux ($cm^3$/s)') ax1.set_xlabel('Time ($s$)')  Out[12]: <pre>Text(0.5, 0, 'Time ($s$)')</pre> In\u00a0[13]: Copied! <pre>D=[]\nfor n in n_Manning:\n    strName='n' + str(n)[2:] \n    fn = 'Output_' + strName + '.nc'\n    D.append(nc4.Dataset(fn))\n</pre> D=[] for n in n_Manning:     strName='n' + str(n)[2:]      fn = 'Output_' + strName + '.nc'     D.append(nc4.Dataset(fn)) In\u00a0[14]: Copied! <pre>D[2]\n</pre> D[2] Out[14]: <pre>&lt;class 'netCDF4._netCDF4.Dataset'&gt;\nroot group (NETCDF4 data model, file format HDF5):\n    maxlevel: 0\n    minlevel: 0\n    xmin: -0.006127678181023175\n    xmax: 28.034127678181026\n    ymin: -0.006127678181023175\n    ymax: 0.18995802361171843\n    dimensions(sizes): time(401), blockid(143), xx_P0(2288), yy_P0(16)\n    variables(dimensions): float32 time(time), int32 blockid(blockid), float32 blockxo(blockid), float32 blockyo(blockid), float32 blockwidth(blockid), int32 blocklevel(blockid), int32 blockstatus(blockid), float64 xx_P0(xx_P0), float64 yy_P0(yy_P0), float32 zs_P0(time, yy_P0, xx_P0), float32 h_P0(time, yy_P0, xx_P0), float32 u_P0(time, yy_P0, xx_P0), float32 v_P0(time, yy_P0, xx_P0), float32 zb_P0(time, yy_P0, xx_P0), float32 hmax_P0(time, yy_P0, xx_P0), float32 zsmax_P0(time, yy_P0, xx_P0)\n    groups: </pre> In\u00a0[15]: Copied! <pre>x_flux = 24\n\nstrName=[]\nfor n in n_Manning:\n    strName.append('n' + str(n)[2:])\n            \nPP=[]\nax=plt.subplot(1,1,1)\n\nP1,=ax.plot(t10,f10,'o', label='Experiment')\nP2,=ax.plot(tm10,fm10,'o', label='model')\nPP.append(P1)\nPP.append(P2)\n\nfor n in [5,6,7,8]:#range(len(n_Manning)):\n    \n    xx=D[n]['xx_P0'][:]\n    yy=D[n]['yy_P0'][:]\n    tt=D[n]['time'][:]\n    hh=D[n]['h_P0'][:,:,:]\n    uu=D[n]['u_P0'][:]\n    vv=D[n]['v_P0'][:]\n    dx=xx[1]-xx[0]\n    \n    #find x-position nearest to the reference x=24m\n    I=0\n    dist_min=10^9\n    for i in range(len(xx)):\n        if abs(xx[i]-x_flux)&lt;dist_min:\n            I=i\n            dist_min=abs(xx[i]-x_flux)\n\n    \n    F=[]\n    for k in range(len(tt)):\n        ft=0;\n        for j in range(len(yy)):\n            ft=ft+hh[k,j,I]*uu[k,j,I]*dx\n        F.append(ft)\n\n    #Change also units from m to cm\n    Fnorm=[]\n    Fpaper=[]\n    for k in range(len(tt)):\n        Fnorm.append(F[k]/(yy[-1]-yy[0])*100*100)\n        Fpaper.append(F[k]/(yy[-1]-yy[0])*0.197*100*100)\n\n    P='P' + str(n+2)\n    P,=plt.plot(tt,Fnorm,'-', label=strName[n])\n    PP.append(P)\n    \nplt.legend(handles=PP)\nplt.title('Flux at the output of the domain')\nplt.ylabel('Flux ($cm^3$/s)')\nplt.xlabel('Time (s)')\n\n    \n    \n\n#xx=ds['xx_P0'][:]\n#yy=ds['yy_P0'][:]\n#tt=ds['time'][:]\n#hh=ds['h_P0'][:,:,:]\n#uu=ds['u_P0'][:]\n#vv=ds['v_P0'][:]\n#dx=xx[1]-xx[0]\n\n#find x-position nearest to the reference x=24m\n#I=0\n#dist_min=10^9\n#for i in range(len(xx)):\n#    if abs(xx[i]-x_flux)&lt;dist_min:\n#        I=i\n#        dist_min=abs(xx[i]-x_flux)\n\n    \n#F=[]\n#for k in range(len(tt)):\n#    ft=0;\n#    for j in range(len(yy)):\n#        ft=ft+hh[k,j,I]*uu[k,j,I]*dx\n#    F.append(ft)\n</pre>  x_flux = 24  strName=[] for n in n_Manning:     strName.append('n' + str(n)[2:])              PP=[] ax=plt.subplot(1,1,1)  P1,=ax.plot(t10,f10,'o', label='Experiment') P2,=ax.plot(tm10,fm10,'o', label='model') PP.append(P1) PP.append(P2)  for n in [5,6,7,8]:#range(len(n_Manning)):          xx=D[n]['xx_P0'][:]     yy=D[n]['yy_P0'][:]     tt=D[n]['time'][:]     hh=D[n]['h_P0'][:,:,:]     uu=D[n]['u_P0'][:]     vv=D[n]['v_P0'][:]     dx=xx[1]-xx[0]          #find x-position nearest to the reference x=24m     I=0     dist_min=10^9     for i in range(len(xx)):         if abs(xx[i]-x_flux) Out[15]: <pre>Text(0.5, 0, 'Time (s)')</pre> In\u00a0[18]: Copied! <pre># version simplifiee du plot precedent:\n\nx_flux = 24\n\nstrName=[]\nfor n in n_Manning:\n    strName.append('n' + str(n)[2:])\n            \nPP=[]\nax=plt.subplot(1,1,1)\n\nP1,=ax.plot(t10,f10,'o', label='Experiment')\nP2,=ax.plot(tm10,fm10,'-', label='Aureli2020')\nPP.append(P1)\nPP.append(P2)\n\nfor n in [8]:#range(len(n_Manning)):\n    \n    xx=D[n]['xx_P0'][:]\n    yy=D[n]['yy_P0'][:]\n    tt=D[n]['time'][:]\n    hh=D[n]['h_P0'][:,:,:]\n    uu=D[n]['u_P0'][:]\n    vv=D[n]['v_P0'][:]\n    dx=xx[1]-xx[0]\n    \n    #find x-position nearest to the reference x=24m\n    I=0\n    dist_min=10^9\n    for i in range(len(xx)):\n        if abs(xx[i]-x_flux)&lt;dist_min:\n            I=i\n            dist_min=abs(xx[i]-x_flux)\n\n    \n    F=[]\n    for k in range(len(tt)):\n        ft=0;\n        for j in range(len(yy)):\n            ft=ft+hh[k,j,I]*uu[k,j,I]*dx\n        F.append(ft)\n\n    #Change also units from m to cm\n    Fnorm=[]\n    Fpaper=[]\n    for k in range(len(tt)):\n        Fnorm.append(F[k]/(yy[-1]-yy[0])*100*100)\n        Fpaper.append(F[k]/(yy[-1]-yy[0])*0.197*100*100)\n\n    P='P' + str(n+2)\n    P,=plt.plot(tt,Fnorm,'-', label='BG_Flood')\n    PP.append(P)\n    \nplt.legend(handles=PP)\nplt.title('Flux at the output of the domain')\nplt.ylabel('Flux ($cm^3$/s)')\nplt.xlabel('Time (s)')\n</pre> # version simplifiee du plot precedent:  x_flux = 24  strName=[] for n in n_Manning:     strName.append('n' + str(n)[2:])              PP=[] ax=plt.subplot(1,1,1)  P1,=ax.plot(t10,f10,'o', label='Experiment') P2,=ax.plot(tm10,fm10,'-', label='Aureli2020') PP.append(P1) PP.append(P2)  for n in [8]:#range(len(n_Manning)):          xx=D[n]['xx_P0'][:]     yy=D[n]['yy_P0'][:]     tt=D[n]['time'][:]     hh=D[n]['h_P0'][:,:,:]     uu=D[n]['u_P0'][:]     vv=D[n]['v_P0'][:]     dx=xx[1]-xx[0]          #find x-position nearest to the reference x=24m     I=0     dist_min=10^9     for i in range(len(xx)):         if abs(xx[i]-x_flux) Out[18]: <pre>Text(0.5, 0, 'Time (s)')</pre> yy[-1]-yy[0]#Change also units from m to cm Fnorm=[] Fpaper=[] for k in range(len(tt)):     #Fnorm.append(F[k]*10*100)     Fnorm.append(F[k]/(yy[-1]-yy[0])*100*100)     Fpaper.append(F[k]/(yy[-1]-yy[0])*0.197*100*100) ax1=plt.subplot(1,1,1) P1,=ax1.plot(t10,f10,'o', label='Experiment') P2,=ax1.plot(tm10,fm10,'o', label='model') ax1.set_ylabel('Flux ($cm^3$/s)') ax1.set_xlabel('Time ($s$)') P3,=ax1.plot(tt,Fnorm,'.-', label='BG_flood for n=0.005') plt.legend(handles=[P1, P2, P3]) ax1.set_title('Flux at the output of the domain')  In\u00a0[55]: Copied! <pre>cd ..\n</pre> cd .. <pre>C:\\Users\\haranga\\BG-Flood\\Test_Cases_Alice\\auto_Aureli2020_RainMap2\n</pre> In\u00a0[74]: Copied! <pre>n_Manning=[0.009,0.01];\ntheta=[1.1,1.2,1.3,1.4,2.0];\n</pre> n_Manning=[0.009,0.01]; theta=[1.1,1.2,1.3,1.4,2.0]; In\u00a0[70]: Copied! <pre>for n in n_Manning:\n    for t in theta:\n        strName='n' + str(n)[2:] + '_theta' + str(t)[0] + '-' + str(t)[2:] \n    \n        #Modify the BG_param file\n        value[key.index('cf')] = n\n        value[key.index('theta')] = t\n        value[key.index('outfile')]='Output_' + strName + '.nc'\n\n        #Save it\n        data = np.column_stack([key, value])\n        datafile_path = 'BG_param_' + strName + '.txt'\n        np.savetxt(datafile_path , data, fmt=['%s ',' %s ;'], delimiter='=')\n    \n        #run BG_Flood for the appropriate BG_param file\n        shutil.copy(datafile_path,'BG_param.txt')\n        process=Popen('BG_flood.exe', stdout=PIPE, stderr=PIPE)\n        stdout, stderr = process.communicate()\n</pre> for n in n_Manning:     for t in theta:         strName='n' + str(n)[2:] + '_theta' + str(t)[0] + '-' + str(t)[2:]               #Modify the BG_param file         value[key.index('cf')] = n         value[key.index('theta')] = t         value[key.index('outfile')]='Output_' + strName + '.nc'          #Save it         data = np.column_stack([key, value])         datafile_path = 'BG_param_' + strName + '.txt'         np.savetxt(datafile_path , data, fmt=['%s ',' %s ;'], delimiter='=')              #run BG_Flood for the appropriate BG_param file         shutil.copy(datafile_path,'BG_param.txt')         process=Popen('BG_flood.exe', stdout=PIPE, stderr=PIPE)         stdout, stderr = process.communicate() In\u00a0[75]: Copied! <pre>D=[]\nfor n in n_Manning:\n    for t in theta:\n        strName='n' + str(n)[2:] + '_theta' + str(t)[0] + '-' + str(t)[2:] \n        fn = 'Output_' + strName + '.nc'\n        D.append(nc4.Dataset(fn))\n</pre> D=[] for n in n_Manning:     for t in theta:         strName='n' + str(n)[2:] + '_theta' + str(t)[0] + '-' + str(t)[2:]          fn = 'Output_' + strName + '.nc'         D.append(nc4.Dataset(fn)) In\u00a0[76]: Copied! <pre>strName\n</pre> strName  Out[76]: <pre>'n01_theta2-0'</pre> In\u00a0[77]: Copied! <pre>x_flux = 24\n\nstrName=[]\nfor n in n_Manning:\n    for t in theta:\n        strName.append('n' + str(n)[2:] + '_theta' + str(t)[0] + '-' + str(t)[2:])\n            \nPP=[]\nax=plt.subplot(1,1,1)\n\nP1,=ax.plot(t10,f10,'o', label='Experiment')\nP2,=ax.plot(tm10,fm10,'o', label='model')\nPP.append(P1)\nPP.append(P2)\n\nfor n in range(len(strName)):\n    \n    xx=D[n]['xx_P0'][:]\n    yy=D[n]['yy_P0'][:]\n    tt=D[n]['time'][:]\n    hh=D[n]['h_P0'][:,:,:]\n    uu=D[n]['u_P0'][:]\n    vv=D[n]['v_P0'][:]\n    dx=xx[1]-xx[0]\n    \n    #find x-position nearest to the reference x=24m\n    I=0\n    dist_min=10^9\n    for i in range(len(xx)):\n        if abs(xx[i]-x_flux)&lt;dist_min:\n            I=i\n            dist_min=abs(xx[i]-x_flux)\n\n    \n    F=[]\n    for k in range(len(tt)):\n        ft=0;\n        for j in range(len(yy)):\n            ft=ft+hh[k,j,I]*uu[k,j,I]*dx\n        F.append(ft)\n\n    #Change also units from m to cm\n    Fnorm=[]\n    Fpaper=[]\n    for k in range(len(tt)):\n        Fnorm.append(F[k]/(yy[-1]-yy[0])*100*100)\n        Fpaper.append(F[k]/(yy[-1]-yy[0])*0.197*100*100)\n\n    P='P' + str(n+2)\n    P,=plt.plot(tt,Fnorm,'-', label=strName[n])\n    PP.append(P)\n    \nplt.legend(handles=PP)\nplt.title('Flux at the output of the domain')\nplt.ylabel('Flux ($cm^3$/s)')\nplt.xlabel('Time (s)')\n</pre>  x_flux = 24  strName=[] for n in n_Manning:     for t in theta:         strName.append('n' + str(n)[2:] + '_theta' + str(t)[0] + '-' + str(t)[2:])              PP=[] ax=plt.subplot(1,1,1)  P1,=ax.plot(t10,f10,'o', label='Experiment') P2,=ax.plot(tm10,fm10,'o', label='model') PP.append(P1) PP.append(P2)  for n in range(len(strName)):          xx=D[n]['xx_P0'][:]     yy=D[n]['yy_P0'][:]     tt=D[n]['time'][:]     hh=D[n]['h_P0'][:,:,:]     uu=D[n]['u_P0'][:]     vv=D[n]['v_P0'][:]     dx=xx[1]-xx[0]          #find x-position nearest to the reference x=24m     I=0     dist_min=10^9     for i in range(len(xx)):         if abs(xx[i]-x_flux) Out[77]: <pre>Text(0.5, 0, 'Time (s)')</pre> In\u00a0[95]: Copied! <pre>ax1=plt.subplot(1,1,1)\nP1,=ax1.plot(t10,f10,'o', label='Experiment')\n\nT_out=np.linspace(3,30,10)\nObs_out=T_out\nObs_out=np.interp(T_out, t10, f10, left=0.0);\nP2,=ax1.plot(T_out,Obs_out,'o', label='interpolation')\nplt.legend(handles=[P1,P2])\nObs_out\n</pre> ax1=plt.subplot(1,1,1) P1,=ax1.plot(t10,f10,'o', label='Experiment')  T_out=np.linspace(3,30,10) Obs_out=T_out Obs_out=np.interp(T_out, t10, f10, left=0.0); P2,=ax1.plot(T_out,Obs_out,'o', label='interpolation') plt.legend(handles=[P1,P2]) Obs_out Out[95]: <pre>array([ 1.75136262,  4.31856716, 24.36350225, 32.02235696, 32.41207121,\n       31.68632601, 29.8140878 , 47.9632521 , 68.78608061, 57.03656989])</pre> In\u00a0[98]: Copied! <pre>n=0.009\nt=1.3\nstrName='n' + str(n)[2:] + '_theta' + str(t)[0] + '-' + str(t)[2:]\nfn = 'Output_' + strName + '.nc'\nD=nc4.Dataset(fn)\n\nxx=D['xx_P0'][:]\nyy=D['yy_P0'][:]\ntt=D['time'][:]\nhh=D['h_P0'][:,:,:]\nuu=D['u_P0'][:]\nvv=D['v_P0'][:]\ndx=xx[1]-xx[0]\n    \n#find x-position nearest to the reference x=24m\nI=0\ndist_min=10^9\nfor i in range(len(xx)):\n    if abs(xx[i]-x_flux)&lt;dist_min:\n        I=i\n        dist_min=abs(xx[i]-x_flux)\n\n    \nF=[]\nfor k in range(len(tt)):\n    ft=0;\n    for j in range(len(yy)):\n        ft=ft+hh[k,j,I]*uu[k,j,I]*dx\n    F.append(ft)\n\n#Change also units from m to cm\nFnorm=[]\nfor k in range(len(tt)):\n    Fnorm.append(F[k]/(yy[-1]-yy[0])*100*100)\n\nRef_out=np.interp(T_out, tt, Fnorm);\n</pre> n=0.009 t=1.3 strName='n' + str(n)[2:] + '_theta' + str(t)[0] + '-' + str(t)[2:] fn = 'Output_' + strName + '.nc' D=nc4.Dataset(fn)  xx=D['xx_P0'][:] yy=D['yy_P0'][:] tt=D['time'][:] hh=D['h_P0'][:,:,:] uu=D['u_P0'][:] vv=D['v_P0'][:] dx=xx[1]-xx[0]      #find x-position nearest to the reference x=24m I=0 dist_min=10^9 for i in range(len(xx)):     if abs(xx[i]-x_flux) In\u00a0[100]: Copied! <pre>ax1=plt.subplot(1,1,1)\nP1,=ax1.plot(tt,Fnorm,'o', label='ref')\nP2,=ax1.plot(T_out,Ref_out,'o', label='interpolation')\nplt.legend(handles=[P1,P2])\nRef_out\n</pre> ax1=plt.subplot(1,1,1) P1,=ax1.plot(tt,Fnorm,'o', label='ref') P2,=ax1.plot(T_out,Ref_out,'o', label='interpolation') plt.legend(handles=[P1,P2]) Ref_out Out[100]: <pre>array([ 3.91529345, 13.25190688, 26.80124094, 35.66923489, 37.53384948,\n       36.48744275, 35.05542626, 33.29121321, 95.42833765, 62.4640137 ])</pre> In\u00a0[94]: Copied! <pre>T_out\n</pre> T_out Out[94]: <pre>array([ 3.,  6.,  9., 12., 15., 18., 21., 24., 27., 30.])</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorial/RainMap_Aureli2020/#rainmap-aureli2020","title":"RainMap Aureli2020\u00b6","text":"<p>This 2D rainfall runoff test is based on the paper of [Aureli, 2020]{https://www.mdpi.com/2073-4441/12/3/637}, which compare a numerical model against a laboratory experiment. This configuration consists in an inclined plane in 3 zones presenting different slopes and rain intensities. A constant friction is applied on the inclined plane. The outlet hydrograph is used for comparing models results against experiments mesurements. (from Aureli2020)</p>"},{"location":"tutorial/RainMap_Aureli2020/#pyton-set-up","title":"Pyton set-up\u00b6","text":"<p>########!pip install -r requierements.txt to automatically install the good libraries (or .yml file shared)</p>"},{"location":"tutorial/RainMap_Aureli2020/#preparation-of-the-bathymetry","title":"Preparation of the bathymetry\u00b6","text":"<p>The bathymetry is directly created using the description in the paper. We choose to have full blocks in both direction, so dx is forced to have exactly 22 blocks in the y direction. The x end of the model is then adjusted (a little further than the experiment set-up) to have full blocks too for square blocks and cells.</p>"},{"location":"tutorial/RainMap_Aureli2020/#creation-of-the-rain-forcing","title":"Creation of the rain forcing\u00b6","text":"<p>In this configuration, the code will be forced by a rain map which is spacially variable and also variable in time.</p>"},{"location":"tutorial/RainMap_Aureli2020/#writing-the-rain-forcing-file","title":"Writing the rain forcing file\u00b6","text":"<p>The boundary condition file will be defined by a time serie with a column for time, and on for millimeters of rain. The rain will last 10s and will be of 3888 mm/h on the top zone with a 2% slope, 2296.8 mm/h in the middle zone with a 1.5% slope and 2880 mm/h in the bottom zone with a 1% slope.</p> <p>Note: for the netcdf file, a regular grid is expected in the spacial space but not in the temporal one. (x should be regularly spaced but the dt may be not constant)</p>"},{"location":"tutorial/RainMap_Aureli2020/#writing-the-bg_params-file","title":"Writing the BG_Params file\u00b6","text":"<p>This text file is the main interface to BG_Flood. It contains a list of key words and associated values to modify the default flow and grid and time keeping parameters, boundary and external forcing, as well as output options and reference values. Different keys can be accepted for the same parameter. (See XXXXX for a detailled list of the input parameters). The minimum input is the bathymetry file. In this example, we will conserve a simple version of the BG_Params file where only the modified values will be listed:</p>"},{"location":"tutorial/RainMap_Aureli2020/#launching-the-code-bg_flood","title":"Launching the code BG_flood\u00b6","text":"<p>All the needed links to the libraries (.dll files) and the BG_flood executable are copied in the working folder. The</p>"},{"location":"tutorial/RainMap_Aureli2020/#comparaison-of-the-data-output-with-the-experimental-results","title":"Comparaison of the data output with the experimental results\u00b6","text":"<p>After identifying the position of the section at the end of the slope ($x=0.0$ m), we will calculate the flux through this section summing, through all the cells ($C_s$) at this location, the water elevation ($h$) times the velocity normal to the section ($v$):</p>"},{"location":"tutorial/RainMap_Aureli2020/#reading-the-benchmark-data","title":"Reading the benchmark data\u00b6","text":""},{"location":"tutorial/RainMap_Aureli2020/#experimental-data","title":"Experimental data\u00b6","text":"<p>The following data has been extracted from a picture of the paper Iwagaki1955, which created this experiment.</p>"},{"location":"tutorial/RainMap_Aureli2020/#reading-the-bg_flood-outputs","title":"Reading the BG_flood outputs\u00b6","text":""},{"location":"tutorial/RainMap_Aureli2020/#calculating-the-flux-at-the-output","title":"Calculating the flux at the output\u00b6","text":"<p>(Note: P0 in the output netCDF file refers to the refinement level.)</p> <p>We calculate the flux through all a section located in $x=24m$. The flux is then normalised by the width of the section and multiply by 0.194 to compare with the experimental results.</p>"},{"location":"tutorial/RainMap_Aureli2020/#evaluation-of-the-influence-of-theta-scheme-level","title":"Evaluation of the influence of theta (scheme level)\u00b6","text":""},{"location":"tutorial/RainMap_Aureli2020/#interpolation-of-observations-to-get-experiment-for-regular-times-steps","title":"Interpolation of observations to get experiment for regular times steps\u00b6","text":""},{"location":"tutorial/RainMap_Aureli2020/#using-values-from-the-experiment-no-longer-used","title":"Using values from the experiment (no longer used)\u00b6","text":""},{"location":"tutorial/RainMap_Aureli2020/#using-values-from-bg_flood-run-theta-13-default-and-manning-coef-0009","title":"Using values from BG_flood run (theta = 1.3 / default and Manning coef = 0.009 )\u00b6","text":""},{"location":"tutorial/Rain_CEA2008/","title":"Uniform rain on an idealised catchment","text":"<p>matplotlib-3.4.2 scipy-1.6.3 netCDF4-1.5.6 numpy-1.20.3 xarray-0.18.2 python-3.9.5</p> In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\nfrom matplotlib.patches import Rectangle\nfrom scipy import interpolate\nfrom scipy.interpolate import LinearNDInterpolator\n\nimport xarray as xr\nimport os\nimport shutil\nfrom netCDF4 import Dataset\nimport netCDF4 as nc4\nimport utm\n\n## Read text file given its name (and path), number of columns, number of header lines\ndef readCSV_Ncol(name,n_col,n_pass):\n    X=[]\n    for i in range(n_col):\n        X.append([])\n\n    f=open(name,'r')\n    n_line=0\n    for line in f.readlines():\n        if n_line&lt;n_pass:\n            n_line = n_line+1\n        else:\n            sline=line.split(',')\n            for i in range(n_col):\n                X[i].append(float(sline[i]))\n    f.close()\n    return(X)\n</pre> import numpy as np import matplotlib.pyplot as plt from matplotlib.colors import ListedColormap from matplotlib.patches import Rectangle from scipy import interpolate from scipy.interpolate import LinearNDInterpolator  import xarray as xr import os import shutil from netCDF4 import Dataset import netCDF4 as nc4 import utm  ## Read text file given its name (and path), number of columns, number of header lines def readCSV_Ncol(name,n_col,n_pass):     X=[]     for i in range(n_col):         X.append([])      f=open(name,'r')     n_line=0     for line in f.readlines():         if n_line In\u00a0[\u00a0]: Copied! <pre># Path to the folder containing the code executable\ncodeDir = r\".\\CodeDir\"\n# Creation (if needed) and access to the working directory\nif not os.path.isdir ('auto_CEA2008'):\n    os.mkdir('auto_CEA2008')\nos.chdir('auto_CEA2008')\nMyDir = os.getcwd()\n</pre> # Path to the folder containing the code executable codeDir = r\".\\CodeDir\" # Creation (if needed) and access to the working directory if not os.path.isdir ('auto_CEA2008'):     os.mkdir('auto_CEA2008') os.chdir('auto_CEA2008') MyDir = os.getcwd() In\u00a0[4]: Copied! <pre>grid=np.loadtxt('topo.asc',skiprows=6)\nx=np.linspace(0, len(grid[1,:])/100, len(grid[1,:])+1)\ny=np.linspace(0, len(grid[:,1])/100, len(grid[:,1])+1)\nplt.pcolor(x,y,grid, vmin=-0.1, vmax=0.1)\nplt.colorbar()\n</pre> grid=np.loadtxt('topo.asc',skiprows=6) x=np.linspace(0, len(grid[1,:])/100, len(grid[1,:])+1) y=np.linspace(0, len(grid[:,1])/100, len(grid[:,1])+1) plt.pcolor(x,y,grid, vmin=-0.1, vmax=0.1) plt.colorbar() Out[4]: <pre>&lt;matplotlib.colorbar.Colorbar at 0x294817b7d30&gt;</pre> In\u00a0[\u00a0]: Copied! <pre>Tr=[0.0,45.0,45.1,150.0]\nHr=[317.0,317.0,0.0,0.0]\nfilename = \"cstRain_forcing.txt\"\nf=open(filename,'w')\nfor i in range(len(Tr)):\n    f.write('%f \\t' % Tr[i])\n    f.write('%f \\n' % Hr[i])\nf.close()\n\nplt.plot(Tr,Hr,'.-')\nplt.title('Rain forcing')\nplt.ylabel('I (mm/h)')\nplt.xlabel('t(s)')\nplt.savefig('rain-forcing.png')\nplt.show()\n</pre> Tr=[0.0,45.0,45.1,150.0] Hr=[317.0,317.0,0.0,0.0] filename = \"cstRain_forcing.txt\" f=open(filename,'w') for i in range(len(Tr)):     f.write('%f \\t' % Tr[i])     f.write('%f \\n' % Hr[i]) f.close()  plt.plot(Tr,Hr,'.-') plt.title('Rain forcing') plt.ylabel('I (mm/h)') plt.xlabel('t(s)') plt.savefig('rain-forcing.png') plt.show() In\u00a0[6]: Copied! <pre>key=[]\nvalue=[]\n</pre> key=[] value=[] <ul> <li>name of the bathymetry file (variable name associated to altitude is also needed the format is netCDF (\"filename?variable\"))</li> </ul> In\u00a0[7]: Copied! <pre>key.append('topofile')\nvalue.append('topo.asc')\n</pre> key.append('topofile') value.append('topo.asc') <ul> <li>mask to remove parts of the domain with elevation over 0.1m</li> </ul> In\u00a0[8]: Copied! <pre>key.append('mask')\nvalue.append('0.1')\n</pre> key.append('mask') value.append('0.1') <ul> <li>Timekeeping parameters<ul> <li>\"inittime\"  : Start time for the simulation</li> <li>\"endtime\" : End of simulation (in s)</li> </ul> </li> </ul> In\u00a0[\u00a0]: Copied! <pre>key.append('inittime')\nvalue.append(Tr[0])\nkey.append('endtime')\nvalue.append(Tr[-1])\n</pre> key.append('inittime') value.append(Tr[0]) key.append('endtime') value.append(Tr[-1]) <ul> <li>Resolution of the simulation (by default, the resolution of the bathymetry or topography file is used)</li> </ul> In\u00a0[10]: Copied! <pre>key.append('dx')\nvalue.append('0.005')\n</pre> key.append('dx') value.append('0.005') <ul> <li>Choice of the GPU/CPU mode (-1 if no GPU else 0 for GPU, by default if present on the computer) and precison of the model</li> </ul> In\u00a0[11]: Copied! <pre>#key.append('gpudevice')\n#value.append(0)\nkey.append('doubleprecision')\nvalue.append('1')\n</pre> #key.append('gpudevice') #value.append(0) key.append('doubleprecision') value.append('1') <ul> <li>Flow and models parameters<ul> <li>\"frictionmodel\": bottom friction model (-1: Manning model, 0:, 1: Smart model (default))</li> <li>\"cf\": friction coefficient</li> <li>\"eps\": minimum water elevation</li> <li>\"theta\": minmod limiter that can be used to tune the momentum dissipation (theta=1 gives minmod, the most dissipative limiter and theta = 2 gives superbee, the least dissipative) (by default 1.3).</li> </ul> </li> </ul> In\u00a0[12]: Copied! <pre>key.append('frictionmdel')\nvalue.append('1')\nkey.append('cf')\nvalue.append('0.000004')\nkey.append('eps')\nvalue.append('0.00000100')\nkey.append('theta')\nvalue.append('1.14')\n</pre> key.append('frictionmdel') value.append('1') key.append('cf') value.append('0.000004') key.append('eps') value.append('0.00000100') key.append('theta') value.append('1.14') <ul> <li>Boundaries condition</li> </ul> <p>Boundaries are refered by their position, using \"top/bottom/right/left\" keywords. They are associated to a boundary type ( 0:wall; 1: Neumann (Default); 2:Dirichlet (zs); 3: abs1d) and possibly a file containing a time serie. In this case, the file name is placed before the type, coma-separated. Here, the by default Neumann type boundary conditions are conserved.</p> <ul> <li>Exterior forcings</li> </ul> <p>Different forcings are available (river, rain, atmospherique pressure...). In this example, we will use the rain forcing. This can be a time serie in a text file if the forcing is uniform on all the domain (like in this case) or a netcdf file if the forcing is space dependent (and time dependent).</p> In\u00a0[13]: Copied! <pre>key.append('rainfile')\nvalue.append('cstRain_forcing.txt')\n</pre> key.append('rainfile') value.append('cstRain_forcing.txt') <ul> <li>Initial conditions<ul> <li>\"zinit\" : initial water level</li> </ul> </li> </ul> In\u00a0[14]: Copied! <pre>key.append('zsinit')\nvalue.append('-0.5')\n</pre> key.append('zsinit') value.append('-0.5') <ul> <li><p>Outputs:</p> <p>The code can output 2D map of 2D time-varying fields in netCDF format and time series at a point location (not used here).</p> <ul> <li>\"outputtimestep\" : Time step for 2D fields outputs</li> <li>\"smallnc\": to scaled and saved 2D fields as a short integer if 1 (default value)</li> <li>\"outvars\": to choose the variable to output (by default: $hh$, $uu$, $vv$, $zb$, $zs$)</li> </ul> </li> </ul> In\u00a0[15]: Copied! <pre>key.append('outputtimestep')\nvalue.append('1.0')\nkey.append('smallnc')\nvalue.append('0')\nkey.append('outvars')\nvalue.append('zs,h,u,v,zb,hmax,zsmax')\n</pre> key.append('outputtimestep') value.append('1.0') key.append('smallnc') value.append('0') key.append('outvars') value.append('zs,h,u,v,zb,hmax,zsmax') In\u00a0[16]: Copied! <pre>key\n</pre> key Out[16]: <pre>['topofile',\n 'mask',\n 'totaltime',\n 'endtime',\n 'dx',\n 'doubleprecision',\n 'frictionmdel',\n 'cf',\n 'eps',\n 'theta',\n 'rainfile',\n 'zsinit',\n 'outputtimestep',\n 'smallnc',\n 'outvars']</pre> In\u00a0[17]: Copied! <pre>value\n</pre> value Out[17]: <pre>['topo.asc',\n '0.1',\n 0.0,\n 60.0,\n '0.005',\n '1',\n '1',\n '0.000004',\n '0.00000100',\n '1.14',\n 'cstRain_forcing.txt',\n '-0.5',\n '1.0',\n '0',\n 'zs,h,u,v,zb,hmax,zsmax']</pre> <p>These data are then saved in a BG_Param.txt file.</p> In\u00a0[18]: Copied! <pre>data = np.column_stack([key, value])\ndatafile_path = \"BG_param.txt\"\nnp.savetxt(datafile_path , data, fmt=['%s ',' %s ;'], delimiter='=')\n</pre> data = np.column_stack([key, value]) datafile_path = \"BG_param.txt\" np.savetxt(datafile_path , data, fmt=['%s ',' %s ;'], delimiter='=') In\u00a0[43]: Copied! <pre>myFiles=[f for f in os.listdir(codeDir) if f.endswith(\".dll\")]\nmyFiles.append('BG_flood.exe')\nfor f in myFiles:\n    origin=os.path.join(codeDir,f)\n    destination=os.path.join(MyDir,f)\n    shutil.copy(origin, destination) \n</pre> myFiles=[f for f in os.listdir(codeDir) if f.endswith(\".dll\")] myFiles.append('BG_flood.exe') for f in myFiles:     origin=os.path.join(codeDir,f)     destination=os.path.join(MyDir,f)     shutil.copy(origin, destination)  In\u00a0[\u00a0]: Copied! <pre>os.system('BG_flood.exe &gt;&gt; BG_out.txt')\n</pre> os.system('BG_flood.exe &gt;&gt; BG_out.txt') <p>$$ F_{out}(t) = \\sum \\limits _{C_s} h \\,  v \\, dx$$</p> <p>This will be calculated at each steps where the 2D fields have been outputted in the netCDF file.</p> In\u00a0[21]: Copied! <pre>[xC1,yC1,xC3,yC3]=readCSV_Ncol('CEA_C1-C3_datasets.csv',4,2)\n</pre> [xC1,yC1,xC3,yC3]=readCSV_Ncol('CEA_C1-C3_datasets.csv',4,2) In\u00a0[31]: Copied! <pre>fn = 'Output_50.nc'\nds = nc4.Dataset(fn)\nds\n</pre> fn = 'Output_50.nc' ds = nc4.Dataset(fn) ds Out[31]: <pre>&lt;class 'netCDF4._netCDF4.Dataset'&gt;\nroot group (NETCDF4 data model, file format HDF5):\n    maxlevel: 0\n    minlevel: 0\n    xmin: -0.005\n    xmax: 2.075\n    ymin: -0.005\n    ymax: 2.555\n    dimensions(sizes): time(61), blockid(832), xx_P0(416), yy_P0(512)\n    variables(dimensions): float32 time(time), int32 blockid(blockid), float32 blockxo(blockid), float32 blockyo(blockid), float32 blockwidth(blockid), int32 blocklevel(blockid), int32 blockstatus(blockid), float64 xx_P0(xx_P0), float64 yy_P0(yy_P0), float32 zb_P0(time, yy_P0, xx_P0), float32 zs_P0(time, yy_P0, xx_P0), float32 u_P0(time, yy_P0, xx_P0), float32 v_P0(time, yy_P0, xx_P0), float32 h_P0(time, yy_P0, xx_P0)\n    groups: </pre> In\u00a0[33]: Copied! <pre>xx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzs=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\n\nF=[]\nfor k in range(len(tt)):\n    ft=0;\n    for i in range(len(xx)):\n        for j in range(len(yy)):\n            if xx[i]&gt;0.5 and xx[i]&lt;1.5:\n                if abs(yy[j]-0.1)&lt;dy/2:\n                    ft=ft+hh[k,j,i]*vv[k,j,i]*dy\n    F.append(-ft)\n                    \nplt.plot(tt,F,'.-')\nplt.title('Flux at the output of the domain')\nplt.ylabel('Flux ($m^3$/s)')\nplt.xlabel('Time (s)')\n</pre> xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zs=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0]  F=[] for k in range(len(tt)):     ft=0;     for i in range(len(xx)):         for j in range(len(yy)):             if xx[i]&gt;0.5 and xx[i]&lt;1.5:                 if abs(yy[j]-0.1) Out[33]: <pre>Text(0.5, 0, 'Time (s)')</pre> In\u00a0[34]: Copied! <pre>plt.pcolormesh(xx,yy,hh[50,:,:]-hh[0,:,:], shading='auto')\n#plt.plot(xx[200],yy[50],'o')\n#plt.plot(xx[200],yy[250],'o')\n#plt.plot(xx[200],yy[400],'o')\nplt.title('Water elevation in the idealized catchment')\nplt.colorbar()\n</pre> plt.pcolormesh(xx,yy,hh[50,:,:]-hh[0,:,:], shading='auto') #plt.plot(xx[200],yy[50],'o') #plt.plot(xx[200],yy[250],'o') #plt.plot(xx[200],yy[400],'o') plt.title('Water elevation in the idealized catchment') plt.colorbar() Out[34]: <pre>&lt;matplotlib.colorbar.Colorbar at 0x2610a346a30&gt;</pre> In\u00a0[9]: Copied! <pre>plt.pcolormesh(xx,yy,hh[50,:,:], shading='auto', vmax=0.0)\nplt.plot(xx[200],yy[50],'o')\nplt.plot(xx[200],yy[250],'o')\nplt.plot(xx[200],yy[400],'o')\nplt.colorbar()\n</pre> plt.pcolormesh(xx,yy,hh[50,:,:], shading='auto', vmax=0.0) plt.plot(xx[200],yy[50],'o') plt.plot(xx[200],yy[250],'o') plt.plot(xx[200],yy[400],'o') plt.colorbar() Out[9]: <pre>&lt;matplotlib.colorbar.Colorbar at 0x294804e0d90&gt;</pre> In\u00a0[10]: Copied! <pre>plt.plot(tt, hh[:,50,200],'o')\nplt.plot(tt, hh[:,250,200],'d')\nplt.plot(tt, hh[:,400,200])\n</pre> plt.plot(tt, hh[:,50,200],'o') plt.plot(tt, hh[:,250,200],'d') plt.plot(tt, hh[:,400,200])  Out[10]: <pre>[&lt;matplotlib.lines.Line2D at 0x29483215eb0&gt;]</pre> In\u00a0[11]: Copied! <pre>ax=plt.subplot(1,1,1)\nP1,=ax.plot(tt, zb[:,250,200],'o', label='zb')\nP2,=ax.plot(tt, zs[:,250,200],'d', label='zs')\nplt.legend(handles=[P1, P2])\nax.set_ylabel('z(m)')\nplt.xlabel('time(s)')\nplt.title('Time evolution of the surface elevation compare to the bottom elevation');\n</pre> ax=plt.subplot(1,1,1) P1,=ax.plot(tt, zb[:,250,200],'o', label='zb') P2,=ax.plot(tt, zs[:,250,200],'d', label='zs') plt.legend(handles=[P1, P2]) ax.set_ylabel('z(m)') plt.xlabel('time(s)') plt.title('Time evolution of the surface elevation compare to the bottom elevation'); In\u00a0[12]: Copied! <pre>fn = 'Output_55.nc'\nds = nc4.Dataset(fn)\nds\nxx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzsk=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\n</pre> fn = 'Output_55.nc' ds = nc4.Dataset(fn) ds xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zsk=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0] In\u00a0[13]: Copied! <pre>fn = 'Output_56.nc'\nds = nc4.Dataset(fn)\nds\nxx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzsb=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\n\nax=plt.subplot(1,1,1)\nP1,=ax.plot(tt, zb[:,250,200],'o', label='zb')\nP2,=ax.plot(tt, zsk[:,250,200],'s', label='zs using Kurgonov')\nP3,=ax.plot(tt, zsb[:,250,200],'d', label='zs using Buttinger')\nplt.legend(handles=[P1, P2, P3])\nax.set_ylabel('z(m)')\nplt.xlabel('time(s)')\nplt.title('Time evolution of the surface elevation compare to the bottom elevation');\n</pre> fn = 'Output_56.nc' ds = nc4.Dataset(fn) ds xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zsb=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0]  ax=plt.subplot(1,1,1) P1,=ax.plot(tt, zb[:,250,200],'o', label='zb') P2,=ax.plot(tt, zsk[:,250,200],'s', label='zs using Kurgonov') P3,=ax.plot(tt, zsb[:,250,200],'d', label='zs using Buttinger') plt.legend(handles=[P1, P2, P3]) ax.set_ylabel('z(m)') plt.xlabel('time(s)') plt.title('Time evolution of the surface elevation compare to the bottom elevation'); In\u00a0[14]: Copied! <pre>fn = 'Output_59.nc'\nds = nc4.Dataset(fn)\nds\nxx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzsf=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\n\nax=plt.subplot(1,1,1)\nP1,=ax.plot(tt, zb[:,250,200],'o', label='zb')\nP2,=ax.plot(tt, zsk[:,250,200],'s', label='zs using Kurgonov')\nP3,=ax.plot(tt, zsb[:,250,200],'d', label='zs using Buttinger')\nP4,=ax.plot(tt, zsf[:,250,200],'.', label='zs using Buttinger after fix')\nplt.legend(handles=[P1, P2, P3, P4])\nax.set_ylabel('z(m)')\nplt.xlabel('time(s)')\nplt.title('Time evolution of the surface elevation compare to the bottom elevation');\n</pre> fn = 'Output_59.nc' ds = nc4.Dataset(fn) ds xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zsf=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0]  ax=plt.subplot(1,1,1) P1,=ax.plot(tt, zb[:,250,200],'o', label='zb') P2,=ax.plot(tt, zsk[:,250,200],'s', label='zs using Kurgonov') P3,=ax.plot(tt, zsb[:,250,200],'d', label='zs using Buttinger') P4,=ax.plot(tt, zsf[:,250,200],'.', label='zs using Buttinger after fix') plt.legend(handles=[P1, P2, P3, P4]) ax.set_ylabel('z(m)') plt.xlabel('time(s)') plt.title('Time evolution of the surface elevation compare to the bottom elevation'); In\u00a0[15]: Copied! <pre>fn = 'Output_ButtingerC1.nc'\nds = nc4.Dataset(fn)\nds\nxx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzsf=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\ndx=xx[1]-xx[0]\n\nF_b=[]\nfor k in range(len(tt)):\n    ft=0;\n    for i in range(len(xx)):\n        for j in range(len(yy)):\n            if xx[i]&gt;0.5 and xx[i]&lt;1.5:\n                if abs(yy[j]-0.1)&lt;dy/2:\n                    ft=ft+hh[k,j,i]*vv[k,j,i]*dx\n    F_b.append(-ft)\n</pre> fn = 'Output_ButtingerC1.nc' ds = nc4.Dataset(fn) ds xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zsf=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0] dx=xx[1]-xx[0]  F_b=[] for k in range(len(tt)):     ft=0;     for i in range(len(xx)):         for j in range(len(yy)):             if xx[i]&gt;0.5 and xx[i]&lt;1.5:                 if abs(yy[j]-0.1) In\u00a0[20]: Copied! <pre>fn = 'Output_KurgonovC1.nc'\nds = nc4.Dataset(fn)\nds\nxx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzsf=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\ndx=xx[1]-xx[0]\n\nF_k=[]\nfor k in range(len(tt)):\n    ft=0;\n    LL=0\n    for i in range(len(xx)):\n        for j in range(len(yy)):\n            if xx[i]&gt;0.5 and xx[i]&lt;1.5:\n                if abs(yy[j]-0.1)&lt;dy/2:\n                    LL=LL+dx\n                    ft=ft+hh[k,j,i]*vv[k,j,i]*dx\n    F_k.append(-ft)\n</pre> fn = 'Output_KurgonovC1.nc' ds = nc4.Dataset(fn) ds xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zsf=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0] dx=xx[1]-xx[0]  F_k=[] for k in range(len(tt)):     ft=0;     LL=0     for i in range(len(xx)):         for j in range(len(yy)):             if xx[i]&gt;0.5 and xx[i]&lt;1.5:                 if abs(yy[j]-0.1) In\u00a0[17]: Copied! <pre>ax1=plt.subplot(1,1,1)\nP1,=ax1.plot(xC1,yC1,'o', label='Experiment')\nP2,=ax1.plot(tt, F_k,'.-', label='zs using Kurganov')\nP3,=ax1.plot(tt, F_b,'.-', label='zs using Buttinger')\nax1.set_ylabel('Flux ($m^3$/s)')\nax1.set_xlim([0.0, 150.0])\nax1.set_ylim([0.0, 0.0005])\nax2=ax1.twinx()\nax2.fill_between(Tr, Hr,alpha=0.1, color='blue', label='Rain forcing')\nax2.set_ylabel('P (mm/h)')\nax2.set_ylim([0.0, 500])\n#ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500))\nhandles, labels = ax2.get_legend_handles_labels()\nhandles.append(P1)\nhandles.append(P2)\nhandles.append(P3)\nplt.legend(handles=handles)\nplt.xlabel('Time(s)')\nplt.title('Time evolution of the flux at the output of the domain, C1');\n</pre> ax1=plt.subplot(1,1,1) P1,=ax1.plot(xC1,yC1,'o', label='Experiment') P2,=ax1.plot(tt, F_k,'.-', label='zs using Kurganov') P3,=ax1.plot(tt, F_b,'.-', label='zs using Buttinger') ax1.set_ylabel('Flux ($m^3$/s)') ax1.set_xlim([0.0, 150.0]) ax1.set_ylim([0.0, 0.0005]) ax2=ax1.twinx() ax2.fill_between(Tr, Hr,alpha=0.1, color='blue', label='Rain forcing') ax2.set_ylabel('P (mm/h)') ax2.set_ylim([0.0, 500]) #ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500)) handles, labels = ax2.get_legend_handles_labels() handles.append(P1) handles.append(P2) handles.append(P3) plt.legend(handles=handles) plt.xlabel('Time(s)') plt.title('Time evolution of the flux at the output of the domain, C1'); In\u00a0[23]: Copied! <pre>Tr3=[0.0,25.0,25.0001,31.99999,32.0,57.0,57.1,150.0]\nHr3=[328.0,328.0,0.0,0.0,328.0,328.0,0.0,0.0]\nfilename = \"cstRain_forcingC3.txt\"\nf=open(filename,'w')\nfor i in range(len(Tr3)):\n    f.write('%f \\t' % Tr3[i])\n    f.write('%f \\n' % Hr3[i])\nf.close()\n\nplt.plot(Tr3,Hr3,'.-')\nplt.title('Rain forcing for test case 3')\nplt.ylabel('h(mm)')\nplt.xlabel('t(s)')\nplt.savefig('rain-forcing_C3.png')\nplt.show()\n</pre> Tr3=[0.0,25.0,25.0001,31.99999,32.0,57.0,57.1,150.0] Hr3=[328.0,328.0,0.0,0.0,328.0,328.0,0.0,0.0] filename = \"cstRain_forcingC3.txt\" f=open(filename,'w') for i in range(len(Tr3)):     f.write('%f \\t' % Tr3[i])     f.write('%f \\n' % Hr3[i]) f.close()  plt.plot(Tr3,Hr3,'.-') plt.title('Rain forcing for test case 3') plt.ylabel('h(mm)') plt.xlabel('t(s)') plt.savefig('rain-forcing_C3.png') plt.show() In\u00a0[\u00a0]: Copied! <pre>#For Kurgonov\n    #Modify the BG_param file\n    value[key.index('outfile')] = 'Output_KurgonovC3.nc'\n    value[key.index('rain')] = filename\n\n    \n    #Save it\n    data = np.column_stack([key, value])\n    datafile_path = 'BG_param_K3.txt'\n    np.savetxt(datafile_path , data, fmt=['%s ',' %s ;'], delimiter='=')\n    \n\n    #run BG_Flood for the appropriate Parameters file\n    shutil.copy(datafile_path,'BG_param.txt')\n    process=Popen('BG_flood_Kur.exe',stdout=PIPE, stderr=PIPE)\n    stdout, stderr = process.communicate()\n    \n#For Buttinger\n    #Modify the BG_param file\n    value[key.index('outfile')] = 'Output_ButtingerC3.nc'\n\n    \n    #Save it\n    data = np.column_stack([key, value])\n    datafile_path = 'BG_param_B3.txt'\n    np.savetxt(datafile_path , data, fmt=['%s ',' %s ;'], delimiter='=')\n    \n\n    #run BG_Flood for the appropriate Parameters file\n    shutil.copy(datafile_path,'BG_param.txt')\n    process=Popen('BG_flood_But.exe',stdout=PIPE, stderr=PIPE)\n    stdout, stderr = process.communicate()\n      \n</pre> #For Kurgonov     #Modify the BG_param file     value[key.index('outfile')] = 'Output_KurgonovC3.nc'     value[key.index('rain')] = filename           #Save it     data = np.column_stack([key, value])     datafile_path = 'BG_param_K3.txt'     np.savetxt(datafile_path , data, fmt=['%s ',' %s ;'], delimiter='=')           #run BG_Flood for the appropriate Parameters file     shutil.copy(datafile_path,'BG_param.txt')     process=Popen('BG_flood_Kur.exe',stdout=PIPE, stderr=PIPE)     stdout, stderr = process.communicate()      #For Buttinger     #Modify the BG_param file     value[key.index('outfile')] = 'Output_ButtingerC3.nc'           #Save it     data = np.column_stack([key, value])     datafile_path = 'BG_param_B3.txt'     np.savetxt(datafile_path , data, fmt=['%s ',' %s ;'], delimiter='=')           #run BG_Flood for the appropriate Parameters file     shutil.copy(datafile_path,'BG_param.txt')     process=Popen('BG_flood_But.exe',stdout=PIPE, stderr=PIPE)     stdout, stderr = process.communicate()        <pre>  File \"&lt;ipython-input-19-84f3ecb6676b&gt;\", line 3\n    value[key.index('outfile')] = 'Output_KurgonovC3.nc'\n    ^\nIndentationError: unexpected indent\n</pre> In\u00a0[20]: Copied! <pre>fn = 'Output_ButtingerC3.nc'\nds = nc4.Dataset(fn)\nds\nxx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzsf=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\ndx=xx[1]-xx[0]\n\nF_b3=[]\nfor k in range(len(tt)):\n    ft=0;\n    for i in range(len(xx)):\n        for j in range(len(yy)):\n            if xx[i]&gt;0.5 and xx[i]&lt;1.5:\n                if abs(yy[j]-0.1)&lt;dy/2:\n                    ft=ft+hh[k,j,i]*vv[k,j,i]*dx\n    F_b3.append(-ft)\n</pre> fn = 'Output_ButtingerC3.nc' ds = nc4.Dataset(fn) ds xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zsf=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0] dx=xx[1]-xx[0]  F_b3=[] for k in range(len(tt)):     ft=0;     for i in range(len(xx)):         for j in range(len(yy)):             if xx[i]&gt;0.5 and xx[i]&lt;1.5:                 if abs(yy[j]-0.1) In\u00a0[22]: Copied! <pre>fn = 'Output_KurgonovC3.nc'\nds = nc4.Dataset(fn)\nds\nxx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzsf=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\n\nF_k3=[]\nfor k in range(len(tt)):\n    ft=0;\n    for i in range(len(xx)):\n        for j in range(len(yy)):\n            if xx[i]&gt;0.5 and xx[i]&lt;1.5:\n                if abs(yy[j]-0.1)&lt;dy/2:\n                    ft=ft+hh[k,j,i]*vv[k,j,i]*dx\n    F_k3.append(-ft)\n</pre> fn = 'Output_KurgonovC3.nc' ds = nc4.Dataset(fn) ds xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zsf=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0]  F_k3=[] for k in range(len(tt)):     ft=0;     for i in range(len(xx)):         for j in range(len(yy)):             if xx[i]&gt;0.5 and xx[i]&lt;1.5:                 if abs(yy[j]-0.1) In\u00a0[23]: Copied! <pre>ax=plt.subplot(1,1,1)\nP1,=ax.plot(xC3,yC3,'o', label='Experiment')\nP2,=ax.plot(tt, F_k3,'.-', label='zs using Kurganov')\nP3,=ax.plot(tt, F_b3,'.-', label='zs using Buttinger')\nax2=ax.twinx()\nax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing')\nax.set_ylabel('Flux ($m^3$/s)')\nax.set_xlim([0.0, 150.0])\nax.set_ylim([0.0, 0.0005])\nax2.set_ylabel('P (mm/h)')\nax2.set_ylim([0.0, 500])\nplt.xlabel('Time(s)')\nhandles, labels = ax2.get_legend_handles_labels()\nhandles.append(P1)\nhandles.append(P2)\nhandles.append(P3)\nplt.legend(handles=handles)\nplt.title('Time evolution of the flux at the output of the domain, C3');\n</pre> ax=plt.subplot(1,1,1) P1,=ax.plot(xC3,yC3,'o', label='Experiment') P2,=ax.plot(tt, F_k3,'.-', label='zs using Kurganov') P3,=ax.plot(tt, F_b3,'.-', label='zs using Buttinger') ax2=ax.twinx() ax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing') ax.set_ylabel('Flux ($m^3$/s)') ax.set_xlim([0.0, 150.0]) ax.set_ylim([0.0, 0.0005]) ax2.set_ylabel('P (mm/h)') ax2.set_ylim([0.0, 500]) plt.xlabel('Time(s)') handles, labels = ax2.get_legend_handles_labels() handles.append(P1) handles.append(P2) handles.append(P3) plt.legend(handles=handles) plt.title('Time evolution of the flux at the output of the domain, C3'); In\u00a0[29]: Copied! <pre>ax=plt.subplot(1,1,1)\nP1,=ax.plot(xC3,yC3,'o', label='Experiment')\n#P2,=ax.plot(tt, F_k3,'.-', label='zs using Kurganov')\nP3,=ax.plot(tt, F_b3,'.-', label='BG_Flood')\nax2=ax.twinx()\nax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing')\nax.set_ylabel('Flux ($m^3$/s)')\nax.set_xlim([0.0, 150.0])\nax.set_ylim([0.0, 0.0005])\nax2.set_ylabel('P (mm/h)')\nax2.set_ylim([0.0, 500])\nplt.xlabel('Time(s)')\nhandles, labels = ax2.get_legend_handles_labels()\nhandles.append(P1)\n#handles.append(P2)\nhandles.append(P3)\nplt.legend(handles=handles)\nplt.title('Time evolution of the flux at the output of the domain, C3');\n</pre> ax=plt.subplot(1,1,1) P1,=ax.plot(xC3,yC3,'o', label='Experiment') #P2,=ax.plot(tt, F_k3,'.-', label='zs using Kurganov') P3,=ax.plot(tt, F_b3,'.-', label='BG_Flood') ax2=ax.twinx() ax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing') ax.set_ylabel('Flux ($m^3$/s)') ax.set_xlim([0.0, 150.0]) ax.set_ylim([0.0, 0.0005]) ax2.set_ylabel('P (mm/h)') ax2.set_ylim([0.0, 500]) plt.xlabel('Time(s)') handles, labels = ax2.get_legend_handles_labels() handles.append(P1) #handles.append(P2) handles.append(P3) plt.legend(handles=handles) plt.title('Time evolution of the flux at the output of the domain, C3'); In\u00a0[24]: Copied! <pre>fn = 'Output_But-XiaC1.nc'\nds = nc4.Dataset(fn)\nds\nxx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzsf=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\ndx=xx[1]-xx[0]\n\nF_bx1=[]\nfor k in range(len(tt)):\n    ft=0;\n    for i in range(len(xx)):\n        for j in range(len(yy)):\n            if xx[i]&gt;0.5 and xx[i]&lt;1.5:\n                if abs(yy[j]-0.1)&lt;dy/2:\n                    ft=ft+hh[k,j,i]*vv[k,j,i]*dx\n    F_bx1.append(-ft)\n</pre> fn = 'Output_But-XiaC1.nc' ds = nc4.Dataset(fn) ds xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zsf=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0] dx=xx[1]-xx[0]  F_bx1=[] for k in range(len(tt)):     ft=0;     for i in range(len(xx)):         for j in range(len(yy)):             if xx[i]&gt;0.5 and xx[i]&lt;1.5:                 if abs(yy[j]-0.1) In\u00a0[25]: Copied! <pre>fn = 'Output_But-XiaC3.nc'\nds = nc4.Dataset(fn)\nds\nxx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzsf=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\ndx=xx[1]-xx[0]\n\nF_bx3=[]\nfor k in range(len(tt)):\n    ft=0;\n    for i in range(len(xx)):\n        for j in range(len(yy)):\n            if xx[i]&gt;0.5 and xx[i]&lt;1.5:\n                if abs(yy[j]-0.1)&lt;dy/2:\n                    ft=ft+hh[k,j,i]*vv[k,j,i]*dx\n    F_bx3.append(-ft)\n</pre> fn = 'Output_But-XiaC3.nc' ds = nc4.Dataset(fn) ds xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zsf=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0] dx=xx[1]-xx[0]  F_bx3=[] for k in range(len(tt)):     ft=0;     for i in range(len(xx)):         for j in range(len(yy)):             if xx[i]&gt;0.5 and xx[i]&lt;1.5:                 if abs(yy[j]-0.1) In\u00a0[26]: Copied! <pre>fn = 'Output_Kur-XiaC1.nc'\nds = nc4.Dataset(fn)\nds\nxx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzsf=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\ndx=xx[1]-xx[0]\n\nF_kx1=[]\nfor k in range(len(tt)):\n    ft=0;\n    for i in range(len(xx)):\n        for j in range(len(yy)):\n            if xx[i]&gt;0.5 and xx[i]&lt;1.5:\n                if abs(yy[j]-0.1)&lt;dy/2:\n                    ft=ft+hh[k,j,i]*vv[k,j,i]*dx\n    F_kx1.append(-ft)\n</pre> fn = 'Output_Kur-XiaC1.nc' ds = nc4.Dataset(fn) ds xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zsf=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0] dx=xx[1]-xx[0]  F_kx1=[] for k in range(len(tt)):     ft=0;     for i in range(len(xx)):         for j in range(len(yy)):             if xx[i]&gt;0.5 and xx[i]&lt;1.5:                 if abs(yy[j]-0.1) In\u00a0[27]: Copied! <pre>fn = 'Output_Kur-XiaC3.nc'\nds = nc4.Dataset(fn)\nds\nxx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzsf=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\ndx=xx[1]-xx[0]\n\nF_kx3=[]\nfor k in range(len(tt)):\n    ft=0;\n    for i in range(len(xx)):\n        for j in range(len(yy)):\n            if xx[i]&gt;0.5 and xx[i]&lt;1.5:\n                if abs(yy[j]-0.1)&lt;dy/2:\n                    ft=ft+hh[k,j,i]*vv[k,j,i]*dx\n    F_kx3.append(-ft)\n</pre> fn = 'Output_Kur-XiaC3.nc' ds = nc4.Dataset(fn) ds xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zsf=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0] dx=xx[1]-xx[0]  F_kx3=[] for k in range(len(tt)):     ft=0;     for i in range(len(xx)):         for j in range(len(yy)):             if xx[i]&gt;0.5 and xx[i]&lt;1.5:                 if abs(yy[j]-0.1) In\u00a0[28]: Copied! <pre>ax1=plt.subplot(1,1,1)\nP1,=ax1.plot(xC1,yC1,'o', label='Experiment')\nP2,=ax1.plot(tt, F_kx1,'.-', label='zs using Kurganov and Xia')\nP3,=ax1.plot(tt, F_bx1,'.-', label='zs using Buttinger and Xia')\nax1.set_ylabel('Flux ($m^3$/s)')\nax1.set_xlim([0.0, 150.0])\nax1.set_ylim([0.0, 0.0005])\nax2=ax1.twinx()\nax2.fill_between(Tr, Hr,alpha=0.1, color='blue', label='Rain forcing')\nax2.set_ylabel('P (mm/h)')\nax2.set_ylim([0.0, 500])\n#ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500))\nhandles, labels = ax2.get_legend_handles_labels()\nhandles.append(P1)\nhandles.append(P2)\nhandles.append(P3)\nplt.legend(handles=handles)\nplt.xlabel('Time(s)')\nplt.title('Time evolution of the flux at the output of the domain, C1');\n</pre> ax1=plt.subplot(1,1,1) P1,=ax1.plot(xC1,yC1,'o', label='Experiment') P2,=ax1.plot(tt, F_kx1,'.-', label='zs using Kurganov and Xia') P3,=ax1.plot(tt, F_bx1,'.-', label='zs using Buttinger and Xia') ax1.set_ylabel('Flux ($m^3$/s)') ax1.set_xlim([0.0, 150.0]) ax1.set_ylim([0.0, 0.0005]) ax2=ax1.twinx() ax2.fill_between(Tr, Hr,alpha=0.1, color='blue', label='Rain forcing') ax2.set_ylabel('P (mm/h)') ax2.set_ylim([0.0, 500]) #ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500)) handles, labels = ax2.get_legend_handles_labels() handles.append(P1) handles.append(P2) handles.append(P3) plt.legend(handles=handles) plt.xlabel('Time(s)') plt.title('Time evolution of the flux at the output of the domain, C1'); In\u00a0[29]: Copied! <pre>ax=plt.subplot(1,1,1)\nP1,=ax.plot(xC3,yC3,'o', label='Experiment')\nP2,=ax.plot(tt, F_kx3,'.-', label='zs using Kurganov and Xia')\nP3,=ax.plot(tt, F_bx3,'.-', label='zs using Buttinger and Xia')\nax2=ax.twinx()\nax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing')\nax.set_ylabel('Flux ($m^3$/s)')\nax.set_xlim([0.0, 150.0])\nax.set_ylim([0.0, 0.0005])\nax2.set_ylabel('P (mm/h)')\nax2.set_ylim([0.0, 500])\nplt.xlabel('Time(s)')\nhandles, labels = ax2.get_legend_handles_labels()\nhandles.append(P1)\nhandles.append(P2)\nhandles.append(P3)\nplt.legend(handles=handles)\nplt.title('Time evolution of the flux at the output of the domain, C3');\n</pre> ax=plt.subplot(1,1,1) P1,=ax.plot(xC3,yC3,'o', label='Experiment') P2,=ax.plot(tt, F_kx3,'.-', label='zs using Kurganov and Xia') P3,=ax.plot(tt, F_bx3,'.-', label='zs using Buttinger and Xia') ax2=ax.twinx() ax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing') ax.set_ylabel('Flux ($m^3$/s)') ax.set_xlim([0.0, 150.0]) ax.set_ylim([0.0, 0.0005]) ax2.set_ylabel('P (mm/h)') ax2.set_ylim([0.0, 500]) plt.xlabel('Time(s)') handles, labels = ax2.get_legend_handles_labels() handles.append(P1) handles.append(P2) handles.append(P3) plt.legend(handles=handles) plt.title('Time evolution of the flux at the output of the domain, C3'); In\u00a0[30]: Copied! <pre>ax=plt.subplot(1,1,1)\n#P1,=ax.plot(xC3,yC3,'o', label='Experiment')\nP1,=ax.plot(tt, (np.asanyarray(F_k)-np.asanyarray(F_kx1))/max(np.asanyarray(F_k))*100,'.-', label='Kurganov, C1, base - Xia (zs)')\nP2,=ax.plot(tt, (np.asanyarray(F_b)-np.asanyarray(F_bx1))/max(np.asanyarray(F_k))*100,'.-', label='Buttinger, C1, base-Xia ')\nP3,=ax.plot(tt, (np.asanyarray(F_k3)-np.asanyarray(F_kx3))/max(np.asanyarray(F_k))*100,'.-', label='Kurganov, C3, base - Xia (zs)')\nP4,=ax.plot(tt, (np.asanyarray(F_b3)-np.asanyarray(F_bx3))/max(np.asanyarray(F_k))*100,'.-', label='Buttinger, C3, base-Xia ')\n#ax2=ax.twinx()\n#ax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing')\nax.set_ylabel('% in Flux ($m^3$/s) difference between friction models')\n#ax.set_xlim([0.0, 150.0])\n#ax.set_ylim([0.0, 0.0005])\n#ax2.set_ylabel('P (mm/h)')\n#ax2.set_ylim([0.0, 500])\nplt.xlabel('Time(s)')\n#handles, labels = ax2.get_legend_handles_labels()\n#handles.append(P1)\n#handles.append(P2)\n#handles.append(P3)\nplt.legend(handles=[P1,P2,P3,P4])\nplt.title('Comparison on the friction implementation : Base-Xia');\n</pre> ax=plt.subplot(1,1,1) #P1,=ax.plot(xC3,yC3,'o', label='Experiment') P1,=ax.plot(tt, (np.asanyarray(F_k)-np.asanyarray(F_kx1))/max(np.asanyarray(F_k))*100,'.-', label='Kurganov, C1, base - Xia (zs)') P2,=ax.plot(tt, (np.asanyarray(F_b)-np.asanyarray(F_bx1))/max(np.asanyarray(F_k))*100,'.-', label='Buttinger, C1, base-Xia ') P3,=ax.plot(tt, (np.asanyarray(F_k3)-np.asanyarray(F_kx3))/max(np.asanyarray(F_k))*100,'.-', label='Kurganov, C3, base - Xia (zs)') P4,=ax.plot(tt, (np.asanyarray(F_b3)-np.asanyarray(F_bx3))/max(np.asanyarray(F_k))*100,'.-', label='Buttinger, C3, base-Xia ') #ax2=ax.twinx() #ax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing') ax.set_ylabel('% in Flux ($m^3$/s) difference between friction models') #ax.set_xlim([0.0, 150.0]) #ax.set_ylim([0.0, 0.0005]) #ax2.set_ylabel('P (mm/h)') #ax2.set_ylim([0.0, 500]) plt.xlabel('Time(s)') #handles, labels = ax2.get_legend_handles_labels() #handles.append(P1) #handles.append(P2) #handles.append(P3) plt.legend(handles=[P1,P2,P3,P4]) plt.title('Comparison on the friction implementation : Base-Xia'); In\u00a0[31]: Copied! <pre>ax=plt.subplot(1,1,1)\n#P1,=ax.plot(xC3,yC3,'o', label='Experiment')\nP1,=ax.plot(tt, (np.asanyarray(F_k)-np.asanyarray(F_b))/max(np.asanyarray(F_k))*100,'.-', label='Base friction, C1, Kur.-But. (zs)')\nP2,=ax.plot(tt, (np.asanyarray(F_k3)-np.asanyarray(F_b3))/max(np.asanyarray(F_k3))*100,'.-', label='Base friction, C3, Kur.-But. ')\nP3,=ax.plot(tt, (np.asanyarray(F_kx1)-np.asanyarray(F_bx1))/max(np.asanyarray(F_kx1))*100,'.-', label='Xia, C1, Kur.-But.')\nP4,=ax.plot(tt, (np.asanyarray(F_kx3)-np.asanyarray(F_bx3))/max(np.asanyarray(F_kx3))*100,'.-', label='Xia, C3, Kur.-But. ')\n#ax2=ax.twinx()\n#ax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing')\nax.set_ylabel('% in Flux ($m^3$/s) difference between surface reconstruction models')\n#ax.set_xlim([0.0, 150.0])\n#ax.set_ylim([0.0, 0.0005])\n#ax2.set_ylabel('P (mm/h)')\n#ax2.set_ylim([0.0, 500])\nplt.xlabel('Time(s)')\n#handles, labels = ax2.get_legend_handles_labels()\n#handles.append(P1)\n#handles.append(P2)\n#handles.append(P3)\nplt.legend(handles=[P1,P2,P3,P4])\nplt.title('Comparison on the surface reconstruction: Kurganov-Buttinger');\n</pre> ax=plt.subplot(1,1,1) #P1,=ax.plot(xC3,yC3,'o', label='Experiment') P1,=ax.plot(tt, (np.asanyarray(F_k)-np.asanyarray(F_b))/max(np.asanyarray(F_k))*100,'.-', label='Base friction, C1, Kur.-But. (zs)') P2,=ax.plot(tt, (np.asanyarray(F_k3)-np.asanyarray(F_b3))/max(np.asanyarray(F_k3))*100,'.-', label='Base friction, C3, Kur.-But. ') P3,=ax.plot(tt, (np.asanyarray(F_kx1)-np.asanyarray(F_bx1))/max(np.asanyarray(F_kx1))*100,'.-', label='Xia, C1, Kur.-But.') P4,=ax.plot(tt, (np.asanyarray(F_kx3)-np.asanyarray(F_bx3))/max(np.asanyarray(F_kx3))*100,'.-', label='Xia, C3, Kur.-But. ') #ax2=ax.twinx() #ax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing') ax.set_ylabel('% in Flux ($m^3$/s) difference between surface reconstruction models') #ax.set_xlim([0.0, 150.0]) #ax.set_ylim([0.0, 0.0005]) #ax2.set_ylabel('P (mm/h)') #ax2.set_ylim([0.0, 500]) plt.xlabel('Time(s)') #handles, labels = ax2.get_legend_handles_labels() #handles.append(P1) #handles.append(P2) #handles.append(P3) plt.legend(handles=[P1,P2,P3,P4]) plt.title('Comparison on the surface reconstruction: Kurganov-Buttinger'); In\u00a0[32]: Copied! <pre>fn = 'Output_KurC1-Smart1-6.nc'\nds = nc4.Dataset(fn)\nds\nxx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzsf=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\ndx=xx[1]-xx[0]\n\nF_kS1=[]\nfor k in range(len(tt)):\n    ft=0;\n    for i in range(len(xx)):\n        for j in range(len(yy)):\n            if xx[i]&gt;0.5 and xx[i]&lt;1.5:\n                if abs(yy[j]-0.1)&lt;dy/2:\n                    ft=ft+hh[k,j,i]*vv[k,j,i]*dx\n    F_kS1.append(-ft)\n</pre> fn = 'Output_KurC1-Smart1-6.nc' ds = nc4.Dataset(fn) ds xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zsf=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0] dx=xx[1]-xx[0]  F_kS1=[] for k in range(len(tt)):     ft=0;     for i in range(len(xx)):         for j in range(len(yy)):             if xx[i]&gt;0.5 and xx[i]&lt;1.5:                 if abs(yy[j]-0.1) In\u00a0[36]: Copied! <pre>ax1=plt.subplot(1,1,1)\nP1,=ax1.plot(xC1,yC1,'o', label='Experiment')\nP2,=ax1.plot(tt, F_k,'.-', label='zs using Kurganov')\nP3,=ax1.plot(tt, F_b,'.-', label='zs using Buttinger')\nP4,=ax1.plot(tt, F_kx1,'.-', label='zs using Kurganov and Xia')\nP5,=ax1.plot(tt, F_bx1,'.-', label='zs using Buttinger and Xia')\nP6,=ax1.plot(tt, F_kS1,'.-', label='zs using Kur. basic frict. with Smart')\nax1.set_ylabel('Flux ($m^3$/s)')\nax1.set_xlim([0.0, 150.0])\nax1.set_ylim([0.0, 0.0005])\nax2=ax1.twinx()\nax2.fill_between(Tr, Hr,alpha=0.1, color='blue', label='Rain forcing')\nax2.set_ylabel('P (mm/h)')\nax2.set_ylim([0.0, 500])\n#ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500))\nhandles, labels = ax2.get_legend_handles_labels()\nhandles.append(P1)\nhandles.append(P2)\nhandles.append(P3)\nhandles.append(P4)\nhandles.append(P5)\nhandles.append(P6)\nplt.legend(handles=handles)\nplt.xlabel('Time(s)')\nplt.title('Time evolution of the flux at the output of the domain, C1');\n</pre> ax1=plt.subplot(1,1,1) P1,=ax1.plot(xC1,yC1,'o', label='Experiment') P2,=ax1.plot(tt, F_k,'.-', label='zs using Kurganov') P3,=ax1.plot(tt, F_b,'.-', label='zs using Buttinger') P4,=ax1.plot(tt, F_kx1,'.-', label='zs using Kurganov and Xia') P5,=ax1.plot(tt, F_bx1,'.-', label='zs using Buttinger and Xia') P6,=ax1.plot(tt, F_kS1,'.-', label='zs using Kur. basic frict. with Smart') ax1.set_ylabel('Flux ($m^3$/s)') ax1.set_xlim([0.0, 150.0]) ax1.set_ylim([0.0, 0.0005]) ax2=ax1.twinx() ax2.fill_between(Tr, Hr,alpha=0.1, color='blue', label='Rain forcing') ax2.set_ylabel('P (mm/h)') ax2.set_ylim([0.0, 500]) #ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500)) handles, labels = ax2.get_legend_handles_labels() handles.append(P1) handles.append(P2) handles.append(P3) handles.append(P4) handles.append(P5) handles.append(P6) plt.legend(handles=handles) plt.xlabel('Time(s)') plt.title('Time evolution of the flux at the output of the domain, C1'); In\u00a0[43]: Copied! <pre>ax1=plt.subplot(1,1,1)\nP1,=ax1.plot(xC1,yC1,'o', label='Experiment')\nP6,=ax1.plot(tt, F_kS1,'.-', label='zs using Kur. basic frict. with Smart')\nax1.set_ylabel('Flux ($m^3$/s)')\nax1.set_xlabel('Time(s)')\nax1.set_xlim([0.0, 150.0])\nax1.set_ylim([0.0, 0.0005])\nax2=ax1.twinx()\nax2.fill_between(Tr, Hr,alpha=0.1, color='blue', label='Rain forcing')\nax2.set_ylabel('P (mm/h)')\nax2.set_ylim([0.0, 500])\n#ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500))\nhandles, labels = ax2.get_legend_handles_labels()\nhandles.append(P1)\nhandles.append(P6)\nplt.legend(handles=handles)\nplt.title('Time evolution of the flux at the output of the domain, C1');\n</pre> ax1=plt.subplot(1,1,1) P1,=ax1.plot(xC1,yC1,'o', label='Experiment') P6,=ax1.plot(tt, F_kS1,'.-', label='zs using Kur. basic frict. with Smart') ax1.set_ylabel('Flux ($m^3$/s)') ax1.set_xlabel('Time(s)') ax1.set_xlim([0.0, 150.0]) ax1.set_ylim([0.0, 0.0005]) ax2=ax1.twinx() ax2.fill_between(Tr, Hr,alpha=0.1, color='blue', label='Rain forcing') ax2.set_ylabel('P (mm/h)') ax2.set_ylim([0.0, 500]) #ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500)) handles, labels = ax2.get_legend_handles_labels() handles.append(P1) handles.append(P6) plt.legend(handles=handles) plt.title('Time evolution of the flux at the output of the domain, C1'); In\u00a0[34]: Copied! <pre>fn = 'Output_KurC3-Smart1-6.nc'\nds = nc4.Dataset(fn)\nds\nxx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzsf=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\ndx=xx[1]-xx[0]\n\nF_kS3=[]\nfor k in range(len(tt)):\n    ft=0;\n    for i in range(len(xx)):\n        for j in range(len(yy)):\n            if xx[i]&gt;0.5 and xx[i]&lt;1.5:\n                if abs(yy[j]-0.1)&lt;dy/2:\n                    ft=ft+hh[k,j,i]*vv[k,j,i]*dx\n    F_kS3.append(-ft)\n</pre> fn = 'Output_KurC3-Smart1-6.nc' ds = nc4.Dataset(fn) ds xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zsf=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0] dx=xx[1]-xx[0]  F_kS3=[] for k in range(len(tt)):     ft=0;     for i in range(len(xx)):         for j in range(len(yy)):             if xx[i]&gt;0.5 and xx[i]&lt;1.5:                 if abs(yy[j]-0.1) In\u00a0[38]: Copied! <pre>ax1=plt.subplot(1,1,1)\nP1,=ax1.plot(xC3,yC3,'o', label='Experiment')\nP2,=ax1.plot(tt, F_k3,'.-', label='zs using Kurganov')\nP3,=ax1.plot(tt, F_b3,'.-', label='zs using Buttinger')\nP4,=ax1.plot(tt, F_kx3,'.-', label='zs using Kurganov and Xia')\nP5,=ax1.plot(tt, F_bx3,'.-', label='zs using Buttinger and Xia')\nP6,=ax1.plot(tt, F_kS3,'.-', label='zs using Kur. basic fric. Smart')\nax1.set_ylabel('Flux ($m^3$/s)')\nax1.set_xlim([0.0, 150.0])\nax1.set_ylim([0.0, 0.0005])\nax2=ax1.twinx()\nax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing')\nax2.set_ylabel('P (mm/h)')\nax2.set_ylim([0.0, 500])\n#ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500))\nhandles, labels = ax2.get_legend_handles_labels()\nhandles.append(P1)\nhandles.append(P2)\nhandles.append(P3)\nhandles.append(P4)\nhandles.append(P5)\nhandles.append(P6)\nplt.legend(handles=handles)\nplt.xlabel('Time(s)')\nplt.title('Time evolution of the flux at the output of the domain, C3');\n</pre> ax1=plt.subplot(1,1,1) P1,=ax1.plot(xC3,yC3,'o', label='Experiment') P2,=ax1.plot(tt, F_k3,'.-', label='zs using Kurganov') P3,=ax1.plot(tt, F_b3,'.-', label='zs using Buttinger') P4,=ax1.plot(tt, F_kx3,'.-', label='zs using Kurganov and Xia') P5,=ax1.plot(tt, F_bx3,'.-', label='zs using Buttinger and Xia') P6,=ax1.plot(tt, F_kS3,'.-', label='zs using Kur. basic fric. Smart') ax1.set_ylabel('Flux ($m^3$/s)') ax1.set_xlim([0.0, 150.0]) ax1.set_ylim([0.0, 0.0005]) ax2=ax1.twinx() ax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing') ax2.set_ylabel('P (mm/h)') ax2.set_ylim([0.0, 500]) #ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500)) handles, labels = ax2.get_legend_handles_labels() handles.append(P1) handles.append(P2) handles.append(P3) handles.append(P4) handles.append(P5) handles.append(P6) plt.legend(handles=handles) plt.xlabel('Time(s)') plt.title('Time evolution of the flux at the output of the domain, C3'); In\u00a0[45]: Copied! <pre>ax1=plt.subplot(1,1,1)\nP1,=ax1.plot(xC3,yC3,'o', label='Experiment')\nP6,=ax1.plot(tt, F_kS3,'.-', label='zs using Kur. basic fric. Smart')\nax1.set_ylabel('Flux ($m^3$/s)')\nax1.set_xlabel('Time(s)')\nax1.set_xlim([0.0, 150.0])\nax1.set_ylim([0.0, 0.0005])\nax2=ax1.twinx()\nax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing')\nax2.set_ylabel('P (mm/h)')\nax2.set_ylim([0.0, 500])\n#ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500))\nhandles, labels = ax2.get_legend_handles_labels()\nhandles.append(P1)\nhandles.append(P6)\nplt.legend(handles=handles)\nplt.title('Time evolution of the flux at the output of the domain, C3');\n</pre> ax1=plt.subplot(1,1,1) P1,=ax1.plot(xC3,yC3,'o', label='Experiment') P6,=ax1.plot(tt, F_kS3,'.-', label='zs using Kur. basic fric. Smart') ax1.set_ylabel('Flux ($m^3$/s)') ax1.set_xlabel('Time(s)') ax1.set_xlim([0.0, 150.0]) ax1.set_ylim([0.0, 0.0005]) ax2=ax1.twinx() ax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing') ax2.set_ylabel('P (mm/h)') ax2.set_ylim([0.0, 500]) #ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500)) handles, labels = ax2.get_legend_handles_labels() handles.append(P1) handles.append(P6) plt.legend(handles=handles) plt.title('Time evolution of the flux at the output of the domain, C3'); In\u00a0[46]: Copied! <pre>fn = 'Output_KurC1-Smart5-6.nc'\nds = nc4.Dataset(fn)\nds\nxx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzsf=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\ndx=xx[1]-xx[0]\n\nF_kS1b=[]\nfor k in range(len(tt)):\n    ft=0;\n    for i in range(len(xx)):\n        for j in range(len(yy)):\n            if xx[i]&gt;0.5 and xx[i]&lt;1.5:\n                if abs(yy[j]-0.1)&lt;dy/2:\n                    ft=ft+hh[k,j,i]*vv[k,j,i]*dx\n    F_kS1b.append(-ft)\n</pre> fn = 'Output_KurC1-Smart5-6.nc' ds = nc4.Dataset(fn) ds xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zsf=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0] dx=xx[1]-xx[0]  F_kS1b=[] for k in range(len(tt)):     ft=0;     for i in range(len(xx)):         for j in range(len(yy)):             if xx[i]&gt;0.5 and xx[i]&lt;1.5:                 if abs(yy[j]-0.1) In\u00a0[53]: Copied! <pre>fn = 'Output_KurC1-Smart5-6_eps-5.nc'\nds = nc4.Dataset(fn)\nds\nxx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzsf=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\ndx=xx[1]-xx[0]\n\nF_kS1c=[]\nfor k in range(len(tt)):\n    ft=0;\n    for i in range(len(xx)):\n        for j in range(len(yy)):\n            if xx[i]&gt;0.5 and xx[i]&lt;1.5:\n                if abs(yy[j]-0.1)&lt;dy/2:\n                    ft=ft+hh[k,j,i]*vv[k,j,i]*dx\n    F_kS1c.append(-ft)\n</pre> fn = 'Output_KurC1-Smart5-6_eps-5.nc' ds = nc4.Dataset(fn) ds xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zsf=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0] dx=xx[1]-xx[0]  F_kS1c=[] for k in range(len(tt)):     ft=0;     for i in range(len(xx)):         for j in range(len(yy)):             if xx[i]&gt;0.5 and xx[i]&lt;1.5:                 if abs(yy[j]-0.1) In\u00a0[55]: Copied! <pre>fn = 'Output_KurC1-Smart5-6_theta-14.nc'\nds = nc4.Dataset(fn)\nds\nxx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzsf=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\ndx=xx[1]-xx[0]\n\nF_kS1d=[]\nfor k in range(len(tt)):\n    ft=0;\n    for i in range(len(xx)):\n        for j in range(len(yy)):\n            if xx[i]&gt;0.5 and xx[i]&lt;1.5:\n                if abs(yy[j]-0.1)&lt;dy/2:\n                    ft=ft+hh[k,j,i]*vv[k,j,i]*dx\n    F_kS1d.append(-ft)\n</pre> fn = 'Output_KurC1-Smart5-6_theta-14.nc' ds = nc4.Dataset(fn) ds xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zsf=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0] dx=xx[1]-xx[0]  F_kS1d=[] for k in range(len(tt)):     ft=0;     for i in range(len(xx)):         for j in range(len(yy)):             if xx[i]&gt;0.5 and xx[i]&lt;1.5:                 if abs(yy[j]-0.1) In\u00a0[62]: Copied! <pre>ax1=plt.subplot(1,1,1)\nP1,=ax1.plot(xC1,yC1,'o', label='Experiment')\nP6,=ax1.plot(tt, F_kS1,'.-', label='zs using Kur. Smart, 1E-6')\nP7,=ax1.plot(tt, F_kS1b,'.-', label='zs using Kur. Smart,5E-6')\nP8,=ax1.plot(tt, F_kS1c,'.-', label='zs using Kur. Smart,5E-6, eps=1E-5')\nP9,=ax1.plot(tt, F_kS1d,'.-', label='zs using Kur., theta=1.4')\nax1.set_ylabel('Flux ($m^3$/s)')\nax1.set_xlabel('Time(s)')\nax1.set_xlim([0.0, 150.0])\nax1.set_ylim([0.0, 0.0005])\nax2=ax1.twinx()\nax2.fill_between(Tr, Hr,alpha=0.1, color='blue', label='Rain forcing')\nax2.set_ylabel('P (mm/h)')\nax2.set_ylim([0.0, 500])\n#ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500))\nhandles, labels = ax2.get_legend_handles_labels()\nhandles.append(P1)\nhandles.append(P6)\nhandles.append(P7)\nhandles.append(P8)\nhandles.append(P9)\nplt.legend(handles=handles)\nplt.title('Time evolution of the flux at the output of the domain, C1');\n</pre> ax1=plt.subplot(1,1,1) P1,=ax1.plot(xC1,yC1,'o', label='Experiment') P6,=ax1.plot(tt, F_kS1,'.-', label='zs using Kur. Smart, 1E-6') P7,=ax1.plot(tt, F_kS1b,'.-', label='zs using Kur. Smart,5E-6') P8,=ax1.plot(tt, F_kS1c,'.-', label='zs using Kur. Smart,5E-6, eps=1E-5') P9,=ax1.plot(tt, F_kS1d,'.-', label='zs using Kur., theta=1.4') ax1.set_ylabel('Flux ($m^3$/s)') ax1.set_xlabel('Time(s)') ax1.set_xlim([0.0, 150.0]) ax1.set_ylim([0.0, 0.0005]) ax2=ax1.twinx() ax2.fill_between(Tr, Hr,alpha=0.1, color='blue', label='Rain forcing') ax2.set_ylabel('P (mm/h)') ax2.set_ylim([0.0, 500]) #ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500)) handles, labels = ax2.get_legend_handles_labels() handles.append(P1) handles.append(P6) handles.append(P7) handles.append(P8) handles.append(P9) plt.legend(handles=handles) plt.title('Time evolution of the flux at the output of the domain, C1'); In\u00a0[48]: Copied! <pre>fn = 'Output_KurC3-Smart5-6.nc'\nds = nc4.Dataset(fn)\nds\nxx=ds['xx_P0'][:]\nyy=ds['yy_P0'][:]\ntt=ds['time'][:]\nhh=ds['h_P0'][:,:,:]\nzsf=ds['zs_P0'][:,:,:]\nzb=ds['zb_P0'][:,:,:]\nvv=ds['v_P0'][:]\ndy=yy[1]-yy[0]\ndx=xx[1]-xx[0]\n\nF_kS3b=[]\nfor k in range(len(tt)):\n    ft=0;\n    for i in range(len(xx)):\n        for j in range(len(yy)):\n            if xx[i]&gt;0.5 and xx[i]&lt;1.5:\n                if abs(yy[j]-0.1)&lt;dy/2:\n                    ft=ft+hh[k,j,i]*vv[k,j,i]*dx\n    F_kS3b.append(-ft)\n</pre> fn = 'Output_KurC3-Smart5-6.nc' ds = nc4.Dataset(fn) ds xx=ds['xx_P0'][:] yy=ds['yy_P0'][:] tt=ds['time'][:] hh=ds['h_P0'][:,:,:] zsf=ds['zs_P0'][:,:,:] zb=ds['zb_P0'][:,:,:] vv=ds['v_P0'][:] dy=yy[1]-yy[0] dx=xx[1]-xx[0]  F_kS3b=[] for k in range(len(tt)):     ft=0;     for i in range(len(xx)):         for j in range(len(yy)):             if xx[i]&gt;0.5 and xx[i]&lt;1.5:                 if abs(yy[j]-0.1) In\u00a0[70]: Copied! <pre>ax1=plt.subplot(1,1,1)\nP1,=ax1.plot(xC3,yC3,'o', label='Experiment')\n#P6,=ax1.plot(tt, F_kS3,'.-', label='zs using Kur. Smart, 1E-6')\nP7,=ax1.plot(tt, F_kS3b,'.-', label='BG_flood, $ks=5\\, 10^{-6}$m')\nax1.set_ylabel('Flux ($m^3$/s)')\nax1.set_xlabel('Time(s)')\nax1.set_xlim([0.0, 150.0])\nax1.set_ylim([0.0, 0.0005])\nax2=ax1.twinx()\nax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing')\nax2.set_ylabel('P (mm/h)')\nax2.set_ylim([0.0, 500])\n#ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500))\nhandles, labels = ax2.get_legend_handles_labels()\nhandles.append(P1)\n#handles.append(P6)\nhandles.append(P7)\nplt.legend(handles=handles)\nplt.title('Time evolution of the flux at the output of the domain, C3');\n</pre> ax1=plt.subplot(1,1,1) P1,=ax1.plot(xC3,yC3,'o', label='Experiment') #P6,=ax1.plot(tt, F_kS3,'.-', label='zs using Kur. Smart, 1E-6') P7,=ax1.plot(tt, F_kS3b,'.-', label='BG_flood, $ks=5\\, 10^{-6}$m') ax1.set_ylabel('Flux ($m^3$/s)') ax1.set_xlabel('Time(s)') ax1.set_xlim([0.0, 150.0]) ax1.set_ylim([0.0, 0.0005]) ax2=ax1.twinx() ax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing') ax2.set_ylabel('P (mm/h)') ax2.set_ylim([0.0, 500]) #ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500)) handles, labels = ax2.get_legend_handles_labels() handles.append(P1) #handles.append(P6) handles.append(P7) plt.legend(handles=handles) plt.title('Time evolution of the flux at the output of the domain, C3'); In\u00a0[77]: Copied! <pre>ax1=plt.subplot(1,1,1)\nP1,=ax1.plot(xC1,yC1,'o', label='Experiment')\nP7,=ax1.plot(tt, F_kS1b,'.-', label='BG_flood, $ks=5\\, 10^{-6}$m')\nax1.set_ylabel('Flux ($m^3$/s)')\nax1.set_xlabel('Time(s)')\nax1.set_xlim([0.0, 150.0])\nax1.set_ylim([0.0, 0.0005])\nax2=ax1.twinx()\nax2.fill_between(Tr, Hr,alpha=0.1, color='blue', label='Rain forcing')\nax2.set_ylabel('P (mm/h)')\nax2.set_ylim([0.0, 500])\n#ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500))\nhandles, labels = ax2.get_legend_handles_labels()\nhandles.append(P1)\nhandles.append(P7)\nplt.legend(handles=handles)\nplt.title('Time evolution of the flux at the output of the domain, C1');\nplt.savefig('CEA_C1_Kur-Smart.png',bbox_inches='tight')\n</pre> ax1=plt.subplot(1,1,1) P1,=ax1.plot(xC1,yC1,'o', label='Experiment') P7,=ax1.plot(tt, F_kS1b,'.-', label='BG_flood, $ks=5\\, 10^{-6}$m') ax1.set_ylabel('Flux ($m^3$/s)') ax1.set_xlabel('Time(s)') ax1.set_xlim([0.0, 150.0]) ax1.set_ylim([0.0, 0.0005]) ax2=ax1.twinx() ax2.fill_between(Tr, Hr,alpha=0.1, color='blue', label='Rain forcing') ax2.set_ylabel('P (mm/h)') ax2.set_ylim([0.0, 500]) #ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500)) handles, labels = ax2.get_legend_handles_labels() handles.append(P1) handles.append(P7) plt.legend(handles=handles) plt.title('Time evolution of the flux at the output of the domain, C1'); plt.savefig('CEA_C1_Kur-Smart.png',bbox_inches='tight') In\u00a0[78]: Copied! <pre>ax1=plt.subplot(1,1,1)\nP1,=ax1.plot(xC3,yC3,'o', label='Experiment')\nP7,=ax1.plot(tt, F_kS3b,'.-', label='BG_flood, $ks=5\\, 10^{-6}$m')\nax1.set_ylabel('Flux ($m^3$/s)')\nax1.set_xlabel('Time(s)')\nax1.set_xlim([0.0, 150.0])\nax1.set_ylim([0.0, 0.0005])\nax2=ax1.twinx()\nax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing')\nax2.set_ylabel('P (mm/h)')\nax2.set_ylim([0.0, 500])\n#ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500))\nhandles, labels = ax2.get_legend_handles_labels()\nhandles.append(P1)\nhandles.append(P7)\nplt.legend(handles=handles)\nplt.title('Time evolution of the flux at the output of the domain, C3');\nplt.savefig('CEA_C3_Kur-Smart.png',bbox_inches='tight')\n</pre> ax1=plt.subplot(1,1,1) P1,=ax1.plot(xC3,yC3,'o', label='Experiment') P7,=ax1.plot(tt, F_kS3b,'.-', label='BG_flood, $ks=5\\, 10^{-6}$m') ax1.set_ylabel('Flux ($m^3$/s)') ax1.set_xlabel('Time(s)') ax1.set_xlim([0.0, 150.0]) ax1.set_ylim([0.0, 0.0005]) ax2=ax1.twinx() ax2.fill_between(Tr3, Hr3, [0]*len(Tr3), alpha=0.1, color='blue', label='Rain forcing') ax2.set_ylabel('P (mm/h)') ax2.set_ylim([0.0, 500]) #ax2 = plt.axes(xlim=(0.0, 150.0), ylim=(0.0, 500)) handles, labels = ax2.get_legend_handles_labels() handles.append(P1) handles.append(P7) plt.legend(handles=handles) plt.title('Time evolution of the flux at the output of the domain, C3'); plt.savefig('CEA_C3_Kur-Smart.png',bbox_inches='tight') In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorial/Rain_CEA2008/#uniform-rain-on-an-idealised-catchment","title":"Uniform rain on an idealised catchment\u00b6","text":"<p>This 2D rainfall runoff test is based on the paper of (Cea, 2008) (https://iwra.org/congress/2008/resource/authors/abs478_article.pdf), which compare a numerical model against a laboratory experiment (Iwagaki,1955). This configuration consists in an ideal catchment with three land surface of constant slope, and two walls increasing the travel time of run-off. A constant rain is applied over the domain, associated with constant friction. The outlet hydrograph is used for comparing models results against experiments mesurements.</p>"},{"location":"tutorial/Rain_CEA2008/#model-set-up","title":"Model set-up\u00b6","text":""},{"location":"tutorial/Rain_CEA2008/#python-set-up","title":"Python set-up\u00b6","text":""},{"location":"tutorial/Rain_CEA2008/#installation","title":"Installation\u00b6","text":"<p>The following libraries will be used in this tutorial. They can be installed using the following requirement file (<code>pip install -r requierements.txt</code>), or any of your favorite method.</p>"},{"location":"tutorial/Rain_CEA2008/#loading-libraries","title":"Loading libraries\u00b6","text":""},{"location":"tutorial/Rain_CEA2008/#setting-up-the-directories","title":"Setting up the directories\u00b6","text":""},{"location":"tutorial/Rain_CEA2008/#preparation-of-the-bathymetry","title":"Preparation of the bathymetry\u00b6","text":"<p>The bathymetry is given in an ascii file (Download topo.asc), that can be directly read by BG_Flood. The initial model has been surronded by walls and a spillway has been added at the outlet to ensure a minimum water elevation in the inital domain (outlet is located at the top of the model).</p>"},{"location":"tutorial/Rain_CEA2008/#creation-of-the-forcing","title":"Creation of the forcing\u00b6","text":"<p>In this configuration, the code will be forced by an homogeneous rain during 45s then, switch off.</p>"},{"location":"tutorial/Rain_CEA2008/#writing-the-rain-forcing-file","title":"Writing the rain forcing file\u00b6","text":"<p>The boundary condition file will be defined by a time serie with a column for time, and one for millimeters of rain: rainfall intensity $I = 317.0 mm/h$).</p>"},{"location":"tutorial/Rain_CEA2008/#writing-the-bg_params-file","title":"Writing the BG_Params file\u00b6","text":"<p>This text file is the main interface to BG_Flood solver. It contains a list of key words and associated values, to modify the default topographic grid and time keeping parameters, boundary and external forcing, as well as output options and parameter values. Different keys can be accepted for the same parameter. (See List of inputs parameters for a detailled list of the input parameters). The minimum input is the bathymetry file. In this example, we will conserve a simple version of the <code>BG_param.txt</code> file where only the modified values will be listed (default values will be kept for the parameters not mentionned):</p>"},{"location":"tutorial/Rain_CEA2008/#launching-the-code-bg_flood","title":"Launching the code BG_flood\u00b6","text":"<p>All the needed links to the libraries (.dll files) and the BG_flood executable are copied in the working folder.</p>"},{"location":"tutorial/Rain_CEA2008/#launch-of-the-code","title":"Launch of the code\u00b6","text":"<p>The code can be launched by a double clic on the executable or from python using the following line:</p>"},{"location":"tutorial/Rain_CEA2008/#comparaison-of-the-data-output-with-the-experimental-results","title":"Comparaison of the data output with the experimental results\u00b6","text":"<p>After identifying the position of the section at the end of the slope ($y=0.1$), we will calculate the flux through this section summing, through all the cells ($C_s$) at this location, the water elevation ($h$) times the velocity normal to the section ($v$):</p>"},{"location":"tutorial/Rain_CEA2008/#reading-the-benchmark-data","title":"Reading the benchmark data\u00b6","text":"<p>This data (Download reference data) has been extracted from the initial paper (Iwagaki, 1955).</p>"},{"location":"tutorial/Rain_CEA2008/#reading-the-bg_flood-outputs","title":"Reading the BG_flood outputs\u00b6","text":"<p>Here, the model is uniform (same grid size everywhere). The handling of BG_Flood results is then relatively easy. When an adaptive grid with different level of refinements is used, different variables, ex: <code>hh_P0</code>, <code>hh_P1</code>, <code>hh_N2</code>, will be saved in the output file. Each corresponds to a layer of refinement and have different dimensions, <code>XX_P0</code> corresponding to the reference level, <code>XX_P1</code> corresponding to one level up (<code>+1</code>), <code>XX_N2</code> corresponding to 2 levels down (<code>-2</code>). One level up correspond to dividing the resolution by two.</p>"},{"location":"tutorial/Rain_CEA2008/#calculating-the-flux-at-the-output","title":"Calculating the flux at the output\u00b6","text":"<p>We calculate the flux through a $1m$-long section ($x \\in [0.5,1.5]$)</p>"},{"location":"tutorial/Rain_CEA2008/#test-of-the-new-buttinger-scheme","title":"Test of the new Buttinger scheme\u00b6","text":"<p>The simulatuion has been restarted (from the previous simulation) from the end of the rain period (45s) for the old Kurgonov and new Buttinger scheme for surface reconstruction.</p>"},{"location":"tutorial/Rain_CEA2008/#adding-fix-in-interpolation-of-the-forcing","title":"Adding fix in interpolation of the forcing\u00b6","text":"<p>A small error of typo on the identification of the running time, causing an error during the interpolation, was creating a negative rain (causing the observed error of negative water elevation).</p>"},{"location":"tutorial/Rain_CEA2008/#comparison-between-the-kurgonov-and-the-buttinger-model","title":"Comparison between the Kurgonov and the Buttinger model\u00b6","text":"<p>The initial implementation of the water surface reconstruction was based on Kurganov&amp;Petrova2007. It is compared to a new surface reconstruction method proposed by Buttinger-Kreuzhuber-et-al2019.</p>"},{"location":"tutorial/Rain_CEA2008/#test-of-the-case-3-of-cea","title":"Test of the Case 3 of CEA\u00b6","text":"<p>For this configuration, 328mm/h rain is applied two times 25s, with a 7s cut-off in between.</p>"},{"location":"tutorial/Rain_CEA2008/#writing-the-rain-forcing-file","title":"Writing the rain forcing file\u00b6","text":"<p>The boundary condition file will be defined by a time serie with a column for time, and on for millimeters of rain.</p>"},{"location":"tutorial/Rain_CEA2008/#modification-of-the-parameter-files-and-running-the-code","title":"Modification of the Parameter files and running the code\u00b6","text":""},{"location":"tutorial/Rain_CEA2008/#results","title":"Results\u00b6","text":""},{"location":"tutorial/Rain_CEA2008/#comparing-with-the-new-friction-implementation-from-xia2018","title":"Comparing with the new friction implementation from Xia2018\u00b6","text":"<p>(from [Xia2018] (https://www.sciencedirect.com/science/article/pii/S0309170818302124))</p>"},{"location":"tutorial/Rain_CEA2008/#testing-the-smart-friction-model","title":"Testing the Smart Friction model\u00b6","text":"<p>The friction model has been changed from Manning (used precendently as in the CEA paper) to the Smart model, used here with a roughness height h=1E-6m (midrange estimation for stainless steel).</p>"},{"location":"tutorial/Rain_CEA2008/#test-by-increasing-the-roughtness-height","title":"Test by increasing the roughtness height\u00b6","text":""},{"location":"tutorial/Rain_CEA2008/#figures-for-the-paper-coast-and-port","title":"Figures for the paper \"Coast and Port\"\u00b6","text":""},{"location":"tutorial/Transpacific_tsunami/","title":"Transpacific tsunami","text":""},{"location":"tutorial/Transpacific_tsunami/#transpacific-tsunami","title":"Transpacific tsunami","text":"<p>This tutorial is the next stat from the Gaussian wave. Here we produce a realistic tsunami and let it propagate across the Pacific.</p>"},{"location":"tutorial/Transpacific_tsunami/#bathy-and-domain-definition","title":"Bathy and domain definition","text":"<p>The bathymetry file we are using was extracted from the GEBCO gobal bathymetry using GMT command grdcut / grdsample. This section needs a tutorial of its own. Here in the <code>BG_param.txt</code> we specify the file name and that it is a spherical model domain. </p>BG_param.txt<pre><code>    # Bathymetry file\n    bathy = Tpac_big.asc;\n    spherical = 1;\n</code></pre> The file covers a bigger area than we want to use for the simulation so we restict the domain: <pre><code>    ymin=-78.0\n    ymax=14.32\n\n    dx=0.08;\n</code></pre> Also we do not want to simulate Blocks that are entirely covered in land where the elevation is bigger than say 30.0m above the datum <pre><code>    mask = 30.0;\n</code></pre>"},{"location":"tutorial/Transpacific_tsunami/#initial-tsunami-wave","title":"Initial tsunami wave","text":"<p>See matlab file in the folder or simply use: </p><pre><code>    hotstartfile=Maule_zs_init_simpleflt.nc;\n</code></pre>"},{"location":"tutorial/Transpacific_tsunami/#boundary","title":"Boundary","text":"<p>In the previous tutorial you have seen how different boundary type let's wave through with minimal reflection. You choose.</p>"},{"location":"tutorial/Transpacific_tsunami/#time-keeping","title":"Time Keeping","text":"<pre><code>    totaltime = 0.000000; # Start time\n    endtime = 54000.000000;\n    outputtimestep = 600.000000;\n</code></pre>"},{"location":"tutorial/Transpacific_tsunami/#outputs","title":"Outputs","text":"<pre><code>    outvars = hh,zs,zsmax;\n    # Files\n    outfile = Output_simple_fault.nc;\n    smallnc = 0; #if smallnc==1 all Output are scaled and saved as a short int\n\n    TSnode = -86.374,-17.984\n    TSOfile = SW_Lima.txt\n</code></pre>"},{"location":"tutorial/Transpacific_tsunami/#things-to-try","title":"Things to try","text":"<ul> <li>Try changing the model domain and resolution. What happens if part of the domain is outside of the area covered by the bathymetry?</li> <li>Try outputing a time series near Christchurch</li> </ul>"},{"location":"tutorial/TutorialJetJulia/","title":"Jet and Julia","text":""},{"location":"tutorial/TutorialJetJulia/#jet-tutorial-with-julia","title":"Jet tutorial with Julia","text":"<p>This is a very simple example that shows the model stability in transitional flows.</p>"},{"location":"tutorial/TutorialJetJulia/#make-a-bathymetry","title":"Make a bathymetry","text":"<p>Below is a Julia script to make the bathymetry. </p><pre><code>    using GMT\n\n    ny=16*16;\n    nx=16*32;\n\n    dx=5.0;\n\n    xmin=0;\n    xmax=nx*dx;\n\n    ymin=0;\n    ymax=ny*dx;\n\n    Bathy=zeros(nx,ny);\n\n    Bathy.=-5.0;\n\n    Bathy[170:172,:].=5.0;\n    Bathy[170:172,127:129].=-5.0;\n\n    Bathy[:,1:2].=5.0;\n    Bathy[:,(end-1):end].=5.0;\n\n    G = mat2grid(transpose(Bathy), 1,[xmin xmax ymin ymax -5.0 5.0 1 dx dx])\n    cmap = grd2cpt(G);      # Compute a colormap with the grid's data range\n    grdimage(G, lw=:thinnest, color=cmap, fmt=:png, show=true)\n\n    gmtwrite(\"bathy.asc\", G; id=\"ef\");\n</code></pre> <p>The result is a grid domain looking like this:  You can also use the bathy.asc file in the example folder.</p>"},{"location":"tutorial/TutorialJetJulia/#make-bnd-files","title":"Make Bnd files","text":"<p>We are going to set the water level to 0.0m on the right and 1.0 on the left and keep it constant. To do that we create 2 files <code>right.txt</code> and <code>left.bnd</code></p> right.bnd<pre><code># This is the right boundary\n0.0 0.0\n3600.0 0.0\n</code></pre> left.bnd<pre><code># This is the left boundary\n0.0 1.0\n3600.0 1.0\n</code></pre>"},{"location":"tutorial/TutorialJetJulia/#set-up-the-bg_paramtxt-file","title":"Set up the <code>BG_param.txt</code> file","text":"<p>First it is good practice to document your parameter file:</p> <p></p>BG_param.txt<pre><code>    ##############################\n    ## Jet demo\n    # CB 04/05/2019\n</code></pre> Then specify the bathymetry file to use. We will use the entire domain and resolution of the file so no need for other parameter for specifying the domain. <pre><code>    bathy=bathy.asc\n</code></pre> Specify the parameter theta to control the numerical diffusion of the model. but first let's leave it to the default. <pre><code>    theta=1.3;\n</code></pre> This is a relatively small model so we can force the netcdf variable to be saved as floats. <pre><code>    smallnc=0\n</code></pre> Sepcify the model duration, output timestep and output file name and variables <pre><code>    endtime=1800\n    outtimestep=10\n    outfile=Jet_demo.nc\n    outvars=zb,uu,vv,zs,vort;\n</code></pre> Specify absorbing boundaries for left and right (There is a wal at the top and bottom so no need to specify any boundary there). <pre><code>    right = 3; # Absorbing bnd\n    rightbndfile = right.bnd\n\n    left=3; # Absorbing bnd\n    leftbndfile = left.txt\n</code></pre>"},{"location":"tutorial/TutorialJetJulia/#run-the-model","title":"Run the model","text":"<p>If you are on windows simply double-click on the executable and on linux launch the binary.</p> <p>Vorticity output (<code>vort</code> variable) should look like this:</p> <p></p><p></p>"},{"location":"tutorial/TutorialJetJulia/#things-to-try","title":"Things to try","text":"<ul> <li>What happens when using a different value for theta (1-2.0)</li> <li>What happens when specifying a different type of boundary on the right </li> <li>What happens when you bring the boundary close to the jet</li> <li>Why is the jet so unstable/asymmetrical? (what are the initial condition like?)</li> </ul>"},{"location":"tutorial/TutorialMonaiJulia/","title":"Monai and Julia","text":"<p>Monai tutorial with Julia</p> <p>This is a tutorial realised for BG_Flood on Julia.</p>"},{"location":"tutorial/TutorialMonaiJulia/#goals","title":"Goals","text":"<ul> <li>Check Boundary forcing</li> <li>Check wave propagation and runup on complex topography against experimental data</li> </ul>"},{"location":"tutorial/TutorialMonaiJulia/#status","title":"Status","text":"<p>Success</p>"},{"location":"tutorial/TutorialMonaiJulia/#settings","title":"Settings","text":""},{"location":"tutorial/TutorialMonaiJulia/#results","title":"Results","text":"<p>Model behaves similar to other codes and ca reproduce the bulk of the tsunami waves. Results are comparable to the same class of models. The double precision simulation is virtually identical to the Double precision run confirming that in this case there is not much point on using the Double precision.</p> <p>skill assessment: Single precision</p> ------------- RMS error (m) Will-corr BSS Gauge 1 0.003391 0.978040 0.910979 Gauge 2 0.003735 0.965899 0.870943 Gauge 3 0.003284 0.976699 0.884080 <p>Double precision</p> ------------- RMS error (m) Will-corr BSS Gauge 1 0.003391 0.978039 0.910981 Gauge 2 0.003733 0.965948 0.871093 Gauge 3 0.003283 0.976704 0.884097 <p> Figure 1. Measured and simulated timeseries for the Monai benchmark</p>"},{"location":"tutorial/TutorialMonaiJulia/#run-times","title":"Run times","text":"GPU Quadro K620 GeForce GTS 450 other GPU Single Precision (s) 27 20 XX Double Precision (s) XX 34 XX"},{"location":"tutorial/TutorialRiver/","title":"Pluvial and fluvial flooding","text":""},{"location":"tutorial/TutorialRiver/#river-flooding-tutorial","title":"River flooding tutorial","text":"<p>The objectif of this tutorial is to explain how to use the code BG_Flood to model river flooding. As the code allows rain on grid, we will look at pluvial and fluvial flooding.</p> <p>This testcase aims to broadly reproduce the flooding event that occured from the 16 to the 18 of July 2021 (a 1 in 50 year flood event).  During this event, the Buller river, passing through the town of Westport, on the West Coast of the South Island of Aotearoa New Zealand, get out of its primary bed and flooded the Westport area.</p> <p>Prerequisite</p> <p>Before begining this tutoral, the user is expected to have downloaded the windows executable (last release on github) or compiled the sources (version &gt; 0.8) of the BG_flood code on linux.</p> <p>During this tutorial, we will build, step by step, a test case. A relatively simple testcase will be build first. Then an example with more complex rain, tidal boundaries inputs will also be shared and explained.</p>"},{"location":"tutorial/TutorialRiver/#param-file","title":"Param file","text":"<p>The interface with BG_flood software is done using only a text file: <code>BG_param.txt</code> (This is the name of the input parameter file by defauls, an other name can be use as first variable when lauching BG_Flood.)</p> <p>This file consists in a list of key words and inputs, separated by a \"=\" sign.  For a full list of the available key words and a further description of this file, please refer to the [parameter list]{../ParametersList-py.md} and the [manual]{../Manual.md}.</p>"},{"location":"tutorial/TutorialRiver/#preparation-of-the-topographybathymetry-dem-digital-elevation-model","title":"Preparation of the topography/bathymetry (DEM: Digital Elevation Model)","text":"<p>The DEM, topography or bathymetry file is the only necessary file to be added to BG_param file to run the model. </p><pre><code>DEM = Wesport_DEM_8m.nc?z;\n</code></pre> <p></p> <p>Note</p> <p>Different formats can be used for this file ( ASCII: .asc or NetCDF .nc principally). As Netcdf files can contain different variables, the \"?\" follows by the name of the variable is needed.</p> <p>Without further information, the code will run will default values for physical parameters and initialisation, Neumann boundaries and no external forcing:</p> <p></p> <p>A result files: <code>output.nc</code> is created (here opened with the [PyNcView]{https://pyncview.software.informer.com/}) </p> <p></p> <p>It contains 2D spatial fields saved regularly in time. It details the blocs information:</p> <ul> <li><code>blockid</code>: block index</li> <li><code>blocklevel</code>: level of refinement for each block</li> <li><code>blockstatus</code>: Is the block active ?</li> <li><code>blockwidth</code>: number of cells in x or y direction in the block (not considering halo cells for computational purpose only)</li> <li><code>blockxo</code>/<code>blockyo</code>: coordinate of the bottom left corner of he block</li> </ul> <p>the time 1D variables or coordinates:</p> <ul> <li><code>time</code>: time vector in second or real time</li> <li><code>xx</code>/<code>yy</code> axis: spacial coordinate in m (by default)</li> </ul> <p>and the by default outputs:</p> <ul> <li><code>h</code> : the water depth in m</li> <li><code>u</code> : the veloctity vector component in the x direction</li> <li><code>v</code>: the velocity vector component in the y direction</li> <li><code>zb</code>: the bottom/ground elevation (m from vertical projection reference)</li> <li><code>zs</code>: the surface water elevation (m from vertical projection reference)</li> </ul> <p>(see manual for further description of the variables).</p> <p>Note</p> <p>In BG_Flood, the memory is organised in blocked for an optimal parallelisation on GPU. All the cells on a block will share some status and parameter such as the level of refinement (or cell size) and the active status.</p> <p>A log file: <code>BG_log.txt</code> (very similaire to the shell outputs) is also created to keep the terminal output information:</p> <p></p>"},{"location":"tutorial/TutorialRiver/#basic-fluvial-flooding-set-up","title":"Basic fluvial flooding set-up","text":""},{"location":"tutorial/TutorialRiver/#river-discharge","title":"River discharge","text":"<p>The river are (at this stage) forced by a vertical discharge on a user defined rectagular area: </p><pre><code>river = river_discharge_TeKuha2.txt,1490249,1490427,5367640,5367805;\n</code></pre> where the four final numbers are: \\(x_1\\), \\(x_2\\), \\(y_1\\), \\(y_2\\), to define the area for the vertical discharge and a text file containing the time-serie of the discharge (first column: time (\\(s\\)) from reference time, second column: river discharge in \\(m^3s^{-1}\\)). <p></p> <p>This file has been generated from an observed hydrograph, with data saved every \\(5\\)min, in second from the begining of the simulation (or event):</p> <p></p> <p>For each new river, just add the a similar river input line in the parameter file.</p>"},{"location":"tutorial/TutorialRiver/#timekeeping-parameters","title":"Timekeeping parameters","text":"<p>In this code, the time is defined in second, relative to some reference or the start of the simulation by default.</p> <p>The end of the simulation is prescribed in second as : </p><pre><code>endtime = 21600;\n</code></pre> <p>The time steps can't be defined by the used, it will be automatically computed as the more restrictive one in the domain by the solver, using the prescribe CFL (Current Friedrich Limiter) value, \\(CFL=0.5000\\) by default.</p> <p>The simulation begin, by default at \\(t=0(s)\\), but this can modify using \"totaltime\":  </p><pre><code>totaltime = 3600;\n</code></pre> to begin one hour after the reference time (used in the forcings for example).  <p>Note</p> <p>The code was initially designed to consider time only through duration in second. We can now use dates to defined time in the forcings and the param file, including a time reference. </p>"},{"location":"tutorial/TutorialRiver/#outputs","title":"Outputs","text":"<p>There is two types of outputs:</p> <ul> <li>map outputs of 2D variables regularly through time</li> <li>time-serie (TS) output of basic values, at a chosen point position, at each time step.</li> </ul>"},{"location":"tutorial/TutorialRiver/#map-outputs","title":"Map outputs","text":"<p>By default, there is only a map output at the begining and end of the simulation.</p> <p>The map output can be modify by:</p> <ul> <li>defining a timestep (in s) for these outputs: <pre><code>outputtimestep = 3600.0;\n</code></pre></li> <li>changing the set of variables in the output file (from the list given in the manual) <pre><code>outvars = zs,h,u,v,zb,hmax,Umax,hUmax,twet;\n</code></pre> The \"max\" variables will be the maximum value during the whole simulation. To reset it between the outputs, see the resetmax variable. There is also special variables for risk assesment after inundation (Umax, hmax, hUmax, twet)</li> <li>changing the name of the output file: <pre><code>outfile = Results_tuto_basicRun.nc;\n</code></pre></li> <li>saving the output as float (variables are saved as short integer by default.): <pre><code>smallnc = 0;\n</code></pre></li> </ul>"},{"location":"tutorial/TutorialRiver/#time-serie-outputs","title":"Time-Serie outputs","text":"<p>For each TS output needed, a line with the destination file and the postition is needed:</p> <p></p><pre><code>TSnodesout=Offshore.txt,1482120,53814890;\n</code></pre> corresponding to <code>TSnodesout=filename.txt,x_p,y_p;</code> The file contains 5 colums \\((t, zs, h, u,v)\\) with the value at the nearest grid point (to the position defined by the user)."},{"location":"tutorial/TutorialRiver/#resolution","title":"Resolution","text":"<p>For a first test, we will modify the resolution and set it to 40m to decrease the computational time: </p><pre><code>dx=40;\n</code></pre>"},{"location":"tutorial/TutorialRiver/#basic-fluvial-innundation-results","title":"Basic fluvial innundation results","text":"<p>This the shell output:  It shows that 1 river has been added to the model, and also the time progression with 5 map outputs (in addition to the initial time step).</p> <p>In the outputs, we get the different fields requested, for 6 different times. </p> <p>The Time-Serie output is: </p>"},{"location":"tutorial/TutorialRiver/#completing-the-set-up","title":"Completing the set-up","text":""},{"location":"tutorial/TutorialRiver/#adding-boundary-conditions","title":"Adding boundary conditions","text":"<p>Boundaries' conditions are refered by their position, using 'top/bottom/right/left' keywords. They are associated to a boundary type ( 0:wall; 1: Neumann (Default); 2:Dirichlet (zs); 3: abs1d) and possibly a file containing a time serie. In this case, the file name is placed before the type, coma-separated. </p> <p>In this case, we will use tide boundaries at when at least a part of the boundary is open on the sea, i.e. for the top, left and right boundaries. At the bottom, we will conserve the default value: 1. </p><pre><code>left = tide_westport.txt,2; \nright = tide_westport.txt,2; \ntop = tide_westport.txt,2; \n</code></pre> <p>In this case, as the boundaries are relatively small compared to the time wave length, we will used the same value along all the boundaries. We will then have only two columns in the file: Time and one elevation. tide_file </p>tide_westport.txt<pre><code>0.000000    0.714714 \n600.000000  0.794714 \n1200.000000     0.864714 \n1800.000000     0.934714 \n2400.000000     0.994714 \n3000.000000     1.054714 \n3600.000000     1.104714 \n4200.000000     1.144714 \n4800.000000     1.174714 \n5400.000000     1.194714 \n6000.000000     1.214714 \n6600.000000     1.214714 \n7200.000000     1.214714 \n7800.000000     1.204714 \n8400.000000     1.184714 \n          ...\n336600.000000   -0.635286 \n337200.000000   -0.705286 \n337800.000000   -0.765286 \n338400.000000   -0.825286 \n339000.000000   -0.875286 \n339600.000000   -0.915286 \n340200.000000   -0.955286 \n</code></pre> <p>They correspond to a classic time Serie observed offshore of the river mouth.</p> <p></p> <p>Note</p> <p>If more values are added to the file (more columns), they will be regularly spread along the boundary and the forcing will be linearly interpolated between these values. </p>"},{"location":"tutorial/TutorialRiver/#bottom-friction","title":"Bottom friction","text":"<p>Different models from bottom friction are available. By default, the model used is -1 corresponding to a Manning model. Here, we will use the model 1 corresponding to a roughness length (see manual for more information on the Bottom friction models). The associated field (ASC or netCDF) or value must be enter with the key word </p><pre><code>frictionmodel=1;\ncf=z0_100423_rec3.asc; #cf=0.01;  #If using a uniform value\n</code></pre> <p></p> <p>Warning</p> <p>The model allows a roughness heigh or manning number map smaller than the computational domain and will extrapolate outside of the map.</p>"},{"location":"tutorial/TutorialRiver/#initialisation","title":"Initialisation","text":"<p>By default, the model is initialised by a plane water surface located at \\(z=0.0\\).</p> <p>This water level can be modify, depending of the local mean sea level and the vertical projection used to create the DEM, using: </p><pre><code>zsinit=-1.39; #in metre\n</code></pre> The model can also be initialised using a restart/hot start. A file containing a least the files zb, h or zs, u and v must be provided, with the steps (and no the time value) to use for the restart. <pre><code>hotstartfile = output_4.nc;\nhotstep=5;\n</code></pre> <p>Warning</p> <p>the code can be restarted only from an uniform grid (and not from results with multi-level of resolutions).</p>"},{"location":"tutorial/TutorialRiver/#model-controls","title":"Model controls","text":"<p>Some variables can be used to adjust the model (see Manual for more details):</p> <ul> <li>run on CPU (or choose a GPU to run on): <pre><code>gpudevice=0;\n</code></pre> By default, the code will detect if there is a suitable GPU on the machine.</li> <li>Double precision instead of a float precision during the computation: <pre><code>doubleprecision = 1;\n</code></pre></li> <li>Minmod limiter parameter (to tune momentum dissipation \\(\\in [1,2]\\)) <pre><code>theta=1.3; #default value=1.3\n</code></pre></li> <li>Minimum heigh to concidere a cell wet (m) <pre><code>eps = 0.00010000; #default=0.0001\n</code></pre></li> </ul>"},{"location":"tutorial/TutorialRiver/#adding-the-rain","title":"... Adding the rain","text":"<p>The model allows rain on grid forcing to model pluvial inundations.</p>"},{"location":"tutorial/TutorialRiver/#rain-forcing","title":"Rain forcing","text":"<p>A rain intensity in \\(mm.h^{-1}\\), time and space varying can be forced in the model.</p> <p>The rain can be forced with a time serie (with uniform values on the domain) or a netCDF file if a spacial file is available:</p> <ul> <li>Time serie forcing: <pre><code>rainfall=rain_westport.txt\n</code></pre></li> <li>Spacial file forcing: <pre><code>rainfile=VCSN_buller_202107_dailynzcsmcov_disaggdaily_500m_nztm_clipped.nc?depth;\n</code></pre> Here, we will use a time serie: </li> </ul> <p>If the data is given in \"rain height\", a post-processing to turn it in rain intensity will be needed (at least at this stage of development).</p> <p>Using the rain on grid forcing will activate all the cells of the domain and will increase the computational time of the simulation.  Part of the domain can be \"de-activate\" (the blocs memory will not be allocated for this area) using different methods:</p> <ul> <li>using the <code>x0</code> / <code>xmax</code> / <code>y0</code> / <code>ymax</code> keywords to restrain the extend of the computational domain (but still rectangular) <pre><code>x0=1475000; #m\n</code></pre></li> <li>a manual mask with values 999 in the bathymetry will be read by the code as \"non-active\" area</li> <li>masking all the bloc with all cells having an elevation superior to some value: <pre><code>mask=250; #m\n</code></pre></li> <li>using a shape file to define a \"area of interest\": <pre><code>AOI=Domain_buffered-sea2.gmt;\n</code></pre></li> </ul> <p>Method advised</p> <p>The last method, consisting in using a contour to identify the area we want to include, is advised as the method allows for example to select a catchment, or any complex contour shape. The expected shape is a *.gmt file that can be generated from a contour using GMT tools or directly as a column of x,y points looped (first point = last point).</p>"},{"location":"tutorial/TutorialRiver/#refining-the-grid-in-area-of-interest","title":"Refining the grid in area of interest","text":"<p>The code is based on a Block-uniform quadtree mesh. Each block, actually a 16 by 16 cells, is one unit of computation in the GPU. These blocks can have different resolutions (but resolution does not change during the computation at this stage).</p> <p>The initial resolution of the grid is the resolution of the bathymetry/topographic data. To refine or coarsen the grid, you can weather use the \"dx\" key word and choose a new resolution for the whole domain; wether use the levels of resolution. The reference level, correponding to the bathymetry resolution will be the level 0. Levels of resolution are then defined in relation to the reference levels using positive integers to increase the resolution or refine and negative integer to coarsen the grid by a multiple of two. For a given level  \\(n\\) , the resolution  \\(dx_n\\) will be: $$ dx_n=\\frac{dx_0}{2^n} $$</p> <p>with  \\(dx_0\\) the resolution at level 0. </p> <p>When refinning using the level implementation, different key words are expected:</p> <ul> <li><code>Initlevel</code>: level used to create the first mesh created by the code in the mesh refinement process</li> <li><code>Maxlevel</code>: maximim level of refinement (over-ruling other commands)</li> <li><code>Minlevel</code>: minimum level of refinement (over-ruling other commands)</li> </ul> <p>The grid can also be unregular with an adaptition of the grid to the model (variables at initialisation step or user-defined refinement map). In this case, the cells will be devided in 4 cells for refinement, or 4 cells merged in one for coarsening. The code will ensure a progressive change of resolution (no cell should have a neighbour with more than 1 level of resolution of difference.)</p> <p>The different methods of refinement available in the code are called using the key word \"Adaptation\". The refinement can be based on a classical input variable or a variable calculated during the initialisation:</p> <ul> <li><code>Threshold</code>: impose a threshold for a different level of resolution</li> <li><code>Inrange</code>: impose a range for a different level of resolutuion or it can be defined using a map of target levels for refinement:</li> <li><code>Targetlevel</code>: the levels of resolution will be targeted but will be overruled by the maxlevel, minlevel entrance.</li> </ul> <p>To refine the grid for this case, we will use the former coarse simulation and create a map for values where hmax is strictly positive (and/or \\(umax\\),\\(vmax\\) different from zero), after removing the sea area. </p> <p>Here, the bathymetry map resolution is a 10m resolution (\\(dx=10m\\)). We will impose:</p> <ul> <li>a level -3 resolution ( \\(dx_{-3}=80m\\)) in the background domain, </li> <li>a level 1 resolution ( \\(dx_1=5m\\)) in the flooded area</li> <li>a level 2 resolution ( \\(dx_2=2.5m\\))  in the main river bed area. </li> </ul> Maximum water depth obtained using a coarse uniform mesh, used to inform refinement. Refinement map obtained based on coarse model, used to enforce refinement. Mesh refinement generated by the code. <p>To use it, the following options need to be added to the param file: </p><pre><code>initlevel = -3 ;\nmaxlevel = 2 ;\nminlevel = -3 ;\nAdaptation = Targetlevel,refin_mask.nc?z ;\n</code></pre> <p>Note</p> <p>In order to optimise the results when using a refined grid, different bathymetry files can be provided. A higher resolution one with smaller extend can be provided as a second DEM and will be use by the code when refining the grid (the code will use the last entered, having the info available):  </p><pre><code>DEM = Wesport_DEM_8m.nc?z;\nDEM = Wesport_DEM_2m_zoomed.nc?z;\n</code></pre>  Similarly, different input files can be used for the roughness coefficient.  <p>Note again ...</p> <p>The code also allows for zone outputs: the output of different zones defined by the user (<code>output-file-name,x1,x2,y1,y2</code>):  </p><pre><code>outzone=zoomed.nc,5.3,5.4,0.5,0.8;\n</code></pre>"},{"location":"tutorial/TutorialRiver/#results","title":"Results:","text":"<p>This is the logfile: </p>BG_log.txt<pre><code>#################################\nBG_Flood v0.8\n#################################\n#################################\n#\nmodel started at 21-02-2023 21:22:53\n\nReading parameter file: BG_param.txt ...\n\nReading bathymetry grid data...\nReading forcing metadata. file: Westport_DEM_8m.nc extension: nc\nForcing grid info: nx=2604 ny=3137 dx=8.000000 grdalpha=0.000000 xo=1474101.125000 xmax=1494925.125000 yo=5364343.000000 ymax=5389431.000000\n\nReading boundary data...\n\nRead Roughness map (cf) data...\nReading forcing metadata. file: z0_100423_rec3.asc extension: asc\nFor asc of bathy file please specify grdalpha in the BG_param.txt (default 0)\nForcing grid info: nx=1724 ny=2420 dx=4.800000 grdalpha=0.000000 xo=1480847.600000 xmax=1489118.000000 yo=5369291.600000 ymax=5380902.800000\n\nRead Target level data...\nReading forcing metadata. file: refin_mask.nc extension: nc\nForcing grid info: nx=624 ny=400 dx=50.000000 grdalpha=0.000000 xo=1469074.407363 xmax=1500224.407363 yo=5364597.770576 ymax=5384547.770576\n\nPreparing rivers (1 rivers)\n\nPreparing Rain forcing\n\nAdjusted model domain (xo/xmax/yo/ymax): \n    1474097.125000/1495057.125000/5364339.000000/5389459.000000\n     Initial resolution (level 2) = 10.000000\nThere are 1 GPU devices on this machine\nUsing Device: NVIDIA T500\n\nInitializing mesh\n    Initial number of blocks: 20567; Will be allocating 21596 in memory.\n\nInitial condition:\n    Warm start\n    Initializing rivers\nAdapting mesh\n     Iteration 1\n        There are 20567 active blocks (21596 blocks allocated in memory), 0 blocks to be refined, 4723 blocks to be coarsen (with neighbour); 1675 blocks untouched; 14169 blocks to be freed (1029 are already available) 0 new blocks will be created\n     Iteration 2\n        There are 6398 active blocks (21596 blocks allocated in memory), 0 blocks to be refined, 1023 blocks to be coarsen (with neighbour); 2306 blocks untouched; 3069 blocks to be freed (15198 are already available) 0 new blocks will be created\n     Iteration 3\n        There are 3329 active blocks (21596 blocks allocated in memory), 0 blocks to be refined, 179 blocks to be coarsen (with neighbour); 2613 blocks untouched; 537 blocks to be freed (18267 are already available) 0 new blocks will be created\n     Iteration 4\n        There are 2792 active blocks (21596 blocks allocated in memory), 0 blocks to be refined, 18 blocks to be coarsen (with neighbour); 2720 blocks untouched; 54 blocks to be freed (18804 are already available) 0 new blocks will be created\n     Iteration 5\n        There are 2738 active blocks (21596 blocks allocated in memory), 0 blocks to be refined, 1 blocks to be coarsen (with neighbour); 2734 blocks untouched; 3 blocks to be freed (18858 are already available) 0 new blocks will be created\n     Iteration 6\n        There are 2735 active blocks (21596 blocks allocated in memory), 0 blocks to be refined, 0 blocks to be coarsen (with neighbour); 2735 blocks untouched; 0 blocks to be freed (18861 are already available) 0 new blocks will be created\n\nInitial condition:\n    Warm start\n    Initializing rivers\nSetting up GPU\n\nModel setup complete\n#################################\nInitialising model main loop\nCreate netCDF output file...\nWarning! Output file name already exist   \nNew file name: Results_tuto_basicRun_2.nc\n        Completed\nModel Running...\nOutput to map. Totaltime = 7200.000000 s; Mean dt = 2.230207e-01 s\n</code></pre> In the model output, each resolution is store independently.  When open with pyncview, we can visualise each layer. QGIS can merge all these layer togather or a postratement steps will be needed. <p></p>"},{"location":"tutorial/TutorialRiver/#how-to-incorporate-more-complex-inputs","title":"How to incorporate more complex inputs","text":"<p>Some more complex inputs can be used in this type of realistic model:</p>"},{"location":"tutorial/TutorialRiver/#date-as-time-reference","title":"Date as time reference","text":"<p>Up to here, the time was define as a duration in second from an arbitrary reference (begining of the simulation for example). All the inputs and the BG_param.txt file used this definition. Due to this convention, most of the inputs had to be modified to change date to duration in seconds, and the resluts are also in second (which can be confusing). The solver can use dates in the inputs (same time zone for all dates) and in the BG_param.txt, as:</p> <pre><code>reftime = 2018-02-16T01:00:00\n\nstarttime = 2018-02-16T02:00:00\n\noutputtimestep = 3600.000000\n\nendtime = 2018-02-18T17:00:00\n</code></pre> <p>where:</p> <ul> <li><code>reftime</code> is the reference time for the simulation</li> <li>time convention is : \\(yyyy-mm-dd\\textbf{T}hh:mm:ss\\)</li> </ul>"},{"location":"tutorial/TutorialRiver/#map-boundary-conditions","title":"Map boundary conditions","text":"<p>To improve the boundary forcing, there is possibility to use a netcdf file associated to contours to define the boundary based on a time evolving 2D surface. It can be use to impose water elevation to impose tide or any open-water forcing for example, specially in a nested configuration.</p> <p></p><pre><code>bndseg = tidebndpoly.bnd,tidebnd.nc,3;\n\nbndtaper = 7200.000000\n</code></pre> where: -  <code>tidebnb.nc</code> is a 2D time varying map of water surface elevation. - <code>3</code> is the type of boundary (absorbing boundary). - <code>tidebndpoly.bnd</code> is a polygon where the boundary is applied - <code>bndtaper</code> is the duration of the relaxation of the boundary (\\(s\\)) <p>As mention earlier, the computationnal domain can be define (or more specifically reduce from default DEM based domain) using an \"aoi\" (area of interest) which consist in a looped list of points. The boundary by default along it is a wall but can be modified by the following parameter <code>aoibnd</code>:</p> <pre><code>aoi = aoi_BGFLOOD.txt\n\naoibnd = 3;\n</code></pre>"},{"location":"tutorial/TutorialRiver/#multi-demroughness-inputs","title":"Multi DEM/roughness inputs","text":"<p>The code support different inputs of DEMs or roughness maps. It will use the first DEM to define the computational extend by default. Then, for each grid point, it will use the last DEM provided where a valide value is defined at this location. One can for example provide a low resolution DEM of all the domain then add a high resolution of a given urban area if higher resolution will be sought after there. Similar set-up is also allowed for roughness maps. </p><pre><code># DEM for the full domain, 8m resolution\ntopofile = geofabric_8m_rupp_and_smart.nc?z;\n\n# DEM for the urban center, 2m resolution\ntopofile = geofabric_2m_town.nc?z;\n</code></pre>"},{"location":"tutorial/TutorialRiver/#multi-river-injection","title":"Multi river injection","text":"<p>Any number of river injection can be added (tested up to a thousand). Just repeat the river injection line as many times as needed.</p>"},{"location":"tutorial/TutorialRiver/#full-bg_paramtxt-file","title":"Full BG_param.txt file","text":"<pre><code>##########\n# DEM    #\n##########\n\n# DEM for the full domain, 8m resolution\ntopofile = geofabric_8m_rupp_and_smart.nc?z;\n\n# DEM for the urban center, 2m resolution\ntopofile = geofabric_2m_town.nc?z;\n\n\nxmin = 1465335.000000\nxmax = 1497847.000000\nymin = 5351567.000000\nymax = 5388175.000000\naoi = aoi_BGFLOOD.txt\ndx = 64.000000\n\n##############\n# Forcing    #\n##############\n\nzsoffset = 0.000000\nzsinit = -1.000000\nfrictionmodel = 1\ncfmap = Roughness.nc?zo\n\nrainfile =outputrain_test.nc?depth\n\n##########\n# Rivers #\n##########\n\n\n\n\n###############\n# Adaptation  #\n###############\n\ninitlevel = 0\nAdaptation = Targetlevel,refine_mask_town.nc\nminlevel = 0\nmaxlevel = 4\n\n################\n# Boundaries   #\n################\n\naoibnd = 3;\nbndseg = tidebndpoly.bnd,tidebnd.nc,3;\n\n#############\n# Timing    #\n#############\n\nbndtaper = 7200.000000\n\nreftime = 2018-02-16T01:00:00\n\nstarttime = 2018-02-16T02:00:00\n\noutputtimestep = 3600.000000\n\nendtime = 2018-02-18T17:00:00\n\n#############\n# Others    #\n#############\n\ngpudevice = 0\n\nvmax = 10.000000\n\n#############\n# Output    #\n#############\n\nsmallnc = 0\n\nsavebyblk= false\n\noutvars = zs, u, v, h, hmax, zsmax, U, hUmax, Umax;\n\noutfile = Westport_Inundation.nc\n</code></pre> <p>Note</p> <p>This is a real configuration run that would take about 15h on a A100 GPU. Not to be run on laptop GPU, but can be tested locally with decreased resolution (<code>dx</code>)</p>"},{"location":"tutorial/TutorialRiver/#ground-infiltration-losses-basic-ilcl-model","title":"Ground infiltration losses (Basic ILCL model)","text":"<p>An Initial Loss, Continuous Loss model has been implemented in the code (see ILCL page).  </p> <p>To use it, provide maps for the two coefficient as follow:</p> <p></p><pre><code>initialloss=InitialLoss.asc;\ncontinuousloss=ContinuousLoss.asc;\n</code></pre> NetCDF files can also be used for these inputs."},{"location":"tutorial/TutorialRiver/#_1","title":"Pluvial and fluvial flooding","text":""},{"location":"BGFlood/annotated/","title":"List","text":""},{"location":"BGFlood/annotated/#class-list","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class AOIinfo </li> <li>struct AdaptP </li> <li>struct AdvanceP Structure holding advance variables for time stepping. </li> <li>struct BlockP </li> <li>struct BndblockP </li> <li>struct DynForcingP </li> <li>struct EvolvingMLP Structure holding evolving variables (no z relative variables). </li> <li>struct EvolvingP Structure holding evolving physical variables. </li> <li>struct EvolvingP_M Structure for mean/max evolving variables, inherits from EvolvingP . </li> <li>class Flowin </li> <li>struct FluxMLP Structure holding flux variables (no z relative variables). </li> <li>struct FluxP Structure holding flux variables for advection. </li> <li>struct Forcing </li> <li>struct GradientsMLP Structure holding gradient arrays (no z relative variables). </li> <li>struct GradientsP Structure holding gradient arrays for physical variables. </li> <li>struct Loop </li> <li>class Mapparam </li> <li>struct Model </li> <li>class Param </li> <li>class Pointout </li> <li>class Polygon </li> <li>class River </li> <li>struct RiverBlk </li> <li>struct RiverInfo </li> <li>class SLTS </li> <li>struct SharedMemory </li> <li>struct SharedMemory&lt; double &gt; </li> <li>struct StaticForcingP </li> <li>class TSoutnode </li> <li>class T_output </li> <li>struct TexSetP </li> <li>struct TimeP </li> <li>class Vertex </li> <li>class Windin </li> <li>struct bndTexP </li> <li>class bndparam </li> <li>class bndsegment </li> <li>class bndsegmentside </li> <li>class deformmap </li> <li>class forcingmap </li> <li>class inputmap </li> <li>struct maskinfo </li> <li>struct outP </li> <li>struct outzoneB </li> <li>class outzoneP </li> <li>namespace utils </li> </ul>"},{"location":"BGFlood/files/","title":"Files","text":""},{"location":"BGFlood/files/#file-list","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir src <ul> <li>file AdaptCriteria.cu </li> <li>file AdaptCriteria.h </li> <li>file Adaptation.cu </li> <li>file Adaptation.h </li> <li>file Advection.cu </li> <li>file Advection.h </li> <li>file Arrays.h </li> <li>file BG_Flood.cu </li> <li>file BG_Flood.h </li> <li>file Boundary.cu </li> <li>file Boundary.h </li> <li>file ConserveElevation.cu </li> <li>file ConserveElevation.h </li> <li>file FlowCPU.cu </li> <li>file FlowCPU.h </li> <li>file FlowGPU.cu </li> <li>file FlowGPU.h </li> <li>file FlowMLGPU.cu </li> <li>file FlowMLGPU.h </li> <li>file Forcing.h </li> <li>file Friction.cu </li> <li>file Friction.h </li> <li>file General.h </li> <li>file Gradients.cu </li> <li>file Gradients.h </li> <li>file GridManip.cu </li> <li>file GridManip.h </li> <li>file Halo.cu </li> <li>file Halo.h </li> <li>file InitEvolv.cu </li> <li>file InitEvolv.h </li> <li>file InitialConditions.cu </li> <li>file InitialConditions.h </li> <li>file Input.h </li> <li>file Kurganov.cu </li> <li>file Kurganov.h </li> <li>file Mainloop.cu </li> <li>file Mainloop.h </li> <li>file Meanmax.cu </li> <li>file Meanmax.h </li> <li>file MemManagement.cu </li> <li>file MemManagement.h </li> <li>file Mesh.cu Mesh initialization and management routines for BG_Flood GPU model. </li> <li>file Mesh.h </li> <li>file Multilayer.cu </li> <li>file Multilayer.h </li> <li>file Param.h </li> <li>file Poly.cu </li> <li>file Poly.h </li> <li>file ReadForcing.cu </li> <li>file ReadForcing.h </li> <li>file ReadInput.cu </li> <li>file ReadInput.h </li> <li>file Read_netcdf.cu </li> <li>file Read_netcdf.h </li> <li>file Reimann.cu </li> <li>file Reimann.h </li> <li>file Setup_GPU.cu </li> <li>file Setup_GPU.h </li> <li>file Spherical.cu </li> <li>file Spherical.h </li> <li>file Testing.cu </li> <li>file Testing.h </li> <li>file Updateforcing.cu </li> <li>file Updateforcing.h </li> <li>file Util_CPU.cu </li> <li>file Util_CPU.h </li> <li>file Write_netcdf.cu </li> <li>file Write_netcdf.h </li> <li>file Write_txtlog.cpp </li> <li>file Write_txtlog.h </li> <li>file utctime.cu </li> <li>file utctime.h </li> </ul> </li> </ul>"},{"location":"BGFlood/class_a_o_iinfo/","title":"Class AOIinfo","text":""},{"location":"BGFlood/class_a_o_iinfo/#class-aoiinfo","title":"Class AOIinfo","text":"<p>ClassList &gt; AOIinfo</p>"},{"location":"BGFlood/class_a_o_iinfo/#public-attributes","title":"Public Attributes","text":"Type Name bool active   = <code>false</code> std::string file Polygon poly"},{"location":"BGFlood/class_a_o_iinfo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/class_a_o_iinfo/#variable-active","title":"variable active","text":"<pre><code>bool AOIinfo::active;\n</code></pre>"},{"location":"BGFlood/class_a_o_iinfo/#variable-file","title":"variable file","text":"<pre><code>std::string AOIinfo::file;\n</code></pre>"},{"location":"BGFlood/class_a_o_iinfo/#variable-poly","title":"variable poly","text":"<pre><code>Polygon AOIinfo::poly;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/struct_adapt_p/","title":"Struct AdaptP","text":""},{"location":"BGFlood/struct_adapt_p/#struct-adaptp","title":"Struct AdaptP","text":"<p>ClassList &gt; AdaptP</p>"},{"location":"BGFlood/struct_adapt_p/#public-attributes","title":"Public Attributes","text":"Type Name int * availblk bool * coarsen int * csumblk int * invactive int * newlevel bool * refine"},{"location":"BGFlood/struct_adapt_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_adapt_p/#variable-availblk","title":"variable availblk","text":"<pre><code>int* AdaptP::availblk;\n</code></pre>"},{"location":"BGFlood/struct_adapt_p/#variable-coarsen","title":"variable coarsen","text":"<pre><code>bool* AdaptP::coarsen;\n</code></pre>"},{"location":"BGFlood/struct_adapt_p/#variable-csumblk","title":"variable csumblk","text":"<pre><code>int * AdaptP::csumblk;\n</code></pre>"},{"location":"BGFlood/struct_adapt_p/#variable-invactive","title":"variable invactive","text":"<pre><code>int* AdaptP::invactive;\n</code></pre>"},{"location":"BGFlood/struct_adapt_p/#variable-newlevel","title":"variable newlevel","text":"<pre><code>int* AdaptP::newlevel;\n</code></pre>"},{"location":"BGFlood/struct_adapt_p/#variable-refine","title":"variable refine","text":"<pre><code>bool * AdaptP::refine;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/struct_advance_p/","title":"Struct AdvanceP","text":""},{"location":"BGFlood/struct_advance_p/#struct-advancep","title":"Struct AdvanceP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; AdvanceP</p> <p>Structure holding advance variables for time stepping. More...</p> <ul> <li><code>#include &lt;Arrays.h&gt;</code></li> </ul>"},{"location":"BGFlood/struct_advance_p/#public-attributes","title":"Public Attributes","text":"Type Name T * dh T * dhu T * dhv"},{"location":"BGFlood/struct_advance_p/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul>"},{"location":"BGFlood/struct_advance_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_advance_p/#variable-dh","title":"variable dh","text":"<pre><code>T* AdvanceP&lt; T &gt;::dh;\n</code></pre> <p>Change in water depth </p>"},{"location":"BGFlood/struct_advance_p/#variable-dhu","title":"variable dhu","text":"<pre><code>T* AdvanceP&lt; T &gt;::dhu;\n</code></pre> <p>Change in velocity u </p>"},{"location":"BGFlood/struct_advance_p/#variable-dhv","title":"variable dhv","text":"<pre><code>T* AdvanceP&lt; T &gt;::dhv;\n</code></pre> <p>Change in velocity v </p> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/struct_block_p/","title":"Struct BlockP","text":""},{"location":"BGFlood/struct_block_p/#struct-blockp","title":"Struct BlockP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; BlockP</p>"},{"location":"BGFlood/struct_block_p/#public-attributes","title":"Public Attributes","text":"Type Name int * BotLeft int * BotRight int * LeftBot int * LeftTop int * RightBot int * RightTop int * TopLeft int * TopRight int * active int * activeCell int * level maskinfo mask std::vector&lt; outzoneB &gt; outZone T * xo T * yo"},{"location":"BGFlood/struct_block_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_block_p/#variable-botleft","title":"variable BotLeft","text":"<pre><code>int* BlockP&lt; T &gt;::BotLeft;\n</code></pre>"},{"location":"BGFlood/struct_block_p/#variable-botright","title":"variable BotRight","text":"<pre><code>int * BlockP&lt; T &gt;::BotRight;\n</code></pre>"},{"location":"BGFlood/struct_block_p/#variable-leftbot","title":"variable LeftBot","text":"<pre><code>int* BlockP&lt; T &gt;::LeftBot;\n</code></pre>"},{"location":"BGFlood/struct_block_p/#variable-lefttop","title":"variable LeftTop","text":"<pre><code>int * BlockP&lt; T &gt;::LeftTop;\n</code></pre>"},{"location":"BGFlood/struct_block_p/#variable-rightbot","title":"variable RightBot","text":"<pre><code>int* BlockP&lt; T &gt;::RightBot;\n</code></pre>"},{"location":"BGFlood/struct_block_p/#variable-righttop","title":"variable RightTop","text":"<pre><code>int * BlockP&lt; T &gt;::RightTop;\n</code></pre>"},{"location":"BGFlood/struct_block_p/#variable-topleft","title":"variable TopLeft","text":"<pre><code>int* BlockP&lt; T &gt;::TopLeft;\n</code></pre>"},{"location":"BGFlood/struct_block_p/#variable-topright","title":"variable TopRight","text":"<pre><code>int * BlockP&lt; T &gt;::TopRight;\n</code></pre>"},{"location":"BGFlood/struct_block_p/#variable-active","title":"variable active","text":"<pre><code>int* BlockP&lt; T &gt;::active;\n</code></pre>"},{"location":"BGFlood/struct_block_p/#variable-activecell","title":"variable activeCell","text":"<pre><code>int* BlockP&lt; T &gt;::activeCell;\n</code></pre>"},{"location":"BGFlood/struct_block_p/#variable-level","title":"variable level","text":"<pre><code>int* BlockP&lt; T &gt;::level;\n</code></pre>"},{"location":"BGFlood/struct_block_p/#variable-mask","title":"variable mask","text":"<pre><code>maskinfo BlockP&lt; T &gt;::mask;\n</code></pre>"},{"location":"BGFlood/struct_block_p/#variable-outzone","title":"variable outZone","text":"<pre><code>std::vector&lt;outzoneB&gt; BlockP&lt; T &gt;::outZone;\n</code></pre>"},{"location":"BGFlood/struct_block_p/#variable-xo","title":"variable xo","text":"<pre><code>T* BlockP&lt; T &gt;::xo;\n</code></pre>"},{"location":"BGFlood/struct_block_p/#variable-yo","title":"variable yo","text":"<pre><code>T * BlockP&lt; T &gt;::yo;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/struct_bndblock_p/","title":"Struct BndblockP","text":""},{"location":"BGFlood/struct_bndblock_p/#struct-bndblockp","title":"Struct BndblockP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; BndblockP</p>"},{"location":"BGFlood/struct_bndblock_p/#public-attributes","title":"Public Attributes","text":"Type Name RiverInfo&lt; T &gt; Riverinfo int * Tsout int * bot int * left int nblkTs int nblkriver int nbndblkbot int nbndblkleft int nbndblkright int nbndblktop int * right int * river int * top"},{"location":"BGFlood/struct_bndblock_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_bndblock_p/#variable-riverinfo","title":"variable Riverinfo","text":"<pre><code>RiverInfo&lt;T&gt; BndblockP&lt; T &gt;::Riverinfo;\n</code></pre>"},{"location":"BGFlood/struct_bndblock_p/#variable-tsout","title":"variable Tsout","text":"<pre><code>int* BndblockP&lt; T &gt;::Tsout;\n</code></pre>"},{"location":"BGFlood/struct_bndblock_p/#variable-bot","title":"variable bot","text":"<pre><code>int* BndblockP&lt; T &gt;::bot;\n</code></pre>"},{"location":"BGFlood/struct_bndblock_p/#variable-left","title":"variable left","text":"<pre><code>int* BndblockP&lt; T &gt;::left;\n</code></pre>"},{"location":"BGFlood/struct_bndblock_p/#variable-nblkts","title":"variable nblkTs","text":"<pre><code>int BndblockP&lt; T &gt;::nblkTs;\n</code></pre>"},{"location":"BGFlood/struct_bndblock_p/#variable-nblkriver","title":"variable nblkriver","text":"<pre><code>int BndblockP&lt; T &gt;::nblkriver;\n</code></pre>"},{"location":"BGFlood/struct_bndblock_p/#variable-nbndblkbot","title":"variable nbndblkbot","text":"<pre><code>int BndblockP&lt; T &gt;::nbndblkbot;\n</code></pre>"},{"location":"BGFlood/struct_bndblock_p/#variable-nbndblkleft","title":"variable nbndblkleft","text":"<pre><code>int BndblockP&lt; T &gt;::nbndblkleft;\n</code></pre>"},{"location":"BGFlood/struct_bndblock_p/#variable-nbndblkright","title":"variable nbndblkright","text":"<pre><code>int BndblockP&lt; T &gt;::nbndblkright;\n</code></pre>"},{"location":"BGFlood/struct_bndblock_p/#variable-nbndblktop","title":"variable nbndblktop","text":"<pre><code>int BndblockP&lt; T &gt;::nbndblktop;\n</code></pre>"},{"location":"BGFlood/struct_bndblock_p/#variable-right","title":"variable right","text":"<pre><code>int* BndblockP&lt; T &gt;::right;\n</code></pre>"},{"location":"BGFlood/struct_bndblock_p/#variable-river","title":"variable river","text":"<pre><code>int* BndblockP&lt; T &gt;::river;\n</code></pre>"},{"location":"BGFlood/struct_bndblock_p/#variable-top","title":"variable top","text":"<pre><code>int* BndblockP&lt; T &gt;::top;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/struct_dyn_forcing_p/","title":"Struct DynForcingP","text":""},{"location":"BGFlood/struct_dyn_forcing_p/#struct-dynforcingp","title":"Struct DynForcingP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; DynForcingP</p> <p>Inherits the following classes: forcingmap</p>"},{"location":"BGFlood/struct_dyn_forcing_p/#public-attributes","title":"Public Attributes","text":"Type Name T * after T * after_g T * before T * before_g T clampedge   = <code>0.0</code> T * now T * now_g T * val"},{"location":"BGFlood/struct_dyn_forcing_p/#public-attributes-inherited-from-forcingmap","title":"Public Attributes inherited from forcingmap","text":"<p>See forcingmap</p> Type Name TexSetP GPU double dt std::string inputfile int instep   = <code>0</code> double nowvalue int nt double tmax double to std::vector&lt; Windin &gt; unidata bool uniform   = <code>false</code>"},{"location":"BGFlood/struct_dyn_forcing_p/#public-attributes-inherited-from-inputmap","title":"Public Attributes inherited from inputmap","text":"<p>See inputmap</p> Type Name double denanval   = <code>NAN</code> double dx   = <code>0.0</code> double dy   = <code>0.0</code> std::string extension bool flipxx   = <code>false</code> bool flipyy   = <code>false</code> double grdalpha   = <code>0.0</code> std::string inputfile int nx   = <code>0</code> int ny   = <code>0</code> std::string varname double xmax   = <code>0.0</code> double xo   = <code>0.0</code> double ymax   = <code>0.0</code> double yo   = <code>0.0</code>"},{"location":"BGFlood/struct_dyn_forcing_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_dyn_forcing_p/#variable-after","title":"variable after","text":"<pre><code>T * DynForcingP&lt; T &gt;::after;\n</code></pre>"},{"location":"BGFlood/struct_dyn_forcing_p/#variable-after_g","title":"variable after_g","text":"<pre><code>T * DynForcingP&lt; T &gt;::after_g;\n</code></pre>"},{"location":"BGFlood/struct_dyn_forcing_p/#variable-before","title":"variable before","text":"<pre><code>T* DynForcingP&lt; T &gt;::before;\n</code></pre>"},{"location":"BGFlood/struct_dyn_forcing_p/#variable-before_g","title":"variable before_g","text":"<pre><code>T* DynForcingP&lt; T &gt;::before_g;\n</code></pre>"},{"location":"BGFlood/struct_dyn_forcing_p/#variable-clampedge","title":"variable clampedge","text":"<pre><code>T DynForcingP&lt; T &gt;::clampedge;\n</code></pre>"},{"location":"BGFlood/struct_dyn_forcing_p/#variable-now","title":"variable now","text":"<pre><code>T* DynForcingP&lt; T &gt;::now;\n</code></pre>"},{"location":"BGFlood/struct_dyn_forcing_p/#variable-now_g","title":"variable now_g","text":"<pre><code>T* DynForcingP&lt; T &gt;::now_g;\n</code></pre>"},{"location":"BGFlood/struct_dyn_forcing_p/#variable-val","title":"variable val","text":"<pre><code>T* DynForcingP&lt; T &gt;::val;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/struct_evolving_m_l_p/","title":"Struct EvolvingMLP","text":""},{"location":"BGFlood/struct_evolving_m_l_p/#struct-evolvingmlp","title":"Struct EvolvingMLP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; EvolvingMLP</p> <p>Structure holding evolving variables (no z relative variables). More...</p> <ul> <li><code>#include &lt;Arrays.h&gt;</code></li> </ul>"},{"location":"BGFlood/struct_evolving_m_l_p/#public-attributes","title":"Public Attributes","text":"Type Name T * h T * u T * v"},{"location":"BGFlood/struct_evolving_m_l_p/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul>"},{"location":"BGFlood/struct_evolving_m_l_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_evolving_m_l_p/#variable-h","title":"variable h","text":"<pre><code>T* EvolvingMLP&lt; T &gt;::h;\n</code></pre> <p>Water depth </p>"},{"location":"BGFlood/struct_evolving_m_l_p/#variable-u","title":"variable u","text":"<pre><code>T* EvolvingMLP&lt; T &gt;::u;\n</code></pre> <p>Velocity u </p>"},{"location":"BGFlood/struct_evolving_m_l_p/#variable-v","title":"variable v","text":"<pre><code>T* EvolvingMLP&lt; T &gt;::v;\n</code></pre> <p>Velocity v </p> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/struct_evolving_p/","title":"Struct EvolvingP","text":""},{"location":"BGFlood/struct_evolving_p/#struct-evolvingp","title":"Struct EvolvingP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; EvolvingP</p> <p>Structure holding evolving physical variables. More...</p> <ul> <li><code>#include &lt;Arrays.h&gt;</code></li> </ul> <p>Inherited by the following classes: EvolvingP_M</p>"},{"location":"BGFlood/struct_evolving_p/#public-attributes","title":"Public Attributes","text":"Type Name T * h T * u T * v T * zs"},{"location":"BGFlood/struct_evolving_p/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul>"},{"location":"BGFlood/struct_evolving_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_evolving_p/#variable-h","title":"variable h","text":"<pre><code>T* EvolvingP&lt; T &gt;::h;\n</code></pre> <p>Water depth </p>"},{"location":"BGFlood/struct_evolving_p/#variable-u","title":"variable u","text":"<pre><code>T* EvolvingP&lt; T &gt;::u;\n</code></pre> <p>X velocity component u </p>"},{"location":"BGFlood/struct_evolving_p/#variable-v","title":"variable v","text":"<pre><code>T* EvolvingP&lt; T &gt;::v;\n</code></pre> <p>Y velocity component v </p>"},{"location":"BGFlood/struct_evolving_p/#variable-zs","title":"variable zs","text":"<pre><code>T* EvolvingP&lt; T &gt;::zs;\n</code></pre> <p>Surface elevation </p> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/struct_evolving_p___m/","title":"Struct EvolvingP_M","text":""},{"location":"BGFlood/struct_evolving_p___m/#struct-evolvingp_m","title":"Struct EvolvingP_M","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; EvolvingP_M</p> <p>Structure for mean/max evolving variables, inherits from EvolvingP .More...</p> <ul> <li><code>#include &lt;Arrays.h&gt;</code></li> </ul> <p>Inherits the following classes: EvolvingP</p>"},{"location":"BGFlood/struct_evolving_p___m/#public-attributes","title":"Public Attributes","text":"Type Name T * U T * hU"},{"location":"BGFlood/struct_evolving_p___m/#public-attributes-inherited-from-evolvingp","title":"Public Attributes inherited from EvolvingP","text":"<p>See EvolvingP</p> Type Name T * h T * u T * v T * zs"},{"location":"BGFlood/struct_evolving_p___m/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul>"},{"location":"BGFlood/struct_evolving_p___m/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_evolving_p___m/#variable-u","title":"variable U","text":"<pre><code>T* EvolvingP_M&lt; T &gt;::U;\n</code></pre> <p>Norm of the velocity </p>"},{"location":"BGFlood/struct_evolving_p___m/#variable-hu","title":"variable hU","text":"<pre><code>T* EvolvingP_M&lt; T &gt;::hU;\n</code></pre> <p>Product of water depth and velocity norm </p> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/class_flowin/","title":"Class Flowin","text":""},{"location":"BGFlood/class_flowin/#class-flowin","title":"Class Flowin","text":"<p>ClassList &gt; Flowin</p>"},{"location":"BGFlood/class_flowin/#public-attributes","title":"Public Attributes","text":"Type Name double q double time"},{"location":"BGFlood/class_flowin/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/class_flowin/#variable-q","title":"variable q","text":"<pre><code>double Flowin::q;\n</code></pre>"},{"location":"BGFlood/class_flowin/#variable-time","title":"variable time","text":"<pre><code>double Flowin::time;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/struct_flux_m_l_p/","title":"Struct FluxMLP","text":""},{"location":"BGFlood/struct_flux_m_l_p/#struct-fluxmlp","title":"Struct FluxMLP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; FluxMLP</p> <p>Structure holding flux variables (no z relative variables). More...</p> <ul> <li><code>#include &lt;Arrays.h&gt;</code></li> </ul>"},{"location":"BGFlood/struct_flux_m_l_p/#public-attributes","title":"Public Attributes","text":"Type Name T * Fux T * Fuy T * Fvx T * Fvy T * hau T * hav T * hfu T * hfv T * hu T * hv"},{"location":"BGFlood/struct_flux_m_l_p/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul>"},{"location":"BGFlood/struct_flux_m_l_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_flux_m_l_p/#variable-fux","title":"variable Fux","text":"<pre><code>T* FluxMLP&lt; T &gt;::Fux;\n</code></pre> <p>Flux of u in x-direction </p>"},{"location":"BGFlood/struct_flux_m_l_p/#variable-fuy","title":"variable Fuy","text":"<pre><code>T* FluxMLP&lt; T &gt;::Fuy;\n</code></pre> <p>Flux of u in y-direction </p>"},{"location":"BGFlood/struct_flux_m_l_p/#variable-fvx","title":"variable Fvx","text":"<pre><code>T* FluxMLP&lt; T &gt;::Fvx;\n</code></pre> <p>Flux of v in x-direction </p>"},{"location":"BGFlood/struct_flux_m_l_p/#variable-fvy","title":"variable Fvy","text":"<pre><code>T* FluxMLP&lt; T &gt;::Fvy;\n</code></pre> <p>Flux of v in y-direction </p>"},{"location":"BGFlood/struct_flux_m_l_p/#variable-hau","title":"variable hau","text":"<pre><code>T* FluxMLP&lt; T &gt;::hau;\n</code></pre> <p>h*a flux in u-direction </p>"},{"location":"BGFlood/struct_flux_m_l_p/#variable-hav","title":"variable hav","text":"<pre><code>T* FluxMLP&lt; T &gt;::hav;\n</code></pre> <p>h*a flux in v-direction </p>"},{"location":"BGFlood/struct_flux_m_l_p/#variable-hfu","title":"variable hfu","text":"<pre><code>T* FluxMLP&lt; T &gt;::hfu;\n</code></pre> <p>h*f flux in u-direction </p>"},{"location":"BGFlood/struct_flux_m_l_p/#variable-hfv","title":"variable hfv","text":"<pre><code>T* FluxMLP&lt; T &gt;::hfv;\n</code></pre> <p>h*f flux in v-direction </p>"},{"location":"BGFlood/struct_flux_m_l_p/#variable-hu","title":"variable hu","text":"<pre><code>T* FluxMLP&lt; T &gt;::hu;\n</code></pre> <p>Water depth flux in u-direction </p>"},{"location":"BGFlood/struct_flux_m_l_p/#variable-hv","title":"variable hv","text":"<pre><code>T* FluxMLP&lt; T &gt;::hv;\n</code></pre> <p>Water depth flux in v-direction </p> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/struct_flux_p/","title":"Struct FluxP","text":""},{"location":"BGFlood/struct_flux_p/#struct-fluxp","title":"Struct FluxP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; FluxP</p> <p>Structure holding flux variables for advection. More...</p> <ul> <li><code>#include &lt;Arrays.h&gt;</code></li> </ul>"},{"location":"BGFlood/struct_flux_p/#public-attributes","title":"Public Attributes","text":"Type Name T * Fhu T * Fhv T * Fqux T * Fquy T * Fqvx T * Fqvy T * Su T * Sv"},{"location":"BGFlood/struct_flux_p/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul>"},{"location":"BGFlood/struct_flux_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_flux_p/#variable-fhu","title":"variable Fhu","text":"<pre><code>T* FluxP&lt; T &gt;::Fhu;\n</code></pre> <p>Flux of h in u-direction </p>"},{"location":"BGFlood/struct_flux_p/#variable-fhv","title":"variable Fhv","text":"<pre><code>T* FluxP&lt; T &gt;::Fhv;\n</code></pre> <p>Flux of h in v-direction </p>"},{"location":"BGFlood/struct_flux_p/#variable-fqux","title":"variable Fqux","text":"<pre><code>T* FluxP&lt; T &gt;::Fqux;\n</code></pre> <p>Flux of u in x-direction </p>"},{"location":"BGFlood/struct_flux_p/#variable-fquy","title":"variable Fquy","text":"<pre><code>T* FluxP&lt; T &gt;::Fquy;\n</code></pre> <p>Flux of u in y-direction </p>"},{"location":"BGFlood/struct_flux_p/#variable-fqvx","title":"variable Fqvx","text":"<pre><code>T* FluxP&lt; T &gt;::Fqvx;\n</code></pre> <p>Flux of v in x-direction </p>"},{"location":"BGFlood/struct_flux_p/#variable-fqvy","title":"variable Fqvy","text":"<pre><code>T* FluxP&lt; T &gt;::Fqvy;\n</code></pre> <p>Flux of v in y-direction </p>"},{"location":"BGFlood/struct_flux_p/#variable-su","title":"variable Su","text":"<pre><code>T* FluxP&lt; T &gt;::Su;\n</code></pre> <p>Source term for u </p>"},{"location":"BGFlood/struct_flux_p/#variable-sv","title":"variable Sv","text":"<pre><code>T* FluxP&lt; T &gt;::Sv;\n</code></pre> <p>Source term for v </p> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/struct_forcing/","title":"Struct Forcing","text":""},{"location":"BGFlood/struct_forcing/#struct-forcing","title":"Struct Forcing","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; Forcing</p>"},{"location":"BGFlood/struct_forcing/#public-attributes","title":"Public Attributes","text":"Type Name AOIinfo AOI DynForcingP&lt; T &gt; Atmp std::vector&lt; StaticForcingP&lt; T &gt; &gt; Bathy DynForcingP&lt; T &gt; Rain DynForcingP&lt; T &gt; UWind DynForcingP&lt; T &gt; VWind std::vector&lt; bndsegment &gt; bndseg bndparam bot std::vector&lt; StaticForcingP&lt; T &gt; &gt; cf StaticForcingP&lt; T &gt; cl std::vector&lt; deformmap&lt; T &gt; &gt; deform StaticForcingP&lt; T &gt; il bndparam left bndparam right std::vector&lt; River &gt; rivers std::vector&lt; StaticForcingP&lt; int &gt; &gt; targetadapt bndparam top"},{"location":"BGFlood/struct_forcing/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_forcing/#variable-aoi","title":"variable AOI","text":"<pre><code>AOIinfo Forcing&lt; T &gt;::AOI;\n</code></pre>"},{"location":"BGFlood/struct_forcing/#variable-atmp","title":"variable Atmp","text":"<pre><code>DynForcingP&lt;T&gt; Forcing&lt; T &gt;::Atmp;\n</code></pre>"},{"location":"BGFlood/struct_forcing/#variable-bathy","title":"variable Bathy","text":"<pre><code>std::vector&lt;StaticForcingP&lt;T&gt; &gt; Forcing&lt; T &gt;::Bathy;\n</code></pre>"},{"location":"BGFlood/struct_forcing/#variable-rain","title":"variable Rain","text":"<pre><code>DynForcingP&lt;T&gt; Forcing&lt; T &gt;::Rain;\n</code></pre>"},{"location":"BGFlood/struct_forcing/#variable-uwind","title":"variable UWind","text":"<pre><code>DynForcingP&lt;T&gt; Forcing&lt; T &gt;::UWind;\n</code></pre>"},{"location":"BGFlood/struct_forcing/#variable-vwind","title":"variable VWind","text":"<pre><code>DynForcingP&lt;T&gt; Forcing&lt; T &gt;::VWind;\n</code></pre>"},{"location":"BGFlood/struct_forcing/#variable-bndseg","title":"variable bndseg","text":"<pre><code>std::vector&lt;bndsegment&gt; Forcing&lt; T &gt;::bndseg;\n</code></pre>"},{"location":"BGFlood/struct_forcing/#variable-bot","title":"variable bot","text":"<pre><code>bndparam Forcing&lt; T &gt;::bot;\n</code></pre>"},{"location":"BGFlood/struct_forcing/#variable-cf","title":"variable cf","text":"<pre><code>std::vector&lt;StaticForcingP&lt;T&gt; &gt; Forcing&lt; T &gt;::cf;\n</code></pre>"},{"location":"BGFlood/struct_forcing/#variable-cl","title":"variable cl","text":"<pre><code>StaticForcingP&lt;T&gt; Forcing&lt; T &gt;::cl;\n</code></pre>"},{"location":"BGFlood/struct_forcing/#variable-deform","title":"variable deform","text":"<pre><code>std::vector&lt;deformmap&lt;T&gt; &gt; Forcing&lt; T &gt;::deform;\n</code></pre>"},{"location":"BGFlood/struct_forcing/#variable-il","title":"variable il","text":"<pre><code>StaticForcingP&lt;T&gt; Forcing&lt; T &gt;::il;\n</code></pre>"},{"location":"BGFlood/struct_forcing/#variable-left","title":"variable left","text":"<pre><code>bndparam Forcing&lt; T &gt;::left;\n</code></pre>"},{"location":"BGFlood/struct_forcing/#variable-right","title":"variable right","text":"<pre><code>bndparam Forcing&lt; T &gt;::right;\n</code></pre>"},{"location":"BGFlood/struct_forcing/#variable-rivers","title":"variable rivers","text":"<pre><code>std::vector&lt;River&gt; Forcing&lt; T &gt;::rivers;\n</code></pre>"},{"location":"BGFlood/struct_forcing/#variable-targetadapt","title":"variable targetadapt","text":"<pre><code>std::vector&lt;StaticForcingP&lt;int&gt; &gt; Forcing&lt; T &gt;::targetadapt;\n</code></pre>"},{"location":"BGFlood/struct_forcing/#variable-top","title":"variable top","text":"<pre><code>bndparam Forcing&lt; T &gt;::top;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/struct_gradients_m_l_p/","title":"Struct GradientsMLP","text":""},{"location":"BGFlood/struct_gradients_m_l_p/#struct-gradientsmlp","title":"Struct GradientsMLP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; GradientsMLP</p> <p>Structure holding gradient arrays (no z relative variables). More...</p> <ul> <li><code>#include &lt;Arrays.h&gt;</code></li> </ul>"},{"location":"BGFlood/struct_gradients_m_l_p/#public-attributes","title":"Public Attributes","text":"Type Name T * dhdx T * dhdy T * dudx T * dudy T * dvdx T * dvdy"},{"location":"BGFlood/struct_gradients_m_l_p/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul>"},{"location":"BGFlood/struct_gradients_m_l_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_gradients_m_l_p/#variable-dhdx","title":"variable dhdx","text":"<pre><code>T* GradientsMLP&lt; T &gt;::dhdx;\n</code></pre> <p>Water depth gradient in x-direction </p>"},{"location":"BGFlood/struct_gradients_m_l_p/#variable-dhdy","title":"variable dhdy","text":"<pre><code>T* GradientsMLP&lt; T &gt;::dhdy;\n</code></pre> <p>Water depth gradient in y-direction </p>"},{"location":"BGFlood/struct_gradients_m_l_p/#variable-dudx","title":"variable dudx","text":"<pre><code>T* GradientsMLP&lt; T &gt;::dudx;\n</code></pre> <p>Velocity u gradient in x-direction </p>"},{"location":"BGFlood/struct_gradients_m_l_p/#variable-dudy","title":"variable dudy","text":"<pre><code>T* GradientsMLP&lt; T &gt;::dudy;\n</code></pre> <p>Velocity u gradient in y-direction </p>"},{"location":"BGFlood/struct_gradients_m_l_p/#variable-dvdx","title":"variable dvdx","text":"<pre><code>T* GradientsMLP&lt; T &gt;::dvdx;\n</code></pre> <p>Velocity v gradient in x-direction </p>"},{"location":"BGFlood/struct_gradients_m_l_p/#variable-dvdy","title":"variable dvdy","text":"<pre><code>T* GradientsMLP&lt; T &gt;::dvdy;\n</code></pre> <p>Velocity v gradient in y-direction </p> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/struct_gradients_p/","title":"Struct GradientsP","text":""},{"location":"BGFlood/struct_gradients_p/#struct-gradientsp","title":"Struct GradientsP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; GradientsP</p> <p>Structure holding gradient arrays for physical variables. More...</p> <ul> <li><code>#include &lt;Arrays.h&gt;</code></li> </ul>"},{"location":"BGFlood/struct_gradients_p/#public-attributes","title":"Public Attributes","text":"Type Name T * dhdx T * dhdy T * dudx T * dudy T * dvdx T * dvdy T * dzbdx T * dzbdy T * dzsdx T * dzsdy"},{"location":"BGFlood/struct_gradients_p/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul>"},{"location":"BGFlood/struct_gradients_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_gradients_p/#variable-dhdx","title":"variable dhdx","text":"<pre><code>T* GradientsP&lt; T &gt;::dhdx;\n</code></pre> <p>Water depth gradient in x-direction </p>"},{"location":"BGFlood/struct_gradients_p/#variable-dhdy","title":"variable dhdy","text":"<pre><code>T* GradientsP&lt; T &gt;::dhdy;\n</code></pre> <p>Water depth gradient in y-direction </p>"},{"location":"BGFlood/struct_gradients_p/#variable-dudx","title":"variable dudx","text":"<pre><code>T* GradientsP&lt; T &gt;::dudx;\n</code></pre> <p>Velocity u gradient in x-direction </p>"},{"location":"BGFlood/struct_gradients_p/#variable-dudy","title":"variable dudy","text":"<pre><code>T* GradientsP&lt; T &gt;::dudy;\n</code></pre> <p>Velocity u gradient in y-direction </p>"},{"location":"BGFlood/struct_gradients_p/#variable-dvdx","title":"variable dvdx","text":"<pre><code>T* GradientsP&lt; T &gt;::dvdx;\n</code></pre> <p>Velocity v gradient in x-direction </p>"},{"location":"BGFlood/struct_gradients_p/#variable-dvdy","title":"variable dvdy","text":"<pre><code>T* GradientsP&lt; T &gt;::dvdy;\n</code></pre> <p>Velocity v gradient in y-direction </p>"},{"location":"BGFlood/struct_gradients_p/#variable-dzbdx","title":"variable dzbdx","text":"<pre><code>T* GradientsP&lt; T &gt;::dzbdx;\n</code></pre> <p>Bed elevation gradient in x-direction </p>"},{"location":"BGFlood/struct_gradients_p/#variable-dzbdy","title":"variable dzbdy","text":"<pre><code>T* GradientsP&lt; T &gt;::dzbdy;\n</code></pre> <p>Bed elevation gradient in y-direction </p>"},{"location":"BGFlood/struct_gradients_p/#variable-dzsdx","title":"variable dzsdx","text":"<pre><code>T* GradientsP&lt; T &gt;::dzsdx;\n</code></pre> <p>Surface elevation gradient in x-direction </p>"},{"location":"BGFlood/struct_gradients_p/#variable-dzsdy","title":"variable dzsdy","text":"<pre><code>T* GradientsP&lt; T &gt;::dzsdy;\n</code></pre> <p>Surface elevation gradient in y-direction </p> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/struct_loop/","title":"Struct Loop","text":""},{"location":"BGFlood/struct_loop/#struct-loop","title":"Struct Loop","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; Loop</p>"},{"location":"BGFlood/struct_loop/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; std::vector&lt; Pointout &gt; &gt; TSAllout int atmpstep   = <code>1</code> T atmpuni bool atmpuniform dim3 blockDim double dt double dtmax T epsilon dim3 gridDim T hugenegval T hugeposval int indNextoutputtime   = <code>0</code> int nTSsteps   = <code>0</code> double nextoutputtime int nstep   = <code>0</code> int nstepout   = <code>0</code> const int num_streams   = <code>4</code> int rainstep   = <code>1</code> T rainuni   = <code>T(0.0)</code> bool rainuniform cudaStream_t streams double totaltime T uwinduni   = <code>T(0.0)</code> T vwinduni   = <code>T(0.0)</code> int windstep   = <code>1</code> bool winduniform"},{"location":"BGFlood/struct_loop/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_loop/#variable-tsallout","title":"variable TSAllout","text":"<pre><code>std::vector&lt; std::vector&lt; Pointout &gt; &gt; Loop&lt; T &gt;::TSAllout;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-atmpstep","title":"variable atmpstep","text":"<pre><code>int Loop&lt; T &gt;::atmpstep;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-atmpuni","title":"variable atmpuni","text":"<pre><code>T Loop&lt; T &gt;::atmpuni;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-atmpuniform","title":"variable atmpuniform","text":"<pre><code>bool Loop&lt; T &gt;::atmpuniform;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-blockdim","title":"variable blockDim","text":"<pre><code>dim3 Loop&lt; T &gt;::blockDim;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-dt","title":"variable dt","text":"<pre><code>double Loop&lt; T &gt;::dt;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-dtmax","title":"variable dtmax","text":"<pre><code>double Loop&lt; T &gt;::dtmax;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-epsilon","title":"variable epsilon","text":"<pre><code>T Loop&lt; T &gt;::epsilon;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-griddim","title":"variable gridDim","text":"<pre><code>dim3 Loop&lt; T &gt;::gridDim;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-hugenegval","title":"variable hugenegval","text":"<pre><code>T Loop&lt; T &gt;::hugenegval;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-hugeposval","title":"variable hugeposval","text":"<pre><code>T Loop&lt; T &gt;::hugeposval;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-indnextoutputtime","title":"variable indNextoutputtime","text":"<pre><code>int Loop&lt; T &gt;::indNextoutputtime;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-ntssteps","title":"variable nTSsteps","text":"<pre><code>int Loop&lt; T &gt;::nTSsteps;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-nextoutputtime","title":"variable nextoutputtime","text":"<pre><code>double Loop&lt; T &gt;::nextoutputtime;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-nstep","title":"variable nstep","text":"<pre><code>int Loop&lt; T &gt;::nstep;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-nstepout","title":"variable nstepout","text":"<pre><code>int Loop&lt; T &gt;::nstepout;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-num_streams","title":"variable num_streams","text":"<pre><code>const int Loop&lt; T &gt;::num_streams;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-rainstep","title":"variable rainstep","text":"<pre><code>int Loop&lt; T &gt;::rainstep;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-rainuni","title":"variable rainuni","text":"<pre><code>T Loop&lt; T &gt;::rainuni;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-rainuniform","title":"variable rainuniform","text":"<pre><code>bool Loop&lt; T &gt;::rainuniform;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-streams","title":"variable streams","text":"<pre><code>cudaStream_t Loop&lt; T &gt;::streams[4];\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-totaltime","title":"variable totaltime","text":"<pre><code>double Loop&lt; T &gt;::totaltime;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-uwinduni","title":"variable uwinduni","text":"<pre><code>T Loop&lt; T &gt;::uwinduni;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-vwinduni","title":"variable vwinduni","text":"<pre><code>T Loop&lt; T &gt;::vwinduni;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-windstep","title":"variable windstep","text":"<pre><code>int Loop&lt; T &gt;::windstep;\n</code></pre>"},{"location":"BGFlood/struct_loop/#variable-winduniform","title":"variable winduniform","text":"<pre><code>bool Loop&lt; T &gt;::winduniform;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/class_mapparam/","title":"Class Mapparam","text":""},{"location":"BGFlood/class_mapparam/#class-mapparam","title":"Class Mapparam","text":"<p>ClassList &gt; Mapparam</p> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/struct_model/","title":"Struct Model","text":""},{"location":"BGFlood/struct_model/#struct-model","title":"Struct Model","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; Model</p>"},{"location":"BGFlood/struct_model/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; double &gt; OutputT std::map&lt; std::string, T * &gt; OutputVarMap std::map&lt; std::string, std::string &gt; Outvarlongname std::map&lt; std::string, std::string &gt; Outvarstdname std::map&lt; std::string, std::string &gt; Outvarunits T * Patm T * TSstore AdaptP adapt AdvanceP&lt; T &gt; adv BlockP&lt; T &gt; blocks BndblockP&lt; T &gt; bndblk T * cf T * cl T * datmpdx T * datmpdy EvolvingP_M&lt; T &gt; evmax EvolvingP_M&lt; T &gt; evmean EvolvingP&lt; T &gt; evolv EvolvingP&lt; T &gt; evolv_o FluxP&lt; T &gt; flux FluxMLP&lt; T &gt; fluxml GradientsP&lt; T &gt; grad T * hgw T * il TimeP&lt; T &gt; time T * wettime T * zb"},{"location":"BGFlood/struct_model/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_model/#variable-outputt","title":"variable OutputT","text":"<pre><code>std::vector&lt;double&gt; Model&lt; T &gt;::OutputT;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-outputvarmap","title":"variable OutputVarMap","text":"<pre><code>std::map&lt;std::string, T *&gt; Model&lt; T &gt;::OutputVarMap;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-outvarlongname","title":"variable Outvarlongname","text":"<pre><code>std::map&lt;std::string, std::string&gt; Model&lt; T &gt;::Outvarlongname;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-outvarstdname","title":"variable Outvarstdname","text":"<pre><code>std::map&lt;std::string, std::string&gt; Model&lt; T &gt;::Outvarstdname;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-outvarunits","title":"variable Outvarunits","text":"<pre><code>std::map&lt;std::string, std::string&gt; Model&lt; T &gt;::Outvarunits;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-patm","title":"variable Patm","text":"<pre><code>T* Model&lt; T &gt;::Patm;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-tsstore","title":"variable TSstore","text":"<pre><code>T* Model&lt; T &gt;::TSstore;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-adapt","title":"variable adapt","text":"<pre><code>AdaptP Model&lt; T &gt;::adapt;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-adv","title":"variable adv","text":"<pre><code>AdvanceP&lt;T&gt; Model&lt; T &gt;::adv;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-blocks","title":"variable blocks","text":"<pre><code>BlockP&lt;T&gt; Model&lt; T &gt;::blocks;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-bndblk","title":"variable bndblk","text":"<pre><code>BndblockP&lt;T&gt; Model&lt; T &gt;::bndblk;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-cf","title":"variable cf","text":"<pre><code>T* Model&lt; T &gt;::cf;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-cl","title":"variable cl","text":"<pre><code>T* Model&lt; T &gt;::cl;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-datmpdx","title":"variable datmpdx","text":"<pre><code>T * Model&lt; T &gt;::datmpdx;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-datmpdy","title":"variable datmpdy","text":"<pre><code>T * Model&lt; T &gt;::datmpdy;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-evmax","title":"variable evmax","text":"<pre><code>EvolvingP_M&lt;T&gt; Model&lt; T &gt;::evmax;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-evmean","title":"variable evmean","text":"<pre><code>EvolvingP_M&lt;T&gt; Model&lt; T &gt;::evmean;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-evolv","title":"variable evolv","text":"<pre><code>EvolvingP&lt;T&gt; Model&lt; T &gt;::evolv;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-evolv_o","title":"variable evolv_o","text":"<pre><code>EvolvingP&lt;T&gt; Model&lt; T &gt;::evolv_o;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-flux","title":"variable flux","text":"<pre><code>FluxP&lt;T&gt; Model&lt; T &gt;::flux;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-fluxml","title":"variable fluxml","text":"<pre><code>FluxMLP&lt;T&gt; Model&lt; T &gt;::fluxml;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-grad","title":"variable grad","text":"<pre><code>GradientsP&lt;T&gt; Model&lt; T &gt;::grad;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-hgw","title":"variable hgw","text":"<pre><code>T* Model&lt; T &gt;::hgw;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-il","title":"variable il","text":"<pre><code>T* Model&lt; T &gt;::il;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-time","title":"variable time","text":"<pre><code>TimeP&lt;T&gt; Model&lt; T &gt;::time;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-wettime","title":"variable wettime","text":"<pre><code>T* Model&lt; T &gt;::wettime;\n</code></pre>"},{"location":"BGFlood/struct_model/#variable-zb","title":"variable zb","text":"<pre><code>T* Model&lt; T &gt;::zb;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/class_param/","title":"Class Param","text":""},{"location":"BGFlood/class_param/#class-param","title":"Class Param","text":"<p>ClassList &gt; Param</p> <p>More...</p> <ul> <li><code>#include &lt;Param.h&gt;</code></li> </ul>"},{"location":"BGFlood/class_param/#public-attributes","title":"Public Attributes","text":"Type Name std::string AdaptCrit int * AdaptCrit_funct_pointer std::string Adapt_arg1 std::string Adapt_arg2 std::string Adapt_arg3 std::string Adapt_arg4 std::string Adapt_arg5 double CFL   = <code>0.5</code> double Cd   = <code>0.002</code> bool ForceMassConserve   = <code>false</code> int GPUDEVICE   = <code>0</code> size_t GPU_initmem_byte size_t GPU_totalmem_byte double Pa2m   = <code>0.00009916</code> double Paref   = <code>101300.0</code> double Radius   = <code>6371220.</code> std::vector&lt; TSoutnode &gt; TSnodesout T_output Toutput double VelThreshold   = <code>-1.0</code> int adaptmaxiteration   = <code>20</code> float addoffset   = <code>0.0f</code> int aoibnd   = <code>0</code> bool atmpforcing   = <code>false</code> int blkmemwidth   = <code>0</code> int blksize   = <code>0</code> int blkwidth   = <code>16</code> double bndfiltertime   = <code>60.0</code> double bndrelaxtime   = <code>3600.0</code> double bndtaper   = <code>0.0</code> bool botbnd   = <code>false</code> double cf   = <code>0.0001</code> double cl   = <code>0.0</code> bool conserveElevation   = <code>false</code> std::string crs_ref   = <code>\"no\\_crs\"</code> double deformmaxtime   = <code>0.0</code> double delta int doubleprecision   = <code>0</code> double dt   = <code>0.0</code> double dtinit   = <code>-1</code> double dtmin   = <code>0.0005</code> double dx   = <code>nan(\"\")</code> clock_t endcputime double endtime   = <code>std::numeric\\_limits&amp;lt;double&amp;gt;::max()</code> int engine   = <code>1</code> double eps   = <code>0.0001</code> int frictionmodel   = <code>0</code> double g   = <code>9.81</code> double grdalpha   = <code>nan(\"\")</code> int halowidth   = <code>1</code> std::string hotstartfile int hotstep   = <code>0</code> double il   = <code>0.0</code> bool infiltration   = <code>false</code> int initlevel   = <code>0</code> double inittime   = <code>0.0</code> double lat   = <code>0.0</code> bool leftbnd   = <code>false</code> double mask   = <code>9999.0</code> int maxTSstorage   = <code>16384</code> int maxlevel   = <code>-99999</code> double membuffer   = <code>1.05</code> int minlevel   = <code>-99999</code> int navailblk   = <code>0</code> int nblk   = <code>0</code> int nblkmem   = <code>0</code> int nblkriver   = <code>0</code> int nbndblkbot   = <code>0</code> int nbndblkleft   = <code>0</code> int nbndblkright   = <code>0</code> int nbndblktop   = <code>0</code> int nmaskblk   = <code>0</code> int nrivers   = <code>0</code> int nx   = <code>0</code> int ny   = <code>0</code> std::string outfile   = <code>\"Output.nc\"</code> int outishift   = <code>0</code> int outjshift   = <code>0</code> bool outmax   = <code>false</code> bool outmean   = <code>false</code> double outputtimestep   = <code>0.0</code> bool outtwet   = <code>false</code> std::vector&lt; std::string &gt; outvars std::vector&lt; outzoneP &gt; outzone int posdown   = <code>0</code> bool rainbnd   = <code>false</code> bool rainforcing   = <code>false</code> std::string reftime   = <code>\"\"</code> bool resetmax   = <code>false</code> double rho   = <code>1025.0</code> bool rightbnd   = <code>false</code> bool savebyblk   = <code>true</code> float scalefactor   = <code>0.01f</code> clock_t setupcputime int smallnc   = <code>1</code> bool spherical   = <code>0</code> clock_t startcputime int test   = <code>-1</code> double theta   = <code>1.3</code> bool topbnd   = <code>false</code> double totaltime   = <code>0.0</code> double wet_threshold   = <code>0.1</code> bool wetdryfix   = <code>true</code> bool windforcing   = <code>false</code> double xmax   = <code>nan(\"\")</code> double xo   = <code>nan(\"\")</code> double ymax   = <code>nan(\"\")</code> double yo   = <code>nan(\"\")</code> double zsinit   = <code>nan(\"\")</code> double zsoffset   = <code>nan(\"\")</code>"},{"location":"BGFlood/class_param/#detailed-description","title":"Detailed Description","text":"<p>A class. A class for holding model parameters. </p>"},{"location":"BGFlood/class_param/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/class_param/#variable-adaptcrit","title":"variable AdaptCrit","text":"<pre><code>std::string Param::AdaptCrit;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-adaptcrit_funct_pointer","title":"variable AdaptCrit_funct_pointer","text":"<pre><code>int* Param::AdaptCrit_funct_pointer;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-adapt_arg1","title":"variable Adapt_arg1","text":"<pre><code>std::string Param::Adapt_arg1;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-adapt_arg2","title":"variable Adapt_arg2","text":"<pre><code>std::string Param::Adapt_arg2;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-adapt_arg3","title":"variable Adapt_arg3","text":"<pre><code>std::string Param::Adapt_arg3;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-adapt_arg4","title":"variable Adapt_arg4","text":"<pre><code>std::string Param::Adapt_arg4;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-adapt_arg5","title":"variable Adapt_arg5","text":"<pre><code>std::string Param::Adapt_arg5;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-cfl","title":"variable CFL","text":"<pre><code>double Param::CFL;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-cd","title":"variable Cd","text":"<pre><code>double Param::Cd;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-forcemassconserve","title":"variable ForceMassConserve","text":"<pre><code>bool Param::ForceMassConserve;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-gpudevice","title":"variable GPUDEVICE","text":"<pre><code>int Param::GPUDEVICE;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-gpu_initmem_byte","title":"variable GPU_initmem_byte","text":"<pre><code>size_t Param::GPU_initmem_byte;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-gpu_totalmem_byte","title":"variable GPU_totalmem_byte","text":"<pre><code>size_t Param::GPU_totalmem_byte;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-pa2m","title":"variable Pa2m","text":"<pre><code>double Param::Pa2m;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-paref","title":"variable Paref","text":"<pre><code>double Param::Paref;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-radius","title":"variable Radius","text":"<pre><code>double Param::Radius;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-tsnodesout","title":"variable TSnodesout","text":"<pre><code>std::vector&lt;TSoutnode&gt; Param::TSnodesout;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-toutput","title":"variable Toutput","text":"<pre><code>T_output Param::Toutput;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-velthreshold","title":"variable VelThreshold","text":"<pre><code>double Param::VelThreshold;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-adaptmaxiteration","title":"variable adaptmaxiteration","text":"<pre><code>int Param::adaptmaxiteration;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-addoffset","title":"variable addoffset","text":"<pre><code>float Param::addoffset;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-aoibnd","title":"variable aoibnd","text":"<pre><code>int Param::aoibnd;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-atmpforcing","title":"variable atmpforcing","text":"<pre><code>bool Param::atmpforcing;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-blkmemwidth","title":"variable blkmemwidth","text":"<pre><code>int Param::blkmemwidth;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-blksize","title":"variable blksize","text":"<pre><code>int Param::blksize;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-blkwidth","title":"variable blkwidth","text":"<pre><code>int Param::blkwidth;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-bndfiltertime","title":"variable bndfiltertime","text":"<pre><code>double Param::bndfiltertime;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-bndrelaxtime","title":"variable bndrelaxtime","text":"<pre><code>double Param::bndrelaxtime;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-bndtaper","title":"variable bndtaper","text":"<pre><code>double Param::bndtaper;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-botbnd","title":"variable botbnd","text":"<pre><code>bool Param::botbnd;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-cf","title":"variable cf","text":"<pre><code>double Param::cf;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-cl","title":"variable cl","text":"<pre><code>double Param::cl;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-conserveelevation","title":"variable conserveElevation","text":"<pre><code>bool Param::conserveElevation;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-crs_ref","title":"variable crs_ref","text":"<pre><code>std::string Param::crs_ref;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-deformmaxtime","title":"variable deformmaxtime","text":"<pre><code>double Param::deformmaxtime;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-delta","title":"variable delta","text":"<pre><code>double Param::delta;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-doubleprecision","title":"variable doubleprecision","text":"<pre><code>int Param::doubleprecision;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-dt","title":"variable dt","text":"<pre><code>double Param::dt;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-dtinit","title":"variable dtinit","text":"<pre><code>double Param::dtinit;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-dtmin","title":"variable dtmin","text":"<pre><code>double Param::dtmin;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-dx","title":"variable dx","text":"<pre><code>double Param::dx;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-endcputime","title":"variable endcputime","text":"<pre><code>clock_t Param::endcputime;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-endtime","title":"variable endtime","text":"<pre><code>double Param::endtime;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-engine","title":"variable engine","text":"<pre><code>int Param::engine;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-eps","title":"variable eps","text":"<pre><code>double Param::eps;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-frictionmodel","title":"variable frictionmodel","text":"<pre><code>int Param::frictionmodel;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-g","title":"variable g","text":"<pre><code>double Param::g;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-grdalpha","title":"variable grdalpha","text":"<pre><code>double Param::grdalpha;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-halowidth","title":"variable halowidth","text":"<pre><code>int Param::halowidth;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-hotstartfile","title":"variable hotstartfile","text":"<pre><code>std::string Param::hotstartfile;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-hotstep","title":"variable hotstep","text":"<pre><code>int Param::hotstep;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-il","title":"variable il","text":"<pre><code>double Param::il;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-infiltration","title":"variable infiltration","text":"<pre><code>bool Param::infiltration;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-initlevel","title":"variable initlevel","text":"<pre><code>int Param::initlevel;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-inittime","title":"variable inittime","text":"<pre><code>double Param::inittime;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-lat","title":"variable lat","text":"<pre><code>double Param::lat;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-leftbnd","title":"variable leftbnd","text":"<pre><code>bool Param::leftbnd;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-mask","title":"variable mask","text":"<pre><code>double Param::mask;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-maxtsstorage","title":"variable maxTSstorage","text":"<pre><code>int Param::maxTSstorage;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-maxlevel","title":"variable maxlevel","text":"<pre><code>int Param::maxlevel;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-membuffer","title":"variable membuffer","text":"<pre><code>double Param::membuffer;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-minlevel","title":"variable minlevel","text":"<pre><code>int Param::minlevel;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-navailblk","title":"variable navailblk","text":"<pre><code>int Param::navailblk;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-nblk","title":"variable nblk","text":"<pre><code>int Param::nblk;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-nblkmem","title":"variable nblkmem","text":"<pre><code>int Param::nblkmem;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-nblkriver","title":"variable nblkriver","text":"<pre><code>int Param::nblkriver;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-nbndblkbot","title":"variable nbndblkbot","text":"<pre><code>int Param::nbndblkbot;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-nbndblkleft","title":"variable nbndblkleft","text":"<pre><code>int Param::nbndblkleft;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-nbndblkright","title":"variable nbndblkright","text":"<pre><code>int Param::nbndblkright;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-nbndblktop","title":"variable nbndblktop","text":"<pre><code>int Param::nbndblktop;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-nmaskblk","title":"variable nmaskblk","text":"<pre><code>int Param::nmaskblk;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-nrivers","title":"variable nrivers","text":"<pre><code>int Param::nrivers;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-nx","title":"variable nx","text":"<pre><code>int Param::nx;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-ny","title":"variable ny","text":"<pre><code>int Param::ny;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-outfile","title":"variable outfile","text":"<pre><code>std::string Param::outfile;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-outishift","title":"variable outishift","text":"<pre><code>int Param::outishift;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-outjshift","title":"variable outjshift","text":"<pre><code>int Param::outjshift;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-outmax","title":"variable outmax","text":"<pre><code>bool Param::outmax;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-outmean","title":"variable outmean","text":"<pre><code>bool Param::outmean;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-outputtimestep","title":"variable outputtimestep","text":"<pre><code>double Param::outputtimestep;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-outtwet","title":"variable outtwet","text":"<pre><code>bool Param::outtwet;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-outvars","title":"variable outvars","text":"<pre><code>std::vector&lt;std::string&gt; Param::outvars;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-outzone","title":"variable outzone","text":"<pre><code>std::vector&lt;outzoneP&gt; Param::outzone;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-posdown","title":"variable posdown","text":"<pre><code>int Param::posdown;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-rainbnd","title":"variable rainbnd","text":"<pre><code>bool Param::rainbnd;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-rainforcing","title":"variable rainforcing","text":"<pre><code>bool Param::rainforcing;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-reftime","title":"variable reftime","text":"<pre><code>std::string Param::reftime;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-resetmax","title":"variable resetmax","text":"<pre><code>bool Param::resetmax;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-rho","title":"variable rho","text":"<pre><code>double Param::rho;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-rightbnd","title":"variable rightbnd","text":"<pre><code>bool Param::rightbnd;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-savebyblk","title":"variable savebyblk","text":"<pre><code>bool Param::savebyblk;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-scalefactor","title":"variable scalefactor","text":"<pre><code>float Param::scalefactor;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-setupcputime","title":"variable setupcputime","text":"<pre><code>clock_t Param::setupcputime;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-smallnc","title":"variable smallnc","text":"<pre><code>int Param::smallnc;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-spherical","title":"variable spherical","text":"<pre><code>bool Param::spherical;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-startcputime","title":"variable startcputime","text":"<pre><code>clock_t Param::startcputime;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-test","title":"variable test","text":"<pre><code>int Param::test;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-theta","title":"variable theta","text":"<pre><code>double Param::theta;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-topbnd","title":"variable topbnd","text":"<pre><code>bool Param::topbnd;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-totaltime","title":"variable totaltime","text":"<pre><code>double Param::totaltime;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-wet_threshold","title":"variable wet_threshold","text":"<pre><code>double Param::wet_threshold;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-wetdryfix","title":"variable wetdryfix","text":"<pre><code>bool Param::wetdryfix;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-windforcing","title":"variable windforcing","text":"<pre><code>bool Param::windforcing;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-xmax","title":"variable xmax","text":"<pre><code>double Param::xmax;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-xo","title":"variable xo","text":"<pre><code>double Param::xo;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-ymax","title":"variable ymax","text":"<pre><code>double Param::ymax;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-yo","title":"variable yo","text":"<pre><code>double Param::yo;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-zsinit","title":"variable zsinit","text":"<pre><code>double Param::zsinit;\n</code></pre>"},{"location":"BGFlood/class_param/#variable-zsoffset","title":"variable zsoffset","text":"<pre><code>double Param::zsoffset;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Param.h</code></p>"},{"location":"BGFlood/class_pointout/","title":"Class Pointout","text":""},{"location":"BGFlood/class_pointout/#class-pointout","title":"Class Pointout","text":"<p>ClassList &gt; Pointout</p>"},{"location":"BGFlood/class_pointout/#public-attributes","title":"Public Attributes","text":"Type Name double h double time double u double v double zs"},{"location":"BGFlood/class_pointout/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/class_pointout/#variable-h","title":"variable h","text":"<pre><code>double Pointout::h;\n</code></pre>"},{"location":"BGFlood/class_pointout/#variable-time","title":"variable time","text":"<pre><code>double Pointout::time;\n</code></pre>"},{"location":"BGFlood/class_pointout/#variable-u","title":"variable u","text":"<pre><code>double Pointout::u;\n</code></pre>"},{"location":"BGFlood/class_pointout/#variable-v","title":"variable v","text":"<pre><code>double Pointout::v;\n</code></pre>"},{"location":"BGFlood/class_pointout/#variable-zs","title":"variable zs","text":"<pre><code>double Pointout::zs;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/class_polygon/","title":"Class Polygon","text":""},{"location":"BGFlood/class_polygon/#class-polygon","title":"Class Polygon","text":"<p>ClassList &gt; Polygon</p>"},{"location":"BGFlood/class_polygon/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; Vertex &gt; vertices double xmax double xmin double ymax double ymin"},{"location":"BGFlood/class_polygon/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/class_polygon/#variable-vertices","title":"variable vertices","text":"<pre><code>std::vector&lt;Vertex&gt; Polygon::vertices;\n</code></pre>"},{"location":"BGFlood/class_polygon/#variable-xmax","title":"variable xmax","text":"<pre><code>double Polygon::xmax;\n</code></pre>"},{"location":"BGFlood/class_polygon/#variable-xmin","title":"variable xmin","text":"<pre><code>double Polygon::xmin;\n</code></pre>"},{"location":"BGFlood/class_polygon/#variable-ymax","title":"variable ymax","text":"<pre><code>double Polygon::ymax;\n</code></pre>"},{"location":"BGFlood/class_polygon/#variable-ymin","title":"variable ymin","text":"<pre><code>double Polygon::ymin;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/class_river/","title":"Class River","text":""},{"location":"BGFlood/class_river/#class-river","title":"Class River","text":"<p>ClassList &gt; River</p>"},{"location":"BGFlood/class_river/#public-attributes","title":"Public Attributes","text":"Type Name std::string Riverflowfile std::vector&lt; int &gt; block double disarea std::vector&lt; Flowin &gt; flowinput std::vector&lt; int &gt; i std::vector&lt; int &gt; j double tmax double to double xend double xstart double yend double ystart"},{"location":"BGFlood/class_river/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/class_river/#variable-riverflowfile","title":"variable Riverflowfile","text":"<pre><code>std::string River::Riverflowfile;\n</code></pre>"},{"location":"BGFlood/class_river/#variable-block","title":"variable block","text":"<pre><code>std::vector&lt;int&gt; River::block;\n</code></pre>"},{"location":"BGFlood/class_river/#variable-disarea","title":"variable disarea","text":"<pre><code>double River::disarea;\n</code></pre>"},{"location":"BGFlood/class_river/#variable-flowinput","title":"variable flowinput","text":"<pre><code>std::vector&lt;Flowin&gt; River::flowinput;\n</code></pre>"},{"location":"BGFlood/class_river/#variable-i","title":"variable i","text":"<pre><code>std::vector&lt;int&gt; River::i;\n</code></pre>"},{"location":"BGFlood/class_river/#variable-j","title":"variable j","text":"<pre><code>std::vector&lt;int&gt; River::j;\n</code></pre>"},{"location":"BGFlood/class_river/#variable-tmax","title":"variable tmax","text":"<pre><code>double River::tmax;\n</code></pre>"},{"location":"BGFlood/class_river/#variable-to","title":"variable to","text":"<pre><code>double River::to;\n</code></pre>"},{"location":"BGFlood/class_river/#variable-xend","title":"variable xend","text":"<pre><code>double River::xend;\n</code></pre>"},{"location":"BGFlood/class_river/#variable-xstart","title":"variable xstart","text":"<pre><code>double River::xstart;\n</code></pre>"},{"location":"BGFlood/class_river/#variable-yend","title":"variable yend","text":"<pre><code>double River::yend;\n</code></pre>"},{"location":"BGFlood/class_river/#variable-ystart","title":"variable ystart","text":"<pre><code>double River::ystart;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/struct_river_blk/","title":"Struct RiverBlk","text":""},{"location":"BGFlood/struct_river_blk/#struct-riverblk","title":"Struct RiverBlk","text":"<p>ClassList &gt; RiverBlk</p>"},{"location":"BGFlood/struct_river_blk/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; int &gt; block"},{"location":"BGFlood/struct_river_blk/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_river_blk/#variable-block","title":"variable block","text":"<pre><code>std::vector&lt;int&gt; RiverBlk::block;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/struct_river_info/","title":"Struct RiverInfo","text":""},{"location":"BGFlood/struct_river_info/#struct-riverinfo","title":"Struct RiverInfo","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; RiverInfo</p>"},{"location":"BGFlood/struct_river_info/#public-attributes","title":"Public Attributes","text":"Type Name int * Xbidir int * Xridib int nbir int nburmax int nribmax T * qnow T * qnow_g T * xend T * xstart T * yend T * ystart"},{"location":"BGFlood/struct_river_info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_river_info/#variable-xbidir","title":"variable Xbidir","text":"<pre><code>int* RiverInfo&lt; T &gt;::Xbidir;\n</code></pre>"},{"location":"BGFlood/struct_river_info/#variable-xridib","title":"variable Xridib","text":"<pre><code>int* RiverInfo&lt; T &gt;::Xridib;\n</code></pre>"},{"location":"BGFlood/struct_river_info/#variable-nbir","title":"variable nbir","text":"<pre><code>int RiverInfo&lt; T &gt;::nbir;\n</code></pre>"},{"location":"BGFlood/struct_river_info/#variable-nburmax","title":"variable nburmax","text":"<pre><code>int RiverInfo&lt; T &gt;::nburmax;\n</code></pre>"},{"location":"BGFlood/struct_river_info/#variable-nribmax","title":"variable nribmax","text":"<pre><code>int RiverInfo&lt; T &gt;::nribmax;\n</code></pre>"},{"location":"BGFlood/struct_river_info/#variable-qnow","title":"variable qnow","text":"<pre><code>T* RiverInfo&lt; T &gt;::qnow;\n</code></pre>"},{"location":"BGFlood/struct_river_info/#variable-qnow_g","title":"variable qnow_g","text":"<pre><code>T* RiverInfo&lt; T &gt;::qnow_g;\n</code></pre>"},{"location":"BGFlood/struct_river_info/#variable-xend","title":"variable xend","text":"<pre><code>T* RiverInfo&lt; T &gt;::xend;\n</code></pre>"},{"location":"BGFlood/struct_river_info/#variable-xstart","title":"variable xstart","text":"<pre><code>T* RiverInfo&lt; T &gt;::xstart;\n</code></pre>"},{"location":"BGFlood/struct_river_info/#variable-yend","title":"variable yend","text":"<pre><code>T* RiverInfo&lt; T &gt;::yend;\n</code></pre>"},{"location":"BGFlood/struct_river_info/#variable-ystart","title":"variable ystart","text":"<pre><code>T* RiverInfo&lt; T &gt;::ystart;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/class_s_l_t_s/","title":"Class SLTS","text":""},{"location":"BGFlood/class_s_l_t_s/#class-slts","title":"Class SLTS","text":"<p>ClassList &gt; SLTS</p>"},{"location":"BGFlood/class_s_l_t_s/#public-attributes","title":"Public Attributes","text":"Type Name double time std::vector&lt; double &gt; uuvel std::vector&lt; double &gt; vvvel std::vector&lt; double &gt; wlevs"},{"location":"BGFlood/class_s_l_t_s/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/class_s_l_t_s/#variable-time","title":"variable time","text":"<pre><code>double SLTS::time;\n</code></pre>"},{"location":"BGFlood/class_s_l_t_s/#variable-uuvel","title":"variable uuvel","text":"<pre><code>std::vector&lt;double&gt; SLTS::uuvel;\n</code></pre>"},{"location":"BGFlood/class_s_l_t_s/#variable-vvvel","title":"variable vvvel","text":"<pre><code>std::vector&lt;double&gt; SLTS::vvvel;\n</code></pre>"},{"location":"BGFlood/class_s_l_t_s/#variable-wlevs","title":"variable wlevs","text":"<pre><code>std::vector&lt;double&gt; SLTS::wlevs;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/struct_shared_memory/","title":"Struct SharedMemory","text":""},{"location":"BGFlood/struct_shared_memory/#struct-sharedmemory","title":"Struct SharedMemory","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; SharedMemory</p>"},{"location":"BGFlood/struct_shared_memory/#public-functions","title":"Public Functions","text":"Type Name __device__ operator T* ()  __device__ operator const T * () const"},{"location":"BGFlood/struct_shared_memory/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/struct_shared_memory/#function-operator-t","title":"function operator T*","text":"<pre><code>inline __device__ SharedMemory::operator T* () \n</code></pre>"},{"location":"BGFlood/struct_shared_memory/#function-operator-const-t","title":"function operator const T *","text":"<pre><code>inline __device__ SharedMemory::operator const T * () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Advection.cu</code></p>"},{"location":"BGFlood/struct_shared_memory_3_01double_01_4/","title":"Struct SharedMemory&lt; double &gt;","text":""},{"location":"BGFlood/struct_shared_memory_3_01double_01_4/#struct-sharedmemory-double","title":"Struct SharedMemory&lt; double &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; SharedMemory&lt; double &gt;</p>"},{"location":"BGFlood/struct_shared_memory_3_01double_01_4/#public-functions","title":"Public Functions","text":"Type Name __device__ operator const double * () const __device__ operator double * ()"},{"location":"BGFlood/struct_shared_memory_3_01double_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/struct_shared_memory_3_01double_01_4/#function-operator-const-double","title":"function operator const double *","text":"<pre><code>inline __device__ SharedMemory&lt; double &gt;::operator const double * () const\n</code></pre>"},{"location":"BGFlood/struct_shared_memory_3_01double_01_4/#function-operator-double","title":"function operator double *","text":"<pre><code>inline __device__ SharedMemory&lt; double &gt;::operator double * () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Advection.cu</code></p>"},{"location":"BGFlood/struct_static_forcing_p/","title":"Struct StaticForcingP","text":""},{"location":"BGFlood/struct_static_forcing_p/#struct-staticforcingp","title":"Struct StaticForcingP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; StaticForcingP</p> <p>Inherits the following classes: inputmap</p>"},{"location":"BGFlood/struct_static_forcing_p/#public-attributes","title":"Public Attributes","text":"Type Name T * val"},{"location":"BGFlood/struct_static_forcing_p/#public-attributes-inherited-from-inputmap","title":"Public Attributes inherited from inputmap","text":"<p>See inputmap</p> Type Name double denanval   = <code>NAN</code> double dx   = <code>0.0</code> double dy   = <code>0.0</code> std::string extension bool flipxx   = <code>false</code> bool flipyy   = <code>false</code> double grdalpha   = <code>0.0</code> std::string inputfile int nx   = <code>0</code> int ny   = <code>0</code> std::string varname double xmax   = <code>0.0</code> double xo   = <code>0.0</code> double ymax   = <code>0.0</code> double yo   = <code>0.0</code>"},{"location":"BGFlood/struct_static_forcing_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_static_forcing_p/#variable-val","title":"variable val","text":"<pre><code>T* StaticForcingP&lt; T &gt;::val;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/class_t_soutnode/","title":"Class TSoutnode","text":""},{"location":"BGFlood/class_t_soutnode/#class-tsoutnode","title":"Class TSoutnode","text":"<p>ClassList &gt; TSoutnode</p>"},{"location":"BGFlood/class_t_soutnode/#public-attributes","title":"Public Attributes","text":"Type Name int block int i int j std::string outname double x double y"},{"location":"BGFlood/class_t_soutnode/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/class_t_soutnode/#variable-block","title":"variable block","text":"<pre><code>int TSoutnode::block;\n</code></pre>"},{"location":"BGFlood/class_t_soutnode/#variable-i","title":"variable i","text":"<pre><code>int TSoutnode::i;\n</code></pre>"},{"location":"BGFlood/class_t_soutnode/#variable-j","title":"variable j","text":"<pre><code>int TSoutnode::j;\n</code></pre>"},{"location":"BGFlood/class_t_soutnode/#variable-outname","title":"variable outname","text":"<pre><code>std::string TSoutnode::outname;\n</code></pre>"},{"location":"BGFlood/class_t_soutnode/#variable-x","title":"variable x","text":"<pre><code>double TSoutnode::x;\n</code></pre>"},{"location":"BGFlood/class_t_soutnode/#variable-y","title":"variable y","text":"<pre><code>double TSoutnode::y;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/class_t__output/","title":"Class T_output","text":""},{"location":"BGFlood/class_t__output/#class-t_output","title":"Class T_output","text":"<p>ClassList &gt; T_output</p>"},{"location":"BGFlood/class_t__output/#public-attributes","title":"Public Attributes","text":"Type Name double end   = <code>NAN</code> double init   = <code>NAN</code> std::vector&lt; std::string &gt; inputstr double tstep   = <code>NAN</code> std::vector&lt; double &gt; val"},{"location":"BGFlood/class_t__output/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/class_t__output/#variable-end","title":"variable end","text":"<pre><code>double T_output::end;\n</code></pre>"},{"location":"BGFlood/class_t__output/#variable-init","title":"variable init","text":"<pre><code>double T_output::init;\n</code></pre>"},{"location":"BGFlood/class_t__output/#variable-inputstr","title":"variable inputstr","text":"<pre><code>std::vector&lt;std::string&gt; T_output::inputstr;\n</code></pre>"},{"location":"BGFlood/class_t__output/#variable-tstep","title":"variable tstep","text":"<pre><code>double T_output::tstep;\n</code></pre>"},{"location":"BGFlood/class_t__output/#variable-val","title":"variable val","text":"<pre><code>std::vector&lt;double&gt; T_output::val;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/struct_tex_set_p/","title":"Struct TexSetP","text":""},{"location":"BGFlood/struct_tex_set_p/#struct-texsetp","title":"Struct TexSetP","text":"<p>ClassList &gt; TexSetP</p>"},{"location":"BGFlood/struct_tex_set_p/#public-attributes","title":"Public Attributes","text":"Type Name cudaArray * CudArr cudaChannelFormatDesc channelDesc   = <code>cudaCreateChannelDesc(32, 0, 0, 0, cudaChannelFormatKindFloat)</code> float dx float dy float nowvalue struct cudaResourceDesc resDesc cudaTextureObject_t tex   = <code>0</code> struct cudaTextureDesc texDesc bool uniform float xo float yo"},{"location":"BGFlood/struct_tex_set_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_tex_set_p/#variable-cudarr","title":"variable CudArr","text":"<pre><code>cudaArray* TexSetP::CudArr;\n</code></pre>"},{"location":"BGFlood/struct_tex_set_p/#variable-channeldesc","title":"variable channelDesc","text":"<pre><code>cudaChannelFormatDesc TexSetP::channelDesc;\n</code></pre>"},{"location":"BGFlood/struct_tex_set_p/#variable-dx","title":"variable dx","text":"<pre><code>float TexSetP::dx;\n</code></pre>"},{"location":"BGFlood/struct_tex_set_p/#variable-dy","title":"variable dy","text":"<pre><code>float TexSetP::dy;\n</code></pre>"},{"location":"BGFlood/struct_tex_set_p/#variable-nowvalue","title":"variable nowvalue","text":"<pre><code>float TexSetP::nowvalue;\n</code></pre>"},{"location":"BGFlood/struct_tex_set_p/#variable-resdesc","title":"variable resDesc","text":"<pre><code>struct cudaResourceDesc TexSetP::resDesc;\n</code></pre>"},{"location":"BGFlood/struct_tex_set_p/#variable-tex","title":"variable tex","text":"<pre><code>cudaTextureObject_t TexSetP::tex;\n</code></pre>"},{"location":"BGFlood/struct_tex_set_p/#variable-texdesc","title":"variable texDesc","text":"<pre><code>struct cudaTextureDesc TexSetP::texDesc;\n</code></pre>"},{"location":"BGFlood/struct_tex_set_p/#variable-uniform","title":"variable uniform","text":"<pre><code>bool TexSetP::uniform;\n</code></pre>"},{"location":"BGFlood/struct_tex_set_p/#variable-xo","title":"variable xo","text":"<pre><code>float TexSetP::xo;\n</code></pre>"},{"location":"BGFlood/struct_tex_set_p/#variable-yo","title":"variable yo","text":"<pre><code>float TexSetP::yo;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/struct_time_p/","title":"Struct TimeP","text":""},{"location":"BGFlood/struct_time_p/#struct-timep","title":"Struct TimeP","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; TimeP</p>"},{"location":"BGFlood/struct_time_p/#public-attributes","title":"Public Attributes","text":"Type Name T * arrmax T * arrmin T dt T * dtmax T totaltime"},{"location":"BGFlood/struct_time_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/struct_time_p/#variable-arrmax","title":"variable arrmax","text":"<pre><code>T* TimeP&lt; T &gt;::arrmax;\n</code></pre>"},{"location":"BGFlood/struct_time_p/#variable-arrmin","title":"variable arrmin","text":"<pre><code>T * TimeP&lt; T &gt;::arrmin;\n</code></pre>"},{"location":"BGFlood/struct_time_p/#variable-dt","title":"variable dt","text":"<pre><code>T TimeP&lt; T &gt;::dt;\n</code></pre>"},{"location":"BGFlood/struct_time_p/#variable-dtmax","title":"variable dtmax","text":"<pre><code>T* TimeP&lt; T &gt;::dtmax;\n</code></pre>"},{"location":"BGFlood/struct_time_p/#variable-totaltime","title":"variable totaltime","text":"<pre><code>T TimeP&lt; T &gt;::totaltime;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/class_vertex/","title":"Class Vertex","text":""},{"location":"BGFlood/class_vertex/#class-vertex","title":"Class Vertex","text":"<p>ClassList &gt; Vertex</p>"},{"location":"BGFlood/class_vertex/#public-attributes","title":"Public Attributes","text":"Type Name double x double y"},{"location":"BGFlood/class_vertex/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/class_vertex/#variable-x","title":"variable x","text":"<pre><code>double Vertex::x;\n</code></pre>"},{"location":"BGFlood/class_vertex/#variable-y","title":"variable y","text":"<pre><code>double Vertex::y;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/class_windin/","title":"Class Windin","text":""},{"location":"BGFlood/class_windin/#class-windin","title":"Class Windin","text":"<p>ClassList &gt; Windin</p>"},{"location":"BGFlood/class_windin/#public-attributes","title":"Public Attributes","text":"Type Name double time double uwind double vwind double wdirection double wspeed"},{"location":"BGFlood/class_windin/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/class_windin/#variable-time","title":"variable time","text":"<pre><code>double Windin::time;\n</code></pre>"},{"location":"BGFlood/class_windin/#variable-uwind","title":"variable uwind","text":"<pre><code>double Windin::uwind;\n</code></pre>"},{"location":"BGFlood/class_windin/#variable-vwind","title":"variable vwind","text":"<pre><code>double Windin::vwind;\n</code></pre>"},{"location":"BGFlood/class_windin/#variable-wdirection","title":"variable wdirection","text":"<pre><code>double Windin::wdirection;\n</code></pre>"},{"location":"BGFlood/class_windin/#variable-wspeed","title":"variable wspeed","text":"<pre><code>double Windin::wspeed;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/structbnd_tex_p/","title":"Struct bndTexP","text":""},{"location":"BGFlood/structbnd_tex_p/#struct-bndtexp","title":"Struct bndTexP","text":"<p>ClassList &gt; bndTexP</p>"},{"location":"BGFlood/structbnd_tex_p/#public-attributes","title":"Public Attributes","text":"Type Name TexSetP Uvel TexSetP Vvel TexSetP WLS"},{"location":"BGFlood/structbnd_tex_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structbnd_tex_p/#variable-uvel","title":"variable Uvel","text":"<pre><code>TexSetP bndTexP::Uvel;\n</code></pre>"},{"location":"BGFlood/structbnd_tex_p/#variable-vvel","title":"variable Vvel","text":"<pre><code>TexSetP bndTexP::Vvel;\n</code></pre>"},{"location":"BGFlood/structbnd_tex_p/#variable-wls","title":"variable WLS","text":"<pre><code>TexSetP bndTexP::WLS;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/classbndparam/","title":"Class bndparam","text":""},{"location":"BGFlood/classbndparam/#class-bndparam","title":"Class bndparam","text":"<p>ClassList &gt; bndparam</p>"},{"location":"BGFlood/classbndparam/#public-attributes","title":"Public Attributes","text":"Type Name bndTexP GPU int * blks int * blks_g std::vector&lt; SLTS &gt; data std::string inputfile int isright   = <code>0</code> int istop   = <code>0</code> int nblk   = <code>0</code> int nbnd bool on   = <code>false</code> float * qmean float * qmean_g int side   = <code>0</code> int type   = <code>1</code>"},{"location":"BGFlood/classbndparam/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classbndparam/#variable-gpu","title":"variable GPU","text":"<pre><code>bndTexP bndparam::GPU;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-blks","title":"variable blks","text":"<pre><code>int* bndparam::blks;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-blks_g","title":"variable blks_g","text":"<pre><code>int* bndparam::blks_g;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-data","title":"variable data","text":"<pre><code>std::vector&lt;SLTS&gt; bndparam::data;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-inputfile","title":"variable inputfile","text":"<pre><code>std::string bndparam::inputfile;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-isright","title":"variable isright","text":"<pre><code>int bndparam::isright;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-istop","title":"variable istop","text":"<pre><code>int bndparam::istop;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-nblk","title":"variable nblk","text":"<pre><code>int bndparam::nblk;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-nbnd","title":"variable nbnd","text":"<pre><code>int bndparam::nbnd;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-on","title":"variable on","text":"<pre><code>bool bndparam::on;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-qmean","title":"variable qmean","text":"<pre><code>float* bndparam::qmean;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-qmean_g","title":"variable qmean_g","text":"<pre><code>float* bndparam::qmean_g;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-side","title":"variable side","text":"<pre><code>int bndparam::side;\n</code></pre>"},{"location":"BGFlood/classbndparam/#variable-type","title":"variable type","text":"<pre><code>int bndparam::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/classbndsegment/","title":"Class bndsegment","text":""},{"location":"BGFlood/classbndsegment/#class-bndsegment","title":"Class bndsegment","text":"<p>ClassList &gt; bndsegment</p>"},{"location":"BGFlood/classbndsegment/#public-attributes","title":"Public Attributes","text":"Type Name DynForcingP&lt; float &gt; WLmap bndsegmentside bot std::vector&lt; Windin &gt; data std::string inputfile bndsegmentside left int nblk   = <code>0</code> int nbnd bool on   = <code>false</code> Polygon poly std::string polyfile bndsegmentside right bndsegmentside top int type   = <code>1</code> bool uniform   = <code>true</code>"},{"location":"BGFlood/classbndsegment/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classbndsegment/#variable-wlmap","title":"variable WLmap","text":"<pre><code>DynForcingP&lt;float&gt; bndsegment::WLmap;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-bot","title":"variable bot","text":"<pre><code>bndsegmentside bndsegment::bot;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-data","title":"variable data","text":"<pre><code>std::vector&lt;Windin&gt; bndsegment::data;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-inputfile","title":"variable inputfile","text":"<pre><code>std::string bndsegment::inputfile;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-left","title":"variable left","text":"<pre><code>bndsegmentside bndsegment::left;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-nblk","title":"variable nblk","text":"<pre><code>int bndsegment::nblk;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-nbnd","title":"variable nbnd","text":"<pre><code>int bndsegment::nbnd;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-on","title":"variable on","text":"<pre><code>bool bndsegment::on;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-poly","title":"variable poly","text":"<pre><code>Polygon bndsegment::poly;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-polyfile","title":"variable polyfile","text":"<pre><code>std::string bndsegment::polyfile;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-right","title":"variable right","text":"<pre><code>bndsegmentside bndsegment::right;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-top","title":"variable top","text":"<pre><code>bndsegmentside bndsegment::top;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-type","title":"variable type","text":"<pre><code>int bndsegment::type;\n</code></pre>"},{"location":"BGFlood/classbndsegment/#variable-uniform","title":"variable uniform","text":"<pre><code>bool bndsegment::uniform;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/classbndsegmentside/","title":"Class bndsegmentside","text":""},{"location":"BGFlood/classbndsegmentside/#class-bndsegmentside","title":"Class bndsegmentside","text":"<p>ClassList &gt; bndsegmentside</p>"},{"location":"BGFlood/classbndsegmentside/#public-attributes","title":"Public Attributes","text":"Type Name int * blk int * blk_g int isright   = <code>0</code> int istop   = <code>0</code> int nblk   = <code>0</code> float * qmean float * qmean_g"},{"location":"BGFlood/classbndsegmentside/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classbndsegmentside/#variable-blk","title":"variable blk","text":"<pre><code>int* bndsegmentside::blk;\n</code></pre>"},{"location":"BGFlood/classbndsegmentside/#variable-blk_g","title":"variable blk_g","text":"<pre><code>int* bndsegmentside::blk_g;\n</code></pre>"},{"location":"BGFlood/classbndsegmentside/#variable-isright","title":"variable isright","text":"<pre><code>int bndsegmentside::isright;\n</code></pre>"},{"location":"BGFlood/classbndsegmentside/#variable-istop","title":"variable istop","text":"<pre><code>int bndsegmentside::istop;\n</code></pre>"},{"location":"BGFlood/classbndsegmentside/#variable-nblk","title":"variable nblk","text":"<pre><code>int bndsegmentside::nblk;\n</code></pre>"},{"location":"BGFlood/classbndsegmentside/#variable-qmean","title":"variable qmean","text":"<pre><code>float* bndsegmentside::qmean;\n</code></pre>"},{"location":"BGFlood/classbndsegmentside/#variable-qmean_g","title":"variable qmean_g","text":"<pre><code>float* bndsegmentside::qmean_g;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/classdeformmap/","title":"Class deformmap","text":""},{"location":"BGFlood/classdeformmap/#class-deformmap","title":"Class deformmap","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; deformmap</p> <p>Inherits the following classes: inputmap</p>"},{"location":"BGFlood/classdeformmap/#public-attributes","title":"Public Attributes","text":"Type Name TexSetP GPU T clampedge   = <code>0.0</code> double duration   = <code>0.0</code> bool iscavity   = <code>false</code> double startime   = <code>0.0</code> T * val"},{"location":"BGFlood/classdeformmap/#public-attributes-inherited-from-inputmap","title":"Public Attributes inherited from inputmap","text":"<p>See inputmap</p> Type Name double denanval   = <code>NAN</code> double dx   = <code>0.0</code> double dy   = <code>0.0</code> std::string extension bool flipxx   = <code>false</code> bool flipyy   = <code>false</code> double grdalpha   = <code>0.0</code> std::string inputfile int nx   = <code>0</code> int ny   = <code>0</code> std::string varname double xmax   = <code>0.0</code> double xo   = <code>0.0</code> double ymax   = <code>0.0</code> double yo   = <code>0.0</code>"},{"location":"BGFlood/classdeformmap/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classdeformmap/#variable-gpu","title":"variable GPU","text":"<pre><code>TexSetP deformmap&lt; T &gt;::GPU;\n</code></pre>"},{"location":"BGFlood/classdeformmap/#variable-clampedge","title":"variable clampedge","text":"<pre><code>T deformmap&lt; T &gt;::clampedge;\n</code></pre>"},{"location":"BGFlood/classdeformmap/#variable-duration","title":"variable duration","text":"<pre><code>double deformmap&lt; T &gt;::duration;\n</code></pre>"},{"location":"BGFlood/classdeformmap/#variable-iscavity","title":"variable iscavity","text":"<pre><code>bool deformmap&lt; T &gt;::iscavity;\n</code></pre>"},{"location":"BGFlood/classdeformmap/#variable-startime","title":"variable startime","text":"<pre><code>double deformmap&lt; T &gt;::startime;\n</code></pre>"},{"location":"BGFlood/classdeformmap/#variable-val","title":"variable val","text":"<pre><code>T* deformmap&lt; T &gt;::val;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/classforcingmap/","title":"Class forcingmap","text":""},{"location":"BGFlood/classforcingmap/#class-forcingmap","title":"Class forcingmap","text":"<p>ClassList &gt; forcingmap</p> <p>Inherits the following classes: inputmap</p> <p>Inherited by the following classes: DynForcingP,  DynForcingP</p>"},{"location":"BGFlood/classforcingmap/#public-attributes","title":"Public Attributes","text":"Type Name TexSetP GPU double dt std::string inputfile int instep   = <code>0</code> double nowvalue int nt double tmax double to std::vector&lt; Windin &gt; unidata bool uniform   = <code>false</code>"},{"location":"BGFlood/classforcingmap/#public-attributes-inherited-from-inputmap","title":"Public Attributes inherited from inputmap","text":"<p>See inputmap</p> Type Name double denanval   = <code>NAN</code> double dx   = <code>0.0</code> double dy   = <code>0.0</code> std::string extension bool flipxx   = <code>false</code> bool flipyy   = <code>false</code> double grdalpha   = <code>0.0</code> std::string inputfile int nx   = <code>0</code> int ny   = <code>0</code> std::string varname double xmax   = <code>0.0</code> double xo   = <code>0.0</code> double ymax   = <code>0.0</code> double yo   = <code>0.0</code>"},{"location":"BGFlood/classforcingmap/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classforcingmap/#variable-gpu","title":"variable GPU","text":"<pre><code>TexSetP forcingmap::GPU;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-dt","title":"variable dt","text":"<pre><code>double forcingmap::dt;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-inputfile","title":"variable inputfile","text":"<pre><code>std::string forcingmap::inputfile;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-instep","title":"variable instep","text":"<pre><code>int forcingmap::instep;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-nowvalue","title":"variable nowvalue","text":"<pre><code>double forcingmap::nowvalue;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-nt","title":"variable nt","text":"<pre><code>int forcingmap::nt;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-tmax","title":"variable tmax","text":"<pre><code>double forcingmap::tmax;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-to","title":"variable to","text":"<pre><code>double forcingmap::to;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-unidata","title":"variable unidata","text":"<pre><code>std::vector&lt;Windin&gt; forcingmap::unidata;\n</code></pre>"},{"location":"BGFlood/classforcingmap/#variable-uniform","title":"variable uniform","text":"<pre><code>bool forcingmap::uniform;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/classinputmap/","title":"Class inputmap","text":""},{"location":"BGFlood/classinputmap/#class-inputmap","title":"Class inputmap","text":"<p>ClassList &gt; inputmap</p> <p>Inherited by the following classes: StaticForcingP,  deformmap,  forcingmap</p>"},{"location":"BGFlood/classinputmap/#public-attributes","title":"Public Attributes","text":"Type Name double denanval   = <code>NAN</code> double dx   = <code>0.0</code> double dy   = <code>0.0</code> std::string extension bool flipxx   = <code>false</code> bool flipyy   = <code>false</code> double grdalpha   = <code>0.0</code> std::string inputfile int nx   = <code>0</code> int ny   = <code>0</code> std::string varname double xmax   = <code>0.0</code> double xo   = <code>0.0</code> double ymax   = <code>0.0</code> double yo   = <code>0.0</code>"},{"location":"BGFlood/classinputmap/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classinputmap/#variable-denanval","title":"variable denanval","text":"<pre><code>double inputmap::denanval;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-dx","title":"variable dx","text":"<pre><code>double inputmap::dx;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-dy","title":"variable dy","text":"<pre><code>double inputmap::dy;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-extension","title":"variable extension","text":"<pre><code>std::string inputmap::extension;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-flipxx","title":"variable flipxx","text":"<pre><code>bool inputmap::flipxx;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-flipyy","title":"variable flipyy","text":"<pre><code>bool inputmap::flipyy;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-grdalpha","title":"variable grdalpha","text":"<pre><code>double inputmap::grdalpha;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-inputfile","title":"variable inputfile","text":"<pre><code>std::string inputmap::inputfile;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-nx","title":"variable nx","text":"<pre><code>int inputmap::nx;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-ny","title":"variable ny","text":"<pre><code>int inputmap::ny;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-varname","title":"variable varname","text":"<pre><code>std::string inputmap::varname;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-xmax","title":"variable xmax","text":"<pre><code>double inputmap::xmax;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-xo","title":"variable xo","text":"<pre><code>double inputmap::xo;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-ymax","title":"variable ymax","text":"<pre><code>double inputmap::ymax;\n</code></pre>"},{"location":"BGFlood/classinputmap/#variable-yo","title":"variable yo","text":"<pre><code>double inputmap::yo;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/structmaskinfo/","title":"Struct maskinfo","text":""},{"location":"BGFlood/structmaskinfo/#struct-maskinfo","title":"Struct maskinfo","text":"<p>ClassList &gt; maskinfo</p>"},{"location":"BGFlood/structmaskinfo/#public-attributes","title":"Public Attributes","text":"Type Name int * blks int nblk   = <code>0</code> int * side int type   = <code>0</code>"},{"location":"BGFlood/structmaskinfo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structmaskinfo/#variable-blks","title":"variable blks","text":"<pre><code>int* maskinfo::blks;\n</code></pre>"},{"location":"BGFlood/structmaskinfo/#variable-nblk","title":"variable nblk","text":"<pre><code>int maskinfo::nblk;\n</code></pre>"},{"location":"BGFlood/structmaskinfo/#variable-side","title":"variable side","text":"<pre><code>int* maskinfo::side;\n</code></pre>"},{"location":"BGFlood/structmaskinfo/#variable-type","title":"variable type","text":"<pre><code>int maskinfo::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/structout_p/","title":"Struct outP","text":""},{"location":"BGFlood/structout_p/#struct-outp","title":"Struct outP","text":"<p>ClassList &gt; outP</p>"},{"location":"BGFlood/structout_p/#public-attributes","title":"Public Attributes","text":"Type Name int level double xmax double xmin double ymax double ymin float * z short * z_s"},{"location":"BGFlood/structout_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structout_p/#variable-level","title":"variable level","text":"<pre><code>int outP::level;\n</code></pre>"},{"location":"BGFlood/structout_p/#variable-xmax","title":"variable xmax","text":"<pre><code>double outP::xmax;\n</code></pre>"},{"location":"BGFlood/structout_p/#variable-xmin","title":"variable xmin","text":"<pre><code>double outP::xmin;\n</code></pre>"},{"location":"BGFlood/structout_p/#variable-ymax","title":"variable ymax","text":"<pre><code>double outP::ymax;\n</code></pre>"},{"location":"BGFlood/structout_p/#variable-ymin","title":"variable ymin","text":"<pre><code>double outP::ymin;\n</code></pre>"},{"location":"BGFlood/structout_p/#variable-z","title":"variable z","text":"<pre><code>float* outP::z;\n</code></pre>"},{"location":"BGFlood/structout_p/#variable-z_s","title":"variable z_s","text":"<pre><code>short* outP::z_s;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/structoutzone_b/","title":"Struct outzoneB","text":""},{"location":"BGFlood/structoutzone_b/#struct-outzoneb","title":"Struct outzoneB","text":"<p>ClassList &gt; outzoneB</p>"},{"location":"BGFlood/structoutzone_b/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; double &gt; OutputT int * blk int index_next_OutputT   = <code>0</code> int maxlevel int minlevel int nblk std::string outname double xmax double xo double ymax double yo"},{"location":"BGFlood/structoutzone_b/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/structoutzone_b/#variable-outputt","title":"variable OutputT","text":"<pre><code>std::vector&lt;double&gt; outzoneB::OutputT;\n</code></pre>"},{"location":"BGFlood/structoutzone_b/#variable-blk","title":"variable blk","text":"<pre><code>int* outzoneB::blk;\n</code></pre>"},{"location":"BGFlood/structoutzone_b/#variable-index_next_outputt","title":"variable index_next_OutputT","text":"<pre><code>int outzoneB::index_next_OutputT;\n</code></pre>"},{"location":"BGFlood/structoutzone_b/#variable-maxlevel","title":"variable maxlevel","text":"<pre><code>int outzoneB::maxlevel;\n</code></pre>"},{"location":"BGFlood/structoutzone_b/#variable-minlevel","title":"variable minlevel","text":"<pre><code>int outzoneB::minlevel;\n</code></pre>"},{"location":"BGFlood/structoutzone_b/#variable-nblk","title":"variable nblk","text":"<pre><code>int outzoneB::nblk;\n</code></pre>"},{"location":"BGFlood/structoutzone_b/#variable-outname","title":"variable outname","text":"<pre><code>std::string outzoneB::outname;\n</code></pre>"},{"location":"BGFlood/structoutzone_b/#variable-xmax","title":"variable xmax","text":"<pre><code>double outzoneB::xmax;\n</code></pre>"},{"location":"BGFlood/structoutzone_b/#variable-xo","title":"variable xo","text":"<pre><code>double outzoneB::xo;\n</code></pre>"},{"location":"BGFlood/structoutzone_b/#variable-ymax","title":"variable ymax","text":"<pre><code>double outzoneB::ymax;\n</code></pre>"},{"location":"BGFlood/structoutzone_b/#variable-yo","title":"variable yo","text":"<pre><code>double outzoneB::yo;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/classoutzone_p/","title":"Class outzoneP","text":""},{"location":"BGFlood/classoutzone_p/#class-outzonep","title":"Class outzoneP","text":"<p>ClassList &gt; outzoneP</p>"},{"location":"BGFlood/classoutzone_p/#public-attributes","title":"Public Attributes","text":"Type Name T_output Toutput std::string outname double xend double xstart double yend double ystart"},{"location":"BGFlood/classoutzone_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"BGFlood/classoutzone_p/#variable-toutput","title":"variable Toutput","text":"<pre><code>T_output outzoneP::Toutput;\n</code></pre>"},{"location":"BGFlood/classoutzone_p/#variable-outname","title":"variable outname","text":"<pre><code>std::string outzoneP::outname;\n</code></pre>"},{"location":"BGFlood/classoutzone_p/#variable-xend","title":"variable xend","text":"<pre><code>double outzoneP::xend;\n</code></pre>"},{"location":"BGFlood/classoutzone_p/#variable-xstart","title":"variable xstart","text":"<pre><code>double outzoneP::xstart;\n</code></pre>"},{"location":"BGFlood/classoutzone_p/#variable-yend","title":"variable yend","text":"<pre><code>double outzoneP::yend;\n</code></pre>"},{"location":"BGFlood/classoutzone_p/#variable-ystart","title":"variable ystart","text":"<pre><code>double outzoneP::ystart;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/namespaceutils/","title":"Namespace utils","text":""},{"location":"BGFlood/namespaceutils/#namespace-utils","title":"Namespace utils","text":"<p>Namespace List &gt; utils</p>"},{"location":"BGFlood/namespaceutils/#public-functions","title":"Public Functions","text":"Type Name __host__ __device__ const T &amp; max (const T &amp; a, const T &amp; b) Generic max function. template __host__ __device__ const double &amp; max&lt; double &gt; (const double &amp; a, const double &amp; b)  template __host__ __device__ const float &amp; max&lt; float &gt; (const float &amp; a, const float &amp; b)  template __host__ __device__ const int &amp; max&lt; int &gt; (const int &amp; a, const int &amp; b)  __host__ __device__ const T &amp; min (const T &amp; a, const T &amp; b) Generic min function. template __host__ __device__ const double &amp; min&lt; double &gt; (const double &amp; a, const double &amp; b)  template __host__ __device__ const float &amp; min&lt; float &gt; (const float &amp; a, const float &amp; b)  template __host__ __device__ const int &amp; min&lt; int &gt; (const int &amp; a, const int &amp; b)  __host__ __device__ const T &amp; nearest (const T &amp; a, const T &amp; b, const T &amp; c) Generic nearest value function to a given value c. __host__ __device__ const T &amp; nearest (const T &amp; a, const T &amp; b) Generic nearest value function to 0.0 between 2 parameter. template __host__ __device__ const double &amp; nearest&lt; double &gt; (const double &amp; a, const double &amp; b, const double &amp; c)  template __host__ __device__ const double &amp; nearest&lt; double &gt; (const double &amp; a, const double &amp; b)  template __host__ __device__ const float &amp; nearest&lt; float &gt; (const float &amp; a, const float &amp; b, const float &amp; c)  template __host__ __device__ const float &amp; nearest&lt; float &gt; (const float &amp; a, const float &amp; b)  template __host__ __device__ const int &amp; nearest&lt; int &gt; (const int &amp; a, const int &amp; b, const int &amp; c)  template __host__ __device__ const int &amp; nearest&lt; int &gt; (const int &amp; a, const int &amp; b)  __host__ __device__ T sq (T a) Generic squaring function. template double __host__ __device__ sq&lt; double &gt; (double a)  template float __host__ __device__ sq&lt; float &gt; (float a)  template int __host__ __device__ sq&lt; int &gt; (int a)"},{"location":"BGFlood/namespaceutils/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/namespaceutils/#function-max","title":"function max","text":"<p>Generic max function. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ const T &amp; utils::max (\n    const T &amp; a,\n    const T &amp; b\n) \n</code></pre> <p>! </p>"},{"location":"BGFlood/namespaceutils/#function-max-double","title":"function max&lt; double &gt;","text":"<pre><code>template __host__ __device__ const double &amp; utils::max&lt; double &gt; (\n    const double &amp; a,\n    const double &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-max-float","title":"function max&lt; float &gt;","text":"<pre><code>template __host__ __device__ const float &amp; utils::max&lt; float &gt; (\n    const float &amp; a,\n    const float &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-max-int","title":"function max&lt; int &gt;","text":"<pre><code>template __host__ __device__ const int &amp; utils::max&lt; int &gt; (\n    const int &amp; a,\n    const int &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-min","title":"function min","text":"<p>Generic min function. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ const T &amp; utils::min (\n    const T &amp; a,\n    const T &amp; b\n) \n</code></pre> <p>! </p>"},{"location":"BGFlood/namespaceutils/#function-min-double","title":"function min&lt; double &gt;","text":"<pre><code>template __host__ __device__ const double &amp; utils::min&lt; double &gt; (\n    const double &amp; a,\n    const double &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-min-float","title":"function min&lt; float &gt;","text":"<pre><code>template __host__ __device__ const float &amp; utils::min&lt; float &gt; (\n    const float &amp; a,\n    const float &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-min-int","title":"function min&lt; int &gt;","text":"<pre><code>template __host__ __device__ const int &amp; utils::min&lt; int &gt; (\n    const int &amp; a,\n    const int &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-nearest","title":"function nearest","text":"<p>Generic nearest value function to a given value c. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ const T &amp; utils::nearest (\n    const T &amp; a,\n    const T &amp; b,\n    const T &amp; c\n) \n</code></pre> <p>! </p>"},{"location":"BGFlood/namespaceutils/#function-nearest_1","title":"function nearest","text":"<p>Generic nearest value function to 0.0 between 2 parameter. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ const T &amp; utils::nearest (\n    const T &amp; a,\n    const T &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-nearest-double","title":"function nearest&lt; double &gt;","text":"<pre><code>template __host__ __device__ const double &amp; utils::nearest&lt; double &gt; (\n    const double &amp; a,\n    const double &amp; b,\n    const double &amp; c\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-nearest-double_1","title":"function nearest&lt; double &gt;","text":"<pre><code>template __host__ __device__ const double &amp; utils::nearest&lt; double &gt; (\n    const double &amp; a,\n    const double &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-nearest-float","title":"function nearest&lt; float &gt;","text":"<pre><code>template __host__ __device__ const float &amp; utils::nearest&lt; float &gt; (\n    const float &amp; a,\n    const float &amp; b,\n    const float &amp; c\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-nearest-float_1","title":"function nearest&lt; float &gt;","text":"<pre><code>template __host__ __device__ const float &amp; utils::nearest&lt; float &gt; (\n    const float &amp; a,\n    const float &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-nearest-int","title":"function nearest&lt; int &gt;","text":"<pre><code>template __host__ __device__ const int &amp; utils::nearest&lt; int &gt; (\n    const int &amp; a,\n    const int &amp; b,\n    const int &amp; c\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-nearest-int_1","title":"function nearest&lt; int &gt;","text":"<pre><code>template __host__ __device__ const int &amp; utils::nearest&lt; int &gt; (\n    const int &amp; a,\n    const int &amp; b\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-sq","title":"function sq","text":"<p>Generic squaring function. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T utils::sq (\n    T a\n) \n</code></pre> <p>! </p>"},{"location":"BGFlood/namespaceutils/#function-sq-double","title":"function sq&lt; double &gt;","text":"<pre><code>template double __host__ __device__ utils::sq&lt; double &gt; (\n    double a\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-sq-float","title":"function sq&lt; float &gt;","text":"<pre><code>template float __host__ __device__ utils::sq&lt; float &gt; (\n    float a\n) \n</code></pre>"},{"location":"BGFlood/namespaceutils/#function-sq-int","title":"function sq&lt; int &gt;","text":"<pre><code>template int __host__ __device__ utils::sq&lt; int &gt; (\n    int a\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Util_CPU.cu</code></p>"},{"location":"BGFlood/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"Dir src","text":""},{"location":"BGFlood/dir_68267d1309a1af8e8297ef4c3efbcdba/#dir-src","title":"Dir src","text":"<p>FileList &gt; src</p>"},{"location":"BGFlood/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","title":"Files","text":"Type Name file AdaptCriteria.cu file AdaptCriteria.h file Adaptation.cu file Adaptation.h file Advection.cu file Advection.h file Arrays.h file BG_Flood.cu file BG_Flood.h file Boundary.cu file Boundary.h file ConserveElevation.cu file ConserveElevation.h file FlowCPU.cu file FlowCPU.h file FlowGPU.cu file FlowGPU.h file FlowMLGPU.cu file FlowMLGPU.h file Forcing.h file Friction.cu file Friction.h file General.h file Gradients.cu file Gradients.h file GridManip.cu file GridManip.h file Halo.cu file Halo.h file InitEvolv.cu file InitEvolv.h file InitialConditions.cu file InitialConditions.h file Input.h file Kurganov.cu file Kurganov.h file Mainloop.cu file Mainloop.h file Meanmax.cu file Meanmax.h file MemManagement.cu file MemManagement.h file Mesh.cu Mesh initialization and management routines for BG_Flood GPU model. file Mesh.h file Multilayer.cu file Multilayer.h file Param.h file Poly.cu file Poly.h file ReadForcing.cu file ReadForcing.h file ReadInput.cu file ReadInput.h file Read_netcdf.cu file Read_netcdf.h file Reimann.cu file Reimann.h file Setup_GPU.cu file Setup_GPU.h file Spherical.cu file Spherical.h file Testing.cu file Testing.h file Updateforcing.cu file Updateforcing.h file Util_CPU.cu file Util_CPU.h file Write_netcdf.cu file Write_netcdf.h file Write_txtlog.cpp file Write_txtlog.h file utctime.cu file utctime.h <p>The documentation for this class was generated from the following file <code>src/</code></p>"},{"location":"BGFlood/_adapt_criteria_8cu/","title":"File AdaptCriteria.cu","text":""},{"location":"BGFlood/_adapt_criteria_8cu/#file-adaptcriteriacu","title":"File AdaptCriteria.cu","text":"<p>FileList &gt; src &gt; AdaptCriteria.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AdaptCriteria.h\"</code></li> </ul>"},{"location":"BGFlood/_adapt_criteria_8cu/#public-functions","title":"Public Functions","text":"Type Name int AdaptCriteria (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel) Selects and applies the adaptation criteria for mesh refinement/coarsening. template int AdaptCriteria&lt; double &gt; (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; XModel)  template int AdaptCriteria&lt; float &gt; (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; XModel)  int Thresholdcriteria (Param XParam, T threshold, T * z, BlockP&lt; T &gt; XBlock, bool * refine, bool * coarsen) Applies threshold-based adaptation criteria for mesh refinement/coarsening. template int Thresholdcriteria&lt; double &gt; (Param XParam, double threshold, double * z, BlockP&lt; double &gt; XBlock, bool * refine, bool * coarsen)  template int Thresholdcriteria&lt; float &gt; (Param XParam, float threshold, float * z, BlockP&lt; float &gt; XBlock, bool * refine, bool * coarsen)  int inrangecriteria (Param XParam, T zmin, T zmax, T * z, BlockP&lt; T &gt; XBlock, bool * refine, bool * coarsen) Applies in-range adaptation criteria for mesh refinement/coarsening. template int inrangecriteria&lt; double &gt; (Param XParam, double zmin, double zmax, double * z, BlockP&lt; double &gt; XBlock, bool * refine, bool * coarsen)  template int inrangecriteria&lt; float &gt; (Param XParam, float zmin, float zmax, float * z, BlockP&lt; float &gt; XBlock, bool * refine, bool * coarsen)  int targetlevelcriteria (Param XParam, StaticForcingP&lt; int &gt; targetlevelmap, BlockP&lt; T &gt; XBlock, bool * refine, bool * coarsen) Applies target level adaptation criteria for mesh refinement/coarsening. template int targetlevelcriteria&lt; double &gt; (Param XParam, StaticForcingP&lt; int &gt; targetlevelmap, BlockP&lt; double &gt; XBlock, bool * refine, bool * coarsen)  template int targetlevelcriteria&lt; float &gt; (Param XParam, StaticForcingP&lt; int &gt; targetlevelmap, BlockP&lt; float &gt; XBlock, bool * refine, bool * coarsen)"},{"location":"BGFlood/_adapt_criteria_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_adapt_criteria_8cu/#function-adaptcriteria","title":"function AdaptCriteria","text":"<p>Selects and applies the adaptation criteria for mesh refinement/coarsening. </p><pre><code>template&lt;class T&gt;\nint AdaptCriteria (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XModel</code> Model structure </li> </ul> <p>Returns:</p> <p>Success flag (0 or 1)</p> <p>This function chooses the adaptation method (\"Threshold\", \"Inrange\", \"Targetlevel\") based on XParam.AdaptCrit, and applies it to the mesh using the corresponding criteria function. It sets the refine/coarsen flags for each block according to the selected method and arguments. For \"Targetlevel\", it loops over all target adaptation maps. </p>"},{"location":"BGFlood/_adapt_criteria_8cu/#function-adaptcriteria-double","title":"function AdaptCriteria&lt; double &gt;","text":"<pre><code>template int AdaptCriteria&lt; double &gt; (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_adapt_criteria_8cu/#function-adaptcriteria-float","title":"function AdaptCriteria&lt; float &gt;","text":"<pre><code>template int AdaptCriteria&lt; float &gt; (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_adapt_criteria_8cu/#function-thresholdcriteria","title":"function Thresholdcriteria","text":"<p>Applies threshold-based adaptation criteria for mesh refinement/coarsening. </p><pre><code>template&lt;class T&gt;\nint Thresholdcriteria (\n    Param XParam,\n    T threshold,\n    T * z,\n    BlockP &lt; T &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>threshold</code> Threshold value for adaptation </li> <li><code>z</code> Array of variable values (e.g., water depth) </li> <li><code>XBlock</code> Block data structure </li> <li><code>refine</code> Array of refinement flags </li> <li><code>coarsen</code> Array of coarsening flags </li> </ul> <p>Returns:</p> <p>Success flag (0 or 1)</p> <p>Refines blocks where any cell value exceeds the threshold, coarsens otherwise.</p> <p>Threshold criteria is a general form of wet dry criteria. Simple wet/dry refining criteria. If the block is wet -&gt; refine is true. If the block is dry -&gt; coarsen is true. </p> <p>Warning:</p> <p>the refinement sanity check is meant to be done after running this function. </p>"},{"location":"BGFlood/_adapt_criteria_8cu/#function-thresholdcriteria-double","title":"function Thresholdcriteria&lt; double &gt;","text":"<pre><code>template int Thresholdcriteria&lt; double &gt; (\n    Param XParam,\n    double threshold,\n    double * z,\n    BlockP &lt; double &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre>"},{"location":"BGFlood/_adapt_criteria_8cu/#function-thresholdcriteria-float","title":"function Thresholdcriteria&lt; float &gt;","text":"<pre><code>template int Thresholdcriteria&lt; float &gt; (\n    Param XParam,\n    float threshold,\n    float * z,\n    BlockP &lt; float &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre>"},{"location":"BGFlood/_adapt_criteria_8cu/#function-inrangecriteria","title":"function inrangecriteria","text":"<p>Applies in-range adaptation criteria for mesh refinement/coarsening. </p><pre><code>template&lt;class T&gt;\nint inrangecriteria (\n    Param XParam,\n    T zmin,\n    T zmax,\n    T * z,\n    BlockP &lt; T &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>zmin</code> Minimum value for refinement </li> <li><code>zmax</code> Maximum value for refinement </li> <li><code>z</code> Array of variable values </li> <li><code>XBlock</code> Block data structure </li> <li><code>refine</code> Array of refinement flags </li> <li><code>coarsen</code> Array of coarsening flags </li> </ul> <p>Returns:</p> <p>Success flag (0 or 1)</p> <p>Refines blocks where any cell value is within [zmin, zmax], coarsens otherwise.</p> <p>Simple in-range refining criteria. If any value of z (could be any variable) is zmin &lt;= z &lt;= zmax the block will try to refine. Otherwise, the block will try to coarsen. </p> <p>Warning:</p> <p>the refinement sanity check is meant to be done after running this function. </p>"},{"location":"BGFlood/_adapt_criteria_8cu/#function-inrangecriteria-double","title":"function inrangecriteria&lt; double &gt;","text":"<pre><code>template int inrangecriteria&lt; double &gt; (\n    Param XParam,\n    double zmin,\n    double zmax,\n    double * z,\n    BlockP &lt; double &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre>"},{"location":"BGFlood/_adapt_criteria_8cu/#function-inrangecriteria-float","title":"function inrangecriteria&lt; float &gt;","text":"<pre><code>template int inrangecriteria&lt; float &gt; (\n    Param XParam,\n    float zmin,\n    float zmax,\n    float * z,\n    BlockP &lt; float &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre>"},{"location":"BGFlood/_adapt_criteria_8cu/#function-targetlevelcriteria","title":"function targetlevelcriteria","text":"<p>Applies target level adaptation criteria for mesh refinement/coarsening. </p><pre><code>template&lt;class T&gt;\nint targetlevelcriteria (\n    Param XParam,\n    StaticForcingP &lt; int &gt; targetlevelmap,\n    BlockP &lt; T &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>targetlevelmap</code> Map of target levels for adaptation </li> <li><code>XBlock</code> Block data structure </li> <li><code>refine</code> Array of refinement flags </li> <li><code>coarsen</code> Array of coarsening flags </li> </ul> <p>Returns:</p> <p>Success flag (0 or 1)</p> <p>Refines blocks where target level is greater than current, coarsens if equal or lower. </p>"},{"location":"BGFlood/_adapt_criteria_8cu/#function-targetlevelcriteria-double","title":"function targetlevelcriteria&lt; double &gt;","text":"<pre><code>template int targetlevelcriteria&lt; double &gt; (\n    Param XParam,\n    StaticForcingP &lt; int &gt; targetlevelmap,\n    BlockP &lt; double &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre>"},{"location":"BGFlood/_adapt_criteria_8cu/#function-targetlevelcriteria-float","title":"function targetlevelcriteria&lt; float &gt;","text":"<pre><code>template int targetlevelcriteria&lt; float &gt; (\n    Param XParam,\n    StaticForcingP &lt; int &gt; targetlevelmap,\n    BlockP &lt; float &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AdaptCriteria.cu</code></p>"},{"location":"BGFlood/_adapt_criteria_8cu_source/","title":"File AdaptCriteria.cu","text":""},{"location":"BGFlood/_adapt_criteria_8cu_source/#file-adaptcriteriacu","title":"File AdaptCriteria.cu","text":"<p>File List &gt; src &gt; AdaptCriteria.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"AdaptCriteria.h\"\n\n// Adaptation criteria functions\n\ntemplate &lt;class T&gt; int AdaptCriteria(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel)\n{\n    int success = 0;\n    if (XParam.AdaptCrit.compare(\"Threshold\") == 0)\n    {\n        success = Thresholdcriteria(XParam, T(std::stod(XParam.Adapt_arg1)), XModel.OutputVarMap[XParam.Adapt_arg2], XModel.blocks, XModel.adapt.refine, XModel.adapt.coarsen);\n    }\n    if (XParam.AdaptCrit.compare(\"Inrange\") == 0)\n    {\n        success = inrangecriteria(XParam, T(std::stod(XParam.Adapt_arg1)), T(std::stod(XParam.Adapt_arg2)), XModel.OutputVarMap[XParam.Adapt_arg3], XModel.blocks, XModel.adapt.refine, XModel.adapt.coarsen);\n    }\n    if (XParam.AdaptCrit.compare(\"Targetlevel\") == 0)\n    {\n        for (int ig = 0; ig &lt; XForcing.targetadapt.size(); ig++)\n        {\n            targetlevelcriteria(XParam, XForcing.targetadapt[ig], XModel.blocks, XModel.adapt.refine, XModel.adapt.coarsen);\n        }\n    }\n    return success;\n}\ntemplate int AdaptCriteria&lt;float&gt;(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;float&gt; XModel);\ntemplate int AdaptCriteria&lt;double&gt;(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;double&gt; XModel);\n\ntemplate &lt;class T&gt; int Thresholdcriteria(Param XParam,T threshold, T* z, BlockP&lt;T&gt; XBlock, bool* refine, bool* coarsen)\n{\n    // Threshold criteria is a general form of wet dry criteria where esp is the threshold and h is the parameter tested\n    // Below is written as a wet dry analogy where wet is vlaue above threshold and dry is below\n\n\n    int success = 0;\n    //int i;\n\n    //Coarsen dry blocks and refine wet ones\n    //CPU version\n\n\n    // To start we assume all values are below the threshold\n    bool iswet = false;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        refine[ib] = false; // only refine if all are wet\n        coarsen[ib] = true; // always try to coarsen\n        iswet = false;\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(XParam, ix, iy, ib);\n                //(ix + XParam.halowidth) + (iy + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n\n                if (z[i] &gt; threshold)\n                {\n                    iswet = true;\n                }\n            }\n        }\n\n\n        refine[ib] = iswet;\n        coarsen[ib] = !iswet;\n\n        //printf(\"ib=%d; refibe[ib]=%s\\n\", ib, iswet ? \"true\" : \"false\");\n    }\n    return success;\n}\ntemplate  int Thresholdcriteria&lt;float&gt;(Param XParam, float threshold, float* z, BlockP&lt;float&gt; XBlock, bool* refine, bool* coarsen);\ntemplate  int Thresholdcriteria&lt;double&gt;(Param XParam, double threshold, double* z, BlockP&lt;double&gt; XBlock, bool* refine, bool* coarsen);\n\ntemplate&lt;class T&gt;\nint inrangecriteria(Param XParam, T zmin, T zmax, T* z, BlockP&lt;T&gt; XBlock, bool* refine, bool* coarsen)\n{\n    // First use a simple refining criteria: zb&gt;zmin &amp;&amp; zb&lt;zmax refine otherwise corasen\n    int success = 0;\n    //int i;\n\n\n    // To start \n    bool isinrange = false;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        refine[ib] = false; // only refine if zb is in range\n        coarsen[ib] = true; // always try to coarsen otherwise\n        isinrange = false;\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = (ix + XParam.halowidth) + (iy + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                if (z[i] &gt;= zmin &amp;&amp; z[i] &lt;= zmax)\n                {\n                    isinrange = true;\n                }\n            }\n        }\n\n\n        refine[ib] = isinrange;\n        coarsen[ib] = !isinrange;\n\n        //printf(\"ib=%d; refibe[ib]=%s\\n\", ib, iswet ? \"true\" : \"false\");\n    }\n    return success;\n}\ntemplate int inrangecriteria&lt;float&gt;(Param XParam, float zmin, float zmax, float* z, BlockP&lt;float&gt; XBlock, bool* refine, bool* coarsen);\ntemplate int inrangecriteria&lt;double&gt;(Param XParam, double zmin, double zmax, double* z, BlockP&lt;double&gt; XBlock, bool* refine, bool* coarsen);\n\ntemplate&lt;class T&gt;\nint targetlevelcriteria(Param XParam, StaticForcingP&lt;int&gt; targetlevelmap, BlockP&lt;T&gt; XBlock, bool* refine, bool* coarsen)\n{\n    int targetlevel;\n    bool uplevel, samelevel;\n    T delta, x, y;\n    int success = 0;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n\n        delta = T(calcres(XParam.dx, XBlock.level[ib]));\n\n        uplevel = false;\n        samelevel = false;\n\n        refine[ib] = false; // only refine if all are wet\n        coarsen[ib] = true; // always try to coarsen\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int n = memloc(XParam, ix, iy, ib);\n                x = T(XParam.xo) + XBlock.xo[ib] + T(ix) * delta;\n                y = T(XParam.yo) + XBlock.yo[ib] + T(iy) * delta;\n\n                targetlevel = int(round(interp2BUQ(x, y, targetlevelmap)));\n\n                if (targetlevel &gt; XBlock.level[ib])\n                {\n                    //printf(\"x=%f; y=%f; target=%d; level=%d\", x, y, targetlevel, XBlock.level[ib]);\n                    uplevel = true;\n\n                }\n                if (targetlevel == XBlock.level[ib])\n                {\n                    samelevel = true;\n\n                }\n\n\n            }\n        }\n\n        if (uplevel)\n        {\n            refine[ib] = true; // only refine if all are wet\n            coarsen[ib] = false;\n        }\n        else if (samelevel)\n        {\n            coarsen[ib] = false;\n        }\n\n    }\n    return success;\n}\ntemplate int targetlevelcriteria&lt;float&gt;(Param XParam, StaticForcingP&lt;int&gt; targetlevelmap, BlockP&lt;float&gt; XBlock, bool* refine, bool* coarsen);\ntemplate int targetlevelcriteria&lt;double&gt;(Param XParam, StaticForcingP&lt;int&gt; targetlevelmap, BlockP&lt;double&gt; XBlock, bool* refine, bool* coarsen);\n</code></pre>"},{"location":"BGFlood/_adapt_criteria_8h/","title":"File AdaptCriteria.h","text":""},{"location":"BGFlood/_adapt_criteria_8h/#file-adaptcriteriah","title":"File AdaptCriteria.h","text":"<p>FileList &gt; src &gt; AdaptCriteria.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Mesh.h\"</code></li> <li><code>#include \"Halo.h\"</code></li> <li><code>#include \"GridManip.h\"</code></li> </ul>"},{"location":"BGFlood/_adapt_criteria_8h/#public-functions","title":"Public Functions","text":"Type Name int AdaptCriteria (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel) Selects and applies the adaptation criteria for mesh refinement/coarsening. int Thresholdcriteria (Param XParam, T threshold, T * z, BlockP&lt; T &gt; XBlock, bool * refine, bool * coarsen) Applies threshold-based adaptation criteria for mesh refinement/coarsening. int inrangecriteria (Param XParam, T zmin, T zmax, T * z, BlockP&lt; T &gt; XBlock, bool * refine, bool * coarsen) Applies in-range adaptation criteria for mesh refinement/coarsening."},{"location":"BGFlood/_adapt_criteria_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_adapt_criteria_8h/#function-adaptcriteria","title":"function AdaptCriteria","text":"<p>Selects and applies the adaptation criteria for mesh refinement/coarsening. </p><pre><code>template&lt;class T&gt;\nint AdaptCriteria (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XModel</code> Model structure </li> </ul> <p>Returns:</p> <p>Success flag (0 or 1)</p> <p>This function chooses the adaptation method (\"Threshold\", \"Inrange\", \"Targetlevel\") based on XParam.AdaptCrit, and applies it to the mesh using the corresponding criteria function. It sets the refine/coarsen flags for each block according to the selected method and arguments. For \"Targetlevel\", it loops over all target adaptation maps. </p>"},{"location":"BGFlood/_adapt_criteria_8h/#function-thresholdcriteria","title":"function Thresholdcriteria","text":"<p>Applies threshold-based adaptation criteria for mesh refinement/coarsening. </p><pre><code>template&lt;class T&gt;\nint Thresholdcriteria (\n    Param XParam,\n    T threshold,\n    T * z,\n    BlockP &lt; T &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>threshold</code> Threshold value for adaptation </li> <li><code>z</code> Array of variable values (e.g., water depth) </li> <li><code>XBlock</code> Block data structure </li> <li><code>refine</code> Array of refinement flags </li> <li><code>coarsen</code> Array of coarsening flags </li> </ul> <p>Returns:</p> <p>Success flag (0 or 1)</p> <p>Refines blocks where any cell value exceeds the threshold, coarsens otherwise.</p> <p>Threshold criteria is a general form of wet dry criteria. Simple wet/dry refining criteria. If the block is wet -&gt; refine is true. If the block is dry -&gt; coarsen is true. </p> <p>Warning:</p> <p>the refinement sanity check is meant to be done after running this function. </p>"},{"location":"BGFlood/_adapt_criteria_8h/#function-inrangecriteria","title":"function inrangecriteria","text":"<p>Applies in-range adaptation criteria for mesh refinement/coarsening. </p><pre><code>template&lt;class T&gt;\nint inrangecriteria (\n    Param XParam,\n    T zmin,\n    T zmax,\n    T * z,\n    BlockP &lt; T &gt; XBlock,\n    bool * refine,\n    bool * coarsen\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>zmin</code> Minimum value for refinement </li> <li><code>zmax</code> Maximum value for refinement </li> <li><code>z</code> Array of variable values </li> <li><code>XBlock</code> Block data structure </li> <li><code>refine</code> Array of refinement flags </li> <li><code>coarsen</code> Array of coarsening flags </li> </ul> <p>Returns:</p> <p>Success flag (0 or 1)</p> <p>Refines blocks where any cell value is within [zmin, zmax], coarsens otherwise.</p> <p>Simple in-range refining criteria. If any value of z (could be any variable) is zmin &lt;= z &lt;= zmax the block will try to refine. Otherwise, the block will try to coarsen. </p> <p>Warning:</p> <p>the refinement sanity check is meant to be done after running this function. </p> <p>The documentation for this class was generated from the following file <code>src/AdaptCriteria.h</code></p>"},{"location":"BGFlood/_adapt_criteria_8h_source/","title":"File AdaptCriteria.h","text":""},{"location":"BGFlood/_adapt_criteria_8h_source/#file-adaptcriteriah","title":"File AdaptCriteria.h","text":"<p>File List &gt; src &gt; AdaptCriteria.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ADAPTCRITERIA_H\n#define ADAPTCRITERIA_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"Mesh.h\"\n#include \"Halo.h\"\n#include \"GridManip.h\"\n\ntemplate &lt;class T&gt; int inrangecriteria(Param XParam, T zmin, T zmax, T* z, BlockP&lt;T&gt; XBlock, bool* refine, bool* coarsen);\ntemplate &lt;class T&gt; int Thresholdcriteria(Param XParam, T threshold, T* z, BlockP&lt;T&gt; XBlock, bool* refine, bool* coarsen);\ntemplate &lt;class T&gt; int AdaptCriteria(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel);\n\n\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/","title":"File Adaptation.cu","text":""},{"location":"BGFlood/_adaptation_8cu/#file-adaptationcu","title":"File Adaptation.cu","text":"<p>FileList &gt; src &gt; Adaptation.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Adaptation.h\"</code></li> </ul>"},{"location":"BGFlood/_adaptation_8cu/#public-functions","title":"Public Functions","text":"Type Name void Adapt (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; &amp; XModel) Applies adaptation (refinement/coarsening) to the mesh and updates variables. void Adaptation (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; &amp; XModel) Performs mesh adaptation (refinement/coarsening) for the model. template void Adaptation&lt; double &gt; (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; &amp; XModel)  template void Adaptation&lt; float &gt; (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; &amp; XModel)  void Adaptationcleanup (Param &amp; XParam, BlockP&lt; T &gt; &amp; XBlock, AdaptP &amp; XAdapt) Cleans up and updates block lists after adaptation. template void Adaptationcleanup&lt; double &gt; (Param &amp; XParam, BlockP&lt; double &gt; &amp; XBlock, AdaptP &amp; XAdapt)  template void Adaptationcleanup&lt; float &gt; (Param &amp; XParam, BlockP&lt; float &gt; &amp; XBlock, AdaptP &amp; XAdapt)  int AddBlocks (int nnewblk, Param &amp; XParam, Model&lt; T &gt; &amp; XModel) Adds new blocks to the mesh for adaptation. template int AddBlocks&lt; double &gt; (int nnewblk, Param &amp; XParam, Model&lt; double &gt; &amp; XModel)  template int AddBlocks&lt; float &gt; (int nnewblk, Param &amp; XParam, Model&lt; float &gt; &amp; XModel)  int CalcAvailblk (Param &amp; XParam, BlockP&lt; T &gt; XBlock, AdaptP &amp; XAdapt) Calculates the number of available blocks for refinement. template int CalcAvailblk&lt; double &gt; (Param &amp; XParam, BlockP&lt; double &gt; XBlock, AdaptP &amp; XAdapt)  template int CalcAvailblk&lt; float &gt; (Param &amp; XParam, BlockP&lt; float &gt; XBlock, AdaptP &amp; XAdapt)  void InitialAdaptation (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel) Performs initial mesh adaptation and reruns initial conditions. template void InitialAdaptation&lt; double &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; double &gt; &amp; XModel)  template void InitialAdaptation&lt; float &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; float &gt; &amp; XModel)  bool checkBUQsanity (Param XParam, BlockP&lt; T &gt; XBlock) Checks the consistency and sanity of the block uniform quadtree mesh. template bool checkBUQsanity&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock)  template bool checkBUQsanity&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock)  bool checklevel (int ib, int levelib, int neighbourib, int levelneighbour)  bool checkneighbourdistance (double dx, int ib, int levelib, T blocko, int neighbourib, int levelneighbour, T neighbourblocko, bool rightortop) Checks if the distance between a block and its neighbor is consistent with their levels. int checkneighbourrefine (int neighbourib, int levelib, int levelneighbour, bool *&amp; refine, bool *&amp; coarsen)  void coarsen (Param XParam, BlockP&lt; T &gt; &amp; XBlock, AdaptP &amp; XAdapt, EvolvingP&lt; T &gt; XEvo, EvolvingP&lt; T &gt; &amp; XEv) Coarsens mesh blocks and updates conserved variables. template void coarsen&lt; double &gt; (Param XParam, BlockP&lt; double &gt; &amp; XBlock, AdaptP &amp; XAdapt, EvolvingP&lt; double &gt; XEvo, EvolvingP&lt; double &gt; &amp; XEv)  template void coarsen&lt; float &gt; (Param XParam, BlockP&lt; float &gt; &amp; XBlock, AdaptP &amp; XAdapt, EvolvingP&lt; float &gt; XEvo, EvolvingP&lt; float &gt; &amp; XEv)  void refine (Param XParam, BlockP&lt; T &gt; &amp; XBlock, AdaptP &amp; XAdapt, EvolvingP&lt; T &gt; XEvo, EvolvingP&lt; T &gt; &amp; XEv) Refines mesh blocks and interpolates conserved variables. template void refine&lt; double &gt; (Param XParam, BlockP&lt; double &gt; &amp; XBlock, AdaptP &amp; XAdapt, EvolvingP&lt; double &gt; XEvo, EvolvingP&lt; double &gt; &amp; XEv)  template void refine&lt; float &gt; (Param XParam, BlockP&lt; float &gt; &amp; XBlock, AdaptP &amp; XAdapt, EvolvingP&lt; float &gt; XEvo, EvolvingP&lt; float &gt; &amp; XEv)  bool refinesanitycheck (Param XParam, BlockP&lt; T &gt; XBlock, bool *&amp; refine, bool *&amp; coarsen)"},{"location":"BGFlood/_adaptation_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_adaptation_8cu/#function-adapt","title":"function Adapt","text":"<p>Applies adaptation (refinement/coarsening) to the mesh and updates variables. </p><pre><code>template&lt;class T&gt;\nvoid Adapt (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XModel</code> Model structure </li> </ul>"},{"location":"BGFlood/_adaptation_8cu/#function-adaptation","title":"function Adaptation","text":"<p>Performs mesh adaptation (refinement/coarsening) for the model. </p><pre><code>template&lt;class T&gt;\nvoid Adaptation (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XModel</code> Model structure</li> </ul> <p>Iteratively refines or coarsens the mesh based on adaptation criteria, updating block info and variables. </p>"},{"location":"BGFlood/_adaptation_8cu/#function-adaptation-double","title":"function Adaptation&lt; double &gt;","text":"<pre><code>template void Adaptation&lt; double &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-adaptation-float","title":"function Adaptation&lt; float &gt;","text":"<pre><code>template void Adaptation&lt; float &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-adaptationcleanup","title":"function Adaptationcleanup","text":"<p>Cleans up and updates block lists after adaptation. </p><pre><code>template&lt;class T&gt;\nvoid Adaptationcleanup (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XAdapt</code> Adaptation data structure</li> </ul> <p>Updates block levels, reorders active block list, and finalizes adaptation. </p>"},{"location":"BGFlood/_adaptation_8cu/#function-adaptationcleanup-double","title":"function Adaptationcleanup&lt; double &gt;","text":"<pre><code>template void Adaptationcleanup&lt; double &gt; (\n    Param &amp; XParam,\n    BlockP &lt; double &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-adaptationcleanup-float","title":"function Adaptationcleanup&lt; float &gt;","text":"<pre><code>template void Adaptationcleanup&lt; float &gt; (\n    Param &amp; XParam,\n    BlockP &lt; float &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-addblocks","title":"function AddBlocks","text":"<p>Adds new blocks to the mesh for adaptation. </p><pre><code>template&lt;class T&gt;\nint AddBlocks (\n    int nnewblk,\n    Param &amp; XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nnewblk</code> Number of new blocks to add </li> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure </li> </ul> <p>Returns:</p> <p>New total number of blocks in memory. </p>"},{"location":"BGFlood/_adaptation_8cu/#function-addblocks-double","title":"function AddBlocks&lt; double &gt;","text":"<pre><code>template int AddBlocks&lt; double &gt; (\n    int nnewblk,\n    Param &amp; XParam,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-addblocks-float","title":"function AddBlocks&lt; float &gt;","text":"<pre><code>template int AddBlocks&lt; float &gt; (\n    int nnewblk,\n    Param &amp; XParam,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-calcavailblk","title":"function CalcAvailblk","text":"<p>Calculates the number of available blocks for refinement. </p><pre><code>template&lt;class T&gt;\nint CalcAvailblk (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; XBlock,\n    AdaptP &amp; XAdapt\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XAdapt</code> Adaptation data structure </li> </ul> <p>Returns:</p> <p>Number of available blocks for refinement. </p>"},{"location":"BGFlood/_adaptation_8cu/#function-calcavailblk-double","title":"function CalcAvailblk&lt; double &gt;","text":"<pre><code>template int CalcAvailblk&lt; double &gt; (\n    Param &amp; XParam,\n    BlockP &lt; double &gt; XBlock,\n    AdaptP &amp; XAdapt\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-calcavailblk-float","title":"function CalcAvailblk&lt; float &gt;","text":"<pre><code>template int CalcAvailblk&lt; float &gt; (\n    Param &amp; XParam,\n    BlockP &lt; float &gt; XBlock,\n    AdaptP &amp; XAdapt\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-initialadaptation","title":"function InitialAdaptation","text":"<p>Performs initial mesh adaptation and reruns initial conditions. </p><pre><code>template&lt;class T&gt;\nvoid InitialAdaptation (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XModel</code> Model structure </li> </ul>"},{"location":"BGFlood/_adaptation_8cu/#function-initialadaptation-double","title":"function InitialAdaptation&lt; double &gt;","text":"<pre><code>template void InitialAdaptation&lt; double &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-initialadaptation-float","title":"function InitialAdaptation&lt; float &gt;","text":"<pre><code>template void InitialAdaptation&lt; float &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-checkbuqsanity","title":"function checkBUQsanity","text":"<p>Checks the consistency and sanity of the block uniform quadtree mesh. </p><pre><code>template&lt;class T&gt;\nbool checkBUQsanity (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> </ul> <p>Returns:</p> <p>True if mesh is sane, false otherwise. </p>"},{"location":"BGFlood/_adaptation_8cu/#function-checkbuqsanity-double","title":"function checkBUQsanity&lt; double &gt;","text":"<pre><code>template bool checkBUQsanity&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-checkbuqsanity-float","title":"function checkBUQsanity&lt; float &gt;","text":"<pre><code>template bool checkBUQsanity&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-checklevel","title":"function checklevel","text":"<pre><code>bool checklevel (\n    int ib,\n    int levelib,\n    int neighbourib,\n    int levelneighbour\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-checkneighbourdistance","title":"function checkneighbourdistance","text":"<p>Checks if the distance between a block and its neighbor is consistent with their levels. </p><pre><code>template&lt;class T&gt;\nbool checkneighbourdistance (\n    double dx,\n    int ib,\n    int levelib,\n    T blocko,\n    int neighbourib,\n    int levelneighbour,\n    T neighbourblocko,\n    bool rightortop\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>dx</code> Base grid spacing </li> <li><code>ib</code> Block index </li> <li><code>levelib</code> Block level </li> <li><code>blocko</code> Block coordinate </li> <li><code>neighbourib</code> Neighbor block index </li> <li><code>levelneighbour</code> Neighbor block level </li> <li><code>neighbourblocko</code> Neighbor block coordinate </li> <li><code>rightortop</code> True if neighbor is right/top, false if left/bottom </li> </ul> <p>Returns:</p> <p>True if distance is consistent, false otherwise. </p>"},{"location":"BGFlood/_adaptation_8cu/#function-checkneighbourrefine","title":"function checkneighbourrefine","text":"<pre><code>int checkneighbourrefine (\n    int neighbourib,\n    int levelib,\n    int levelneighbour,\n    bool *&amp; refine,\n    bool *&amp; coarsen\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-coarsen","title":"function coarsen","text":"<p>Coarsens mesh blocks and updates conserved variables. </p><pre><code>template&lt;class T&gt;\nvoid coarsen (\n    Param XParam,\n    BlockP &lt; T &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt,\n    EvolvingP &lt; T &gt; XEvo,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XAdapt</code> Adaptation data structure </li> <li><code>XEvo</code> Old evolving variables </li> <li><code>XEv</code> New evolving variables </li> </ul>"},{"location":"BGFlood/_adaptation_8cu/#function-coarsen-double","title":"function coarsen&lt; double &gt;","text":"<pre><code>template void coarsen&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt,\n    EvolvingP &lt; double &gt; XEvo,\n    EvolvingP &lt; double &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-coarsen-float","title":"function coarsen&lt; float &gt;","text":"<pre><code>template void coarsen&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt,\n    EvolvingP &lt; float &gt; XEvo,\n    EvolvingP &lt; float &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-refine","title":"function refine","text":"<p>Refines mesh blocks and interpolates conserved variables. </p><pre><code>template&lt;class T&gt;\nvoid refine (\n    Param XParam,\n    BlockP &lt; T &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt,\n    EvolvingP &lt; T &gt; XEvo,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XAdapt</code> Adaptation data structure </li> <li><code>XEvo</code> Old evolving variables </li> <li><code>XEv</code> New evolving variables </li> </ul>"},{"location":"BGFlood/_adaptation_8cu/#function-refine-double","title":"function refine&lt; double &gt;","text":"<pre><code>template void refine&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt,\n    EvolvingP &lt; double &gt; XEvo,\n    EvolvingP &lt; double &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-refine-float","title":"function refine&lt; float &gt;","text":"<pre><code>template void refine&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt,\n    EvolvingP &lt; float &gt; XEvo,\n    EvolvingP &lt; float &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8cu/#function-refinesanitycheck","title":"function refinesanitycheck","text":"<pre><code>template&lt;class T&gt;\nbool refinesanitycheck (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    bool *&amp; refine,\n    bool *&amp; coarsen\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Adaptation.cu</code></p>"},{"location":"BGFlood/_adaptation_8cu_source/","title":"File Adaptation.cu","text":""},{"location":"BGFlood/_adaptation_8cu_source/#file-adaptationcu","title":"File Adaptation.cu","text":"<p>File List &gt; src &gt; Adaptation.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Adaptation.h\"\n\n\n\ntemplate &lt;class T&gt; void Adaptation(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel)\n{\n    int oldnblk = 0;\n\n    int niteration = 0;\n\n    int maxiteration = XParam.adaptmaxiteration;\n    //fillHalo(XParam, XModel.blocks, XModel.evolv_o);\n    //fillCorners(XParam, XModel.blocks, XModel.evolv_o);\n    if (XParam.maxlevel != XParam.minlevel)\n    {\n        while (oldnblk != XParam.nblk &amp;&amp; niteration&lt; maxiteration)\n        {\n            niteration++;\n            log(\"\\t Iteration \" + std::to_string(niteration));\n            // Fill halo and corners\n            fillHalo(XParam, XModel.blocks, XModel.evolv_o);\n            fillCorners(XParam, XModel.blocks, XModel.evolv_o);\n\n\n            oldnblk = XParam.nblk;\n            //wetdrycriteria(XParam, refine, coarsen);\n            //inrangecriteria(XParam, (T)-5.2, (T)0.2, XModel.zb, XModel.blocks, XModel.adapt.refine, XModel.adapt.coarsen);\n            AdaptCriteria(XParam, XForcing, XModel);\n            refinesanitycheck(XParam, XModel.blocks, XModel.adapt.refine, XModel.adapt.coarsen);\n            //XParam = adapt(XParam);\n            Adapt(XParam, XForcing, XModel);\n\n\n            if (!checkBUQsanity(XParam,XModel.blocks))\n            {\n\n                XParam.outfile = \"Bad_mesh.nc\";\n                log(\"\\tERROR!!!  Bad BUQ mesh layout! See file: \"+ XParam.outfile);\n                copyID2var(XParam, XModel.blocks, XModel.flux.Fhu);\n                copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.LeftBot, XModel.grad.dhdx);\n                copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.LeftTop, XModel.grad.dhdy);\n                copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.TopLeft, XModel.grad.dzsdx);\n                copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.TopRight, XModel.grad.dzsdy);\n                copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.RightTop, XModel.grad.dudx);\n                copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.RightBot, XModel.grad.dudy);\n                copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.BotRight, XModel.grad.dvdx);\n                copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.BotLeft, XModel.grad.dvdy);\n\n                creatncfileBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, XModel.blocks.outZone[0]);\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"blockID\", 3, XModel.flux.Fhu, XModel.blocks.outZone[0]);\n\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"LeftBot\", 3, XModel.grad.dhdx, XModel.blocks.outZone[0]);\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"LeftTop\", 3, XModel.grad.dhdy, XModel.blocks.outZone[0]);\n\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"TopLeft\", 3, XModel.grad.dzsdx, XModel.blocks.outZone[0]);\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"TopRight\", 3, XModel.grad.dzsdy, XModel.blocks.outZone[0]);\n\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"RightTop\", 3, XModel.grad.dudx, XModel.blocks.outZone[0]);\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"RightBot\", 3, XModel.grad.dudy, XModel.blocks.outZone[0]);\n\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"BotLeft\", 3, XModel.grad.dvdx, XModel.blocks.outZone[0]);\n                defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"BotRight\", 3, XModel.grad.dvdy, XModel.blocks.outZone[0]);\n                exit(2);\n                break;\n            }\n\n\n        }\n        //=====================================\n        // Initialise Friction map\n\n        if (!XForcing.cf.empty())\n        {\n            interp2BUQ(XParam, XModel.blocks, XForcing.cf, XModel.cf);\n        }\n        else\n        {\n            InitArrayBUQ(XParam, XModel.blocks, (T)XParam.cf, XModel.cf);\n        }\n        // Set edges of friction map\n        setedges(XParam, XModel.blocks, XModel.cf);\n\n        //=====================================\n        // Initialise the continuous losses map\n        if (XParam.infiltration)\n        {\n            if (!XForcing.il.inputfile.empty())\n            {\n                interp2BUQ(XParam, XModel.blocks, XForcing.il, XModel.il);\n            }\n            else\n            {\n                InitArrayBUQ(XParam, XModel.blocks, (T)XParam.il, XModel.il);\n            }\n            if (!XForcing.cl.inputfile.empty())\n            {\n                interp2BUQ(XParam, XModel.blocks, XForcing.cl, XModel.cl);\n            }\n            else\n            {\n                InitArrayBUQ(XParam, XModel.blocks, (T)XParam.cl, XModel.cl);\n            }\n            // Set edges of friction map\n            setedges(XParam, XModel.blocks, XModel.il);\n            setedges(XParam, XModel.blocks, XModel.cl);\n        }\n\n    }\n}\ntemplate void Adaptation&lt;float&gt;(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;float&gt;&amp; XModel);\ntemplate void Adaptation&lt;double&gt;(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;double&gt;&amp; XModel);\n\n//Initial adaptation also reruns initial conditions\ntemplate &lt;class T&gt; void InitialAdaptation(Param&amp; XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;T&gt;&amp; XModel)\n{\n    if (XParam.maxlevel != XParam.minlevel)\n    {\n        log(\"Adapting mesh\");\n        Adaptation(XParam, XForcing, XModel);\n\n\n        InitialConditions(XParam, XForcing, XModel);\n\n\n\n    }\n}\ntemplate void InitialAdaptation&lt;float&gt;(Param&amp; XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;float&gt;&amp; XModel);\ntemplate void InitialAdaptation&lt;double&gt;(Param&amp; XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;double&gt;&amp; XModel);\n\n\ntemplate &lt;class T&gt; bool refinesanitycheck(Param XParam, BlockP&lt;T&gt; XBlock,  bool*&amp; refine, bool*&amp; coarsen)\n{\n    // Can't actually refine if the level is the max level (i.e. finest)\n    // this may be over-ruled later on\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        if (refine[ib] == true &amp;&amp; XBlock.level[ib] == XParam.maxlevel)\n        {\n            refine[ib] = false;\n            //printf(\"ib=%d; level[ib]=%d\\n\", ib, level[ib]);\n        }\n        if (coarsen[ib] == true &amp;&amp; XBlock.level[ib] == XParam.minlevel)\n        {\n            coarsen[ib] = false;\n        }\n        // Warning, Here cancelling all coasening because of a bug\n        // This could become an option for optimising the refinment process ??\n        coarsen[ib] = false;\n    }\n\n\n    // Can't corasen if any of your direct neighbour refines\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        if (refine[ib] == true)\n        {\n            //Can probably get away with checking only the principal 4 ?\n            coarsen[XBlock.RightBot[ib]] = false;\n            coarsen[XBlock.RightTop[ib]] = false;\n            coarsen[XBlock.LeftBot[ib]] = false;\n            coarsen[XBlock.LeftTop[ib]] = false;\n            coarsen[XBlock.TopLeft[ib]] = false;\n            coarsen[XBlock.TopRight[ib]] = false;\n            coarsen[XBlock.BotLeft[ib]] = false;\n            coarsen[XBlock.BotRight[ib]] = false;\n        }\n    }\n\n    // Can't coarsen if any neighbours have a higher level\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        if (coarsen[ib] == true)\n        {\n            int levi = XBlock.level[ib];\n            //printf(\"ib=%d; leftblk[ib]=%d; rightblk[ib]=%d, topblk[ib]=%d, botblk[ib]=%d\\n\", ib, leftblk[ib], rightblk[ib], topblk[ib], botblk[ib]);\n            if (levi &lt; XBlock.level[XBlock.LeftBot[ib]] ||  levi &lt; XBlock.level[XBlock.RightBot[ib]] || levi &lt; XBlock.level[XBlock.TopLeft[ib]] || levi &lt; XBlock.level[XBlock.BotLeft[ib]])\n            {\n                coarsen[ib] = false;\n            }\n        }\n    }\n\n\n    //check whether neighbour need refinement because they are too coarse to allow one to refine\n    // This below could be cascading so need to iterate several time\n    int iter = 1;\n\n    while (iter &gt; 0)\n    {\n        iter = 0;\n\n\n\n        for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n        {\n            int ib = XBlock.active[ibl];\n\n\n            if (refine[ib] == true)\n            {\n                iter += checkneighbourrefine(XBlock.TopLeft[ib], XBlock.level[ib], XBlock.level[XBlock.TopLeft[ib]], refine, coarsen);\n                //iter += checkneighbourrefine(XBlock.TopRight[ib], XBlock.level[ib], XBlock.level[XBlock.TopRight[ib]], refine, coarsen);\n                iter += checkneighbourrefine(XBlock.BotLeft[ib], XBlock.level[ib], XBlock.level[XBlock.BotLeft[ib]], refine, coarsen);\n                //iter += checkneighbourrefine(XBlock.BotRight[ib], XBlock.level[ib], XBlock.level[XBlock.BotRight[ib]], refine, coarsen);\n                iter += checkneighbourrefine(XBlock.LeftBot[ib], XBlock.level[ib], XBlock.level[XBlock.LeftBot[ib]], refine, coarsen);\n                //iter += checkneighbourrefine(XBlock.LeftTop[ib], XBlock.level[ib], XBlock.level[XBlock.LeftTop[ib]], refine, coarsen);\n                iter += checkneighbourrefine(XBlock.RightBot[ib], XBlock.level[ib], XBlock.level[XBlock.RightBot[ib]], refine, coarsen);\n                //iter += checkneighbourrefine(XBlock.RightTop[ib], XBlock.level[ib], XBlock.level[XBlock.RightTop[ib]], refine, coarsen);\n\n            }\n\n        }\n    }\n\n\n\n\n    // Can't actually coarsen if top, right and topright block are not all corsen\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n\n        //printf(\"ib=%d\\n\", ib);\n        // if all the neighbour are not wet then coarsen if possible\n        double dxfac = calcres(XParam.dx, XBlock.level[ib]);\n        //printf(\"blockxo_d[ib]=%f, dxfac=%f, ((blx-xo)/dx)%2=%d\\n\", blockxo_d[ib], dxfac, (int((blockxo_d[ib] - XParam.xo) / dxfac / XParam.blkwidth) % 2));\n        //only check for coarsening if the block analysed is a lower left corner block of the lower level\n        //need to prevent coarsenning if the block is on the model edges...\n        //((int((blockxo_d[ib] - XParam.xo) / dxfac) % 2) == 0 &amp;&amp; (int((blockyo_d[ib] - XParam.yo) / dxfac) % 2) == 0) &amp;&amp; rightblk[ib] != ib &amp;&amp; topblk[ib] != ib &amp;&amp; rightblk[topblk[ib]] != topblk[ib]\n        if (coarsen[ib] == true)\n        {\n            //if this block is a lower left corner block of teh potentialy coarser block\n            if (((int((XBlock.xo[ib]) / dxfac / XParam.blkwidth) % 2) == 0 &amp;&amp; (int((XBlock.yo[ib]) / dxfac / XParam.blkwidth) % 2) == 0 &amp;&amp; XBlock.RightBot[ib] != ib &amp;&amp;  XBlock.TopLeft[ib] != ib &amp;&amp; XBlock.RightBot[XBlock.TopRight[ib]] != XBlock.TopRight[ib]))\n            {\n                //if all the neighbour blocks ar at the same level\n                if (XBlock.level[ib] == XBlock.level[XBlock.RightBot[ib]] &amp;&amp; XBlock.level[ib] == XBlock.level[XBlock.TopLeft[ib]] &amp;&amp; XBlock.level[ib] == XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]])\n                {\n                    //printf(\"Is it true?\\t\");\n                    //if right, top and topright block teh same level and can coarsen\n                    if (coarsen[XBlock.RightBot[ib]] == true &amp;&amp; coarsen[XBlock.TopLeft[ib]] == true &amp;&amp; coarsen[XBlock.RightBot[XBlock.TopRight[ib]]] == true)\n                    {\n                        //Yes\n                        //printf(\"Yes!\\n\");\n                        //coarsen[ib] = true;\n                    }\n                    else\n                    {\n                        coarsen[ib] = false;\n                    }\n                }\n                else\n                {\n                    coarsen[ib] = false;\n                }\n\n            }\n            else\n            {\n                coarsen[ib] = false;\n            }\n        }\n\n    }\n    return true;\n}\n\n\nint checkneighbourrefine(int neighbourib,int levelib, int levelneighbour, bool*&amp; refine, bool*&amp; coarsen)\n{\n    int iter = 0;\n    if (refine[neighbourib] == false &amp;&amp; (levelneighbour &lt; levelib))\n    {\n        refine[neighbourib] = true;\n        coarsen[neighbourib] = false;\n        iter++;\n    }\n    if (levelneighbour == levelib)\n    {\n        coarsen [neighbourib]= false;\n    }\n    return iter;\n}\n\ntemplate &lt;class T&gt; bool checkBUQsanity(Param XParam,BlockP&lt;T&gt; XBlock)\n{\n    bool check = true;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        int nib;\n        // check that levels are consistent\n        check = check &amp;&amp; checklevel(ib, XBlock.level[ib], XBlock.LeftBot[ib], XBlock.level[XBlock.LeftBot[ib]]);\n        check = check &amp;&amp; checklevel(ib, XBlock.level[ib], XBlock.LeftTop[ib], XBlock.level[XBlock.LeftTop[ib]]);\n\n        check = check &amp;&amp; checklevel(ib, XBlock.level[ib], XBlock.TopLeft[ib], XBlock.level[XBlock.TopLeft[ib]]);\n        check = check &amp;&amp; checklevel(ib, XBlock.level[ib], XBlock.TopRight[ib], XBlock.level[XBlock.TopRight[ib]]);\n\n        check = check &amp;&amp; checklevel(ib, XBlock.level[ib], XBlock.RightTop[ib], XBlock.level[XBlock.RightTop[ib]]);\n        check = check &amp;&amp; checklevel(ib, XBlock.level[ib], XBlock.RightBot[ib], XBlock.level[XBlock.RightBot[ib]]);\n\n        check = check &amp;&amp; checklevel(ib, XBlock.level[ib], XBlock.BotRight[ib], XBlock.level[XBlock.BotRight[ib]]);\n        check = check &amp;&amp; checklevel(ib, XBlock.level[ib], XBlock.BotLeft[ib], XBlock.level[XBlock.BotLeft[ib]]);\n\n        //check that neighbour distance makes sense with level\n        nib = XBlock.LeftBot[ib];\n        check = check &amp;&amp; checkneighbourdistance(XParam.dx, ib, XBlock.level[ib], XBlock.xo[ib], nib, XBlock.level[nib], XBlock.xo[nib], false);\n        nib = XBlock.LeftTop[ib];\n        check = check &amp;&amp; checkneighbourdistance(XParam.dx, ib, XBlock.level[ib], XBlock.xo[ib], nib, XBlock.level[nib], XBlock.xo[nib], false);\n\n        nib = XBlock.RightTop[ib];\n        check = check &amp;&amp; checkneighbourdistance(XParam.dx, ib, XBlock.level[ib], XBlock.xo[ib], nib, XBlock.level[nib], XBlock.xo[nib], true);\n        nib = XBlock.RightBot[ib];\n        check = check &amp;&amp; checkneighbourdistance(XParam.dx, ib, XBlock.level[ib], XBlock.xo[ib], nib, XBlock.level[nib], XBlock.xo[nib], true);\n\n        nib = XBlock.TopRight[ib];\n        check = check &amp;&amp; checkneighbourdistance(XParam.dx, ib, XBlock.level[ib], XBlock.yo[ib], nib, XBlock.level[nib], XBlock.yo[nib], true);\n        nib = XBlock.TopLeft[ib];\n        check = check &amp;&amp; checkneighbourdistance(XParam.dx, ib, XBlock.level[ib], XBlock.yo[ib], nib, XBlock.level[nib], XBlock.yo[nib], true);\n\n        nib = XBlock.BotLeft[ib];\n        check = check &amp;&amp; checkneighbourdistance(XParam.dx, ib, XBlock.level[ib], XBlock.yo[ib], nib, XBlock.level[nib], XBlock.yo[nib], false);\n        nib = XBlock.BotRight[ib];\n        check = check &amp;&amp; checkneighbourdistance(XParam.dx, ib, XBlock.level[ib], XBlock.yo[ib], nib, XBlock.level[nib], XBlock.yo[nib], false);\n    }\n\n    return check;\n\n}\ntemplate bool checkBUQsanity&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock);\ntemplate bool checkBUQsanity&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock);\n\nbool checklevel(int ib, int levelib, int neighbourib, int levelneighbour)\n{\n    bool check = true;\n    if (abs(levelneighbour - (levelib)) &gt; 1)\n    {\n        log(\"Warning! Bad Neighbour Level. ib=\"+std::to_string(ib)+\"; level[ib]=\"+ std::to_string(levelib)+\"; neighbour[ib]=\"+ std::to_string(neighbourib) +\"; level[neighbour[ib]]=\"+ std::to_string(levelneighbour));\n        check = false;\n    }\n    return check;\n}\n\ntemplate &lt;class T&gt; bool checkneighbourdistance(double dx, int ib, int levelib, T blocko, int neighbourib, int levelneighbour, T neighbourblocko, bool rightortop )\n{\n    T expecteddistance= blocko;\n    bool test;\n    if (neighbourib != ib)\n    {\n        if (rightortop)\n        {\n            expecteddistance = blocko + calcres(T(dx), levelib) * T(15.5) + T(0.5) * calcres(T(dx), levelneighbour);\n        }\n        else\n        {\n            expecteddistance = blocko - calcres(T(dx), levelib) * T(0.5) - T(15.5) * calcres(T(dx), levelneighbour);\n        }\n\n    }\n\n    test= abs(expecteddistance - neighbourblocko) &lt; (calcres(T(dx), levelib) * 0.01);\n    if (!test)\n    {\n        log(\"Warning! Bad Neighbour distance. ib=\" + std::to_string(ib) + \"; level[ib]=\" + std::to_string(levelib) + \"; neighbour[ib]=\" + std::to_string(neighbourib) + \"; level[neighbour[ib]]=\" + std::to_string(levelneighbour));\n    }\n\n    return test;\n\n}\n\n\n\ntemplate &lt;class T&gt; void Adapt(Param &amp;XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel)\n{\n    int nnewblk = CalcAvailblk(XParam, XModel.blocks, XModel.adapt);\n\n    // Check if there are enough available block to refin \n    if (nnewblk &gt; XParam.navailblk)\n    {\n        //Reallocate\n        int nblkmem=AddBlocks(nnewblk, XParam, XModel);\n\n        log(\"\\t\\tReallocation complete: \"+std::to_string(XParam.navailblk)+\" new blocks are available ( \"+std::to_string(nblkmem)+\" blocks in memory) \");\n    }\n    //===========================================================\n    //  Start coarsening and refinement\n    // First Initialise newlevel (Do this every time because new level is reused later)\n\n    for (int ibl = 0; ibl &lt; XParam.nblkmem; ibl++)\n    {\n        // Set newlevel\n        XModel.adapt.newlevel[ibl] = XModel.blocks.level[ibl];\n    }\n\n    //=========================================================\n    //  COARSEN\n    coarsen(XParam, XModel.blocks, XModel.adapt, XModel.evolv_o, XModel.evolv);\n\n    //=========================================================\n    //  REFINE\n    refine(XParam, XModel.blocks, XModel.adapt, XModel.evolv_o, XModel.evolv);\n\n    //=========================================================\n    // CLEAN-UP\n    Adaptationcleanup(XParam, XModel.blocks, XModel.adapt);\n\n    //____________________________________________________\n    //\n    //  Reinterpolate zb. \n    //\n    //  Isn't it better to do that only for newly refined blk?\n    //  Not necessary if no coarsening/refinement occur\n    interp2BUQ(XParam, XModel.blocks, XForcing.Bathy, XModel.zb);\n\n    // Set edges\n    setedges(XParam, XModel.blocks, XModel.zb);\n\n    //____________________________________________________\n    //\n    //  Update hh and or zb\n    //\n    //  Recalculate hh from zs for fully wet cells and zs from zb for dry cells\n    //\n\n    // Because zb cannot be conserved through the refinement or coarsening\n    // We have to decide whtether to conserve elevation (zs) or Volume (hh)\n    // \n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam,ix,iy,ib);\n\n                if (XModel.evolv.h[i] &gt; XParam.eps)\n                {\n                    XModel.evolv.h[i] = max((T)XParam.eps, XModel.evolv.zs[i] - XModel.zb[i]);\n                }\n                else\n                {\n                    // when refining dry area zs should be zb!\n                    XModel.evolv.zs[i] = XModel.zb[i];\n                }\n\n\n\n            }\n        }\n    }\n\n    //copy back hh and zs to hho and zso\n    CopyArrayBUQ(XParam, XModel.blocks, XModel.evolv, XModel.evolv_o);\n\n}\n\ntemplate &lt;class T&gt; int CalcAvailblk(Param &amp;XParam, BlockP&lt;T&gt; XBlock, AdaptP&amp; XAdapt)\n{\n    //\n\n    int csum = -3;\n    int nrefineblk = 0;\n    int ncoarsenlk = 0;\n    int nnewblk = 0;\n\n    for (int ibl = 0; ibl &lt; XParam.nblkmem; ibl++)\n    {\n        XAdapt.invactive[ibl] = -1;\n\n\n    }\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        XAdapt.invactive[ib] = ibl;\n\n        // When refining we need csum\n        if (XAdapt.refine[ib] == true)\n        {\n            nrefineblk++;\n            csum = csum + 3;\n\n        }\n        if (XAdapt.coarsen[ib] == true)\n        {\n            ncoarsenlk++;\n\n\n        }\n        XAdapt.csumblk[ib] = csum;\n    }\n\n    //=========================================\n    //  Reconstruct availblk\n    XParam.navailblk = 0;\n    for (int ibl = 0; ibl &lt; XParam.nblkmem; ibl++)\n    {\n        if (XAdapt.invactive[ibl] == -1)\n        {\n            XAdapt.availblk[XParam.navailblk] = ibl;\n            XParam.navailblk++;\n        }\n\n    }\n\n    // How many new block are needed\n    // This below would be ideal but I don't see how that could work.\n    // One issue is to make the newly coarsen blocks directly available in the section above but that would make the code even more confusingalthough we haven't taken them into account in the \n    //nnewblk = 3*nrefineblk - ncoarsenlk*3;\n    // Below is conservative and keeps the peice of code above a bit more simple\n    nnewblk = 3 * nrefineblk;\n\n    log(\"\\t\\tThere are \"+ std::to_string(XParam.nblk) +\" active blocks (\"+ std::to_string(XParam.nblkmem) +\" blocks allocated in memory), \"+std::to_string(nrefineblk)+\" blocks to be refined, \"+std::to_string(ncoarsenlk)+\" blocks to be coarsen (with neighbour); \"+std::to_string(XParam.nblk - nrefineblk - 4 * ncoarsenlk)+\" blocks untouched; \"+std::to_string(ncoarsenlk * 3)+\" blocks to be freed (\"+ std::to_string(XParam.navailblk) +\" are already available) \"+std::to_string(nnewblk)+\" new blocks will be created\");\n\n    return nnewblk;\n\n}\ntemplate int CalcAvailblk&lt;float&gt;(Param &amp;XParam, BlockP&lt;float&gt; XBlock, AdaptP&amp; XAdapt);\ntemplate int CalcAvailblk&lt;double&gt;(Param &amp;XParam, BlockP&lt;double&gt; XBlock, AdaptP&amp; XAdapt);\n\ntemplate &lt;class T&gt; int AddBlocks(int nnewblk, Param&amp; XParam, Model&lt;T&gt;&amp; XModel)\n{\n    //\n    int nblkmem, oldblkmem;\n    oldblkmem = XParam.nblkmem;\n    nblkmem = (int)ceil((XParam.nblk + nnewblk) * XParam.membuffer);\n    XParam.nblkmem = nblkmem;\n    ReallocArray(nblkmem, XParam.blksize, XParam, XModel);\n\n\n    // Reconstruct blk info\n    XParam.navailblk = 0;\n    for (int ibl = 0; ibl &lt; (XParam.nblkmem - XParam.nblk); ibl++)\n    {\n        XModel.blocks.active[XParam.nblk + ibl] = -1;\n    }\n    for (int ibl = 0; ibl &lt; (XParam.nblkmem - oldblkmem); ibl++)\n    {\n        XModel.adapt.invactive[oldblkmem + ibl] = -1;\n\n\n    }\n\n    for (int ibl = 0; ibl &lt; XParam.nblkmem; ibl++)\n    {\n        if (XModel.adapt.invactive[ibl] == -1)\n        {\n            XModel.adapt.availblk[XParam.navailblk] = ibl;\n            XParam.navailblk++;\n        }\n\n    }\n\n    //Because reallocation may be producing different pointers we need to update the output map array\n\n    Initmaparray(XModel);\n    return nblkmem;\n}\ntemplate int AddBlocks&lt;float&gt;(int nnewblk, Param&amp; XParam, Model&lt;float&gt;&amp; XModel);\ntemplate int AddBlocks&lt;double&gt;(int nnewblk, Param&amp; XParam, Model&lt;double&gt;&amp; XModel);\n\n\ntemplate &lt;class T&gt; void coarsen(Param XParam, BlockP&lt;T&gt;&amp; XBlock, AdaptP&amp; XAdapt,EvolvingP&lt;T&gt; XEvo, EvolvingP&lt;T&gt;&amp; XEv )\n{\n    //=========================================================\n    //  COARSEN\n    //=========================================================\n    // This is a 2 step process\n    // 1. First deal with the conserved variables (hh,uu,vv,zs,zb)\n    // 2. Deactivate the block\n    // 3. Fix neighbours\n\n    //____________________________________________________\n    //\n    // Step 1 &amp; 2: Average conserved variables and deactivate the blocks\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        int i, ii, ir, it, itr;\n        if (XAdapt.coarsen[ib] == true)\n        {\n            double dxfac = calcres(XParam.dx, XBlock.level[ib]);\n            //int xnode = int((XBlock.xo[ib]) / dxfac / XParam.blkwidth);\n            //int ynode = int((XBlock.yo[ib]) / dxfac / XParam.blkwidth);\n\n            int ibr = XBlock.RightBot[ib];\n            int ibtl = XBlock.TopLeft[ib];\n            int ibtr = XBlock.TopLeft[XBlock.RightBot[ib]];\n\n\n            int oldrightbot = XBlock.RightBot[ibr];\n            int oldrighttop = XBlock.RightBot[ibtr];\n            //int oldtopofright = topblk[oldright];\n            int oldtopleft = XBlock.TopLeft[ibtl];\n            int oldtopright = XBlock.TopLeft[ibtr];\n            //int oldrightoftop = rightblk[oldtop];\n            int oldleftbot = XBlock.LeftBot[ib];\n            int oldlefttop = XBlock.LeftBot[ibtl];\n            //int oldtopofleft = topblk[oldleft];\n            int oldbotleft = XBlock.BotLeft[ib];\n            int oldbotright = XBlock.BotLeft[ibr];\n            //int oldrightofbot = rightblk[oldbot];\n\n\n\n\n            for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n            {\n                for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n                {\n                    i = memloc(XParam, ix, iy, ib);\n\n                    if (ix &lt; (XParam.blkwidth / 2) &amp;&amp; iy &lt; (XParam.blkwidth /2))\n                    {\n                        ii = memloc(XParam, ix * 2, iy * 2, ib);// ix * 2 + (iy * 2) * 16 + ib * XParam.blksize;\n                        ir = memloc(XParam, (ix * 2 + 1), (iy * 2), ib); //(ix * 2 + 1) + (iy * 2) * 16 + ib * XParam.blksize;\n                        it = memloc(XParam, (ix * 2 ), (iy * 2 + 1), ib);// (ix) * 2 + (iy * 2 + 1) * 16 + ib * XParam.blksize;\n                        itr = memloc(XParam, (ix * 2 + 1), (iy * 2 + 1), ib); //(ix * 2 + 1) + (iy * 2 + 1) * 16 + ib * XParam.blksize;\n                    }\n                    if (ix &gt;= (XParam.blkwidth / 2) &amp;&amp; iy &lt; (XParam.blkwidth / 2))\n                    {\n                        ii = memloc(XParam, (ix - XParam.blkwidth / 2) * 2, iy * 2, ibr);//((ix - 8) * 2) + (iy * 2) * 16 + rightblk[ib] * XParam.blksize;\n                        ir = memloc(XParam, (ix - XParam.blkwidth / 2) * 2 + 1, iy * 2, ibr);// ((ix - 8) * 2 + 1) + (iy * 2) * 16 + rightblk[ib] * XParam.blksize;\n                        it = memloc(XParam, (ix - XParam.blkwidth / 2) * 2, iy * 2 + 1, ibr);// ((ix - 8)) * 2 + (iy * 2 + 1) * 16 + rightblk[ib] * XParam.blksize;\n                        itr = memloc(XParam, (ix - XParam.blkwidth / 2) * 2 + 1, (iy * 2 + 1), ibr);// ((ix - 8) * 2 + 1) + (iy * 2 + 1) * 16 + rightblk[ib] * XParam.blksize;\n                    }\n                    if (ix &lt; (XParam.blkwidth / 2) &amp;&amp; iy &gt;= (XParam.blkwidth / 2))\n                    {\n                        ii = memloc(XParam, ix * 2, (iy - XParam.blkwidth / 2) * 2, ibtl);// ix * 2 + ((iy - 8) * 2) * 16 + topblk[ib] * XParam.blksize;\n                        ir = memloc(XParam, ix * 2 + 1, (iy - XParam.blkwidth / 2) * 2, ibtl);//(ix * 2 + 1) + ((iy - 8) * 2) * 16 + topblk[ib] * XParam.blksize;\n                        it = memloc(XParam, ix * 2, (iy - XParam.blkwidth / 2) * 2 + 1, ibtl);//(ix) * 2 + ((iy - 8) * 2 + 1) * 16 + topblk[ib] * XParam.blksize;\n                        itr = memloc(XParam, ix * 2 + 1, (iy - XParam.blkwidth / 2) * 2 + 1, ibtl);//(ix * 2 + 1) + ((iy - 8) * 2 + 1) * 16 + topblk[ib] * XParam.blksize;\n                    }\n                    if (ix &gt;= (XParam.blkwidth / 2) &amp;&amp; iy &gt;= (XParam.blkwidth / 2))\n                    {\n                        ii = memloc(XParam, (ix - XParam.blkwidth / 2) * 2, (iy - XParam.blkwidth / 2) * 2, ibtr);// (ix - 8) * 2 + ((iy - 8) * 2) * 16 + rightblk[topblk[ib]] * XParam.blksize;\n                        ir = memloc(XParam, (ix - XParam.blkwidth / 2) * 2 + 1, (iy - XParam.blkwidth / 2) * 2, ibtr);//((ix - 8) * 2 + 1) + ((iy - 8) * 2) * 16 + rightblk[topblk[ib]] * XParam.blksize;\n                        it = memloc(XParam, (ix - XParam.blkwidth / 2) * 2, (iy - XParam.blkwidth / 2) * 2 + 1, ibtr);//(ix - 8) * 2 + ((iy - 8) * 2 + 1) * 16 + rightblk[topblk[ib]] * XParam.blksize;\n                        itr = memloc(XParam, (ix - XParam.blkwidth / 2) * 2 + 1, (iy - XParam.blkwidth / 2) * 2 + 1, ibtr);//((ix - 8) * 2 + 1) + ((iy - 8) * 2 + 1) * 16 + rightblk[topblk[ib]] * XParam.blksize;\n                    }\n\n\n                    // These are the only guys that need to be coarsen, other are recalculated on the fly or interpolated from forcing\n                    XEv.h[i] = T(0.25) * (XEvo.h[ii] + XEvo.h[ir] + XEvo.h[it] + XEvo.h[itr]);\n                    XEv.zs[i] = T(0.25) * (XEvo.zs[ii] + XEvo.zs[ir] + XEvo.zs[it] + XEvo.zs[itr]);\n                    XEv.u[i] = T(0.25) * (XEvo.u[ii] + XEvo.u[ir] + XEvo.u[it] + XEvo.u[itr]);\n                    XEv.v[i] =  T(0.25) * (XEvo.v[ii] + XEvo.v[ir] + XEvo.v[it] + XEvo.v[itr]);\n                    //zb will be interpolated from input grid later // I wonder is this makes the bilinear interpolation scheme crash at the refining step for zb?\n                    // No because zb is also interpolated later from the original mesh data\n                    //zb[i] = 0.25 * (zbo[ii] + zbo[ir] + zbo[it], zbo[itr]);\n\n\n                }\n            }\n\n            //Need more?\n\n            // Make right, top and top-right block available for refine step\n            XAdapt.availblk[XParam.navailblk] = ibr;\n            XAdapt.availblk[XParam.navailblk + 1] = ibtl;\n            XAdapt.availblk[XParam.navailblk + 2] = ibtr;\n\n            XAdapt.newlevel[ib] = XBlock.level[ib] - 1;\n\n            //Do not comment! While this 3 line below seem irrelevant in a first order they are needed for the neighbours below (next step down) but then is not afterward\n            XAdapt.newlevel[ibr] = XBlock.level[ib] - 1;\n            XAdapt.newlevel[ibtl] = XBlock.level[ib] - 1;\n            XAdapt.newlevel[ibtr] = XBlock.level[ib] - 1;\n\n\n\n            // increment available block count\n            XParam.navailblk = XParam.navailblk + 3;\n\n            // Make right, top and top-right block inactive\n            XBlock.active[XAdapt.invactive[ibr]] = -1;\n            XBlock.active[XAdapt.invactive[ibtl]] = -1;\n            XBlock.active[XAdapt.invactive[ibtr]] = -1;\n\n            //check neighbour's (Full neighbour happens in the next big loop below)\n            if (ibr == oldrightbot) // Surely that can never be true. if that was the case the coarsening would not have been allowed!\n            {\n                XBlock.RightBot[ib] = ib;\n                //XBlock.RightTop[ib] = ib;\n            }\n            else\n            {\n                XBlock.RightBot[ib] = oldrightbot;\n                //XBlock.RightTop[ib] = oldright;\n            }\n            if (ibtr == oldrighttop) // Surely that can never be true. if that was the case the coarsening would not have been allowed!\n            {\n                XBlock.RightTop[ib] = ib;\n                //XBlock.RightTop[ib] = ib;\n            }\n            else\n            {\n                XBlock.RightTop[ib] = oldrighttop;\n                //XBlock.RightTop[ib] = oldright;\n            }\n\n\n\n            if (ibtl == oldtopleft)//Ditto here\n            {\n                XBlock.TopLeft[ib] = ib;\n            }\n            else\n            {\n                XBlock.TopLeft[ib] = oldtopleft;\n            }\n            if (ibtr == oldtopright)//Ditto here\n            {\n                XBlock.TopRight[ib] = ib;\n            }\n            else\n            {\n                XBlock.TopRight[ib] = oldtopright;\n            }\n\n\n\n            XBlock.LeftBot[ib] = oldleftbot;// It is that already but it clearer to spell it out\n            XBlock.LeftTop[ib] = oldlefttop;\n            if (oldlefttop == ibtl)\n            {\n                XBlock.LeftTop[ib] = ib;\n            }\n\n            XBlock.BotLeft[ib] = oldbotleft;\n            XBlock.BotRight[ib] = oldbotright;\n            if (oldbotright == ibr)\n            {\n                XBlock.BotRight[ib] = ib;\n            }\n\n            //Also need to do lft and bottom!\n\n\n\n            // Bot and left blk should remain unchanged at this stage(they will change if the neighbour themselves change)\n\n            XBlock.xo[ib] = XBlock.xo[ib] + T(calcres(XParam.dx, XBlock.level[ib] + 1));\n            XBlock.yo[ib] = XBlock.yo[ib] + T(calcres(XParam.dx, XBlock.level[ib] + 1));\n\n\n\n        }\n\n    }\n\n    //____________________________________________________\n    //\n    // Step 3: deal with neighbour\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n\n        if (ib &gt;= 0) // ib can be -1 for newly inactive blocks\n        {\n\n            int oldrightbot = XBlock.RightBot[ib];\n\n            int oldtopleft = XBlock.TopLeft[ib];\n\n            int oldleftbot = XBlock.LeftBot[ib];\n\n            int oldbotleft = XBlock.BotLeft[ib];\n\n\n\n\n\n            if (XAdapt.newlevel[oldleftbot] &lt; XBlock.level[oldleftbot])\n            {\n                //left blk has coarsen\n                if (XAdapt.coarsen[XBlock.LeftBot[oldleftbot]])\n                {\n                    XBlock.LeftBot[ib] = XBlock.LeftBot[oldleftbot];\n                    XBlock.LeftTop[ib] = XBlock.LeftBot[oldleftbot];\n                }\n                else\n                {\n                    XBlock.LeftBot[ib] = XBlock.BotLeft[XBlock.LeftBot[oldleftbot]];\n                    XBlock.LeftTop[ib] = XBlock.BotLeft[XBlock.LeftBot[oldleftbot]];\n                }\n            }\n\n\n\n\n            if (XAdapt.newlevel[oldbotleft] &lt; XBlock.level[oldbotleft])\n            {\n                // botblk has coarsen\n                if (XAdapt.coarsen[XBlock.BotLeft[oldbotleft]])\n                {\n                    XBlock.BotLeft[ib] = XBlock.BotLeft[oldbotleft];\n                    XBlock.BotRight[ib] = XBlock.BotLeft[oldbotleft];\n                }\n                else\n                {\n                    XBlock.BotLeft[ib] = XBlock.LeftBot[XBlock.BotLeft[oldbotleft]];\n                    XBlock.BotRight[ib] = XBlock.LeftBot[XBlock.BotLeft[oldbotleft]];\n                }\n            }\n\n\n\n            if (XAdapt.newlevel[oldrightbot] &lt; XBlock.level[oldrightbot])\n            {\n                // right block has coarsen\n                if (!XAdapt.coarsen[oldrightbot])\n                {\n                    XBlock.RightBot[ib] = XBlock.BotLeft[oldrightbot];\n                    XBlock.RightTop[ib] = XBlock.BotLeft[oldrightbot];\n\n                }\n                // else do nothing because the right block is the reference one\n            }\n\n\n            if (XAdapt.newlevel[oldtopleft] &lt; XBlock.level[oldtopleft])\n            {\n                // top blk has coarsen\n                if (!XAdapt.coarsen[oldtopleft])\n                {\n                    XBlock.TopLeft[ib] = XBlock.LeftBot[oldtopleft];\n                    XBlock.TopRight[ib] = XBlock.LeftBot[oldtopleft];\n                }\n\n\n            }\n\n\n        }\n    }\n\n    //____________________________________________________\n    //\n    // Step 4: deal with other neighbour pair\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n\n        if (ib &gt;= 0 &amp;&amp; (XAdapt.newlevel[ib] &lt; XBlock.level[ib])) // ib can be -1 for newly inactive blocks\n        {\n            if (XAdapt.newlevel[XBlock.LeftBot[ib]] &lt;= XAdapt.newlevel[ib])\n            {\n                XBlock.LeftTop[ib] = XBlock.LeftBot[ib]; // this is fine even if this is a boundary edge\n            }\n            else //(XAdapt.newlevel[XBlock.LeftBot[ib]] &gt; XAdapt.newlevel[ib])\n            {\n                XBlock.LeftTop[ib] = XBlock.TopLeft[XBlock.LeftBot[ib]];\n            }\n\n            if (XAdapt.newlevel[XBlock.RightBot[ib]] &lt;= XAdapt.newlevel[ib])\n            {\n                XBlock.RightTop[ib] = XBlock.RightBot[ib]; // this is fine even if this is a boundary edge\n            }\n            else //(XAdapt.newlevel[XBlock.LeftBot[ib]] &gt; XAdapt.newlevel[ib])\n            {\n                XBlock.RightTop[ib] = XBlock.TopLeft[XBlock.RightBot[ib]];\n            }\n\n            if (XAdapt.newlevel[XBlock.BotLeft[ib]] &lt;= XAdapt.newlevel[ib])\n            {\n                XBlock.BotRight[ib] = XBlock.BotLeft[ib];\n            }\n            else //(XAdapt.newlevel[XBlock.LeftBot[ib]] &gt; XAdapt.newlevel[ib])\n            {\n                XBlock.BotRight[ib] = XBlock.RightBot[XBlock.BotLeft[ib]];\n            }\n\n\n            if (XAdapt.newlevel[XBlock.TopLeft[ib]] &lt;= XAdapt.newlevel[ib])\n            {\n                XBlock.TopRight[ib] = XBlock.TopLeft[ib];\n            }\n            else //(XAdapt.newlevel[XBlock.TopBot[ib]] &gt; XAdapt.newlevel[ib])\n            {\n                XBlock.TopRight[ib] = XBlock.RightBot[XBlock.TopLeft[ib]];\n            }\n\n\n        }\n    }\n}\n\ntemplate void coarsen&lt;float&gt;(Param XParam, BlockP&lt;float&gt;&amp; XBlock, AdaptP&amp; XAdapt, EvolvingP&lt;float&gt; XEvo, EvolvingP&lt;float&gt;&amp; XEv);\ntemplate void coarsen&lt;double&gt;(Param XParam, BlockP&lt;double&gt;&amp; XBlock, AdaptP&amp; XAdapt, EvolvingP&lt;double&gt; XEvo, EvolvingP&lt;double&gt;&amp; XEv);\n\ntemplate &lt;class T&gt; void refine(Param XParam, BlockP&lt;T&gt;&amp; XBlock, AdaptP&amp; XAdapt, EvolvingP&lt;T&gt; XEvo, EvolvingP&lt;T&gt;&amp; XEv)\n{\n    //==========================================================================\n    //  REFINE\n    //==========================================================================\n    // This is also a multi step process:\n    //  1. Interpolate conserved variables (although zb is done here it is overwritten later down the code)\n    //  2. Set direct neighbours blockxo/yo and levels\n    //  3. Set wider neighbourhood\n    //  4. Activate new blocks \n\n    //____________________________________________________\n    //\n    // Step 1. Interpolate conserved variables\n\n    int nblk = XParam.nblk;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //\n\n        int ib = XBlock.active[ibl];\n        int o;\n        int  ii, ir, it,itr;\n\n\n        if (ib &gt;= 0) // ib can be -1 for newly inactive blocks\n        {\n            if (XAdapt.refine[ib])\n            {\n\n                // Bilinear interpolation\n                for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n                {\n                    for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n                    {\n                        int kx[] = { 0, XParam.blkwidth/2, 0, XParam.blkwidth/2 };\n                        int ky[] = { 0, 0, XParam.blkwidth/2, XParam.blkwidth/2 };\n                        int kb[] = { ib, XAdapt.availblk[XAdapt.csumblk[ib]], XAdapt.availblk[XAdapt.csumblk[ib] + 1], XAdapt.availblk[XAdapt.csumblk[ib] + 2] };\n\n                        //double mx, my;\n\n                        for (int kk = 0; kk &lt; 4; kk++)\n                        {\n\n                            int cx, fx, cy, fy;\n\n                            T lx, ly, rx, ry;\n\n                            lx = ix * T(0.5) - T(0.25);\n                            ly = iy * T(0.5) - T(0.25);\n\n\n                            fx = (int)floor(lx) + kx[kk];\n                            cx = (int)ceil(lx) + kx[kk];\n                            fy = (int)floor(ly) + ky[kk];\n                            cy = (int)ceil(ly) + ky[kk];\n\n                            rx = (lx)+T(kx[kk]);\n                            ry = (ly)+T(ky[kk]);\n\n                            o = memloc(XParam,ix,iy, kb[kk]);//ix + iy * 16 + kb[kk] * XParam.blksize;\n\n                            ii = memloc(XParam, fx, fy, ib);\n                            ir = memloc(XParam, cx, fy, ib);\n                            it = memloc(XParam, fx, cy, ib);\n                            itr = memloc(XParam, cx, cy, ib);\n\n\n                            //printf(\"fx = %d; cx=%d; fy=%d; cy=%d; rx=%f; ry=%f\\n\", fx, cx, fy, cy,rx,ry);\n\n                            //printf(\"First blk %f\\n\",BilinearInterpolation(h11, h12, h21, h22, fx, cx, fy, cy, rx, ry));\n\n                            XEv.h[o] = BilinearInterpolation(XEvo.h[ii], XEvo.h[it], XEvo.h[ir], XEvo.h[itr], (T)fx, (T)cx, (T)fy, (T)cy, rx, ry);\n                            XEv.zs[o] = BilinearInterpolation(XEvo.zs[ii], XEvo.zs[it], XEvo.zs[ir], XEvo.zs[itr], (T)fx, (T)cx, (T)fy, (T)cy, rx, ry);\n                            XEv.u[o] = BilinearInterpolation(XEvo.u[ii], XEvo.u[it], XEvo.u[ir], XEvo.u[itr], (T)fx, (T)cx, (T)fy, (T)cy, rx, ry);\n                            XEv.v[o] = BilinearInterpolation(XEvo.v[ii], XEvo.v[it], XEvo.v[ir], XEvo.v[itr], (T)fx, (T)cx, (T)fy, (T)cy, rx, ry);\n\n\n                        }\n\n                    }\n                }\n            }\n        }\n    }\n\n    //____________________________________________________\n    //  \n    // Step 2. Set direct neighbours blockxo/yo and levels\n    //\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        if (ib &gt;= 0) // ib can be -1 for newly inactive blocks\n        {\n            if (XAdapt.refine[ib])\n            {\n                double delx = calcres(XParam.dx, XBlock.level[ib] + 1);\n                double xoblk = XBlock.xo[ib] - 0.5 * delx;\n                double yoblk = XBlock.yo[ib] - 0.5 * delx;\n\n                int oldtopleft, oldrightbot;\n                //int oldleftbot, oldbotleft;\n                int oldtopright, oldlefttop, oldrighttop, oldbotright;\n\n\n                oldtopleft = XBlock.TopLeft[ib];\n                oldtopright = XBlock.TopRight[ib];\n\n                //oldbotleft = XBlock.BotLeft[ib];\n                oldbotright = XBlock.BotRight[ib];\n\n                oldrightbot = XBlock.RightBot[ib];\n                oldrighttop = XBlock.RightTop[ib];\n\n                //oldleftbot = XBlock.LeftBot[ib];\n                oldlefttop = XBlock.LeftTop[ib];\n\n                // One block becomes 4 blocks:\n                // ib is the starting blk and new bottom left blk\n                // ibr is the new bottom right blk\n                // ibtl is the new top left blk\n                // ibtr is the new top right block\n\n                int ibr, ibtl, ibtr;\n                ibr = XAdapt.availblk[XAdapt.csumblk[ib]];\n                ibtl = XAdapt.availblk[XAdapt.csumblk[ib] + 1];\n                ibtr = XAdapt.availblk[XAdapt.csumblk[ib] + 2];\n\n                // sort out block info\n                XAdapt.newlevel[ib] = XBlock.level[ib] + 1;\n                XAdapt.newlevel[ibr] = XBlock.level[ib] + 1;\n                XAdapt.newlevel[ibtl] = XBlock.level[ib] + 1;\n                XAdapt.newlevel[ibtr] = XBlock.level[ib] + 1;\n\n                XBlock.xo[ib] = T(xoblk);\n                XBlock.yo[ib] = T(yoblk);\n                //bottom right blk\n                XBlock.xo[ibr] = T(xoblk + (XParam.blkwidth) * delx);\n                XBlock.yo[ibr] = T(yoblk);\n                //top left blk\n                XBlock.xo[ibtl] = T(xoblk);\n                XBlock.yo[ibtl] = T(yoblk + (XParam.blkwidth) * delx);\n                //top right blk\n                XBlock.xo[ibtr] = T(xoblk + (XParam.blkwidth) * delx);\n                XBlock.yo[ibtr] = T(yoblk + (XParam.blkwidth) * delx);\n\n\n                //sort out internal blocks neighbour\n                // external neighbours are dealt with in the following loop\n\n                //top neighbours\n                XBlock.TopLeft[ib] = ibtl;\n                XBlock.TopRight[ib] = ibtl;\n\n                XBlock.TopLeft[ibtl] = oldtopleft;\n                XBlock.TopRight[ibtl] = oldtopleft;\n\n                XBlock.TopLeft[ibr] = ibtr;\n                XBlock.TopRight[ibr] = ibtr;\n\n                XBlock.TopLeft[ibtr] = oldtopright;\n                XBlock.TopRight[ibtr] = oldtopright;\n\n                // Right neighbours\n                XBlock.RightBot[ib] = ibr;\n                XBlock.RightTop[ib] = ibr;\n\n                XBlock.RightBot[ibr] = oldrightbot;\n                XBlock.RightTop[ibr] = oldrightbot;\n\n                XBlock.RightBot[ibtl] = ibtr;\n                XBlock.RightTop[ibtl] = ibtr;\n\n                XBlock.RightBot[ibtr] = oldrighttop;\n                XBlock.RightTop[ibtr] = oldrighttop;\n\n                //Bottom Neighbours\n                XBlock.BotLeft[ibtl] = ib;\n                XBlock.BotRight[ibtl] = ib;\n\n                XBlock.BotLeft[ibtr] = ibr;\n                XBlock.BotRight[ibtr] = ibr;\n\n                XBlock.BotLeft[ibr] = oldbotright;\n                XBlock.BotRight[ibr] = oldbotright;\n\n                //Left neightbour\n                XBlock.LeftBot[ibr] = ib;\n                XBlock.LeftTop[ibr] = ib;\n\n                XBlock.LeftBot[ibtr] = ibtl;\n                XBlock.LeftTop[ibtr] = ibtl;\n\n                XBlock.LeftBot[ibtl] = oldlefttop;\n                XBlock.LeftTop[ibtl] = oldlefttop;\n\n\n\n                XParam.navailblk = XParam.navailblk - 3;\n            }\n        }\n\n    }\n\n\n    //____________________________________________________\n    //  \n    //  Step 3. Set wider neighbourhood\n    //\n    // set the external neighbours\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        if (ib &gt;= 0) // ib can be -1 for newly inactive blocks\n        {\n            if (XAdapt.refine[ib])\n            {\n                int oldtopleft, oldleftbot, oldrightbot, oldbotleft;\n                int oldtopright, oldlefttop, oldrighttop, oldbotright;\n\n                // One block becomes 4 blocks:\n                // ib is the starting blk and new bottom left blk\n                // ibr is the new bottom right blk\n                // ibtl is the new top left blk\n                // ibtr is the new top right block\n\n                int ibr, ibtl, ibtr;\n                ibr = XAdapt.availblk[XAdapt.csumblk[ib]];\n                ibtl = XAdapt.availblk[XAdapt.csumblk[ib] + 1];\n                ibtr = XAdapt.availblk[XAdapt.csumblk[ib] + 2];\n\n                oldtopleft = XBlock.TopLeft[ibtl];\n                oldtopright = XBlock.TopRight[ibtr];\n\n                oldbotleft = XBlock.BotLeft[ib];\n                oldbotright = XBlock.BotRight[ibr];\n\n                oldrightbot = XBlock.RightBot[ibr];\n                oldrighttop = XBlock.RightTop[ibtr];\n\n                oldleftbot = XBlock.LeftBot[ib];\n                oldlefttop = XBlock.LeftTop[ibtl];\n\n\n                // Deal with neighbours \n                // This is F@*%!ng tedious!\n\n                //_________________________________\n                // Left Neighbours\n                if (XAdapt.refine[oldleftbot])// is true and possibly the top left guy!!!\n                {\n                    if (XAdapt.newlevel[oldleftbot] &lt; XAdapt.newlevel[ib])\n                    {\n                        if (abs(XBlock.yo[ib] - XBlock.yo[oldleftbot]) &lt; calcres(XParam.dx, XAdapt.newlevel[ib]))//(XBlock.RightBot[XBlock.RightBot[oldleftbot]] == ib) // bottom side\n                        {\n                            XBlock.LeftBot[ib] = XAdapt.availblk[XAdapt.csumblk[oldleftbot]];\n                            XBlock.LeftTop[ib] = XAdapt.availblk[XAdapt.csumblk[oldleftbot]];\n\n                            XBlock.LeftBot[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldleftbot]];\n                            XBlock.LeftTop[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldleftbot]];\n                        }\n                        else //Top side\n                        {\n                            XBlock.LeftBot[ib] = XAdapt.availblk[XAdapt.csumblk[oldleftbot] + 2];\n                            XBlock.LeftTop[ib] = XAdapt.availblk[XAdapt.csumblk[oldleftbot] + 2];\n\n                            XBlock.LeftBot[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldleftbot] + 2];\n                            XBlock.LeftTop[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldleftbot] + 2];\n                        }\n                    }\n                    else\n                    {\n                        if (oldleftbot == ib)\n                        {\n                            XBlock.LeftBot[ib] = ib;\n                            XBlock.LeftTop[ib] = ib;\n\n                            if (oldlefttop == ib)\n                            {\n                                XBlock.LeftBot[ibtl] = ibtl;\n                                XBlock.LeftTop[ibtl] = ibtl;\n                            }\n                            else if(XAdapt.refine[oldlefttop])\n                            {\n                                XBlock.LeftBot[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldlefttop]];\n                                XBlock.LeftTop[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldlefttop] + 2];\n                            }\n                            else\n                            {\n                                XBlock.LeftBot[ibtl] = oldlefttop;\n                                XBlock.LeftTop[ibtl] = oldlefttop;\n                                XBlock.RightBot[oldlefttop] = ibtl;\n                                XBlock.RightTop[oldlefttop] = ibtl;\n                            }\n\n                        }\n                        else if (XAdapt.newlevel[oldleftbot] == XAdapt.newlevel[ib])\n                        {\n                            XBlock.LeftBot[ib] = XAdapt.availblk[XAdapt.csumblk[oldleftbot]];\n                            XBlock.LeftTop[ib] = XAdapt.availblk[XAdapt.csumblk[oldleftbot]];\n\n                            XBlock.LeftBot[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldleftbot] + 2];\n                            XBlock.LeftTop[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldleftbot] + 2];\n                        }\n                        else\n                        {\n                            XBlock.LeftBot[ib] = XAdapt.availblk[XAdapt.csumblk[oldleftbot]];\n                            XBlock.LeftTop[ib] = XAdapt.availblk[XAdapt.csumblk[oldleftbot] + 2];\n                            if (oldlefttop == ib)\n                            {\n                                XBlock.LeftBot[ibtl] = ibtl;\n                                XBlock.LeftTop[ibtl] = ibtl;\n                            }\n                            else if (XAdapt.refine[oldlefttop])\n                            {\n                                XBlock.LeftBot[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldlefttop] ];\n                                XBlock.LeftTop[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldlefttop] + 2];\n                            }\n                            else\n                            {\n                                XBlock.LeftBot[ibtl] = oldlefttop;\n                                XBlock.LeftTop[ibtl] = oldlefttop;\n                                XBlock.RightBot[oldlefttop] = ibtl;\n                                XBlock.RightTop[oldlefttop] = ibtl;\n                            }\n                        }\n                    }\n                }\n                else // oldleftbot did not refine (couldn't have corasen either)\n                {\n                    XBlock.LeftTop[ib] = oldleftbot;\n\n                    if (XAdapt.newlevel[oldleftbot] &lt; XAdapt.newlevel[ib])\n                    {\n                        //Don't  need to do this part (i.e. it is already the case)\n                        //XBlock.LeftBot[ib] = oldleftbot;\n                        //XBlock.LeftTop[ib] = oldleftbot;\n\n                        //XBlock.LeftBot[ibtl] = oldleftbot;\n                        //XBlock.LeftTop[ibtl] = oldleftbot;\n                        XBlock.RightBot[oldleftbot] = ib;\n                        XBlock.RightTop[oldleftbot] = ibtl;\n                    }\n                    else\n                    {\n                        XBlock.RightBot[oldleftbot] = ib;\n                        XBlock.RightTop[oldleftbot] = ib;\n                        if (oldlefttop != ib)\n                        {\n\n                            if (!XAdapt.refine[oldlefttop])\n                            {\n                                XBlock.RightBot[oldlefttop] = ibtl;\n                                XBlock.RightTop[oldlefttop] = ibtl;\n                            }\n                            else\n                            {\n                                XBlock.LeftBot[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldlefttop]];\n                                XBlock.LeftTop[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldlefttop] + 2];\n                            }\n                        }\n                        else\n                        {\n                            XBlock.LeftBot[ibtl] = ibtl;\n                            XBlock.LeftTop[ibtl] = ibtl;\n                        }\n                    }\n                }\n\n                //_________________________________\n                // Right Neighbours\n                if (XAdapt.refine[oldrightbot])// is true and possibly the top left guy!!!\n                {\n                    if (XAdapt.newlevel[oldrightbot] &lt; XAdapt.newlevel[ib])\n                    {\n                        if (abs(XBlock.yo[ib]-XBlock.yo[oldrightbot])&lt;calcres(XParam.dx, XAdapt.newlevel[ib])) //XBlock.LeftBot[oldrightbot] == ib// bottom side\n                        {\n                            XBlock.RightBot[ibr] = oldrightbot;\n                            XBlock.RightTop[ibr] = oldrightbot;\n\n                            XBlock.RightBot[ibtr] = oldrightbot;\n                            XBlock.RightTop[ibtr] = oldrightbot;\n                        }\n                        else //Top side\n                        {\n                            XBlock.RightBot[ibr] = XAdapt.availblk[XAdapt.csumblk[oldrightbot] + 1];\n                            XBlock.RightTop[ibr] = XAdapt.availblk[XAdapt.csumblk[oldrightbot] + 1];\n\n                            XBlock.RightBot[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldrightbot] + 1];\n                            XBlock.RightTop[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldrightbot] + 1];\n                        }\n                    }\n                    else\n                    {\n                        if (oldrightbot == ib)\n                        {\n                            XBlock.RightBot[ibr] = ibr;\n                            XBlock.RightTop[ibr] = ibr;\n\n                            if (oldrighttop == ib)\n                            {\n                                XBlock.RightBot[ibtr] = ibtr;\n                                XBlock.RightTop[ibtr] = ibtr;\n                            }\n                            else if (XAdapt.refine[oldrighttop])\n                            {\n                                XBlock.RightBot[ibtr] = oldrighttop;\n                                XBlock.RightTop[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldrighttop] + 1];\n                            }\n                            else\n                            {\n                                XBlock.RightBot[ibtr] = oldrighttop;\n                                XBlock.RightTop[ibtr] = oldrighttop;\n                                XBlock.LeftBot[oldrighttop] = ibtr;\n                                XBlock.LeftTop[oldrighttop] = ibtr;\n                            }\n\n                        }\n                        else if (XAdapt.newlevel[oldrightbot] == XAdapt.newlevel[ib])\n                        {\n                            XBlock.RightBot[ibr] = oldrightbot;\n                            XBlock.RightTop[ibr] = oldrightbot;\n\n                            XBlock.RightBot[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldrightbot] + 1];\n                            XBlock.RightTop[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldrightbot] + 1];\n                        }\n                        else\n                        {\n                            XBlock.RightBot[ibr] = oldrightbot;\n                            XBlock.RightTop[ibr] = XAdapt.availblk[XAdapt.csumblk[oldrightbot] + 1];\n                            if (oldrighttop == ib)\n                            {\n                                XBlock.RightBot[ibtr] = ibtr;\n                                XBlock.RightTop[ibtr] = ibtr;\n                            }\n                            else if (XAdapt.refine[oldrighttop])\n                            {\n                                XBlock.RightBot[ibtr] = oldrighttop;\n                                XBlock.RightTop[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldrighttop] + 1];\n                            }\n                            else\n                            {\n                                XBlock.RightBot[ibtr] = oldrighttop;\n                                XBlock.RightTop[ibtr] = oldrighttop;\n                                XBlock.LeftBot[oldrighttop] = ibtr;\n                                XBlock.LeftTop[oldrighttop] = ibtr;\n                            }\n                        }\n                    }\n                }\n                else // oldrightbot did not refine (couldn't have corasen either)\n                {\n                    //XBlock.RightTop[ib] = oldrightbot;\n                    if (XAdapt.newlevel[oldrightbot] &lt; XAdapt.newlevel[ib])\n                    {\n                        //Don't  need to do this part (i.e. it is already the case)\n                        //XBlock.LeftBot[ib] = oldleftbot;\n                        //XBlock.LeftTop[ib] = oldleftbot;\n\n                        //XBlock.LeftBot[ibtl] = oldleftbot;\n                        //XBlock.LeftTop[ibtl] = oldleftbot;\n                        XBlock.LeftBot[oldrightbot] = ibr;\n                        XBlock.LeftTop[oldrightbot] = ibtr;\n                    }\n                    else\n                    {\n                        XBlock.LeftBot[oldrightbot] = ibr;\n                        XBlock.LeftTop[oldrightbot] = ibr;\n                        if (oldrighttop != ib)\n                        {\n\n                            if (!XAdapt.refine[oldrighttop])\n                            {\n                                XBlock.LeftBot[oldrighttop] = ibtr;\n                                XBlock.LeftTop[oldrighttop] = ibtr;\n                            }\n                            else\n                            {\n                                XBlock.RightBot[ibtr] = oldrighttop;\n                                XBlock.RightTop[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldrighttop] + 1];\n                            }\n                        }\n                        else\n                        {\n                            XBlock.RightBot[ibtr] = ibtr;\n                            XBlock.RightTop[ibtr] = ibtr;\n                        }\n                    }\n                }\n\n\n                //_________________________________\n                // Bottom Neighbours\n                if (XAdapt.refine[oldbotleft])// is true and possibly the top left guy!!!\n                {\n                    if (XAdapt.newlevel[oldbotleft] &lt; XAdapt.newlevel[ib])\n                    {\n                        if (abs(XBlock.xo[ib] - XBlock.xo[oldbotleft]) &lt; calcres(XParam.dx, XAdapt.newlevel[ib]))//(XBlock.TopLeft[XBlock.TopLeft[oldbotleft]] == ib) // left side\n                        {\n                            XBlock.BotLeft[ib] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 1];\n                            XBlock.BotRight[ib] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 1];\n\n                            XBlock.BotLeft[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 1];\n                            XBlock.BotRight[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 1];\n                        }\n                        else //Right side\n                        {\n                            XBlock.BotLeft[ib] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 2];\n                            XBlock.BotRight[ib] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 2];\n\n                            XBlock.BotLeft[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 2];\n                            XBlock.BotRight[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 2];\n                        }\n                    }\n                    else\n                    {\n                        if (oldbotleft == ib)\n                        {\n                            XBlock.BotLeft[ib] = ib;\n                            XBlock.BotRight[ib] = ib;\n\n                            if (oldbotright == ib)\n                            {\n                                XBlock.BotLeft[ibr] = ibr;\n                                XBlock.BotRight[ibr] = ibr;\n                            }\n                            else if (XAdapt.refine[oldbotright])\n                            {\n                                XBlock.BotLeft[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotright] + 1];\n                                XBlock.BotRight[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotright] + 2];\n                            }\n                            else\n                            {\n                                XBlock.BotLeft[ibr] = oldbotright;\n                                XBlock.BotRight[ibr] = oldbotright;\n                                XBlock.TopLeft[oldbotright] = ibr;\n                                XBlock.TopRight[oldbotright] = ibr;\n                            }\n\n                        }\n                        else if (XAdapt.newlevel[oldbotleft] == XAdapt.newlevel[ib])\n                        {\n                            XBlock.BotLeft[ib] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 1];\n                            XBlock.BotRight[ib] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 1];\n\n                            XBlock.BotLeft[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 2];\n                            XBlock.BotRight[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 2];\n                        }\n                        else\n                        {\n                            XBlock.BotLeft[ib] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 1];\n                            XBlock.BotRight[ib] = XAdapt.availblk[XAdapt.csumblk[oldbotleft] + 2];\n                            if (oldbotright == ib)\n                            {\n                                XBlock.BotLeft[ibr] = ibr;\n                                XBlock.BotRight[ibr] = ibr;\n                            }\n                            else if (XAdapt.refine[oldbotright])\n                            {\n                                XBlock.BotLeft[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotright] + 1];\n                                XBlock.BotRight[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotright] + 2];\n                            }\n                            else\n                            {\n                                XBlock.BotLeft[ibr] = oldbotright;\n                                XBlock.BotRight[ibr] = oldbotright;\n                                XBlock.TopLeft[oldbotright] = ibr;\n                                XBlock.TopRight[oldbotright] = ibr;\n                            }\n                        }\n                    }\n                }\n                else // oldbotleft did not refine (couldn't have corasen either)\n                {\n                    XBlock.BotRight[ib] = oldbotleft;\n\n                    if (XAdapt.newlevel[oldbotleft] &lt; XAdapt.newlevel[ib])\n                    {\n                        //Don't  need to do this part (i.e. it is already the case)\n                        //XBlock.LeftBot[ib] = oldleftbot;\n                        //XBlock.LeftTop[ib] = oldleftbot;\n\n                        //XBlock.LeftBot[ibtl] = oldleftbot;\n                        //XBlock.LeftTop[ibtl] = oldleftbot;\n                        XBlock.TopLeft[oldbotleft] = ib;\n                        XBlock.TopRight[oldbotleft] = ibr;\n                    }\n                    else\n                    {\n                        XBlock.TopLeft[oldbotleft] = ib;\n                        XBlock.TopRight[oldbotleft] = ib;\n\n                        if (oldbotright != ib)\n                        {\n\n                            if (!XAdapt.refine[oldbotright])\n                            {\n                                XBlock.TopLeft[oldbotright] = ibr;\n                                XBlock.TopRight[oldbotright] = ibr;\n                            }\n                            else\n                            {\n                                XBlock.BotLeft[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotright] + 1];\n                                XBlock.BotRight[ibr] = XAdapt.availblk[XAdapt.csumblk[oldbotright] + 2];\n                            }\n                        }\n                        else\n                        {\n                            XBlock.BotLeft[ibr] = ibr;\n                            XBlock.BotRight[ibr] = ibr;\n                        }\n                    }\n                }\n\n                //_________________________________\n                // Top Neighbours\n                if (XAdapt.refine[oldtopleft])// is true and possibly the top left guy!!!\n                {\n                    if (XAdapt.newlevel[oldtopleft] &lt; XAdapt.newlevel[ib])\n                    {\n                        if (abs(XBlock.xo[ib] - XBlock.xo[oldtopleft]) &lt; calcres(XParam.dx, XAdapt.newlevel[ib]))//(XBlock.BotLeft[oldtopleft] == ib) // left side\n                        {\n                            XBlock.TopLeft[ibtl] = oldtopleft;\n                            XBlock.TopRight[ibtl] = oldtopleft;\n\n                            XBlock.TopLeft[ibtr] = oldtopleft;\n                            XBlock.TopRight[ibtr] = oldtopleft;\n                        }\n                        else //Right side\n                        {\n                            XBlock.TopLeft[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldtopleft]];\n                            XBlock.TopRight[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldtopleft]];\n\n                            XBlock.TopLeft[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldtopleft]];\n                            XBlock.TopRight[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldtopleft]];\n                        }\n                    }\n                    else\n                    {\n                        if (oldtopleft == ib)\n                        {\n                            XBlock.TopLeft[ibtl] = ibtl;\n                            XBlock.TopRight[ibtl] = ibtl;\n\n                            if (oldtopright == ib)\n                            {\n                                XBlock.TopLeft[ibtr] = ibtr;\n                                XBlock.TopRight[ibtr] = ibtr;\n                            }\n                            else if (XAdapt.refine[oldtopright])\n                            {\n                                XBlock.TopLeft[ibtr] = oldtopright;\n                                XBlock.TopRight[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldtopright]];\n                            }\n                            else\n                            {\n                                XBlock.TopLeft[ibtr] = oldbotright;\n                                XBlock.TopRight[ibtr] = oldbotright;\n                                XBlock.BotLeft[oldtopright] = ibtr;\n                                XBlock.BotRight[oldtopright] = ibtr;\n                            }\n\n                        }\n                        else if (XAdapt.newlevel[oldtopleft] == XAdapt.newlevel[ib])\n                        {\n                            XBlock.TopLeft[ibtl] = oldtopleft;\n                            XBlock.TopRight[ibtl] = oldtopleft;\n\n                            XBlock.TopLeft[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldtopleft] ];\n                            XBlock.TopRight[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldtopleft] ];\n                        }\n                        else\n                        {\n                            XBlock.TopLeft[ibtl] = oldtopleft;\n                            XBlock.TopRight[ibtl] = XAdapt.availblk[XAdapt.csumblk[oldtopleft]];\n                            if (oldtopright == ib)\n                            {\n                                XBlock.TopLeft[ibtr] = ibtr;\n                                XBlock.TopRight[ibtr] = ibtr;\n                            }\n                            else if (XAdapt.refine[oldtopright])\n                            {\n                                XBlock.TopLeft[ibtr] = oldtopright;\n                                XBlock.TopRight[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldtopright]];\n                            }\n                            else\n                            {\n                                XBlock.TopLeft[ibtr] = oldtopright;\n                                XBlock.TopRight[ibtr] = oldtopright;\n                                XBlock.BotLeft[oldtopright] = ibtr;\n                                XBlock.BotRight[oldtopright] = ibtr;\n                            }\n                        }\n                    }\n                }\n                else // oldleftbot did not refine (couldn't have corasen either)\n                {\n                    //XBlock.TopRight[ib] = oldtopleft;\n                    if (XAdapt.newlevel[oldtopleft] &lt; XAdapt.newlevel[ib])\n                    {\n                        //Don't  need to do this part (i.e. it is already the case)\n                        //XBlock.LeftBot[ib] = oldleftbot;\n                        //XBlock.LeftTop[ib] = oldleftbot;\n\n                        //XBlock.LeftBot[ibtl] = oldleftbot;\n                        //XBlock.LeftTop[ibtl] = oldleftbot;\n                        XBlock.BotLeft[oldtopleft] = ibtl;\n                        XBlock.BotRight[oldtopleft] = ibtr;\n                    }\n                    else\n                    {\n                        XBlock.BotLeft[oldtopleft] = ibtl;\n                        XBlock.BotRight[oldtopleft] = ibtl;\n                        if (oldtopright != ib)\n                        {\n\n                            if (!XAdapt.refine[oldtopright])\n                            {\n                                XBlock.BotLeft[oldtopright] = ibtr;\n                                XBlock.BotRight[oldtopright] = ibtr;\n                            }\n                            else\n                            {\n                                XBlock.TopLeft[ibtr] = oldtopright;\n                                XBlock.TopRight[ibtr] = XAdapt.availblk[XAdapt.csumblk[oldtopright]];\n                            }\n                        }\n                        else\n                        {\n                            XBlock.TopLeft[ibtr] = ibtr;\n                            XBlock.TopRight[ibtr] = ibtr;\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n    //____________________________________________________\n    //  \n    //  Step 4. Activate new blocks \n    //\n\n    nblk = XParam.nblk;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //\n\n        int ib = XBlock.active[ibl];\n\n        if (ib &gt;= 0) // ib can be -1 for newly inactive blocks\n        {\n\n            if (XAdapt.refine[ib] == true)\n            {\n\n                //After that we are done so activate the new blocks\n                XBlock.active[nblk] = XAdapt.availblk[XAdapt.csumblk[ib]];\n                XBlock.active[nblk + 1] = XAdapt.availblk[XAdapt.csumblk[ib] + 1];\n                XBlock.active[nblk + 2] = XAdapt.availblk[XAdapt.csumblk[ib] + 2];\n\n\n\n                nblk = nblk + 3;\n            }\n        }\n    }\n\n    // Now clean up the mess\n}\ntemplate void refine&lt;float&gt;(Param XParam, BlockP&lt;float&gt;&amp; XBlock, AdaptP&amp; XAdapt, EvolvingP&lt;float&gt; XEvo, EvolvingP&lt;float&gt;&amp; XEv);\ntemplate void refine&lt;double&gt;(Param XParam, BlockP&lt;double&gt;&amp; XBlock, AdaptP&amp; XAdapt, EvolvingP&lt;double&gt; XEvo, EvolvingP&lt;double&gt;&amp; XEv);\n\n\ntemplate &lt;class T&gt; void Adaptationcleanup(Param &amp;XParam, BlockP&lt;T&gt;&amp; XBlock, AdaptP&amp; XAdapt)\n{\n    //===========================================================\n    // UPDATE all remaining variables and clean up\n\n    //____________________________________________________\n    //\n    //  Update level\n    //\n    for (int ibl = 0; ibl &lt; XParam.nblkmem; ibl++)\n    {\n        //\n\n        int ib = XBlock.active[ibl];\n\n\n        if (ib &gt;= 0) // ib can be -1 for newly inactive blocks\n        {\n\n\n            XBlock.level[ib] = XAdapt.newlevel[ib];\n\n\n        }\n    }\n\n    //____________________________________________________\n    //\n    //  Reorder activeblk\n    //\n    // \n    int nblk = XParam.nblk;\n    for (int ibl = 0; ibl &lt; XParam.nblkmem; ibl++)\n    {\n        //reuse newlevel as temporary storage for activeblk\n        XAdapt.newlevel[ibl] = XBlock.active[ibl];\n        XBlock.active[ibl] = -1;\n\n\n    }\n    // cleanup and Reorder active block list\n    int ib = 0;\n    for (int ibl = 0; ibl &lt; XParam.nblkmem; ibl++)\n    {\n\n        if (XAdapt.newlevel[ibl] != -1)//i.e. old activeblk\n        {\n            XBlock.active[ib] = XAdapt.newlevel[ibl];\n\n            ib++;\n        }\n    }\n\n    nblk = ib;\n\n    //____________________________________________________\n    //\n    //  Reset adaptive info\n    //\n    // \n    for (int ibl = 0; ibl &lt; XParam.nblkmem; ibl++)\n    {\n\n        XAdapt.newlevel[ibl] = 0;\n        XAdapt.refine[ibl] = false;\n        XAdapt.coarsen[ibl] = false;\n    }\n    XParam.nblk = nblk;\n\n}\n\ntemplate void Adaptationcleanup&lt;float&gt;(Param&amp; XParam, BlockP&lt;float&gt;&amp; XBlock, AdaptP&amp; XAdapt);\ntemplate void Adaptationcleanup&lt;double&gt;(Param&amp; XParam, BlockP&lt;double&gt;&amp; XBlock, AdaptP&amp; XAdapt);\n</code></pre>"},{"location":"BGFlood/_adaptation_8h/","title":"File Adaptation.h","text":""},{"location":"BGFlood/_adaptation_8h/#file-adaptationh","title":"File Adaptation.h","text":"<p>FileList &gt; src &gt; Adaptation.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Mesh.h\"</code></li> <li><code>#include \"AdaptCriteria.h\"</code></li> <li><code>#include \"Halo.h\"</code></li> <li><code>#include \"InitialConditions.h\"</code></li> <li><code>#include \"Testing.h\"</code></li> </ul>"},{"location":"BGFlood/_adaptation_8h/#public-functions","title":"Public Functions","text":"Type Name void Adapt (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; &amp; XModel) Applies adaptation (refinement/coarsening) to the mesh and updates variables. void Adaptation (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; &amp; XModel) Performs mesh adaptation (refinement/coarsening) for the model. void Adaptationcleanup (Param &amp; XParam, BlockP&lt; T &gt; &amp; XBlock, AdaptP &amp; XAdapt) Cleans up and updates block lists after adaptation. int AddBlocks (int nnewblk, Param &amp; XParam, Model&lt; T &gt; &amp; XModel) Adds new blocks to the mesh for adaptation. int CalcAvailblk (Param &amp; XParam, BlockP&lt; T &gt; XBlock, AdaptP &amp; XAdapt) Calculates the number of available blocks for refinement. void InitialAdaptation (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel) Performs initial mesh adaptation and reruns initial conditions. bool checkBUQsanity (Param XParam, BlockP&lt; T &gt; XBlock) Checks the consistency and sanity of the block uniform quadtree mesh. bool checklevel (int ib, int levelib, int neighbourib, int levelneighbour)  bool checkneighbourdistance (double dx, int ib, int levelib, T blocko, int neighbourib, int levelneighbour, T neighbourblocko, bool rightortop) Checks if the distance between a block and its neighbor is consistent with their levels. int checkneighbourrefine (int neighbourib, int levelib, int levelneighbour, bool *&amp; refine, bool *&amp; coarsen)  void coarsen (Param XParam, BlockP&lt; T &gt; &amp; XBlock, AdaptP &amp; XAdapt, EvolvingP&lt; T &gt; XEvo, EvolvingP&lt; T &gt; &amp; XEv) Coarsens mesh blocks and updates conserved variables. void refine (Param XParam, BlockP&lt; T &gt; &amp; XBlock, AdaptP &amp; XAdapt, EvolvingP&lt; T &gt; XEvo, EvolvingP&lt; T &gt; &amp; XEv) Refines mesh blocks and interpolates conserved variables. bool refinesanitycheck (Param XParam, BlockP&lt; T &gt; XBlock, bool *&amp; refine, bool *&amp; coarsen)"},{"location":"BGFlood/_adaptation_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_adaptation_8h/#function-adapt","title":"function Adapt","text":"<p>Applies adaptation (refinement/coarsening) to the mesh and updates variables. </p><pre><code>template&lt;class T&gt;\nvoid Adapt (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XModel</code> Model structure </li> </ul>"},{"location":"BGFlood/_adaptation_8h/#function-adaptation","title":"function Adaptation","text":"<p>Performs mesh adaptation (refinement/coarsening) for the model. </p><pre><code>template&lt;class T&gt;\nvoid Adaptation (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XModel</code> Model structure</li> </ul> <p>Iteratively refines or coarsens the mesh based on adaptation criteria, updating block info and variables. </p>"},{"location":"BGFlood/_adaptation_8h/#function-adaptationcleanup","title":"function Adaptationcleanup","text":"<p>Cleans up and updates block lists after adaptation. </p><pre><code>template&lt;class T&gt;\nvoid Adaptationcleanup (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XAdapt</code> Adaptation data structure</li> </ul> <p>Updates block levels, reorders active block list, and finalizes adaptation. </p>"},{"location":"BGFlood/_adaptation_8h/#function-addblocks","title":"function AddBlocks","text":"<p>Adds new blocks to the mesh for adaptation. </p><pre><code>template&lt;class T&gt;\nint AddBlocks (\n    int nnewblk,\n    Param &amp; XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nnewblk</code> Number of new blocks to add </li> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure </li> </ul> <p>Returns:</p> <p>New total number of blocks in memory. </p>"},{"location":"BGFlood/_adaptation_8h/#function-calcavailblk","title":"function CalcAvailblk","text":"<p>Calculates the number of available blocks for refinement. </p><pre><code>template&lt;class T&gt;\nint CalcAvailblk (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; XBlock,\n    AdaptP &amp; XAdapt\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XAdapt</code> Adaptation data structure </li> </ul> <p>Returns:</p> <p>Number of available blocks for refinement. </p>"},{"location":"BGFlood/_adaptation_8h/#function-initialadaptation","title":"function InitialAdaptation","text":"<p>Performs initial mesh adaptation and reruns initial conditions. </p><pre><code>template&lt;class T&gt;\nvoid InitialAdaptation (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XModel</code> Model structure </li> </ul>"},{"location":"BGFlood/_adaptation_8h/#function-checkbuqsanity","title":"function checkBUQsanity","text":"<p>Checks the consistency and sanity of the block uniform quadtree mesh. </p><pre><code>template&lt;class T&gt;\nbool checkBUQsanity (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> </ul> <p>Returns:</p> <p>True if mesh is sane, false otherwise. </p>"},{"location":"BGFlood/_adaptation_8h/#function-checklevel","title":"function checklevel","text":"<pre><code>bool checklevel (\n    int ib,\n    int levelib,\n    int neighbourib,\n    int levelneighbour\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8h/#function-checkneighbourdistance","title":"function checkneighbourdistance","text":"<p>Checks if the distance between a block and its neighbor is consistent with their levels. </p><pre><code>template&lt;class T&gt;\nbool checkneighbourdistance (\n    double dx,\n    int ib,\n    int levelib,\n    T blocko,\n    int neighbourib,\n    int levelneighbour,\n    T neighbourblocko,\n    bool rightortop\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>dx</code> Base grid spacing </li> <li><code>ib</code> Block index </li> <li><code>levelib</code> Block level </li> <li><code>blocko</code> Block coordinate </li> <li><code>neighbourib</code> Neighbor block index </li> <li><code>levelneighbour</code> Neighbor block level </li> <li><code>neighbourblocko</code> Neighbor block coordinate </li> <li><code>rightortop</code> True if neighbor is right/top, false if left/bottom </li> </ul> <p>Returns:</p> <p>True if distance is consistent, false otherwise. </p>"},{"location":"BGFlood/_adaptation_8h/#function-checkneighbourrefine","title":"function checkneighbourrefine","text":"<pre><code>int checkneighbourrefine (\n    int neighbourib,\n    int levelib,\n    int levelneighbour,\n    bool *&amp; refine,\n    bool *&amp; coarsen\n) \n</code></pre>"},{"location":"BGFlood/_adaptation_8h/#function-coarsen","title":"function coarsen","text":"<p>Coarsens mesh blocks and updates conserved variables. </p><pre><code>template&lt;class T&gt;\nvoid coarsen (\n    Param XParam,\n    BlockP &lt; T &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt,\n    EvolvingP &lt; T &gt; XEvo,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XAdapt</code> Adaptation data structure </li> <li><code>XEvo</code> Old evolving variables </li> <li><code>XEv</code> New evolving variables </li> </ul>"},{"location":"BGFlood/_adaptation_8h/#function-refine","title":"function refine","text":"<p>Refines mesh blocks and interpolates conserved variables. </p><pre><code>template&lt;class T&gt;\nvoid refine (\n    Param XParam,\n    BlockP &lt; T &gt; &amp; XBlock,\n    AdaptP &amp; XAdapt,\n    EvolvingP &lt; T &gt; XEvo,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XAdapt</code> Adaptation data structure </li> <li><code>XEvo</code> Old evolving variables </li> <li><code>XEv</code> New evolving variables </li> </ul>"},{"location":"BGFlood/_adaptation_8h/#function-refinesanitycheck","title":"function refinesanitycheck","text":"<pre><code>template&lt;class T&gt;\nbool refinesanitycheck (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    bool *&amp; refine,\n    bool *&amp; coarsen\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Adaptation.h</code></p>"},{"location":"BGFlood/_adaptation_8h_source/","title":"File Adaptation.h","text":""},{"location":"BGFlood/_adaptation_8h_source/#file-adaptationh","title":"File Adaptation.h","text":"<p>File List &gt; src &gt; Adaptation.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ADAPTATION_H\n#define ADAPTATION_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"Mesh.h\"\n#include \"AdaptCriteria.h\"\n#include \"Halo.h\"\n#include \"InitialConditions.h\"\n#include \"Testing.h\"\n\n\ntemplate &lt;class T&gt; void Adaptation(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel);\ntemplate &lt;class T&gt; void InitialAdaptation(Param&amp; XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;T&gt;&amp; XModel);\ntemplate &lt;class T&gt; bool refinesanitycheck(Param XParam, BlockP&lt;T&gt; XBlock, bool*&amp; refine, bool*&amp; coarsen);\nint checkneighbourrefine(int neighbourib, int levelib, int levelneighbour, bool*&amp; refine, bool*&amp; coarsen);\n\ntemplate &lt;class T&gt; bool checkBUQsanity(Param XParam, BlockP&lt;T&gt; XBlock);\nbool checklevel(int ib, int levelib, int neighbourib, int levelneighbour);\n\ntemplate &lt;class T&gt; void Adapt(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel);\n\ntemplate &lt;class T&gt; int CalcAvailblk(Param&amp; XParam, BlockP&lt;T&gt; XBlock, AdaptP&amp; XAdapt);\ntemplate &lt;class T&gt; int AddBlocks(int nnewblk, Param&amp; XParam, Model&lt;T&gt;&amp; XModel);\ntemplate &lt;class T&gt; void coarsen(Param XParam, BlockP&lt;T&gt;&amp; XBlock, AdaptP&amp; XAdapt, EvolvingP&lt;T&gt; XEvo, EvolvingP&lt;T&gt;&amp; XEv);\ntemplate &lt;class T&gt; void refine(Param XParam, BlockP&lt;T&gt;&amp; XBlock, AdaptP&amp; XAdapt, EvolvingP&lt;T&gt; XEvo, EvolvingP&lt;T&gt;&amp; XEv);\ntemplate &lt;class T&gt; void Adaptationcleanup(Param&amp; XParam, BlockP&lt;T&gt;&amp; XBlock, AdaptP&amp; XAdapt);\n\n\ntemplate &lt;class T&gt; bool checkneighbourdistance(double dx, int ib, int levelib, T blocko, int neighbourib, int levelneighbour, T neighbourblocko, bool rightortop );\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_advection_8cu/","title":"File Advection.cu","text":""},{"location":"BGFlood/_advection_8cu/#file-advectioncu","title":"File Advection.cu","text":"<p>FileList &gt; src &gt; Advection.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Advection.h\"</code></li> </ul>"},{"location":"BGFlood/_advection_8cu/#classes","title":"Classes","text":"Type Name struct SharedMemory &lt;class T&gt; struct SharedMemory&lt; double &gt; &lt;&gt;"},{"location":"BGFlood/_advection_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ void AdvkernelCPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * zb, EvolvingP&lt; T &gt; XEv, AdvanceP&lt; T &gt; XAdv, EvolvingP&lt; T &gt; XEv_o) CPU routine for advancing the solution in time for each block and cell. template __host__ void AdvkernelCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, double * zb, EvolvingP&lt; double &gt; XEv, AdvanceP&lt; double &gt; XAdv, EvolvingP&lt; double &gt; XEv_o)  template __host__ void AdvkernelCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, float * zb, EvolvingP&lt; float &gt; XEv, AdvanceP&lt; float &gt; XAdv, EvolvingP&lt; float &gt; XEv_o)  __global__ void AdvkernelGPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * zb, EvolvingP&lt; T &gt; XEv, AdvanceP&lt; T &gt; XAdv, EvolvingP&lt; T &gt; XEv_o) GPU kernel for advancing the solution in time for each block and cell. template __global__ void AdvkernelGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, double * zb, EvolvingP&lt; double &gt; XEv, AdvanceP&lt; double &gt; XAdv, EvolvingP&lt; double &gt; XEv_o)  template __global__ void AdvkernelGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, float * zb, EvolvingP&lt; float &gt; XEv, AdvanceP&lt; float &gt; XAdv, EvolvingP&lt; float &gt; XEv_o)  __host__ T CalctimestepCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, TimeP&lt; T &gt; XTime) CPU routine to calculate the next time step for the simulation. template __host__ double CalctimestepCPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, TimeP&lt; double &gt; XTime)  template __host__ float CalctimestepCPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, TimeP&lt; float &gt; XTime)  __host__ T CalctimestepGPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, TimeP&lt; T &gt; XTime) GPU routine to calculate the next time step for the simulation. template __host__ double CalctimestepGPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, TimeP&lt; double &gt; XTime)  template __host__ float CalctimestepGPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, TimeP&lt; float &gt; XTime)  __host__ void cleanupCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, EvolvingP&lt; T &gt; XEv_o) CPU routine to clean up evolving variables after advection step. template __host__ void cleanupCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, EvolvingP&lt; double &gt; XEv_o)  template __host__ void cleanupCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, EvolvingP&lt; float &gt; XEv_o)  __global__ void cleanupGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, EvolvingP&lt; T &gt; XEv_o) GPU kernel to clean up evolving variables after advection step. template __global__ void cleanupGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, EvolvingP&lt; double &gt; XEv_o)  template __global__ void cleanupGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, EvolvingP&lt; float &gt; XEv_o)  __global__ void densify (Param XParam, BlockP&lt; T &gt; XBlock, T * g_idata, T * g_odata) GPU kernel to copy and densify data from block memory to output array. __global__ void reducemin3 (T * g_idata, T * g_odata, unsigned int n) GPU kernel to compute the minimum value in an array using parallel reduction. __host__ T timestepreductionCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, TimeP&lt; T &gt; XTime) CPU routine to compute the minimum allowed time step across all blocks and cells. template __host__ float timestepreductionCPU (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, TimeP&lt; float &gt; XTime)  template __host__ double timestepreductionCPU (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, TimeP&lt; double &gt; XTime)  __host__ void updateEVCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, FluxP&lt; T &gt; XFlux, AdvanceP&lt; T &gt; XAdv) CPU routine to update evolving variables (h, u, v, zs) for each block and cell. template __host__ void updateEVCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, FluxP&lt; double &gt; XFlux, AdvanceP&lt; double &gt; XAdv)  template __host__ void updateEVCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, FluxP&lt; float &gt; XFlux, AdvanceP&lt; float &gt; XAdv)  __global__ void updateEVGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, FluxP&lt; T &gt; XFlux, AdvanceP&lt; T &gt; XAdv) GPU kernel to update evolving variables (h, u, v, zs) for each block and cell. template __global__ void updateEVGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, FluxP&lt; double &gt; XFlux, AdvanceP&lt; double &gt; XAdv)  template __global__ void updateEVGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, FluxP&lt; float &gt; XFlux, AdvanceP&lt; float &gt; XAdv)"},{"location":"BGFlood/_advection_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_advection_8cu/#function-advkernelcpu","title":"function AdvkernelCPU","text":"<p>CPU routine for advancing the solution in time for each block and cell. </p><pre><code>template&lt;class T&gt;\n__host__ void AdvkernelCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * zb,\n    EvolvingP &lt; T &gt; XEv,\n    AdvanceP &lt; T &gt; XAdv,\n    EvolvingP &lt; T &gt; XEv_o\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>dt</code> Time step </li> <li><code>zb</code> Bed elevation array </li> <li><code>XEv</code> Evolving variables </li> <li><code>XAdv</code> Advance variables </li> <li><code>XEv_o</code> Output evolving variables</li> </ul> <p>Updates water height, velocity, and surface elevation for the next time step. </p>"},{"location":"BGFlood/_advection_8cu/#function-advkernelcpu-double","title":"function AdvkernelCPU&lt; double &gt;","text":"<pre><code>template __host__ void AdvkernelCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    double * zb,\n    EvolvingP &lt; double &gt; XEv,\n    AdvanceP &lt; double &gt; XAdv,\n    EvolvingP &lt; double &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/_advection_8cu/#function-advkernelcpu-float","title":"function AdvkernelCPU&lt; float &gt;","text":"<pre><code>template __host__ void AdvkernelCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    float * zb,\n    EvolvingP &lt; float &gt; XEv,\n    AdvanceP &lt; float &gt; XAdv,\n    EvolvingP &lt; float &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/_advection_8cu/#function-advkernelgpu","title":"function AdvkernelGPU","text":"<p>GPU kernel for advancing the solution in time for each block and cell. </p><pre><code>template&lt;class T&gt;\n__global__ void AdvkernelGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * zb,\n    EvolvingP &lt; T &gt; XEv,\n    AdvanceP &lt; T &gt; XAdv,\n    EvolvingP &lt; T &gt; XEv_o\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>dt</code> Time step </li> <li><code>zb</code> Bed elevation array </li> <li><code>XEv</code> Evolving variables </li> <li><code>XAdv</code> Advance variables </li> <li><code>XEv_o</code> Output evolving variables</li> </ul> <p>Updates water height, velocity, and surface elevation for the next time step. </p>"},{"location":"BGFlood/_advection_8cu/#function-advkernelgpu-double","title":"function AdvkernelGPU&lt; double &gt;","text":"<pre><code>template __global__ void AdvkernelGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    double * zb,\n    EvolvingP &lt; double &gt; XEv,\n    AdvanceP &lt; double &gt; XAdv,\n    EvolvingP &lt; double &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/_advection_8cu/#function-advkernelgpu-float","title":"function AdvkernelGPU&lt; float &gt;","text":"<pre><code>template __global__ void AdvkernelGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    float * zb,\n    EvolvingP &lt; float &gt; XEv,\n    AdvanceP &lt; float &gt; XAdv,\n    EvolvingP &lt; float &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/_advection_8cu/#function-calctimestepcpu","title":"function CalctimestepCPU","text":"<p>CPU routine to calculate the next time step for the simulation. </p><pre><code>template&lt;class T&gt;\n__host__ T CalctimestepCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    TimeP &lt; T &gt; XTime\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XBlock</code> Block data structure </li> <li><code>XTime</code> Time control structure </li> </ul> <p>Returns:</p> <p>Computed time step </p>"},{"location":"BGFlood/_advection_8cu/#function-calctimestepcpu-double","title":"function CalctimestepCPU&lt; double &gt;","text":"<pre><code>template __host__ double CalctimestepCPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    TimeP &lt; double &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/_advection_8cu/#function-calctimestepcpu-float","title":"function CalctimestepCPU&lt; float &gt;","text":"<pre><code>template __host__ float CalctimestepCPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    TimeP &lt; float &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/_advection_8cu/#function-calctimestepgpu","title":"function CalctimestepGPU","text":"<p>GPU routine to calculate the next time step for the simulation. </p><pre><code>template&lt;class T&gt;\n__host__ T CalctimestepGPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    TimeP &lt; T &gt; XTime\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XBlock</code> Block data structure </li> <li><code>XTime</code> Time control structure </li> </ul> <p>Returns:</p> <p>Computed time step </p>"},{"location":"BGFlood/_advection_8cu/#function-calctimestepgpu-double","title":"function CalctimestepGPU&lt; double &gt;","text":"<pre><code>template __host__ double CalctimestepGPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    TimeP &lt; double &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/_advection_8cu/#function-calctimestepgpu-float","title":"function CalctimestepGPU&lt; float &gt;","text":"<pre><code>template __host__ float CalctimestepGPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    TimeP &lt; float &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/_advection_8cu/#function-cleanupcpu","title":"function cleanupCPU","text":"<p>CPU routine to clean up evolving variables after advection step. </p><pre><code>template&lt;class T&gt;\n__host__ void cleanupCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    EvolvingP &lt; T &gt; XEv_o\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables </li> <li><code>XEv_o</code> Output evolving variables </li> </ul>"},{"location":"BGFlood/_advection_8cu/#function-cleanupcpu-double","title":"function cleanupCPU&lt; double &gt;","text":"<pre><code>template __host__ void cleanupCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    EvolvingP &lt; double &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/_advection_8cu/#function-cleanupcpu-float","title":"function cleanupCPU&lt; float &gt;","text":"<pre><code>template __host__ void cleanupCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    EvolvingP &lt; float &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/_advection_8cu/#function-cleanupgpu","title":"function cleanupGPU","text":"<p>GPU kernel to clean up evolving variables after advection step. </p><pre><code>template&lt;class T&gt;\n__global__ void cleanupGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    EvolvingP &lt; T &gt; XEv_o\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables </li> <li><code>XEv_o</code> Output evolving variables </li> </ul>"},{"location":"BGFlood/_advection_8cu/#function-cleanupgpu-double","title":"function cleanupGPU&lt; double &gt;","text":"<pre><code>template __global__ void cleanupGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    EvolvingP &lt; double &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/_advection_8cu/#function-cleanupgpu-float","title":"function cleanupGPU&lt; float &gt;","text":"<pre><code>template __global__ void cleanupGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    EvolvingP &lt; float &gt; XEv_o\n) \n</code></pre>"},{"location":"BGFlood/_advection_8cu/#function-densify","title":"function densify","text":"<p>GPU kernel to copy and densify data from block memory to output array. </p><pre><code>template&lt;class T&gt;\n__global__ void densify (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * g_idata,\n    T * g_odata\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>g_idata</code> Input array </li> <li><code>g_odata</code> Output array </li> </ul>"},{"location":"BGFlood/_advection_8cu/#function-reducemin3","title":"function reducemin3","text":"<p>GPU kernel to compute the minimum value in an array using parallel reduction. </p><pre><code>template&lt;class T&gt;\n__global__ void reducemin3 (\n    T * g_idata,\n    T * g_odata,\n    unsigned int n\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>g_idata</code> Input array </li> <li><code>g_odata</code> Output array (min per block) </li> <li><code>n</code> Number of elements </li> </ul>"},{"location":"BGFlood/_advection_8cu/#function-timestepreductioncpu","title":"function timestepreductionCPU","text":"<p>CPU routine to compute the minimum allowed time step across all blocks and cells. </p><pre><code>template&lt;class T&gt;\n__host__ T timestepreductionCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    TimeP &lt; T &gt; XTime\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XBlock</code> Block data structure </li> <li><code>XTime</code> Time control structure </li> </ul> <p>Returns:</p> <p>Minimum allowed time step </p>"},{"location":"BGFlood/_advection_8cu/#function-timestepreductioncpu_1","title":"function timestepreductionCPU","text":"<pre><code>template __host__ float timestepreductionCPU (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    TimeP &lt; float &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/_advection_8cu/#function-timestepreductioncpu_2","title":"function timestepreductionCPU","text":"<pre><code>template __host__ double timestepreductionCPU (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    TimeP &lt; double &gt; XTime\n) \n</code></pre>"},{"location":"BGFlood/_advection_8cu/#function-updateevcpu","title":"function updateEVCPU","text":"<p>CPU routine to update evolving variables (h, u, v, zs) for each block and cell. </p><pre><code>template&lt;class T&gt;\n__host__ void updateEVCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    FluxP &lt; T &gt; XFlux,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables </li> <li><code>XFlux</code> Flux variables </li> <li><code>XAdv</code> Advance variables</li> </ul> <p>Computes new values for water height, velocity, and surface elevation using fluxes and advances. </p>"},{"location":"BGFlood/_advection_8cu/#function-updateevcpu-double","title":"function updateEVCPU&lt; double &gt;","text":"<pre><code>template __host__ void updateEVCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    FluxP &lt; double &gt; XFlux,\n    AdvanceP &lt; double &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/_advection_8cu/#function-updateevcpu-float","title":"function updateEVCPU&lt; float &gt;","text":"<pre><code>template __host__ void updateEVCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    FluxP &lt; float &gt; XFlux,\n    AdvanceP &lt; float &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/_advection_8cu/#function-updateevgpu","title":"function updateEVGPU","text":"<p>GPU kernel to update evolving variables (h, u, v, zs) for each block and cell. </p><pre><code>template&lt;class T&gt;\n__global__ void updateEVGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    FluxP &lt; T &gt; XFlux,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables </li> <li><code>XFlux</code> Flux variables </li> <li><code>XAdv</code> Advance variables</li> </ul> <p>Computes new values for water height, velocity, and surface elevation using fluxes and advances. </p>"},{"location":"BGFlood/_advection_8cu/#function-updateevgpu-double","title":"function updateEVGPU&lt; double &gt;","text":"<pre><code>template __global__ void updateEVGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    FluxP &lt; double &gt; XFlux,\n    AdvanceP &lt; double &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/_advection_8cu/#function-updateevgpu-float","title":"function updateEVGPU&lt; float &gt;","text":"<pre><code>template __global__ void updateEVGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    FluxP &lt; float &gt; XFlux,\n    AdvanceP &lt; float &gt; XAdv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Advection.cu</code></p>"},{"location":"BGFlood/_advection_8cu_source/","title":"File Advection.cu","text":""},{"location":"BGFlood/_advection_8cu_source/#file-advectioncu","title":"File Advection.cu","text":"<p>File List &gt; src &gt; Advection.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Advection.h\"\n\ntemplate&lt;class T&gt;\nstruct SharedMemory\n{\n    __device__ inline operator T* ()\n    {\n        extern __shared__ int __smem[];\n        return (T*)__smem;\n    }\n\n    __device__ inline operator const T* () const\n    {\n        extern __shared__ int __smem[];\n        return (T*)__smem;\n    }\n};\n\n// specialize for double to avoid unaligned memory\n// access compile errors\ntemplate&lt;&gt;\nstruct SharedMemory&lt;double&gt;\n{\n    __device__ inline operator double* ()\n    {\n        extern __shared__ double __smem_d[];\n        return (double*)__smem_d;\n    }\n\n    __device__ inline operator const double* () const\n    {\n        extern __shared__ double __smem_d[];\n        return (double*)__smem_d;\n    }\n};\n\n\ntemplate &lt;class T&gt;__global__ void updateEVGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, FluxP&lt;T&gt; XFlux, AdvanceP&lt;T&gt; XAdv)\n{\n\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n    //T eps = T(XParam.eps);\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n\n    T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n\n    T fc = 0.0;// XParam.spherical ? sin((ybo + calcres(T(XParam.dx), lev) * iy) * pi / 180.0) * pi / T(21600.0) : sin(T(XParam.lat * pi / 180.0)) * pi / T(21600.0); // 2*(2*pi/24/3600)\n    // fc should be pi / T(21600.0) * sin(phi)\n\n\n    int iright, itop;\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    iright = memloc(halowidth, blkmemwidth, ix + 1, iy, ib);\n    itop = memloc(halowidth, blkmemwidth, ix, iy + 1, ib);\n\n    T yup = T(iy) + T(1.0);\n    T ydwn = T(iy);\n\n    if (iy == XParam.blkwidth - 1)\n    {\n        if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n        {\n            yup = iy + 0.75;\n        }\n        //if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib])\n        //{\n        //  yup = iy + 1.000;\n        //}\n    }\n\n    if (iy == 0)\n    {\n        if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n        {\n            ydwn = iy - 0.25 ;\n        }\n\n    }\n\n\n\n\n\n    T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T fmu = T(1.0);\n    T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, ydwn) : T(1.0);\n    T fmup = T(1.0);\n    T fmvp = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, yup) : T(1.0);\n\n\n\n    T hi = XEv.h[i];\n    T uui = XEv.u[i];\n    T vvi = XEv.v[i];\n\n\n    T cmdinv, ga;\n\n    cmdinv = T(1.0) / (cm * delta);\n    ga = T(0.5) * g;\n\n\n    XAdv.dh[i] = T(-1.0) * (XFlux.Fhu[iright] - XFlux.Fhu[i] + XFlux.Fhv[itop] - XFlux.Fhv[i]) * cmdinv;\n\n\n\n    //double dmdl = (fmu[xplus + iy*nx] - fmu[i]) / (cm * delta);\n    //double dmdt = (fmv[ix + yplus*nx] - fmv[i]) / (cm  * delta);\n    T dmdl = (fmup - fmu) * cmdinv;// absurd if not spherical!\n    T dmdt = (fmvp - fmv) * cmdinv;;\n    T fG = vvi * dmdl - uui * dmdt;\n    XAdv.dhu[i] = (XFlux.Fqux[i] + XFlux.Fquy[i] - XFlux.Su[iright] - XFlux.Fquy[itop]) * cmdinv + fc * hi * vvi;\n    XAdv.dhv[i] = (XFlux.Fqvy[i] + XFlux.Fqvx[i] - XFlux.Sv[itop] - XFlux.Fqvx[iright]) * cmdinv - fc * hi * uui;\n\n    XAdv.dhu[i] += hi * (ga * hi * dmdl + fG * vvi);// This term is == 0 so should be commented here\n    XAdv.dhv[i] += hi * (ga * hi * dmdt - fG * uui);// Need double checking before doing that\n\n\n\n}\ntemplate __global__ void updateEVGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, FluxP&lt;float&gt; XFlux, AdvanceP&lt;float&gt; XAdv);\ntemplate __global__ void updateEVGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, FluxP&lt;double&gt; XFlux, AdvanceP&lt;double&gt; XAdv);\n\n\ntemplate &lt;class T&gt;__host__ void updateEVCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, FluxP&lt;T&gt; XFlux, AdvanceP&lt;T&gt; XAdv)\n{\n\n    //T eps = T(XParam.eps);\n    T delta;\n    T g = T(XParam.g);\n\n    T ybo;\n\n\n    int ib,lev;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        lev = XBlock.level[ib];\n        delta = calcres(T(XParam.delta), lev);\n\n        ybo = (T)XParam.yo + XBlock.yo[ib];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                T fc = XParam.spherical ? sin((ybo + calcres(T(XParam.dx), lev) * iy) * pi / 180.0) * pi / T(21600.0) : sin(T(XParam.lat * pi / 180.0)) * pi / T(21600.0); // 2*(2*pi/24/3600)\n\n                int iright, itop;\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                iright = memloc(halowidth, blkmemwidth, ix + 1, iy, ib);\n                itop = memloc(halowidth, blkmemwidth, ix, iy + 1, ib);\n\n\n                T yup = T(iy) + T(1.0);\n                T ydwn = T(iy);\n\n                if (iy == XParam.blkwidth - 1)\n                {\n                    if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n                    {\n                        yup = iy + T(0.75);\n                    }\n\n                }\n                if (iy == 0)\n                {\n                    if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n                    {\n                        ydwn = iy - T(0.25);\n                    }\n\n                }\n\n\n\n                T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n                T fmu = T(1.0);\n                T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, ydwn) : T(1.0);\n                T fmup = T(1.0);\n                T fmvp = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, yup) : T(1.0);\n\n                T hi = XEv.h[i];\n                T uui = XEv.u[i];\n                T vvi = XEv.v[i];\n\n\n                T cmdinv, ga;\n\n                cmdinv = T(1.0) / (cm * delta);\n                ga = T(0.5) * g;\n\n\n                XAdv.dh[i] = T(-1.0) * (XFlux.Fhu[iright] - XFlux.Fhu[i] + XFlux.Fhv[itop] - XFlux.Fhv[i]) * cmdinv;\n\n\n\n                //double dmdl = (fmu[xplus + iy*nx] - fmu[i]) / (cm * delta);\n                //double dmdt = (fmv[ix + yplus*nx] - fmv[i]) / (cm  * delta);\n                T dmdl = (fmup - fmu) / (cm * delta);// absurd if not spherical!\n                T dmdt = (fmvp - fmv) / (cm * delta);\n                T fG = vvi * dmdl - uui * dmdt;\n                XAdv.dhu[i] = (XFlux.Fqux[i] + XFlux.Fquy[i] - XFlux.Su[iright] - XFlux.Fquy[itop]) * cmdinv + fc * hi * vvi;\n                XAdv.dhv[i] = (XFlux.Fqvy[i] + XFlux.Fqvx[i] - XFlux.Sv[itop] - XFlux.Fqvx[iright]) * cmdinv - fc * hi * uui;\n\n\n                XAdv.dhu[i] += hi * (ga * hi * dmdl + fG * vvi);// This term is == 0 so should be commented here\n                XAdv.dhv[i] += hi * (ga * hi * dmdt - fG * uui);// Need double checking before doing that\n            }\n        }\n    }\n}\ntemplate __host__ void updateEVCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, FluxP&lt;float&gt; XFlux, AdvanceP&lt;float&gt; XAdv);\ntemplate __host__ void updateEVCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, FluxP&lt;double&gt; XFlux, AdvanceP&lt;double&gt; XAdv);\n\n\ntemplate &lt;class T&gt; __global__ void AdvkernelGPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt ,T* zb, EvolvingP&lt;T&gt; XEv, AdvanceP&lt;T&gt; XAdv, EvolvingP&lt;T&gt; XEv_o)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    T eps = T(XParam.eps);\n    T hold = XEv.h[i];\n    T ho, uo, vo;\n    T dhi = XAdv.dh[i];\n\n    T edt = XParam.ForceMassConserve ? dt : dhi &gt;= T(0.0) ? dt : min(dt, max(hold, XParam.eps) / abs(dhi));\n\n    //ho = max(hold + edt * dhi,T(0.0));\n    ho = hold + edt * dhi;\n\n    if (ho &gt; eps) {\n        //\n        uo = (hold * XEv.u[i] + edt * XAdv.dhu[i]) / ho;\n        vo = (hold * XEv.v[i] + edt * XAdv.dhv[i]) / ho;\n\n    }\n    else\n    {// dry\n\n        uo = T(0.0);\n        vo = T(0.0);\n    }\n\n\n    XEv_o.zs[i] = zb[i] + ho;\n    XEv_o.h[i] = ho;\n    XEv_o.u[i] = uo;\n    XEv_o.v[i] = vo;\n\n\n}\ntemplate __global__ void AdvkernelGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float dt, float* zb, EvolvingP&lt;float&gt; XEv, AdvanceP&lt;float&gt; XAdv, EvolvingP&lt;float&gt; XEv_o);\ntemplate __global__ void AdvkernelGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double dt, double* zb, EvolvingP&lt;double&gt; XEv, AdvanceP&lt;double&gt; XAdv, EvolvingP&lt;double&gt; XEv_o);\n\n\ntemplate &lt;class T&gt; __host__ void AdvkernelCPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt, T* zb, EvolvingP&lt;T&gt; XEv, AdvanceP&lt;T&gt; XAdv, EvolvingP&lt;T&gt; XEv_o)\n{\n    T eps = T(XParam.eps);\n\n\n\n    int ib;\n    //int halowidth = XParam.halowidth;\n    //int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(XParam, ix, iy, ib);\n\n\n                T hold = XEv.h[i];\n                T ho, uo, vo, dhi;\n\n                dhi = XAdv.dh[i];\n\n                T edt = XParam.ForceMassConserve ? dt : dhi &gt;= T(0.0) ? dt : min(dt, max(hold, XParam.eps) / abs(dhi));\n\n                ho = hold + edt * dhi;\n\n\n                if (ho &gt; eps) {\n                    //\n                    uo = (hold * XEv.u[i] + edt * XAdv.dhu[i]) / ho;\n                    vo = (hold * XEv.v[i] + edt * XAdv.dhv[i]) / ho;\n\n                }\n                else\n                {// dry\n\n                    uo = T(0.0);\n                    vo = T(0.0);\n                }\n\n\n                XEv_o.zs[i] = zb[i] + ho;\n                XEv_o.h[i] = ho;\n                XEv_o.u[i] = uo;\n                XEv_o.v[i] = vo;\n            }\n        }\n    }\n\n}\ntemplate __host__ void AdvkernelCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float dt, float* zb, EvolvingP&lt;float&gt; XEv, AdvanceP&lt;float&gt; XAdv, EvolvingP&lt;float&gt; XEv_o);\ntemplate __host__ void AdvkernelCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double dt, double* zb, EvolvingP&lt;double&gt; XEv, AdvanceP&lt;double&gt; XAdv, EvolvingP&lt;double&gt; XEv_o);\n\n\n\ntemplate &lt;class T&gt; __global__ void cleanupGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, EvolvingP&lt;T&gt; XEv_o)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n\n    XEv_o.h[i] = XEv.h[i];\n    XEv_o.zs[i] = XEv.zs[i];\n    XEv_o.u[i] = XEv.u[i];\n    XEv_o.v[i] = XEv.v[i];\n\n}\ntemplate __global__ void cleanupGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, EvolvingP&lt;float&gt; XEv_o);\ntemplate __global__ void cleanupGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, EvolvingP&lt;double&gt; XEv_o);\n\n\n\ntemplate &lt;class T&gt; __host__ void cleanupCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, EvolvingP&lt;T&gt; XEv_o)\n{\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                XEv_o.h[i] = XEv.h[i];\n                XEv_o.zs[i] = XEv.zs[i];\n                XEv_o.u[i] = XEv.u[i];\n                XEv_o.v[i] = XEv.v[i];\n            }\n        }\n    }\n\n}\ntemplate __host__ void cleanupCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, EvolvingP&lt;float&gt; XEv_o);\ntemplate __host__ void cleanupCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, EvolvingP&lt;double&gt; XEv_o);\n\n\ntemplate &lt;class T&gt; __host__ T timestepreductionCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, TimeP&lt;T&gt; XTime)\n{\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n\n    T dt = T(1.0) / epsi;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                dt = utils::min(dt, XTime.dtmax[i]);\n\n            }\n        }\n    }\n\n    return dt;\n}\ntemplate __host__ float timestepreductionCPU(Param XParam, Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, TimeP&lt;float&gt; XTime);\ntemplate __host__ double timestepreductionCPU(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, TimeP&lt;double&gt; XTime);\n\ntemplate &lt;class T&gt; __host__ T CalctimestepCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, TimeP&lt;T&gt; XTime)\n{\n\n\n    T dt= timestepreductionCPU(XParam,XLoop,XBlock,XTime);\n\n\n\n    // also don't allow dt to be larger than 1.5*dtmax (usually the last time step or smallest delta/sqrt(gh) if the first step)\n    if (dt &gt; (1.5 * XLoop.dtmax))\n    {\n        dt = T(1.5 * XLoop.dtmax);\n    }\n\n    if (ceil((XLoop.nextoutputtime - XLoop.totaltime) / dt) &gt; 0.0)\n    {\n        dt = T((XLoop.nextoutputtime - XLoop.totaltime) / ceil((XLoop.nextoutputtime - XLoop.totaltime) / dt));\n    }\n\n\n\n    return dt;\n\n\n}\ntemplate __host__ float CalctimestepCPU&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, TimeP&lt;float&gt; XTime);\ntemplate __host__ double CalctimestepCPU&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, TimeP&lt;double&gt; XTime);\n\n\ntemplate &lt;class T&gt; __host__ T CalctimestepGPU(Param XParam,Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, TimeP&lt;T&gt; XTime)\n{\n    T* dummy;\n    AllocateCPU(32, 1, dummy);\n\n    // densify dtmax (i.e. remove empty block and halo that may sit in the middle of the memory structure)\n    int s = XParam.nblk * (XParam.blkwidth* XParam.blkwidth); // Not blksize wich includes Halo\n\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    densify &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt;(XParam, XBlock, XTime.dtmax, XTime.arrmin);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    CUDA_CHECK(cudaMemcpy(XTime.dtmax, XTime.arrmin, s * sizeof(T), cudaMemcpyDeviceToDevice));\n\n\n    //GPU Harris reduction #3. 8.3x reduction #0  Note #7 if a lot faster\n    // This was successfully tested with a range of grid size\n    //reducemax3 &lt;&lt;&lt;gridDimLine, blockDimLine, 64*sizeof(float) &gt;&gt;&gt;(dtmax_g, arrmax_g, nx*ny)\n\n    int maxThreads = 256;\n    int threads = (s &lt; maxThreads * 2) ? nextPow2((s + 1) / 2) : maxThreads;\n    int blocks = (s + (threads * 2 - 1)) / (threads * 2);\n    int smemSize = (threads &lt;= 32) ? 2 * threads * sizeof(T) : threads * sizeof(T);\n    dim3 blockDimLine(threads, 1, 1);\n    dim3 gridDimLine(blocks, 1, 1);\n\n\n    reducemin3 &lt;&lt;&lt;gridDimLine, blockDimLine, smemSize &gt;&gt;&gt; (XTime.dtmax, XTime.arrmin, s);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n\n    s = gridDimLine.x;\n    while (s &gt; 1)//cpuFinalThreshold\n    {\n        threads = (s &lt; maxThreads * 2) ? nextPow2((s + 1) / 2) : maxThreads;\n        blocks = (s + (threads * 2 - 1)) / (threads * 2);\n\n        smemSize = (threads &lt;= 32) ? 2 * threads * sizeof(T) : threads * sizeof(T);\n\n        dim3 blockDimLineS(threads, 1, 1);\n        dim3 gridDimLineS(blocks, 1, 1);\n\n        CUDA_CHECK(cudaMemcpy(XTime.dtmax, XTime.arrmin, s * sizeof(T), cudaMemcpyDeviceToDevice));\n\n        reducemin3 &lt;&lt;&lt;gridDimLineS, blockDimLineS, smemSize &gt;&gt;&gt; (XTime.dtmax, XTime.arrmin, s);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        s = (s + (threads * 2 - 1)) / (threads * 2);\n    }\n\n\n    CUDA_CHECK(cudaMemcpy(dummy, XTime.arrmin, 32 * sizeof(T), cudaMemcpyDeviceToHost)); // replace 32 by word here?\n\n    if (dummy[0] &gt; (1.5 * XLoop.dtmax))\n    {\n        dummy[0] = T(1.5 * XLoop.dtmax);\n    }\n\n    if (ceil((XLoop.nextoutputtime - XLoop.totaltime) / dummy[0]) &gt; 0.0)\n    {\n        dummy[0] = T((XLoop.nextoutputtime - XLoop.totaltime) / ceil((XLoop.nextoutputtime - XLoop.totaltime) / dummy[0]));\n    }\n\n\n    return dummy[0];\n\n    free(dummy);\n}\ntemplate __host__ float CalctimestepGPU&lt;float&gt;(Param XParam,Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, TimeP&lt;float&gt; XTime);\ntemplate __host__ double CalctimestepGPU&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, TimeP&lt;double&gt; XTime);\n\n\n\n\ntemplate &lt;class T&gt; __global__ void reducemin3(T* g_idata, T* g_odata, unsigned int n)\n{\n    //T *sdata = SharedMemory&lt;T&gt;();\n    T* sdata = SharedMemory&lt;T&gt;();\n    // perform first level of reduction,\n    // reading from global memory, writing to shared memory\n    unsigned int tid = threadIdx.x;\n    unsigned int i = blockIdx.x * (blockDim.x * 2) + threadIdx.x;\n\n    T myMin = (i &lt; n) ? g_idata[i] : T(1e30);\n\n    if (i + blockDim.x &lt; n)\n        myMin = min(myMin, g_idata[i + blockDim.x]);\n\n    sdata[tid] = myMin;\n    __syncthreads();\n\n\n    // do reduction in shared mem\n    for (unsigned int s = blockDim.x / 2; s &gt; 0; s &gt;&gt;= 1)\n    {\n        if (tid &lt; s)\n        {\n            sdata[tid] = myMin = min(myMin, sdata[tid + s]);\n        }\n\n        __syncthreads();\n    }\n\n    // write result for this block to global mem\n    if (tid == 0) g_odata[blockIdx.x] = myMin;\n}\n\n\ntemplate &lt;class T&gt; __global__ void densify(Param XParam, BlockP&lt;T&gt; XBlock, T* g_idata, T* g_odata)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int o = ix + iy * blockDim.x + ibl * (blockDim.x * blockDim.x);\n\n    g_odata[o] = g_idata[i];\n}\n</code></pre>"},{"location":"BGFlood/_advection_8h/","title":"File Advection.h","text":""},{"location":"BGFlood/_advection_8h/#file-advectionh","title":"File Advection.h","text":"<p>FileList &gt; src &gt; Advection.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Spherical.h\"</code></li> </ul>"},{"location":"BGFlood/_advection_8h/#public-functions","title":"Public Functions","text":"Type Name __host__ void AdvkernelCPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * zb, EvolvingP&lt; T &gt; XEv, AdvanceP&lt; T &gt; XAdv, EvolvingP&lt; T &gt; XEv_o) CPU routine for advancing the solution in time for each block and cell. __global__ void AdvkernelGPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * zb, EvolvingP&lt; T &gt; XEv, AdvanceP&lt; T &gt; XAdv, EvolvingP&lt; T &gt; XEv_o) GPU kernel for advancing the solution in time for each block and cell. __host__ T CalctimestepCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, TimeP&lt; T &gt; XTime) CPU routine to calculate the next time step for the simulation. __host__ T CalctimestepGPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, TimeP&lt; T &gt; XTime) GPU routine to calculate the next time step for the simulation. __host__ void cleanupCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, EvolvingP&lt; T &gt; XEv_o) CPU routine to clean up evolving variables after advection step. __global__ void cleanupGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, EvolvingP&lt; T &gt; XEv_o) GPU kernel to clean up evolving variables after advection step. __global__ void densify (Param XParam, BlockP&lt; T &gt; XBlock, T * g_idata, T * g_odata) GPU kernel to copy and densify data from block memory to output array. __global__ void reducemin3 (T * g_idata, T * g_odata, unsigned int n) GPU kernel to compute the minimum value in an array using parallel reduction. __host__ T timestepreductionCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, TimeP&lt; T &gt; XTime) CPU routine to compute the minimum allowed time step across all blocks and cells. __host__ void updateEVCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, FluxP&lt; T &gt; XFlux, AdvanceP&lt; T &gt; XAdv) CPU routine to update evolving variables (h, u, v, zs) for each block and cell. __global__ void updateEVGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, FluxP&lt; T &gt; XFlux, AdvanceP&lt; T &gt; XAdv) GPU kernel to update evolving variables (h, u, v, zs) for each block and cell."},{"location":"BGFlood/_advection_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_advection_8h/#function-advkernelcpu","title":"function AdvkernelCPU","text":"<p>CPU routine for advancing the solution in time for each block and cell. </p><pre><code>template&lt;class T&gt;\n__host__ void AdvkernelCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * zb,\n    EvolvingP &lt; T &gt; XEv,\n    AdvanceP &lt; T &gt; XAdv,\n    EvolvingP &lt; T &gt; XEv_o\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>dt</code> Time step </li> <li><code>zb</code> Bed elevation array </li> <li><code>XEv</code> Evolving variables </li> <li><code>XAdv</code> Advance variables </li> <li><code>XEv_o</code> Output evolving variables</li> </ul> <p>Updates water height, velocity, and surface elevation for the next time step. </p>"},{"location":"BGFlood/_advection_8h/#function-advkernelgpu","title":"function AdvkernelGPU","text":"<p>GPU kernel for advancing the solution in time for each block and cell. </p><pre><code>template&lt;class T&gt;\n__global__ void AdvkernelGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * zb,\n    EvolvingP &lt; T &gt; XEv,\n    AdvanceP &lt; T &gt; XAdv,\n    EvolvingP &lt; T &gt; XEv_o\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>dt</code> Time step </li> <li><code>zb</code> Bed elevation array </li> <li><code>XEv</code> Evolving variables </li> <li><code>XAdv</code> Advance variables </li> <li><code>XEv_o</code> Output evolving variables</li> </ul> <p>Updates water height, velocity, and surface elevation for the next time step. </p>"},{"location":"BGFlood/_advection_8h/#function-calctimestepcpu","title":"function CalctimestepCPU","text":"<p>CPU routine to calculate the next time step for the simulation. </p><pre><code>template&lt;class T&gt;\n__host__ T CalctimestepCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    TimeP &lt; T &gt; XTime\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XBlock</code> Block data structure </li> <li><code>XTime</code> Time control structure </li> </ul> <p>Returns:</p> <p>Computed time step </p>"},{"location":"BGFlood/_advection_8h/#function-calctimestepgpu","title":"function CalctimestepGPU","text":"<p>GPU routine to calculate the next time step for the simulation. </p><pre><code>template&lt;class T&gt;\n__host__ T CalctimestepGPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    TimeP &lt; T &gt; XTime\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XBlock</code> Block data structure </li> <li><code>XTime</code> Time control structure </li> </ul> <p>Returns:</p> <p>Computed time step </p>"},{"location":"BGFlood/_advection_8h/#function-cleanupcpu","title":"function cleanupCPU","text":"<p>CPU routine to clean up evolving variables after advection step. </p><pre><code>template&lt;class T&gt;\n__host__ void cleanupCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    EvolvingP &lt; T &gt; XEv_o\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables </li> <li><code>XEv_o</code> Output evolving variables </li> </ul>"},{"location":"BGFlood/_advection_8h/#function-cleanupgpu","title":"function cleanupGPU","text":"<p>GPU kernel to clean up evolving variables after advection step. </p><pre><code>template&lt;class T&gt;\n__global__ void cleanupGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    EvolvingP &lt; T &gt; XEv_o\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables </li> <li><code>XEv_o</code> Output evolving variables </li> </ul>"},{"location":"BGFlood/_advection_8h/#function-densify","title":"function densify","text":"<p>GPU kernel to copy and densify data from block memory to output array. </p><pre><code>template&lt;class T&gt;\n__global__ void densify (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * g_idata,\n    T * g_odata\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>g_idata</code> Input array </li> <li><code>g_odata</code> Output array </li> </ul>"},{"location":"BGFlood/_advection_8h/#function-reducemin3","title":"function reducemin3","text":"<p>GPU kernel to compute the minimum value in an array using parallel reduction. </p><pre><code>template&lt;class T&gt;\n__global__ void reducemin3 (\n    T * g_idata,\n    T * g_odata,\n    unsigned int n\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>g_idata</code> Input array </li> <li><code>g_odata</code> Output array (min per block) </li> <li><code>n</code> Number of elements </li> </ul>"},{"location":"BGFlood/_advection_8h/#function-timestepreductioncpu","title":"function timestepreductionCPU","text":"<p>CPU routine to compute the minimum allowed time step across all blocks and cells. </p><pre><code>template&lt;class T&gt;\n__host__ T timestepreductionCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    TimeP &lt; T &gt; XTime\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XBlock</code> Block data structure </li> <li><code>XTime</code> Time control structure </li> </ul> <p>Returns:</p> <p>Minimum allowed time step </p>"},{"location":"BGFlood/_advection_8h/#function-updateevcpu","title":"function updateEVCPU","text":"<p>CPU routine to update evolving variables (h, u, v, zs) for each block and cell. </p><pre><code>template&lt;class T&gt;\n__host__ void updateEVCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    FluxP &lt; T &gt; XFlux,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables </li> <li><code>XFlux</code> Flux variables </li> <li><code>XAdv</code> Advance variables</li> </ul> <p>Computes new values for water height, velocity, and surface elevation using fluxes and advances. </p>"},{"location":"BGFlood/_advection_8h/#function-updateevgpu","title":"function updateEVGPU","text":"<p>GPU kernel to update evolving variables (h, u, v, zs) for each block and cell. </p><pre><code>template&lt;class T&gt;\n__global__ void updateEVGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    FluxP &lt; T &gt; XFlux,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables </li> <li><code>XFlux</code> Flux variables </li> <li><code>XAdv</code> Advance variables</li> </ul> <p>Computes new values for water height, velocity, and surface elevation using fluxes and advances. </p> <p>The documentation for this class was generated from the following file <code>src/Advection.h</code></p>"},{"location":"BGFlood/_advection_8h_source/","title":"File Advection.h","text":""},{"location":"BGFlood/_advection_8h_source/#file-advectionh","title":"File Advection.h","text":"<p>File List &gt; src &gt; Advection.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ADVECTION_H\n#define ADVECTION_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"Spherical.h\"\n\ntemplate &lt;class T&gt; __global__ void updateEVGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, FluxP&lt;T&gt; XFlux, AdvanceP&lt;T&gt; XAdv);\ntemplate &lt;class T&gt; __host__ void updateEVCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, FluxP&lt;T&gt; XFlux, AdvanceP&lt;T&gt; XAdv);\n\ntemplate &lt;class T&gt; __global__ void AdvkernelGPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt, T* zb, EvolvingP&lt;T&gt; XEv, AdvanceP&lt;T&gt; XAdv, EvolvingP&lt;T&gt; XEv_o);\ntemplate &lt;class T&gt; __host__ void AdvkernelCPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt, T* zb, EvolvingP&lt;T&gt; XEv, AdvanceP&lt;T&gt; XAdv, EvolvingP&lt;T&gt; XEv_o);\n\ntemplate &lt;class T&gt; __global__ void cleanupGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, EvolvingP&lt;T&gt; XEv_o);\ntemplate &lt;class T&gt; __host__ void cleanupCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, EvolvingP&lt;T&gt; XEv_o);\n\ntemplate &lt;class T&gt; __host__ T CalctimestepCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, TimeP&lt;T&gt; XTime);\ntemplate &lt;class T&gt; __host__ T CalctimestepGPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, TimeP&lt;T&gt; XTime);\n\ntemplate &lt;class T&gt; __host__ T timestepreductionCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, TimeP&lt;T&gt; XTime);\n\ntemplate &lt;class T&gt; __global__ void reducemin3(T* g_idata, T* g_odata, unsigned int n);\n\ntemplate &lt;class T&gt; __global__ void densify(Param XParam, BlockP&lt;T&gt; XBlock, T* g_idata, T* g_odata);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_arrays_8h/","title":"File Arrays.h","text":""},{"location":"BGFlood/_arrays_8h/#file-arraysh","title":"File Arrays.h","text":"<p>FileList &gt; src &gt; Arrays.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Input.h\"</code></li> </ul>"},{"location":"BGFlood/_arrays_8h/#classes","title":"Classes","text":"Type Name struct AdaptP struct AdvanceP &lt;class T&gt;Structure holding advance variables for time stepping. struct BlockP &lt;class T&gt; struct BndblockP &lt;class T&gt; struct EvolvingMLP &lt;class T&gt;Structure holding evolving variables (no z relative variables). struct EvolvingP &lt;class T&gt;Structure holding evolving physical variables. struct EvolvingP_M &lt;class T&gt;Structure for mean/max evolving variables, inherits from EvolvingP . struct FluxMLP &lt;class T&gt;Structure holding flux variables (no z relative variables). struct FluxP &lt;class T&gt;Structure holding flux variables for advection. struct GradientsMLP &lt;class T&gt;Structure holding gradient arrays (no z relative variables). struct GradientsP &lt;class T&gt;Structure holding gradient arrays for physical variables. struct Loop &lt;class T&gt; struct Model &lt;class T&gt; struct RiverBlk struct RiverInfo &lt;class T&gt; struct TimeP &lt;class T&gt; struct maskinfo struct outP struct outzoneB <p>The documentation for this class was generated from the following file <code>src/Arrays.h</code></p>"},{"location":"BGFlood/_arrays_8h_source/","title":"File Arrays.h","text":""},{"location":"BGFlood/_arrays_8h_source/#file-arraysh","title":"File Arrays.h","text":"<p>File List &gt; src &gt; Arrays.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ARRAYS_H\n#define ARRAYS_H\n\n#include \"General.h\"\n#include \"Input.h\"\n\n\ntemplate &lt;class T&gt;\nstruct GradientsP\n{\n    T* dzsdx;\n    T* dhdx;\n    T* dudx;\n    T* dvdx;\n\n    T* dzsdy;\n    T* dhdy;\n    T* dudy;\n    T* dvdy;\n\n    T* dzbdx;\n    T* dzbdy;\n};\n\ntemplate &lt;class T&gt;\nstruct GradientsMLP\n{\n    T* dhdx;\n    T* dudx;\n    T* dvdx;\n    T* dhdy;\n    T* dudy;\n    T* dvdy;\n};\n\n\ntemplate &lt;class T&gt;\nstruct EvolvingP\n{\n    T* zs;\n    T* h;\n    T* u;\n    T* v;\n};\n\ntemplate &lt;class T&gt;\nstruct EvolvingMLP\n{\n    T* h;\n    T* u;\n    T* v;\n};\n\n//subclass inheriting from EvolvingP for Mean/Max\ntemplate &lt;class T&gt;\nstruct EvolvingP_M : public EvolvingP&lt;T&gt;\n{\n    T* U;\n    T* hU;\n};\n\ntemplate &lt;class T&gt;\nstruct FluxP\n{\n    T* Su;\n    T* Sv;\n    T* Fqux;\n    T* Fquy;\n    T* Fqvx;\n    T* Fqvy;\n    T* Fhu;\n    T* Fhv;\n};\n\ntemplate &lt;class T&gt;\nstruct FluxMLP\n{\n    T* hu;\n    T* hv;\n    T* hfu;\n    T* hfv;\n    T* hau;\n    T* hav;\n    T* Fux;\n    T* Fvy;\n    T* Fuy;\n    T* Fvx;\n};\n\ntemplate &lt;class T&gt;\nstruct AdvanceP\n{\n    T* dh;\n    T* dhu;\n    T* dhv;\n};\n\n\nstruct outP\n{\n    float* z;\n    short* z_s;\n    int level;\n    double xmin, xmax, ymin, ymax;\n};\n\n\nstruct maskinfo \n{\n\n    int nblk = 0; //number of blocks where this bnd applies\n\n    int* blks; // array of block where bnd applies \n    // 8 digit binary where 1 is a mask and 0 is not a mask with the first digit represent the left bottom side the rest is clockwise (i.e.left-bot left-top, top-left, top-right, right-top, right-bot, bot-right, bot-left)\n    int* side; // e.g. 11000000 for the entire left side being a mask\n\n    int type = 0;\n};\n\ntemplate &lt;class T&gt;\nstruct RiverInfo\n{\n    int nbir;\n    int nburmax; // size of (max number of) unique block with rivers  \n    int nribmax; // size of (max number of) rivers in one block\n    int* Xbidir; // array of block id for each river size(nburmax,nribmax)\n    int* Xridib; // array of river id in each block size(nburmax,nribmax)\n    T* xstart;\n    T* xend;\n    T* ystart;\n    T *yend;\n    T* qnow; // qnow is a pin mapped and so both pointers are needed here\n    T* qnow_g; // this simplify the code later\n\n};\n\n\n// outzone info used to actually write the nc files (one nc file by zone, the default zone is the full domain)\nstruct outzoneB \n{\n    int nblk; //number of blocks concerned\n    int* blk; // one zone will spread across multiple blocks (entire blocks containing a part of the area will be output)\n    double xo, xmax, yo, ymax; // Real zone for output (because we output full blocks)(corner of cells, as Xparam.xo)\n    std::string outname; // name for the output file (one for each zone)\n    int maxlevel; // maximum level in the zone\n    int minlevel; //minimum level in the zone\n    std::vector&lt;double&gt; OutputT; //Next time for the output of this zone\n    int index_next_OutputT = 0; //Index of next time output\n};\n\n\ntemplate &lt;class T&gt;\nstruct BlockP\n{\n    T* xo, *yo;\n    int* BotLeft, *BotRight;\n    int* TopLeft, *TopRight;\n    int* LeftBot, *LeftTop;\n    int* RightBot, *RightTop;\n\n    int* level;\n    int* active; // active blocks\n    int* activeCell; //To apply forcings (rain) only on these\n\n    maskinfo mask;\n\n    std::vector&lt;outzoneB&gt; outZone;\n};\n\n\nstruct AdaptP\n{\n    int *newlevel;\n    int *availblk, * csumblk;\n    int *invactive;\n    bool * coarsen, *refine;\n\n};\n\n\n\ntemplate &lt;class T&gt;\nstruct BndblockP\n{\n    int nblkriver, nblkTs, nbndblkleft, nbndblkright, nbndblktop, nbndblkbot;\n    int* river;\n    int* Tsout;\n    //int * DrainSink;\n    //int * DrainSource;\n    //int * Bridges;\n\n    int* left;\n    int* right;\n    int* top;\n    int* bot;\n\n    RiverInfo&lt;T&gt; Riverinfo;\n\n\n};\n\nstruct RiverBlk\n{\n    std::vector&lt;int&gt; block;\n};\n\n\n\n\n\ntemplate &lt;class T&gt;\nstruct TimeP\n{\n    T totaltime;\n    T dt;\n    T* dtmax;\n    T* arrmax, *arrmin;\n};\n\ntemplate &lt;class T&gt;\nstruct Model\n{\n    EvolvingP&lt;T&gt; evolv;\n    EvolvingP&lt;T&gt; evolv_o;\n\n    GradientsP&lt;T&gt; grad;\n    FluxP&lt;T&gt; flux;\n    FluxMLP&lt;T&gt; fluxml;\n    AdvanceP&lt;T&gt; adv;\n\n    //external forcing\n    T* zb;\n    T* cf;\n    T* il;\n    T* cl;\n\n    //GroundWater elevation (due to the accumulation of water by infiltration during the simulation)\n    T* hgw;\n\n    // Used for external forcing too\n    // May need a better placeholder\n    T* Patm, *datmpdx, *datmpdy;\n\n    TimeP&lt;T&gt; time;\n\n\n\n    // \n    std::map&lt;std::string, T *&gt; OutputVarMap;\n    std::map&lt;std::string, std::string&gt; Outvarlongname;\n    std::map&lt;std::string, std::string&gt; Outvarstdname;\n    std::map&lt;std::string, std::string&gt; Outvarunits;\n    std::vector&lt;double&gt; OutputT;\n\n    //other output\n    //std::vector&lt; std::vector&lt; Pointout &gt; &gt; TSallout;\n    T* TSstore;//buffer for TS data so not to save to disk too often\n    //T* vort;\n    //T* U;\n    EvolvingP_M&lt;T&gt; evmean;\n    EvolvingP_M&lt;T&gt; evmax;\n    T* wettime; //Inundation duration (h &gt; 0.1)\n\n    //Block information\n    BlockP&lt;T&gt; blocks;\n\n    AdaptP adapt;\n\n    BndblockP&lt;T&gt; bndblk;\n\n\n\n\n};\n\n\n// structure of useful variable for runing the main loop\ntemplate &lt;class T&gt;\nstruct Loop\n{\n    double nextoutputtime;\n    double dt;\n    double dtmax;\n    double totaltime;\n\n\n    // Needed to average mean varable for output\n    int nstep = 0;\n    //useful for calculating avg timestep\n    int nstepout = 0;\n    // Needed to identify next output time\n    int indNextoutputtime = 0;\n\n    // usefull for Time series output\n    int nTSsteps = 0;\n    std::vector&lt; std::vector&lt; Pointout &gt; &gt; TSAllout;\n\n    int windstep = 1;\n    int atmpstep = 1;\n    int rainstep = 1;\n\n    bool winduniform;\n    bool rainuniform;\n    bool atmpuniform;\n\n    T uwinduni = T(0.0);\n    T vwinduni = T(0.0);\n    T atmpuni;\n    T rainuni = T(0.0);\n\n    // CUDA specific stuff\n\n    dim3 blockDim;// (16, 16, 1);\n    dim3 gridDim;\n\n    const int num_streams = 4;\n\n    cudaStream_t streams[4];\n\n    T epsilon;\n    T hugeposval;\n    T hugenegval;\n\n};\n\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_b_g___flood_8cu/","title":"File BG_Flood.cu","text":""},{"location":"BGFlood/_b_g___flood_8cu/#file-bg_floodcu","title":"File BG_Flood.cu","text":"<p>FileList &gt; src &gt; BG_Flood.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"BG_Flood.h\"</code></li> </ul>"},{"location":"BGFlood/_b_g___flood_8cu/#public-functions","title":"Public Functions","text":"Type Name int main (int argc, char * argv) Main entry point for the BG_Flood model executable. int mainwork (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Main model setup and execution routine for BG_Flood."},{"location":"BGFlood/_b_g___flood_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_b_g___flood_8cu/#function-main","title":"function main","text":"<p>Main entry point for the BG_Flood model executable. </p><pre><code>int main (\n    int argc,\n    char * argv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>argc</code> Number of command-line arguments </li> <li><code>argv</code> Array of command-line argument strings </li> </ul> <p>Returns:</p> <p>Status code (0 for success)</p> <p>Main function This function is the entry point to the software The main function setups all the init of the model and then calls the mainloop to actually run the model</p> <p>There are 3 main class storing information about the model: XParam (class Param), XModel (class Model) and XForcing (class Forcing) Leading X stands for eXecution and is to avoid confusion between the class variable and the class declaration When running with the GPU there is also XModel_g which is the same as XModel but with GPU specific pointers</p> <p>This function does: * Reads the inputs to the model * Allocate memory on GPU and CPU * Prepare and initialise memory and arrays on CPU and GPU * Setup initial condition * Adapt grid if require * Prepare output file * Run main loop * Clean up and close</p> <p>It coordinates CPU and GPU resources and calls the mainwork routine for model execution. </p>"},{"location":"BGFlood/_b_g___flood_8cu/#function-mainwork","title":"function mainwork","text":"<p>Main model setup and execution routine for BG_Flood. </p><pre><code>template&lt;class T&gt;\nint mainwork (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XModel</code> Model structure (CPU) </li> <li><code>XModel_g</code> Model structure (GPU) </li> </ul> <p>Returns:</p> <p>Status code (0 for success)</p> <p>This function performs the main setup and execution steps for the BG_Flood model: * Reads and verifies input/forcing data * Initializes mesh and initial conditions * Performs initial adaptation * Sets up GPU resources * Runs the main simulation loop (MainLoop) * Handles test mode if specified</p> <p>Integrates all major model components and coordinates CPU/GPU execution. </p> <p>The documentation for this class was generated from the following file <code>src/BG_Flood.cu</code></p>"},{"location":"BGFlood/_b_g___flood_8cu_source/","title":"File BG_Flood.cu","text":""},{"location":"BGFlood/_b_g___flood_8cu_source/#file-bg_floodcu","title":"File BG_Flood.cu","text":"<p>File List &gt; src &gt; BG_Flood.cu</p> <p>Go to the documentation of this file</p> <pre><code>// BG_Flood Main function                                                       //\n// Copyright (C) 2018 Bosserelle                                                //\n// This code contains an adaptation of the St Venant equation from Basilisk     //\n// See                                                                          //\n// http://basilisk.fr/src/saint-venant.h and                                    //\n// S. Popinet. Quadtree-adaptive tsunami modelling. Ocean Dynamics,             //\n// doi: 61(9) : 1261 - 1285, 2011                                               //\n//                                                                              //\n// This program is free software: you can redistribute it and/or modify         //\n// it under the terms of the GNU General Public License as published by         //\n// the Free Software Foundation.                                                //\n//                                                                              //\n// This program is distributed in the hope that it will be useful,              //\n// but WITHOUT ANY WARRANTY; without even the implied warranty of               //\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                //\n// GNU General Public License for more details.                                 //\n//                                                                              //\n// You should have received a copy of the GNU General Public License            //\n// along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.        //\n\n// includes, system\n\n#include \"BG_Flood.h\"\n\n\nint main(int argc, char* argv[])\n{\n    //===========================================\n    // Read model argument (filename). If one is not given use the default name\n    std::string ParamFile;\n\n    if (argc &gt; 1)\n    {\n        ParamFile = argv[1];\n    }\n    else\n    {\n        ParamFile = \"BG_param.txt\";\n    }\n\n    //std::cout &lt;&lt; ParamFile &lt;&lt; '\\n';\n\n    //===========================================\n    //  Define the main parameter controling the model (XModels class at produced later) \n    Param XParam;\n    Forcing&lt;float&gt; XForcing; // for reading and storing forcing data (CPU only) // by default we read only float precision!\n    // Start timer to keep track of time\n    XParam.startcputime = clock();\n\n\n    // Create/overwrite existing \n    create_logfile();\n\n    //============================================\n    // Read Operational file\n    // Also check XParam sanity\n\n    Readparamfile(XParam, XForcing, ParamFile);\n\n\n    //============================================\n    // Create external forcing and model pointers\n    // Before this is done we need to check\n    // if the model will be double or float precision\n\n    Model&lt;double&gt; XModel_d; // For CPU double pointers\n    Model&lt;double&gt; XModel_gd; // For GPU double pointers\n\n    Model&lt;float&gt; XModel_f; // For CPU float pointers\n    Model&lt;float&gt; XModel_gf; // For GPU float pointers\n\n    if (XParam.doubleprecision &lt; 1)\n    {\n        // Call the Float precision run\n        mainwork(XParam, XForcing, XModel_f, XModel_gf);\n    }\n    else\n    {\n        mainwork(XParam, XForcing, XModel_d, XModel_gd);\n    }\n\n}\n\ntemplate &lt; class T &gt; int mainwork(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    //============================================\n    // Read the forcing data (Including bathymetry)\n    readforcing(XParam, XForcing);\n\n    //=============================================\n    // Verify Compatibility of forcing and model Parameters\n    checkparamsanity(XParam, XForcing);\n\n    //============================================\n    // Prepare initial mesh layout\n    InitMesh(XParam, XForcing, XModel);\n\n    //============================================\n    // Prepare initial conditions on CPU\n    InitialConditions(XParam, XForcing, XModel);\n\n    //============================================\n    // Initial adaptation\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    //============================================\n    // Setup GPU (bypassed within the function if no suitable GPU is available)\n    SetupGPU(XParam, XModel,XForcing, XModel_g);\n\n\n    //\n    log(\"\\nModel setup complete\");\n    log(\"#################################\");\n    //===========================================\n    //   End of Initialisation time\n    //===========================================\n    XParam.setupcputime = clock();\n    bool isfailed = false;\n\n    if (XParam.test &lt; 0)\n    {\n        //============================================\n        // MainLoop\n        MainLoop(XParam, XForcing, XModel, XModel_g);\n    }\n    else\n    {\n        //============================================\n        // Testing\n        //Gaussianhump(XParam, XModel, XModel_g);\n        isfailed = Testing(XParam, XForcing, XModel, XModel_g);\n    }\n\n\n\n    //===========================================\n    //   End of Model\n    //===========================================\n    XParam.endcputime = clock();\n\n    //===========================================\n    //   Log the timer\n    //===========================================\n    log(\"#################################\");\n    log(\"End Computation\");\n    log(\"#################################\");\n    log(\"Total runtime= \" + std::to_string((XParam.endcputime - XParam.startcputime) / CLOCKS_PER_SEC) + \" seconds\");\n    log(\"Model Setup time= \" + std::to_string((XParam.setupcputime - XParam.startcputime) / CLOCKS_PER_SEC) + \" seconds\");\n    log(\"Model runtime= \" + std::to_string((XParam.endcputime - XParam.setupcputime) / CLOCKS_PER_SEC) + \" seconds\");\n\n\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        size_t free_byte;\n\n        size_t total_byte;\n\n        CUDA_CHECK(cudaMemGetInfo(&amp;free_byte, &amp;total_byte));\n\n        XParam.GPU_totalmem_byte = (total_byte - free_byte) - XParam.GPU_initmem_byte;\n        log(\"Model final memory usage= \" + std::to_string((XParam.GPU_totalmem_byte) / 1024.0 / 1024.0) + \" MB\");\n\n    }\n\n\n    //============================================\n    // Cleanup and free memory\n    //\n    if (XParam.test &lt; 0)\n    {\n        exit(0);\n    }\n    else \n    {\n        exit(isfailed);\n    }\n\n}\n</code></pre>"},{"location":"BGFlood/_b_g___flood_8h/","title":"File BG_Flood.h","text":""},{"location":"BGFlood/_b_g___flood_8h/#file-bg_floodh","title":"File BG_Flood.h","text":"<p>FileList &gt; src &gt; BG_Flood.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"ReadInput.h\"</code></li> <li><code>#include \"ReadForcing.h\"</code></li> <li><code>#include \"Setup_GPU.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Mesh.h\"</code></li> <li><code>#include \"InitialConditions.h\"</code></li> <li><code>#include \"Adaptation.h\"</code></li> <li><code>#include \"Mainloop.h\"</code></li> <li><code>#include \"Testing.h\"</code></li> </ul>"},{"location":"BGFlood/_b_g___flood_8h/#public-functions","title":"Public Functions","text":"Type Name int mainwork (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Main model setup and execution routine for BG_Flood."},{"location":"BGFlood/_b_g___flood_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_b_g___flood_8h/#function-mainwork","title":"function mainwork","text":"<p>Main model setup and execution routine for BG_Flood. </p><pre><code>template&lt;class T&gt;\nint mainwork (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XModel</code> Model structure (CPU) </li> <li><code>XModel_g</code> Model structure (GPU) </li> </ul> <p>Returns:</p> <p>Status code (0 for success)</p> <p>This function performs the main setup and execution steps for the BG_Flood model: * Reads and verifies input/forcing data * Initializes mesh and initial conditions * Performs initial adaptation * Sets up GPU resources * Runs the main simulation loop (MainLoop) * Handles test mode if specified</p> <p>Integrates all major model components and coordinates CPU/GPU execution. </p> <p>The documentation for this class was generated from the following file <code>src/BG_Flood.h</code></p>"},{"location":"BGFlood/_b_g___flood_8h_source/","title":"File BG_Flood.h","text":""},{"location":"BGFlood/_b_g___flood_8h_source/#file-bg_floodh","title":"File BG_Flood.h","text":"<p>File List &gt; src &gt; BG_Flood.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef BGFLOOD_H\n#define BGFLOOD_H\n// includes, system\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"ReadInput.h\"\n#include \"ReadForcing.h\"\n#include \"Setup_GPU.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"Mesh.h\"\n#include \"InitialConditions.h\"\n#include \"Adaptation.h\"\n#include \"Setup_GPU.h\"\n#include \"Mainloop.h\"\n\n#include \"Testing.h\"\n\n\ntemplate &lt; class T &gt; int mainwork(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_boundary_8cu/","title":"File Boundary.cu","text":""},{"location":"BGFlood/_boundary_8cu/#file-boundarycu","title":"File Boundary.cu","text":"<p>FileList &gt; src &gt; Boundary.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Boundary.h\"</code></li> </ul>"},{"location":"BGFlood/_boundary_8cu/#public-functions","title":"Public Functions","text":"Type Name __device__ __host__ void ABS1D (T g, T sign, T zsbnd, T zsinside, T hinside, T utbnd, T unbnd, T &amp; un, T &amp; ut, T &amp; zs, T &amp; h) Device/host function for 1D absorbing boundary condition. __device__ __host__ void ABS1DQ (T g, T sign, T factime, T facrel, T zs, T zsbnd, T zsinside, T h, T &amp; qmean, T &amp; q, T &amp; G, T &amp; S) Device/host function for 1D absorbing boundary condition for flux variables. __device__ __host__ void Dirichlet1D (T g, T sign, T zsbnd, T zsinside, T hinside, T uninside, T &amp; un, T &amp; ut, T &amp; zs, T &amp; h) Device/host function for 1D Dirichlet boundary condition. __device__ __host__ void Dirichlet1Q (T g, T sign, T zsbnd, T zsinside, T hinside, T uninside, T &amp; q) Device/host function for 1D Dirichlet boundary condition for flux variables. void Flowbnd (Param XParam, Loop&lt; T &gt; &amp; XLoop, BlockP&lt; T &gt; XBlock, bndparam side, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; T &gt; XEv) Applies boundary conditions for flow variables on a given side of the domain. template void Flowbnd&lt; double &gt; (Param XParam, Loop&lt; double &gt; &amp; XLoop, BlockP&lt; double &gt; XBlock, bndparam side, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; double &gt; XEv)  template void Flowbnd&lt; float &gt; (Param XParam, Loop&lt; float &gt; &amp; XLoop, BlockP&lt; float &gt; XBlock, bndparam side, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; float &gt; XEv)  void FlowbndFlux (Param XParam, double totaltime, BlockP&lt; T &gt; XBlock, bndsegment bndseg, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; T &gt; XEv, FluxP&lt; T &gt; XFlux) Applies boundary conditions for flux variables on a given segment of the domain. template void FlowbndFlux&lt; double &gt; (Param XParam, double totaltime, BlockP&lt; double &gt; XBlock, bndsegment bndseg, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; double &gt; XEv, FluxP&lt; double &gt; XFlux)  template void FlowbndFlux&lt; float &gt; (Param XParam, double totaltime, BlockP&lt; float &gt; XBlock, bndsegment bndseg, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; float &gt; XEv, FluxP&lt; float &gt; XFlux)  void FlowbndFluxML (Param XParam, double totaltime, BlockP&lt; T &gt; XBlock, bndsegment bndseg, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; T &gt; XEv, FluxMLP&lt; T &gt; XFlux) Applies boundary conditions for flux ML variables on a given segment of the domain. template void FlowbndFluxML&lt; double &gt; (Param XParam, double totaltime, BlockP&lt; double &gt; XBlock, bndsegment bndseg, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; double &gt; XEv, FluxMLP&lt; double &gt; XFlux)  template void FlowbndFluxML&lt; float &gt; (Param XParam, double totaltime, BlockP&lt; float &gt; XBlock, bndsegment bndseg, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; float &gt; XEv, FluxMLP&lt; float &gt; XFlux)  void FlowbndFluxold (Param XParam, double totaltime, BlockP&lt; T &gt; XBlock, bndparam side, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; T &gt; XEv, FluxP&lt; T &gt; XFlux) Applies legacy boundary conditions for flux variables on a given side of the domain. template void FlowbndFluxold&lt; double &gt; (Param XParam, double totaltime, BlockP&lt; double &gt; XBlock, bndparam side, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; double &gt; XEv, FluxP&lt; double &gt; XFlux)  template void FlowbndFluxold&lt; float &gt; (Param XParam, double totaltime, BlockP&lt; float &gt; XBlock, bndparam side, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; float &gt; XEv, FluxP&lt; float &gt; XFlux)  __host__ __device__ int Inside (int halowidth, int blkmemwidth, int isright, int istop, int ix, int iy, int ib) Helper to compute the index of the inside cell for a boundary cell. __host__ void bndCPU (Param XParam, bndparam side, BlockP&lt; T &gt; XBlock, std::vector&lt; double &gt; zsbndvec, std::vector&lt; double &gt; uubndvec, std::vector&lt; double &gt; vvbndvec, DynForcingP&lt; float &gt; Atmp, T * zs, T * h, T * un, T * ut) CPU implementation for applying boundary conditions on a side. template __host__ void bndCPU&lt; double &gt; (Param XParam, bndparam side, BlockP&lt; double &gt; XBlock, std::vector&lt; double &gt; zsbndvec, std::vector&lt; double &gt; uubndvec, std::vector&lt; double &gt; vvbndvec, DynForcingP&lt; float &gt; Atmp, double * zs, double * h, double * un, double * ut)  template __host__ void bndCPU&lt; float &gt; (Param XParam, bndparam side, BlockP&lt; float &gt; XBlock, std::vector&lt; double &gt; zsbndvec, std::vector&lt; double &gt; uubndvec, std::vector&lt; double &gt; vvbndvec, DynForcingP&lt; float &gt; Atmp, float * zs, float * h, float * un, float * ut)  __global__ void bndFluxGPUSide (Param XParam, bndsegmentside side, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Atmp, DynForcingP&lt; float &gt; Zsmap, bool uniform, int type, float zsbnd, T taper, T * zs, T * h, T * un, T * ut, T * Fh, T * Fq, T * Ss) CUDA kernel for applying boundary fluxes on a segment side (GPU version). void bndFluxGPUSideCPU (Param XParam, bndsegmentside side, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Atmp, DynForcingP&lt; float &gt; Zsmap, bool uniform, int type, float zsbnd, T taper, T * zs, T * h, T * un, T * ut, T * Fh, T * Fq, T * Ss) CPU implementation for applying boundary fluxes on a segment side. __global__ void bndGPU (Param XParam, bndparam side, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Atmp, float itime, T * zs, T * h, T * un, T * ut) CUDA kernel for applying boundary conditions on a side (GPU version). template __global__ void bndGPU&lt; double &gt; (Param XParam, bndparam side, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; Atmp, float itime, double * zs, double * h, double * un, double * ut)  template __global__ void bndGPU&lt; float &gt; (Param XParam, bndparam side, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; Atmp, float itime, float * zs, float * h, float * un, float * ut)  __device__ __host__ void findmaskside (int side, bool &amp; isleftbot, bool &amp; islefttop, bool &amp; istopleft, bool &amp; istopright, bool &amp; isrighttop, bool &amp; isrightbot, bool &amp; isbotright, bool &amp; isbotleft) Helper to decode mask side bitfield into booleans for each boundary/corner. __device__ __host__ void halowall (T zsinside, T &amp; un, T &amp; ut, T &amp; zs, T &amp; h, T &amp; zb) Device/host function to apply wall boundary in halo region. __host__ __device__ bool isbnd (int isright, int istop, int blkwidth, int ix, int iy) Helper to check if a cell is at the boundary. __host__ void maskbnd (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) CPU implementation for applying masked blocks boundary conditions (halo walls). template __host__ void maskbnd&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template __host__ void maskbnd&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  __global__ void maskbndGPUFluxbot (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux) CUDA kernel for applying masked flux boundary conditions on the bottom side. template __global__ void maskbndGPUFluxbot&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, FluxP&lt; double &gt; Flux)  template __global__ void maskbndGPUFluxbot&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, FluxP&lt; float &gt; Flux)  __global__ void maskbndGPUFluxleft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, FluxP&lt; T &gt; Flux) CUDA kernel for applying masked flux boundary conditions on the left side. template __global__ void maskbndGPUFluxleft&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, FluxP&lt; double &gt; Flux)  template __global__ void maskbndGPUFluxleft&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, FluxP&lt; float &gt; Flux)  __global__ void maskbndGPUFluxright (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux) CUDA kernel for applying masked flux boundary conditions on the right side. template __global__ void maskbndGPUFluxright&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, FluxP&lt; double &gt; Flux)  template __global__ void maskbndGPUFluxright&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, FluxP&lt; float &gt; Flux)  __global__ void maskbndGPUFluxtop (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux) CUDA kernel for applying masked flux boundary conditions on the top side. template __global__ void maskbndGPUFluxtop&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, FluxP&lt; double &gt; Flux)  template __global__ void maskbndGPUFluxtop&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, FluxP&lt; float &gt; Flux)  __global__ void maskbndGPUbot (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) CUDA kernel for applying masked boundary conditions (halo walls) on the bottom side. template __global__ void maskbndGPUbot&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template __global__ void maskbndGPUbot&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  __global__ void maskbndGPUleft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) CUDA kernel for applying masked boundary conditions (halo walls) on the left side. template __global__ void maskbndGPUleft&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template __global__ void maskbndGPUleft&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  __global__ void maskbndGPUright (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) CUDA kernel for applying masked boundary conditions (halo walls) on the right side. template __global__ void maskbndGPUright&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template __global__ void maskbndGPUright&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  __global__ void maskbndGPUtop (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) CUDA kernel for applying masked boundary conditions (halo walls) on the top side. template __global__ void maskbndGPUtop&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template __global__ void maskbndGPUtop&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  __device__ __host__ void noslipbnd (T zsinside, T hinside, T &amp; un, T &amp; ut, T &amp; zs, T &amp; h) Device/host function to apply no-slip boundary condition. __device__ __host__ void noslipbndQ (T &amp; F, T &amp; G, T &amp; S) Device/host function to apply no-slip boundary for flux variables."},{"location":"BGFlood/_boundary_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_boundary_8cu/#function-abs1d","title":"function ABS1D","text":"<p>Device/host function for 1D absorbing boundary condition. </p><pre><code>template&lt;class T&gt;\n__device__ __host__ void ABS1D (\n    T g,\n    T sign,\n    T zsbnd,\n    T zsinside,\n    T hinside,\n    T utbnd,\n    T unbnd,\n    T &amp; un,\n    T &amp; ut,\n    T &amp; zs,\n    T &amp; h\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>g</code> Gravity </li> <li><code>sign</code> Side sign </li> <li><code>zsbnd</code> Boundary zs value </li> <li><code>zsinside</code> Inside zs value </li> <li><code>hinside</code> Inside h value </li> <li><code>utbnd</code> Tangential boundary velocity </li> <li><code>unbnd</code> Normal boundary velocity </li> <li><code>un</code> Normal velocity (output) </li> <li><code>ut</code> Tangential velocity (output) </li> <li><code>zs</code> zs value (output) </li> <li><code>h</code> h value (output)</li> </ul> <p>Computes absorbing boundary for normal/tangential velocity and updates zs, h. </p>"},{"location":"BGFlood/_boundary_8cu/#function-abs1dq","title":"function ABS1DQ","text":"<p>Device/host function for 1D absorbing boundary condition for flux variables. </p><pre><code>template&lt;class T&gt;\n__device__ __host__ void ABS1DQ (\n    T g,\n    T sign,\n    T factime,\n    T facrel,\n    T zs,\n    T zsbnd,\n    T zsinside,\n    T h,\n    T &amp; qmean,\n    T &amp; q,\n    T &amp; G,\n    T &amp; S\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>g</code> Gravity </li> <li><code>sign</code> Side sign </li> <li><code>factime</code> Filter time factor </li> <li><code>facrel</code> Relaxation time factor </li> <li><code>zs</code> zs value </li> <li><code>zsbnd</code> Boundary zs value </li> <li><code>zsinside</code> Inside zs value </li> <li><code>h</code> h value </li> <li><code>qmean</code> Mean flux (output) </li> <li><code>q</code> Flux q (output) </li> <li><code>G</code> Flux G (output) </li> <li><code>S</code> Source term (output)</li> </ul> <p>Computes absorbing boundary for flux variables and updates qmean, q, G, S. </p>"},{"location":"BGFlood/_boundary_8cu/#function-dirichlet1d","title":"function Dirichlet1D","text":"<p>Device/host function for 1D Dirichlet boundary condition. </p><pre><code>template&lt;class T&gt;\n__device__ __host__ void Dirichlet1D (\n    T g,\n    T sign,\n    T zsbnd,\n    T zsinside,\n    T hinside,\n    T uninside,\n    T &amp; un,\n    T &amp; ut,\n    T &amp; zs,\n    T &amp; h\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>g</code> Gravity </li> <li><code>sign</code> Side sign </li> <li><code>zsbnd</code> Boundary zs value </li> <li><code>zsinside</code> Inside zs value </li> <li><code>hinside</code> Inside h value </li> <li><code>uninside</code> Inside normal velocity </li> <li><code>un</code> Normal velocity (output) </li> <li><code>ut</code> Tangential velocity (output) </li> <li><code>zs</code> zs value (output) </li> <li><code>h</code> h value (output)</li> </ul> <p>Computes Dirichlet boundary for normal/tangential velocity and updates zs, h. </p>"},{"location":"BGFlood/_boundary_8cu/#function-dirichlet1q","title":"function Dirichlet1Q","text":"<p>Device/host function for 1D Dirichlet boundary condition for flux variables. </p><pre><code>template&lt;class T&gt;\n__device__ __host__ void Dirichlet1Q (\n    T g,\n    T sign,\n    T zsbnd,\n    T zsinside,\n    T hinside,\n    T uninside,\n    T &amp; q\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>g</code> Gravity </li> <li><code>sign</code> Side sign </li> <li><code>zsbnd</code> Boundary zs value </li> <li><code>zsinside</code> Inside zs value </li> <li><code>hinside</code> Inside h value </li> <li><code>uninside</code> Inside normal velocity </li> <li><code>q</code> Flux q (output)</li> </ul> <p>Computes Dirichlet boundary for flux variable q. </p>"},{"location":"BGFlood/_boundary_8cu/#function-flowbnd","title":"function Flowbnd","text":"<p>Applies boundary conditions for flow variables on a given side of the domain. </p><pre><code>template&lt;class T&gt;\nvoid Flowbnd (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    bndparam side,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; T &gt; XEv\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XBlock</code> Block data structure </li> <li><code>side</code> Boundary parameter (side info) </li> <li><code>Atmp</code> Dynamic forcing data </li> <li><code>XEv</code> Evolving variables</li> </ul> <p>Handles boundary values for water level, velocity, and applies interpolation in time and space. Integrates any existing comments and logic. </p>"},{"location":"BGFlood/_boundary_8cu/#function-flowbnd-double","title":"function Flowbnd&lt; double &gt;","text":"<pre><code>template void Flowbnd&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; &amp; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    bndparam side,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; double &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-flowbnd-float","title":"function Flowbnd&lt; float &gt;","text":"<pre><code>template void Flowbnd&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; &amp; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    bndparam side,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; float &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-flowbndflux","title":"function FlowbndFlux","text":"<p>Applies boundary conditions for flux variables on a given segment of the domain. </p><pre><code>template&lt;class T&gt;\nvoid FlowbndFlux (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; T &gt; XBlock,\n    bndsegment bndseg,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; T &gt; XEv,\n    FluxP &lt; T &gt; XFlux\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>totaltime</code> Current simulation time </li> <li><code>XBlock</code> Block data structure </li> <li><code>bndseg</code> Boundary segment info </li> <li><code>Atmp</code> Dynamic forcing data </li> <li><code>XEv</code> Evolving variables </li> <li><code>XFlux</code> Flux variables</li> </ul> <p>Handles boundary fluxes, applies tapers, and manages GPU/CPU execution for boundary segments. Integrates any existing comments and logic. </p>"},{"location":"BGFlood/_boundary_8cu/#function-flowbndflux-double","title":"function FlowbndFlux&lt; double &gt;","text":"<pre><code>template void FlowbndFlux&lt; double &gt; (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; double &gt; XBlock,\n    bndsegment bndseg,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; double &gt; XEv,\n    FluxP &lt; double &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-flowbndflux-float","title":"function FlowbndFlux&lt; float &gt;","text":"<pre><code>template void FlowbndFlux&lt; float &gt; (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; float &gt; XBlock,\n    bndsegment bndseg,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; float &gt; XEv,\n    FluxP &lt; float &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-flowbndfluxml","title":"function FlowbndFluxML","text":"<p>Applies boundary conditions for flux ML variables on a given segment of the domain. </p><pre><code>template&lt;class T&gt;\nvoid FlowbndFluxML (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; T &gt; XBlock,\n    bndsegment bndseg,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; T &gt; XEv,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>totaltime</code> Current simulation time </li> <li><code>XBlock</code> Block data structure </li> <li><code>bndseg</code> Boundary segment info </li> <li><code>Atmp</code> Dynamic forcing data </li> <li><code>XEv</code> Evolving variables </li> <li><code>XFlux</code> Machine learning flux variables</li> </ul> <p>Handles boundary fluxes for ML variables, applies tapers, and manages GPU/CPU execution for boundary segments. Integrates any existing comments and logic. </p>"},{"location":"BGFlood/_boundary_8cu/#function-flowbndfluxml-double","title":"function FlowbndFluxML&lt; double &gt;","text":"<pre><code>template void FlowbndFluxML&lt; double &gt; (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; double &gt; XBlock,\n    bndsegment bndseg,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; double &gt; XEv,\n    FluxMLP &lt; double &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-flowbndfluxml-float","title":"function FlowbndFluxML&lt; float &gt;","text":"<pre><code>template void FlowbndFluxML&lt; float &gt; (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; float &gt; XBlock,\n    bndsegment bndseg,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; float &gt; XEv,\n    FluxMLP &lt; float &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-flowbndfluxold","title":"function FlowbndFluxold","text":"<p>Applies legacy boundary conditions for flux variables on a given side of the domain. </p><pre><code>template&lt;class T&gt;\nvoid FlowbndFluxold (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; T &gt; XBlock,\n    bndparam side,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; T &gt; XEv,\n    FluxP &lt; T &gt; XFlux\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>totaltime</code> Current simulation time </li> <li><code>XBlock</code> Block data structure </li> <li><code>side</code> Boundary parameter (side info) </li> <li><code>Atmp</code> Dynamic forcing data </li> <li><code>XEv</code> Evolving variables </li> <li><code>XFlux</code> Flux variables</li> </ul> <p>Handles boundary fluxes using older logic, applies tapers, and manages GPU/CPU execution for boundary sides. Integrates any existing comments and logic. </p>"},{"location":"BGFlood/_boundary_8cu/#function-flowbndfluxold-double","title":"function FlowbndFluxold&lt; double &gt;","text":"<pre><code>template void FlowbndFluxold&lt; double &gt; (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; double &gt; XBlock,\n    bndparam side,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; double &gt; XEv,\n    FluxP &lt; double &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-flowbndfluxold-float","title":"function FlowbndFluxold&lt; float &gt;","text":"<pre><code>template void FlowbndFluxold&lt; float &gt; (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; float &gt; XBlock,\n    bndparam side,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; float &gt; XEv,\n    FluxP &lt; float &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-inside","title":"function Inside","text":"<p>Helper to compute the index of the inside cell for a boundary cell. </p><pre><code>__host__ __device__ int Inside (\n    int halowidth,\n    int blkmemwidth,\n    int isright,\n    int istop,\n    int ix,\n    int iy,\n    int ib\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> Halo width </li> <li><code>blkmemwidth</code> Block memory width </li> <li><code>isright</code> Side info </li> <li><code>istop</code> Top info </li> <li><code>ix</code> x-index </li> <li><code>iy</code> y-index </li> <li><code>ib</code> Block index </li> </ul> <p>Returns:</p> <p>Index of the inside cell </p>"},{"location":"BGFlood/_boundary_8cu/#function-bndcpu","title":"function bndCPU","text":"<p>CPU implementation for applying boundary conditions on a side. </p><pre><code>template&lt;class T&gt;\n__host__ void bndCPU (\n    Param XParam,\n    bndparam side,\n    BlockP &lt; T &gt; XBlock,\n    std::vector&lt; double &gt; zsbndvec,\n    std::vector&lt; double &gt; uubndvec,\n    std::vector&lt; double &gt; vvbndvec,\n    DynForcingP &lt; float &gt; Atmp,\n    T * zs,\n    T * h,\n    T * un,\n    T * ut\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>side</code> Boundary parameter info </li> <li><code>XBlock</code> Block data structure </li> <li><code>zsbndvec</code> Vector of boundary zs values </li> <li><code>uubndvec</code> Vector of boundary u values </li> <li><code>vvbndvec</code> Vector of boundary v values </li> <li><code>Atmp</code> Dynamic forcing data </li> <li><code>zs</code> Array of zs values </li> <li><code>h</code> Array of h values </li> <li><code>un</code> Array of normal velocities </li> <li><code>ut</code> Array of tangential velocities</li> </ul> <p>Applies boundary conditions for each block/thread on the CPU, using provided boundary vectors and dynamic forcing data. Handles no-slip, Dirichlet, ABS, and Neumann boundary types. Integrates any existing comments and logic. </p>"},{"location":"BGFlood/_boundary_8cu/#function-bndcpu-double","title":"function bndCPU&lt; double &gt;","text":"<pre><code>template __host__ void bndCPU&lt; double &gt; (\n    Param XParam,\n    bndparam side,\n    BlockP &lt; double &gt; XBlock,\n    std::vector&lt; double &gt; zsbndvec,\n    std::vector&lt; double &gt; uubndvec,\n    std::vector&lt; double &gt; vvbndvec,\n    DynForcingP &lt; float &gt; Atmp,\n    double * zs,\n    double * h,\n    double * un,\n    double * ut\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-bndcpu-float","title":"function bndCPU&lt; float &gt;","text":"<pre><code>template __host__ void bndCPU&lt; float &gt; (\n    Param XParam,\n    bndparam side,\n    BlockP &lt; float &gt; XBlock,\n    std::vector&lt; double &gt; zsbndvec,\n    std::vector&lt; double &gt; uubndvec,\n    std::vector&lt; double &gt; vvbndvec,\n    DynForcingP &lt; float &gt; Atmp,\n    float * zs,\n    float * h,\n    float * un,\n    float * ut\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-bndfluxgpuside","title":"function bndFluxGPUSide","text":"<p>CUDA kernel for applying boundary fluxes on a segment side (GPU version). </p><pre><code>template&lt;class T&gt;\n__global__ void bndFluxGPUSide (\n    Param XParam,\n    bndsegmentside side,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Atmp,\n    DynForcingP &lt; float &gt; Zsmap,\n    bool uniform,\n    int type,\n    float zsbnd,\n    T taper,\n    T * zs,\n    T * h,\n    T * un,\n    T * ut,\n    T * Fh,\n    T * Fq,\n    T * Ss\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>side</code> Boundary segment side info </li> <li><code>XBlock</code> Block data structure </li> <li><code>Atmp</code> Dynamic forcing data </li> <li><code>Zsmap</code> Dynamic forcing data for zs </li> <li><code>uniform</code> Whether boundary is uniform </li> <li><code>type</code> Boundary type </li> <li><code>zsbnd</code> Boundary zs value </li> <li><code>taper</code> Taper value for smoothing </li> <li><code>zs</code> Array of zs values </li> <li><code>h</code> Array of h values </li> <li><code>un</code> Array of normal velocities </li> <li><code>ut</code> Array of tangential velocities </li> <li><code>Fh</code> Array for flux h </li> <li><code>Fq</code> Array for flux q </li> <li><code>Ss</code> Array for source terms</li> </ul> <p>Applies boundary conditions and fluxes for each thread/block on the GPU, handling tapers, Dirichlet, and ABS boundary types. </p>"},{"location":"BGFlood/_boundary_8cu/#function-bndfluxgpusidecpu","title":"function bndFluxGPUSideCPU","text":"<p>CPU implementation for applying boundary fluxes on a segment side. </p><pre><code>template&lt;class T&gt;\nvoid bndFluxGPUSideCPU (\n    Param XParam,\n    bndsegmentside side,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Atmp,\n    DynForcingP &lt; float &gt; Zsmap,\n    bool uniform,\n    int type,\n    float zsbnd,\n    T taper,\n    T * zs,\n    T * h,\n    T * un,\n    T * ut,\n    T * Fh,\n    T * Fq,\n    T * Ss\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>side</code> Boundary segment side info </li> <li><code>XBlock</code> Block data structure </li> <li><code>Atmp</code> Dynamic forcing data </li> <li><code>Zsmap</code> Dynamic forcing data for zs </li> <li><code>uniform</code> Whether boundary is uniform </li> <li><code>type</code> Boundary type </li> <li><code>zsbnd</code> Boundary zs value </li> <li><code>taper</code> Taper value for smoothing </li> <li><code>zs</code> Array of zs values </li> <li><code>h</code> Array of h values </li> <li><code>un</code> Array of normal velocities </li> <li><code>ut</code> Array of tangential velocities </li> <li><code>Fh</code> Array for flux h </li> <li><code>Fq</code> Array for flux q </li> <li><code>Ss</code> Array for source terms</li> </ul> <p>Applies boundary conditions and fluxes for each block/thread on the CPU, handling tapers, Dirichlet, and ABS boundary types. </p>"},{"location":"BGFlood/_boundary_8cu/#function-bndgpu","title":"function bndGPU","text":"<p>CUDA kernel for applying boundary conditions on a side (GPU version). </p><pre><code>template&lt;class T&gt;\n__global__ void bndGPU (\n    Param XParam,\n    bndparam side,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Atmp,\n    float itime,\n    T * zs,\n    T * h,\n    T * un,\n    T * ut\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>side</code> Boundary parameter info </li> <li><code>XBlock</code> Block data structure </li> <li><code>Atmp</code> Dynamic forcing data </li> <li><code>itime</code> Interpolated time for boundary data </li> <li><code>zs</code> Array of zs values </li> <li><code>h</code> Array of h values </li> <li><code>un</code> Array of normal velocities </li> <li><code>ut</code> Array of tangential velocities</li> </ul> <p>Applies boundary conditions for each thread/block on the GPU, using interpolated time and dynamic forcing data. </p>"},{"location":"BGFlood/_boundary_8cu/#function-bndgpu-double","title":"function bndGPU&lt; double &gt;","text":"<pre><code>template __global__ void bndGPU&lt; double &gt; (\n    Param XParam,\n    bndparam side,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; Atmp,\n    float itime,\n    double * zs,\n    double * h,\n    double * un,\n    double * ut\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-bndgpu-float","title":"function bndGPU&lt; float &gt;","text":"<pre><code>template __global__ void bndGPU&lt; float &gt; (\n    Param XParam,\n    bndparam side,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; Atmp,\n    float itime,\n    float * zs,\n    float * h,\n    float * un,\n    float * ut\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-findmaskside","title":"function findmaskside","text":"<p>Helper to decode mask side bitfield into booleans for each boundary/corner. </p><pre><code>__device__ __host__ void findmaskside (\n    int side,\n    bool &amp; isleftbot,\n    bool &amp; islefttop,\n    bool &amp; istopleft,\n    bool &amp; istopright,\n    bool &amp; isrighttop,\n    bool &amp; isrightbot,\n    bool &amp; isbotright,\n    bool &amp; isbotleft\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>side</code> Bitfield encoding mask sides </li> <li><code>isleftbot</code> Is left-bottom active </li> <li><code>islefttop</code> Is left-top active </li> <li><code>istopleft</code> Is top-left active </li> <li><code>istopright</code> Is top-right active </li> <li><code>isrighttop</code> Is right-top active </li> <li><code>isrightbot</code> Is right-bottom active </li> <li><code>isbotright</code> Is bottom-right active </li> <li><code>isbotleft</code> Is bottom-left active </li> </ul>"},{"location":"BGFlood/_boundary_8cu/#function-halowall","title":"function halowall","text":"<p>Device/host function to apply wall boundary in halo region. </p><pre><code>template&lt;class T&gt;\n__device__ __host__ void halowall (\n    T zsinside,\n    T &amp; un,\n    T &amp; ut,\n    T &amp; zs,\n    T &amp; h,\n    T &amp; zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>zsinside</code> Inside zs value </li> <li><code>un</code> Normal velocity (output) </li> <li><code>ut</code> Tangential velocity (output) </li> <li><code>zs</code> zs value (output) </li> <li><code>h</code> h value (output) </li> <li><code>zb</code> Mask value (output)</li> </ul> <p>Sets normal/tangential velocity and h to zero, copies zsinside to zs and zb. </p>"},{"location":"BGFlood/_boundary_8cu/#function-isbnd","title":"function isbnd","text":"<p>Helper to check if a cell is at the boundary. </p><pre><code>__host__ __device__ bool isbnd (\n    int isright,\n    int istop,\n    int blkwidth,\n    int ix,\n    int iy\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>isright</code> Side info </li> <li><code>istop</code> Top info </li> <li><code>blkwidth</code> Block width </li> <li><code>ix</code> x-index </li> <li><code>iy</code> y-index </li> </ul> <p>Returns:</p> <p>True if cell is at the boundary, false otherwise </p>"},{"location":"BGFlood/_boundary_8cu/#function-maskbnd","title":"function maskbnd","text":"<p>CPU implementation for applying masked blocks boundary conditions (halo walls). </p><pre><code>template&lt;class T&gt;\n__host__ void maskbnd (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Xev</code> Evolving variables </li> <li><code>zb</code> Array of mask values</li> </ul> <p>Applies wall boundary conditions in the halo region for masked blocks, updating velocities, zs, h, and mask values. Handles all four sides and corners. Integrates any existing comments and logic. </p>"},{"location":"BGFlood/_boundary_8cu/#function-maskbnd-double","title":"function maskbnd&lt; double &gt;","text":"<pre><code>template __host__ void maskbnd&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-maskbnd-float","title":"function maskbnd&lt; float &gt;","text":"<pre><code>template __host__ void maskbnd&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpufluxbot","title":"function maskbndGPUFluxbot","text":"<p>CUDA kernel for applying masked flux boundary conditions on the bottom side. </p><pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUFluxbot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Flux</code> Flux variables</li> </ul> <p>Applies flux boundary conditions in the halo region for masked blocks on the bottom side. </p>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpufluxbot-double","title":"function maskbndGPUFluxbot&lt; double &gt;","text":"<pre><code>template __global__ void maskbndGPUFluxbot&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    FluxP &lt; double &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpufluxbot-float","title":"function maskbndGPUFluxbot&lt; float &gt;","text":"<pre><code>template __global__ void maskbndGPUFluxbot&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    FluxP &lt; float &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpufluxleft","title":"function maskbndGPUFluxleft","text":"<p>CUDA kernel for applying masked flux boundary conditions on the left side. </p><pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUFluxleft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Xev</code> Evolving variables </li> <li><code>Flux</code> Flux variables</li> </ul> <p>Applies flux boundary conditions in the halo region for masked blocks on the left side. </p>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpufluxleft-double","title":"function maskbndGPUFluxleft&lt; double &gt;","text":"<pre><code>template __global__ void maskbndGPUFluxleft&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    FluxP &lt; double &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpufluxleft-float","title":"function maskbndGPUFluxleft&lt; float &gt;","text":"<pre><code>template __global__ void maskbndGPUFluxleft&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    FluxP &lt; float &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpufluxright","title":"function maskbndGPUFluxright","text":"<p>CUDA kernel for applying masked flux boundary conditions on the right side. </p><pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUFluxright (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Flux</code> Flux variables</li> </ul> <p>Applies flux boundary conditions in the halo region for masked blocks on the right side. </p>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpufluxright-double","title":"function maskbndGPUFluxright&lt; double &gt;","text":"<pre><code>template __global__ void maskbndGPUFluxright&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    FluxP &lt; double &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpufluxright-float","title":"function maskbndGPUFluxright&lt; float &gt;","text":"<pre><code>template __global__ void maskbndGPUFluxright&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    FluxP &lt; float &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpufluxtop","title":"function maskbndGPUFluxtop","text":"<p>CUDA kernel for applying masked flux boundary conditions on the top side. </p><pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUFluxtop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Flux</code> Flux variables</li> </ul> <p>Applies flux boundary conditions in the halo region for masked blocks on the top side. </p>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpufluxtop-double","title":"function maskbndGPUFluxtop&lt; double &gt;","text":"<pre><code>template __global__ void maskbndGPUFluxtop&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    FluxP &lt; double &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpufluxtop-float","title":"function maskbndGPUFluxtop&lt; float &gt;","text":"<pre><code>template __global__ void maskbndGPUFluxtop&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    FluxP &lt; float &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpubot","title":"function maskbndGPUbot","text":"<p>CUDA kernel for applying masked boundary conditions (halo walls) on the bottom side. </p><pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUbot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Xev</code> Evolving variables </li> <li><code>zb</code> Array of mask values</li> </ul> <p>Applies wall boundary conditions in the halo region for masked blocks on the bottom side. </p>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpubot-double","title":"function maskbndGPUbot&lt; double &gt;","text":"<pre><code>template __global__ void maskbndGPUbot&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpubot-float","title":"function maskbndGPUbot&lt; float &gt;","text":"<pre><code>template __global__ void maskbndGPUbot&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpuleft","title":"function maskbndGPUleft","text":"<p>CUDA kernel for applying masked boundary conditions (halo walls) on the left side. </p><pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUleft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Xev</code> Evolving variables </li> <li><code>zb</code> Array of mask values</li> </ul> <p>Applies wall boundary conditions in the halo region for masked blocks on the left side. </p>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpuleft-double","title":"function maskbndGPUleft&lt; double &gt;","text":"<pre><code>template __global__ void maskbndGPUleft&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpuleft-float","title":"function maskbndGPUleft&lt; float &gt;","text":"<pre><code>template __global__ void maskbndGPUleft&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpuright","title":"function maskbndGPUright","text":"<p>CUDA kernel for applying masked boundary conditions (halo walls) on the right side. </p><pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUright (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Xev</code> Evolving variables </li> <li><code>zb</code> Array of mask values</li> </ul> <p>Applies wall boundary conditions in the halo region for masked blocks on the right side. </p>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpuright-double","title":"function maskbndGPUright&lt; double &gt;","text":"<pre><code>template __global__ void maskbndGPUright&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgpuright-float","title":"function maskbndGPUright&lt; float &gt;","text":"<pre><code>template __global__ void maskbndGPUright&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgputop","title":"function maskbndGPUtop","text":"<p>CUDA kernel for applying masked boundary conditions (halo walls) on the top side. </p><pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUtop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Xev</code> Evolving variables </li> <li><code>zb</code> Array of mask values</li> </ul> <p>Applies wall boundary conditions in the halo region for masked blocks on the top side. </p>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgputop-double","title":"function maskbndGPUtop&lt; double &gt;","text":"<pre><code>template __global__ void maskbndGPUtop&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-maskbndgputop-float","title":"function maskbndGPUtop&lt; float &gt;","text":"<pre><code>template __global__ void maskbndGPUtop&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8cu/#function-noslipbnd","title":"function noslipbnd","text":"<p>Device/host function to apply no-slip boundary condition. </p><pre><code>template&lt;class T&gt;\n__device__ __host__ void noslipbnd (\n    T zsinside,\n    T hinside,\n    T &amp; un,\n    T &amp; ut,\n    T &amp; zs,\n    T &amp; h\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>zsinside</code> Inside zs value </li> <li><code>hinside</code> Inside h value </li> <li><code>un</code> Normal velocity (output) </li> <li><code>ut</code> Tangential velocity (output) </li> <li><code>zs</code> zs value (output) </li> <li><code>h</code> h value (output)</li> </ul> <p>Sets normal velocity to zero, copies zsinside and hinside. </p>"},{"location":"BGFlood/_boundary_8cu/#function-noslipbndq","title":"function noslipbndQ","text":"<p>Device/host function to apply no-slip boundary for flux variables. </p><pre><code>template&lt;class T&gt;\n__device__ __host__ void noslipbndQ (\n    T &amp; F,\n    T &amp; G,\n    T &amp; S\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>F</code> Flux F (output) </li> <li><code>G</code> Flux G (input) </li> <li><code>S</code> Source term (output)</li> </ul> <p>Sets F to zero, S to G. </p> <p>The documentation for this class was generated from the following file <code>src/Boundary.cu</code></p>"},{"location":"BGFlood/_boundary_8cu_source/","title":"File Boundary.cu","text":""},{"location":"BGFlood/_boundary_8cu_source/#file-boundarycu","title":"File Boundary.cu","text":"<p>File List &gt; src &gt; Boundary.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Boundary.h\"\n\n\ntemplate &lt;class T&gt; void Flowbnd(Param XParam, Loop&lt;T&gt; &amp;XLoop, BlockP&lt;T&gt; XBlock, bndparam side, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;T&gt; XEv)\n{\n    dim3 blockDim(XParam.blkwidth, 1, 1);\n    dim3 gridDimBBND(side.nblk, 1, 1);\n\n    T* un, * ut;\n\n    double itime=0.0;\n\n    std::vector&lt;double&gt; zsbndleft;\n    std::vector&lt;double&gt; uubndleft;\n    std::vector&lt;double&gt; vvbndleft;\n\n    if (side.isright == 0)\n    {\n        //top or bottom\n        un = XEv.v; //u normal to boundary\n        ut = XEv.u; //u tangent to boundary\n    }\n    else\n    {\n        un = XEv.u;\n        ut = XEv.v;\n    }\n\n    if (side.on)\n    {\n        int SLstepinbnd = 1;\n\n        double difft = side.data[SLstepinbnd].time - XLoop.totaltime;\n        while (difft &lt; 0.0)\n        {\n            SLstepinbnd++;\n            difft = side.data[SLstepinbnd].time - XLoop.totaltime;\n        }\n\n        itime = SLstepinbnd - 1.0 + (XLoop.totaltime - side.data[SLstepinbnd - 1].time) / (side.data[SLstepinbnd].time - side.data[SLstepinbnd - 1].time);\n\n\n        for (int n = 0; n &lt; side.data[SLstepinbnd].wlevs.size(); n++)\n        {\n            zsbndleft.push_back(interptime(side.data[SLstepinbnd].wlevs[n], side.data[SLstepinbnd - 1].wlevs[n], side.data[SLstepinbnd].time - side.data[SLstepinbnd - 1].time, XLoop.totaltime - side.data[SLstepinbnd - 1].time));\n\n        }\n        // Repeat for u and v only if needed (otherwise values may not exist!)\n        if (side.type == 4)\n        {\n            for (int n = 0; n &lt; side.data[SLstepinbnd].uuvel.size(); n++)\n            {\n                uubndleft.push_back(interptime(side.data[SLstepinbnd].uuvel[n], side.data[SLstepinbnd - 1].uuvel[n], side.data[SLstepinbnd].time - side.data[SLstepinbnd - 1].time, XLoop.totaltime - side.data[SLstepinbnd - 1].time));\n\n            }\n            for (int n = 0; n &lt; side.data[SLstepinbnd].vvvel.size(); n++)\n            {\n                vvbndleft.push_back(interptime(side.data[SLstepinbnd].vvvel[n], side.data[SLstepinbnd - 1].vvvel[n], side.data[SLstepinbnd].time - side.data[SLstepinbnd - 1].time, XLoop.totaltime - side.data[SLstepinbnd - 1].time));\n\n            }\n        }\n\n\n    }\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        bndGPU &lt;&lt;&lt; gridDimBBND, blockDim, 0 &gt;&gt;&gt; (XParam, side, XBlock, Atmp, T(itime), XEv.zs, XEv.h, un, ut);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else\n    {\n        bndCPU(XParam, side, XBlock, zsbndleft, uubndleft, vvbndleft, Atmp, XEv.zs, XEv.h, un, ut);\n    }\n\n\n\n}\ntemplate void Flowbnd&lt;float&gt;(Param XParam, Loop&lt;float&gt;&amp; XLoop, BlockP&lt;float&gt; XBlock, bndparam side, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;float&gt; XEv);\ntemplate void Flowbnd&lt;double&gt;(Param XParam, Loop&lt;double&gt;&amp; XLoop, BlockP&lt;double&gt; XBlock, bndparam side, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;double&gt; XEv);\n\ntemplate &lt;class T&gt; void FlowbndFlux(Param XParam, double totaltime, BlockP&lt;T&gt; XBlock, bndsegment bndseg, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;T&gt; XEv, FluxP&lt;T&gt; XFlux)\n{\n    dim3 blockDim(XParam.blkwidth, 1, 1);\n    dim3 gridDimBBNDLeft(bndseg.left.nblk, 1, 1);\n    dim3 gridDimBBNDRight(bndseg.right.nblk, 1, 1);\n    dim3 gridDimBBNDTop(bndseg.top.nblk, 1, 1);\n    dim3 gridDimBBNDBot(bndseg.bot.nblk, 1, 1);\n\n    double zsbnd = 0.0;\n    if (!std::isnan(XParam.zsinit)) // apply specified zsinit\n    {\n        zsbnd = XParam.zsinit;\n    }\n    // Warning this above is not ideal but sufficient for fail safe of testing if someone specifies initial conditions and no boundary for a type 3 they should be in trouble\n    T taper=T(1.0);\n    if (bndseg.on)\n    {\n        if (XParam.bndtaper &gt; 0.0)\n        {\n            taper = min((totaltime - XParam.inittime) / XParam.bndtaper, 1.0);\n        }\n\n        if (bndseg.uniform)\n        {\n            int SLstepinbnd = 1;\n\n            double difft = bndseg.data[SLstepinbnd].time - totaltime;\n            while (difft &lt; 0.0)\n            {\n                SLstepinbnd++;\n                difft = bndseg.data[SLstepinbnd].time - totaltime;\n            }\n\n            //itime = SLstepinbnd - 1.0 + (totaltime - bndseg.data[SLstepinbnd - 1].time) / (bndseg.data[SLstepinbnd].time - bndseg.data[SLstepinbnd - 1].time);\n            zsbnd = interptime(bndseg.data[SLstepinbnd].wspeed, bndseg.data[SLstepinbnd - 1].wspeed, bndseg.data[SLstepinbnd].time - bndseg.data[SLstepinbnd - 1].time, totaltime - bndseg.data[SLstepinbnd - 1].time);\n\n\n\n        }\n        else\n        {\n            // Nothing. it is already done in update forcing\n        }\n\n    }\n\n    if (bndseg.type != 1)\n    {\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            //if (bndseg.left.nblk &gt; 0)\n            {\n                //Left\n                //template &lt;class T&gt; __global__ void bndFluxGPUSide(Param XParam, bndsegmentside side, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Atmp, DynForcingP&lt;float&gt; Zsmap, bool uniform, float zsbnd, T * zs, T * h, T * un, T * ut, T * Fh, T * Fq, T * Ss)\n                //bndFluxGPUSide &lt;&lt;&lt; gridDimBBND, blockDim, 0 &gt;&gt;&gt; (XParam, bndseg.left, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), XEv.zs, XEv.h, un, ut, Fh, Fq, S);\n                bndFluxGPUSide &lt;&lt;&lt; gridDimBBNDLeft, blockDim, 0 &gt;&gt;&gt; (XParam, bndseg.left, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.u, XEv.v, XFlux.Fhu, XFlux.Fqux, XFlux.Su);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n            //if (bndseg.right.nblk &gt; 0)\n            {\n                //Right\n                bndFluxGPUSide &lt;&lt;&lt; gridDimBBNDRight, blockDim, 0 &gt;&gt;&gt; (XParam, bndseg.right, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.u, XEv.v, XFlux.Fhu, XFlux.Fqux, XFlux.Su);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n            //if (bndseg.top.nblk &gt; 0)\n            {\n                //top\n                bndFluxGPUSide &lt;&lt;&lt; gridDimBBNDTop, blockDim, 0 &gt;&gt;&gt; (XParam, bndseg.top, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.v, XEv.u, XFlux.Fhv, XFlux.Fqvy, XFlux.Sv);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n            //if (bndseg.bot.nblk &gt; 0)\n            {\n                //bot\n                bndFluxGPUSide &lt;&lt;&lt; gridDimBBNDBot, blockDim, 0 &gt;&gt;&gt; (XParam, bndseg.bot, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.v, XEv.u, XFlux.Fhv, XFlux.Fqvy, XFlux.Sv);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n        }\n        else\n        {\n            bndFluxGPUSideCPU(XParam, bndseg.left, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.u, XEv.v, XFlux.Fhu, XFlux.Fqux, XFlux.Su);\n            bndFluxGPUSideCPU(XParam, bndseg.right, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.u, XEv.v, XFlux.Fhu, XFlux.Fqux, XFlux.Su);\n            bndFluxGPUSideCPU(XParam, bndseg.top, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.v, XEv.u, XFlux.Fhv, XFlux.Fqvy, XFlux.Sv);\n            bndFluxGPUSideCPU(XParam, bndseg.bot, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.v, XEv.u, XFlux.Fhv, XFlux.Fqvy, XFlux.Sv);\n\n\n        }\n    }\n}\ntemplate void FlowbndFlux&lt;float&gt;(Param XParam,  double totaltime, BlockP&lt;float&gt; XBlock, bndsegment bndseg, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;float&gt; XEv, FluxP&lt;float&gt; XFlux);\ntemplate void FlowbndFlux&lt;double&gt;(Param XParam, double totaltime, BlockP&lt;double&gt; XBlock, bndsegment bndseg, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;double&gt; XEv, FluxP&lt;double&gt; XFlux);\n\ntemplate &lt;class T&gt; void FlowbndFluxML(Param XParam, double totaltime, BlockP&lt;T&gt; XBlock, bndsegment bndseg, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;T&gt; XEv, FluxMLP&lt;T&gt; XFlux)\n{\n    dim3 blockDim(XParam.blkwidth, 1, 1);\n    dim3 gridDimBBNDLeft(bndseg.left.nblk, 1, 1);\n    dim3 gridDimBBNDRight(bndseg.right.nblk, 1, 1);\n    dim3 gridDimBBNDTop(bndseg.top.nblk, 1, 1);\n    dim3 gridDimBBNDBot(bndseg.bot.nblk, 1, 1);\n\n    double zsbnd = 0.0;\n    if (!std::isnan(XParam.zsinit)) // apply specified zsinit\n    {\n        zsbnd = XParam.zsinit;\n    }\n    // Warning this above is not ideal but sufficient for fail safe of testing if someone specifies initial conditions and no boundary for a type 3 they should be in trouble\n    T taper = T(1.0);\n    if (bndseg.on)\n    {\n        if (bndseg.uniform)\n        {\n            int SLstepinbnd = 1;\n\n            double difft = bndseg.data[SLstepinbnd].time - totaltime;\n            while (difft &lt; 0.0)\n            {\n                SLstepinbnd++;\n                difft = bndseg.data[SLstepinbnd].time - totaltime;\n            }\n\n            //itime = SLstepinbnd - 1.0 + (totaltime - bndseg.data[SLstepinbnd - 1].time) / (bndseg.data[SLstepinbnd].time - bndseg.data[SLstepinbnd - 1].time);\n            zsbnd = interptime(bndseg.data[SLstepinbnd].wspeed, bndseg.data[SLstepinbnd - 1].wspeed, bndseg.data[SLstepinbnd].time - bndseg.data[SLstepinbnd - 1].time, totaltime - bndseg.data[SLstepinbnd - 1].time);\n\n\n            if (XParam.bndtaper &gt; 0.0)\n            {\n                taper = min(totaltime / XParam.bndtaper, 1.0);\n            }\n        }\n        else\n        {\n            // Nothing. it is already done in update forcing\n        }\n\n    }\n\n    if (bndseg.type != 1)\n    {\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            //if (bndseg.left.nblk &gt; 0)\n            {\n                //Left\n                bndFluxGPUSide &lt;&lt; &lt; gridDimBBNDLeft, blockDim, 0 &gt;&gt; &gt; (XParam, bndseg.left, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.u, XEv.v, XFlux.hu, XFlux.hfu, XFlux.hau);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n            //if (bndseg.right.nblk &gt; 0)\n            {\n                //Right\n                bndFluxGPUSide &lt;&lt; &lt; gridDimBBNDRight, blockDim, 0 &gt;&gt; &gt; (XParam, bndseg.right, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.u, XEv.v, XFlux.hu, XFlux.hfu, XFlux.hau);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n            //if (bndseg.top.nblk &gt; 0)\n            {\n                //top\n                bndFluxGPUSide &lt;&lt; &lt; gridDimBBNDTop, blockDim, 0 &gt;&gt; &gt; (XParam, bndseg.top, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.v, XEv.u, XFlux.hv, XFlux.hfv, XFlux.hav);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n            //if (bndseg.bot.nblk &gt; 0)\n            {\n                //bot\n                bndFluxGPUSide &lt;&lt; &lt; gridDimBBNDBot, blockDim, 0 &gt;&gt; &gt; (XParam, bndseg.bot, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.v, XEv.u, XFlux.hv, XFlux.hfv, XFlux.hfv);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n        }\n        else\n        {\n            //bndFluxGPUSideCPU(XParam, bndseg.left, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.u, XEv.v, XFlux.Fhu, XFlux.Fqux, XFlux.Su);\n            //bndFluxGPUSideCPU(XParam, bndseg.right, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.u, XEv.v, XFlux.Fhu, XFlux.Fqux, XFlux.Su);\n            //bndFluxGPUSideCPU(XParam, bndseg.top, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.v, XEv.u, XFlux.Fhv, XFlux.Fqvy, XFlux.Sv);\n            //bndFluxGPUSideCPU(XParam, bndseg.bot, XBlock, Atmp, bndseg.WLmap, bndseg.uniform, bndseg.type, float(zsbnd), taper, XEv.zs, XEv.h, XEv.v, XEv.u, XFlux.Fhv, XFlux.Fqvy, XFlux.Sv);\n\n\n        }\n    }\n}\ntemplate void FlowbndFluxML&lt;float&gt;(Param XParam, double totaltime, BlockP&lt;float&gt; XBlock, bndsegment bndseg, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;float&gt; XEv, FluxMLP&lt;float&gt; XFlux);\ntemplate void FlowbndFluxML&lt;double&gt;(Param XParam, double totaltime, BlockP&lt;double&gt; XBlock, bndsegment bndseg, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;double&gt; XEv, FluxMLP&lt;double&gt; XFlux);\n\ntemplate &lt;class T&gt; void FlowbndFluxold(Param XParam, double totaltime, BlockP&lt;T&gt; XBlock, bndparam side, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;T&gt; XEv, FluxP&lt;T&gt; XFlux)\n{\n    dim3 blockDim(XParam.blkwidth, 1, 1);\n    dim3 gridDimBBND(side.nblk, 1, 1);\n\n    T* un, * ut, * Fh, * Fq, * S;\n\n\n    double itime = 0.0;\n    if (side.on)\n    {\n        int SLstepinbnd = 1;\n\n        double difft = side.data[SLstepinbnd].time - totaltime;\n        while (difft &lt; 0.0)\n        {\n            SLstepinbnd++;\n            difft = side.data[SLstepinbnd].time - totaltime;\n        }\n\n        itime = SLstepinbnd - 1.0 + (totaltime - side.data[SLstepinbnd - 1].time) / (side.data[SLstepinbnd].time - side.data[SLstepinbnd - 1].time);\n\n    }\n\n\n    if (side.isright == 0)\n    {\n        //top or bottom\n        un = XEv.v; //u normal to boundary\n        ut = XEv.u; //u tangent to boundary\n    }\n    else\n    {\n        un = XEv.u;\n        ut = XEv.v;\n    }\n\n    if (side.isright == 0) // top or bottom\n    {\n        Fh = XFlux.Fhv;\n        Fq = XFlux.Fqvy;\n        S = XFlux.Sv;\n    }\n    else\n    {\n        Fh = XFlux.Fhu;\n        Fq = XFlux.Fqux;\n        S = XFlux.Su;\n    }\n\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        //bndFluxGPU &lt;&lt;&lt; gridDimBBND, blockDim, 0 &gt;&gt;&gt; (XParam, side, XBlock, Atmp, float(itime), XEv.zs, XEv.h, un, ut, Fh, Fq, S);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else\n    {\n        //bndFluxCPU(XParam, side, XBlock, zsbndleft, uubndleft, vvbndleft, Atmp, XEv.zs, XEv.h, un, ut);\n    }\n}\ntemplate void FlowbndFluxold&lt;float&gt;(Param XParam, double totaltime, BlockP&lt;float&gt; XBlock, bndparam side, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;float&gt; XEv, FluxP&lt;float&gt; XFlux);\ntemplate void FlowbndFluxold&lt;double&gt;(Param XParam, double totaltime, BlockP&lt;double&gt; XBlock, bndparam side, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;double&gt; XEv, FluxP&lt;double&gt; XFlux);\n\ntemplate &lt;class T&gt; __global__ void bndFluxGPUSide(Param XParam, bndsegmentside side, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Atmp, DynForcingP&lt;float&gt; Zsmap, bool uniform, int type, float zsbnd, T taper, T* zs, T* h, T* un, T* ut, T* Fh, T* Fq, T* Ss)\n{\n    //\n\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n\n    int ibl = blockIdx.x;\n    int ix, iy;\n\n\n    int iq = ibl * XParam.blkwidth + threadIdx.x;\n\n    int ib = side.blk_g[ibl];\n    int lev = XBlock.level[ib];\n\n\n    T delta = calcres(T(XParam.dx), lev);\n\n    if (side.isright == 0)\n    {\n        ix = threadIdx.x;\n        iy = side.istop &lt; 0 ? 0 : (blockDim.x);\n        //itx = (xx - XParam.xo) / (XParam.xmax - XParam.xo) * side.nbnd;\n    }\n    else\n    {\n        iy = threadIdx.x;\n        ix = side.isright &lt; 0 ? 0 : (blockDim.x);\n        //itx = (yy - XParam.yo) / (XParam.ymax - XParam.yo) * side.nbnd;\n    }\n\n    T sign = T(side.isright) + T(side.istop);\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n\n    T xx, yy;\n\n    xx = XBlock.xo[ib] + ix * delta;\n    yy = XBlock.yo[ib] + iy * delta;\n\n\n    T zsatm = T(0.0);\n\n    if (XParam.atmpforcing)\n    {\n        float atmpi;\n\n        atmpi = interpDyn2BUQ(XParam.xo + xx, XParam.yo + yy, Atmp.GPU);\n        zsatm = -1.0 * (atmpi - XParam.Paref) * XParam.Pa2m;\n    }\n    if (!uniform)\n    {\n\n\n        zsbnd = interpDyn2BUQ(XParam.xo + xx, XParam.yo + yy, Zsmap.GPU);\n    }\n\n\n\n    zsbnd = zsbnd + XParam.zsoffset;\n\n\n    int inside = Inside(halowidth, blkmemwidth, side.isright, side.istop, ix, iy, ib);\n\n    //T zsbnd;\n    T unbnd = T(0.0);\n    T utbnd = T(0.0);\n\n    T zsinside, hinside, uninside, utinside,zsi;\n    T F, G, S;\n    T qmean;\n\n    zsi = zs[i];\n    zsinside = zs[inside];\n    hinside = h[inside];\n    uninside = un[inside];\n    utinside = ut[inside];\n\n    T zsX = (zsbnd + zsatm - 0.5 * (zsi + zsinside)) * taper + 0.5 * (zsi + zsinside);\n\n    qmean = side.qmean_g[iq];\n\n\n    if (side.isright &lt; 0 || side.istop &lt; 0) //left or bottom\n    {\n        F = Fh[i];\n        G = Fq[i];\n        S = Ss[inside];\n    }\n    else\n    {\n        F = Fh[i];\n        G = Ss[i];\n        S = Fq[inside];\n    }\n\n    T factime = min(T(XParam.dt / XParam.bndfiltertime), T(1.0));\n    T facrel =  T(1.0) - min(T(XParam.dt / XParam.bndrelaxtime), T(1.0));\n\n\n\n\n    if (type == 0) // No Flux\n    {\n        //noslipbnd(zsinside, hinside, unnew, utnew, zsnew, hnew);\n        //noslipbndQ(F, G, S);\n\n\n        noslipbndQ(F, G, S);//noslipbndQ(T &amp; F, T &amp; G, T &amp; S) F = T(0.0); S = G;\n\n    }\n    else if (type == 2)\n    {\n        if (h[i] &gt; XParam.eps || zsX &gt; zsi)\n        {\n            //\n            Dirichlet1Q(T(XParam.g), sign, zsX, zsinside, hinside, uninside, F);\n        }\n        else\n        {\n            noslipbndQ(F, G, S);\n            qmean = T(0.0);\n        }\n    }\n    else if (type == 3)\n    {\n        if (h[i] &gt; XParam.eps || zsX &gt; zsi )\n        {\n            ABS1DQ(T(XParam.g), sign, factime, facrel, zsi, zsX, zsinside, h[i], qmean, F, G, S);\n            //qmean = T(0.0);\n        }\n        else\n        {\n            noslipbndQ(F, G, S);\n            qmean = T(0.0);\n        }\n        side.qmean_g[iq] = qmean;\n    }\n\n\n    // write the results\n\n    if (side.isright &lt; 0 || side.istop &lt; 0) // left or bottom\n    {\n        Fh[i]=F;\n        Fq[i]=G;\n        Ss[inside]=S;\n    }\n    else\n    {\n        Fh[i] = F;\n        Ss[i] = G;\n        Fq[inside] = S;\n    }\n\n\n\n\n\n\n\n}\n\n\ntemplate &lt;class T&gt; void bndFluxGPUSideCPU(Param XParam, bndsegmentside side, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Atmp, DynForcingP&lt;float&gt; Zsmap, bool uniform, int type, float zsbnd, T taper, T* zs, T* h, T* un, T* ut, T* Fh, T* Fq, T* Ss)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; side.nblk; ibl++)\n    {\n\n        int ib = side.blk[ibl];\n        int lev = XBlock.level[ib];\n\n        T delta = calcres(T(XParam.dx), lev);\n\n        for (int tx = 0; tx &lt; XParam.blkwidth; tx++)\n        {\n            int ix, iy;\n\n            T xx, yy;\n            if (side.isright == 0)\n            {\n                ix = tx;\n                iy = side.istop &lt; 0 ? 0 : (XParam.blkwidth);\n                //itx = (xx - XParam.xo) / (XParam.xmax - XParam.xo) * side.nbnd;\n            }\n            else\n            {\n                iy = tx;\n                ix = side.isright &lt; 0 ? 0 : (XParam.blkwidth);\n                //itx = (yy - XParam.yo) / (XParam.ymax - XParam.yo) * side.nbnd;\n            }\n            xx = XBlock.xo[ib] + ix * delta;\n            yy = XBlock.yo[ib] + iy * delta;\n\n            T sign = T(side.isright) + T(side.istop);\n            int iq = ibl * XParam.blkwidth + tx;\n\n\n            T zsatm = T(0.0);\n            T atmpi = T(0.0);\n\n            if (XParam.atmpforcing)\n            {\n                if (Atmp.uniform)\n                {\n                    atmpi = T(Atmp.nowvalue);\n                }\n                else\n                {\n                    atmpi = interp2BUQ(XParam.xo + xx, XParam.yo + yy, Atmp);\n                }\n                zsatm = -(atmpi - (T)XParam.Paref) * (T)XParam.Pa2m;\n            }\n            if (!uniform)\n            {\n\n\n                zsbnd = interp2BUQ(XParam.xo + xx, XParam.yo + yy, Zsmap);\n            }\n\n\n            zsbnd = zsbnd + XParam.zsoffset;\n\n\n            int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n            int inside = Inside(halowidth, blkmemwidth, side.isright, side.istop, ix, iy, ib);\n\n            //T zsbnd;\n            T unbnd = T(0.0);\n            T utbnd = T(0.0);\n\n            T zsinside, hinside, uninside, utinside, zsi;\n            T F, G, S;\n            T qmean;\n\n            zsi = zs[i];\n            zsinside = zs[inside];\n            hinside = h[inside];\n            uninside = un[inside];\n            utinside = ut[inside];\n\n            T zsX = (zsbnd + zsatm - 0.5 * (zsi + zsinside)) * taper + 0.5 * (zsi + zsinside);\n\n            qmean = side.qmean[iq];\n\n\n            if (side.isright &lt; 0 || side.istop &lt; 0) //left or bottom\n            {\n                F = Fh[i];\n                G = Fq[i];\n                S = Ss[inside];\n            }\n            else\n            {\n                F = Fh[i];\n                G = Ss[i];\n                S = Fq[inside];\n            }\n\n            T factime = min(T(XParam.dt / XParam.bndfiltertime), T(1.0));\n            T facrel = T(1.0) - min(T(XParam.dt / XParam.bndrelaxtime), T(1.0));\n            if (type == 0) // No Flux\n            {\n                //noslipbnd(zsinside, hinside, unnew, utnew, zsnew, hnew);\n                //noslipbndQ(F, G, S);\n\n\n                noslipbndQ(F, G, S);//noslipbndQ(T &amp; F, T &amp; G, T &amp; S) F = T(0.0); S = G;\n\n            }\n            else if (type == 3)\n            {\n                if (h[i] &gt; XParam.eps || zsX &gt; zsi)\n                {\n                    ABS1DQ(T(XParam.g), sign, factime, facrel, zsi, zsX, zsinside, h[i], qmean, F, G, S);\n                    //qmean = T(0.0);\n                }\n                else\n                {\n                    noslipbndQ(F, G, S);\n                    qmean = T(0.0);\n                }\n                side.qmean[iq] = qmean;\n            }\n            else if (type == 2)\n            {\n                if (h[i] &gt; XParam.eps || zsX &gt; zsi)\n                {\n                    //ABS1DQ(T(XParam.g), sign, factime, facrel, zsi, zsX, zsinside, h[i], qmean, F, G, S);\n                    //qmean = T(0.0);\n                    Dirichlet1Q(T(XParam.g), sign, zsX, zsinside, hinside, uninside, F);\n                }\n                else\n                {\n                    noslipbndQ(F, G, S);\n                    qmean = T(0.0);\n                }\n                side.qmean[iq] = qmean;\n            }\n\n\n            // write the results\n\n            if (side.isright &lt; 0 || side.istop &lt; 0) // left or bottom\n            {\n                Fh[i] = F;\n                Fq[i] = G;\n                Ss[inside] = S;\n            }\n            else\n            {\n                Fh[i] = F;\n                Ss[i] = G;\n                Fq[inside] = S;\n            }\n        }\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void bndGPU(Param XParam, bndparam side, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Atmp, float itime, T* zs, T* h, T* un, T* ut)\n{\n    //\n\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n\n    unsigned int ibl = blockIdx.x;\n    unsigned int ix, iy;\n    float itx;\n\n    int ib = side.blks_g[ibl];\n    int lev = XBlock.level[ib];\n\n\n    T delta = calcres(T(XParam.dx), lev);\n\n    if (side.isright == 0)\n    {\n        ix = threadIdx.x;\n        iy = side.istop &lt; 0 ? 0 : (blockDim.x - 1);\n        //itx = (xx - XParam.xo) / (XParam.xmax - XParam.xo) * side.nbnd;\n    }\n    else\n    {\n        iy = threadIdx.x;\n        ix = side.isright &lt; 0 ? 0 : (blockDim.x - 1);\n        //itx = (yy - XParam.yo) / (XParam.ymax - XParam.yo) * side.nbnd;\n    }\n\n    T sign = T(side.isright) + T(side.istop);\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n\n    T xx, yy;\n\n    xx = XBlock.xo[ib] + ix * delta;\n    yy = XBlock.yo[ib] + iy * delta;\n\n    if (side.isright == 0)\n    {\n        itx = (xx) / (XParam.xmax - XParam.xo) * side.nbnd;\n    }\n    else\n    {\n        itx = (yy) / (XParam.ymax - XParam.yo) * side.nbnd;\n    }\n\n    T zsatm = T(0.0);\n\n    if (XParam.atmpforcing)\n    {\n        float atmpi;\n\n        atmpi = interpDyn2BUQ(XParam.xo + xx, XParam.yo + yy, Atmp.GPU);\n        zsatm = -1.0 * (atmpi - XParam.Paref) * XParam.Pa2m;\n    }\n\n    int inside= Inside(halowidth, blkmemwidth, side.isright, side.istop, ix, iy, ib);\n\n    T unnew, utnew, hnew, zsnew;\n    T uninside, utinside, hinside, zsinside;\n    T zsbnd;\n    T unbnd = T(0.0);\n    T utbnd = T(0.0);\n\n    unnew = un[i];\n    utnew = ut[i];\n    hnew = h[i];\n    zsnew = zs[i];\n\n    zsinside = zs[inside];\n    hinside = h[inside];\n    uninside = un[inside];\n    utinside = ut[inside];\n\n    if (side.on)\n    {\n\n        zsbnd = tex2D&lt;float&gt;(side.GPU.WLS.tex, itime + 0.5f, itx + 0.5f) + zsatm;\n\n        if (side.type == 4)\n        {\n            //un is V (top or bot bnd) or U (left or right bnd) depending on which side it's dealing with (same for ut)\n            unbnd = side.isright == 0 ? tex2D&lt;float&gt;(side.GPU.Vvel.tex, itime + 0.5f, itx + 0.5f) : tex2D&lt;float&gt;(side.GPU.Uvel.tex, itime + 0.5f, itx + 0.5f);\n            utbnd = side.isright == 0 ? tex2D&lt;float&gt;(side.GPU.Uvel.tex, itime + 0.5f, itx + 0.5f) : tex2D&lt;float&gt;(side.GPU.Vvel.tex, itime + 0.5f, itx + 0.5f);\n\n        }\n\n    }\n\n    if (side.type == 0) // No slip == no friction wall\n    {\n        //noslipbnd(zsinside, hinside, unnew, utnew, zsnew, hnew);\n    }\n    else if (side.type == 1) // neumann type\n    {\n        // Nothing to do here?\n    }\n    else if (side.type == 2)\n    {\n        Dirichlet1D(T(XParam.g), sign, zsbnd, zsinside, hinside, uninside, unnew, utnew, zsnew, hnew);\n    }\n    else if (side.type == 3 )\n    {\n        if (hnew &gt; XParam.eps &amp;&amp; hinside &gt; XParam.eps)\n        {\n            //ABS1D(T(XParam.g), sign, zsbnd, zsinside, hinside, utinside, unbnd, unnew, utnew, zsnew, hnew);\n            //printf(\"No boundary!\\n\");\n        }\n    }\n    else if (side.type == 4)\n    {\n\n        ABS1D(T(XParam.g), sign, zsbnd, zsinside, hinside, utbnd, unbnd, unnew, utnew, zsnew, hnew);\n    }\n\n    un[i] = unnew;\n    ut[i] = utnew;\n    h[i] = hnew;\n    zs[i] = zsnew;\n}\ntemplate __global__ void bndGPU&lt;float&gt;(Param XParam, bndparam side, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; Atmp, float itime, float* zs, float* h, float* un, float* ut);\ntemplate __global__ void bndGPU&lt;double&gt;(Param XParam, bndparam side, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; Atmp, float itime, double* zs, double* h, double* un, double* ut);\n\ntemplate &lt;class T&gt; __host__ void bndCPU(Param XParam, bndparam side, BlockP&lt;T&gt; XBlock, std::vector&lt;double&gt; zsbndvec, std::vector&lt;double&gt; uubndvec, std::vector&lt;double&gt; vvbndvec, DynForcingP&lt;float&gt; Atmp, T* zs, T* h, T* un, T* ut)\n{\n    //\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; side.nblk; ibl++)\n    {\n\n        int ib = side.blks[ibl];\n        int lev = XBlock.level[ib];\n        int nbnd = side.nbnd;\n        T delta = calcres(T(XParam.dx), lev);\n\n        for (int tx = 0; tx &lt; XParam.blkwidth; tx++)\n        {\n            unsigned int ix, iy;\n            double itx;\n            T xx, yy;\n            if (side.isright == 0)\n            {\n                ix = tx;\n                iy = side.istop &lt; 0 ? 0 : (XParam.blkwidth - 1);\n                //itx = (xx - XParam.xo) / (XParam.xmax - XParam.xo) * side.nbnd;\n            }\n            else\n            {\n                iy = tx;\n                ix = side.isright &lt; 0 ? 0 : (XParam.blkwidth - 1);\n                //itx = (yy - XParam.yo) / (XParam.ymax - XParam.yo) * side.nbnd;\n            }\n            xx = XBlock.xo[ib] + ix * delta;\n            yy = XBlock.yo[ib] + iy * delta;\n\n            T sign = T(side.isright) + T(side.istop);\n\n            if (side.isright == 0)\n            {\n                itx = (xx) / (XParam.xmax - XParam.xo) * side.nbnd;\n            }\n            else\n            {\n                itx = (yy) / (XParam.ymax - XParam.yo) * side.nbnd;\n            }\n\n            T zsatm = T(0.0);\n            T atmpi = T(0.0);\n\n            if (XParam.atmpforcing)\n            {\n                if (Atmp.uniform)\n                {\n                    atmpi = T(Atmp.nowvalue);\n                }\n                else\n                {\n                    atmpi = interp2BUQ(XParam.xo + xx, XParam.yo + yy, Atmp);\n                }\n                zsatm = -(atmpi - (T)XParam.Paref) * (T)XParam.Pa2m;\n            }\n\n\n            int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n            int inside = Inside(halowidth, blkmemwidth, side.isright, side.istop, ix, iy, ib);\n\n            T unnew, utnew, hnew, zsnew;\n            T uninside, utinside, hinside, zsinside;\n            T zsbnd;\n            T unbnd = T(0.0);\n            T utbnd = T(0.0);\n\n            unnew = un[i];\n            utnew = ut[i];\n            hnew = h[i];\n            zsnew = zs[i];\n\n            zsinside = zs[inside];\n            hinside = h[inside];\n            uninside = un[inside];\n            utinside = ut[inside];\n\n            if (side.on)\n            {\n                int iprev = utils::max(int(floor(itx * (side.nbnd - 1))), 0);//min(max((int)ceil(itx / (1 / (side.nbnd - 1))), 0), (int)side.nbnd() - 2);\n                int inext = iprev + 1;\n\n                if (side.nbnd == 1)\n                {\n                    zsbnd = zsbndvec[0] + zsatm;\n                    if (side.type == 4)\n                    {\n                        unbnd = side.isright == 0 ? vvbndvec[0] : uubndvec[0];\n                        utbnd = side.isright == 0 ? uubndvec[0] : vvbndvec[0];\n                    }\n                }\n                else\n                {\n\n                    // here interp time is used to interpolate to the right node rather than in time...//\n                    zsbnd = T(interptime(zsbndvec[inext], zsbndvec[iprev], 1.0, itx * (nbnd - 1) - iprev)) + zsatm;\n\n                    if (side.type == 4)\n                    {\n                        unbnd = side.isright == 0 ? T(interptime(vvbndvec[inext], vvbndvec[iprev], 1.0, itx * (nbnd - 1) - iprev)) : T(interptime(uubndvec[inext], uubndvec[iprev], 1.0, itx * (nbnd - 1) - iprev));\n                        utbnd = side.isright == 0 ? T(interptime(uubndvec[inext], uubndvec[iprev], 1.0, itx * (nbnd - 1) - iprev)) : T(interptime(vvbndvec[inext], vvbndvec[iprev], 1.0, itx * (nbnd - 1) - iprev));\n                    }\n                }\n\n\n\n            }\n\n            if (side.type == 0) // No slip == no friction wall\n            {\n                noslipbnd(zsinside, hinside, unnew, utnew, zsnew, hnew);\n            }\n            else if (side.type == 1) // neumann type\n            {\n                // Nothing to do here?\n            }\n            else if (side.type == 2)\n            {\n                Dirichlet1D(T(XParam.g), sign, zsbnd, zsinside, hinside, uninside, unnew, utnew, zsnew, hnew);\n\n            }\n            else if (side.type == 3)\n            {\n                if (hnew &gt; XParam.eps &amp;&amp; hinside &gt; XParam.eps)\n                {\n                    ABS1D(T(XParam.g), sign, zsbnd, zsinside, hinside, utinside, unbnd, unnew, utnew, zsnew, hnew);\n                }\n            }\n            else if (side.type == 4)\n            {\n\n                ABS1D(T(XParam.g), sign, zsbnd, zsinside, hinside, utbnd, unbnd, unnew, utnew, zsnew, hnew);\n            }\n\n            un[i] = unnew;\n            ut[i] = utnew;\n            h[i] = hnew;\n            zs[i] = zsnew;\n        }\n    }\n}\ntemplate __host__ void bndCPU&lt;float&gt;(Param XParam, bndparam side, BlockP&lt;float&gt; XBlock, std::vector&lt;double&gt; zsbndvec, std::vector&lt;double&gt; uubndvec, std::vector&lt;double&gt; vvbndvec, DynForcingP&lt;float&gt; Atmp, float* zs, float* h, float* un, float* ut);\ntemplate __host__ void bndCPU&lt;double&gt;(Param XParam, bndparam side, BlockP&lt;double&gt; XBlock, std::vector&lt;double&gt; zsbndvec, std::vector&lt;double&gt; uubndvec, std::vector&lt;double&gt; vvbndvec, DynForcingP&lt;float&gt; Atmp, double* zs, double* h, double* un, double* ut);\n\n\n// function to apply bnd at the boundary with masked blocked\n// here a wall is applied in the halo \ntemplate &lt;class T&gt; __host__ void maskbnd(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T*zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int isright,istop;\n\n    T zsinside,zsnew,hnew,vnew,unew,zbnew;\n\n    bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n\n    for (int ibl = 0; ibl &lt;XBlock.mask.nblk ; ibl++)\n    {\n\n        int ib = XBlock.mask.blks[ibl];\n        int lev = XBlock.level[ib];\n        T delta = calcres(T(XParam.dx), lev);\n\n        // find where the mask applies\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        //leftside\n        if (isleftbot | islefttop )//?\n        {\n            isright = -1;\n            istop = 0;\n\n            int ix = -1;\n\n            int yst = isleftbot ? 0 : ftoi(XParam.blkwidth * 0.5);\n            int ynd = islefttop ? XParam.blkwidth : ftoi(XParam.blkwidth * 0.5);\n\n            for (int iy = yst; iy &lt; ynd; iy++)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n                zsinside = Xev.zs[inside];\n                unew = Xev.u[i];\n                vnew = Xev.v[i];\n                zsnew = Xev.zs[i];\n                hnew = Xev.h[i];\n                zbnew = zb[i];\n\n                halowall(zsinside, unew, vnew, zsnew, hnew, zbnew);\n\n                Xev.u[i]=unew;\n                Xev.v[i]=vnew;\n                Xev.zs[i]=zsnew;\n                Xev.h[i]=hnew;\n                zb[i]=zbnew;\n\n            }\n\n        }\n        //topside\n        if (istopleft | istopright)//?\n        {\n            isright = 0;\n            istop = 1;\n\n            int iy = XParam.blkwidth;\n\n            int xst = istopleft ? 0 : ftoi(XParam.blkwidth * 0.5);\n            int xnd = istopright ? XParam.blkwidth : ftoi(XParam.blkwidth * 0.5);\n\n            for (int ix = xst; ix &lt; xnd; ix++)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n                zsinside = Xev.zs[inside];\n                unew = Xev.u[i];\n                vnew = Xev.v[i];\n                zsnew = Xev.zs[i];\n                hnew = Xev.h[i];\n                zbnew = zb[i];\n\n                halowall(zsinside, unew, vnew, zsnew, hnew, zbnew);\n\n                Xev.u[i] = unew;\n                Xev.v[i] = vnew;\n                Xev.zs[i] = zsnew;\n                Xev.h[i] = hnew;\n                zb[i] = zbnew;\n\n            }\n\n        }\n        //rightside\n        if (isrighttop | isrightbot)//?\n        {\n            isright = 1;\n            istop = 0;\n\n            int ix = XParam.blkwidth;\n\n            int yst = isrightbot ? 0 : ftoi(XParam.blkwidth * 0.5);\n            int ynd = isrighttop ? XParam.blkwidth : ftoi(XParam.blkwidth * 0.5);\n\n            for (int iy = yst; iy &lt; ynd; iy++)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n                zsinside = Xev.zs[inside];\n                unew = Xev.u[i];\n                vnew = Xev.v[i];\n                zsnew = Xev.zs[i];\n                hnew = Xev.h[i];\n                zbnew = zb[i];\n\n                halowall(zsinside, unew, vnew, zsnew, hnew, zbnew);\n\n                Xev.u[i] = unew;\n                Xev.v[i] = vnew;\n                Xev.zs[i] = zsnew;\n                Xev.h[i] = hnew;\n                zb[i] = zbnew;\n\n            }\n\n        }\n\n        //botside\n        if (isbotright | isbotleft)//?\n        {\n            isright = 0;\n            istop = -1;\n\n            int iy = -1;\n\n            int xst = isbotleft ? 0 : ftoi(XParam.blkwidth * 0.5);\n            int xnd = isbotright ? XParam.blkwidth :ftoi( XParam.blkwidth * 0.5);\n\n            for (int ix = xst; ix &lt; xnd; ix++)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n                zsinside = Xev.zs[inside];\n                unew = Xev.u[i];\n                vnew = Xev.v[i];\n                zsnew = Xev.zs[i];\n                hnew = Xev.h[i];\n                zbnew = zb[i];\n\n                halowall(zsinside, unew, vnew, zsnew, hnew, zbnew);\n\n                Xev.u[i] = unew;\n                Xev.v[i] = vnew;\n                Xev.zs[i] = zsnew;\n                Xev.h[i] = hnew;\n                zb[i] = zbnew;\n\n            }\n\n        }\n\n\n\n    }\n}\ntemplate __host__ void maskbnd&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float* zb);\ntemplate __host__ void maskbnd&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, double* zb);\n\n//For the GPU version we apply 4 separate global function in the hope to increase occupancy\ntemplate &lt;class T&gt; __global__ void maskbndGPUleft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ibl = blockIdx.x;\n    if (ibl &lt; XBlock.mask.nblk)\n    {\n        int ix, iy;\n\n        int isright, istop;\n\n        T zsinside, zsnew, hnew, vnew, unew, zbnew;\n        T hinside;\n\n        bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n        int ib = XBlock.mask.blks[ibl];\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        //leftside\n        if (isleftbot | islefttop)//?\n        {\n            isright = -1;\n            istop = 0;\n\n            ix = -1;\n            iy = threadIdx.x;\n            int yst = isleftbot ? 0 : XParam.blkwidth * 0.5;\n            int ynd = islefttop ? XParam.blkwidth : XParam.blkwidth * 0.5;\n\n            if (iy &gt;= yst &amp;&amp; iy &lt; ynd)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n\n                zsinside = Xev.zs[inside];\n                hinside = Xev.h[inside];\n\n                unew = Xev.u[i];\n                vnew = Xev.v[i];\n                zsnew = Xev.zs[i];\n                hnew = Xev.h[i];\n                zbnew = zb[i];\n\n\n                //halowall(zsinside, unew, vnew, zsnew, hnew, zbnew);\n                //noslipbnd(zsinside, hinside, unew, vnew, zsnew, hnew);\n\n\n                Xev.u[i] = unew;\n                Xev.v[i] = vnew;\n                Xev.zs[i] = zsnew;\n                Xev.h[i] = hnew;\n                zb[i] = zbnew;\n\n\n            }\n\n        }\n    }\n\n}\ntemplate __global__ void maskbndGPUleft&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float* zb);\ntemplate __global__ void maskbndGPUleft&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, double* zb);\n\n\ntemplate &lt;class T&gt; __global__ void maskbndGPUFluxleft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, FluxP&lt;T&gt; Flux)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ibl = blockIdx.x;\n    if (ibl &lt; XBlock.mask.nblk)\n    {\n        int ix, iy;\n\n        int isright, istop;\n\n        //T zsinside, zsnew, hnew, vnew, unew, zbnew;\n        //T hinside;\n\n        bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n        int ib = XBlock.mask.blks[ibl];\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        //leftside\n        if (isleftbot | islefttop)//?\n        {\n            isright = -1;\n            istop = 0;\n\n            ix = -1;\n            iy = threadIdx.x;\n            int yst = isleftbot ? 0 : XParam.blkwidth * 0.5;\n            int ynd = islefttop ? XParam.blkwidth : XParam.blkwidth * 0.5;\n\n            if (iy &gt;= yst &amp;&amp; iy &lt; ynd)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n                T zsinside = Xev.zs[inside];\n                T zsi = Xev.zs[i];\n                T hinside = Xev.h[i];\n\n                T zsbnd = T(0.0);\n                T qmean = T(0.0);\n                T factime = min(T(XParam.dt / 60.0), T(1.0));\n                T facrel = T(1.0) - min(T(XParam.dt / 3600.0), T(1.0));\n                if (XParam.aoibnd == 0)\n                {\n                    noslipbndQ(Flux.Fhu[inside], Flux.Fqux[i], Flux.Su[inside]); //noslipbndQ(T &amp; F, T &amp; G, T &amp; S) F = T(0.0); S = G;\n                }\n                //ABS1DQ(T g, T sign, T factime, T facrel, T zs, T zsbnd, T zsinside, T h, T &amp; qmean, T &amp; q, T &amp; G, T &amp; S)\n                //ABS1DQ(T g, T sign, T factime, T facrel, T zs, T zsbnd, T zsinside, T h, T &amp; qmean, T &amp; q, T &amp; G, T &amp; S)\n                if (XParam.aoibnd == 3)\n                {\n                    if (hinside &gt; XParam.eps)\n                    {\n                        ABS1DQ(T(XParam.g), T(-1.0), factime, facrel, zsi, zsbnd, zsinside, hinside, qmean, Flux.Fhu[inside], Flux.Fqux[i], Flux.Su[inside]);\n                    }\n                    else\n                    {\n                        noslipbndQ(Flux.Fhu[inside], Flux.Fqux[i], Flux.Su[inside]);\n                    }\n                }\n\n\n\n            }\n\n        }\n    }\n\n}\ntemplate __global__ void maskbndGPUFluxleft&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, FluxP&lt;float&gt; Flux);\ntemplate __global__ void maskbndGPUFluxleft&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, FluxP&lt;double&gt; Flux);\n\n\ntemplate &lt;class T&gt; __global__ void maskbndGPUtop(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ibl = blockIdx.x;\n    if (ibl &lt; XBlock.mask.nblk)\n    {\n        int ix, iy;\n\n        int isright, istop;\n\n        T zsinside, zsnew, hnew, vnew, unew, zbnew;\n        T hinside;\n        bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n        int ib = XBlock.mask.blks[ibl];\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        if (istopleft | istopright)//?\n        {\n            isright = 0;\n            istop = 1;\n\n            iy = XParam.blkwidth;\n            ix = threadIdx.x;\n\n            int xst = istopleft ? 0 : XParam.blkwidth * 0.5;\n            int xnd = istopright ? XParam.blkwidth : XParam.blkwidth * 0.5;\n\n            if (ix &gt;= xst &amp;&amp; ix &lt; xnd)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n\n                zsinside = Xev.zs[inside];\n                hinside = Xev.h[inside];\n                unew = Xev.u[i];\n                vnew = Xev.v[i];\n                zsnew = Xev.zs[i];\n                hnew = Xev.h[i];\n                zbnew = zb[i];\n\n                //halowall(zsinside, unew, vnew, zsnew, hnew, zbnew);\n                //noslipbnd(zsinside, hinside, vnew, unew, zsnew, hnew);\n\n                Xev.u[i] = unew;\n                Xev.v[i] = vnew;\n                Xev.zs[i] = zsnew;\n                Xev.h[i] = hnew;\n                zb[i] = zbnew;\n\n\n            }\n        }\n    }\n}\ntemplate __global__ void maskbndGPUtop&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float* zb);\ntemplate __global__ void maskbndGPUtop&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, double* zb);\n\ntemplate &lt;class T&gt; __global__ void maskbndGPUFluxtop(Param XParam, BlockP&lt;T&gt; XBlock,  FluxP&lt;T&gt; Flux)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ibl = blockIdx.x;\n    if (ibl &lt; XBlock.mask.nblk)\n    {\n        int ix, iy;\n\n        int isright, istop;\n\n        T hinside;\n        bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n        int ib = XBlock.mask.blks[ibl];\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        if (istopleft | istopright)//?\n        {\n            isright = 0;\n            istop = 1;\n\n            iy = XParam.blkwidth;\n            ix = threadIdx.x;\n\n            int xst = istopleft ? 0 : XParam.blkwidth * 0.5;\n            int xnd = istopright ? XParam.blkwidth : XParam.blkwidth * 0.5;\n\n            if (ix &gt;= xst &amp;&amp; ix &lt; xnd)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n\n                noslipbndQ(Flux.Fhv[i], Flux.Sv[i], Flux.Fqvy[inside]); //noslipbndQ(T &amp; F, T &amp; G, T &amp; S) F = T(0.0); S = G;\n\n\n\n            }\n        }\n    }\n}\ntemplate __global__ void maskbndGPUFluxtop&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, FluxP&lt;float&gt; Flux);\ntemplate __global__ void maskbndGPUFluxtop&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, FluxP&lt;double&gt; Flux);\n\ntemplate &lt;class T&gt; __global__ void maskbndGPUright(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ibl = blockIdx.x;\n    if (ibl &lt; XBlock.mask.nblk)\n    {\n        int ix, iy;\n\n        int isright, istop;\n\n        T zsinside, zsnew, hnew, vnew, unew, zbnew;\n        T hinside;\n        bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n        int ib = XBlock.mask.blks[ibl];\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        if (isrighttop | isrightbot)//?\n        {\n            isright = 1;\n            istop = 0;\n\n            ix = XParam.blkwidth;\n\n            iy = threadIdx.x;\n\n            int yst = isrightbot ? 0 : XParam.blkwidth * 0.5;\n            int ynd = isrighttop ? XParam.blkwidth : XParam.blkwidth * 0.5;\n\n            if (iy &gt;= yst &amp;&amp; iy &lt; ynd)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n\n                zsinside = Xev.zs[inside];\n                hinside = Xev.h[inside];\n                unew = Xev.u[i];\n                vnew = Xev.v[i];\n                zsnew = Xev.zs[i];\n                hnew = Xev.h[i];\n                zbnew = zb[i];\n\n                //halowall(zsinside, unew, vnew, zsnew, hnew, zbnew);\n                //noslipbnd(zsinside, hinside, unew, vnew, zsnew, hnew);\n\n                Xev.u[i] = unew;\n                Xev.v[i] = vnew;\n                Xev.zs[i] = zsnew;\n                Xev.h[i] = hnew;\n                zb[i] = zbnew;\n\n\n            }\n        }\n    }\n}\ntemplate __global__ void maskbndGPUright&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float* zb);\ntemplate __global__ void maskbndGPUright&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, double* zb);\n\n\ntemplate &lt;class T&gt; __global__ void maskbndGPUFluxright(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ibl = blockIdx.x;\n    if (ibl &lt; XBlock.mask.nblk)\n    {\n        int ix, iy;\n\n        int isright, istop;\n\n        //T zsinside, zsnew, hnew, vnew, unew, zbnew;\n        //T hinside;\n        bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n        int ib = XBlock.mask.blks[ibl];\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        if (isrighttop | isrightbot)//?\n        {\n            isright = 1;\n            istop = 0;\n\n            ix = XParam.blkwidth;\n\n            iy = threadIdx.x;\n\n            int yst = isrightbot ? 0 : XParam.blkwidth * 0.5;\n            int ynd = isrighttop ? XParam.blkwidth : XParam.blkwidth * 0.5;\n\n            if (iy &gt;= yst &amp;&amp; iy &lt; ynd)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n\n                noslipbndQ(Flux.Fhu[i], Flux.Su[i], Flux.Fqux[inside]); //noslipbndQ(T &amp; F, T &amp; G, T &amp; S) F = T(0.0); S = G;\n\n\n\n            }\n        }\n    }\n}\ntemplate __global__ void maskbndGPUFluxright&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, FluxP&lt;float&gt; Flux);\ntemplate __global__ void maskbndGPUFluxright&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, FluxP&lt;double&gt; Flux);\n\ntemplate &lt;class T&gt; __global__ void maskbndGPUbot(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ibl = blockIdx.x;\n    if (ibl &lt; XBlock.mask.nblk)\n    {\n        int ix, iy;\n\n        int isright, istop;\n\n        T zsinside, zsnew, hnew, vnew, unew, zbnew;\n        T hinside;\n        bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n        int ib = XBlock.mask.blks[ibl];\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        if (isbotright | isbotleft)//?\n        {\n            isright = 0;\n            istop = -1;\n\n\n            iy = -1;\n            ix = threadIdx.x;\n            int xst = isbotleft ? 0 : XParam.blkwidth * 0.5;\n            int xnd = isbotright ? XParam.blkwidth : XParam.blkwidth * 0.5;\n\n\n            if (ix &gt;= xst &amp;&amp; ix &lt; xnd)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n\n                zsinside = Xev.zs[inside];\n                hinside = Xev.h[inside];\n\n                unew = Xev.u[i];\n                vnew = Xev.v[i];\n                zsnew = Xev.zs[i];\n                hnew = Xev.h[i];\n                zbnew = zb[i];\n\n                //halowall(zsinside, unew, vnew, zsnew, hnew, zbnew);\n                //noslipbnd(zsinside, hinside, vnew, unew, zsnew, hnew);\n\n                Xev.u[i] = unew;\n                Xev.v[i] = vnew;\n                Xev.zs[i] = zsnew;\n                Xev.h[i] = hnew;\n                zb[i] = zbnew;\n\n            }\n\n        }\n    }\n}\ntemplate __global__ void maskbndGPUbot&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float* zb);\ntemplate __global__ void maskbndGPUbot&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, double* zb);\n\ntemplate &lt;class T&gt; __global__ void maskbndGPUFluxbot(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ibl = blockIdx.x;\n    if (ibl &lt; XBlock.mask.nblk)\n    {\n        int ix, iy;\n\n        int isright, istop;\n\n        T zsinside, zsnew, hnew, vnew, unew, zbnew;\n        T hinside;\n        bool isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft;\n\n        int ib = XBlock.mask.blks[ibl];\n        //\n        findmaskside(XBlock.mask.side[ibl], isleftbot, islefttop, istopleft, istopright, isrighttop, isrightbot, isbotright, isbotleft);\n\n        if (isbotright | isbotleft)//?\n        {\n            isright = 0;\n            istop = -1;\n\n\n            iy = 0;\n            ix = threadIdx.x;\n            int xst = isbotleft ? 0 : XParam.blkwidth * 0.5;\n            int xnd = isbotright ? XParam.blkwidth : XParam.blkwidth * 0.5;\n\n\n            if (ix &gt;= xst &amp;&amp; ix &lt; xnd)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int inside = Inside(halowidth, blkmemwidth, isright, istop, ix, iy, ib);\n\n                noslipbndQ(Flux.Fhv[inside], Flux.Fqvy[i], Flux.Sv[inside]); //noslipbndQ(T &amp; F, T &amp; G, T &amp; S) F = T(0.0); S = G;\n\n            }\n\n        }\n    }\n}\ntemplate __global__ void maskbndGPUFluxbot&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, FluxP&lt;float&gt; Flux);\ntemplate __global__ void maskbndGPUFluxbot&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, FluxP&lt;double&gt; Flux);\n\n__device__ __host__ void findmaskside(int side, bool &amp;isleftbot, bool&amp; islefttop, bool&amp; istopleft, bool&amp; istopright, bool&amp; isrighttop, bool&amp; isrightbot, bool&amp; isbotright, bool&amp; isbotleft)\n{\n    int lb = 0b10000000;\n    int lt = 0b01000000;\n    int tl = 0b00100000;\n    int tr = 0b00010000;\n    int rt = 0b00001000;\n    int rb = 0b00000100;\n    int br = 0b00000010;\n    int bl = 0b00000001;\n\n    isleftbot = (side &amp; lb) == lb;\n    islefttop = (side &amp; lt) == lt;\n\n    istopleft = (side &amp; tl) == tl;\n    istopright = (side &amp; tr) == tr;\n\n    isrighttop = (side &amp; rt) == rt;\n    isrightbot = (side &amp; rb) == rb;\n\n    isbotright = (side &amp; br) == br;\n    isbotleft = (side &amp; bl) == bl;\n}\n\n\ntemplate &lt;class T&gt; __device__ __host__ void halowall(T zsinside, T&amp; un, T&amp; ut, T&amp; zs, T&amp; h,T&amp;zb)\n{\n    // This function is used to make a wall on the halo to act as a wall\n    // It may be more suitable/stable than the noslip as a wall boundary\n    un = T(0.0);\n    zs = zsinside;\n    ut = T(0.0);\n    h = T(0.0);\n    zb = zsinside;\n\n}\n\n\ntemplate &lt;class T&gt; __device__ __host__ void noslipbnd(T zsinside,T hinside,T &amp;un, T &amp;ut,T &amp;zs, T &amp;h)\n{\n    // Basic no slip bnd hs no normal velocity and leaves tanegtial velocity alone (maybe needs a wall friction added to it?)\n    // \n    un = T(0.0);\n    zs = zsinside;\n    //ut[i] = ut[inside];//=0.0?\n    h = hinside;//=0.0?\n\n}\n\ntemplate &lt;class T&gt; __device__ __host__ void noslipbndQ(T&amp; F, T&amp; G, T&amp; S)\n{\n    // Basic no slip bnd hs no normal velocity and leaves tanegtial velocity alone (maybe needs a wall friction added to it?)\n    // \n    F = T(0.0);\n    S = G;\n\n}\n\n\ntemplate &lt;class T&gt; __device__ __host__ void ABS1D(T g, T sign, T zsbnd, T zsinside, T hinside, T utbnd,T unbnd, T&amp; un, T&amp; ut, T&amp; zs, T&amp; h)\n{\n    //Absorbing 1D boundary\n    //When nesting unbnd is read from file. when unbnd is not known assume 0. or the mean of un over a certain time \n    // For utbnd use utinside if no utbnd are known \n    un= sign * sqrt(g / h) * (zsinside - zsbnd) + T(unbnd);\n    zs = zsinside;\n    ut = T(utbnd);//ut[inside];\n    h = hinside;\n}\n\ntemplate &lt;class T&gt; __device__ __host__ void ABS1DQ(T g, T sign, T factime,T facrel,T zs, T zsbnd, T zsinside, T h, T&amp; qmean, T&amp; q, T&amp; G, T&amp; S)\n{\n    //Absorbing 1D boundary\n    //When nesting unbnd is read from file. when unbnd is not known assume 0. or the mean of un over a certain time \n    // For utbnd use utinside if no utbnd are known \n\n\n\n    qmean = h &lt; T(0.01) ? T(0.0) : factime* q + facrel * (T(1.0) - factime) * qmean;\n    //qmean = factime * q + facrel * (T(1.0) - factime) * qmean;\n\n    T un;\n    T zn = max(zsbnd, (zs - h));\n\n    T hn = max(h, T(0.0001));\n\n\n    // Below should be hinside ? or h at Flux bnd?\n    // What if h is 0? then q and qmean should be 0\n    //un = sign * sqrt(g / h) * (T(2.0)*(zs - zsbnd) - (zsinside - zsbnd));\n    //un = sign* sqrt(g / h)* (T(2.0) * zs - zsinside - zsbnd);\n    un = sign * sqrt(g / hn) * (zs-zn);\n    //un = sign* sqrt(g / h)* (zs + zsinside - T(2.0) * zsbnd);\n    //zs = zsinside;\n    //zs = zsinside;\n    //ut = T(utbnd);//ut[inside];\n    //h = hinside;\n\n    q = un * hn + qmean;\n\n    //S = G;\n    //G = S-q;\n\n\n}\n\ntemplate &lt;class T&gt; __device__ __host__ void Dirichlet1D(T g, T sign, T zsbnd, T zsinside, T hinside,  T uninside, T&amp; un, T&amp; ut, T&amp; zs, T&amp; h)\n{\n    // Is this even the right formulation?.\n    // I don't really like this formulation. while a bit less dissipative then abs1D with 0 unbnd (but worse if forcing uniside with 0) it is very reflective an not stable  \n    T zbinside = zsinside - hinside;\n    un = sign * T(2.0) * (sqrt(g * max(hinside, T(0.0))) - sqrt(g * max(zsbnd - zbinside, T(0.0)))) + uninside;\n    ut = T(0.0);\n    zs = zsinside;\n    //ut[i] = ut[inside];\n    h = hinside;\n}\n\ntemplate &lt;class T&gt; __device__ __host__ void Dirichlet1Q(T g, T sign, T zsbnd, T zsinside, T hinside, T uninside, T&amp; q)\n{\n    // Is this even the right formulation?.\n    // I don't really like this formulation. while a bit less dissipative then abs1D with 0 unbnd (but worse if forcing uniside with 0) it is very reflective an not stable  \n    T zbinside = zsinside - hinside;\n    T un = sign * T(2.0) * (sqrt(g * max(hinside, T(0.0))) - sqrt(g * max(zsbnd - zbinside, T(0.0)))) + uninside;\n    T ut = T(0.0);\n    //zs = zsinside;\n    //ut[i] = ut[inside];\n    //h = hinside;\n\n    q = un * hinside;\n}\n\n\n\n/*\ntemplate &lt;class T&gt; __global__ void ABS1D(int halowidth,int isright, int istop, int nbnd, T g, T dx, T xo, T yo, T xmax, T ymax, T itime, cudaTextureObject_t texZsBND, int* bndblck, int* level, T* blockxo, T* blockyo, T* zs, T* zb, T* h, T* un, T* ut)\n{\n\n\n\n    T xx, yy;\n\n    T  sign, umean;\n    float itx;\n\n    sign = T(isright) + T(istop);\n\n\n\n\n    //int xplus;\n    //float hhi;\n    float zsbnd;\n    T zsinside;\n    T levdx= calcres(dx, level[ib]);\n    xx = blockxo[ib] + ix * levdx;\n    yy = blockyo[ib] + iy * levdx;\n\n\n    if (isright == 0) //leftside\n    {\n\n        itx = (xx - xo) / (xmax - xo) * (nbnd - 1);\n    }\n    else \n    {\n\n        itx = (yy - yo) / (ymax - yo) * (nbnd - 1);\n    }\n\n\n    umean = T(0.0);\n    zsbnd = tex2D(texZsBND, itime + 0.5f, itx + 0.5f);// textures use pixel registration so index of 0 is actually located at 0.5...\n\n    if (isbnd(isright, istop, blockDim.x, ix, iy) &amp;&amp; zsbnd &gt; zb[i])\n    {\n\n        zsinside = zs[inside];\n\n        un[i] = sign * sqrt(g / h[i]) * (zsinside - zsbnd) + umean;\n        zs[i] = zsinside;\n        ut[i] = ut[inside];\n        h[i] = h[inside];\n    }\n}\n\n\ntemplate &lt;class T&gt; __host__ void ABS1D(Param XParam, std::vector&lt;double&gt; zsbndvec, int isright, int istop, int nbnd, T itime, BlockP&lt;T&gt; XBlock, int * bndblk, T* zs, T* zb, T* h, T* un, T* ut)\n{\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = bndblk[ibl];\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n                int inside = Inside(XParam.halowidth, XParam.blkmemwidth, isright, istop, ix, iy, ib);\n\n                // left bnd: isrigit = -1; istop=0;\n                // right bnd: isright = 1; istop=0;\n                // bottom bnd: isright = 0; istop=-1;\n                // top bnd: isright = 0; istop=1;\n\n                T xx, yy;\n\n                T  sign, umean;\n                float itx;\n\n                sign = T(isright) + T(istop);\n\n\n\n\n                //int xplus;\n                //float hhi;\n                float zsbnd;\n                T zsinside;\n                T levdx = calcres(dx, XBlock.level[ib]);\n                xx = XBlock.xo[ib] + ix * levdx;\n                yy = XBlock.yo[ib] + iy * levdx;\n                int nbnd = zsbndvec.size();\n\n                if (isright == 0) //leftside\n                {\n\n                    itx = (xx - XParam.xo) / (XParam.xmax - XParam.xo) * (nbnd - 1);\n                }\n                else\n                {\n\n                    itx = (yy - XParam.yo) / (XParam.ymax - XParam.yo) * (nbnd - 1);\n                }\n\n\n                umean = T(0.0);\n\n                if (zsbndvec.size() == 1)\n                {\n                    zsbnd = zsbndvec[0];\n                }\n                else\n                {\n                    int iprev = utils::max(utils::min((int)floor(itx),nbnd-2),0);//utils::min(utils::max((int)ceil(itx / (1 / (zsbndvec.size() - 1))), 0), (int)zsbndvec.size() - 2);\n                    int inext = iprev + 1;\n                    // here interp time is used to interpolate to the right node rather than in time...\n                    zsbnd = interptime(zsbndvec[inext], zsbndvec[iprev], 1.0, (itx - iprev));\n                }\n\n                if (isbnd(isright, istop, blockDim.x, ix, iy) &amp;&amp; zsbnd &gt; zb[i])\n                {\n\n                    zsinside = zs[inside];\n\n                    un[i] = sign * sqrt(XParam.g / h[i]) * (zsinside - zsbnd) + umean;\n                    zs[i] = zsinside;\n                    ut[i] = ut[inside];\n                    h[i] = h[inside];\n                }\n            }\n        }\n    }\n}\n*/\n\n__host__ __device__ int Inside(int halowidth, int blkmemwidth, int isright, int istop,int ix,int iy, int ib)\n{\n    //int bnd, bnd_c;\n    int inside;\n\n    if (isright &lt; 0)\n    {\n        inside = memloc(halowidth, blkmemwidth, ix + 1, iy, ib);\n        //bnd_c = 0;\n        //bnd = ix;\n\n    }\n    else if (isright &gt; 0)\n    {\n        inside = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n        //bnd_c = blockDim.x - 1;\n        //bnd = ix;\n\n    }\n    else if (istop &lt; 0)//isright must be ==0!\n    {\n        inside = memloc(halowidth, blkmemwidth, ix, iy + 1, ib);\n        //bnd_c = 0;\n        //bnd = iy;\n\n    }\n    else // istop ==1 &amp;&amp; isright ==0\n    {\n        inside = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n        //bnd_c = blockDim.y - 1;\n        //bnd = iy;\n\n    }\n    return inside;\n}\n\n\n__host__ __device__ bool isbnd(int isright, int istop, int blkwidth, int ix, int iy)\n{\n    int bnd, bnd_c;\n    //int inside;\n\n    if (isright &lt; 0 || istop &lt; 0)\n    {\n        bnd_c = 0;\n    }\n    else\n    {\n        bnd_c = blkwidth - 1;\n    }\n\n    if (isright == 0)\n    {\n        bnd = iy;\n    }\n    else\n    {\n        bnd = ix;\n    }\n\n\n    return (bnd == bnd_c);\n}\n</code></pre>"},{"location":"BGFlood/_boundary_8h/","title":"File Boundary.h","text":""},{"location":"BGFlood/_boundary_8h/#file-boundaryh","title":"File Boundary.h","text":"<p>FileList &gt; src &gt; Boundary.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Updateforcing.h\"</code></li> </ul>"},{"location":"BGFlood/_boundary_8h/#public-functions","title":"Public Functions","text":"Type Name __device__ __host__ void ABS1D (T g, T sign, T zsbnd, T zsinside, T hinside, T utbnd, T unbnd, T &amp; un, T &amp; ut, T &amp; zs, T &amp; h) Device/host function for 1D absorbing boundary condition. __device__ __host__ void ABS1DQ (T g, T sign, T factime, T facrel, T zs, T zsbnd, T zsinside, T h, T &amp; qmean, T &amp; q, T &amp; G, T &amp; S) Device/host function for 1D absorbing boundary condition for flux variables. __device__ __host__ void Dirichlet1D (T g, T sign, T zsbnd, T zsinside, T hinside, T uninside, T &amp; un, T &amp; ut, T &amp; zs, T &amp; h) Device/host function for 1D Dirichlet boundary condition. __device__ __host__ void Dirichlet1Q (T g, T sign, T zsbnd, T zsinside, T hinside, T uninside, T &amp; q) Device/host function for 1D Dirichlet boundary condition for flux variables. void Flowbnd (Param XParam, Loop&lt; T &gt; &amp; XLoop, BlockP&lt; T &gt; XBlock, bndparam side, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; T &gt; XEv) Applies boundary conditions for flow variables on a given side of the domain. void FlowbndFlux (Param XParam, double totaltime, BlockP&lt; T &gt; XBlock, bndsegment bndseg, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; T &gt; XEv, FluxP&lt; T &gt; XFlux) Applies boundary conditions for flux variables on a given segment of the domain. void FlowbndFlux (Param XParam, double totaltime, BlockP&lt; T &gt; XBlock, bndparam side, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; T &gt; XEv, FluxP&lt; T &gt; XFlux)  void FlowbndFluxML (Param XParam, double totaltime, BlockP&lt; T &gt; XBlock, bndsegment bndseg, DynForcingP&lt; float &gt; Atmp, EvolvingP&lt; T &gt; XEv, FluxMLP&lt; T &gt; XFlux) Applies boundary conditions for flux ML variables on a given segment of the domain. __host__ __device__ int Inside (int halowidth, int blkmemwidth, int isright, int istop, int ix, int iy, int ib) Helper to compute the index of the inside cell for a boundary cell. __host__ void bndCPU (Param XParam, bndparam side, BlockP&lt; T &gt; XBlock, std::vector&lt; double &gt; zsbndvec, std::vector&lt; double &gt; uubndvec, std::vector&lt; double &gt; vvbndvec, DynForcingP&lt; float &gt; Atmp, T * zs, T * h, T * un, T * ut) CPU implementation for applying boundary conditions on a side. __global__ void bndFluxGPUSide (Param XParam, bndsegmentside side, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Atmp, DynForcingP&lt; float &gt; Zsmap, bool uniform, int type, float zsbnd, T taper, T * zs, T * h, T * un, T * ut, T * Fh, T * Fq, T * Ss) CUDA kernel for applying boundary fluxes on a segment side (GPU version). __global__ void bndGPU (Param XParam, bndparam side, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Atmp, float itime, T * zs, T * h, T * un, T * ut) CUDA kernel for applying boundary conditions on a side (GPU version). __device__ __host__ void findmaskside (int side, bool &amp; isleftbot, bool &amp; islefttop, bool &amp; istopleft, bool &amp; istopright, bool &amp; isrighttop, bool &amp; isrightbot, bool &amp; isbotright, bool &amp; isbotleft) Helper to decode mask side bitfield into booleans for each boundary/corner. __device__ __host__ void halowall (T zsinside, T &amp; un, T &amp; ut, T &amp; zs, T &amp; h, T &amp; zb) Device/host function to apply wall boundary in halo region. __host__ __device__ bool isbnd (int isright, int istop, int blkwidth, int ix, int iy) Helper to check if a cell is at the boundary. __host__ void maskbnd (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) CPU implementation for applying masked blocks boundary conditions (halo walls). __global__ void maskbndGPUFluxbot (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux) CUDA kernel for applying masked flux boundary conditions on the bottom side. __global__ void maskbndGPUFluxleft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, FluxP&lt; T &gt; Flux) CUDA kernel for applying masked flux boundary conditions on the left side. __global__ void maskbndGPUFluxright (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux) CUDA kernel for applying masked flux boundary conditions on the right side. __global__ void maskbndGPUFluxtop (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux) CUDA kernel for applying masked flux boundary conditions on the top side. __global__ void maskbndGPUbot (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) CUDA kernel for applying masked boundary conditions (halo walls) on the bottom side. __global__ void maskbndGPUleft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) CUDA kernel for applying masked boundary conditions (halo walls) on the left side. __global__ void maskbndGPUright (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) CUDA kernel for applying masked boundary conditions (halo walls) on the right side. __global__ void maskbndGPUtop (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) CUDA kernel for applying masked boundary conditions (halo walls) on the top side. __device__ __host__ void noslipbnd (T zsinside, T hinside, T &amp; un, T &amp; ut, T &amp; zs, T &amp; h) Device/host function to apply no-slip boundary condition. __device__ __host__ void noslipbndQ (T &amp; F, T &amp; G, T &amp; S) Device/host function to apply no-slip boundary for flux variables."},{"location":"BGFlood/_boundary_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_boundary_8h/#function-abs1d","title":"function ABS1D","text":"<p>Device/host function for 1D absorbing boundary condition. </p><pre><code>template&lt;class T&gt;\n__device__ __host__ void ABS1D (\n    T g,\n    T sign,\n    T zsbnd,\n    T zsinside,\n    T hinside,\n    T utbnd,\n    T unbnd,\n    T &amp; un,\n    T &amp; ut,\n    T &amp; zs,\n    T &amp; h\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>g</code> Gravity </li> <li><code>sign</code> Side sign </li> <li><code>zsbnd</code> Boundary zs value </li> <li><code>zsinside</code> Inside zs value </li> <li><code>hinside</code> Inside h value </li> <li><code>utbnd</code> Tangential boundary velocity </li> <li><code>unbnd</code> Normal boundary velocity </li> <li><code>un</code> Normal velocity (output) </li> <li><code>ut</code> Tangential velocity (output) </li> <li><code>zs</code> zs value (output) </li> <li><code>h</code> h value (output)</li> </ul> <p>Computes absorbing boundary for normal/tangential velocity and updates zs, h. </p>"},{"location":"BGFlood/_boundary_8h/#function-abs1dq","title":"function ABS1DQ","text":"<p>Device/host function for 1D absorbing boundary condition for flux variables. </p><pre><code>template&lt;class T&gt;\n__device__ __host__ void ABS1DQ (\n    T g,\n    T sign,\n    T factime,\n    T facrel,\n    T zs,\n    T zsbnd,\n    T zsinside,\n    T h,\n    T &amp; qmean,\n    T &amp; q,\n    T &amp; G,\n    T &amp; S\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>g</code> Gravity </li> <li><code>sign</code> Side sign </li> <li><code>factime</code> Filter time factor </li> <li><code>facrel</code> Relaxation time factor </li> <li><code>zs</code> zs value </li> <li><code>zsbnd</code> Boundary zs value </li> <li><code>zsinside</code> Inside zs value </li> <li><code>h</code> h value </li> <li><code>qmean</code> Mean flux (output) </li> <li><code>q</code> Flux q (output) </li> <li><code>G</code> Flux G (output) </li> <li><code>S</code> Source term (output)</li> </ul> <p>Computes absorbing boundary for flux variables and updates qmean, q, G, S. </p>"},{"location":"BGFlood/_boundary_8h/#function-dirichlet1d","title":"function Dirichlet1D","text":"<p>Device/host function for 1D Dirichlet boundary condition. </p><pre><code>template&lt;class T&gt;\n__device__ __host__ void Dirichlet1D (\n    T g,\n    T sign,\n    T zsbnd,\n    T zsinside,\n    T hinside,\n    T uninside,\n    T &amp; un,\n    T &amp; ut,\n    T &amp; zs,\n    T &amp; h\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>g</code> Gravity </li> <li><code>sign</code> Side sign </li> <li><code>zsbnd</code> Boundary zs value </li> <li><code>zsinside</code> Inside zs value </li> <li><code>hinside</code> Inside h value </li> <li><code>uninside</code> Inside normal velocity </li> <li><code>un</code> Normal velocity (output) </li> <li><code>ut</code> Tangential velocity (output) </li> <li><code>zs</code> zs value (output) </li> <li><code>h</code> h value (output)</li> </ul> <p>Computes Dirichlet boundary for normal/tangential velocity and updates zs, h. </p>"},{"location":"BGFlood/_boundary_8h/#function-dirichlet1q","title":"function Dirichlet1Q","text":"<p>Device/host function for 1D Dirichlet boundary condition for flux variables. </p><pre><code>template&lt;class T&gt;\n__device__ __host__ void Dirichlet1Q (\n    T g,\n    T sign,\n    T zsbnd,\n    T zsinside,\n    T hinside,\n    T uninside,\n    T &amp; q\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>g</code> Gravity </li> <li><code>sign</code> Side sign </li> <li><code>zsbnd</code> Boundary zs value </li> <li><code>zsinside</code> Inside zs value </li> <li><code>hinside</code> Inside h value </li> <li><code>uninside</code> Inside normal velocity </li> <li><code>q</code> Flux q (output)</li> </ul> <p>Computes Dirichlet boundary for flux variable q. </p>"},{"location":"BGFlood/_boundary_8h/#function-flowbnd","title":"function Flowbnd","text":"<p>Applies boundary conditions for flow variables on a given side of the domain. </p><pre><code>template&lt;class T&gt;\nvoid Flowbnd (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    bndparam side,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; T &gt; XEv\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XBlock</code> Block data structure </li> <li><code>side</code> Boundary parameter (side info) </li> <li><code>Atmp</code> Dynamic forcing data </li> <li><code>XEv</code> Evolving variables</li> </ul> <p>Handles boundary values for water level, velocity, and applies interpolation in time and space. Integrates any existing comments and logic. </p>"},{"location":"BGFlood/_boundary_8h/#function-flowbndflux","title":"function FlowbndFlux","text":"<p>Applies boundary conditions for flux variables on a given segment of the domain. </p><pre><code>template&lt;class T&gt;\nvoid FlowbndFlux (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; T &gt; XBlock,\n    bndsegment bndseg,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; T &gt; XEv,\n    FluxP &lt; T &gt; XFlux\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>totaltime</code> Current simulation time </li> <li><code>XBlock</code> Block data structure </li> <li><code>bndseg</code> Boundary segment info </li> <li><code>Atmp</code> Dynamic forcing data </li> <li><code>XEv</code> Evolving variables </li> <li><code>XFlux</code> Flux variables</li> </ul> <p>Handles boundary fluxes, applies tapers, and manages GPU/CPU execution for boundary segments. Integrates any existing comments and logic. </p>"},{"location":"BGFlood/_boundary_8h/#function-flowbndflux_1","title":"function FlowbndFlux","text":"<pre><code>template&lt;class T&gt;\nvoid FlowbndFlux (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; T &gt; XBlock,\n    bndparam side,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; T &gt; XEv,\n    FluxP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_boundary_8h/#function-flowbndfluxml","title":"function FlowbndFluxML","text":"<p>Applies boundary conditions for flux ML variables on a given segment of the domain. </p><pre><code>template&lt;class T&gt;\nvoid FlowbndFluxML (\n    Param XParam,\n    double totaltime,\n    BlockP &lt; T &gt; XBlock,\n    bndsegment bndseg,\n    DynForcingP &lt; float &gt; Atmp,\n    EvolvingP &lt; T &gt; XEv,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>totaltime</code> Current simulation time </li> <li><code>XBlock</code> Block data structure </li> <li><code>bndseg</code> Boundary segment info </li> <li><code>Atmp</code> Dynamic forcing data </li> <li><code>XEv</code> Evolving variables </li> <li><code>XFlux</code> Machine learning flux variables</li> </ul> <p>Handles boundary fluxes for ML variables, applies tapers, and manages GPU/CPU execution for boundary segments. Integrates any existing comments and logic. </p>"},{"location":"BGFlood/_boundary_8h/#function-inside","title":"function Inside","text":"<p>Helper to compute the index of the inside cell for a boundary cell. </p><pre><code>__host__ __device__ int Inside (\n    int halowidth,\n    int blkmemwidth,\n    int isright,\n    int istop,\n    int ix,\n    int iy,\n    int ib\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> Halo width </li> <li><code>blkmemwidth</code> Block memory width </li> <li><code>isright</code> Side info </li> <li><code>istop</code> Top info </li> <li><code>ix</code> x-index </li> <li><code>iy</code> y-index </li> <li><code>ib</code> Block index </li> </ul> <p>Returns:</p> <p>Index of the inside cell </p>"},{"location":"BGFlood/_boundary_8h/#function-bndcpu","title":"function bndCPU","text":"<p>CPU implementation for applying boundary conditions on a side. </p><pre><code>template&lt;class T&gt;\n__host__ void bndCPU (\n    Param XParam,\n    bndparam side,\n    BlockP &lt; T &gt; XBlock,\n    std::vector&lt; double &gt; zsbndvec,\n    std::vector&lt; double &gt; uubndvec,\n    std::vector&lt; double &gt; vvbndvec,\n    DynForcingP &lt; float &gt; Atmp,\n    T * zs,\n    T * h,\n    T * un,\n    T * ut\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>side</code> Boundary parameter info </li> <li><code>XBlock</code> Block data structure </li> <li><code>zsbndvec</code> Vector of boundary zs values </li> <li><code>uubndvec</code> Vector of boundary u values </li> <li><code>vvbndvec</code> Vector of boundary v values </li> <li><code>Atmp</code> Dynamic forcing data </li> <li><code>zs</code> Array of zs values </li> <li><code>h</code> Array of h values </li> <li><code>un</code> Array of normal velocities </li> <li><code>ut</code> Array of tangential velocities</li> </ul> <p>Applies boundary conditions for each block/thread on the CPU, using provided boundary vectors and dynamic forcing data. Handles no-slip, Dirichlet, ABS, and Neumann boundary types. Integrates any existing comments and logic. </p>"},{"location":"BGFlood/_boundary_8h/#function-bndfluxgpuside","title":"function bndFluxGPUSide","text":"<p>CUDA kernel for applying boundary fluxes on a segment side (GPU version). </p><pre><code>template&lt;class T&gt;\n__global__ void bndFluxGPUSide (\n    Param XParam,\n    bndsegmentside side,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Atmp,\n    DynForcingP &lt; float &gt; Zsmap,\n    bool uniform,\n    int type,\n    float zsbnd,\n    T taper,\n    T * zs,\n    T * h,\n    T * un,\n    T * ut,\n    T * Fh,\n    T * Fq,\n    T * Ss\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>side</code> Boundary segment side info </li> <li><code>XBlock</code> Block data structure </li> <li><code>Atmp</code> Dynamic forcing data </li> <li><code>Zsmap</code> Dynamic forcing data for zs </li> <li><code>uniform</code> Whether boundary is uniform </li> <li><code>type</code> Boundary type </li> <li><code>zsbnd</code> Boundary zs value </li> <li><code>taper</code> Taper value for smoothing </li> <li><code>zs</code> Array of zs values </li> <li><code>h</code> Array of h values </li> <li><code>un</code> Array of normal velocities </li> <li><code>ut</code> Array of tangential velocities </li> <li><code>Fh</code> Array for flux h </li> <li><code>Fq</code> Array for flux q </li> <li><code>Ss</code> Array for source terms</li> </ul> <p>Applies boundary conditions and fluxes for each thread/block on the GPU, handling tapers, Dirichlet, and ABS boundary types. </p>"},{"location":"BGFlood/_boundary_8h/#function-bndgpu","title":"function bndGPU","text":"<p>CUDA kernel for applying boundary conditions on a side (GPU version). </p><pre><code>template&lt;class T&gt;\n__global__ void bndGPU (\n    Param XParam,\n    bndparam side,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Atmp,\n    float itime,\n    T * zs,\n    T * h,\n    T * un,\n    T * ut\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>side</code> Boundary parameter info </li> <li><code>XBlock</code> Block data structure </li> <li><code>Atmp</code> Dynamic forcing data </li> <li><code>itime</code> Interpolated time for boundary data </li> <li><code>zs</code> Array of zs values </li> <li><code>h</code> Array of h values </li> <li><code>un</code> Array of normal velocities </li> <li><code>ut</code> Array of tangential velocities</li> </ul> <p>Applies boundary conditions for each thread/block on the GPU, using interpolated time and dynamic forcing data. </p>"},{"location":"BGFlood/_boundary_8h/#function-findmaskside","title":"function findmaskside","text":"<p>Helper to decode mask side bitfield into booleans for each boundary/corner. </p><pre><code>__device__ __host__ void findmaskside (\n    int side,\n    bool &amp; isleftbot,\n    bool &amp; islefttop,\n    bool &amp; istopleft,\n    bool &amp; istopright,\n    bool &amp; isrighttop,\n    bool &amp; isrightbot,\n    bool &amp; isbotright,\n    bool &amp; isbotleft\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>side</code> Bitfield encoding mask sides </li> <li><code>isleftbot</code> Is left-bottom active </li> <li><code>islefttop</code> Is left-top active </li> <li><code>istopleft</code> Is top-left active </li> <li><code>istopright</code> Is top-right active </li> <li><code>isrighttop</code> Is right-top active </li> <li><code>isrightbot</code> Is right-bottom active </li> <li><code>isbotright</code> Is bottom-right active </li> <li><code>isbotleft</code> Is bottom-left active </li> </ul>"},{"location":"BGFlood/_boundary_8h/#function-halowall","title":"function halowall","text":"<p>Device/host function to apply wall boundary in halo region. </p><pre><code>template&lt;class T&gt;\n__device__ __host__ void halowall (\n    T zsinside,\n    T &amp; un,\n    T &amp; ut,\n    T &amp; zs,\n    T &amp; h,\n    T &amp; zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>zsinside</code> Inside zs value </li> <li><code>un</code> Normal velocity (output) </li> <li><code>ut</code> Tangential velocity (output) </li> <li><code>zs</code> zs value (output) </li> <li><code>h</code> h value (output) </li> <li><code>zb</code> Mask value (output)</li> </ul> <p>Sets normal/tangential velocity and h to zero, copies zsinside to zs and zb. </p>"},{"location":"BGFlood/_boundary_8h/#function-isbnd","title":"function isbnd","text":"<p>Helper to check if a cell is at the boundary. </p><pre><code>__host__ __device__ bool isbnd (\n    int isright,\n    int istop,\n    int blkwidth,\n    int ix,\n    int iy\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>isright</code> Side info </li> <li><code>istop</code> Top info </li> <li><code>blkwidth</code> Block width </li> <li><code>ix</code> x-index </li> <li><code>iy</code> y-index </li> </ul> <p>Returns:</p> <p>True if cell is at the boundary, false otherwise </p>"},{"location":"BGFlood/_boundary_8h/#function-maskbnd","title":"function maskbnd","text":"<p>CPU implementation for applying masked blocks boundary conditions (halo walls). </p><pre><code>template&lt;class T&gt;\n__host__ void maskbnd (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Xev</code> Evolving variables </li> <li><code>zb</code> Array of mask values</li> </ul> <p>Applies wall boundary conditions in the halo region for masked blocks, updating velocities, zs, h, and mask values. Handles all four sides and corners. Integrates any existing comments and logic. </p>"},{"location":"BGFlood/_boundary_8h/#function-maskbndgpufluxbot","title":"function maskbndGPUFluxbot","text":"<p>CUDA kernel for applying masked flux boundary conditions on the bottom side. </p><pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUFluxbot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Flux</code> Flux variables</li> </ul> <p>Applies flux boundary conditions in the halo region for masked blocks on the bottom side. </p>"},{"location":"BGFlood/_boundary_8h/#function-maskbndgpufluxleft","title":"function maskbndGPUFluxleft","text":"<p>CUDA kernel for applying masked flux boundary conditions on the left side. </p><pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUFluxleft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Xev</code> Evolving variables </li> <li><code>Flux</code> Flux variables</li> </ul> <p>Applies flux boundary conditions in the halo region for masked blocks on the left side. </p>"},{"location":"BGFlood/_boundary_8h/#function-maskbndgpufluxright","title":"function maskbndGPUFluxright","text":"<p>CUDA kernel for applying masked flux boundary conditions on the right side. </p><pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUFluxright (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Flux</code> Flux variables</li> </ul> <p>Applies flux boundary conditions in the halo region for masked blocks on the right side. </p>"},{"location":"BGFlood/_boundary_8h/#function-maskbndgpufluxtop","title":"function maskbndGPUFluxtop","text":"<p>CUDA kernel for applying masked flux boundary conditions on the top side. </p><pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUFluxtop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Flux</code> Flux variables</li> </ul> <p>Applies flux boundary conditions in the halo region for masked blocks on the top side. </p>"},{"location":"BGFlood/_boundary_8h/#function-maskbndgpubot","title":"function maskbndGPUbot","text":"<p>CUDA kernel for applying masked boundary conditions (halo walls) on the bottom side. </p><pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUbot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Xev</code> Evolving variables </li> <li><code>zb</code> Array of mask values</li> </ul> <p>Applies wall boundary conditions in the halo region for masked blocks on the bottom side. </p>"},{"location":"BGFlood/_boundary_8h/#function-maskbndgpuleft","title":"function maskbndGPUleft","text":"<p>CUDA kernel for applying masked boundary conditions (halo walls) on the left side. </p><pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUleft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Xev</code> Evolving variables </li> <li><code>zb</code> Array of mask values</li> </ul> <p>Applies wall boundary conditions in the halo region for masked blocks on the left side. </p>"},{"location":"BGFlood/_boundary_8h/#function-maskbndgpuright","title":"function maskbndGPUright","text":"<p>CUDA kernel for applying masked boundary conditions (halo walls) on the right side. </p><pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUright (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Xev</code> Evolving variables </li> <li><code>zb</code> Array of mask values</li> </ul> <p>Applies wall boundary conditions in the halo region for masked blocks on the right side. </p>"},{"location":"BGFlood/_boundary_8h/#function-maskbndgputop","title":"function maskbndGPUtop","text":"<p>CUDA kernel for applying masked boundary conditions (halo walls) on the top side. </p><pre><code>template&lt;class T&gt;\n__global__ void maskbndGPUtop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Xev</code> Evolving variables </li> <li><code>zb</code> Array of mask values</li> </ul> <p>Applies wall boundary conditions in the halo region for masked blocks on the top side. </p>"},{"location":"BGFlood/_boundary_8h/#function-noslipbnd","title":"function noslipbnd","text":"<p>Device/host function to apply no-slip boundary condition. </p><pre><code>template&lt;class T&gt;\n__device__ __host__ void noslipbnd (\n    T zsinside,\n    T hinside,\n    T &amp; un,\n    T &amp; ut,\n    T &amp; zs,\n    T &amp; h\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>zsinside</code> Inside zs value </li> <li><code>hinside</code> Inside h value </li> <li><code>un</code> Normal velocity (output) </li> <li><code>ut</code> Tangential velocity (output) </li> <li><code>zs</code> zs value (output) </li> <li><code>h</code> h value (output)</li> </ul> <p>Sets normal velocity to zero, copies zsinside and hinside. </p>"},{"location":"BGFlood/_boundary_8h/#function-noslipbndq","title":"function noslipbndQ","text":"<p>Device/host function to apply no-slip boundary for flux variables. </p><pre><code>template&lt;class T&gt;\n__device__ __host__ void noslipbndQ (\n    T &amp; F,\n    T &amp; G,\n    T &amp; S\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>F</code> Flux F (output) </li> <li><code>G</code> Flux G (input) </li> <li><code>S</code> Source term (output)</li> </ul> <p>Sets F to zero, S to G. </p> <p>The documentation for this class was generated from the following file <code>src/Boundary.h</code></p>"},{"location":"BGFlood/_boundary_8h_source/","title":"File Boundary.h","text":""},{"location":"BGFlood/_boundary_8h_source/#file-boundaryh","title":"File Boundary.h","text":"<p>File List &gt; src &gt; Boundary.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef BOUNDARY_H\n#define BOUNDARY_H\n// includes, system\n\n#include \"General.h\"\n#include \"MemManagement.h\"\n#include \"Util_CPU.h\"\n#include \"Updateforcing.h\"\n\n\n\ntemplate &lt;class T&gt; void Flowbnd(Param XParam, Loop&lt;T&gt;&amp; XLoop, BlockP&lt;T&gt; XBlock, bndparam side, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;T&gt; XEv);\n__host__ __device__ int Inside(int halowidth, int blkmemwidth, int isright, int istop, int ix, int iy, int ib);\n__host__ __device__ bool isbnd(int isright, int istop, int blkwidth, int ix, int iy);\n\ntemplate &lt;class T&gt; __host__ void maskbnd(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\ntemplate &lt;class T&gt; __global__ void maskbndGPUleft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\ntemplate &lt;class T&gt; __global__ void maskbndGPUtop(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\ntemplate &lt;class T&gt; __global__ void maskbndGPUright(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\ntemplate &lt;class T&gt; __global__ void maskbndGPUbot(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\n\ntemplate &lt;class T&gt; __global__ void maskbndGPUFluxleft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, FluxP&lt;T&gt; Flux);\ntemplate &lt;class T&gt; __global__ void maskbndGPUFluxtop(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux);\ntemplate &lt;class T&gt; __global__ void maskbndGPUFluxright(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux);\ntemplate &lt;class T&gt; __global__ void maskbndGPUFluxbot(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux);\n\ntemplate &lt;class T&gt; void FlowbndFlux(Param XParam, double totaltime, BlockP&lt;T&gt; XBlock, bndsegment bndseg, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;T&gt; XEv, FluxP&lt;T&gt; XFlux);\ntemplate &lt;class T&gt; void FlowbndFlux(Param XParam,double totaltime, BlockP&lt;T&gt; XBlock, bndparam side, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;T&gt; XEv, FluxP&lt;T&gt; XFlux);\ntemplate &lt;class T&gt; void FlowbndFluxML(Param XParam, double totaltime, BlockP&lt;T&gt; XBlock, bndsegment bndseg, DynForcingP&lt;float&gt; Atmp, EvolvingP&lt;T&gt; XEv, FluxMLP&lt;T&gt; XFlux);\n\ntemplate &lt;class T&gt; __global__ void bndFluxGPUSide(Param XParam, bndsegmentside side, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Atmp, DynForcingP&lt;float&gt; Zsmap, bool uniform, int type, float zsbnd, T taper, T* zs, T* h, T* un, T* ut, T* Fh, T* Fq, T* Ss);\n\ntemplate &lt;class T&gt; __global__ void bndGPU(Param XParam, bndparam side, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Atmp, float itime, T* zs, T* h, T* un, T* ut);\ntemplate &lt;class T&gt; __host__ void bndCPU(Param XParam, bndparam side, BlockP&lt;T&gt; XBlock, std::vector&lt;double&gt; zsbndvec, std::vector&lt;double&gt; uubndvec, std::vector&lt;double&gt; vvbndvec, DynForcingP&lt;float&gt; Atmp, T* zs, T* h, T* un, T* ut);\n\n\n__device__ __host__ void findmaskside(int side, bool &amp;isleftbot, bool&amp; islefttop, bool&amp; istopleft, bool&amp; istopright, bool&amp; isrighttop, bool&amp; isrightbot, bool&amp; isbotright, bool&amp; isbotleft);\ntemplate &lt;class T&gt; __device__ __host__ void halowall(T zsinside, T&amp; un, T&amp; ut, T&amp; zs, T&amp; h,T&amp;zb);\ntemplate &lt;class T&gt; __device__ __host__ void noslipbnd(T zsinside,T hinside,T &amp;un, T &amp;ut,T &amp;zs, T &amp;h);\ntemplate &lt;class T&gt; __device__ __host__ void noslipbndQ(T&amp; F, T&amp; G, T&amp; S);\ntemplate &lt;class T&gt; __device__ __host__ void ABS1D(T g, T sign, T zsbnd, T zsinside, T hinside, T utbnd,T unbnd, T&amp; un, T&amp; ut, T&amp; zs, T&amp; h);\ntemplate &lt;class T&gt; __device__ __host__ void ABS1DQ(T g, T sign, T factime, T facrel, T zs, T zsbnd, T zsinside, T h, T&amp; qmean, T&amp; q, T&amp; G, T&amp; S);\ntemplate &lt;class T&gt; __device__ __host__ void Dirichlet1D(T g, T sign, T zsbnd, T zsinside, T hinside,  T uninside, T&amp; un, T&amp; ut, T&amp; zs, T&amp; h);\ntemplate &lt;class T&gt; __device__ __host__ void Dirichlet1Q(T g, T sign, T zsbnd, T zsinside, T hinside, T uninside, T&amp; q);\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/","title":"File ConserveElevation.cu","text":""},{"location":"BGFlood/_conserve_elevation_8cu/#file-conserveelevationcu","title":"File ConserveElevation.cu","text":"<p>FileList &gt; src &gt; ConserveElevation.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ConserveElevation.h\"</code></li> </ul>"},{"location":"BGFlood/_conserve_elevation_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ __device__ void ProlongationElevation (int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, T * h, T * zs, T * zb) Prolongs elevation values from parent to child block halo cells, handling dry/wet logic. __host__ __device__ void ProlongationElevationGH (int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, T * h, T * dhdx, T * dzsdx) Prolongs gradient and water surface values from parent to child block halo cells, handling dry/wet logic. __host__ __device__ void RevertProlongationElevation (int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, int level, T dx, T * h, T * zb, T * dzbdx, T * dzbdy) Reverts prolongation for elevation, adjusting bed elevation using gradients. void WetDryProlongation (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb) Performs wet/dry prolongation for all block boundaries. template void WetDryProlongation&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, double * zb)  template void WetDryProlongation&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, float * zb)  void WetDryProlongationGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb) Performs wet/dry prolongation for all block boundaries on the GPU using CUDA kernels. template void WetDryProlongationGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, double * zb)  template void WetDryProlongationGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, float * zb)  __global__ void WetDryProlongationGPUBot (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryProlongationGPULeft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryProlongationGPURight (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryProlongationGPUTop (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void WetDryRestriction (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb) Performs wet/dry restriction for all block boundaries. template void WetDryRestriction&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, double * zb)  template void WetDryRestriction&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, float * zb)  void WetDryRestrictionGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb) Performs wet/dry restriction for all block boundaries on the GPU using CUDA kernels. template void WetDryRestrictionGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, double * zb)  template void WetDryRestrictionGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, float * zb)  __global__ void WetDryRestrictionGPUBot (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryRestrictionGPULeft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryRestrictionGPURight (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryRestrictionGPUTop (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevation (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb) Conserves elevation across all active blocks by applying elevation conservation on each block's boundaries. __host__ __device__ void conserveElevation (int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, T * h, T * zs, T * zb) Conserves elevation for a single halo cell using neighbor values. __host__ __device__ void conserveElevation (T zb, T &amp; zswet, T &amp; hwet)  template void conserveElevation&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, double * zb)  template __host__ __device__ void conserveElevation&lt; double &gt; (int halowidth, int blkmemwidth, double eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, double * h, double * zs, double * zb)  template void conserveElevation&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, float * zb)  template __host__ __device__ void conserveElevation&lt; float &gt; (int halowidth, int blkmemwidth, float eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, float * h, float * zs, float * zb)  void conserveElevationBot (Param XParam, int ib, int ibBL, int ibBR, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void conserveElevationBot (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevationGHBot (Param XParam, int ib, int ibBL, int ibBR, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  __global__ void conserveElevationGHBot (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGHLeft (Param XParam, int ib, int ibLB, int ibLT, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  __global__ void conserveElevationGHLeft (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGHRight (Param XParam, int ib, int ibRB, int ibRT, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  __global__ void conserveElevationGHRight (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGHTop (Param XParam, int ib, int ibTL, int ibTR, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  __global__ void conserveElevationGHTop (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb) Conserves elevation on the GPU for all active blocks using CUDA kernels. template void conserveElevationGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, double * zb)  template void conserveElevationGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, float * zb)  void conserveElevationGradHalo (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx, T * dhdy, T * dzsdy) Conserves elevation gradients in halo cells for all active blocks. __host__ __device__ void conserveElevationGradHalo (int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, T * h, T * dhdx, T * dhdy)  template void conserveElevationGradHalo&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * h, double * zs, double * zb, double * dhdx, double * dzsdx, double * dhdy, double * dzsdy)  template void conserveElevationGradHalo&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * h, float * zs, float * zb, float * dhdx, float * dzsdx, float * dhdy, float * dzsdy)  __host__ __device__ void conserveElevationGradHaloA (int halowidth, int blkmemwidth, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, int iq, int jq, T theta, T delta, T * h, T * dhdx)  __host__ __device__ void conserveElevationGradHaloB (int halowidth, int blkmemwidth, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, int iq, int jq, T theta, T delta, T eps, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGradHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx, T * dhdy, T * dzsdy)  template void conserveElevationGradHaloGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * h, double * zs, double * zb, double * dhdx, double * dzsdx, double * dhdy, double * dzsdy)  template void conserveElevationGradHaloGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * h, float * zs, float * zb, float * dhdx, float * dzsdx, float * dhdy, float * dzsdy)  void conserveElevationLeft (Param XParam, int ib, int ibLB, int ibLT, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void conserveElevationLeft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevationRight (Param XParam, int ib, int ibRB, int ibRT, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void conserveElevationRight (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevationTop (Param XParam, int ib, int ibTL, int ibTR, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void conserveElevationTop (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __host__ __device__ void wetdryrestriction (int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, T * h, T * zs, T * zb)  template __host__ __device__ void wetdryrestriction&lt; double &gt; (int halowidth, int blkmemwidth, double eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, double * h, double * zs, double * zb)  template __host__ __device__ void wetdryrestriction&lt; float &gt; (int halowidth, int blkmemwidth, float eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, float * h, float * zs, float * zb)"},{"location":"BGFlood/_conserve_elevation_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_conserve_elevation_8cu/#function-prolongationelevation","title":"function ProlongationElevation","text":"<p>Prolongs elevation values from parent to child block halo cells, handling dry/wet logic. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ void ProlongationElevation (\n    int halowidth,\n    int blkmemwidth,\n    T eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int ip,\n    int jp,\n    T * h,\n    T * zs,\n    T * zb\n) \n</code></pre> <p>Copies elevation and water surface values from parent to child halo if any neighbor is dry.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Halo width </li> <li><code>blkmemwidth</code> Block memory width </li> <li><code>eps</code> Dry threshold </li> <li><code>ib</code> Block index </li> <li><code>ibn</code> Neighbor block index </li> <li><code>ihalo</code> Halo i-index </li> <li><code>jhalo</code> Halo j-index </li> <li><code>ip</code> Parent i-index </li> <li><code>jp</code> Parent j-index </li> <li><code>h</code> Water depth array </li> <li><code>zs</code> Water surface array </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-prolongationelevationgh","title":"function ProlongationElevationGH","text":"<p>Prolongs gradient and water surface values from parent to child block halo cells, handling dry/wet logic. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ void ProlongationElevationGH (\n    int halowidth,\n    int blkmemwidth,\n    T eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int ip,\n    int jp,\n    T * h,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre> <p>Sets gradients to zero in child halo if any neighbor is dry.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Halo width </li> <li><code>blkmemwidth</code> Block memory width </li> <li><code>eps</code> Dry threshold </li> <li><code>ib</code> Block index </li> <li><code>ibn</code> Neighbor block index </li> <li><code>ihalo</code> Halo i-index </li> <li><code>jhalo</code> Halo j-index </li> <li><code>ip</code> Parent i-index </li> <li><code>jp</code> Parent j-index </li> <li><code>h</code> Water depth array </li> <li><code>dhdx</code> Water depth gradient x </li> <li><code>dzsdx</code> Water surface gradient x </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-revertprolongationelevation","title":"function RevertProlongationElevation","text":"<p>Reverts prolongation for elevation, adjusting bed elevation using gradients. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ void RevertProlongationElevation (\n    int halowidth,\n    int blkmemwidth,\n    T eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int ip,\n    int jp,\n    int level,\n    T dx,\n    T * h,\n    T * zb,\n    T * dzbdx,\n    T * dzbdy\n) \n</code></pre> <p>Applies gradient-based correction to bed elevation in halo cells if any neighbor is dry.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Halo width </li> <li><code>blkmemwidth</code> Block memory width </li> <li><code>eps</code> Dry threshold </li> <li><code>ib</code> Block index </li> <li><code>ibn</code> Neighbor block index </li> <li><code>ihalo</code> Halo i-index </li> <li><code>jhalo</code> Halo j-index </li> <li><code>ip</code> Parent i-index </li> <li><code>jp</code> Parent j-index </li> <li><code>level</code> Block refinement level </li> <li><code>dx</code> Cell size </li> <li><code>h</code> Water depth array </li> <li><code>zb</code> Bed elevation array </li> <li><code>dzbdx</code> Bed elevation gradient x </li> <li><code>dzbdy</code> Bed elevation gradient y </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryprolongation","title":"function WetDryProlongation","text":"<p>Performs wet/dry prolongation for all block boundaries. </p><pre><code>template&lt;class T&gt;\nvoid WetDryProlongation (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre> <p>Applies prolongation logic to left, right, top, and bottom boundaries where block level is greater than neighbor.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables structure </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryprolongation-double","title":"function WetDryProlongation&lt; double &gt;","text":"<pre><code>template void WetDryProlongation&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryprolongation-float","title":"function WetDryProlongation&lt; float &gt;","text":"<pre><code>template void WetDryProlongation&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryprolongationgpu","title":"function WetDryProlongationGPU","text":"<p>Performs wet/dry prolongation for all block boundaries on the GPU using CUDA kernels. </p><pre><code>template&lt;class T&gt;\nvoid WetDryProlongationGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre> <p>Launches CUDA kernels for left, right, top, and bottom boundaries, synchronizing after each.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables structure </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryprolongationgpu-double","title":"function WetDryProlongationGPU&lt; double &gt;","text":"<pre><code>template void WetDryProlongationGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryprolongationgpu-float","title":"function WetDryProlongationGPU&lt; float &gt;","text":"<pre><code>template void WetDryProlongationGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryprolongationgpubot","title":"function WetDryProlongationGPUBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryProlongationGPUBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryprolongationgpuleft","title":"function WetDryProlongationGPULeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryProlongationGPULeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryprolongationgpuright","title":"function WetDryProlongationGPURight","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryProlongationGPURight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryprolongationgputop","title":"function WetDryProlongationGPUTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryProlongationGPUTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryrestriction","title":"function WetDryRestriction","text":"<p>Performs wet/dry restriction for all block boundaries. </p><pre><code>template&lt;class T&gt;\nvoid WetDryRestriction (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre> <p>Applies restriction logic to left, right, top, and bottom boundaries where block level is less than neighbor.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables structure </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryrestriction-double","title":"function WetDryRestriction&lt; double &gt;","text":"<pre><code>template void WetDryRestriction&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryrestriction-float","title":"function WetDryRestriction&lt; float &gt;","text":"<pre><code>template void WetDryRestriction&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryrestrictiongpu","title":"function WetDryRestrictionGPU","text":"<p>Performs wet/dry restriction for all block boundaries on the GPU using CUDA kernels. </p><pre><code>template&lt;class T&gt;\nvoid WetDryRestrictionGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre> <p>Launches CUDA kernels for left, right, top, and bottom boundaries, synchronizing after each.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables structure </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryrestrictiongpu-double","title":"function WetDryRestrictionGPU&lt; double &gt;","text":"<pre><code>template void WetDryRestrictionGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryrestrictiongpu-float","title":"function WetDryRestrictionGPU&lt; float &gt;","text":"<pre><code>template void WetDryRestrictionGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryrestrictiongpubot","title":"function WetDryRestrictionGPUBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryRestrictionGPUBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryrestrictiongpuleft","title":"function WetDryRestrictionGPULeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryRestrictionGPULeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryrestrictiongpuright","title":"function WetDryRestrictionGPURight","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryRestrictionGPURight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryrestrictiongputop","title":"function WetDryRestrictionGPUTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryRestrictionGPUTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevation","title":"function conserveElevation","text":"<p>Conserves elevation across all active blocks by applying elevation conservation on each block's boundaries. </p><pre><code>template&lt;class T&gt;\nvoid conserveElevation (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre> <p>Iterates over all active blocks and applies conservation routines for left, right, top, and bottom boundaries.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables structure </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevation_1","title":"function conserveElevation","text":"<p>Conserves elevation for a single halo cell using neighbor values. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ void conserveElevation (\n    int halowidth,\n    int blkmemwidth,\n    T eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int i,\n    int j,\n    T * h,\n    T * zs,\n    T * zb\n) \n</code></pre> <p>Computes wet/dry averages and updates water depth and surface for the halo cell.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Halo width </li> <li><code>blkmemwidth</code> Block memory width </li> <li><code>eps</code> Dry threshold </li> <li><code>ib</code> Block index </li> <li><code>ibn</code> Neighbor block index </li> <li><code>ihalo</code> Halo i-index </li> <li><code>jhalo</code> Halo j-index </li> <li><code>i</code> Parent i-index </li> <li><code>j</code> Parent j-index </li> <li><code>h</code> Water depth array </li> <li><code>zs</code> Water surface array </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevation_2","title":"function conserveElevation","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ void conserveElevation (\n    T zb,\n    T &amp; zswet,\n    T &amp; hwet\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevation-double","title":"function conserveElevation&lt; double &gt;","text":"<pre><code>template void conserveElevation&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevation-double_1","title":"function conserveElevation&lt; double &gt;","text":"<pre><code>template __host__ __device__ void conserveElevation&lt; double &gt; (\n    int halowidth,\n    int blkmemwidth,\n    double eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int i,\n    int j,\n    double * h,\n    double * zs,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevation-float","title":"function conserveElevation&lt; float &gt;","text":"<pre><code>template void conserveElevation&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevation-float_1","title":"function conserveElevation&lt; float &gt;","text":"<pre><code>template __host__ __device__ void conserveElevation&lt; float &gt; (\n    int halowidth,\n    int blkmemwidth,\n    float eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int i,\n    int j,\n    float * h,\n    float * zs,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationbot","title":"function conserveElevationBot","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationBot (\n    Param XParam,\n    int ib,\n    int ibBL,\n    int ibBR,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationbot_1","title":"function conserveElevationBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationghbot","title":"function conserveElevationGHBot","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGHBot (\n    Param XParam,\n    int ib,\n    int ibBL,\n    int ibBR,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationghbot_1","title":"function conserveElevationGHBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationGHBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationghleft","title":"function conserveElevationGHLeft","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGHLeft (\n    Param XParam,\n    int ib,\n    int ibLB,\n    int ibLT,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationghleft_1","title":"function conserveElevationGHLeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationGHLeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationghright","title":"function conserveElevationGHRight","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGHRight (\n    Param XParam,\n    int ib,\n    int ibRB,\n    int ibRT,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationghright_1","title":"function conserveElevationGHRight","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationGHRight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationghtop","title":"function conserveElevationGHTop","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGHTop (\n    Param XParam,\n    int ib,\n    int ibTL,\n    int ibTR,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationghtop_1","title":"function conserveElevationGHTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationGHTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationgpu","title":"function conserveElevationGPU","text":"<p>Conserves elevation on the GPU for all active blocks using CUDA kernels. </p><pre><code>template&lt;class T&gt;\nvoid conserveElevationGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre> <p>Launches CUDA kernels for left, right, top, and bottom boundaries, synchronizing after each.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables structure </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationgpu-double","title":"function conserveElevationGPU&lt; double &gt;","text":"<pre><code>template void conserveElevationGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationgpu-float","title":"function conserveElevationGPU&lt; float &gt;","text":"<pre><code>template void conserveElevationGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationgradhalo","title":"function conserveElevationGradHalo","text":"<p>Conserves elevation gradients in halo cells for all active blocks. </p><pre><code>template&lt;class T&gt;\nvoid conserveElevationGradHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx,\n    T * dhdy,\n    T * dzsdy\n) \n</code></pre> <p>Applies gradient conservation routines for left, right, top, and bottom boundaries.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>h</code> Water depth array </li> <li><code>zs</code> Water surface array </li> <li><code>zb</code> Bed elevation array </li> <li><code>dhdx</code> Water depth gradient x </li> <li><code>dzsdx</code> Water surface gradient x </li> <li><code>dhdy</code> Water depth gradient y </li> <li><code>dzsdy</code> Water surface gradient y </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationgradhalo_1","title":"function conserveElevationGradHalo","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ void conserveElevationGradHalo (\n    int halowidth,\n    int blkmemwidth,\n    T eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int i,\n    int j,\n    T * h,\n    T * dhdx,\n    T * dhdy\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationgradhalo-double","title":"function conserveElevationGradHalo&lt; double &gt;","text":"<pre><code>template void conserveElevationGradHalo&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * h,\n    double * zs,\n    double * zb,\n    double * dhdx,\n    double * dzsdx,\n    double * dhdy,\n    double * dzsdy\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationgradhalo-float","title":"function conserveElevationGradHalo&lt; float &gt;","text":"<pre><code>template void conserveElevationGradHalo&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * h,\n    float * zs,\n    float * zb,\n    float * dhdx,\n    float * dzsdx,\n    float * dhdy,\n    float * dzsdy\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationgradhaloa","title":"function conserveElevationGradHaloA","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ void conserveElevationGradHaloA (\n    int halowidth,\n    int blkmemwidth,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int ip,\n    int jp,\n    int iq,\n    int jq,\n    T theta,\n    T delta,\n    T * h,\n    T * dhdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationgradhalob","title":"function conserveElevationGradHaloB","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ void conserveElevationGradHaloB (\n    int halowidth,\n    int blkmemwidth,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int ip,\n    int jp,\n    int iq,\n    int jq,\n    T theta,\n    T delta,\n    T eps,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationgradhalogpu","title":"function conserveElevationGradHaloGPU","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGradHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx,\n    T * dhdy,\n    T * dzsdy\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationgradhalogpu-double","title":"function conserveElevationGradHaloGPU&lt; double &gt;","text":"<pre><code>template void conserveElevationGradHaloGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * h,\n    double * zs,\n    double * zb,\n    double * dhdx,\n    double * dzsdx,\n    double * dhdy,\n    double * dzsdy\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationgradhalogpu-float","title":"function conserveElevationGradHaloGPU&lt; float &gt;","text":"<pre><code>template void conserveElevationGradHaloGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * h,\n    float * zs,\n    float * zb,\n    float * dhdx,\n    float * dzsdx,\n    float * dhdy,\n    float * dzsdy\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationleft","title":"function conserveElevationLeft","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationLeft (\n    Param XParam,\n    int ib,\n    int ibLB,\n    int ibLT,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationleft_1","title":"function conserveElevationLeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationLeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationright","title":"function conserveElevationRight","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationRight (\n    Param XParam,\n    int ib,\n    int ibRB,\n    int ibRT,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationright_1","title":"function conserveElevationRight","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationRight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationtop","title":"function conserveElevationTop","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationTop (\n    Param XParam,\n    int ib,\n    int ibTL,\n    int ibTR,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-conserveelevationtop_1","title":"function conserveElevationTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryrestriction_1","title":"function wetdryrestriction","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ void wetdryrestriction (\n    int halowidth,\n    int blkmemwidth,\n    T eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int i,\n    int j,\n    T * h,\n    T * zs,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryrestriction-double_1","title":"function wetdryrestriction&lt; double &gt;","text":"<pre><code>template __host__ __device__ void wetdryrestriction&lt; double &gt; (\n    int halowidth,\n    int blkmemwidth,\n    double eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int i,\n    int j,\n    double * h,\n    double * zs,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8cu/#function-wetdryrestriction-float_1","title":"function wetdryrestriction&lt; float &gt;","text":"<pre><code>template __host__ __device__ void wetdryrestriction&lt; float &gt; (\n    int halowidth,\n    int blkmemwidth,\n    float eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int i,\n    int j,\n    float * h,\n    float * zs,\n    float * zb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/ConserveElevation.cu</code></p>"},{"location":"BGFlood/_conserve_elevation_8cu_source/","title":"File ConserveElevation.cu","text":""},{"location":"BGFlood/_conserve_elevation_8cu_source/#file-conserveelevationcu","title":"File ConserveElevation.cu","text":"<p>File List &gt; src &gt; ConserveElevation.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"ConserveElevation.h\"\n\n\ntemplate &lt;class T&gt; void conserveElevation(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        //int ii = memloc(XParam, -1, 5, 46);\n\n\n        conserveElevationLeft(XParam, ib, XBlock.LeftBot[ib], XBlock.LeftTop[ib], XBlock, XEv, zb);\n\n        conserveElevationRight(XParam, ib, XBlock.RightBot[ib], XBlock.RightTop[ib], XBlock, XEv, zb);\n\n        conserveElevationTop(XParam, ib, XBlock.TopLeft[ib], XBlock.TopRight[ib], XBlock, XEv, zb);\n\n        conserveElevationBot(XParam, ib, XBlock.BotLeft[ib], XBlock.BotRight[ib], XBlock, XEv, zb);\n\n    }\n}\ntemplate void conserveElevation&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, float* zb);\ntemplate void conserveElevation&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, double* zb);\n\ntemplate &lt;class T&gt; void conserveElevationGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    dim3 blockDimHaloLR(1, 16, 1);\n    dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n\n    conserveElevationLeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    conserveElevationRight &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    conserveElevationTop &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    conserveElevationBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n}\ntemplate void conserveElevationGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, float* zb);\ntemplate void conserveElevationGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, double* zb);\n\ntemplate &lt;class T&gt; void WetDryProlongation(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int ib, ibLB, ibTL, ibBL, ibRB,ibn;\n    int ihalo, jhalo, ip, jp;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        ibLB = XBlock.LeftBot[ib];\n        ibRB = XBlock.RightBot[ib];\n\n        ibTL = XBlock.TopLeft[ib];\n        ibBL = XBlock.BotLeft[ib];\n\n        //Left side\n        if (XBlock.level[ib] &gt; XBlock.level[ibLB])\n        {\n            // Prolongation\n            for (int j = 0; j &lt; XParam.blkwidth; j++)\n            {\n\n                ihalo = -1;\n                //\n                jhalo = j;\n                ibn = ibLB;\n\n                //il = 0;\n                //jl = j;\n\n\n\n\n                ip = XParam.blkwidth - 1;\n                jp = XBlock.RightBot[ibLB] == ib ? ftoi(floor(j * T(0.5))) : ftoi(floor(j * T(0.5)) + XParam.blkwidth / 2);\n\n                //im = ip;\n                //jm = ceil(j * T(0.5)) * 2 &gt; j ? jp + 1 : jp - 1;\n\n                ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n            }\n        }\n\n        //Right side\n        if (XBlock.level[ib] &gt; XBlock.level[ibRB])\n        {\n            // Prolongation\n            for (int j = 0; j &lt; XParam.blkwidth; j++)\n            {\n\n                ihalo = XParam.blkwidth;\n                //\n                jhalo = j;\n                ibn = ibRB;\n\n                //il = 0;\n                //jl = j;\n\n\n\n\n                ip = 0;\n                jp = XBlock.LeftBot[ibn] == ib ? ftoi(floor(j * T(0.5))) : ftoi(floor(j * T(0.5)) + XParam.blkwidth / 2);\n\n                //im = ip;\n                //jm = ceil(j * T(0.5)) * 2 &gt; j ? jp + 1 : jp - 1;\n\n                ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n            }\n        }\n\n        // Top side\n        if (XBlock.level[ib] &gt; XBlock.level[ibTL])\n        {\n            //\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                jhalo = XParam.blkwidth;\n                //\n                ihalo = i;\n                ibn = ibTL;\n\n                //il = i;\n                //jl = XParam.blkwidth - 1;\n\n                jp = 0;\n                ip = XBlock.BotLeft[ibn] == ib ? ftoi(floor(i * T(0.5))) : ftoi(floor(i * T(0.5)) + XParam.blkwidth / 2);\n\n                //jm = jp;\n                //im = ceil(i * T(0.5)) * 2 &gt; i ? ip + 1 : ip - 1;\n\n                ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n            }\n\n        }\n\n        // Bot side\n        if (XBlock.level[ib] &gt; XBlock.level[ibBL])\n        {\n            //\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                //\n                jhalo = -1;\n                ihalo = i;\n                ibn = ibBL;\n\n                //il = i;\n                //jl = 0;\n\n                jp = XParam.blkwidth - 1;\n                ip = XBlock.TopLeft[ibn] == ib ? ftoi(floor(i * T(0.5))) : ftoi(floor(i * T(0.5)) + XParam.blkwidth / 2);\n\n                //jm = jp;\n                //im = ceil(i * T(0.5)) * 2 &gt; i ? ip + 1 : ip - 1;\n\n                ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n            }\n\n        }\n\n    }\n\n}\ntemplate void WetDryProlongation&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, double* zb);\ntemplate void WetDryProlongation&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, float* zb);\n\ntemplate &lt;class T&gt; void WetDryRestriction(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int ib, ibLB, ibTL, ibBL, ibRB, ibLT, ibRT, ibTR, ibBR, ibn;\n    int ihalo, jhalo, ir, jr, lev;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        ibLB = XBlock.LeftBot[ib];\n        ibLT = XBlock.LeftTop[ib];\n\n        ibRB = XBlock.RightBot[ib];\n        ibRT = XBlock.RightTop[ib];\n\n        ibTL = XBlock.TopLeft[ib];\n        ibTR = XBlock.TopRight[ib];\n\n        ibBL = XBlock.BotLeft[ib];\n        ibBR = XBlock.BotRight[ib];\n\n        lev = XBlock.level[ib];\n\n\n        //Left side\n        ir = XParam.blkwidth - 2;\n        ihalo = -1;\n\n\n        if (lev &lt; XBlock.level[ibLB])\n        {\n\n            for (int iy = 0; iy &lt; (XParam.blkwidth / 2); iy++)\n            {\n                jhalo = iy;\n\n                ibn = ibLB;\n\n\n                jr = iy * 2;\n\n                wetdryrestriction(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n            }\n        }\n        if (lev &lt; XBlock.level[ibLT])\n        {\n            for (int iy = (XParam.blkwidth / 2); iy &lt; XParam.blkwidth; iy++)\n            {\n                jhalo = iy;\n                ibn = ibLT;\n                jr = (iy - (XParam.blkwidth / 2)) * 2;\n\n                wetdryrestriction(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n            }\n        }\n\n\n        //Right side\n\n        ihalo = XParam.blkwidth;\n        ir = 0;\n\n        if (lev &lt; XBlock.level[ibRB] )\n        {\n\n            for (int iy = 0; iy &lt; (XParam.blkwidth / 2); iy++)\n            {\n                jhalo = iy;\n                ibn = ibRB;\n                jr = iy * 2;\n\n                wetdryrestriction(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n            }\n        }\n        if (lev &lt; XBlock.level[ibRT] )\n        {\n            for (int iy = (XParam.blkwidth / 2); iy &lt; XParam.blkwidth; iy++)\n            {\n                jhalo = iy;\n                ibn = ibRT;\n                jr = (iy - (XParam.blkwidth / 2)) * 2;\n\n                wetdryrestriction(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n            }\n        }\n\n        // Top side\n        jhalo = XParam.blkwidth;\n\n        jr = 0;\n\n        if (lev &lt; XBlock.level[ibTL] )\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth / 2); ix++)\n            {\n                ihalo = ix;\n                ibn = ibTL;\n\n                ir = ix * 2;\n\n                wetdryrestriction(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n            }\n        }\n        if (lev &lt; XBlock.level[ibTR] )\n        {\n            for (int ix = (XParam.blkwidth / 2); ix &lt; XParam.blkwidth; ix++)\n            {\n                ihalo = ix;\n                ibn = ibTR;\n                ir = (ix - (XParam.blkwidth / 2)) * 2;\n\n                wetdryrestriction(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n            }\n        }\n\n        // Bot side\n        jhalo = -1;\n\n        jr = XParam.blkwidth - 2;\n\n        if (lev &lt; XBlock.level[ibBL] )\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth / 2); ix++)\n            {\n                ihalo = ix;\n                ibn = ibBL;\n\n                ir = ix * 2;\n\n                wetdryrestriction(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n            }\n        }\n        if (lev &lt; XBlock.level[ibBR] )\n        {\n            for (int ix = (XParam.blkwidth / 2); ix &lt; XParam.blkwidth; ix++)\n            {\n                ihalo = ix;\n                ibn = ibBR;\n                ir = (ix - (XParam.blkwidth / 2)) * 2;\n\n                wetdryrestriction(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n            }\n        }\n\n    }\n\n}\ntemplate void WetDryRestriction&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, double* zb);\ntemplate void WetDryRestriction&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, float* zb);\n\ntemplate &lt;class T&gt; void WetDryProlongationGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    dim3 blockDimHaloLR(1, 16, 1);\n    dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    //WetDryProlongationGPUBot\n\n    WetDryProlongationGPULeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    WetDryProlongationGPURight &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    WetDryProlongationGPUTop &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    WetDryProlongationGPUBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n}\ntemplate void WetDryProlongationGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, double* zb);\ntemplate void WetDryProlongationGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, float* zb);\n\ntemplate &lt;class T&gt; void WetDryRestrictionGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    dim3 blockDimHaloLR(1, 16, 1);\n    dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    //WetDryProlongationGPUBot\n\n    WetDryRestrictionGPULeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    WetDryRestrictionGPURight &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    WetDryRestrictionGPUTop &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    WetDryRestrictionGPUBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n}\ntemplate void WetDryRestrictionGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, double* zb);\ntemplate void WetDryRestrictionGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, float* zb);\n\ntemplate &lt;class T&gt; __host__ __device__ void ProlongationElevation(int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo,  int ip, int jp, T* h, T* zs, T* zb)\n{\n    int  halo;\n    //pp = memloc(halowidth, blkmemwidth, ip, jp, ibn);\n    //ll = memloc(halowidth, blkmemwidth, il, jl, ib);\n    //mm = memloc(halowidth, blkmemwidth, im, jm, ibn);\n\n    halo = memloc(halowidth, blkmemwidth, ihalo, jhalo, ib);\n    //Check if parent is dry or any of close neighbour\n    int ii, left, right, top, bot;\n    ii = memloc(halowidth, blkmemwidth, ip, jp, ibn);\n    left = memloc(halowidth, blkmemwidth, ip - 1, jp, ibn);\n    right = memloc(halowidth, blkmemwidth, ip + 1, jp, ibn);\n    top = memloc(halowidth, blkmemwidth, ip, jp + 1, ibn);\n    bot = memloc(halowidth, blkmemwidth, ip, jp - 1, ibn);\n\n\n    //if (!(h[ll] &gt; eps &amp;&amp; h[halo]&gt;eps &amp;&amp; h[pp] &gt; eps &amp;&amp; h[mm] &gt; eps))\n    if (!(h[ii] &gt; eps &amp;&amp; h[left] &gt; eps &amp;&amp; h[right] &gt; eps &amp;&amp; h[top] &gt; eps &amp;&amp; h[bot] &gt; eps))\n    {\n\n        //h[halo] = utils::max(T(0.0), zs[pp] - zb[halo]);\n        //zs[halo] = h[halo] + zb[halo];\n        h[halo] = h[ii];\n        zb[halo] = zb[ii];\n        zs[halo] = zs[ii];\n\n    }\n\n\n\n}\n\n\ntemplate &lt;class T&gt; __host__ __device__ void RevertProlongationElevation(int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, int level, T dx, T* h, T* zb, T* dzbdx, T* dzbdy)\n{\n    int  halo;\n    //pp = memloc(halowidth, blkmemwidth, ip, jp, ibn);\n    //ll = memloc(halowidth, blkmemwidth, il, jl, ib);\n    //mm = memloc(halowidth, blkmemwidth, im, jm, ibn);\n\n    halo = memloc(halowidth, blkmemwidth, ihalo, jhalo, ib);\n    //Check if parent is dry or any of close neighbour\n    int ii, left, right, top, bot;\n    ii = memloc(halowidth, blkmemwidth, ip, jp, ibn);\n    left = memloc(halowidth, blkmemwidth, ip - 1, jp, ibn);\n    right = memloc(halowidth, blkmemwidth, ip + 1, jp, ibn);\n    top = memloc(halowidth, blkmemwidth, ip, jp + 1, ibn);\n    bot = memloc(halowidth, blkmemwidth, ip, jp - 1, ibn);\n\n    T ilevdx = calcres(dx, level) * T(0.5);\n\n    T facbt, faclr;\n\n    //if (!(h[ll] &gt; eps &amp;&amp; h[halo]&gt;eps &amp;&amp; h[pp] &gt; eps &amp;&amp; h[mm] &gt; eps))\n    if (!(h[ii] &gt; eps &amp;&amp; h[left] &gt; eps &amp;&amp; h[right] &gt; eps &amp;&amp; h[top] &gt; eps &amp;&amp; h[bot] &gt; eps))\n    {\n        if (ihalo == -1)\n        {\n            faclr = 1.0;\n            facbt = floor(jhalo * (T)0.5) * T(2.0) &lt; (jhalo - T(0.01)) ? 1.0 : -1.0;\n        }\n        else if (ihalo == 16)\n        {\n            faclr = -1.0;\n            facbt = floor(jhalo * (T)0.5) * T(2.0) &lt; (jhalo - T(0.01)) ? 1.0 : -1.0;\n        }\n        if (jhalo == -1)\n        {\n            facbt = 1.0;\n            facbt = floor(ihalo * (T)0.5) * T(2.0) &lt; (ihalo - T(0.01)) ? 1.0 : -1.0;\n        }\n        else if (jhalo == 16)\n        {\n            facbt = -1.0;\n            facbt = floor(ihalo * (T)0.5) * T(2.0) &lt; (ihalo - T(0.01)) ? 1.0 : -1.0;\n        }\n\n        //h[halo] = utils::max(T(0.0), zs[pp] - zb[halo]);\n        //zs[halo] = h[halo] + zb[halo];\n\n        zb[halo] = zb[ii] + (faclr * dzbdx[ii] + facbt * dzbdy[ii]) * ilevdx;\n\n\n    }\n\n\n\n}\n\ntemplate &lt;class T&gt; __host__ __device__ void ProlongationElevationGH(int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, T* h, T* dhdx, T* dzsdx)\n{\n    int halo;\n    //pp = memloc(halowidth, blkmemwidth, ip, jp, ibn);\n    //ll = memloc(halowidth, blkmemwidth, il, jl, ib);\n    //mm = memloc(halowidth, blkmemwidth, im, jm, ibn);\n\n    halo = memloc(halowidth, blkmemwidth, ihalo, jhalo, ib);\n    //Check if parent is dry or any of close neighbour\n\n    int ii, left, right, top, bot;\n    ii = memloc(halowidth, blkmemwidth, ip, jp, ibn);\n    left = memloc(halowidth, blkmemwidth, ip - 1, jp, ibn);\n    right = memloc(halowidth, blkmemwidth, ip + 1, jp, ibn);\n    top = memloc(halowidth, blkmemwidth, ip, jp + 1, ibn);\n    bot = memloc(halowidth, blkmemwidth, ip, jp - 1, ibn);\n\n    //if (!(h[ll] &gt; eps &amp;&amp; h[halo] &gt; eps &amp;&amp; h[pp] &gt; eps &amp;&amp; h[mm] &gt; eps))\n    if (!(h[ii] &gt; eps &amp;&amp; h[left] &gt; eps &amp;&amp; h[right] &gt; eps &amp;&amp; h[top] &gt; eps &amp;&amp; h[bot] &gt; eps))\n    {\n\n        dhdx[halo] = T(0.0);\n        dzsdx[halo] = T(0.0);\n    }\n\n\n\n}\n\ntemplate &lt;class T&gt; __host__ __device__ void conserveElevation(int halowidth,int blkmemwidth,T eps, int ib, int ibn,int ihalo, int jhalo ,int i,int j, T* h, T* zs, T * zb)\n{\n    int ii, ir, it, itr;\n    T iiwet, irwet, itwet, itrwet;\n    T zswet, hwet;\n\n    int write;\n\n    write = memloc(halowidth, blkmemwidth, ihalo, jhalo, ib);\n\n    ii = memloc(halowidth, blkmemwidth, i, j, ibn);\n    ir = memloc(halowidth, blkmemwidth, i + 1, j, ibn);\n    it = memloc(halowidth, blkmemwidth, i, j + 1, ibn);\n    itr = memloc(halowidth, blkmemwidth, i + 1, j + 1, ibn);\n\n    iiwet = h[ii] &gt; eps ? h[ii] : T(0.0);\n    irwet = h[ir] &gt; eps ? h[ir] : T(0.0);\n    itwet = h[it] &gt; eps ? h[it] : T(0.0);\n    itrwet = h[itr] &gt; eps ? h[itr] : T(0.0);\n\n    hwet = (iiwet + irwet + itwet + itrwet);\n    zswet = iiwet * (zb[ii] + h[ii]) + irwet * (zb[ir] + h[ir]) + itwet * (zb[it] + h[it]) + itrwet * (zb[itr] + h[itr]);\n\n    //conserveElevation(zb[write], zswet, hwet);\n    if (hwet &gt; T(0.0))\n    {\n        zswet = zswet / hwet;\n        hwet = utils::max(T(0.0), zswet - zb[write]);\n\n    }\n    else\n    {\n        hwet = T(0.0);\n\n    }\n\n    //zswet = hwet + zb;\n\n    h[write] = hwet;\n    zs[write] = hwet + zb[write];\n\n\n}\ntemplate __host__ __device__ void conserveElevation&lt;float&gt;(int halowidth, int blkmemwidth, float eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, float* h, float* zs, float* zb);\ntemplate __host__ __device__ void conserveElevation&lt;double&gt;(int halowidth, int blkmemwidth, double eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, double* h, double* zs, double* zb);\n\ntemplate &lt;class T&gt; __host__ __device__ void wetdryrestriction(int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, T* h, T* zs, T* zb)\n{\n    int ii, ir, it, itr;\n    T iiwet, irwet, itwet, itrwet;\n    T zswet, hwet, cwet, zbw;\n\n    int write;\n\n    write = memloc(halowidth, blkmemwidth, ihalo, jhalo, ib);\n\n    ii = memloc(halowidth, blkmemwidth, i, j, ibn);\n    ir = memloc(halowidth, blkmemwidth, i + 1, j, ibn);\n    it = memloc(halowidth, blkmemwidth, i, j + 1, ibn);\n    itr = memloc(halowidth, blkmemwidth, i + 1, j + 1, ibn);\n\n    T hii, hir, hit, hitr;\n\n    hii = h[ii];\n    hir = h[ir];\n    hit = h[it];\n    hitr = h[itr];\n\n    zbw = zb[write];\n\n    iiwet = hii &gt; eps ? T(1.0) : T(0.0);\n    irwet = hir &gt; eps ? T(1.0) : T(0.0);\n    itwet = hit &gt; eps ? T(1.0) : T(0.0);\n    itrwet = hitr &gt; eps ? T(1.0) : T(0.0);\n\n    cwet = (iiwet + irwet + itwet + itrwet);\n    hwet = (iiwet*hii + irwet*hir + itwet*hit + itrwet*hitr);\n    zswet = (iiwet*hii) * (zb[ii] + h[ii]) + (irwet*hir) * (zb[ir] + h[ir]) + (itwet*hit) * (zb[it] + h[it]) + (itrwet * hitr) * (zb[itr] + h[itr]);\n\n    //conserveElevation(zb[write], zswet, hwet);\n    if (cwet &gt; T(0.0) &amp;&amp; cwet &lt; T(4.0))\n    {\n        zswet = zswet / hwet;\n        hwet = utils::max(T(0.0), zswet - zbw);\n\n\n        h[write] = hwet;\n        //zs[write] = hwet + zbw;\n\n    }\n\n\n    //zswet = hwet + zb;\n\n\n\n}\ntemplate __host__ __device__ void wetdryrestriction&lt;float&gt;(int halowidth, int blkmemwidth, float eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, float* h, float* zs, float* zb);\ntemplate __host__ __device__ void wetdryrestriction&lt;double&gt;(int halowidth, int blkmemwidth, double eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, double* h, double* zs, double* zb);\n\n\n\n\ntemplate &lt;class T&gt; __host__ __device__ void conserveElevation(T zb, T&amp; zswet, T&amp; hwet)\n{\n\n    if (hwet &gt; 0.0)\n    {\n        zswet = zswet / hwet;\n        hwet = utils::max(T(0.0), zswet - zb);\n\n    }\n    else\n    {\n        hwet = T(0.0);\n\n    }\n\n    zswet = hwet + zb;\n}\n\ntemplate &lt;class T&gt; void conserveElevationGradHalo(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx, T* dhdy, T* dzsdy)\n{\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        conserveElevationGHLeft(XParam, ib, XBlock.LeftBot[ib], XBlock.LeftTop[ib], XBlock, h, zs, zb, dhdx, dzsdx);\n        conserveElevationGHRight(XParam, ib, XBlock.RightBot[ib], XBlock.RightTop[ib], XBlock, h, zs, zb, dhdx, dzsdx);\n        conserveElevationGHTop(XParam, ib, XBlock.TopLeft[ib], XBlock.TopRight[ib], XBlock, h, zs, zb, dhdy, dzsdy);\n        conserveElevationGHBot(XParam, ib, XBlock.BotLeft[ib], XBlock.BotRight[ib], XBlock, h, zs, zb, dhdy, dzsdy);\n    }\n}\ntemplate void conserveElevationGradHalo&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* h, float* zs, float* zb, float* dhdx, float* dzsdx, float* dhdy, float* dzsdy);\ntemplate void conserveElevationGradHalo&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* h, double* zs, double* zb, double* dhdx, double* dzsdx, double* dhdy, double* dzsdy);\n\ntemplate &lt;class T&gt; void conserveElevationGradHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx, T* dhdy, T* dzsdy)\n{\n    dim3 blockDimHaloLR(1, 16, 1);\n    dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    conserveElevationGHLeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, h, zs, zb, dhdx, dzsdx);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    conserveElevationGHRight &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, h, zs, zb, dhdx, dzsdx);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    conserveElevationGHTop &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, h, zs, zb, dhdy, dzsdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    conserveElevationGHBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, h, zs, zb, dhdy, dzsdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n}\ntemplate void conserveElevationGradHaloGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* h, float* zs, float* zb, float* dhdx, float* dzsdx, float* dhdy, float* dzsdy);\ntemplate void conserveElevationGradHaloGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* h, double* zs, double* zb, double* dhdx, double* dzsdx, double* dhdy, double* dzsdy);\n\ntemplate &lt;class T&gt; __host__ __device__ void conserveElevationGradHalo(int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo,int i, int j, T* h, T* dhdx, T* dhdy)\n{\n    int ii, ir, it, itr, jj;\n    int write;\n    write = memloc(halowidth, blkmemwidth, ihalo, jhalo, ib);\n\n    ii = memloc(halowidth, blkmemwidth, i, j, ibn);\n    ir = memloc(halowidth, blkmemwidth, i + 1, j, ibn);\n    it = memloc(halowidth, blkmemwidth, i, j + 1, ibn);\n    itr = memloc(halowidth, blkmemwidth, i + 1, j + 1, ibn);\n\n    if (h[write] &lt;= eps)\n    {\n        // Because of the slope limiter the average slope is not the slope of the averaged values\n        // It seems that it should be the closest to zero instead... With conserve elevation This will work but maybe all prolongation need to be applied this way (?)\n        dhdy[write] = utils::nearest(utils::nearest(utils::nearest(dhdy[ii], dhdy[ir]), dhdy[it]), dhdy[itr]);\n        dhdx[write] = utils::nearest(utils::nearest(utils::nearest(dhdx[ii], dhdx[ir]), dhdx[it]), dhdx[itr]);\n    }\n}\n\n\ntemplate &lt;class T&gt; __host__ __device__ void conserveElevationGradHaloA(int halowidth, int blkmemwidth, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, int iq, int jq, T theta, T delta, T* h, T* dhdx)\n{\n    //int pii, pir, pit, pitr;\n    int qii, qir, qit, qitr;\n\n    T p, q;\n    T s0, s1, s2;\n\n    int write, pii;\n    write = memloc(halowidth, blkmemwidth, ihalo, jhalo, ib);\n    pii = memloc(halowidth, blkmemwidth, ip, jp, ib);\n\n\n\n\n    //pii = memloc(halowidth, blkmemwidth, ip, jp, ibn);\n    //pir = memloc(halowidth, blkmemwidth, ip + 1, jp, ibn);\n    //pit = memloc(halowidth, blkmemwidth, ip, jp + 1, ibn);\n    //pitr = memloc(halowidth, blkmemwidth, ip + 1, jp + 1, ibn);\n\n    qii = memloc(halowidth, blkmemwidth, iq, jq, ibn);\n    qir = memloc(halowidth, blkmemwidth, iq + 1, jq, ibn);\n    qit = memloc(halowidth, blkmemwidth, iq, jq + 1, ibn);\n    qitr = memloc(halowidth, blkmemwidth, iq + 1, jq + 1, ibn);\n\n    s1 = h[write];\n    p = h[pii];\n    q = T(0.25) * (h[qii] + h[qir] + h[qit] + h[qitr]);\n\n\n\n    if (ip &gt; ihalo || jp &gt; jhalo)\n    {\n        s0 = q;\n        s2 = p;\n    }\n    else\n    {\n        s2 = q;\n        s0 = p;\n    }\n\n    dhdx[write] = minmod2(theta, s0, s1, s2) / delta;\n    //dhdx[write] = utils::nearest(utils::nearest(utils::nearest(dhdx[ii], dhdx[ir]), dhdx[it]), dhdx[itr]);\n\n}\n\ntemplate &lt;class T&gt; __host__ __device__ void conserveElevationGradHaloB(int halowidth, int blkmemwidth, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, int iq, int jq, T theta, T delta, T eps, T* h, T* zs, T* zb, T* dhdx, T* dzsdx)\n{\n    //int pii, pir, pit, pitr;\n    int qii, qir, qit, qitr;\n\n    T hp, hq,zsp,zsq, zbq;\n    T hs0, hs1, hs2,zss0, zss1, zss2;\n\n    T hwet, zswet;\n    int write, pii;\n    T iiwet, irwet, itwet, itrwet;\n    write = memloc(halowidth, blkmemwidth, ihalo, jhalo, ib);\n    pii = memloc(halowidth, blkmemwidth, ip, jp, ib);\n\n    //pii = memloc(halowidth, blkmemwidth, ip, jp, ibn);\n    //pir = memloc(halowidth, blkmemwidth, ip + 1, jp, ibn);\n    //pit = memloc(halowidth, blkmemwidth, ip, jp + 1, ibn);\n    //pitr = memloc(halowidth, blkmemwidth, ip + 1, jp + 1, ibn);\n\n    qii = memloc(halowidth, blkmemwidth, iq, jq, ibn);\n    qir = memloc(halowidth, blkmemwidth, iq + 1, jq, ibn);\n    qit = memloc(halowidth, blkmemwidth, iq, jq + 1, ibn);\n    qitr = memloc(halowidth, blkmemwidth, iq + 1, jq + 1, ibn);\n\n\n\n\n    zbq = T(0.25) * (zb[qii] + zb[qir] + zb[qit] + zb[qitr]);\n\n    iiwet = h[qii] &gt; eps ? h[qii] : T(0.0);\n    irwet = h[qir] &gt; eps ? h[qir] : T(0.0);\n    itwet = h[qit] &gt; eps ? h[qit] : T(0.0);\n    itrwet = h[qitr] &gt; eps ? h[qitr] : T(0.0);\n\n    hwet = T(iiwet + irwet + itwet + itrwet);\n    zswet = iiwet * (zb[qii] + h[qii]) + irwet * (zb[qir] + h[qir]) + itwet * (zb[qit] + h[qit]) + itrwet * (zb[qitr] + h[qitr]);\n\n    if (hwet &gt; T(0.0))\n    {\n        zswet = zswet / hwet;\n        hq = utils::max(T(0.0), zswet - zbq);\n\n    }\n    else\n    {\n        hq = T(0.0);\n    }\n\n    hs1 = h[write];\n    zss1= zs[write];\n    hp = h[pii];\n    zsp = zs[pii];\n    zsq = hq + zbq;\n\n    if (ip &gt; ihalo || jp &gt; jhalo )\n    {\n        hs0 = hq;\n        hs2 = hp;\n        zss0 = zsq;\n        zss2 = zsp;\n    }\n    else\n    {\n        hs2 = hq;\n        hs0 = hp;\n        zss2 = zsq;\n        zss0 = zsp;\n    }\n\n    dhdx[write] = minmod2(theta,hs0,hs1,hs2)/ delta;\n    dzsdx[write] = minmod2(theta, zss0, zss1, zss2) / delta;\n    //dhdx[write] = utils::nearest(utils::nearest(utils::nearest(dhdx[ii], dhdx[ir]), dhdx[it]), dhdx[itr]);\n\n}\n\ntemplate &lt;class T&gt; void conserveElevationGHLeft(Param XParam, int ib, int ibLB, int ibLT, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx)\n{\n    int ibn;\n    int ihalo, jhalo, ip, jp, iq, jq;\n    T delta = calcres(T(XParam.delta), XBlock.level[ib]);\n    ihalo = -1;\n    ip = 0;\n\n\n    if (XBlock.level[ib] &lt; XBlock.level[ibLB])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n            jhalo = j;\n            jp = j;\n            iq = XParam.blkwidth - 4;\n            jq = j * 2;\n            ibn = ibLB;\n            conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n            //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n            //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibLB,  -1, j, XParam.blkwidth - 2, j * 2, h, dhdx, dhdy);\n        }\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[ibLT])\n    {\n        for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n        {\n            jhalo = j;\n            jp = j;\n            iq = XParam.blkwidth - 4;\n            jq = (j - (XParam.blkwidth / 2)) * 2;\n            ibn = ibLT;\n\n            conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n            //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n\n            //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibLT, -1, j, XParam.blkwidth - 2, (j - (XParam.blkwidth / 2)) * 2, h, dhdx, dhdy);\n        }\n    }\n\n    // Prolongation part\n    //int il, jl, im, jm;\n    ihalo = -1;\n\n    if (XBlock.level[ib] &gt; XBlock.level[ibLB])\n    {\n        //\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n            jhalo = j;\n            ibn = ibLB;\n\n            //il = 0;\n            //jl = j;\n\n            ip = XParam.blkwidth - 1;\n            jp = XBlock.RightBot[ibLB] == ib ? ftoi(floor(j / 2)) : ftoi(floor(j / 2) + XParam.blkwidth / 2);\n\n            //im = ip;\n            //jm = ceil(j * T(0.5)) * 2 &gt; j ? jp + 1 : jp - 1;\n\n            ProlongationElevationGH(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, h, dhdx, dzsdx);\n        }\n\n    }\n\n\n\n}\n\ntemplate &lt;class T&gt; __global__ void conserveElevationGHLeft(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T*zs, T*zb, T* dhdx, T* dzsdx)\n{\n\n\n\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int LB = XBlock.LeftBot[ib];\n    int LT = XBlock.LeftTop[ib];\n\n    int ip, jp, iq, jq;\n\n    int ihalo, jhalo, ibn;\n    T delta = calcres(XParam.delta, lev);\n\n\n    ihalo = -1;\n    jhalo = iy;\n    iq = XParam.blkwidth - 4;\n    ip = 0;\n    jp = iy;\n    if (lev &lt; XBlock.level[LB] &amp;&amp; iy &lt; (blockDim.y / 2))\n    {\n        ibn = LB;\n        jq = iy * 2;\n        conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n        //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n\n        //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, h, dhdx, dhdy);\n    }\n    if (lev &lt; XBlock.level[LT] &amp;&amp; iy &gt;= (blockDim.y / 2))\n    {\n        ibn = LT;\n        jq = (iy - (blockDim.y / 2)) * 2;\n        conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n        //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, h, dhdx, dhdy);\n        //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n    }\n\n    // Prolongation part\n    //int il, jl, im, jm;\n\n\n    if (XBlock.level[ib] &gt; XBlock.level[LB])\n    {\n        //\n        //\n\n        ibn = LB;\n\n        //il = 0;\n        //jl = iy;\n\n        ip = blockDim.y - 1;\n        jp = XBlock.RightBot[LB] == ib ? int(floor(iy *T(0.5))) : int((floor(iy * T(0.5)) + blockDim.y / 2));\n        //im = ip;\n        //jm = ceil(iy * T(0.5)) * 2 &gt; iy ? jp + 1 : jp - 1;\n\n        ProlongationElevationGH(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, h, dhdx, dzsdx);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; void conserveElevationGHRight(Param XParam, int ib, int ibRB, int ibRT, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx)\n{\n    int ibn;\n    int ihalo, jhalo, ip, jp, iq, jq;\n    T delta = calcres(T(XParam.delta), XBlock.level[ib]);\n    ihalo = XParam.blkwidth;\n    ip = XParam.blkwidth-1;\n\n    if (XBlock.level[ib] &lt; XBlock.level[ibRB])\n    {\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n            jhalo = j;\n            jp = j;\n            iq = 2;\n            jq = j * 2;\n            ibn = ibRB;\n            conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n            //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n            //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibRB, XParam.blkwidth, j, 0, j * 2, h, dhdx, dhdy);\n        }\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[ibRT])\n    {\n        for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n        {\n            jhalo = j;\n            jp = j;\n            iq = 2;\n            jq = (j - (XParam.blkwidth / 2)) * 2;\n            ibn = ibRT;\n            conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n            //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n\n            //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibRT, XParam.blkwidth, j, 0, (j - (XParam.blkwidth / 2)) * 2, h, dhdx, dhdy);\n        }\n    }\n\n    // Prolongation part\n    //int il, jl, im, jm;\n\n\n    if (XBlock.level[ib] &gt; XBlock.level[ibRB])\n    {\n        //\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n            jhalo = j;\n            ibn = ibRB;\n\n            //il = XParam.blkwidth-2;\n            //jl = j;\n\n            ip = 0;\n            jp = XBlock.LeftBot[ibRB] == ib ? ftoi(floor(j / 2)) : ftoi(floor(j / 2) + XParam.blkwidth / 2);\n            //im = ip;\n            //jm = ceil(j * T(0.5)) * 2 &gt; j ? jp + 1 : jp - 1;\n\n            ProlongationElevationGH(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, h, dhdx, dzsdx);\n        }\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void conserveElevationGHRight(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T*zs, T*zb, T* dhdx, T* dzsdx)\n{\n\n\n\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int RB = XBlock.RightBot[ib];\n    int RT = XBlock.RightTop[ib];\n\n\n\n    int ihalo, jhalo, iq, jq, ip, jp, ibn;\n\n    T delta = calcres(XParam.delta, lev);\n\n    ihalo = blockDim.y;\n    jhalo = iy;\n    iq = blockDim.y - 4;\n    ip = blockDim.y-1;\n    jp = iy;\n\n    if (XBlock.level[ib] &lt; XBlock.level[RB] &amp;&amp; iy &lt; (blockDim.y / 2))\n    {\n        ibn = RB;\n        jq = iy * 2;\n        conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n        //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n\n        //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, h, dhdx, dhdy);\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[RT] &amp;&amp; iy &gt;= (blockDim.y / 2))\n    {\n        ibn = RT;\n        jq = (iy - (XParam.blkwidth / 2)) * 2;\n        conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n        //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n        //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, h, dhdx, dhdy);\n    }\n\n    // Prolongation part\n    //int il, jl, im, jm;\n\n\n    if (XBlock.level[ib] &gt; XBlock.level[RB])\n    {\n        //\n\n        //\n        jhalo = iy;\n        ibn = RB;\n\n        //il = blockDim.y - 2;\n        //jl = iy;\n\n        ip = 0;\n        jp = XBlock.LeftBot[RB] == ib ? int(floor(iy * T(0.5))) : int((floor(iy *T (0.5)) + blockDim.y / 2));\n\n        //im = ip;\n        //jm = ceil(iy * T(0.5)) * 2 &gt; iy ? jp + 1 : jp - 1;\n\n        ProlongationElevationGH(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, h, dhdx, dzsdx);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; void conserveElevationGHTop(Param XParam, int ib, int ibTL, int ibTR, BlockP&lt;T&gt; XBlock, T* h, T*zs, T*zb, T* dhdx, T* dzsdx)\n{\n    int ibn;\n    int ihalo, jhalo, ip, jp, iq, jq;\n    T delta = calcres(T(XParam.delta), XBlock.level[ib]);\n    jhalo = XParam.blkwidth;\n    jp = XParam.blkwidth - 1;\n\n    if (XBlock.level[ib] &lt; XBlock.level[ibTL])\n    {\n        for (int i = 0; i &lt; XParam.blkwidth / 2; i++)\n        {\n            ihalo = i;\n            ip = i;\n            jq = 2;\n            iq = i * 2;\n            ibn = ibTL;\n            conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n            //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibTL, i, XParam.blkwidth, i * 2, 0, h, dhdx, dhdy);\n        }\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[ibTR])\n    {\n        for (int i = (XParam.blkwidth / 2); i &lt; (XParam.blkwidth); i++)\n        {\n            ihalo = i;\n            ip = i;\n            jq = 2;\n            iq = (i - (XParam.blkwidth / 2)) * 2;\n            ibn = ibTR;\n            conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n            //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n\n            //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibTR, i, XParam.blkwidth, (i - (XParam.blkwidth / 2)) * 2, 0, h, dhdx, dhdy);\n        }\n    }\n\n    // Prolongation part\n    //int il, jl, im, jm;\n\n\n    if (XBlock.level[ib] &gt; XBlock.level[ibTL])\n    {\n        //\n        for (int i = 0; i &lt; XParam.blkwidth; i++)\n        {\n            //\n            ihalo = i;\n            ibn = ibTL;\n\n            //jl = XParam.blkwidth - 2;\n            //il = i;\n\n            jp = 0;\n            ip = XBlock.BotLeft[ibTL] == ib ? ftoi(floor(i / 2)) : ftoi(floor(i / 2) + XParam.blkwidth / 2);\n            //jm = jp;\n            //im = ceil(i * T(0.5)) * 2 &gt; i ? ip + 1 : ip - 1;\n\n            ProlongationElevationGH(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, h, dhdx, dzsdx);\n        }\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void conserveElevationGHTop(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T*zs, T*zb, T* dhdx, T* dzsdx)\n{\n\n\n    unsigned int iy = blockDim.x - 1;\n    unsigned int ix = threadIdx.x;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int TL = XBlock.TopLeft[ib];\n    int TR = XBlock.TopRight[ib];\n\n\n\n    int ihalo, jhalo, iq, jq, ip, jp, ibn;\n    T delta = calcres(XParam.delta, lev);\n\n    ihalo = ix;\n    jhalo = iy+1;\n    jp = iy;\n    ip = ix;\n    jq = 2;\n\n    if (XBlock.level[ib] &lt; XBlock.level[TL] &amp;&amp; ix &lt; (blockDim.x / 2))\n    {\n        ibn = TL;\n        iq = ix * 2;\n        conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n        //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n\n        //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, h, dhdx, dhdy);\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[TR] &amp;&amp; ix &gt;= (blockDim.x / 2))\n    {\n        ibn = TR;\n        iq = (ix - (blockDim.x / 2)) * 2;;\n        conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n        //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n        //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, h, dhdx, dhdy);\n    }\n\n    // Prolongation part\n    //int il, jl, im, jm;\n\n\n    if (XBlock.level[ib] &gt; XBlock.level[TL])\n    {\n        //\n        //\n        //ihalo = i;\n        ibn = TL;\n\n        //jl = blockDim.x - 2;\n        //il = ix;\n\n        jp = 0;\n        ip = XBlock.BotLeft[TL] == ib ? int(floor(ix *T(0.0))) : int((floor(ix * T(0.0)) + blockDim.x / 2));\n        //jm = jp;\n        //im = ceil(ix * T(0.5)) * 2 &gt; ix ? ip + 1 : ip - 1;\n\n        ProlongationElevationGH(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, h, dhdx, dzsdx);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; void conserveElevationGHBot(Param XParam, int ib, int ibBL, int ibBR, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx)\n{\n    int ibn;\n    int ihalo, jhalo, ip, jp, iq, jq;\n    T delta = calcres(T(XParam.delta), XBlock.level[ib]);\n    jhalo = -1;\n    jp = 0;\n\n    if (XBlock.level[ib] &lt; XBlock.level[ibBL])\n    {\n        for (int i = 0; i &lt; XParam.blkwidth / 2; i++)\n        {\n            ihalo = i;\n            ip = i;\n            iq = i * 2;\n            jq = XParam.blkwidth - 4;\n            ibn = ibBL;\n            conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n            //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n\n            //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibBL, i, -1, i * 2, XParam.blkwidth - 2, h, dhdx, dhdy);\n        }\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[ibBR])\n    {\n        for (int i = (XParam.blkwidth / 2); i &lt; (XParam.blkwidth); i++)\n        {\n            ihalo = i;\n            ip = i;\n            iq = (i - (XParam.blkwidth / 2)) * 2;;\n            jq = XParam.blkwidth - 4;\n            ibn = ibBR;\n            conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n            //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n\n            //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibBR, i, -1, (i - (XParam.blkwidth / 2)) * 2, XParam.blkwidth - 2, h, dhdx, dhdy);\n        }\n    }\n    // Prolongation part\n    //int il, jl, im, jm;\n\n\n    if (XBlock.level[ib] &gt; XBlock.level[ibBL])\n    {\n        //\n        for (int i = 0; i &lt; XParam.blkwidth; i++)\n        {\n            //\n            ihalo = i;\n            ibn = ibBL;\n\n            //jl = 0;\n            //il = i;\n\n            jp = XParam.blkwidth - 1;\n            ip = XBlock.TopLeft[ibBL] == ib ? ftoi(floor(i / 2)) : ftoi(floor(i / 2) + XParam.blkwidth / 2);\n            //jm = jp;\n            //im = ceil(i * T(0.5)) * 2 &gt; i ? ip + 1 : ip - 1;\n\n            ProlongationElevationGH(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, h, dhdx, dzsdx);\n        }\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void conserveElevationGHBot(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx)\n{\n\n\n\n    unsigned int ix = threadIdx.x;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int BL = XBlock.BotLeft[ib];\n    int BR = XBlock.BotRight[ib];\n\n    int ip, jp, iq, jq;\n\n    int ihalo, jhalo, ibn;\n    T delta = calcres(XParam.delta, lev);\n\n    ihalo = ix;\n    jhalo = -1;\n    jq = XParam.blkwidth - 4;\n    jp = 0;\n    ip = ix;\n\n    if (XBlock.level[ib] &lt; XBlock.level[BL] &amp;&amp; ix &lt; (blockDim.x / 2))\n    {\n        ibn = BL;\n        iq = ix * 2;\n        conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n        //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n        //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, h, dhdx, dhdy);\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[BR] &amp;&amp; ix &gt;= (blockDim.x / 2))\n    {\n        ibn = BR;\n        iq = (ix - (blockDim.x / 2)) * 2;\n        conserveElevationGradHaloB(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, T(XParam.eps), h, zs, zb, dhdx, dzsdx);\n        //conserveElevationGradHaloA(XParam.halowidth, XParam.blkmemwidth, ib, ibn, ihalo, jhalo, ip, jp, iq, jq, T(XParam.theta), delta, h, dhdx);\n        //conserveElevationGradHalo(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, h, dhdx, dhdy);\n    }\n\n    // Prolongation part\n    //int il, jl, im, jm;\n\n\n    if (XBlock.level[ib] &gt; XBlock.level[BL])\n    {\n        //\n\n        ihalo = ix;\n        ibn = BL;\n\n        //jl = 0;\n        //il = ix;\n\n        jp = blockDim.x - 1;\n        ip = XBlock.TopLeft[BL] == ib ? int(floor(ix * T(0.0))) : int((floor(ix * T(0.0)) + blockDim.x / 2));\n\n        //jm = jp;\n        //im = ceil(ix * T(0.5)) * 2 &gt; ix ? ip + 1 : ip - 1;\n\n        ProlongationElevationGH(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, h, dhdx, dzsdx);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; void conserveElevationLeft(Param XParam,int ib, int ibLB, int ibLT, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int ihalo,jhalo,ibn,ip, jp;\n\n    // Restriction\n    ihalo = -1;\n    ip = XParam.blkwidth - 2;\n\n    //int ii = memloc(XParam, -1, 5, 46);\n    if (XBlock.level[ib] &lt; XBlock.level[ibLB])\n    {\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n            jhalo = j;\n            jp = j * 2;\n            ibn = ibLB;\n            conserveElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n        }\n\n    }\n\n    if (XBlock.level[ib] &lt; XBlock.level[ibLT])\n    {\n        for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n        {\n            jhalo = j;\n            jp = (j - (XParam.blkwidth / 2)) * 2;\n            ibn = ibLT;\n            conserveElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n        }\n\n    }\n\n    // Prolongation\n\n    ihalo = -1;\n\n    if (XBlock.level[ib] &gt; XBlock.level[ibLB])\n    {\n        //\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n            jhalo = j;\n            ibn = ibLB;\n\n            //il = 0;\n            //jl = j;\n\n            ip = XParam.blkwidth - 1;\n            jp = XBlock.RightBot[ibLB] == ib ? ftoi(floor(j * T(0.5))) : ftoi(floor(j * T(0.5)) + XParam.blkwidth / 2);\n\n            //im = ip;\n            //jm = ceil(j * T(0.5)) * 2 &gt; j ? jp + 1 : jp - 1;\n\n            ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n        }\n\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void conserveElevationLeft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    unsigned int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n\n\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int LB = XBlock.LeftBot[ib];\n    int LT = XBlock.LeftTop[ib];\n\n\n\n    int ihalo , jhalo, i, j, ibn;\n\n    ihalo = -1;\n    jhalo = iy;\n    i = XParam.blkwidth - 2;\n\n    if (lev &lt; XBlock.level[LB] &amp;&amp; iy &lt; (blockDim.y / 2))\n    {\n        ibn = LB;\n        j = iy * 2;\n\n        conserveElevation(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, XEv.h, XEv.zs, zb);\n    }\n    if (lev &lt; XBlock.level[LT] &amp;&amp; iy &gt;= (blockDim.y / 2))\n    {\n        ibn = LT;\n        j = (iy - (blockDim.y / 2)) * 2;\n\n        conserveElevation(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, XEv.h, XEv.zs, zb);\n    }\n\n    // Prolongation\n    int ip, jp;\n    ihalo = -1;\n\n    if (XBlock.level[ib] &gt; XBlock.level[LB])\n    {\n        //\n\n        jhalo = iy;\n        ibn = LB;\n\n        //il = 0;\n        //jl = iy;\n\n        ip = XParam.blkwidth - 1;\n        jp = XBlock.RightBot[ibn] == ib ? floor(iy * T(0.5)) : (floor(iy * T(0.5)) + blockDim.y / 2);\n\n\n        //im = ip;\n        //jm = ceil(iy * T(0.5)) * 2 &gt; iy ? jp + 1 : jp - 1;\n\n        ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void WetDryProlongationGPULeft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    unsigned int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n\n\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int LB = XBlock.LeftBot[ib];\n    int LT = XBlock.LeftTop[ib];\n\n    int ip, jp, ihalo, jhalo, ibn;\n\n    jhalo = iy;\n    ihalo = -1;\n\n\n    if (lev &gt; XBlock.level[LB])\n    {\n        //\n\n        ibn = LB;\n\n\n        //il = 0;\n        //jl = iy;\n\n        ip = XParam.blkwidth - 1;\n        jp = XBlock.RightBot[ibn] == ib ? floor(iy * T(0.5)) : (floor(iy * T(0.5)) + blockDim.y / 2);\n\n\n        //im = ip;\n        //jm = ceil(iy * T(0.5)) * 2 &gt; iy ? jp + 1 : jp - 1;\n\n        ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void WetDryRestrictionGPULeft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    unsigned int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n\n\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int LB = XBlock.LeftBot[ib];\n    int LT = XBlock.LeftTop[ib];\n\n    int ihalo, jhalo, ibn, ir, jr;\n\n    jhalo = iy;\n    ihalo = -1;\n\n    ir = XParam.blkwidth - 2;\n\n    if (lev &lt; XBlock.level[LB] &amp;&amp; iy &lt; (blockDim.y / 2))\n    {\n        ibn = LB;\n        jr = iy * 2;\n\n        wetdryrestriction(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n    }\n    if (lev &lt; XBlock.level[LT] &amp;&amp; iy &gt;= (blockDim.y / 2))\n    {\n        ibn = LT;\n        jr = (iy - (blockDim.y / 2)) * 2;\n\n        wetdryrestriction(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n    }\n\n\n}\n\n\ntemplate &lt;class T&gt; void conserveElevationRight(Param XParam, int ib, int ibRB, int ibRT, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int ihalo, jhalo, ibn, ip, jp;\n\n    if (XBlock.level[ib] &lt; XBlock.level[ibRB])\n    {\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n            conserveElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibRB, XParam.blkwidth, j, 0, j*2, XEv.h, XEv.zs, zb);\n        }\n\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[ibRT])\n    {\n        for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n        {\n            conserveElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibRT, XParam.blkwidth, j, 0, (j - (XParam.blkwidth / 2)) * 2, XEv.h, XEv.zs, zb);\n        }\n\n    }\n\n    // Prolongation\n\n    ihalo = XParam.blkwidth;\n\n    if (XBlock.level[ib] &gt; XBlock.level[ibRB])\n    {\n        //\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n            jhalo = j;\n            ibn = ibRB;\n\n            //il = XParam.blkwidth-1;\n            //jl = j;\n\n            ip = 0;\n            jp = XBlock.LeftBot[ibn] == ib ? ftoi(floor(j * T(0.5))) : ftoi(floor(j * T(0.5)) + XParam.blkwidth / 2);\n            //im = ip;\n            //jm = ceil(j * T(0.5)) * 2 &gt; j ? jp + 1 : jp - 1;\n\n            ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo,  ip, jp, XEv.h, XEv.zs, zb);\n        }\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void conserveElevationRight(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    unsigned int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n\n\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int RB = XBlock.RightBot[ib];\n    int RT = XBlock.RightTop[ib];\n\n\n\n\n    int ihalo, jhalo, i, j, ibn;\n\n    ihalo = blockDim.y;\n    jhalo = iy;\n\n    i = 0;\n\n    if (lev &lt; XBlock.level[RB] &amp;&amp; iy &lt; (blockDim.y / 2))\n    {\n        ibn = RB;\n        j = iy * 2;\n\n        conserveElevation(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, XEv.h, XEv.zs, zb);\n    }\n    if (lev &lt; XBlock.level[RT] &amp;&amp; iy &gt;= (blockDim.y / 2))\n    {\n        ibn = RT;\n        j = (iy - (blockDim.y / 2)) * 2;\n\n        conserveElevation(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, XEv.h, XEv.zs, zb);\n    }\n\n    // Prolongation\n    int ip, jp;\n    //ihalo = -1;\n\n    if (lev &gt; XBlock.level[RB])\n    {\n        //\n\n        jhalo = iy;\n        ibn = RB;\n\n        //il = blockDim.y - 1;\n        //jl = iy;\n\n        ip = 0;\n        jp = XBlock.LeftBot[ibn] == ib ? floor(iy * T(0.5)) : (floor(iy * T(0.5)) + blockDim.y / 2);\n\n        //im = ip;\n        //jm = ceil(iy * T(0.5)) * 2 &gt; iy ? jp + 1 : jp - 1;\n\n        ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n\n\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void WetDryProlongationGPURight(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n\n\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int RB = XBlock.RightBot[ib];\n    int RT = XBlock.RightTop[ib];\n\n    int ip, jp, ihalo, jhalo, ibn;\n\n    ihalo = blockDim.y;\n    jhalo = iy;\n\n\n    if (lev &gt; XBlock.level[RB])\n    {\n        //\n\n\n        ibn = RB;\n\n        //il = blockDim.y - 1;\n        //jl = iy;\n\n        ip = 0;\n        jp = XBlock.LeftBot[ibn] == ib ? floor(iy * T(0.5)) : (floor(iy * T(0.5)) + blockDim.y / 2);\n\n        //im = ip;\n        //jm = ceil(iy * T(0.5)) * 2 &gt; iy ? jp + 1 : jp - 1;\n\n        ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n\n\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void WetDryRestrictionGPURight(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n\n\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int RB = XBlock.RightBot[ib];\n    int RT = XBlock.RightTop[ib];\n\n    int ihalo, jhalo, ibn, ir, jr;\n\n    ihalo = blockDim.y;\n    jhalo = iy;\n\n    ir = 0;\n\n    if (lev &lt; XBlock.level[RB] &amp;&amp; iy &lt; (blockDim.y / 2))\n    {\n        ibn = RB;\n        jr = iy * 2;\n\n        wetdryrestriction(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n    }\n    if (lev &lt; XBlock.level[RT] &amp;&amp; iy &gt;= (blockDim.y / 2))\n    {\n        ibn = RT;\n        jr = (iy - (blockDim.y / 2)) * 2;\n\n        wetdryrestriction(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n    }\n\n\n\n}\n\ntemplate &lt;class T&gt; void conserveElevationTop(Param XParam, int ib, int ibTL, int ibTR, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int ihalo, jhalo, ibn, ip, jp;\n\n\n\n    if (XBlock.level[ib] &lt; XBlock.level[ibTL])\n    {\n        for (int i = 0; i &lt; XParam.blkwidth / 2; i++)\n        {\n            conserveElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibTL, i, XParam.blkwidth, i*2, 0, XEv.h, XEv.zs, zb);\n        }\n\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[ibTR])\n    {\n        for (int i = (XParam.blkwidth / 2); i &lt; (XParam.blkwidth); i++)\n        {\n            conserveElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibTR, i, XParam.blkwidth, (i - (XParam.blkwidth / 2)) * 2, 0, XEv.h, XEv.zs, zb);\n        }\n\n    }\n\n    // Prolongation\n\n    jhalo = XParam.blkwidth;\n\n    if (XBlock.level[ib] &gt; XBlock.level[ibTL])\n    {\n        //\n        for (int i = 0; i &lt; XParam.blkwidth; i++)\n        {\n            //\n            ihalo = i;\n            ibn = ibTL;\n\n            //il = i;\n            //jl = XParam.blkwidth - 1;\n\n            jp = 0;\n            ip = XBlock.BotLeft[ibn] == ib ? ftoi(floor(i * T(0.5))) : ftoi(floor(i * T(0.5)) + XParam.blkwidth / 2);\n\n            //jm = jp;\n            //im = ceil(i * T(0.5)) * 2 &gt; i ? ip + 1 : ip - 1;\n\n            ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n        }\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void conserveElevationTop(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    unsigned int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n\n\n    unsigned int ix = threadIdx.x;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int TL = XBlock.TopLeft[ib];\n    int TR = XBlock.TopRight[ib];\n\n\n\n    int ihalo, jhalo, i, j, ibn;\n\n    ihalo = ix;\n    jhalo = blockDim.x;\n    j = 0;\n\n    if (lev &lt; XBlock.level[TL] &amp;&amp; ix &lt; (blockDim.x / 2))\n    {\n        ibn = TL;\n\n        i = ix * 2;\n\n        conserveElevation(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, XEv.h, XEv.zs, zb);\n    }\n    if (lev &lt; XBlock.level[TR] &amp;&amp; ix &gt;= (blockDim.x / 2))\n    {\n        ibn = TR;\n        i = (ix - (blockDim.x / 2)) * 2;\n\n        conserveElevation(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, XEv.h, XEv.zs, zb);\n    }\n\n    // Prolongation\n    int ip, jp;\n\n\n    if (lev &gt; XBlock.level[TL])\n    {\n        //\n\n        ihalo = ix;\n        ibn = TL;\n\n        //il = ix;\n        //jl = blockDim.x - 1;\n\n        jp = 0;\n        ip = XBlock.BotLeft[ibn] == ib ? floor(ix * T(0.5)) : (floor(ix * T(0.5)) + blockDim.x / 2);\n\n        //jm = jp;\n        //im = ceil(ix * T(0.5)) * 2 &gt; ix ? ip + 1 : ip - 1;\n\n        ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void WetDryProlongationGPUTop(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n\n\n    int ix = threadIdx.x;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int TL = XBlock.TopLeft[ib];\n    int TR = XBlock.TopRight[ib];\n    // Prolongation\n    int ip, jp,ihalo,jhalo,ibn;\n\n    jhalo = blockDim.x;\n    ihalo = ix;\n\n\n\n    if (lev &gt; XBlock.level[TL])\n    {\n        //\n\n        ibn = TL;\n\n        //il = ix;\n        //jl = blockDim.x - 1;\n\n        jp = 0;\n        ip = XBlock.BotLeft[ibn] == ib ? floor(ix * T(0.5)) : (floor(ix * T(0.5)) + blockDim.x / 2);\n\n        //jm = jp;\n        //im = ceil(ix * T(0.5)) * 2 &gt; ix ? ip + 1 : ip - 1;\n\n        ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void WetDryRestrictionGPUTop(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n\n\n    int ix = threadIdx.x;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int TL = XBlock.TopLeft[ib];\n    int TR = XBlock.TopRight[ib];\n    // Prolongation\n    int ihalo, jhalo, ibn, ir, jr;\n\n    jhalo = blockDim.x;\n    ihalo = ix;\n\n    jr = 0;\n\n    if (lev &lt; XBlock.level[TL] &amp;&amp; ix &lt; (blockDim.x / 2))\n    {\n        ibn = TL;\n\n        ir = ix * 2;\n\n        wetdryrestriction(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n    }\n    if (lev &lt; XBlock.level[TR] &amp;&amp; ix &gt;= (blockDim.x / 2))\n    {\n        ibn = TR;\n        ir = (ix - (blockDim.x / 2)) * 2;\n\n        wetdryrestriction(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n    }\n\n\n\n}\n\ntemplate &lt;class T&gt; void conserveElevationBot(Param XParam, int ib, int ibBL, int ibBR, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int ihalo, jhalo, ibn, ip, jp;\n\n\n\n    if (XBlock.level[ib] &lt; XBlock.level[ibBL])\n    {\n        for (int i = 0; i &lt; XParam.blkwidth / 2; i++)\n        {\n            conserveElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibBL, i,-1, i * 2, XParam.blkwidth-2, XEv.h, XEv.zs, zb);\n        }\n\n    }\n    if (XBlock.level[ib] &lt; XBlock.level[ibBR])\n    {\n        for (int i = (XParam.blkwidth / 2); i &lt; (XParam.blkwidth); i++)\n        {\n            conserveElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibBR, i, -1, (i - (XParam.blkwidth / 2)) * 2, XParam.blkwidth-2, XEv.h, XEv.zs, zb);\n        }\n\n    }\n\n\n    // Prolongation\n\n    jhalo = -1;\n\n    if (XBlock.level[ib] &gt; XBlock.level[ibBL])\n    {\n        //\n        for (int i = 0; i &lt; XParam.blkwidth; i++)\n        {\n            //\n            ihalo = i;\n            ibn = ibBL;\n\n            //il = i;\n            //jl = 0;\n\n            jp = XParam.blkwidth - 1;\n            ip = XBlock.TopLeft[ibn] == ib ? ftoi(floor(i * T(0.5))) : ftoi(floor(i * T(0.5)) + XParam.blkwidth / 2);\n\n            //jm = jp;\n            //im = ceil(i * T(0.5)) * 2 &gt; i ? ip + 1 : ip - 1;\n\n            ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n        }\n\n    }\n}\n\n\ntemplate &lt;class T&gt; __global__ void conserveElevationBot(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    unsigned int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n\n\n    unsigned int ix = threadIdx.x;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int BL = XBlock.BotLeft[ib];\n    int BR = XBlock.BotRight[ib];\n\n\n\n\n    int ihalo, jhalo, ibn;\n    int i, j;\n\n    ihalo = ix;\n    jhalo = -1;\n    j = blockDim.x-2;\n\n    if (lev &lt; XBlock.level[BL] &amp;&amp; ix &lt; (blockDim.x / 2))\n    {\n        ibn = BL;\n\n        i = ix * 2;\n\n        conserveElevation(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, XEv.h, XEv.zs, zb);\n    }\n    if (lev &lt; XBlock.level[BR] &amp;&amp; ix &gt;= (blockDim.x / 2))\n    {\n        ibn = BR;\n        i = (ix - (blockDim.x / 2)) * 2;\n\n        conserveElevation(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, i, j, XEv.h, XEv.zs, zb);\n    }\n\n    // Prolongation\n    int ip, jp;\n    //int ip, jp, il, jl, im, jm;\n    //jhalo = -1;\n\n    if (lev &gt; XBlock.level[BL])\n    {\n        //\n\n        ihalo = ix;\n        ibn = BL;\n\n        //il = ix;\n        //jl = 0;\n\n        jp = blockDim.x - 1;\n        ip = XBlock.TopLeft[ibn] == ib ? floor(ix *T(0.5)) : (floor(ix*T(0.5)) + blockDim.x / 2);\n\n        //jm = jp;\n        //im = ceil(ix * T(0.5)) * 2 &gt; ix ? ip + 1 : ip - 1;\n\n        ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp,  XEv.h, XEv.zs, zb);\n\n\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void WetDryProlongationGPUBot(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n\n\n    int ix = threadIdx.x;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int BL = XBlock.BotLeft[ib];\n    int BR = XBlock.BotRight[ib];\n\n\n\n\n    int ihalo, jhalo, ibn;\n\n    // Prolongation\n    int ip, jp;\n    //int ip, jp, il, jl, im, jm;\n    //jhalo = -1;\n    jhalo = -1;\n    ihalo = ix;\n\n\n\n    if (lev &gt; XBlock.level[BL])\n    {\n        //\n\n        ibn = BL;\n\n        //il = ix;\n        //jl = 0;\n\n        jp = blockDim.x - 1;\n        ip = XBlock.TopLeft[ibn] == ib ? floor(ix * T(0.5)) : (floor(ix * T(0.5)) + blockDim.x / 2);\n\n        //jm = jp;\n        //im = ceil(ix * T(0.5)) * 2 &gt; ix ? ip + 1 : ip - 1;\n\n        ProlongationElevation(XParam.halowidth, XParam.blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ip, jp, XEv.h, XEv.zs, zb);\n\n\n    }\n}\n\n\ntemplate &lt;class T&gt; __global__ void WetDryRestrictionGPUBot(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb)\n{\n    int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n\n\n    int ix = threadIdx.x;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int BL = XBlock.BotLeft[ib];\n    int BR = XBlock.BotRight[ib];\n\n\n\n\n    int ihalo, jhalo, ibn;\n\n    // Prolongation\n    int ir, jr;\n    //int ip, jp, il, jl, im, jm;\n    //jhalo = -1;\n    jhalo = -1;\n    ihalo = ix;\n    jr = blockDim.x - 2;\n\n    if (lev &lt; XBlock.level[BL] &amp;&amp; ix &lt; (blockDim.x / 2))\n    {\n        ibn = BL;\n\n        ir = ix * 2;\n\n        wetdryrestriction(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n    }\n    if (lev &lt; XBlock.level[BR] &amp;&amp; ix &gt;= (blockDim.x / 2))\n    {\n        ibn = BR;\n        ir = (ix - (blockDim.x / 2)) * 2;\n\n        wetdryrestriction(XParam.halowidth, blkmemwidth, T(XParam.eps), ib, ibn, ihalo, jhalo, ir, jr, XEv.h, XEv.zs, zb);\n    }\n\n\n}\n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/","title":"File ConserveElevation.h","text":""},{"location":"BGFlood/_conserve_elevation_8h/#file-conserveelevationh","title":"File ConserveElevation.h","text":"<p>FileList &gt; src &gt; ConserveElevation.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> </ul>"},{"location":"BGFlood/_conserve_elevation_8h/#public-functions","title":"Public Functions","text":"Type Name __host__ __device__ void ProlongationElevation (int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, T * h, T * zs, T * zb) Prolongs elevation values from parent to child block halo cells, handling dry/wet logic. void WetDryProlongation (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb) Performs wet/dry prolongation for all block boundaries. void WetDryProlongationGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb) Performs wet/dry prolongation for all block boundaries on the GPU using CUDA kernels. __global__ void WetDryProlongationGPUBot (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryProlongationGPULeft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryProlongationGPURight (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryProlongationGPUTop (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void WetDryRestriction (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb) Performs wet/dry restriction for all block boundaries. void WetDryRestrictionGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb) Performs wet/dry restriction for all block boundaries on the GPU using CUDA kernels. __global__ void WetDryRestrictionGPUBot (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryRestrictionGPULeft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryRestrictionGPURight (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void WetDryRestrictionGPUTop (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevation (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb) Conserves elevation across all active blocks by applying elevation conservation on each block's boundaries. void conserveElevationBot (Param XParam, int ib, int ibBL, int ibBR, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void conserveElevationBot (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevationGHBot (Param XParam, int ib, int ibBL, int ibBR, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  __global__ void conserveElevationGHBot (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGHLeft (Param XParam, int ib, int ibLB, int ibLT, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  __global__ void conserveElevationGHLeft (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGHRight (Param XParam, int ib, int ibRB, int ibRT, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  __global__ void conserveElevationGHRight (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGHTop (Param XParam, int ib, int ibTL, int ibTR, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  __global__ void conserveElevationGHTop (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx)  void conserveElevationGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb) Conserves elevation on the GPU for all active blocks using CUDA kernels. void conserveElevationGradHalo (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx, T * dhdy, T * dzsdy) Conserves elevation gradients in halo cells for all active blocks. void conserveElevationGradHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * zs, T * zb, T * dhdx, T * dzsdx, T * dhdy, T * dzsdy)  void conserveElevationLeft (Param XParam, int ib, int ibLB, int ibLT, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void conserveElevationLeft (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevationRight (Param XParam, int ib, int ibRB, int ibRT, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void conserveElevationRight (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  void conserveElevationTop (Param XParam, int ib, int ibTL, int ibTR, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void conserveElevationTop (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __host__ __device__ void wetdryrestriction (int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, T * h, T * zs, T * zb)"},{"location":"BGFlood/_conserve_elevation_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_conserve_elevation_8h/#function-prolongationelevation","title":"function ProlongationElevation","text":"<p>Prolongs elevation values from parent to child block halo cells, handling dry/wet logic. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ void ProlongationElevation (\n    int halowidth,\n    int blkmemwidth,\n    T eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int ip,\n    int jp,\n    T * h,\n    T * zs,\n    T * zb\n) \n</code></pre> <p>Copies elevation and water surface values from parent to child halo if any neighbor is dry.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Halo width </li> <li><code>blkmemwidth</code> Block memory width </li> <li><code>eps</code> Dry threshold </li> <li><code>ib</code> Block index </li> <li><code>ibn</code> Neighbor block index </li> <li><code>ihalo</code> Halo i-index </li> <li><code>jhalo</code> Halo j-index </li> <li><code>ip</code> Parent i-index </li> <li><code>jp</code> Parent j-index </li> <li><code>h</code> Water depth array </li> <li><code>zs</code> Water surface array </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8h/#function-wetdryprolongation","title":"function WetDryProlongation","text":"<p>Performs wet/dry prolongation for all block boundaries. </p><pre><code>template&lt;class T&gt;\nvoid WetDryProlongation (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre> <p>Applies prolongation logic to left, right, top, and bottom boundaries where block level is greater than neighbor.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables structure </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8h/#function-wetdryprolongationgpu","title":"function WetDryProlongationGPU","text":"<p>Performs wet/dry prolongation for all block boundaries on the GPU using CUDA kernels. </p><pre><code>template&lt;class T&gt;\nvoid WetDryProlongationGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre> <p>Launches CUDA kernels for left, right, top, and bottom boundaries, synchronizing after each.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables structure </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8h/#function-wetdryprolongationgpubot","title":"function WetDryProlongationGPUBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryProlongationGPUBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-wetdryprolongationgpuleft","title":"function WetDryProlongationGPULeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryProlongationGPULeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-wetdryprolongationgpuright","title":"function WetDryProlongationGPURight","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryProlongationGPURight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-wetdryprolongationgputop","title":"function WetDryProlongationGPUTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryProlongationGPUTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-wetdryrestriction","title":"function WetDryRestriction","text":"<p>Performs wet/dry restriction for all block boundaries. </p><pre><code>template&lt;class T&gt;\nvoid WetDryRestriction (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre> <p>Applies restriction logic to left, right, top, and bottom boundaries where block level is less than neighbor.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables structure </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8h/#function-wetdryrestrictiongpu","title":"function WetDryRestrictionGPU","text":"<p>Performs wet/dry restriction for all block boundaries on the GPU using CUDA kernels. </p><pre><code>template&lt;class T&gt;\nvoid WetDryRestrictionGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre> <p>Launches CUDA kernels for left, right, top, and bottom boundaries, synchronizing after each.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables structure </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8h/#function-wetdryrestrictiongpubot","title":"function WetDryRestrictionGPUBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryRestrictionGPUBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-wetdryrestrictiongpuleft","title":"function WetDryRestrictionGPULeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryRestrictionGPULeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-wetdryrestrictiongpuright","title":"function WetDryRestrictionGPURight","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryRestrictionGPURight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-wetdryrestrictiongputop","title":"function WetDryRestrictionGPUTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void WetDryRestrictionGPUTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevation","title":"function conserveElevation","text":"<p>Conserves elevation across all active blocks by applying elevation conservation on each block's boundaries. </p><pre><code>template&lt;class T&gt;\nvoid conserveElevation (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre> <p>Iterates over all active blocks and applies conservation routines for left, right, top, and bottom boundaries.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables structure </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationbot","title":"function conserveElevationBot","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationBot (\n    Param XParam,\n    int ib,\n    int ibBL,\n    int ibBR,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationbot_1","title":"function conserveElevationBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationghbot","title":"function conserveElevationGHBot","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGHBot (\n    Param XParam,\n    int ib,\n    int ibBL,\n    int ibBR,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationghbot_1","title":"function conserveElevationGHBot","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationGHBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationghleft","title":"function conserveElevationGHLeft","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGHLeft (\n    Param XParam,\n    int ib,\n    int ibLB,\n    int ibLT,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationghleft_1","title":"function conserveElevationGHLeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationGHLeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationghright","title":"function conserveElevationGHRight","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGHRight (\n    Param XParam,\n    int ib,\n    int ibRB,\n    int ibRT,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationghright_1","title":"function conserveElevationGHRight","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationGHRight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationghtop","title":"function conserveElevationGHTop","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGHTop (\n    Param XParam,\n    int ib,\n    int ibTL,\n    int ibTR,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationghtop_1","title":"function conserveElevationGHTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationGHTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationgpu","title":"function conserveElevationGPU","text":"<p>Conserves elevation on the GPU for all active blocks using CUDA kernels. </p><pre><code>template&lt;class T&gt;\nvoid conserveElevationGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre> <p>Launches CUDA kernels for left, right, top, and bottom boundaries, synchronizing after each.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEv</code> Evolving variables structure </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationgradhalo","title":"function conserveElevationGradHalo","text":"<p>Conserves elevation gradients in halo cells for all active blocks. </p><pre><code>template&lt;class T&gt;\nvoid conserveElevationGradHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx,\n    T * dhdy,\n    T * dzsdy\n) \n</code></pre> <p>Applies gradient conservation routines for left, right, top, and bottom boundaries.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>h</code> Water depth array </li> <li><code>zs</code> Water surface array </li> <li><code>zb</code> Bed elevation array </li> <li><code>dhdx</code> Water depth gradient x </li> <li><code>dzsdx</code> Water surface gradient x </li> <li><code>dhdy</code> Water depth gradient y </li> <li><code>dzsdy</code> Water surface gradient y </li> </ul>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationgradhalogpu","title":"function conserveElevationGradHaloGPU","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationGradHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * zs,\n    T * zb,\n    T * dhdx,\n    T * dzsdx,\n    T * dhdy,\n    T * dzsdy\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationleft","title":"function conserveElevationLeft","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationLeft (\n    Param XParam,\n    int ib,\n    int ibLB,\n    int ibLT,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationleft_1","title":"function conserveElevationLeft","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationLeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationright","title":"function conserveElevationRight","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationRight (\n    Param XParam,\n    int ib,\n    int ibRB,\n    int ibRT,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationright_1","title":"function conserveElevationRight","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationRight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationtop","title":"function conserveElevationTop","text":"<pre><code>template&lt;class T&gt;\nvoid conserveElevationTop (\n    Param XParam,\n    int ib,\n    int ibTL,\n    int ibTR,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-conserveelevationtop_1","title":"function conserveElevationTop","text":"<pre><code>template&lt;class T&gt;\n__global__ void conserveElevationTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_conserve_elevation_8h/#function-wetdryrestriction_1","title":"function wetdryrestriction","text":"<pre><code>template&lt;class T&gt;\n__host__ __device__ void wetdryrestriction (\n    int halowidth,\n    int blkmemwidth,\n    T eps,\n    int ib,\n    int ibn,\n    int ihalo,\n    int jhalo,\n    int i,\n    int j,\n    T * h,\n    T * zs,\n    T * zb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/ConserveElevation.h</code></p>"},{"location":"BGFlood/_conserve_elevation_8h_source/","title":"File ConserveElevation.h","text":""},{"location":"BGFlood/_conserve_elevation_8h_source/#file-conserveelevationh","title":"File ConserveElevation.h","text":"<p>File List &gt; src &gt; ConserveElevation.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef CONSERVEELEVATION_H\n#define CONSERVEELEVATION_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"MemManagement.h\"\n\ntemplate &lt;class T&gt; void conserveElevation(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; void conserveElevationGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\n\n//template &lt;class T&gt; void conserveElevationGradHalo(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* dhdx, T* dhdy);\ntemplate &lt;class T&gt; void conserveElevationGradHalo(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx, T* dhdy, T* dzsdy);\n//template &lt;class T&gt; void conserveElevationGradHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* dhdx, T* dhdy);\ntemplate &lt;class T&gt; void conserveElevationGradHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx, T* dhdy, T* dzsdy);\n\ntemplate &lt;class T&gt; void conserveElevationLeft(Param XParam, int ib, int ibLB, int ibLT, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void conserveElevationLeft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; void conserveElevationRight(Param XParam, int ib, int ibRB, int ibRT, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void conserveElevationRight(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; void conserveElevationTop(Param XParam, int ib, int ibTL, int ibTR, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void conserveElevationTop(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; void conserveElevationBot(Param XParam, int ib, int ibBL, int ibBR, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void conserveElevationBot(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; void conserveElevationGHLeft(Param XParam, int ib, int ibLB, int ibLT, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx);\ntemplate &lt;class T&gt; __global__ void conserveElevationGHLeft(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx);\n\ntemplate &lt;class T&gt; void conserveElevationGHRight(Param XParam, int ib, int ibRB, int ibRT, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx);\ntemplate &lt;class T&gt; __global__ void conserveElevationGHRight(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx);\n\ntemplate &lt;class T&gt; void conserveElevationGHTop(Param XParam, int ib, int ibTL, int ibTR, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx);\ntemplate &lt;class T&gt; __global__ void conserveElevationGHTop(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx);\n\ntemplate &lt;class T&gt; void conserveElevationGHBot(Param XParam, int ib, int ibBL, int ibBR, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx);\ntemplate &lt;class T&gt; __global__ void conserveElevationGHBot(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* zs, T* zb, T* dhdx, T* dzsdx);\n\ntemplate &lt;class T&gt; void WetDryProlongationGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; void WetDryProlongation(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; __global__ void WetDryProlongationGPURight(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void WetDryProlongationGPUTop(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void WetDryProlongationGPUBot(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void WetDryProlongationGPULeft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; void WetDryRestrictionGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; void WetDryRestriction(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; __global__ void WetDryRestrictionGPULeft(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void WetDryRestrictionGPUTop(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void WetDryRestrictionGPUBot(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\ntemplate &lt;class T&gt; __global__ void WetDryRestrictionGPURight(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\ntemplate &lt;class T&gt; __host__ __device__ void wetdryrestriction(int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int i, int j, T* h, T* zs, T* zb);\ntemplate &lt;class T&gt; __host__ __device__ void ProlongationElevation(int halowidth, int blkmemwidth, T eps, int ib, int ibn, int ihalo, int jhalo, int ip, int jp, T* h, T* zs, T* zb);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_flow_c_p_u_8cu/","title":"File FlowCPU.cu","text":""},{"location":"BGFlood/_flow_c_p_u_8cu/#file-flowcpucu","title":"File FlowCPU.cu","text":"<p>FileList &gt; src &gt; FlowCPU.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"FlowCPU.h\"</code></li> </ul>"},{"location":"BGFlood/_flow_c_p_u_8cu/#public-functions","title":"Public Functions","text":"Type Name void FlowCPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel) Main CPU flow solver for the flood model. template void FlowCPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; XModel)  template void FlowCPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; XModel)  void HalfStepCPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel) Debugging flow step for the flood model. template void HalfStepCPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; XModel)  template void HalfStepCPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; XModel)"},{"location":"BGFlood/_flow_c_p_u_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_flow_c_p_u_8cu/#function-flowcpu","title":"function FlowCPU","text":"<p>Main CPU flow solver for the flood model. </p><pre><code>template&lt;class T&gt;\nvoid FlowCPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Executes predictor and corrector steps, applies atmospheric, wind, and river forcing, updates advection and friction terms, and manages halo and gradient reconstruction for all blocks.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XLoop</code> Loop control and time stepping </li> <li><code>XForcing</code> Forcing data (atmospheric, wind, river, rain) </li> <li><code>XModel</code> Model data structure </li> </ul>"},{"location":"BGFlood/_flow_c_p_u_8cu/#function-flowcpu-double","title":"function FlowCPU&lt; double &gt;","text":"<pre><code>template void FlowCPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_flow_c_p_u_8cu/#function-flowcpu-float","title":"function FlowCPU&lt; float &gt;","text":"<pre><code>template void FlowCPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_flow_c_p_u_8cu/#function-halfstepcpu","title":"function HalfStepCPU","text":"<p>Debugging flow step for the flood model. </p><pre><code>template&lt;class T&gt;\nvoid HalfStepCPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Runs a simplified flow step for debugging the main engine, including forcing, advection, friction, and halo/gradient reconstruction.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XLoop</code> Loop control and time stepping </li> <li><code>XForcing</code> Forcing data (atmospheric, wind, river, rain) </li> <li><code>XModel</code> Model data structure</li> </ul> <p>Debugging flow step This function was created to debug the main engine of the model </p>"},{"location":"BGFlood/_flow_c_p_u_8cu/#function-halfstepcpu-double","title":"function HalfStepCPU&lt; double &gt;","text":"<pre><code>template void HalfStepCPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_flow_c_p_u_8cu/#function-halfstepcpu-float","title":"function HalfStepCPU&lt; float &gt;","text":"<pre><code>template void HalfStepCPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; XModel\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/FlowCPU.cu</code></p>"},{"location":"BGFlood/_flow_c_p_u_8cu_source/","title":"File FlowCPU.cu","text":""},{"location":"BGFlood/_flow_c_p_u_8cu_source/#file-flowcpucu","title":"File FlowCPU.cu","text":"<p>File List &gt; src &gt; FlowCPU.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"FlowCPU.h\"\n\n\ntemplate &lt;class T&gt; void FlowCPU(Param XParam, Loop&lt;T&gt;&amp; XLoop,Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel)\n{\n    //============================================\n    // Predictor step in reimann solver\n    //============================================\n\n\n    if (XParam.atmpforcing)\n    {\n        //Update atm press forcing\n        AddPatmforcingCPU(XParam, XModel.blocks, XForcing.Atmp, XModel);\n\n        //Fill atmp halo\n        fillHaloC(XParam, XModel.blocks, XModel.Patm);\n\n\n        //Calc dpdx and dpdy\n        gradientC(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        gradientHalo(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n        refine_linear(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        gradientHalo(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n\n\n\n    }\n\n    //============================================\n    //  Fill the halo for gradient reconstruction\n    fillHalo(XParam, XModel.blocks, XModel.evolv, XModel.zb);\n\n    //============================================\n    // Reset DTmax\n    InitArrayBUQ(XParam, XModel.blocks, XLoop.hugeposval, XModel.time.dtmax);\n\n    //============================================\n    // Calculate gradient for evolving parameters\n    gradientCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.zb);\n\n    //============================================\n    // Flux and Source term reconstruction\n    // X- direction\n    if (XParam.engine == 1)\n    {\n        // X- direction\n        UpdateButtingerXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n\n        // Y- direction\n        UpdateButtingerYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n    }\n    else if (XParam.engine == 2)\n    {\n        // X- direction\n        updateKurgXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //AddSlopeSourceXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n\n        // Y- direction\n        updateKurgYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //AddSlopeSourceYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n    }\n    else if (XParam.engine == 3)\n    {\n        // X- direction\n        updateKurgXATMCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdx);\n        //AddSlopeSourceXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n\n        // Y- direction\n\n        updateKurgYATMCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdy);\n        //AddSlopeSourceYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n    }\n\n\n    //============================================\n    // Fill Halo for flux from fine to coarse\n    fillHalo(XParam, XModel.blocks, XModel.flux);\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n        FlowbndFlux(XParam, XLoop.totaltime + XLoop.dt * 0.5, XModel.blocks, XForcing.bndseg[iseg], XForcing.Atmp, XModel.evolv, XModel.flux);\n    }\n\n\n    //bndmaskCPU(XParam, XModel.blocks, XModel.evolv, XModel.flux);\n\n    //============================================\n    // Reduce minimum timestep\n    XLoop.dt = double(CalctimestepCPU(XParam,XLoop, XModel.blocks, XModel.time));\n    XLoop.dtmax = XLoop.dt;\n    XModel.time.dt = T(XLoop.dt);\n\n\n    //============================================\n    // Update advection terms (dh dhu dhv) \n    updateEVCPU(XParam, XModel.blocks, XModel.evolv, XModel.flux, XModel.adv);\n\n    //============================================\n    // Add forcing (Rain, Wind)\n    //if (!XForcing.Rain.inputfile.empty())\n    //{\n    //  AddrainforcingCPU(XParam, XModel.blocks, XForcing.Rain, XModel.adv);\n    //}\n    if (!XForcing.UWind.inputfile.empty())//&amp;&amp; !XForcing.UWind.inputfile.empty()\n    {\n        AddwindforcingCPU(XParam, XModel.blocks, XForcing.UWind, XForcing.VWind, XModel.adv);\n    }\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        AddRiverForcing(XParam, XLoop, XForcing.rivers, XModel);\n    }\n\n    //============================================\n    //Update evolving variable by 1/2 time step\n    AdvkernelCPU(XParam, XModel.blocks, XModel.time.dt * T(0.5), XModel.zb, XModel.evolv, XModel.adv, XModel.evolv_o);\n\n\n    //============================================\n    // Corrector step in reimann solver\n    //============================================\n\n    //============================================\n    //  Fill the halo for gradient reconstruction\n    fillHalo(XParam, XModel.blocks, XModel.evolv_o,XModel.zb);\n\n    //============================================\n    // Calculate gradient for evolving parameters\n    gradientCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.zb);\n\n    //============================================\n    // Flux and Source term reconstruction\n    if (XParam.engine == 1)\n    {\n\n        // X- direction\n        UpdateButtingerXCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //updateKurgXCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //AddSlopeSourceXCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n\n        // Y- direction\n        UpdateButtingerYCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //updateKurgYCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //AddSlopeSourceYCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n    }\n    else if (XParam.engine == 2)\n    {\n        // X- direction\n        updateKurgXCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //AddSlopeSourceXCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n\n        // Y- direction\n        updateKurgYCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //AddSlopeSourceYCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n    }\n    else if (XParam.engine == 3)\n    {\n        // X- direction\n        //UpdateButtingerXCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        updateKurgXATMCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdx);\n        //AddSlopeSourceXCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n\n        // Y- direction\n        //UpdateButtingerYCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        updateKurgYATMCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdy);\n        //AddSlopeSourceYCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n    }\n\n    //============================================\n    // Fill Halo for flux from fine to coarse\n    fillHalo(XParam, XModel.blocks, XModel.flux);\n\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n        FlowbndFlux(XParam, XLoop.totaltime + XLoop.dt , XModel.blocks, XForcing.bndseg[iseg], XForcing.Atmp, XModel.evolv, XModel.flux);\n    }\n\n\n    //============================================\n    // Update advection terms (dh dhu dhv) \n    updateEVCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.flux, XModel.adv);\n\n    //============================================\n    // Add forcing (Rain, Wind)\n    //if (!XForcing.Rain.inputfile.empty())\n    //{\n    //  AddrainforcingCPU(XParam, XModel.blocks, XForcing.Rain, XModel.adv);\n    //}\n    if (!XForcing.UWind.inputfile.empty())//&amp;&amp; !XForcing.UWind.inputfile.empty()\n    {\n        AddwindforcingCPU(XParam, XModel.blocks, XForcing.UWind, XForcing.VWind, XModel.adv);\n    }\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        AddRiverForcing(XParam, XLoop, XForcing.rivers, XModel);\n    }\n\n    //============================================\n    //Update evolving variable by 1 full time step\n    AdvkernelCPU(XParam, XModel.blocks, XModel.time.dt, XModel.zb, XModel.evolv, XModel.adv, XModel.evolv_o);\n\n\n\n    //============================================\n    // Add bottom friction\n\n    bottomfrictionCPU(XParam, XModel.blocks, XModel.time.dt, XModel.cf, XModel.evolv_o);\n    //XiafrictionCPU(XParam, XModel.blocks, XModel.time.dt, XModel.cf, XModel.evolv, XModel.evolv_o);\n\n\n    //============================================\n    //Copy updated evolving variable back\n    cleanupCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.evolv);\n\n\n\n    if (!XForcing.Rain.inputfile.empty())\n    {\n        AddrainforcingImplicitCPU(XParam, XLoop, XModel.blocks, XForcing.Rain, XModel.evolv);\n    }\n\n    if (XParam.infiltration)\n    {\n        AddinfiltrationImplicitCPU(XParam, XLoop, XModel.blocks, XModel.il, XModel.cl, XModel.evolv, XModel.hgw);\n    }\n\n    if (XParam.VelThreshold &gt; 0.0)\n    {\n        TheresholdVelCPU(XParam, XModel.blocks, XModel.evolv);\n\n    }\n\n    //============================================\n    // Reset zb in halo from prolonggation injection\n    if (XParam.conserveElevation)\n    {\n        refine_linear(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    }\n\n\n}\ntemplate void FlowCPU&lt;float&gt;(Param XParam, Loop&lt;float&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;float&gt; XModel);\ntemplate void FlowCPU&lt;double&gt;(Param XParam, Loop&lt;double&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;double&gt; XModel);\n\n\n\n\ntemplate &lt;class T&gt; void HalfStepCPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel)\n{\n    if (XParam.atmpforcing)\n    {\n        //Update atm press forcing\n        AddPatmforcingCPU(XParam, XModel.blocks, XForcing.Atmp, XModel);\n\n        //Fill atmp halo\n        fillHaloC(XParam, XModel.blocks, XModel.Patm);\n\n\n        //Calc dpdx and dpdy\n        gradientC(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        gradientHalo(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n        refine_linear(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        gradientHalo(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n\n\n\n    }\n\n\n    //============================================\n    //  Fill the halo for gradient reconstruction\n    fillHalo(XParam, XModel.blocks, XModel.evolv, XModel.zb);\n\n    //============================================\n    // Reset DTmax\n    InitArrayBUQ(XParam, XModel.blocks, XLoop.hugeposval, XModel.time.dtmax);\n\n    //============================================\n    // Calculate gradient for evolving parameters\n    gradientCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.zb);\n\n    //============================================\n    // Flux and Source term reconstruction\n    // X- direction\n    if (XParam.engine == 1)\n    {\n        // X- direction\n        UpdateButtingerXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n\n        // Y- direction\n        UpdateButtingerYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n    }\n    else if (XParam.engine == 2)\n    {\n        // X- direction\n        updateKurgXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //AddSlopeSourceXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n\n        // Y- direction\n        updateKurgYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //AddSlopeSourceYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n    }\n    else if (XParam.engine == 3)\n    {\n        // X- direction\n        updateKurgXATMCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdx);\n        //AddSlopeSourceXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n\n        // Y- direction\n\n        updateKurgYATMCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdy);\n        //AddSlopeSourceYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n    }\n\n\n    //============================================\n    // Fill Halo for flux from fine to coarse\n    fillHalo(XParam, XModel.blocks, XModel.flux);\n\n    //============================================\n    // Reduce minimum timestep\n    XLoop.dt = double(CalctimestepCPU(XParam, XLoop, XModel.blocks, XModel.time));\n    XLoop.dtmax = XLoop.dt;\n    XModel.time.dt = T(XLoop.dt);\n\n\n    //============================================\n    // Update advection terms (dh dhu dhv) \n    updateEVCPU(XParam, XModel.blocks, XModel.evolv, XModel.flux, XModel.adv);\n\n    //============================================\n    // Add forcing (Rain, Wind)\n    //if (!XForcing.Rain.inputfile.empty())\n    //{\n    //  AddrainforcingCPU(XParam, XModel.blocks, XForcing.Rain, XModel.adv);\n    //}\n    if (!XForcing.UWind.inputfile.empty())//&amp;&amp; !XForcing.UWind.inputfile.empty()\n    {\n        AddwindforcingCPU(XParam, XModel.blocks, XForcing.UWind, XForcing.VWind, XModel.adv);\n    }\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        AddRiverForcing(XParam, XLoop, XForcing.rivers, XModel);\n    }\n\n    //============================================\n    //Update evolving variable by 1/2 time step\n    AdvkernelCPU(XParam, XModel.blocks, XModel.time.dt * T(0.5), XModel.zb, XModel.evolv, XModel.adv, XModel.evolv_o);\n\n    //============================================\n    // Add bottom friction\n\n    bottomfrictionCPU(XParam, XModel.blocks, XModel.time.dt, XModel.cf, XModel.evolv_o);\n    //XiafrictionCPU(XParam, XModel.blocks, XModel.time.dt, XModel.cf, XModel.evolv, XModel.evolv_o);\n\n\n    //============================================\n    //Copy updated evolving variable back\n    cleanupCPU(XParam, XModel.blocks, XModel.evolv_o, XModel.evolv);\n\n    if (!XForcing.Rain.inputfile.empty())\n    {\n        AddrainforcingImplicitCPU(XParam, XLoop, XModel.blocks, XForcing.Rain, XModel.evolv);\n    }\n  if (XParam.infiltration)\n    {\n        AddinfiltrationImplicitCPU(XParam, XLoop, XModel.blocks, XModel.il, XModel.cl, XModel.evolv, XModel.hgw);\n    }\n\n\n    if (XParam.VelThreshold &gt; 0.0)\n    {\n        TheresholdVelCPU(XParam, XModel.blocks, XModel.evolv);\n\n    }\n\n    //============================================\n    // Reset zb in halo from prolonggation injection\n    if (XParam.conserveElevation)\n    {\n        refine_linear(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    }\n\n\n}\ntemplate void HalfStepCPU&lt;float&gt;(Param XParam, Loop&lt;float&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;float&gt; XModel);\ntemplate void HalfStepCPU&lt;double&gt;(Param XParam, Loop&lt;double&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;double&gt; XModel);\n</code></pre>"},{"location":"BGFlood/_flow_c_p_u_8h/","title":"File FlowCPU.h","text":""},{"location":"BGFlood/_flow_c_p_u_8h/#file-flowcpuh","title":"File FlowCPU.h","text":"<p>FileList &gt; src &gt; FlowCPU.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Halo.h\"</code></li> <li><code>#include \"GridManip.h\"</code></li> <li><code>#include \"Gradients.h\"</code></li> <li><code>#include \"Kurganov.h\"</code></li> <li><code>#include \"Advection.h\"</code></li> <li><code>#include \"Friction.h\"</code></li> <li><code>#include \"Updateforcing.h\"</code></li> <li><code>#include \"Reimann.h\"</code></li> </ul>"},{"location":"BGFlood/_flow_c_p_u_8h/#public-functions","title":"Public Functions","text":"Type Name void FlowCPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel) Main CPU flow solver for the flood model. void HalfStepCPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel) Debugging flow step for the flood model."},{"location":"BGFlood/_flow_c_p_u_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_flow_c_p_u_8h/#function-flowcpu","title":"function FlowCPU","text":"<p>Main CPU flow solver for the flood model. </p><pre><code>template&lt;class T&gt;\nvoid FlowCPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Executes predictor and corrector steps, applies atmospheric, wind, and river forcing, updates advection and friction terms, and manages halo and gradient reconstruction for all blocks.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XLoop</code> Loop control and time stepping </li> <li><code>XForcing</code> Forcing data (atmospheric, wind, river, rain) </li> <li><code>XModel</code> Model data structure </li> </ul>"},{"location":"BGFlood/_flow_c_p_u_8h/#function-halfstepcpu","title":"function HalfStepCPU","text":"<p>Debugging flow step for the flood model. </p><pre><code>template&lt;class T&gt;\nvoid HalfStepCPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Runs a simplified flow step for debugging the main engine, including forcing, advection, friction, and halo/gradient reconstruction.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XLoop</code> Loop control and time stepping </li> <li><code>XForcing</code> Forcing data (atmospheric, wind, river, rain) </li> <li><code>XModel</code> Model data structure</li> </ul> <p>Debugging flow step This function was created to debug the main engine of the model </p> <p>The documentation for this class was generated from the following file <code>src/FlowCPU.h</code></p>"},{"location":"BGFlood/_flow_c_p_u_8h_source/","title":"File FlowCPU.h","text":""},{"location":"BGFlood/_flow_c_p_u_8h_source/#file-flowcpuh","title":"File FlowCPU.h","text":"<p>File List &gt; src &gt; FlowCPU.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef FLOWCPU_H\n#define FLOWCPU_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"Util_CPU.h\"\n#include \"MemManagement.h\"\n#include \"Halo.h\"\n#include \"GridManip.h\"\n#include \"Gradients.h\"\n#include \"Kurganov.h\"\n#include \"Advection.h\"\n#include \"Friction.h\"\n#include \"Updateforcing.h\"\n#include \"Reimann.h\"\n\n// End of global definition\ntemplate &lt;class T&gt; void FlowCPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel);\ntemplate &lt;class T&gt; void HalfStepCPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel);\n\n\n#endif\n</code></pre>"},{"location":"BGFlood/_flow_g_p_u_8cu/","title":"File FlowGPU.cu","text":""},{"location":"BGFlood/_flow_g_p_u_8cu/#file-flowgpucu","title":"File FlowGPU.cu","text":"<p>FileList &gt; src &gt; FlowGPU.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"FlowGPU.h\"</code></li> </ul>"},{"location":"BGFlood/_flow_g_p_u_8cu/#public-functions","title":"Public Functions","text":"Type Name void FlowGPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel) Main GPU flow solver for the flood model. template void FlowGPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; XModel)  template void FlowGPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; XModel)  void HalfStepGPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel) Debugging GPU flow step for the flood model. template void HalfStepGPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; XModel)  template void HalfStepGPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; XModel)  __global__ void reset_var (int halowidth, int * active, T resetval, T * Var) CUDA kernel to reset a variable array for all active blocks. template __global__ void reset_var&lt; double &gt; (int halowidth, int * active, double resetval, double * Var)  template __global__ void reset_var&lt; float &gt; (int halowidth, int * active, float resetval, float * Var)"},{"location":"BGFlood/_flow_g_p_u_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_flow_g_p_u_8cu/#function-flowgpu","title":"function FlowGPU","text":"<p>Main GPU flow solver for the flood model. </p><pre><code>template&lt;class T&gt;\nvoid FlowGPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Executes predictor and corrector steps, applies atmospheric, wind, and river forcing, updates advection and friction terms, and manages halo and gradient reconstruction for all blocks using CUDA kernels and streams.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XLoop</code> Loop control and time stepping </li> <li><code>XForcing</code> Forcing data (atmospheric, wind, river, rain) </li> <li><code>XModel</code> Model data structure </li> </ul>"},{"location":"BGFlood/_flow_g_p_u_8cu/#function-flowgpu-double","title":"function FlowGPU&lt; double &gt;","text":"<pre><code>template void FlowGPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_flow_g_p_u_8cu/#function-flowgpu-float","title":"function FlowGPU&lt; float &gt;","text":"<pre><code>template void FlowGPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_flow_g_p_u_8cu/#function-halfstepgpu","title":"function HalfStepGPU","text":"<p>Debugging GPU flow step for the flood model. </p><pre><code>template&lt;class T&gt;\nvoid HalfStepGPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Runs a simplified flow step for debugging the main engine, including forcing, advection, friction, and halo/gradient reconstruction using CUDA kernels and streams.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XLoop</code> Loop control and time stepping </li> <li><code>XForcing</code> Forcing data (atmospheric, wind, river, rain) </li> <li><code>XModel</code> Model data structure </li> </ul>"},{"location":"BGFlood/_flow_g_p_u_8cu/#function-halfstepgpu-double","title":"function HalfStepGPU&lt; double &gt;","text":"<pre><code>template void HalfStepGPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_flow_g_p_u_8cu/#function-halfstepgpu-float","title":"function HalfStepGPU&lt; float &gt;","text":"<pre><code>template void HalfStepGPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_flow_g_p_u_8cu/#function-reset_var","title":"function reset_var","text":"<p>CUDA kernel to reset a variable array for all active blocks. </p><pre><code>template&lt;class T&gt;\n__global__ void reset_var (\n    int halowidth,\n    int * active,\n    T resetval,\n    T * Var\n) \n</code></pre> <p>Sets all values in the variable array to the specified reset value for each block and cell.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Halo width </li> <li><code>active</code> Array of active block indices </li> <li><code>resetval</code> Value to set </li> <li><code>Var</code> Variable array to reset </li> </ul>"},{"location":"BGFlood/_flow_g_p_u_8cu/#function-reset_var-double","title":"function reset_var&lt; double &gt;","text":"<pre><code>template __global__ void reset_var&lt; double &gt; (\n    int halowidth,\n    int * active,\n    double resetval,\n    double * Var\n) \n</code></pre>"},{"location":"BGFlood/_flow_g_p_u_8cu/#function-reset_var-float","title":"function reset_var&lt; float &gt;","text":"<pre><code>template __global__ void reset_var&lt; float &gt; (\n    int halowidth,\n    int * active,\n    float resetval,\n    float * Var\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/FlowGPU.cu</code></p>"},{"location":"BGFlood/_flow_g_p_u_8cu_source/","title":"File FlowGPU.cu","text":""},{"location":"BGFlood/_flow_g_p_u_8cu_source/#file-flowgpucu","title":"File FlowGPU.cu","text":"<p>File List &gt; src &gt; FlowGPU.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"FlowGPU.h\"\n\ntemplate &lt;class T&gt; void FlowGPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel)\n{\n    //============================================\n    // construct threads abnd block parameters\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    // for flux reconstruction the loop overlap the right(or top for the y direction) halo\n    dim3 blockDimKX(XParam.blkwidth + XParam.halowidth, XParam.blkwidth, 1);\n    dim3 blockDimKY(XParam.blkwidth, XParam.blkwidth + XParam.halowidth, 1);\n\n    //dim3 blockDimHalo(XParam.blkwidth + XParam.halowidth*2, XParam.blkwidth + XParam.halowidth * 2, 1);\n\n    //============================================\n    // Build cuda threads for multitasking on the GPU\n    for (int i = 0; i &lt; XLoop.num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;XLoop.streams[i]));\n    }\n\n    if (XParam.atmpforcing)\n    {\n        //Update atm press forcing\n        AddPatmforcingGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XForcing.Atmp, XModel);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        //Fill atmp halo\n        cudaStream_t atmpstreams[1];\n        CUDA_CHECK(cudaStreamCreate(&amp;atmpstreams[0]));\n        fillHaloGPU(XParam, XModel.blocks, atmpstreams[0], XModel.Patm);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        cudaStreamDestroy(atmpstreams[0]);\n\n        //Calc dpdx and dpdy\n\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n\n        CUDA_CHECK(cudaDeviceSynchronize());\n        gradientHaloGPU(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        //\n\n\n        refine_linearGPU(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientHaloGPU(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n\n    }\n\n\n    //============================================\n    // Predictor step in reimann solver\n    //============================================\n\n    //============================================\n    //  Fill the halo for gradient reconstruction\n    fillHaloGPU(XParam, XModel.blocks, XModel.evolv, XModel.zb);\n\n\n    //============================================\n    // Reset DTmax\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth,XModel.blocks.active,XLoop.hugeposval,XModel.time.dtmax);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //============================================\n    // Calculate gradient for evolving parameters for predictor step\n    gradientGPUnew(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.zb);\n\n    //============================================\n    // Synchronise all ongoing streams\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n\n    //============================================\n    // Flux and Source term reconstruction\n    if (XParam.engine == 1)\n    {\n        // X- direction\n        UpdateButtingerXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //updateKurgXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        // Y- direction\n        UpdateButtingerYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //updateKurgYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0, XLoop.streams[1] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        // //updateKurgY &lt;&lt;&lt; XLoop.gridDim, XLoop.blockDim, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XLoop.epsilon, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax);\n\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else if (XParam.engine == 2)\n    {\n        // X- direction\n        updateKurgXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        // Y- direction\n        updateKurgYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0, XLoop.streams[1] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        // //updateKurgY &lt;&lt;&lt; XLoop.gridDim, XLoop.blockDim, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XLoop.epsilon, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax);\n\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else if (XParam.engine == 3)\n    {\n        // \n        updateKurgXATMGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdx);\n        // //AddSlopeSourceXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        // Y- direction\n        updateKurgYATMGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdy);\n        // //AddSlopeSourceYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0, XLoop.streams[1] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        // //updateKurgY &lt;&lt;&lt; XLoop.gridDim, XLoop.blockDim, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XLoop.epsilon, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax);\n\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    //============================================\n    // Fill Halo for flux from fine to coarse\n    fillHaloGPU(XParam, XModel.blocks, XModel.flux);\n\n    //============================================\n    // Reduce minimum timestep\n    XLoop.dt = double(CalctimestepGPU(XParam, XLoop, XModel.blocks, XModel.time));\n    XLoop.dtmax = XLoop.dt;\n\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n        FlowbndFlux(XParam, XLoop.totaltime + XLoop.dt * 0.5, XModel.blocks, XForcing.bndseg[iseg], XForcing.Atmp, XModel.evolv, XModel.flux);\n    }\n\n    //bndmaskGPU(XParam, XModel.blocks, XModel.evolv, XModel.flux);\n\n\n    XModel.time.dt = T(XLoop.dt);\n\n    //============================================\n    // Update advection terms (dh dhu dhv) \n    updateEVGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.flux, XModel.adv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //============================================\n    // Add forcing (Rain, Wind)\n    //if (!XForcing.Rain.inputfile.empty())\n    //{\n    //  AddrainforcingGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XForcing.Rain, XModel.adv);\n    //}\n    if (!XForcing.UWind.inputfile.empty())//&amp;&amp; !XForcing.UWind.inputfile.empty()\n    {\n        AddwindforcingGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XForcing.UWind, XForcing.VWind, XModel.adv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        AddRiverForcing(XParam, XLoop, XForcing.rivers, XModel);\n    }\n\n    //============================================\n    //Update evolving variable by 1/2 time step\n    AdvkernelGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.time.dt*T(0.5), XModel.zb, XModel.evolv, XModel.adv, XModel.evolv_o);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    //============================================\n    // Corrector step in reimann solver\n    //============================================\n\n    //============================================\n    //  Fill the halo for gradient reconstruction also wall boundary for masked block\n    fillHaloGPU(XParam, XModel.blocks, XModel.evolv_o, XModel.zb);\n\n    //============================================\n    // Calculate gradient for evolving parameters\n    gradientGPUnew(XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //============================================\n    // Flux and Source term reconstruction\n    if (XParam.engine == 1)\n    {\n        // X- direction\n        UpdateButtingerXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //updateKurgXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        // Y- direction\n        UpdateButtingerYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //updateKurgYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else if (XParam.engine == 2)\n    {\n        // X- direction\n        updateKurgXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        // Y- direction\n        updateKurgYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else if (XParam.engine == 3)\n    {\n        //\n        //\n        updateKurgXATMGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdx);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        // Y- direction\n        updateKurgYATMGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    //============================================\n    // Fill Halo for flux from fine to coarse\n    fillHaloGPU(XParam, XModel.blocks, XModel.flux);\n\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n        FlowbndFlux(XParam, XLoop.totaltime + XLoop.dt , XModel.blocks, XForcing.bndseg[iseg], XForcing.Atmp, XModel.evolv, XModel.flux);\n    }\n\n    //bndmaskGPU(XParam, XModel.blocks, XModel.evolv, XModel.flux);\n\n    //============================================\n    // Update advection terms (dh dhu dhv) \n    updateEVGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.flux, XModel.adv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    //============================================\n    // Add forcing (Rain, Wind)\n    //if (!XForcing.Rain.inputfile.empty())\n    //{\n    //  AddrainforcingGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XForcing.Rain, XModel.adv);\n    //}\n    if (!XForcing.UWind.inputfile.empty())//&amp;&amp; !XForcing.UWind.inputfile.empty()\n    {\n        AddwindforcingGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XForcing.UWind, XForcing.VWind, XModel.adv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        AddRiverForcing(XParam, XLoop, XForcing.rivers, XModel);\n    }\n\n\n    //============================================\n    //Update evolving variable by 1 full time step\n    AdvkernelGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.time.dt, XModel.zb, XModel.evolv, XModel.adv, XModel.evolv_o);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    //============================================\n    // Add bottom friction\n\n    bottomfrictionGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.time.dt, XModel.cf, XModel.evolv_o);\n    //XiafrictionGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.time.dt, XModel.cf, XModel.evolv, XModel.evolv_o);\n\n\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //============================================\n    //Copy updated evolving variable back\n    cleanupGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.evolv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    if (!XForcing.Rain.inputfile.empty())\n    {\n        AddrainforcingImplicitGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam,XLoop, XModel.blocks, XForcing.Rain, XModel.evolv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    if (XParam.infiltration)\n    {\n        AddinfiltrationImplicitGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XLoop, XModel.blocks, XModel.il, XModel.cl, XModel.evolv, XModel.hgw);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    if (XParam.VelThreshold &gt; 0.0)\n    {\n        TheresholdVelGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    //============================================\n    // Reset zb in prolongation halo\n    if (XParam.conserveElevation)\n    {\n        refine_linearGPU(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    }\n\n    for (int i = 0; i &lt; XLoop.num_streams; i++)\n    {\n        cudaStreamDestroy(XLoop.streams[i]);\n    }\n\n}\ntemplate void FlowGPU&lt;float&gt;(Param XParam, Loop&lt;float&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;float&gt; XModel);\ntemplate void FlowGPU&lt;double&gt;(Param XParam, Loop&lt;double&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;double&gt; XModel);\n\ntemplate &lt;class T&gt; void HalfStepGPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel)\n{\n    //============================================\n    // construct threads abnd block parameters\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    // for flux reconstruction the loop overlap the right(or top for the y direction) halo\n    dim3 blockDimKX(XParam.blkwidth + XParam.halowidth, XParam.blkwidth, 1);\n    dim3 blockDimKY(XParam.blkwidth, XParam.blkwidth + XParam.halowidth, 1);\n\n    //dim3 blockDimHalo(XParam.blkwidth + XParam.halowidth*2, XParam.blkwidth + XParam.halowidth * 2, 1);\n\n    //============================================\n    // Build cuda threads for multitasking on the GPU\n    for (int i = 0; i &lt; XLoop.num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;XLoop.streams[i]));\n    }\n\n    if (XParam.atmpforcing)\n    {\n        //Update atm press forcing\n        AddPatmforcingGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XForcing.Atmp, XModel);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        //Fill atmp halo\n        cudaStream_t atmpstreams[1];\n        CUDA_CHECK(cudaStreamCreate(&amp;atmpstreams[0]));\n        fillHaloGPU(XParam, XModel.blocks, atmpstreams[0], XModel.Patm);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        cudaStreamDestroy(atmpstreams[0]);\n\n        //Calc dpdx and dpdy\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        gradientHaloGPU(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        //\n\n\n        refine_linearGPU(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientHaloGPU(XParam, XModel.blocks, XModel.Patm, XModel.datmpdx, XModel.datmpdy);\n\n\n    }\n\n\n    //============================================\n    // Predictor step in reimann solver\n    //============================================\n\n    //============================================\n    //  Fill the halo for gradient reconstruction\n    fillHaloGPU(XParam, XModel.blocks, XModel.evolv, XModel.zb);\n\n\n    //============================================\n    // Reset DTmax\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel.blocks.active, XLoop.hugeposval, XModel.time.dtmax);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //============================================\n    // Calculate gradient for evolving parameters for predictor step\n    gradientGPUnew(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.zb);\n\n    //============================================\n    // Synchronise all ongoing streams\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n\n    //============================================\n    // Flux and Source term reconstruction\n    if (XParam.engine == 1)\n    {\n        // X- direction\n        UpdateButtingerXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //updateKurgXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        // Y- direction\n        UpdateButtingerYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        //updateKurgYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0, XLoop.streams[1] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        // //updateKurgY &lt;&lt;&lt; XLoop.gridDim, XLoop.blockDim, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XLoop.epsilon, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax);\n\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else if (XParam.engine == 2)\n    {\n        // X- direction\n        updateKurgXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        // Y- direction\n        updateKurgYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n        // //AddSlopeSourceYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0, XLoop.streams[1] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        // //updateKurgY &lt;&lt;&lt; XLoop.gridDim, XLoop.blockDim, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XLoop.epsilon, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax);\n\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else if (XParam.engine == 3)\n    {\n        // \n        updateKurgXATMGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdx);\n        // //AddSlopeSourceXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        // Y- direction\n        updateKurgYATMGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb, XModel.Patm, XModel.datmpdy);\n        // //AddSlopeSourceYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0, XLoop.streams[1] &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n        // //updateKurgY &lt;&lt;&lt; XLoop.gridDim, XLoop.blockDim, 0, XLoop.streams[0] &gt;&gt;&gt; (XParam, XLoop.epsilon, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax);\n\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    //============================================\n    // Fill Halo for flux from fine to coarse\n    fillHaloGPU(XParam, XModel.blocks, XModel.flux);\n\n    //============================================\n    // Reduce minimum timestep\n    XLoop.dt = double(CalctimestepGPU(XParam, XLoop, XModel.blocks, XModel.time));\n    XLoop.dtmax = XLoop.dt;\n\n\n    XModel.time.dt = T(XLoop.dt);\n\n    //============================================\n    // Update advection terms (dh dhu dhv) \n    updateEVGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.flux, XModel.adv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //============================================\n    // Add forcing (Rain, Wind)\n    //if (!XForcing.Rain.inputfile.empty())\n    //{\n    //  AddrainforcingGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XForcing.Rain, XModel.adv);\n    //}\n    if (!XForcing.UWind.inputfile.empty())//&amp;&amp; !XForcing.UWind.inputfile.empty()\n    {\n        AddwindforcingGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XForcing.UWind, XForcing.VWind, XModel.adv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        AddRiverForcing(XParam, XLoop, XForcing.rivers, XModel);\n    }\n\n    //============================================\n    //Update evolving variable by 1/2 time step\n    AdvkernelGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.time.dt * T(0.5), XModel.zb, XModel.evolv, XModel.adv, XModel.evolv_o);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //============================================\n    // Add bottom friction\n\n    bottomfrictionGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.time.dt, XModel.cf, XModel.evolv_o);\n    //XiafrictionGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.time.dt, XModel.cf, XModel.evolv, XModel.evolv_o);\n\n\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //============================================\n    //Copy updated evolving variable back\n    cleanupGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv_o, XModel.evolv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    if (!XForcing.Rain.inputfile.empty())\n    {\n        AddrainforcingImplicitGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XLoop, XModel.blocks, XForcing.Rain, XModel.evolv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    if (XParam.VelThreshold &gt; 0.0)\n    {\n        TheresholdVelGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    //============================================\n    // Reset zb in prolongation halo\n    if (XParam.conserveElevation)\n    {\n        refine_linearGPU(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    }\n\n    for (int i = 0; i &lt; XLoop.num_streams; i++)\n    {\n        cudaStreamDestroy(XLoop.streams[i]);\n    }\n\n}\ntemplate void HalfStepGPU&lt;float&gt;(Param XParam, Loop&lt;float&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;float&gt; XModel);\ntemplate void HalfStepGPU&lt;double&gt;(Param XParam, Loop&lt;double&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;double&gt; XModel);\n\n\ntemplate &lt;class T&gt; __global__ void reset_var(int halowidth, int* active, T resetval, T* Var)\n{\n\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = active[ibl];\n\n    int n = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    //int n= (ix + halowidth) + (iy + halowidth) * blkmemwidth + ib * blksize;\n    Var[n] = resetval;\n}\ntemplate __global__ void reset_var&lt;float&gt;(int halowidth, int* active, float resetval, float* Var);\ntemplate __global__ void reset_var&lt;double&gt;(int halowidth, int* active, double resetval, double* Var);\n</code></pre>"},{"location":"BGFlood/_flow_g_p_u_8h/","title":"File FlowGPU.h","text":""},{"location":"BGFlood/_flow_g_p_u_8h/#file-flowgpuh","title":"File FlowGPU.h","text":"<p>FileList &gt; src &gt; FlowGPU.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Gradients.h\"</code></li> <li><code>#include \"Kurganov.h\"</code></li> <li><code>#include \"Advection.h\"</code></li> <li><code>#include \"Friction.h\"</code></li> <li><code>#include \"Updateforcing.h\"</code></li> <li><code>#include \"Reimann.h\"</code></li> <li><code>#include \"Boundary.h\"</code></li> </ul>"},{"location":"BGFlood/_flow_g_p_u_8h/#public-functions","title":"Public Functions","text":"Type Name void FlowGPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel) Main GPU flow solver for the flood model. void HalfStepGPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel) Debugging GPU flow step for the flood model. __global__ void reset_var (int halowidth, int * active, T resetval, T * Var) CUDA kernel to reset a variable array for all active blocks."},{"location":"BGFlood/_flow_g_p_u_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_flow_g_p_u_8h/#function-flowgpu","title":"function FlowGPU","text":"<p>Main GPU flow solver for the flood model. </p><pre><code>template&lt;class T&gt;\nvoid FlowGPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Executes predictor and corrector steps, applies atmospheric, wind, and river forcing, updates advection and friction terms, and manages halo and gradient reconstruction for all blocks using CUDA kernels and streams.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XLoop</code> Loop control and time stepping </li> <li><code>XForcing</code> Forcing data (atmospheric, wind, river, rain) </li> <li><code>XModel</code> Model data structure </li> </ul>"},{"location":"BGFlood/_flow_g_p_u_8h/#function-halfstepgpu","title":"function HalfStepGPU","text":"<p>Debugging GPU flow step for the flood model. </p><pre><code>template&lt;class T&gt;\nvoid HalfStepGPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Runs a simplified flow step for debugging the main engine, including forcing, advection, friction, and halo/gradient reconstruction using CUDA kernels and streams.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XLoop</code> Loop control and time stepping </li> <li><code>XForcing</code> Forcing data (atmospheric, wind, river, rain) </li> <li><code>XModel</code> Model data structure </li> </ul>"},{"location":"BGFlood/_flow_g_p_u_8h/#function-reset_var","title":"function reset_var","text":"<p>CUDA kernel to reset a variable array for all active blocks. </p><pre><code>template&lt;class T&gt;\n__global__ void reset_var (\n    int halowidth,\n    int * active,\n    T resetval,\n    T * Var\n) \n</code></pre> <p>Sets all values in the variable array to the specified reset value for each block and cell.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Halo width </li> <li><code>active</code> Array of active block indices </li> <li><code>resetval</code> Value to set </li> <li><code>Var</code> Variable array to reset </li> </ul> <p>The documentation for this class was generated from the following file <code>src/FlowGPU.h</code></p>"},{"location":"BGFlood/_flow_g_p_u_8h_source/","title":"File FlowGPU.h","text":""},{"location":"BGFlood/_flow_g_p_u_8h_source/#file-flowgpuh","title":"File FlowGPU.h","text":"<p>File List &gt; src &gt; FlowGPU.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef FLOWGPU_H\n#define FLOWGPU_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"Util_CPU.h\"\n#include \"MemManagement.h\"\n#include \"Gradients.h\"\n#include \"Kurganov.h\"\n#include \"Advection.h\"\n#include \"Friction.h\"\n#include \"Updateforcing.h\"\n#include \"Reimann.h\"\n#include \"Boundary.h\"\n\ntemplate &lt;class T&gt; void FlowGPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel);\n\ntemplate &lt;class T&gt; __global__ void reset_var(int halowidth, int* active, T resetval, T* Var);\n\ntemplate &lt;class T&gt; void HalfStepGPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_flow_m_l_g_p_u_8cu/","title":"File FlowMLGPU.cu","text":""},{"location":"BGFlood/_flow_m_l_g_p_u_8cu/#file-flowmlgpucu","title":"File FlowMLGPU.cu","text":"<p>FileList &gt; src &gt; FlowMLGPU.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"FlowMLGPU.h\"</code></li> </ul>"},{"location":"BGFlood/_flow_m_l_g_p_u_8cu/#public-functions","title":"Public Functions","text":"Type Name void FlowMLGPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel)  template void FlowMLGPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; XModel)  template void FlowMLGPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; XModel)"},{"location":"BGFlood/_flow_m_l_g_p_u_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_flow_m_l_g_p_u_8cu/#function-flowmlgpu","title":"function FlowMLGPU","text":"<pre><code>template&lt;class T&gt;\nvoid FlowMLGPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_flow_m_l_g_p_u_8cu/#function-flowmlgpu-double","title":"function FlowMLGPU&lt; double &gt;","text":"<pre><code>template void FlowMLGPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_flow_m_l_g_p_u_8cu/#function-flowmlgpu-float","title":"function FlowMLGPU&lt; float &gt;","text":"<pre><code>template void FlowMLGPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; XModel\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/FlowMLGPU.cu</code></p>"},{"location":"BGFlood/_flow_m_l_g_p_u_8cu_source/","title":"File FlowMLGPU.cu","text":""},{"location":"BGFlood/_flow_m_l_g_p_u_8cu_source/#file-flowmlgpucu","title":"File FlowMLGPU.cu","text":"<p>File List &gt; src &gt; FlowMLGPU.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"FlowMLGPU.h\"\n\ntemplate &lt;class T&gt; void FlowMLGPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel)\n{\n    //============================================\n    // construct threads abnd block parameters\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n    // for flux reconstruction the loop overlap the right(or top for the y direction) halo\n    dim3 blockDimKX(XParam.blkwidth + XParam.halowidth, XParam.blkwidth, 1);\n    dim3 blockDimKY(XParam.blkwidth, XParam.blkwidth + XParam.halowidth, 1);\n\n    // For halo corners\n    dim3 blockDimHC(4, 1, 1);\n\n    // Fill halo for Fu and Fv\n    dim3 blockDimHaloLR(2, XParam.blkwidth, 1);\n    //dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDimHaloLR(ceil(XParam.nblk / 2), 1, 1);\n\n    dim3 blockDimHaloBT(XParam.blkwidth, 2, 1);\n    dim3 gridDimHaloBT(ceil(XParam.nblk / 2), 1, 1);\n\n\n    // fill halo for zs,h,u and v \n\n    //============================================\n    //  Fill the halo for gradient reconstruction &amp; Recalculate zs\n    fillHaloGPU(XParam, XModel.blocks, XModel.evolv, XModel.zb);\n\n    // calculate grad for dhdx dhdy only\n\n    //============================================\n    // Calculate gradient for evolving parameters for predictor step\n    gradientGPUnew(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.zb);\n    //gradientSMC &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.evolv.h, XModel.grad.dhdx, XModel.grad.dhdy);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    //============================================\n    // Synchronise all ongoing streams\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Set max timestep\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel.blocks.active, XLoop.hugeposval, XModel.time.dtmax);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Compute face value\n    CalcfaceValX &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (T(XLoop.dtmax), XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.fluxml, XModel.time.dtmax, XModel.zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    CalcfaceValY &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (T(XLoop.dtmax), XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.fluxml, XModel.time.dtmax, XModel.zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Timestep reduction\n    XLoop.dt = double(CalctimestepGPU(XParam, XLoop, XModel.blocks, XModel.time));\n    XLoop.dtmax = XLoop.dt;\n\n\n\n    //Fill flux Halo for ha and hf\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.hfu);\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.hfv);\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.hau);\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.hav);\n\n    HaloFluxGPULRnew &lt;&lt; &lt; gridDimHaloLR, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hfu);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    HaloFluxGPUBTnew &lt;&lt; &lt;gridDimHaloBT, blockDimHaloBT, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hfv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    HaloFluxGPULRnew &lt;&lt; &lt; gridDimHaloLR, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hau);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    HaloFluxGPUBTnew &lt;&lt; &lt;gridDimHaloBT, blockDimHaloBT, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hav);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Acceleration\n    // Pressure\n    pressureML &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XModel.blocks, T(XLoop.dt), XModel.evolv, XModel.grad, XModel.fluxml);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Check hu/hv\n    CheckadvecMLY &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XModel.blocks, T(XLoop.dt), XModel.evolv, XModel.grad, XModel.fluxml);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    CheckadvecMLX &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XModel.blocks, T(XLoop.dt), XModel.evolv, XModel.grad, XModel.fluxml);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Fill halo u and v calc grd for u and v and fill halo for hu and hv\n    // \n\n    fillHaloGPU(XParam, XModel.blocks, XModel.evolv.u);\n    fillHaloGPU(XParam, XModel.blocks, XModel.evolv.v);\n\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.hu);\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.hv);\n\n\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n        FlowbndFluxML(XParam, XLoop.totaltime + XLoop.dt, XModel.blocks, XForcing.bndseg[iseg], XForcing.Atmp, XModel.evolv, XModel.fluxml);\n    }\n    //HaloFluxGPULRnew &lt;&lt; &lt; gridDimHaloLR, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hu);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    //HaloFluxGPUBTnew &lt;&lt; &lt;gridDimHaloBT, blockDimHaloBT, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hv);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    //HaloFluxGPULRnew &lt;&lt; &lt; gridDimHaloLR, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hv);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    //HaloFluxGPUBTnew &lt;&lt; &lt;gridDimHaloBT, blockDimHaloBT, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hu);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradientSMC &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.evolv.u, XModel.grad.dudx, XModel.grad.dudy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradientSMC &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.evolv.v, XModel.grad.dvdx, XModel.grad.dvdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    fillHaloGPU(XParam, XModel.blocks, XModel.grad.dudx);\n    fillHaloGPU(XParam, XModel.blocks, XModel.grad.dudy);\n    fillHaloGPU(XParam, XModel.blocks, XModel.grad.dvdx);\n    fillHaloGPU(XParam, XModel.blocks, XModel.grad.dvdy);\n\n\n    fillCornersGPU &lt;&lt;&lt; gridDim, blockDimHC, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.fluxml.hu);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    fillCornersGPU &lt;&lt; &lt; gridDim, blockDimHC, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    fillCornersGPU &lt;&lt; &lt; gridDim, blockDimHC, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hfu);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    fillCornersGPU &lt;&lt; &lt; gridDim, blockDimHC, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.hfv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    fillCornersGPU &lt;&lt; &lt; gridDim, blockDimHC, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.evolv.u);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    fillCornersGPU &lt;&lt; &lt; gridDim, blockDimHC, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.evolv.v);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //hv hfv u hu hfu v\n\n\n\n    // Advection\n    AdvecFluxML &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XModel.blocks, T(XLoop.dt), XModel.evolv, XModel.grad, XModel.fluxml);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.Fux);\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.Fvx);\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.Fuy);\n    fillHaloGPU(XParam, XModel.blocks, XModel.fluxml.Fvy);\n\n    //HaloFluxGPULRnew &lt;&lt; &lt; gridDimHaloLR, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.Fu);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    //HaloFluxGPUBTnew &lt;&lt; &lt;gridDimHaloBT, blockDimHaloBT, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.fluxml.Fv);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n\n\n    AdvecEv &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XModel.blocks, T(XLoop.dt), XModel.evolv, XModel.grad, XModel.fluxml);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n\n\n\n    bottomfrictionGPU &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XModel.blocks, T(XLoop.dt), XModel.cf, XModel.evolv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        //Add River ML\n    }\n\n\n    if (!XForcing.Rain.inputfile.empty())\n    {\n        AddrainforcingImplicitGPU &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XLoop, XModel.blocks, XForcing.Rain, XModel.evolv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    if (XParam.infiltration)\n    {\n        AddinfiltrationImplicitGPU &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XLoop, XModel.blocks, XModel.il, XModel.cl, XModel.evolv, XModel.hgw);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    if (XParam.VelThreshold &gt; 0.0)\n    {\n        TheresholdVelGPU &lt;&lt; &lt; gridDim, blockDim, 0 &gt;&gt; &gt; (XParam, XModel.blocks, XModel.evolv);\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    // Recalculate zs based on h and zb\n    CleanupML &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n}\ntemplate void FlowMLGPU&lt;float&gt;(Param XParam, Loop&lt;float&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;float&gt; XModel);\ntemplate void FlowMLGPU&lt;double&gt;(Param XParam, Loop&lt;double&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;double&gt; XModel);\n</code></pre>"},{"location":"BGFlood/_flow_m_l_g_p_u_8h/","title":"File FlowMLGPU.h","text":""},{"location":"BGFlood/_flow_m_l_g_p_u_8h/#file-flowmlgpuh","title":"File FlowMLGPU.h","text":"<p>FileList &gt; src &gt; FlowMLGPU.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Multilayer.h\"</code></li> <li><code>#include \"FlowGPU.h\"</code></li> <li><code>#include \"Advection.h\"</code></li> </ul>"},{"location":"BGFlood/_flow_m_l_g_p_u_8h/#public-functions","title":"Public Functions","text":"Type Name void FlowMLGPU (Param XParam, Loop&lt; T &gt; &amp; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel)"},{"location":"BGFlood/_flow_m_l_g_p_u_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_flow_m_l_g_p_u_8h/#function-flowmlgpu","title":"function FlowMLGPU","text":"<pre><code>template&lt;class T&gt;\nvoid FlowMLGPU (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/FlowMLGPU.h</code></p>"},{"location":"BGFlood/_flow_m_l_g_p_u_8h_source/","title":"File FlowMLGPU.h","text":""},{"location":"BGFlood/_flow_m_l_g_p_u_8h_source/#file-flowmlgpuh","title":"File FlowMLGPU.h","text":"<p>File List &gt; src &gt; FlowMLGPU.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef FLOWMLGPU_H\n#define FLOWMLGPU_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"Util_CPU.h\"\n#include \"MemManagement.h\"\n#include \"Multilayer.h\"\n#include \"FlowGPU.h\"\n#include \"Advection.h\"\n\ntemplate &lt;class T&gt; void FlowMLGPU(Param XParam, Loop&lt;T&gt;&amp; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel);\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_forcing_8h/","title":"File Forcing.h","text":""},{"location":"BGFlood/_forcing_8h/#file-forcingh","title":"File Forcing.h","text":"<p>FileList &gt; src &gt; Forcing.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Input.h\"</code></li> </ul>"},{"location":"BGFlood/_forcing_8h/#classes","title":"Classes","text":"Type Name class AOIinfo struct DynForcingP &lt;class T&gt; struct Forcing &lt;class T&gt; struct StaticForcingP &lt;class T&gt; struct TexSetP struct bndTexP class bndparam class bndsegment class bndsegmentside class deformmap &lt;class T&gt; class forcingmap <p>The documentation for this class was generated from the following file <code>src/Forcing.h</code></p>"},{"location":"BGFlood/_forcing_8h_source/","title":"File Forcing.h","text":""},{"location":"BGFlood/_forcing_8h_source/#file-forcingh","title":"File Forcing.h","text":"<p>File List &gt; src &gt; Forcing.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef FORCING_H\n#define FORCING_H\n\n#include \"General.h\"\n#include \"Input.h\"\n\nstruct TexSetP\n{\n    float xo, yo, dx, dy; // used to calculate coordinates insode the device function\n    float nowvalue;\n    bool uniform;\n    cudaArray* CudArr;\n    cudaChannelFormatDesc channelDesc = cudaCreateChannelDesc(32, 0, 0, 0, cudaChannelFormatKindFloat);\n    //texture&lt;float, 2, cudaReadModeElementType&gt; tex;\n    struct cudaResourceDesc resDesc;\n    struct cudaTextureDesc texDesc;\n    cudaTextureObject_t tex = 0;\n};\n\nstruct bndTexP\n{\n    TexSetP WLS;\n    TexSetP Uvel;\n    TexSetP Vvel;\n};\n\nclass forcingmap : public inputmap {\npublic:\n\n    int nt;\n    bool uniform = false;\n    double to, tmax;\n    double dt;\n    int instep = 0; // last step that was read\n    std::string inputfile;\n    std::vector&lt;Windin&gt; unidata; // only used if uniform forcing\n    double nowvalue; // temporary storage for value at a given time\n    TexSetP GPU;\n\n};\n\ntemplate &lt;class T&gt;\nclass deformmap : public inputmap\n{\n    //Deform are maps to applie to both zs and zb; this is often co-seismic vertical deformation used to generate tsunami initial wave\n    // Here you can spread the deformation across a certain amount of time and apply it at any point in the model.\n    // To modify only zs, use the same structure with the key word \"cavity\"\npublic:\n    double startime = 0.0;\n    double duration = 0.0;\n    bool iscavity = false;\n    T* val;\n\n    T clampedge = 0.0;\n    TexSetP GPU;\n};\n\n\ntemplate &lt;class T&gt;\nstruct DynForcingP: public forcingmap\n{\n    T *now;\n    T *before, *after;\n    T* val; // useful for reading from file\n\n    // gpu version of these array\n    T* now_g;\n    T* before_g, * after_g;\n\n    T clampedge=0.0;\n\n};\n\n\n\n\n\ntemplate &lt;class T&gt;\nstruct StaticForcingP : public inputmap\n{\n    T *val;\n\n};\n\n//bnd\nclass bndparam {\npublic:\n    std::vector&lt;SLTS&gt; data;\n    bool on = false;\n    //If changing this default value, please change documentation later on the file\n    int type = 1; // 0:Wall (no slip); 1:neumann (zeros gradient) [Default]; 2:sealevel dirichlet; 3: Absorbing 1D 4: Absorbing 2D (not yet implemented)\n    std::string inputfile;\n    int nbnd; // number of forcing bnds along the side (&gt;=1 is side is on)\n    int nblk = 0; //number of blocks where this bnd applies\n    int side = 0; // 0: top bnd, 1: rightbnd, 2: bot bnd, 3, Left bnd\n    int isright = 0;\n    int istop = 0;\n    bndTexP GPU;\n    int* blks; // array of block where bnd applies \n    int* blks_g; // Also needed for GPU (because it should be a gpu allocated pointer) This is not pretty at all! In the future maybe using pagelocked memory or other new type may be beneficial \n    float* qmean;\n    float* qmean_g;\n};\n\nclass bndsegmentside {\npublic:\n    int nblk=0;\n    int* blk;\n    int* blk_g;\n    float* qmean;\n    float* qmean_g;\n    int isright = 0;\n    int istop = 0;\n    // 8 digit binary where 1 is a mask and 0 is not a mask with the first digit represent the left bottom side the rest is clockwise (i.e.left-bot left-top, top-left, top-right, right-top, right-bot, bot-right, bot-left)\n    //int* side; // e.g. 11000000 for the entire left side being a mask\n};\n\n\nclass bndsegment {\npublic:\n    std::vector&lt;Windin&gt; data;\n    std::string inputfile;\n    Polygon poly;\n    std::string polyfile;\n    bool on = false;\n    bool uniform = true;\n    //If changing this default value, please change documentation later on the file\n    int type = 1; // 0:Wall (no slip); 1:neumann (zeros gradient) [Default]; 2:sealevel dirichlet; 3: Absorbing 1D 4: Absorbing 2D (not yet implemented)\n\n    int nbnd; // number of forcing bnds along the side (&gt;=1 is side is on) \n    int nblk = 0; //number of blocks where this bnd applies\n\n\n\n\n    DynForcingP&lt;float&gt; WLmap;\n\n    bndsegmentside left;\n    bndsegmentside right;\n    bndsegmentside top;\n    bndsegmentside bot;\n\n};\n\n\nclass AOIinfo {\npublic:\n    std::string file;\n    Polygon poly;\n    bool active=false;\n};\n\n\ntemplate &lt;class T&gt;\nstruct Forcing\n{\n    DynForcingP&lt;T&gt; UWind;\n    DynForcingP&lt;T&gt; VWind;\n    //Forcing the Wind;\n    /*Spacially varying (.nc): 2 files are given, 1st file is U wind and second is V wind (no rotation of the data is performed)\n    Spacially uniform (.txt): 1 file is given then a 3 column file is expected, showing time, windspeed and direction.\n    Wind direction is rotated (later) to the grid direction (using grdalpha input parameter)\n    Ex: Wind = mywind.nc?uw,mywind.nc?vw\n    Ex: Wind = MyWind.txt\n    Default: None\n    */\n\n\n    DynForcingP&lt;T&gt; Rain;\n    /* This allow to force a time varying, space varying rain intensity on the model, in mm/h.\n    Spacially varrying (rain map), a netcdf file is expected (with the variable associated to the rain after \"?\").\n    Spacially uniform: the rain is forced using a time serie using a 2 column values table containing time (not necessary unformly distributed) and rain.\n    Ex: rain=rain_forcing.txt \n    Ex: rain=rain_forcing.nc?RainIntensity\n    Default: None\n    */\n\n    DynForcingP&lt;T&gt; Atmp;\n    /* Atmospheric forcing file. The forcing pressure is expected to be in Pa and the effect of the atmospheric pressure gradient is calculated as the difference to a reference pressure Paref, converted to a height using the Pa2m parameter.\n    Ex: Atmp=AtmosphericPressure.nc?p\n    Default: None\n    */\n\n\n    std::vector&lt;StaticForcingP&lt;T&gt;&gt; Bathy; //Should be a vector at some point\n    /* Bathymetry/Topography input, ONLY NECESSARY INPUT\n    Different format are accepted: .asc, .nc, .md. , the grid must be regular with growing coordinate.\n    This grid will define the extend of the model domain and model resolution (if not inform by the user).\n    The coordinate can be cartesian or spherical (still in development).\n    A list of file can also be use to provide a thiner resolution localy by using the key word each time on a different line.\n    The first file will be use to define the domain area and base resolution but the following file\n    will be used during the refinement process.\n    Ex: bathy=Westport_DEM_2020.nc?z\n    Ex: topo=Westport_DEM_2020.asc\n    Default: None but input NECESSARY\n    */\n\n\n    std::vector&lt;StaticForcingP&lt;T&gt;&gt; cf;\n    /*Bottom friction coefficient map (associated to the chosen bottom friction model: n, z0, ...)\n    A list of roughness map can be provide. At any grid point, the last one defined will be used.\n    Ex: cf=0.001;\n    Ex: cf=bottom_friction.nc?bfc;\n    Default: (see constant in parameters)\n    */\n\n    StaticForcingP&lt;T&gt; il;\n    /*Initial Rain loss coefficient map (in mm)\n    Ex: il=rain_loss.nc?initial_loss;\n    Default: (see constant in parameters)\n    */\n\n    StaticForcingP&lt;T&gt; cl;\n    /*Continuous Rain loss coefficient map (in mm/h)\n    Ex: cl=rain_loss.nc?continuous_loss;\n    Default: (see constant in parameters)\n    */\n\n    std::vector&lt;StaticForcingP&lt;int&gt;&gt; targetadapt;\n\n    std::vector&lt;deformmap&lt;T&gt;&gt; deform;\n    /*Deform are maps to apply to both zs and zb; this is often co-seismic vertical deformation used to generate tsunami initial wave\n    Here you can spread the deformation across a certain amount of time and apply it at any point in the model.\n    Ex: deform = myDeform.nc?z_def,3.0,10.0;\n    Ex: deform = *filename*, *time of initial rupture*, *rising time*;\n    Default: None\n    */\n\n\n    std::vector&lt;River&gt; rivers;\n    /*The river is added as a vertical discharge (m3/s) on a chosen area (the user input consists in a time serie and a rectangular area definition).\n    The whole cells containing the corners of the area will be included in the area, no horizontal velocity is applied.\n    To add multiple rivers, just add different lines in the input file (one by river).\n    Ex: river = Votualevu_R.txt,1867430,1867455,3914065,3914090;\n    Ex: river = *Fluxfile*, *xstart*, *xend*, *ystart*, *yend*;\n    Default: None\n    */\n\n    bndparam left;\n    /* 0:Wall (no slip); 1:neumann (zeros gradient) [Default]; 2:sealevel dirichlet; 3: Absorbing 1D 4: Absorbing 2D (not yet implemented)\n    For type 2 and 3 boundary, a file need to be added to determine the vaules at the boundary. This file will consist in a first column containing time (with possibly variable time steps) and forcing values in the following columns (1 column of values corresponding to a constant value along the boundary, 2 columns correspond to values at boundary edges with linear evolution in between, n columns correspond to n regularly spaced values applied along the boundary)\n    Ex: left = 0;\n    Ex: left = leftBnd.txt,2;\n    Default: 1\n    */\n\n    bndparam right;\n    /*Same as left boundary\n    Ex: right = 0;\n    Ex: right = rightBnd.txt,2;\n    Default: 1\n    */\n\n    bndparam top;\n    /*Same as left boundary\n    Ex: top = 0;\n    Ex: top = topBnd.txt,2;\n    Default: 1\n    */\n\n    bndparam bot;\n    /*Same as left boundary\n    Ex: bot = 0;\n    Ex: bot = botBnd.txt,2;\n    Default: 1\n    */\n\n\n    std::vector&lt;bndsegment&gt; bndseg;\n    /* boundary segment; Only applies to AOI bnds\n    Ex: bndseg=area.txt,waterlevelforcing,1;\n    Default: none\n    */\n\n    AOIinfo AOI;\n    /*Area of interest polygon\n    Ex: AOI=myarea.gmt;\n    the input file is a text file with 2 columns containing the coordinate of a closed polygon (last line==first line)\n    Default: N/A\n    */\n\n};\n\n\n\n\n\n\n\n\n\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_friction_8cu/","title":"File Friction.cu","text":""},{"location":"BGFlood/_friction_8cu/#file-frictioncu","title":"File Friction.cu","text":"<p>FileList &gt; src &gt; Friction.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Friction.h\"</code></li> </ul>"},{"location":"BGFlood/_friction_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ void TheresholdVelCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEvolv) CPU routine for enforcing a velocity threshold. template __host__ void TheresholdVelCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEvolv)  template __host__ void TheresholdVelCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEvolv)  __global__ void TheresholdVelGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEvolv) CUDA kernel for enforcing a velocity threshold. Function Used to prevent crazy velocity on the GPU. The function wraps the main function for the GPU. Updates velocity components to ensure they do not exceed a specified threshold. template __global__ void TheresholdVelGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEvolv)  template __global__ void TheresholdVelGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEvolv)  __host__ __device__ bool ThresholdVelocity (T Threshold, T &amp; u, T &amp; v) Function Used to prevent crazy velocity. __host__ void XiafrictionCPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * cf, EvolvingP&lt; T &gt; XEvolv, EvolvingP&lt; T &gt; XEvolv_o) CPU routine for applying bottom friction following Xia &amp; Lang (2018). template __host__ void XiafrictionCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, double * cf, EvolvingP&lt; double &gt; XEvolv, EvolvingP&lt; double &gt; XEvolv_o)  template __host__ void XiafrictionCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, float * cf, EvolvingP&lt; float &gt; XEvolv, EvolvingP&lt; float &gt; XEvolv_o)  __global__ void XiafrictionGPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * cf, EvolvingP&lt; T &gt; XEvolv, EvolvingP&lt; T &gt; XEvolv_o) CUDA kernel for applying Xia &amp; Lang (2018) bottom friction to all active blocks. template __global__ void XiafrictionGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, double * cf, EvolvingP&lt; double &gt; XEvolv, EvolvingP&lt; double &gt; XEvolv_o)  template __global__ void XiafrictionGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, float * cf, EvolvingP&lt; float &gt; XEvolv, EvolvingP&lt; float &gt; XEvolv_o)  __host__ void bottomfrictionCPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * cf, EvolvingP&lt; T &gt; XEvolv) CPU routine for applying bottom friction to all active blocks. template __host__ void bottomfrictionCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, double * cf, EvolvingP&lt; double &gt; XEvolv)  template __host__ void bottomfrictionCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, float * cf, EvolvingP&lt; float &gt; XEvolv)  __global__ void bottomfrictionGPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * cf, EvolvingP&lt; T &gt; XEvolv) CUDA kernel for applying bottom friction to all active blocks. template __global__ void bottomfrictionGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, double * cf, EvolvingP&lt; double &gt; XEvolv)  template __global__ void bottomfrictionGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, float * cf, EvolvingP&lt; float &gt; XEvolv)  __host__ __device__ T manningfriction (T g, T hi, T n) Manning friction model. __host__ __device__ T smartfriction (T hi, T zo) Smart friction model for roughness height."},{"location":"BGFlood/_friction_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_friction_8cu/#function-theresholdvelcpu","title":"function TheresholdVelCPU","text":"<p>CPU routine for enforcing a velocity threshold. </p><pre><code>template&lt;class T&gt;\n__host__ void TheresholdVelCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEvolv\n) \n</code></pre> <p>Updates velocity components to ensure they do not exceed a specified threshold. Function Used to prevent crazy velocity on the CPU</p> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEvolv</code> Evolving variables structure </li> </ul>"},{"location":"BGFlood/_friction_8cu/#function-theresholdvelcpu-double","title":"function TheresholdVelCPU&lt; double &gt;","text":"<pre><code>template __host__ void TheresholdVelCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/_friction_8cu/#function-theresholdvelcpu-float","title":"function TheresholdVelCPU&lt; float &gt;","text":"<pre><code>template __host__ void TheresholdVelCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/_friction_8cu/#function-theresholdvelgpu","title":"function TheresholdVelGPU","text":"<p>CUDA kernel for enforcing a velocity threshold. Function Used to prevent crazy velocity on the GPU. The function wraps the main function for the GPU. Updates velocity components to ensure they do not exceed a specified threshold. </p><pre><code>template&lt;class T&gt;\n__global__ void TheresholdVelGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEvolv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEvolv</code> Evolving variables structure </li> </ul>"},{"location":"BGFlood/_friction_8cu/#function-theresholdvelgpu-double","title":"function TheresholdVelGPU&lt; double &gt;","text":"<pre><code>template __global__ void TheresholdVelGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/_friction_8cu/#function-theresholdvelgpu-float","title":"function TheresholdVelGPU&lt; float &gt;","text":"<pre><code>template __global__ void TheresholdVelGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/_friction_8cu/#function-thresholdvelocity","title":"function ThresholdVelocity","text":"<p>Function Used to prevent crazy velocity. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ bool ThresholdVelocity (\n    T Threshold,\n    T &amp; u,\n    T &amp; v\n) \n</code></pre> <p>The function scale velocities so it doesn't exceeds a given threshold. Default threshold is/should be 16.0m/s</p> <p>Parameters:</p> <ul> <li><code>Threshold</code> Velocity threshold </li> <li><code>u</code> Velocity component in x direction </li> <li><code>v</code> Velocity component in y direction </li> </ul> <p>Returns:</p> <p>true if velocity was above threshold and has been scaled down, false otherwise </p>"},{"location":"BGFlood/_friction_8cu/#function-xiafrictioncpu","title":"function XiafrictionCPU","text":"<p>CPU routine for applying bottom friction following Xia &amp; Lang (2018). </p><pre><code>template&lt;class T&gt;\n__host__ void XiafrictionCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * cf,\n    EvolvingP &lt; T &gt; XEvolv,\n    EvolvingP &lt; T &gt; XEvolv_o\n) \n</code></pre> <p>Updates velocity components using the Xia &amp; Lang friction model for each cell in all blocks, using both current and previous evolving variables. Reference: Xia and Lang (2018), https://doi.org/10.1016/j.advwatres.2018.05.004</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>dt</code> Time step </li> <li><code>cf</code> Friction coefficient array </li> <li><code>XEvolv</code> Current evolving variables structure </li> <li><code>XEvolv_o</code> Previous evolving variables structure </li> </ul>"},{"location":"BGFlood/_friction_8cu/#function-xiafrictioncpu-double","title":"function XiafrictionCPU&lt; double &gt;","text":"<pre><code>template __host__ void XiafrictionCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    double * cf,\n    EvolvingP &lt; double &gt; XEvolv,\n    EvolvingP &lt; double &gt; XEvolv_o\n) \n</code></pre>"},{"location":"BGFlood/_friction_8cu/#function-xiafrictioncpu-float","title":"function XiafrictionCPU&lt; float &gt;","text":"<pre><code>template __host__ void XiafrictionCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    float * cf,\n    EvolvingP &lt; float &gt; XEvolv,\n    EvolvingP &lt; float &gt; XEvolv_o\n) \n</code></pre>"},{"location":"BGFlood/_friction_8cu/#function-xiafrictiongpu","title":"function XiafrictionGPU","text":"<p>CUDA kernel for applying Xia &amp; Lang (2018) bottom friction to all active blocks. </p><pre><code>template&lt;class T&gt;\n__global__ void XiafrictionGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * cf,\n    EvolvingP &lt; T &gt; XEvolv,\n    EvolvingP &lt; T &gt; XEvolv_o\n) \n</code></pre> <p>Updates velocity components using the Xia &amp; Lang friction model for each cell in all blocks, using both current and previous evolving variables.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>dt</code> Time step </li> <li><code>cf</code> Friction coefficient array </li> <li><code>XEvolv</code> Current evolving variables structure </li> <li><code>XEvolv_o</code> Previous evolving variables structure </li> </ul>"},{"location":"BGFlood/_friction_8cu/#function-xiafrictiongpu-double","title":"function XiafrictionGPU&lt; double &gt;","text":"<pre><code>template __global__ void XiafrictionGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    double * cf,\n    EvolvingP &lt; double &gt; XEvolv,\n    EvolvingP &lt; double &gt; XEvolv_o\n) \n</code></pre>"},{"location":"BGFlood/_friction_8cu/#function-xiafrictiongpu-float","title":"function XiafrictionGPU&lt; float &gt;","text":"<pre><code>template __global__ void XiafrictionGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    float * cf,\n    EvolvingP &lt; float &gt; XEvolv,\n    EvolvingP &lt; float &gt; XEvolv_o\n) \n</code></pre>"},{"location":"BGFlood/_friction_8cu/#function-bottomfrictioncpu","title":"function bottomfrictionCPU","text":"<p>CPU routine for applying bottom friction to all active blocks. </p><pre><code>template&lt;class T&gt;\n__host__ void bottomfrictionCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * cf,\n    EvolvingP &lt; T &gt; XEvolv\n) \n</code></pre> <p>Updates velocity components using the specified friction model (default, smart, or Manning) for each cell in all blocks.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>dt</code> Time step </li> <li><code>cf</code> Friction coefficient array </li> <li><code>XEvolv</code> Evolving variables structure </li> </ul>"},{"location":"BGFlood/_friction_8cu/#function-bottomfrictioncpu-double","title":"function bottomfrictionCPU&lt; double &gt;","text":"<pre><code>template __host__ void bottomfrictionCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    double * cf,\n    EvolvingP &lt; double &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/_friction_8cu/#function-bottomfrictioncpu-float","title":"function bottomfrictionCPU&lt; float &gt;","text":"<pre><code>template __host__ void bottomfrictionCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    float * cf,\n    EvolvingP &lt; float &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/_friction_8cu/#function-bottomfrictiongpu","title":"function bottomfrictionGPU","text":"<p>CUDA kernel for applying bottom friction to all active blocks. </p><pre><code>template&lt;class T&gt;\n__global__ void bottomfrictionGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * cf,\n    EvolvingP &lt; T &gt; XEvolv\n) \n</code></pre> <p>Updates velocity components using the specified friction model (default, smart, or Manning) for each cell in all blocks.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>dt</code> Time step </li> <li><code>cf</code> Friction coefficient array </li> <li><code>XEvolv</code> Evolving variables structure </li> </ul>"},{"location":"BGFlood/_friction_8cu/#function-bottomfrictiongpu-double","title":"function bottomfrictionGPU&lt; double &gt;","text":"<pre><code>template __global__ void bottomfrictionGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    double * cf,\n    EvolvingP &lt; double &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/_friction_8cu/#function-bottomfrictiongpu-float","title":"function bottomfrictionGPU&lt; float &gt;","text":"<pre><code>template __global__ void bottomfrictionGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    float * cf,\n    EvolvingP &lt; float &gt; XEvolv\n) \n</code></pre>"},{"location":"BGFlood/_friction_8cu/#function-manningfriction","title":"function manningfriction","text":"<p>Manning friction model. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T manningfriction (\n    T g,\n    T hi,\n    T n\n) \n</code></pre> <p>Computes friction coefficient using Manning's equation based on gravity, water depth, and Manning's n.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>g</code> Gravity </li> <li><code>hi</code> Water depth </li> <li><code>n</code> Manning's n </li> </ul> <p>Returns:</p> <p>Friction coefficient </p>"},{"location":"BGFlood/_friction_8cu/#function-smartfriction","title":"function smartfriction","text":"<p>Smart friction model for roughness height. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T smartfriction (\n    T hi,\n    T zo\n) \n</code></pre> <p>Computes friction coefficient using a log-law based on water depth and roughness height.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>hi</code> Water depth </li> <li><code>zo</code> Roughness height </li> </ul> <p>Returns:</p> <p>Friction coefficient </p> <p>The documentation for this class was generated from the following file <code>src/Friction.cu</code></p>"},{"location":"BGFlood/_friction_8cu_source/","title":"File Friction.cu","text":""},{"location":"BGFlood/_friction_8cu_source/#file-frictioncu","title":"File Friction.cu","text":"<p>File List &gt; src &gt; Friction.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Friction.h\"\n\n\n\ntemplate &lt;class T&gt; __global__ void bottomfrictionGPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt, T* cf,EvolvingP&lt;T&gt; XEvolv)\n{\n    // Shear stress equation:\n    // Taub=cf*rho*U*sqrt(U^2+V^2)\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    T eps = T(XParam.eps);\n    T g = T(XParam.g);\n\n    int frictionmodel = XParam.frictionmodel;\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n\n    T normu, hi, ui, vi;\n\n\n\n    hi = XEvolv.h[i];\n    ui = XEvolv.u[i];\n    vi = XEvolv.v[i];\n    if (hi &gt; eps)\n    {\n        normu = sqrt(ui * ui + vi * vi);\n\n        T cfi;\n        if (frictionmodel == 0)\n        {\n            cfi = cf[i];\n        }\n        else if (frictionmodel == 1)//Smart friction formulation\n        {\n            cfi = smartfriction(hi, cf[i]);\n\n        }\n        else if (frictionmodel == -1)// Manning friction formulation\n        {\n            cfi = manningfriction(g, hi, cf[i]);\n\n        }\n\n        T tb = cfi * normu / hi * dt;\n        XEvolv.u[i] = ui / (T(1.0) + tb);\n        XEvolv.v[i] = vi / (T(1.0) + tb);\n    }\n\n\n\n}\ntemplate __global__ void bottomfrictionGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock,float dt, float* cf, EvolvingP&lt;float&gt; XEvolv);\ntemplate __global__ void bottomfrictionGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock,double dt, double* cf, EvolvingP&lt;double&gt; XEvolv);\n\n\n\ntemplate &lt;class T&gt; __host__ void bottomfrictionCPU(Param XParam, BlockP&lt;T&gt; XBlock,T dt, T* cf, EvolvingP&lt;T&gt; XEvolv)\n{\n    T eps = T(XParam.eps);\n    T g = T(XParam.g);\n\n\n\n    T hi, ui, vi,normu;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                hi = XEvolv.h[i];\n                ui = XEvolv.u[i];\n                vi = XEvolv.v[i];\n                if (hi &gt; eps)\n                {\n                    normu = sqrt(ui * ui + vi * vi);\n\n                    T cfi;\n                    if (XParam.frictionmodel == 0)\n                    {\n                        cfi = cf[i];\n                    }\n                    else if (XParam.frictionmodel == 1)//Smart friction formulation\n                    {\n\n                        cfi = smartfriction(hi, cf[i]);\n\n                    }\n                    else if (XParam.frictionmodel == -1)// Manning friction formulation\n                    {\n                        T n = cf[i];\n                        cfi = manningfriction(g, hi, n);\n\n\n                    }\n\n                    T tb = cfi * normu / hi * dt;\n                    XEvolv.u[i] = ui / (T(1.0) + tb);\n                    XEvolv.v[i] = vi / (T(1.0) + tb);\n                }\n            }\n        }\n    }\n\n\n}\ntemplate __host__ void bottomfrictionCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock,float dt, float* cf, EvolvingP&lt;float&gt; XEvolv);\ntemplate __host__ void bottomfrictionCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock,double dt, double* cf, EvolvingP&lt;double&gt; XEvolv);\n\ntemplate &lt;class T&gt; __host__ void XiafrictionCPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt, T* cf, EvolvingP&lt;T&gt; XEvolv, EvolvingP&lt;T&gt; XEvolv_o)\n{\n    T eps = T(XParam.eps);\n    T g = T(XParam.g);\n\n\n\n    T hi, ho, ui, vi, normu;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                ho = XEvolv.h[i];\n                hi = XEvolv_o.h[i];\n                ui = XEvolv_o.u[i];\n                vi = XEvolv_o.v[i];\n                if (hi &gt; eps)\n                {\n                    normu = sqrt(ui * ui + vi * vi);\n\n                    T cfi = cf[i]; //if (XParam.frictionmodel == 0)\n                    if (XParam.frictionmodel == 1)//Smart friction formulation\n                    {\n\n                        cfi = smartfriction(hi, cf[i]);\n\n                    }\n                    else if (XParam.frictionmodel == -1)// Manning friction formulation\n                    {\n                        T n = cf[i];\n                        cfi = manningfriction(g, hi, n);\n\n\n                    }\n\n                    T tb = cfi * normu * hi/(ho*ho) * dt;\n                    if (tb &gt;= T(1e-10))\n                    {\n                        XEvolv_o.u[i] = (ui - ui * sqrt(T(1.0) + T(4.0) * tb)) / (T(-2.0) * tb);\n                        XEvolv_o.v[i] = (vi - vi * sqrt(T(1.0) + T(4.0) * tb)) / (T(-2.0) * tb);\n                    }\n\n                }\n            }\n        }\n    }\n\n\n}\n\ntemplate __host__ void XiafrictionCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock,float dt, float* cf, EvolvingP&lt;float&gt; XEvolv, EvolvingP&lt;float&gt; XEvolv_o);\ntemplate __host__ void XiafrictionCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock,double dt, double* cf, EvolvingP&lt;double&gt; XEvolv, EvolvingP&lt;double&gt; XEvolv_o);\n\ntemplate &lt;class T&gt; __global__ void XiafrictionGPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt, T* cf, EvolvingP&lt;T&gt; XEvolv, EvolvingP&lt;T&gt; XEvolv_o)\n{\n    // Shear stress equation:\n    // Taub=cf*rho*U*sqrt(U^2+V^2)\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    T eps = T(XParam.eps);\n    T g = T(XParam.g);\n\n    //int frictionmodel = XParam.frictionmodel;\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n\n    T normu,ho, hi, ui, vi;\n\n\n\n\n    ho = XEvolv.h[i];\n    hi = XEvolv_o.h[i];\n    ui = XEvolv_o.u[i];\n    vi = XEvolv_o.v[i];\n    if (hi &gt; eps) //SHould this be both ho and hi &gt;eps ?\n    {\n        normu = sqrt(ui * ui + vi * vi);\n\n        T cfi = cf[i]; //if (XParam.frictionmodel == 0)\n        if (XParam.frictionmodel == 1)//Smart friction formulation\n        {\n\n            cfi = smartfriction(hi, cf[i]);\n\n        }\n        else if (XParam.frictionmodel == -1)// Manning friction formulation\n        {\n            T n = cf[i];\n            cfi = manningfriction(g, hi, n);\n\n\n        }\n\n        T tb = cfi * normu * hi / (ho * ho) * dt;\n        if (tb &gt;= T(1e-10))\n        {\n            XEvolv_o.u[i] = (ui - ui * sqrt(T(1.0) + T(4.0) * tb)) / (T(-2.0) * tb);\n            XEvolv_o.v[i] = (vi - vi * sqrt(T(1.0) + T(4.0) * tb)) / (T(-2.0) * tb);\n        }\n\n    }\n\n\n\n}\ntemplate __global__ void XiafrictionGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float dt, float* cf, EvolvingP&lt;float&gt; XEvolv, EvolvingP&lt;float&gt; XEvolv_o);\ntemplate __global__ void XiafrictionGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double dt, double* cf, EvolvingP&lt;double&gt; XEvolv, EvolvingP&lt;double&gt; XEvolv_o);\n\n\ntemplate &lt;class T&gt; __host__ __device__ T smartfriction(T hi,T zo)\n{\n    T cfi;\n    T ee = T(2.71828182845905);\n\n    T Hbar = hi / zo;\n    if (Hbar &lt;= ee)\n    {\n        cfi = T(1.0) / (T(0.46) * Hbar);\n    }\n    else\n    {\n        cfi = T(1.0) / (T(2.5) * (log(Hbar) - T(1.0) + T(1.359) / Hbar));\n    }\n    cfi = cfi * cfi; //\n\n    return cfi;\n}\n\ntemplate &lt;class T&gt; __host__ __device__ T manningfriction(T g, T hi, T n)\n{\n    T cfi= g * n * n / cbrt(hi);\n    return cfi;\n}\n\n\ntemplate &lt;class T&gt; __global__ void TheresholdVelGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEvolv)\n{\n\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    bool bustedThreshold = false;\n\n\n    T ui, vi;\n\n\n    ui = XEvolv.u[i];\n    vi = XEvolv.v[i];\n\n    bustedThreshold = ThresholdVelocity(T(XParam.VelThreshold), ui, vi);\n\n    if (bustedThreshold)\n    {\n        XEvolv.u[i] = ui;\n        XEvolv.v[i] = vi;\n    }\n\n\n\n\n}\ntemplate __global__ void TheresholdVelGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEvolv);\ntemplate __global__ void TheresholdVelGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEvolv);\n\ntemplate &lt;class T&gt; __host__ void TheresholdVelCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEvolv)\n{\n\n    T ui, vi;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                bool bustedThreshold = false;\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                ui = XEvolv.u[i];\n\n                vi = XEvolv.v[i];\n\n                bustedThreshold = ThresholdVelocity(T(XParam.VelThreshold), ui, vi);\n\n                if (bustedThreshold)\n                {\n                    log(\"Velocity Threshold exceeded!\");\n                }\n                XEvolv.u[i] = ui;\n\n                XEvolv.v[i] = vi;\n            }\n        }\n    }\n}\ntemplate __host__ void TheresholdVelCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEvolv);\ntemplate __host__ void TheresholdVelCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEvolv);\n\ntemplate &lt;class T&gt; __host__ __device__ bool ThresholdVelocity(T Threshold, T&amp; u, T&amp; v)\n{\n    T normvel = sqrt(u * u + v * v);\n\n    bool alert = normvel &gt; Threshold;\n\n    if (alert)\n    {\n        u /= normvel / Threshold;\n        v /= normvel / Threshold;\n    }\n    return alert;\n}\n</code></pre>"},{"location":"BGFlood/_friction_8h/","title":"File Friction.h","text":""},{"location":"BGFlood/_friction_8h/#file-frictionh","title":"File Friction.h","text":"<p>FileList &gt; src &gt; Friction.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> </ul>"},{"location":"BGFlood/_friction_8h/#public-functions","title":"Public Functions","text":"Type Name __host__ void TheresholdVelCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEvolv) CPU routine for enforcing a velocity threshold. __global__ void TheresholdVelGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEvolv) CUDA kernel for enforcing a velocity threshold. Function Used to prevent crazy velocity on the GPU. The function wraps the main function for the GPU. Updates velocity components to ensure they do not exceed a specified threshold. __host__ __device__ bool ThresholdVelocity (T Threshold, T &amp; u, T &amp; v) Function Used to prevent crazy velocity. __host__ void XiafrictionCPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * cf, EvolvingP&lt; T &gt; XEvolv, EvolvingP&lt; T &gt; XEvolv_o) CPU routine for applying bottom friction following Xia &amp; Lang (2018). __global__ void XiafrictionGPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * cf, EvolvingP&lt; T &gt; XEvolv, EvolvingP&lt; T &gt; XEvolv_o) CUDA kernel for applying Xia &amp; Lang (2018) bottom friction to all active blocks. __host__ void bottomfrictionCPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * cf, EvolvingP&lt; T &gt; XEvolv) CPU routine for applying bottom friction to all active blocks. __global__ void bottomfrictionGPU (Param XParam, BlockP&lt; T &gt; XBlock, T dt, T * cf, EvolvingP&lt; T &gt; XEvolv) CUDA kernel for applying bottom friction to all active blocks. __host__ __device__ T manningfriction (T g, T hi, T n) Manning friction model. __host__ __device__ T smartfriction (T hi, T zo) Smart friction model for roughness height."},{"location":"BGFlood/_friction_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_friction_8h/#function-theresholdvelcpu","title":"function TheresholdVelCPU","text":"<p>CPU routine for enforcing a velocity threshold. </p><pre><code>template&lt;class T&gt;\n__host__ void TheresholdVelCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEvolv\n) \n</code></pre> <p>Updates velocity components to ensure they do not exceed a specified threshold. Function Used to prevent crazy velocity on the CPU</p> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEvolv</code> Evolving variables structure </li> </ul>"},{"location":"BGFlood/_friction_8h/#function-theresholdvelgpu","title":"function TheresholdVelGPU","text":"<p>CUDA kernel for enforcing a velocity threshold. Function Used to prevent crazy velocity on the GPU. The function wraps the main function for the GPU. Updates velocity components to ensure they do not exceed a specified threshold. </p><pre><code>template&lt;class T&gt;\n__global__ void TheresholdVelGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEvolv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XEvolv</code> Evolving variables structure </li> </ul>"},{"location":"BGFlood/_friction_8h/#function-thresholdvelocity","title":"function ThresholdVelocity","text":"<p>Function Used to prevent crazy velocity. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ bool ThresholdVelocity (\n    T Threshold,\n    T &amp; u,\n    T &amp; v\n) \n</code></pre> <p>The function scale velocities so it doesn't exceeds a given threshold. Default threshold is/should be 16.0m/s</p> <p>Parameters:</p> <ul> <li><code>Threshold</code> Velocity threshold </li> <li><code>u</code> Velocity component in x direction </li> <li><code>v</code> Velocity component in y direction </li> </ul> <p>Returns:</p> <p>true if velocity was above threshold and has been scaled down, false otherwise </p>"},{"location":"BGFlood/_friction_8h/#function-xiafrictioncpu","title":"function XiafrictionCPU","text":"<p>CPU routine for applying bottom friction following Xia &amp; Lang (2018). </p><pre><code>template&lt;class T&gt;\n__host__ void XiafrictionCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * cf,\n    EvolvingP &lt; T &gt; XEvolv,\n    EvolvingP &lt; T &gt; XEvolv_o\n) \n</code></pre> <p>Updates velocity components using the Xia &amp; Lang friction model for each cell in all blocks, using both current and previous evolving variables. Reference: Xia and Lang (2018), https://doi.org/10.1016/j.advwatres.2018.05.004</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>dt</code> Time step </li> <li><code>cf</code> Friction coefficient array </li> <li><code>XEvolv</code> Current evolving variables structure </li> <li><code>XEvolv_o</code> Previous evolving variables structure </li> </ul>"},{"location":"BGFlood/_friction_8h/#function-xiafrictiongpu","title":"function XiafrictionGPU","text":"<p>CUDA kernel for applying Xia &amp; Lang (2018) bottom friction to all active blocks. </p><pre><code>template&lt;class T&gt;\n__global__ void XiafrictionGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * cf,\n    EvolvingP &lt; T &gt; XEvolv,\n    EvolvingP &lt; T &gt; XEvolv_o\n) \n</code></pre> <p>Updates velocity components using the Xia &amp; Lang friction model for each cell in all blocks, using both current and previous evolving variables.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>dt</code> Time step </li> <li><code>cf</code> Friction coefficient array </li> <li><code>XEvolv</code> Current evolving variables structure </li> <li><code>XEvolv_o</code> Previous evolving variables structure </li> </ul>"},{"location":"BGFlood/_friction_8h/#function-bottomfrictioncpu","title":"function bottomfrictionCPU","text":"<p>CPU routine for applying bottom friction to all active blocks. </p><pre><code>template&lt;class T&gt;\n__host__ void bottomfrictionCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * cf,\n    EvolvingP &lt; T &gt; XEvolv\n) \n</code></pre> <p>Updates velocity components using the specified friction model (default, smart, or Manning) for each cell in all blocks.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>dt</code> Time step </li> <li><code>cf</code> Friction coefficient array </li> <li><code>XEvolv</code> Evolving variables structure </li> </ul>"},{"location":"BGFlood/_friction_8h/#function-bottomfrictiongpu","title":"function bottomfrictionGPU","text":"<p>CUDA kernel for applying bottom friction to all active blocks. </p><pre><code>template&lt;class T&gt;\n__global__ void bottomfrictionGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    T * cf,\n    EvolvingP &lt; T &gt; XEvolv\n) \n</code></pre> <p>Updates velocity components using the specified friction model (default, smart, or Manning) for each cell in all blocks.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>dt</code> Time step </li> <li><code>cf</code> Friction coefficient array </li> <li><code>XEvolv</code> Evolving variables structure </li> </ul>"},{"location":"BGFlood/_friction_8h/#function-manningfriction","title":"function manningfriction","text":"<p>Manning friction model. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T manningfriction (\n    T g,\n    T hi,\n    T n\n) \n</code></pre> <p>Computes friction coefficient using Manning's equation based on gravity, water depth, and Manning's n.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>g</code> Gravity </li> <li><code>hi</code> Water depth </li> <li><code>n</code> Manning's n </li> </ul> <p>Returns:</p> <p>Friction coefficient </p>"},{"location":"BGFlood/_friction_8h/#function-smartfriction","title":"function smartfriction","text":"<p>Smart friction model for roughness height. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T smartfriction (\n    T hi,\n    T zo\n) \n</code></pre> <p>Computes friction coefficient using a log-law based on water depth and roughness height.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>hi</code> Water depth </li> <li><code>zo</code> Roughness height </li> </ul> <p>Returns:</p> <p>Friction coefficient </p> <p>The documentation for this class was generated from the following file <code>src/Friction.h</code></p>"},{"location":"BGFlood/_friction_8h_source/","title":"File Friction.h","text":""},{"location":"BGFlood/_friction_8h_source/#file-frictionh","title":"File Friction.h","text":"<p>File List &gt; src &gt; Friction.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef FRICTION_H\n#define FRICTION_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n\ntemplate &lt;class T&gt; __global__ void bottomfrictionGPU(Param XParam, BlockP&lt;T&gt; XBlock,T dt, T* cf, EvolvingP&lt;T&gt; XEvolv);\ntemplate &lt;class T&gt; __host__ void bottomfrictionCPU(Param XParam, BlockP&lt;T&gt; XBlock,T dt, T* cf, EvolvingP&lt;T&gt; XEvolv);\n\ntemplate &lt;class T&gt; __host__ void XiafrictionCPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt, T* cf, EvolvingP&lt;T&gt; XEvolv, EvolvingP&lt;T&gt; XEvolv_o);\ntemplate &lt;class T&gt; __global__ void XiafrictionGPU(Param XParam, BlockP&lt;T&gt; XBlock, T dt, T* cf, EvolvingP&lt;T&gt; XEvolv, EvolvingP&lt;T&gt; XEvolv_o);\n\ntemplate &lt;class T&gt; __host__ __device__ T smartfriction(T hi,T zo);\ntemplate &lt;class T&gt; __host__ __device__ T manningfriction(T g, T hi, T n);\n\ntemplate &lt;class T&gt; __host__ __device__ bool ThresholdVelocity(T Threshold, T&amp; u, T&amp; v);\n\ntemplate &lt;class T&gt; __global__ void TheresholdVelGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEvolv);\ntemplate &lt;class T&gt; __host__ void TheresholdVelCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEvolv);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_general_8h/","title":"File General.h","text":""},{"location":"BGFlood/_general_8h/#file-generalh","title":"File General.h","text":"<p>FileList &gt; src &gt; General.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"cuda_runtime.h\"</code></li> <li><code>#include \"device_launch_parameters.h\"</code></li> <li><code>#include &lt;stdio.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;math.h&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;netcdf.h&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;iomanip&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;limits&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"BGFlood/_general_8h/#macros","title":"Macros","text":"Type Name define pi <code>3.14159265</code>"},{"location":"BGFlood/_general_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"BGFlood/_general_8h/#define-pi","title":"define pi","text":"<pre><code>#define pi `3.14159265`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/General.h</code></p>"},{"location":"BGFlood/_general_8h_source/","title":"File General.h","text":""},{"location":"BGFlood/_general_8h_source/#file-generalh","title":"File General.h","text":"<p>File List &gt; src &gt; General.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef GENERAL_H\n#define GENERAL_H\n// includes, system\n\n#define pi 3.14159265\n\n#include \"cuda_runtime.h\"\n#include \"device_launch_parameters.h\"\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n#include &lt;cmath&gt;\n#include &lt;chrono&gt;\n#include &lt;ctime&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;netcdf.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n#include &lt;limits&gt; \n#include &lt;thread&gt;\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_gradients_8cu/","title":"File Gradients.cu","text":""},{"location":"BGFlood/_gradients_8cu/#file-gradientscu","title":"File Gradients.cu","text":"<p>FileList &gt; src &gt; Gradients.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Gradients.h\"</code></li> </ul>"},{"location":"BGFlood/_gradients_8cu/#public-functions","title":"Public Functions","text":"Type Name void WetsloperesetCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) CPU function to apply wet slope limiters to gradients of surface elevation. Adjusts gradients to prevent non-physical slopes in wet-dry transition zones. void WetsloperesetHaloBotCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) CPU function to reset the wet slope limiter at the bottom halo boundary. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. __global__ void WetsloperesetHaloBotGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) GPU kernel to reset the wet slope limiter at the bottom halo boundary. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. void WetsloperesetHaloLeftCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) CPU function to apply wet slope limiters to gradients of surface elevation at the left halo boundary. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. __global__ void WetsloperesetHaloLeftGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) Device kernel to apply wet slope limiters to gradients of surface elevation at the left halo boundary. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. void WetsloperesetHaloRightCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) CPU function to apply wet slope limiters to gradients of surface elevation at the right halo boundary. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. __global__ void WetsloperesetHaloRightGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) Device kernel to apply wet slope limiters to gradients of surface elevation at the right halo boundary. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. void WetsloperesetHaloTopCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) CPU function to reset the wet slope limiter at the top halo boundary. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. __global__ void WetsloperesetHaloTopGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) GPU kernel to reset the wet slope limiter at the top halo boundary. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. __global__ void WetsloperesetXGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) Device kernel to apply wet slope limiters to gradients of surface elevation in the x-direction. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. __global__ void WetsloperesetYGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) Device kernel to apply wet slope limiters to gradients of surface elevation in the y-direction. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. __global__ void gradient (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx, T * dady) Device kernel for calculating gradients for an evolving parameter using the minmod limiter. template __global__ void gradient&lt; double &gt; (int halowidth, int * active, int * level, double theta, double dx, double * a, double * dadx, double * dady)  template __global__ void gradient&lt; float &gt; (int halowidth, int * active, int * level, float theta, float dx, float * a, float * dadx, float * dady)  void gradientC (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) CPU function for calculating gradients using the minmod limiter. Computes spatial derivatives in x and y directions for a given variable. template void gradientC&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * a, double * dadx, double * dady)  template void gradientC&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * a, float * dadx, float * dady)  void gradientCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) CPU function to compute gradients for all evolving parameters, handle halo regions, and apply wet-dry fixes. Calculates spatial derivatives for height, surface elevation, and velocity components. Also manages halo regions and applies wet-dry fixes if necessary. template void gradientCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, double * zb)  template void gradientCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, float * zb)  void gradientGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) Entry point for gradient of evolving variables calculation on the GPU. template void gradientGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, double * zb)  template void gradientGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, float * zb)  void gradientGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) Alternative GPU gradient calculation using shared memory kernels and CUDA streams. template void gradientGPUnew&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, double * zb)  template void gradientGPUnew&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, float * zb)  void gradientHalo (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) CPU function to compute gradients at the halo boundaries of all active blocks. This function iterates over all active blocks and computes the gradients at their halo boundaries using finite difference approximations. void gradientHaloBot (Param XParam, BlockP&lt; T &gt; XBlock, int ib, int ix, T * a, T * dadx, T * dady) CPU function to compute the gradient at the bottom halo boundary of a specific block. This function calculates the x and y derivatives at the bottom edge of the block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. __global__ void gradientHaloBotGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU kernel to compute the gradient at the bottom halo boundary of blocks. This kernel calculates the x and y derivatives at the bottom edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. __global__ void gradientHaloBotGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU kernel to compute the gradient at the bottom halo boundary of blocks. This kernel calculates the x and y derivatives at the bottom edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. void gradientHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU function to compute gradients at the halo boundaries of all active blocks. This function launches CUDA kernels to compute the gradients at the halo boundaries of all active blocks using parallel processing. void gradientHaloGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU function to compute gradients at the halo boundaries of all active blocks using multiple CUDA streams. This function launches CUDA kernels in separate streams to compute the gradients at the halo boundaries of all active blocks, allowing for concurrent execution and improved performance. void gradientHaloLeft (Param XParam, BlockP&lt; T &gt; XBlock, int ib, int iy, T * a, T * dadx, T * dady) CPU function to compute the gradient at the left halo boundary of a specific block. This function calculates the x and y derivatives at the left edge of the block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. __global__ void gradientHaloLeftGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU kernel to compute the gradient at the left halo boundary of blocks. This kernel calculates the x and y derivatives at the left edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. __global__ void gradientHaloLeftGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU kernel to compute the gradient at the left halo boundary of blocks. This kernel calculates the x and y derivatives at the left edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. void gradientHaloRight (Param XParam, BlockP&lt; T &gt; XBlock, int ib, int iy, T * a, T * dadx, T * dady) CPU function to compute the gradient at the left halo boundary of a specific block. This function calculates the x and y derivatives at the left edge of the block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. __global__ void gradientHaloRightGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU kernel to compute the gradient at the right halo boundary of blocks. This kernel calculates the x and y derivatives at the right edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. __global__ void gradientHaloRightGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU kernel to compute the gradient at the right halo boundary of blocks. This kernel calculates the x and y derivatives at the right edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. void gradientHaloTop (Param XParam, BlockP&lt; T &gt; XBlock, int ib, int ix, T * a, T * dadx, T * dady) CPU function to compute the gradient at the top halo boundary of a specific block. This function calculates the x and y derivatives at the top edge of the block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. __global__ void gradientHaloTopGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU kernel to compute the gradient at the top halo boundary of blocks. This kernel calculates the x and y derivatives at the top edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. __global__ void gradientHaloTopGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU kernel to compute the gradient at the top halo boundary of blocks. This kernel calculates the x and y derivatives at the top edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. __global__ void gradientSM (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx, T * dady) Deprecated shared memory device kernel for gradient calculation. template __global__ void gradientSM&lt; double &gt; (int halowidth, int * active, int * level, double theta, double dx, double * a, double * dadx, double * dady)  template __global__ void gradientSM&lt; float &gt; (int halowidth, int * active, int * level, float theta, float dx, float * a, float * dadx, float * dady)  __global__ void gradientSMB (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx, T * dady) Shared memory device kernel for gradient calculation (variant B). template __global__ void gradientSMB&lt; double &gt; (int halowidth, int * active, int * level, double theta, double dx, double * a, double * dadx, double * dady)  template __global__ void gradientSMB&lt; float &gt; (int halowidth, int * active, int * level, float theta, float dx, float * a, float * dadx, float * dady)  __global__ void gradientSMC (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx, T * dady) Shared memory device kernel for gradient calculation (variant C). template __global__ void gradientSMC&lt; double &gt; (int halowidth, int * active, int * level, double theta, double dx, double * a, double * dadx, double * dady)  template __global__ void gradientSMC&lt; float &gt; (int halowidth, int * active, int * level, float theta, float dx, float * a, float * dadx, float * dady)  __global__ void gradientedgeX (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx) Device kernel for calculating gradients for an evolving parameter using the minmod limiter only at a fixed column (i.e. fixed ix). template __global__ void gradientedgeX&lt; double &gt; (int halowidth, int * active, int * level, double theta, double dx, double * a, double * dadx)  template __global__ void gradientedgeX&lt; float &gt; (int halowidth, int * active, int * level, float theta, float dx, float * a, float * dadx)  __global__ void gradientedgeY (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dady) Device kernel for calculating gradients for an evolving parameter using the minmod limiter only at a fixed row (i.e. fixed iy). template __global__ void gradientedgeY&lt; double &gt; (int halowidth, int * active, int * level, double theta, double dx, double * a, double * dady)  template __global__ void gradientedgeY&lt; float &gt; (int halowidth, int * active, int * level, float theta, float dx, float * a, float * dady)"},{"location":"BGFlood/_gradients_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_gradients_8cu/#function-wetsloperesetcpu","title":"function WetsloperesetCPU","text":"<p>CPU function to apply wet slope limiters to gradients of surface elevation. Adjusts gradients to prevent non-physical slopes in wet-dry transition zones. </p><pre><code>template&lt;class T&gt;\nvoid WetsloperesetCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_gradients_8cu/#function-wetsloperesethalobotcpu","title":"function WetsloperesetHaloBotCPU","text":"<p>CPU function to reset the wet slope limiter at the bottom halo boundary. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </p><pre><code>template&lt;class T&gt;\nvoid WetsloperesetHaloBotCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>Note:</p> <p>This function specifically handles the bottom halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the bottom surface elevation needed for the wet slope limiter. </p>"},{"location":"BGFlood/_gradients_8cu/#function-wetsloperesethalobotgpu","title":"function WetsloperesetHaloBotGPU","text":"<p>GPU kernel to reset the wet slope limiter at the bottom halo boundary. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </p><pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetHaloBotGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>Note:</p> <p>This kernel specifically handles the bottom halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the bottom surface elevation needed for the wet slope limiter. </p>"},{"location":"BGFlood/_gradients_8cu/#function-wetsloperesethaloleftcpu","title":"function WetsloperesetHaloLeftCPU","text":"<p>CPU function to apply wet slope limiters to gradients of surface elevation at the left halo boundary. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </p><pre><code>template&lt;class T&gt;\nvoid WetsloperesetHaloLeftCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>Note:</p> <p>This function specifically handles the left halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the left surface elevation needed for </p>"},{"location":"BGFlood/_gradients_8cu/#function-wetsloperesethaloleftgpu","title":"function WetsloperesetHaloLeftGPU","text":"<p>Device kernel to apply wet slope limiters to gradients of surface elevation at the left halo boundary. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </p><pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetHaloLeftGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>Note:</p> <p>This kernel specifically handles the left halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the left surface elevation needed for the wet slope limiter. </p>"},{"location":"BGFlood/_gradients_8cu/#function-wetsloperesethalorightcpu","title":"function WetsloperesetHaloRightCPU","text":"<p>CPU function to apply wet slope limiters to gradients of surface elevation at the right halo boundary. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </p><pre><code>template&lt;class T&gt;\nvoid WetsloperesetHaloRightCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>Note:</p> <p>This function specifically handles the right halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the right surface elevation needed for the wet slope limiter. </p>"},{"location":"BGFlood/_gradients_8cu/#function-wetsloperesethalorightgpu","title":"function WetsloperesetHaloRightGPU","text":"<p>Device kernel to apply wet slope limiters to gradients of surface elevation at the right halo boundary. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </p><pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetHaloRightGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>Note:</p> <p>This kernel specifically handles the right halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the right surface elevation needed for the wet slope limiter. </p>"},{"location":"BGFlood/_gradients_8cu/#function-wetsloperesethalotopcpu","title":"function WetsloperesetHaloTopCPU","text":"<p>CPU function to reset the wet slope limiter at the top halo boundary. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </p><pre><code>template&lt;class T&gt;\nvoid WetsloperesetHaloTopCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>Note:</p> <p>This function specifically handles the top halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the top surface elevation needed for the wet slope limiter. </p>"},{"location":"BGFlood/_gradients_8cu/#function-wetsloperesethalotopgpu","title":"function WetsloperesetHaloTopGPU","text":"<p>GPU kernel to reset the wet slope limiter at the top halo boundary. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </p><pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetHaloTopGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>Note:</p> <p>This kernel specifically handles the top halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the top surface elevation needed for the wet slope limiter. </p>"},{"location":"BGFlood/_gradients_8cu/#function-wetsloperesetxgpu","title":"function WetsloperesetXGPU","text":"<p>Device kernel to apply wet slope limiters to gradients of surface elevation in the x-direction. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </p><pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetXGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_gradients_8cu/#function-wetsloperesetygpu","title":"function WetsloperesetYGPU","text":"<p>Device kernel to apply wet slope limiters to gradients of surface elevation in the y-direction. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </p><pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetYGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_gradients_8cu/#function-gradient","title":"function gradient","text":"<p>Device kernel for calculating gradients for an evolving parameter using the minmod limiter. </p><pre><code>template&lt;class T&gt;\n__global__ void gradient (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Computes spatial derivatives in x and y directions for a given variable.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Width of halo region </li> <li><code>active</code> Active block indices </li> <li><code>level</code> Block refinement levels </li> <li><code>theta</code> Limiter parameter </li> <li><code>dx</code> Grid spacing </li> <li><code>a</code> Input variable array </li> <li><code>dadx</code> Output gradient in x </li> <li><code>dady</code> Output gradient in y </li> </ul>"},{"location":"BGFlood/_gradients_8cu/#function-gradient-double","title":"function gradient&lt; double &gt;","text":"<pre><code>template __global__ void gradient&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    double theta,\n    double dx,\n    double * a,\n    double * dadx,\n    double * dady\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradient-float","title":"function gradient&lt; float &gt;","text":"<pre><code>template __global__ void gradient&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    float theta,\n    float dx,\n    float * a,\n    float * dadx,\n    float * dady\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradientc","title":"function gradientC","text":"<p>CPU function for calculating gradients using the minmod limiter. Computes spatial derivatives in x and y directions for a given variable. </p><pre><code>template&lt;class T&gt;\nvoid gradientC (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Input variable array </li> <li><code>dadx</code> Output gradient in x </li> <li><code>dady</code> Output gradient in y </li> </ul>"},{"location":"BGFlood/_gradients_8cu/#function-gradientc-double","title":"function gradientC&lt; double &gt;","text":"<pre><code>template void gradientC&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * a,\n    double * dadx,\n    double * dady\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradientc-float","title":"function gradientC&lt; float &gt;","text":"<pre><code>template void gradientC&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * a,\n    float * dadx,\n    float * dady\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradientcpu","title":"function gradientCPU","text":"<p>CPU function to compute gradients for all evolving parameters, handle halo regions, and apply wet-dry fixes. Calculates spatial derivatives for height, surface elevation, and velocity components. Also manages halo regions and applies wet-dry fixes if necessary. </p><pre><code>template&lt;class T&gt;\nvoid gradientCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_gradients_8cu/#function-gradientcpu-double","title":"function gradientCPU&lt; double &gt;","text":"<pre><code>template void gradientCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradientcpu-float","title":"function gradientCPU&lt; float &gt;","text":"<pre><code>template void gradientCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradientgpu","title":"function gradientGPU","text":"<p>Entry point for gradient of evolving variables calculation on the GPU. </p><pre><code>template&lt;class T&gt;\nvoid gradientGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Calculates gradients of evolving variables using CUDA kernels and synchronizes device operations. Handles halo filling and elevation conservation if required.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradient variables </li> <li><code>zb</code> Bed elevation array</li> </ul> <p>Wrapping function to calculate gradien of evolving variables on GPU This function is the entry point to the gradient functions on the GPU </p>"},{"location":"BGFlood/_gradients_8cu/#function-gradientgpu-double","title":"function gradientGPU&lt; double &gt;","text":"<pre><code>template void gradientGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradientgpu-float","title":"function gradientGPU&lt; float &gt;","text":"<pre><code>template void gradientGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradientgpunew","title":"function gradientGPUnew","text":"<p>Alternative GPU gradient calculation using shared memory kernels and CUDA streams. </p><pre><code>template&lt;class T&gt;\nvoid gradientGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Uses gradientSMC kernels and handles halo filling, elevation conservation, and wet/dry prolongation.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradient variables </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_gradients_8cu/#function-gradientgpunew-double","title":"function gradientGPUnew&lt; double &gt;","text":"<pre><code>template void gradientGPUnew&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradientgpunew-float","title":"function gradientGPUnew&lt; float &gt;","text":"<pre><code>template void gradientGPUnew&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradienthalo","title":"function gradientHalo","text":"<p>CPU function to compute gradients at the halo boundaries of all active blocks. This function iterates over all active blocks and computes the gradients at their halo boundaries using finite difference approximations. </p><pre><code>template&lt;class T&gt;\nvoid gradientHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This function calls specific functions to handle each of the four halo boundaries (left, right, bottom, top) for each block. It ensures that gradients are accurately computed at the edges of the computational domain, which is crucial for maintaining solution accuracy and stability. The function assumes that the input arrays are properly allocated and sized according to the simulation parameters. The gradient computations are performed using central differences where possible, and one-sided differences at the boundaries. The function is templated to support different data types (e.g., float, double). </p> <p>See also: gradientHaloLeft, gradientHaloRight, gradientHaloBot, gradientHaloTop </p>"},{"location":"BGFlood/_gradients_8cu/#function-gradienthalobot","title":"function gradientHaloBot","text":"<p>CPU function to compute the gradient at the bottom halo boundary of a specific block. This function calculates the x and y derivatives at the bottom edge of the block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\nvoid gradientHaloBot (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    int ib,\n    int ix,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>ib</code> Index of the block for which the bottom halo gradient is to be computed </li> <li><code>ix</code> x-index within the block </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This function handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8cu/#function-gradienthalobotgpu","title":"function gradientHaloBotGPU","text":"<p>GPU kernel to compute the gradient at the bottom halo boundary of blocks. This kernel calculates the x and y derivatives at the bottom edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientHaloBotGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8cu/#function-gradienthalobotgpunew","title":"function gradientHaloBotGPUnew","text":"<p>GPU kernel to compute the gradient at the bottom halo boundary of blocks. This kernel calculates the x and y derivatives at the bottom edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientHaloBotGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8cu/#function-gradienthalogpu","title":"function gradientHaloGPU","text":"<p>GPU function to compute gradients at the halo boundaries of all active blocks. This function launches CUDA kernels to compute the gradients at the halo boundaries of all active blocks using parallel processing. </p><pre><code>template&lt;class T&gt;\nvoid gradientHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This function sets up the CUDA grid and block dimensions and launches specific kernels to handle each of the four halo boundaries (left, right, bottom, top) for all active blocks. It ensures that gradients are accurately computed at the edges of the computational domain, which is crucial for maintaining solution accuracy and stability. The function assumes that the input arrays are properly allocated and sized according to the simulation parameters. The gradient computations are performed using central differences where possible, and one-sided differences at the boundaries. The function is templated to support different data types (e.g., float, double). </p> <p>See also: gradientHaloLeftGPU, gradientHaloRightGPU, gradientHaloBotGPU, gradientHaloTopGPU </p> <p>See also: gradientHaloLeft, gradientHaloRight, gradientHaloBot, gradientHaloTop </p>"},{"location":"BGFlood/_gradients_8cu/#function-gradienthalogpunew","title":"function gradientHaloGPUnew","text":"<p>GPU function to compute gradients at the halo boundaries of all active blocks using multiple CUDA streams. This function launches CUDA kernels in separate streams to compute the gradients at the halo boundaries of all active blocks, allowing for concurrent execution and improved performance. </p><pre><code>template&lt;class T&gt;\nvoid gradientHaloGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This function sets up multiple CUDA streams and launches specific kernels to handle each of the four halo boundaries (left, right, bottom, top) for all active blocks in separate streams. It ensures that gradients are accurately computed at the edges of the computational domain, which is crucial for maintaining solution accuracy and stability. The function assumes that the input arrays are properly allocated and sized according to the simulation parameters. The gradient computations are performed using central differences where possible, and one-sided differences at the boundaries. The function is templated to support different data types (e.g., float, double). </p> <p>See also: gradientHaloLeftGPUnew, gradientHaloRightGPUnew, gradientHaloBotGPUnew, gradientHaloTopGPUnew </p> <p>See also: gradientHaloLeft, gradientHaloRight, gradientHaloBot, gradientHaloTop </p>"},{"location":"BGFlood/_gradients_8cu/#function-gradienthaloleft","title":"function gradientHaloLeft","text":"<p>CPU function to compute the gradient at the left halo boundary of a specific block. This function calculates the x and y derivatives at the left edge of the block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\nvoid gradientHaloLeft (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    int ib,\n    int iy,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>ib</code> Index of the block for which the left halo gradient is to be computed </li> <li><code>iy</code> y-index within the block </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This function handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8cu/#function-gradienthaloleftgpu","title":"function gradientHaloLeftGPU","text":"<p>GPU kernel to compute the gradient at the left halo boundary of blocks. This kernel calculates the x and y derivatives at the left edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientHaloLeftGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8cu/#function-gradienthaloleftgpunew","title":"function gradientHaloLeftGPUnew","text":"<p>GPU kernel to compute the gradient at the left halo boundary of blocks. This kernel calculates the x and y derivatives at the left edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientHaloLeftGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8cu/#function-gradienthaloright","title":"function gradientHaloRight","text":"<p>CPU function to compute the gradient at the left halo boundary of a specific block. This function calculates the x and y derivatives at the left edge of the block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\nvoid gradientHaloRight (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    int ib,\n    int iy,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>ib</code> Index of the block for which the left halo gradient is to be computed </li> <li><code>iy</code> y-index within the block </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This function handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8cu/#function-gradienthalorightgpu","title":"function gradientHaloRightGPU","text":"<p>GPU kernel to compute the gradient at the right halo boundary of blocks. This kernel calculates the x and y derivatives at the right edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientHaloRightGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8cu/#function-gradienthalorightgpunew","title":"function gradientHaloRightGPUnew","text":"<p>GPU kernel to compute the gradient at the right halo boundary of blocks. This kernel calculates the x and y derivatives at the right edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientHaloRightGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8cu/#function-gradienthalotop","title":"function gradientHaloTop","text":"<p>CPU function to compute the gradient at the top halo boundary of a specific block. This function calculates the x and y derivatives at the top edge of the block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\nvoid gradientHaloTop (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    int ib,\n    int ix,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>ib</code> Index of the block for which the top halo gradient is to be computed </li> <li><code>ix</code> x-index within the block </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This function handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8cu/#function-gradienthalotopgpu","title":"function gradientHaloTopGPU","text":"<p>GPU kernel to compute the gradient at the top halo boundary of blocks. This kernel calculates the x and y derivatives at the top edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientHaloTopGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8cu/#function-gradienthalotopgpunew","title":"function gradientHaloTopGPUnew","text":"<p>GPU kernel to compute the gradient at the top halo boundary of blocks. This kernel calculates the x and y derivatives at the top edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientHaloTopGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8cu/#function-gradientsm","title":"function gradientSM","text":"<p>Deprecated shared memory device kernel for gradient calculation. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientSM (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Uses shared memory for stencil operations; slower than the standard kernel.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Width of halo region </li> <li><code>active</code> Active block indices </li> <li><code>level</code> Block refinement levels </li> <li><code>theta</code> Limiter parameter </li> <li><code>dx</code> Grid spacing </li> <li><code>a</code> Input variable array </li> <li><code>dadx</code> Output gradient in x </li> <li><code>dady</code> Output gradient in y </li> </ul>"},{"location":"BGFlood/_gradients_8cu/#function-gradientsm-double","title":"function gradientSM&lt; double &gt;","text":"<pre><code>template __global__ void gradientSM&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    double theta,\n    double dx,\n    double * a,\n    double * dadx,\n    double * dady\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradientsm-float","title":"function gradientSM&lt; float &gt;","text":"<pre><code>template __global__ void gradientSM&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    float theta,\n    float dx,\n    float * a,\n    float * dadx,\n    float * dady\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradientsmb","title":"function gradientSMB","text":"<p>Shared memory device kernel for gradient calculation (variant B). </p><pre><code>template&lt;class T&gt;\n__global__ void gradientSMB (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Uses a fixed shared memory tile for stencil operations; only computes gradients for interior points.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Width of halo region </li> <li><code>active</code> Active block indices </li> <li><code>level</code> Block refinement levels </li> <li><code>theta</code> Limiter parameter </li> <li><code>dx</code> Grid spacing </li> <li><code>a</code> Input variable array </li> <li><code>dadx</code> Output gradient in x </li> <li><code>dady</code> Output gradient in y </li> </ul>"},{"location":"BGFlood/_gradients_8cu/#function-gradientsmb-double","title":"function gradientSMB&lt; double &gt;","text":"<pre><code>template __global__ void gradientSMB&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    double theta,\n    double dx,\n    double * a,\n    double * dadx,\n    double * dady\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradientsmb-float","title":"function gradientSMB&lt; float &gt;","text":"<pre><code>template __global__ void gradientSMB&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    float theta,\n    float dx,\n    float * a,\n    float * dadx,\n    float * dady\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradientsmc","title":"function gradientSMC","text":"<p>Shared memory device kernel for gradient calculation (variant C). </p><pre><code>template&lt;class T&gt;\n__global__ void gradientSMC (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Uses a flat shared memory array for stencil operations; computes gradients for all points.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Width of halo region </li> <li><code>active</code> Active block indices </li> <li><code>level</code> Block refinement levels </li> <li><code>theta</code> Limiter parameter </li> <li><code>dx</code> Grid spacing </li> <li><code>a</code> Input variable array </li> <li><code>dadx</code> Output gradient in x </li> <li><code>dady</code> Output gradient in y </li> </ul>"},{"location":"BGFlood/_gradients_8cu/#function-gradientsmc-double","title":"function gradientSMC&lt; double &gt;","text":"<pre><code>template __global__ void gradientSMC&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    double theta,\n    double dx,\n    double * a,\n    double * dadx,\n    double * dady\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradientsmc-float","title":"function gradientSMC&lt; float &gt;","text":"<pre><code>template __global__ void gradientSMC&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    float theta,\n    float dx,\n    float * a,\n    float * dadx,\n    float * dady\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradientedgex","title":"function gradientedgeX","text":"<p>Device kernel for calculating gradients for an evolving parameter using the minmod limiter only at a fixed column (i.e. fixed ix). </p><pre><code>template&lt;class T&gt;\n__global__ void gradientedgeX (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx\n) \n</code></pre> <p>Computes x-derivative for a specific column using the minmod limiter.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Width of halo region </li> <li><code>active</code> Active block indices </li> <li><code>level</code> Block refinement levels </li> <li><code>theta</code> Limiter parameter </li> <li><code>dx</code> Grid spacing </li> <li><code>a</code> Input variable array </li> <li><code>dadx</code> Output gradient in x </li> </ul>"},{"location":"BGFlood/_gradients_8cu/#function-gradientedgex-double","title":"function gradientedgeX&lt; double &gt;","text":"<pre><code>template __global__ void gradientedgeX&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    double theta,\n    double dx,\n    double * a,\n    double * dadx\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradientedgex-float","title":"function gradientedgeX&lt; float &gt;","text":"<pre><code>template __global__ void gradientedgeX&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    float theta,\n    float dx,\n    float * a,\n    float * dadx\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradientedgey","title":"function gradientedgeY","text":"<p>Device kernel for calculating gradients for an evolving parameter using the minmod limiter only at a fixed row (i.e. fixed iy). </p><pre><code>template&lt;class T&gt;\n__global__ void gradientedgeY (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dady\n) \n</code></pre> <p>Computes y-derivative for a specific row using the minmod limiter.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Width of halo region </li> <li><code>active</code> Active block indices </li> <li><code>level</code> Block refinement levels </li> <li><code>theta</code> Limiter parameter </li> <li><code>dx</code> Grid spacing </li> <li><code>a</code> Input variable array </li> <li><code>dady</code> Output gradient in y </li> </ul>"},{"location":"BGFlood/_gradients_8cu/#function-gradientedgey-double","title":"function gradientedgeY&lt; double &gt;","text":"<pre><code>template __global__ void gradientedgeY&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    double theta,\n    double dx,\n    double * a,\n    double * dady\n) \n</code></pre>"},{"location":"BGFlood/_gradients_8cu/#function-gradientedgey-float","title":"function gradientedgeY&lt; float &gt;","text":"<pre><code>template __global__ void gradientedgeY&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    float theta,\n    float dx,\n    float * a,\n    float * dady\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Gradients.cu</code></p>"},{"location":"BGFlood/_gradients_8cu_source/","title":"File Gradients.cu","text":""},{"location":"BGFlood/_gradients_8cu_source/#file-gradientscu","title":"File Gradients.cu","text":"<p>File List &gt; src &gt; Gradients.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Gradients.h\"\n\n\ntemplate &lt;class T&gt; void gradientGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad,T* zb)\n{\n    //const int num_streams = 4;\n    /*\n    cudaStream_t streams[num_streams];\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n    }\n    */\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 blockDimLR(1, XParam.blkwidth, 1);\n    dim3 blockDimBT(XParam.blkwidth, 1, 1);\n    dim3 blockDimLR2(2, XParam.blkwidth, 1);\n    dim3 blockDimBT2(XParam.blkwidth, 2, 1);\n    dim3 blockDimfull(XParam.blkmemwidth, XParam.blkmemwidth, 1);\n\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[1] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[2] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[3] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudx, XGrad.dudy);\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.u, XGrad.dudx, XGrad.dudy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[0] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdx, XGrad.dvdy);\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.v, XGrad.dvdx, XGrad.dvdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    //CUDA_CHECK(cudaDeviceSynchronize());\n    /*\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamDestroy(streams[i]);\n    }\n    */\n\n\n    //fillHaloGPU(XParam, XBlock, XGrad);\n    gradientHaloGPU(XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    gradientHaloGPU(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    gradientHaloGPU(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    gradientHaloGPU(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n\n    if (XParam.conserveElevation)\n    {\n        conserveElevationGradHaloGPU(XParam, XBlock, XEv.h, XEv.zs, zb, XGrad.dhdx, XGrad.dzsdx, XGrad.dhdy, XGrad.dzsdy);\n    }\n\n    //else\n    {\n        if (XParam.maxlevel &gt; XParam.minlevel)\n        {\n            refine_linearGPU(XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n            //refine_linearGPU(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n            refine_linearGPU(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n            refine_linearGPU(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n            if (XParam.conserveElevation)\n            {\n                conserveElevationGPU(XParam, XBlock, XEv, zb);\n            }\n\n      RecalculateZsGPU &lt;&lt;&lt; gridDim, blockDimfull, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n            CUDA_CHECK(cudaDeviceSynchronize());\n\n\n\n        //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[1] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdx, XGrad.dhdy);\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.h, XGrad.dhdx, XGrad.dhdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[2] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[3] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudx, XGrad.dudy);\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.u, XGrad.dudx, XGrad.dudy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[0] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdx, XGrad.dvdy);\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.v, XGrad.dvdx, XGrad.dvdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n\n            /*\n            gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.h, XGrad.dhdx);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            //gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth-1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdx);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n\n            gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.h, XGrad.dhdy);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            //gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT, 0&gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth-1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdy);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n\n            gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.zs, XGrad.dzsdx);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            //gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdx);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n\n            gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.zs, XGrad.dzsdy);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            //gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdy);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n\n            gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.u, XGrad.dudx);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            //gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudx);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n\n            gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.u, XGrad.dudy);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            //gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudy);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n\n            gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.v, XGrad.dvdx);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            //gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdx);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n\n            gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.v, XGrad.dvdy);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            //gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdy);\n            CUDA_CHECK(cudaDeviceSynchronize());\n            */\n\n\n            gradientHaloGPU(XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n            gradientHaloGPU(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n            gradientHaloGPU(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n            gradientHaloGPU(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n            if (XParam.conserveElevation)\n            {\n                conserveElevationGradHaloGPU(XParam, XBlock, XEv.h, XEv.zs, zb, XGrad.dhdx, XGrad.dzsdx, XGrad.dhdy, XGrad.dzsdy);\n            }\n        }\n        if (XParam.engine == 1)\n        {\n            //  wet slope limiter\n            WetsloperesetXGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n            CUDA_CHECK(cudaDeviceSynchronize());\n\n            WetsloperesetYGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n            CUDA_CHECK(cudaDeviceSynchronize());\n\n            // ALso do the slope limiter on the halo\n            WetsloperesetHaloLeftGPU &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n            CUDA_CHECK(cudaDeviceSynchronize());\n\n            WetsloperesetHaloRightGPU &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n            CUDA_CHECK(cudaDeviceSynchronize());\n\n            WetsloperesetHaloBotGPU &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n            CUDA_CHECK(cudaDeviceSynchronize());\n\n            WetsloperesetHaloTopGPU &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n\n            CUDA_CHECK(cudaDeviceSynchronize());\n        }\n\n    }\n    //conserveElevationGradHaloGPU(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    //conserveElevationGradHaloGPU(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    //conserveElevationGradHaloGPU(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n}\ntemplate void gradientGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt;XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, float * zb);\ntemplate void gradientGPU&lt;double&gt;(Param XParam,  BlockP&lt;double&gt;XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, double * zb);\n\ntemplate &lt;class T&gt; void gradientGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 blockDimLR(1, XParam.blkwidth, 1);\n    dim3 blockDimBT(XParam.blkwidth, 1, 1);\n    dim3 blockDimLR2(2, XParam.blkwidth, 1);\n    dim3 blockDimBT2(XParam.blkwidth, 2, 1);\n    dim3 blockDimfull(XParam.blkmemwidth, XParam.blkmemwidth, 1);\n\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    const int num_streams = 4;\n\n    cudaStream_t streams[num_streams];\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n    }\n\n    //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[1] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    gradientSMC &lt;&lt;&lt; gridDim, blockDim, 0, streams[0] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[2] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    gradientSMC &lt;&lt;&lt; gridDim, blockDim, 0, streams[1] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[3] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudx, XGrad.dudy);\n    gradientSMC &lt;&lt;&lt; gridDim, blockDim, 0, streams[2] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.u, XGrad.dudx, XGrad.dudy);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[0] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdx, XGrad.dvdy);\n    gradientSMC &lt;&lt;&lt; gridDim, blockDim, 0, streams[3] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.v, XGrad.dvdx, XGrad.dvdy);\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    //CUDA_CHECK(cudaDeviceSynchronize());\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamDestroy(streams[i]);\n    }\n\n\n\n    //fillHaloGPU(XParam, XBlock, XGrad);\n    gradientHaloGPUnew(XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    gradientHaloGPUnew(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    gradientHaloGPUnew(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    gradientHaloGPUnew(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n    if (XParam.maxlevel &gt; XParam.minlevel)\n    {\n\n        if (XParam.conserveElevation)\n        {\n            conserveElevationGradHaloGPU(XParam, XBlock, XEv.h, XEv.zs, zb, XGrad.dhdx, XGrad.dzsdx, XGrad.dhdy, XGrad.dzsdy);\n        }\n\n\n        refine_linearGPU(XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n        //refine_linearGPU(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n        refine_linearGPU(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n        refine_linearGPU(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n        if (XParam.conserveElevation)\n        {\n            conserveElevationGPU(XParam, XBlock, XEv, zb);\n        }\n        else if (XParam.wetdryfix)\n        {\n            WetDryProlongationGPU(XParam, XBlock, XEv, zb);\n        }\n\n        RecalculateZsGPU &lt;&lt;&lt; gridDim, blockDimfull, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        /*\n        //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[1] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdx, XGrad.dhdy);\n        gradientSM &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdx, XGrad.dhdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[2] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n        gradientSM &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[3] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudx, XGrad.dudy);\n        gradientSM &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudx, XGrad.dudy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        //gradient &lt;&lt;&lt; gridDim, blockDim, 0, streams[0] &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdx, XGrad.dvdy);\n        gradientSM &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdx, XGrad.dvdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n        */\n        /*\n        const int num_streams = 16;\n\n        cudaStream_t streams[num_streams];\n\n        for (int i = 0; i &lt; num_streams; i++)\n        {\n            CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n        }\n        */\n\n\n\n        gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.h, XGrad.dhdx);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n        //gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth-1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdx);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.h, XGrad.dhdy);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n        //gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT, 0&gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth-1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.h, XGrad.dhdy);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.zs, XGrad.dzsdx);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n        //gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdx);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.zs, XGrad.dzsdy);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n        //gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.zs, XGrad.dzsdy);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.u, XGrad.dudx);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n        //gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudx);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.u, XGrad.dudy);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n        //gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.u, XGrad.dudy);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.v, XGrad.dvdx);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n        //gradientedgeX &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdx);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT2, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.delta, XEv.v, XGrad.dvdy);\n        //CUDA_CHECK(cudaDeviceSynchronize());\n        //gradientedgeY &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.blkwidth - 1, XBlock.active, XBlock.level, (T)XParam.theta, (T)XParam.dx, XEv.v, XGrad.dvdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        /*\n        for (int i = 0; i &lt; num_streams; i++)\n        {\n            cudaStreamDestroy(streams[i]);\n        }\n        */\n        gradientHaloGPUnew(XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n        gradientHaloGPUnew(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n        gradientHaloGPUnew(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n        gradientHaloGPUnew(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n        if (XParam.conserveElevation)\n        {\n            conserveElevationGradHaloGPU(XParam, XBlock, XEv.h, XEv.zs, zb, XGrad.dhdx, XGrad.dzsdx, XGrad.dhdy, XGrad.dzsdy);\n        }\n    }\n    if (XParam.engine == 1)\n    {\n        //  wet slope limiter\n        WetsloperesetXGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        WetsloperesetYGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        // ALso do the slope limiter on the halo\n        WetsloperesetHaloLeftGPU &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        WetsloperesetHaloRightGPU &lt;&lt;&lt; gridDim, blockDimLR, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        WetsloperesetHaloBotGPU &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        WetsloperesetHaloTopGPU &lt;&lt;&lt; gridDim, blockDimBT, 0 &gt;&gt;&gt; (XParam, XBlock, XEv, XGrad, zb);\n\n        CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n\n    //conserveElevationGradHaloGPU(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    //conserveElevationGradHaloGPU(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    //conserveElevationGradHaloGPU(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n}\ntemplate void gradientGPUnew&lt;float&gt;(Param XParam, BlockP&lt;float&gt;XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, float* zb);\ntemplate void gradientGPUnew&lt;double&gt;(Param XParam, BlockP&lt;double&gt;XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, double* zb);\n\n\ntemplate &lt;class T&gt; __global__ void gradient(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx, T* dady)\n{\n    //int *leftblk,int *rightblk,int* topblk, int * botblk,\n\n    //int ix = threadIdx.x+1;\n    //int iy = threadIdx.y+1;\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = active[ibl];\n\n    int lev = level[ib];\n\n    T delta = calcres(dx, lev);\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    //int iright, ileft, ibot;\n    // shared array index to make the code bit more readable\n    //unsigned int sx = ix + halowidth;\n    //unsigned int sy = iy + halowidth;\n\n\n    T a_l, a_t, a_r, a_b,a_i;\n\n    a_i = a[i];\n\n\n    a_l = a[memloc(halowidth, blkmemwidth, ix - 1, iy, ib)];\n    a_t = a[memloc(halowidth, blkmemwidth, ix , iy + 1, ib)];\n    a_r = a[memloc(halowidth, blkmemwidth, ix + 1, iy, ib)];\n    a_b = a[memloc(halowidth, blkmemwidth, ix, iy - 1, ib)];\n    //__shared__ T a_s[18][18];\n\n\n\n    //__syncthreads();\n    //__syncwarp;\n\n    dadx[i] = minmod2(theta, a_l, a_i, a_r) / delta;\n\n    dady[i] = minmod2(theta, a_b, a_i, a_t) / delta;\n\n\n}\ntemplate __global__ void gradient&lt;float&gt;(int halowidth, int* active, int* level, float theta, float dx, float* a, float* dadx, float* dady);\ntemplate __global__ void gradient&lt;double&gt;(int halowidth, int* active, int* level, double theta, double dx, double* a, double* dadx, double* dady);\n\n\n\ntemplate &lt;class T&gt; __global__ void gradientSM(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx, T* dady)\n{\n    //int *leftblk,int *rightblk,int* topblk, int * botblk,\n\n    //int ix = threadIdx.x+1;\n    //int iy = threadIdx.y+1;\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = active[ibl];\n\n    int lev = level[ib];\n\n    T delta = calcres(dx, lev);\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    int iright, ileft, itop, ibot;\n    // shared array index to make the code bit more readable\n    int sx = ix + halowidth;\n    int sy = iy + halowidth;\n\n\n\n    __shared__ T a_s[18][18];\n\n\n\n    a_s[sx][sy] = a[i];\n\n    //syncthread is needed here ?\n\n\n    // read the halo around the tile\n    if (threadIdx.x == blockDim.x - 1)\n    {\n        iright = memloc(halowidth, blkmemwidth, ix + 1, iy, ib);\n        a_s[sx + 1][sy] = a[iright];\n\n    }\n\n\n    if (threadIdx.x == 0)\n    {\n        ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);;\n        a_s[sx - 1][sy] = a[ileft];\n\n    }\n\n    if (threadIdx.y == blockDim.y - 1)\n    {\n        itop = memloc(halowidth, blkmemwidth, ix, iy + 1, ib);;\n        a_s[sx][sy + 1] = a[itop];\n\n    }\n\n    if (threadIdx.y == 0)\n    {\n        ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n        a_s[sx][sy - 1] = a[ibot];\n\n    }\n\n    __syncthreads();\n\n\n\n    dadx[i] = minmod2(theta, a_s[sx - 1][sy], a_s[sx][sy], a_s[sx + 1][sy]) / delta;\n\n    dady[i] = minmod2(theta, a_s[sx][sy - 1], a_s[sx][sy], a_s[sx][sy + 1]) / delta;\n\n\n}\ntemplate __global__ void gradientSM&lt;float&gt;(int halowidth, int* active, int* level, float theta, float dx, float* a, float* dadx, float* dady);\ntemplate __global__ void gradientSM&lt;double&gt;(int halowidth, int* active, int* level, double theta, double dx, double* a, double* dadx, double* dady);\n\n\n\ntemplate &lt;class T&gt; __global__ void gradientSMB(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx, T* dady)\n{\n    //int *leftblk,int *rightblk,int* topblk, int * botblk,\n\n    //int ix = threadIdx.x+1;\n    //int iy = threadIdx.y+1;\n    int blkmemwidth = 18;\n    int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x-1;\n    int iy = threadIdx.y-1;\n    int ibl = blockIdx.x;\n    int ib = active[ibl];\n\n    int lev = level[ib];\n\n    T delta = calcres(dx, lev);\n\n\n\n    int iright, ileft, itop, ibot;\n    // shared array index to make the code bit more readable\n    int sx = ix + 1;\n    int sy = iy + 1;\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    //int o = memloc(halowidth, blkmemwidth, sx, sy, ib);\n\n    __shared__ T a_s[18][18];\n\n\n\n\n    a_s[sx][sy] = a[i];\n    __syncthreads();\n    //syncthread is needed here ?\n\n    T aleft, aright, atop, abot;\n    aleft = a_s[sx - 1][sy];\n    aright = a_s[sx + 1][sy];\n    atop = a_s[sx][sy + 1];\n    abot = a_s[sx][sy - 1];\n\n\n    if (ix &gt;= 0 &amp;&amp; ix &lt; 16 &amp;&amp; iy &gt;=0 &amp;&amp; iy &lt; 16)\n    {\n\n        dadx[i] = minmod2(theta, aleft, a_s[sx][sy], aright) / delta;\n\n        dady[i] = minmod2(theta, abot, a_s[sx][sy], atop) / delta;\n    }\n\n}\ntemplate __global__ void gradientSMB&lt;float&gt;(int halowidth, int* active, int* level, float theta, float dx, float* a, float* dadx, float* dady);\ntemplate __global__ void gradientSMB&lt;double&gt;(int halowidth, int* active, int* level, double theta, double dx, double* a, double* dadx, double* dady);\n\ntemplate &lt;class T&gt; __global__ void gradientSMC(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx, T* dady)\n{\n    //int *leftblk,int *rightblk,int* topblk, int * botblk,\n\n    //int ix = threadIdx.x+1;\n    //int iy = threadIdx.y+1;\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    int flatenwidth = blockDim.x * blockDim.y;\n    int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = active[ibl];\n\n    int lev = level[ib];\n\n    T delta = calcres(dx, lev);\n\n    int ism =ix + iy * blockDim.x;\n\n    int istore = ism + ib * (blkmemwidth * blkmemwidth);\n    //(i + halowidth) + (j + halowidth) * blkmemwidth + ib * (blkmemwidth * blkmemwidth);\n    //memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n\n    int ileft, iright, itop, ibot, i, iwrite;\n\n\n    // shared array index to make the code bit more readable\n    int sx = ix + halowidth;\n    int sy = iy + halowidth;\n\n\n\n    __shared__ T a_s[324];\n    //__shared__ T dadx_out[18 * 18];\n    //__shared__ T dady_out[18 * 18];\n    //__shared__ T a_s[324];\n    //__shared__ T a_left[324];\n    //__shared__ T a_right[324];\n    //__shared__ T a_top[324];\n    //__shared__ T a_bot[324];\n\n\n\n    //(i + halowidth) + (j + halowidth) * blkmemwidth + ib * (blkmemwidth * blkmemwidth);\n    //memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n//\n    a_s[ism] = a[istore];\n\n    if (ism &lt; (324 - (flatenwidth)))\n    {\n        a_s[ism + flatenwidth] = a[istore + flatenwidth];\n    }\n\n\n    __syncthreads();\n    i = memloc(halowidth, blkmemwidth, ix, iy, 0);\n    ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, 0);\n    iright = memloc(halowidth, blkmemwidth, ix + 1, iy, 0);\n    itop = memloc(halowidth, blkmemwidth, ix, iy + 1, 0);\n    ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, 0);\n    iwrite = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    //a_left[i] = a_s[ileft];\n    //a_right[i] = a_s[iright];\n    //a_top[i] = a_s[itop];\n    //a_bot[i] = a_s[ibot];\n\n    //dadx[iwrite] = minmod2(theta, a_left[i], a_s[i], a_right[i]) / delta;\n    //dady[iwrite] = minmod2(theta, a_bot[i], a_s[i], a_top[i]) / delta;\n    dadx[iwrite] = minmod2(theta, a_s[ileft], a_s[i], a_s[iright]) / delta;\n\n    dady[iwrite] = minmod2(theta, a_s[ibot], a_s[i], a_s[itop]) / delta;\n\n    /*\n    dadx_out[i] = minmod2(theta, a_s[ileft], a_s[i], a_s[iright]) / delta;\n    dady_out[i] = minmod2(theta, a_s[ibot], a_s[i], a_s[itop]) / delta;\n\n\n    dadx[istore] = dadx_out[ism];// = a[istore];\n    dady[istore] = dady_out[ism];\n\n    if (ism &lt; (324 - (flatenwidth)))\n    {\n        dadx[istore + flatenwidth] = dadx_out[ism + flatenwidth];\n        dady[istore + flatenwidth] = dady_out[ism + flatenwidth];\n    }\n    */\n\n\n}\ntemplate __global__ void gradientSMC&lt;float&gt;(int halowidth, int* active, int* level, float theta, float dx, float* a, float* dadx, float* dady);\ntemplate __global__ void gradientSMC&lt;double&gt;(int halowidth, int* active, int* level, double theta, double dx, double* a, double* dadx, double* dady);\n\n\n\ntemplate &lt;class T&gt; __global__ void gradientedgeX(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx)\n{\n    //int *leftblk,int *rightblk,int* topblk, int * botblk,\n\n    //int ix = threadIdx.x+1;\n    //int iy = threadIdx.y+1;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = threadIdx.x;\n    int ix;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = active[ibl];\n\n    if (threadIdx.x == 0)\n    {\n        ix = 0;\n    }\n    else\n    {\n        ix = blockDim.y - 1;\n    }\n\n\n    int lev = level[ib];\n\n    T delta = calcres(dx, lev);\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    //int iright, ileft, ibot;\n    // shared array index to make the code bit more readable\n    //unsigned int sx = ix + halowidth;\n    //unsigned int sy = iy + halowidth;\n\n\n    T a_l, a_r, a_i;\n\n    a_i = a[i];\n\n\n    a_l = a[memloc(halowidth, blkmemwidth, ix - 1, iy, ib)];\n    //a_t = a[memloc(halowidth, blkmemwidth, ix, iy + 1, ib)];\n    a_r = a[memloc(halowidth, blkmemwidth, ix + 1, iy, ib)];\n    //a_b = a[memloc(halowidth, blkmemwidth, ix, iy - 1, ib)];\n    //__shared__ T a_s[18][18];\n\n\n\n    //__syncthreads();\n    //__syncwarp;\n\n    dadx[i] = minmod2(theta, a_l, a_i, a_r) / delta;\n\n\n\n\n}\ntemplate __global__ void gradientedgeX&lt;float&gt;(int halowidth,  int* active, int* level, float theta, float dx, float* a, float* dadx);\ntemplate __global__ void gradientedgeX&lt;double&gt;(int halowidth, int* active, int* level, double theta, double dx, double* a, double* dadx);\n\n\n\ntemplate &lt;class T&gt; __global__ void gradientedgeY(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dady)\n{\n    //int *leftblk,int *rightblk,int* topblk, int * botblk,\n\n    //int ix = threadIdx.x+1;\n    //int iy = threadIdx.y+1;\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy;\n    //unsigned int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = active[ibl];\n\n    int lev = level[ib];\n\n    T delta = calcres(dx, lev);\n\n    if (threadIdx.y == 0)\n    {\n        iy = 0;\n    }\n    else\n    {\n        iy = blockDim.x - 1;\n    }\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    //int iright, ileft, ibot;\n    // shared array index to make the code bit more readable\n    //unsigned int sx = ix + halowidth;\n    //unsigned int sy = iy + halowidth;\n\n\n    T  a_t, a_b, a_i;\n\n    a_i = a[i];\n\n\n    //a_l = a[memloc(halowidth, blkmemwidth, ix - 1, iy, ib)];\n    a_t = a[memloc(halowidth, blkmemwidth, ix, iy + 1, ib)];\n    //a_r = a[memloc(halowidth, blkmemwidth, ix + 1, iy, ib)];\n    a_b = a[memloc(halowidth, blkmemwidth, ix, iy - 1, ib)];\n    //__shared__ T a_s[18][18];\n\n\n\n    //__syncthreads();\n    //__syncwarp;\n\n    //dadx[i] = minmod2(theta, a_l, a_i, a_r) / delta;\n\n    dady[i] = minmod2(theta, a_b, a_i, a_t) / delta;\n\n\n}\ntemplate __global__ void gradientedgeY&lt;float&gt;(int halowidth, int* active, int* level, float theta, float dx, float* a, float* dady);\ntemplate __global__ void gradientedgeY&lt;double&gt;(int halowidth, int* active, int* level, double theta, double dx, double* a, double* dady);\n\n\n\ntemplate &lt;class T&gt; void gradientC(Param XParam, BlockP&lt;T&gt; XBlock, T* a, T* dadx, T* dady)\n{\n\n    int i,ib;\n    int xplus, xminus, yplus, yminus;\n\n    T delta;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        delta = calcres(T(XParam.delta), XBlock.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                i = memloc(XParam, ix,iy,ib);\n\n                //\n                xplus = memloc(XParam, ix+1, iy, ib);\n                xminus = memloc(XParam, ix-1, iy, ib);\n                yplus = memloc(XParam, ix, iy+1, ib);\n                yminus = memloc(XParam, ix, iy-1, ib);\n\n                dadx[i] = minmod2(T(XParam.theta), a[xminus], a[i], a[xplus]) / delta;\n                dady[i] = minmod2(T(XParam.theta), a[yminus], a[i], a[yplus]) / delta;\n            }\n\n\n        }\n\n\n    }\n\n\n\n}\ntemplate void gradientC&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* a, float* dadx, float* dady);\ntemplate void gradientC&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* a, double* dadx, double* dady);\n\ntemplate &lt;class T&gt; void gradientCPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n\n\n    std::thread t0(&amp;gradientC&lt;T&gt;, XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    std::thread t1(&amp;gradientC&lt;T&gt;, XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    std::thread t2(&amp;gradientC&lt;T&gt;, XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    std::thread t3(&amp;gradientC&lt;T&gt;, XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n    t0.join();\n    t1.join();\n    t2.join();\n    t3.join();\n\n    //fillHalo(XParam, XBlock, XGrad);\n\n    gradientHalo(XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    gradientHalo(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    gradientHalo(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    gradientHalo(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n    if (XParam.conserveElevation)\n    {\n        conserveElevationGradHalo(XParam, XBlock, XEv.h, XEv.zs, zb, XGrad.dhdx, XGrad.dzsdx, XGrad.dhdy, XGrad.dzsdy);\n\n    }\n\n\n    refine_linear(XParam,XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    refine_linear(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    refine_linear(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n    if (XParam.conserveElevation)\n    {\n        conserveElevation(XParam, XBlock, XEv, zb);\n    }\n    else if (XParam.wetdryfix)\n    {\n        WetDryProlongation(XParam, XBlock, XEv, zb);\n    }\n\n    RecalculateZs(XParam, XBlock, XEv, zb);\n\n    std::thread t4(&amp;gradientC&lt;T&gt;, XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    std::thread t5(&amp;gradientC&lt;T&gt;, XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    std::thread t6(&amp;gradientC&lt;T&gt;, XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    std::thread t7(&amp;gradientC&lt;T&gt;, XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n    t4.join();\n    t5.join();\n    t6.join();\n    t7.join();\n\n    gradientHalo(XParam, XBlock, XEv.h, XGrad.dhdx, XGrad.dhdy);\n    gradientHalo(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    gradientHalo(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    gradientHalo(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdy);\n\n    if (XParam.conserveElevation)\n    {\n        conserveElevationGradHalo(XParam, XBlock, XEv.h, XEv.zs, zb, XGrad.dhdx, XGrad.dzsdx, XGrad.dhdy, XGrad.dzsdy);\n\n    }\n\n    if (XParam.engine == 1)\n    {\n        WetsloperesetCPU(XParam, XBlock, XEv, XGrad, zb);\n\n        WetsloperesetHaloLeftCPU(XParam, XBlock, XEv, XGrad, zb);\n        WetsloperesetHaloRightCPU(XParam, XBlock, XEv, XGrad, zb);\n        WetsloperesetHaloBotCPU(XParam, XBlock, XEv, XGrad, zb);\n        WetsloperesetHaloTopCPU(XParam, XBlock, XEv, XGrad, zb);\n    }\n\n\n\n\n\n    //conserveElevationGradHalo(XParam, XBlock, XEv.zs, XGrad.dzsdx, XGrad.dzsdy);\n    //conserveElevationGradHalo(XParam, XBlock, XEv.u, XGrad.dudx, XGrad.dudy);\n    //conserveElevationGradHalo(XParam, XBlock, XEv.v, XGrad.dvdx, XGrad.dvdyythhhhhhhhhg);\n\n\n}\ntemplate void gradientCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt;XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, float * zb);\ntemplate void gradientCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt;XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, double * zb);\n\ntemplate &lt;class T&gt; void WetsloperesetCPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    int i, ib;\n    int xplus, xminus, yminus;\n\n    T delta;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        delta = calcres(T(XParam.delta), XBlock.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                i = memloc(XParam, ix, iy, ib);\n\n                //\n                xplus = memloc(XParam, ix + 1, iy, ib);\n                xminus = memloc(XParam, ix - 1, iy, ib);\n                //yplus = memloc(XParam, ix, iy + 1, ib);\n                yminus = memloc(XParam, ix, iy - 1, ib);\n\n                T dzsdxi = XGrad.dzsdx[i];\n                T dzsdyi = XGrad.dzsdy[i];\n\n\n\n\n                //Do X axis\n                if (utils::sq(dzsdxi) &gt; utils::sq(XGrad.dzbdx[i]))\n                {\n                    T leftzs, rightzs;\n                    leftzs = XEv.zs[i] - XEv.h[i] - delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n                    rightzs = XEv.zs[i] - XEv.h[i] + delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n\n                    if (leftzs &gt; XEv.zs[xminus] || rightzs &gt; XEv.zs[xplus])\n                    {\n                        XGrad.dzsdx[i] = XGrad.dhdx[i] + XGrad.dzbdx[i];\n                    }\n\n                }\n\n                //Do Y axis\n                if (utils::sq(dzsdyi) &gt; utils::sq(XGrad.dzbdy[i]))\n                {\n                    T botzs, topzs;\n                    botzs = XEv.zs[i] - XEv.h[i] - delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n                    topzs = XEv.zs[i] - XEv.h[i] + delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n\n                    if (botzs &gt; XEv.zs[yminus] || topzs &gt; XEv.zs[yminus])\n                    {\n                        XGrad.dzsdy[i] = XGrad.dhdy[i] + XGrad.dzbdy[i];\n                    }\n\n                }\n\n\n            }\n        }\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void WetsloperesetXGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n    T delta = calcres(XParam.delta, lev);\n\n\n    int i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n    int iright, ileft;\n    iright = memloc(XParam.halowidth, blkmemwidth, ix + 1, iy, ib);\n    ileft = memloc(XParam.halowidth, blkmemwidth, ix - 1, iy, ib);\n\n    T dzsdxi = XGrad.dzsdx[i];\n\n\n    if (utils::sq(dzsdxi) &gt; utils::sq(XGrad.dzbdx[i]))\n    {\n        T leftzs, rightzs;\n        leftzs = XEv.zs[i] - XEv.h[i] - delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n        rightzs = XEv.zs[i] - XEv.h[i] + delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n\n        if (leftzs &gt; XEv.zs[ileft] || rightzs &gt; XEv.zs[iright])\n        {\n            XGrad.dzsdx[i] = XGrad.dhdx[i] + XGrad.dzbdx[i];\n        }\n\n    }\n\n\n}\n\ntemplate &lt;class T&gt; __global__ void WetsloperesetYGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n    T delta = calcres(XParam.delta, lev);\n\n\n    int i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n    int itop, ibot;\n    itop = memloc(XParam.halowidth, blkmemwidth, ix, iy + 1, ib);\n    ibot = memloc(XParam.halowidth, blkmemwidth, ix, iy - 1, ib);\n\n    T dzsdyi = XGrad.dzsdy[i];\n\n\n    if (utils::sq(dzsdyi) &gt; utils::sq(XGrad.dzbdy[i]))\n    {\n        T botzs, topzs;\n        botzs = XEv.zs[i] - XEv.h[i] - delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n        topzs = XEv.zs[i] - XEv.h[i] + delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n\n        if (botzs &gt; XEv.zs[ibot] || topzs &gt; XEv.zs[itop])\n        {\n            XGrad.dzsdy[i] = XGrad.dhdy[i] + XGrad.dzbdy[i];\n        }\n\n    }\n\n\n}\n\ntemplate &lt;class T&gt; __global__ void WetsloperesetHaloLeftGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int ix = -1;\n    int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n\n    T delta = calcres(XParam.delta, lev);\n\n    T zsi, zsright, zsleft;\n\n    int i, iright;\n    i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n    iright = memloc(XParam.halowidth, blkmemwidth, ix + 1, iy, ib);\n\n    zsi = XEv.zs[i];\n    zsright = XEv.zs[iright];\n\n    int read, jj, ii, ir, it, itr;\n\n    if (XBlock.LeftBot[ib] == ib)//The lower half is a boundary \n    {\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            zsleft = XEv.zs[read];\n        }\n\n        if (XBlock.LeftTop[ib] == ib) // boundary on the top half too\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);\n\n                zsleft = XEv.zs[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                zsleft = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.LeftBot[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), iy, XBlock.LeftBot[ib]);\n        zsleft = XEv.zs[read];\n\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = iy * 2;\n            int bb = XBlock.LeftBot[ib];\n\n            ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, bb);\n            ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, bb);\n            it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, bb);\n            itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, bb);\n\n            zsleft = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.LeftTop[ib] == ib)\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);\n\n                zsleft = XEv.zs[read];\n            }\n        }\n        else\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                zsleft = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + XParam.blkwidth / 2;\n        T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 1), jj, XBlock.LeftBot[ib]);\n        ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), jj, XBlock.LeftBot[ib]);\n        it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 1), jj - 1, XBlock.LeftBot[ib]);\n        itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), jj - 1, XBlock.LeftBot[ib]);\n\n        zsleft = BilinearInterpolation(XEv.zs[itr], XEv.zs[ir], XEv.zs[it], XEv.zs[ii], T(0.0), T(1.0), T(0.0), T(1.0), T(0.75), jr);\n    }\n\n\n    T dzsdxi = XGrad.dzsdx[i];\n\n\n    if (utils::sq(dzsdxi) &gt; utils::sq(XGrad.dzbdx[i]))\n    {\n        T leftzs, rightzs;\n        leftzs = zsi - XEv.h[i] - delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n        rightzs = zsi - XEv.h[i] + delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n\n        if (leftzs &gt; zsleft || rightzs &gt; zsright)\n        {\n            XGrad.dzsdx[i] = XGrad.dhdx[i] + XGrad.dzbdx[i];\n        }\n\n    }\n\n\n}\n\ntemplate &lt;class T&gt; void WetsloperesetHaloLeftCPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n\n\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int ix = -1;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n\n        unsigned int ib = XBlock.active[ibl];\n\n        int lev = XBlock.level[ib];\n\n\n        T delta = calcres(XParam.delta, lev);\n\n        T zsi, zsright, zsleft;\n\n        for (int iy = 0; iy &lt;= XParam.blkwidth; iy++)\n        {\n\n            int i, iright;\n            i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n            iright = memloc(XParam.halowidth, blkmemwidth, ix + 1, iy, ib);\n\n            zsi = XEv.zs[i];\n            zsright = XEv.zs[iright];\n\n            int read, jj, ii, ir, it, itr;\n\n            if (XBlock.LeftBot[ib] == ib)//The lower half is a boundary \n            {\n                if (iy &lt; (XParam.blkwidth / 2))\n                {\n\n                    read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n                    zsleft = XEv.zs[read];\n                }\n\n                if (XBlock.LeftTop[ib] == ib) // boundary on the top half too\n                {\n                    if (iy &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n\n                        read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);\n\n                        zsleft = XEv.zs[read];\n                    }\n                }\n                else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n                {\n\n                    if (iy &gt;= (XParam.blkwidth / 2))\n                    {\n\n                        jj = (iy - XParam.blkwidth / 2) * 2;\n                        ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                        ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                        it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                        itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                        zsleft = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n\n                    }\n                }\n            }\n            else if (XBlock.level[ib] == XBlock.level[XBlock.LeftBot[ib]]) // LeftTop block does not exist\n            {\n\n                read = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), iy, XBlock.LeftBot[ib]);\n                zsleft = XEv.zs[read];\n\n            }\n            else if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])\n            {\n\n                if (iy &lt; (XParam.blkwidth / 2))\n                {\n\n                    jj = iy * 2;\n                    int bb = XBlock.LeftBot[ib];\n\n                    ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, bb);\n                    ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, bb);\n                    it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, bb);\n                    itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, bb);\n\n                    zsleft = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n                }\n                //now find out aboy lefttop block\n                if (XBlock.LeftTop[ib] == ib)\n                {\n                    if (iy &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n\n                        read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);\n\n                        zsleft = XEv.zs[read];\n                    }\n                }\n                else\n                {\n                    if (iy &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n                        jj = (iy - XParam.blkwidth / 2) * 2;\n                        ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                        ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                        it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                        itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                        zsleft = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n                    }\n                }\n\n            }\n            else if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n            {\n                jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib ? ftoi(ceil(iy * (T)0.5)) : ftoi(ceil(iy * (T)0.5) + XParam.blkwidth / 2);\n                T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n                ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 1), jj, XBlock.LeftBot[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), jj, XBlock.LeftBot[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 1), jj - 1, XBlock.LeftBot[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), jj - 1, XBlock.LeftBot[ib]);\n\n                zsleft = BilinearInterpolation(XEv.zs[itr], XEv.zs[ir], XEv.zs[it], XEv.zs[ii], T(0.0), T(1.0), T(0.0), T(1.0), T(0.75), jr);\n            }\n\n\n            T dzsdxi = XGrad.dzsdx[i];\n\n\n            if (utils::sq(dzsdxi) &gt; utils::sq(XGrad.dzbdx[i]))\n            {\n                T leftzs, rightzs;\n                leftzs = zsi - XEv.h[i] - delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n                rightzs = zsi - XEv.h[i] + delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n\n                if (leftzs &gt; zsleft || rightzs &gt; zsright)\n                {\n                    XGrad.dzsdx[i] = XGrad.dhdx[i] + XGrad.dzbdx[i];\n                }\n\n            }\n        }\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void WetsloperesetHaloRightGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int ix = XParam.blkwidth;\n    int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n    int i, jj, ii, ir, it, itr;\n    int read;\n\n    int lev = XBlock.level[ib];\n\n    T delta = calcres(XParam.delta, lev);\n\n\n    i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n    int ileft;\n\n    ileft = memloc(XParam.halowidth, blkmemwidth, ix - 1, iy, ib);\n\n    T zsi, zsleft, zsright;\n\n    zsi = XEv.zs[i];\n    zsleft = XEv.zs[ileft];\n\n    T dzsdxi = XGrad.dzsdx[i];\n\n\n    if (XBlock.RightBot[ib] == ib)//The lower half is a boundary \n    {\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            zsright = XEv.zs[read];;\n        }\n\n        if (XBlock.RightTop[ib] == ib) // boundary on the top half too\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);\n\n                zsright = XEv.zs[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, XBlock.RightTop[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, XBlock.RightTop[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, XBlock.RightTop[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, XBlock.RightTop[ib]);\n\n                zsright = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.RightBot[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam.halowidth, blkmemwidth, 1, iy, XBlock.RightBot[ib]);\n        zsright = XEv.zs[read];\n\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = iy * 2;\n            int bb = XBlock.RightBot[ib];\n\n            ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, bb);\n            ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, bb);\n            it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, bb);\n            itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, bb);\n\n            zsright = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.RightTop[ib] == ib)\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);\n\n                zsright = XEv.zs[read];\n            }\n        }\n        else\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, XBlock.RightTop[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, XBlock.RightTop[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, XBlock.RightTop[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, XBlock.RightTop[ib]);\n\n                zsright = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + XParam.blkwidth / 2;\n        T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightBot[ib]);\n        ir = memloc(XParam.halowidth, blkmemwidth, 1, jj, XBlock.RightBot[ib]);\n        it = memloc(XParam.halowidth, blkmemwidth, 0, jj - 1, XBlock.RightBot[ib]);\n        itr = memloc(XParam.halowidth, blkmemwidth, 1, jj - 1, XBlock.RightBot[ib]);\n\n        zsright = BilinearInterpolation(XEv.zs[it], XEv.zs[ii], XEv.zs[itr], XEv.zs[ir], T(0.0), T(1.0), T(0.0), T(1.0), T(0.25), jr);\n    }\n\n\n\n\n\n\n\n    if (utils::sq(dzsdxi) &gt; utils::sq(XGrad.dzbdx[i]))\n    {\n        T leftzs, rightzs;\n        leftzs = zsi - XEv.h[i] - delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n        rightzs = zsi - XEv.h[i] + delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n\n        if (leftzs &gt; zsleft || rightzs &gt; zsright)\n        {\n            XGrad.dzsdx[i] = XGrad.dhdx[i] + XGrad.dzbdx[i];\n        }\n\n    }\n\n\n}\n\ntemplate &lt;class T&gt; void WetsloperesetHaloRightCPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int ix = XParam.blkwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n\n\n\n            unsigned int ib = XBlock.active[ibl];\n            int i, jj, ii, ir, it, itr;\n            int read;\n\n            int lev = XBlock.level[ib];\n\n            T delta = calcres(XParam.delta, lev);\n\n\n            i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n            int  ileft;\n\n            ileft = memloc(XParam.halowidth, blkmemwidth, ix - 1, iy, ib);\n\n            T zsi, zsleft, zsright;\n\n            zsi = XEv.zs[i];\n            zsleft = XEv.zs[ileft];\n\n            T dzsdxi = XGrad.dzsdx[i];\n\n\n            if (XBlock.RightBot[ib] == ib)//The lower half is a boundary \n            {\n                if (iy &lt; (XParam.blkwidth / 2))\n                {\n\n                    read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n                    zsright = XEv.zs[read];;\n                }\n\n                if (XBlock.RightTop[ib] == ib) // boundary on the top half too\n                {\n                    if (iy &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n\n                        read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);\n\n                        zsright = XEv.zs[read];\n                    }\n                }\n                else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n                {\n\n                    if (iy &gt;= (XParam.blkwidth / 2))\n                    {\n\n                        jj = (iy - XParam.blkwidth / 2) * 2;\n                        ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, XBlock.RightTop[ib]);\n                        ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, XBlock.RightTop[ib]);\n                        it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, XBlock.RightTop[ib]);\n                        itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, XBlock.RightTop[ib]);\n\n                        zsright = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n\n                    }\n                }\n            }\n            else if (XBlock.level[ib] == XBlock.level[XBlock.RightBot[ib]]) // LeftTop block does not exist\n            {\n\n                read = memloc(XParam.halowidth, blkmemwidth, 1, iy, XBlock.RightBot[ib]);\n                zsright = XEv.zs[read];\n\n            }\n            else if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])\n            {\n\n                if (iy &lt; (XParam.blkwidth / 2))\n                {\n\n                    jj = iy * 2;\n                    int bb = XBlock.RightBot[ib];\n\n                    ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, bb);\n                    ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, bb);\n                    it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, bb);\n                    itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, bb);\n\n                    zsright = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n                }\n                //now find out aboy lefttop block\n                if (XBlock.RightTop[ib] == ib)\n                {\n                    if (iy &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n\n                        read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);\n\n                        zsright = XEv.zs[read];\n                    }\n                }\n                else\n                {\n                    if (iy &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n                        jj = (iy - XParam.blkwidth / 2) * 2;\n                        ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, XBlock.RightTop[ib]);\n                        ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, XBlock.RightTop[ib]);\n                        it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, XBlock.RightTop[ib]);\n                        itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, XBlock.RightTop[ib]);\n\n                        zsright = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n                    }\n                }\n\n            }\n            else if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n            {\n                jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? ftoi(ceil(iy * (T)0.5)) : ftoi(ceil(iy * (T)0.5) + XParam.blkwidth / 2);\n                T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n                ii = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightBot[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, 1, jj, XBlock.RightBot[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, 0, jj - 1, XBlock.RightBot[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, 1, jj - 1, XBlock.RightBot[ib]);\n\n                zsright = BilinearInterpolation(XEv.zs[it], XEv.zs[ii], XEv.zs[itr], XEv.zs[ir], T(0.0), T(1.0), T(0.0), T(1.0), T(0.25), jr);\n            }\n\n\n\n\n\n\n\n            if (utils::sq(dzsdxi) &gt; utils::sq(XGrad.dzbdx[i]))\n            {\n                T leftzs, rightzs;\n                leftzs = zsi - XEv.h[i] - delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n                rightzs = zsi - XEv.h[i] + delta * T(0.5) * (dzsdxi - XGrad.dhdx[i]);\n\n                if (leftzs &gt; zsleft || rightzs &gt; zsright)\n                {\n                    XGrad.dzsdx[i] = XGrad.dhdx[i] + XGrad.dzbdx[i];\n                }\n\n            }\n        }\n\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void WetsloperesetHaloBotGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int iy = -1;\n    int ix = threadIdx.x;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i, jj, ii, ir, it, itr;\n\n    int lev = XBlock.level[ib];\n\n    T delta = calcres(XParam.delta, lev);\n\n\n    i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n    int itop,read;\n    itop = memloc(XParam.halowidth, blkmemwidth, ix, iy + 1, ib);\n\n    T zsi, zstop, zsbot;\n\n    T dzsdyi = XGrad.dzsdy[i];\n\n    zsi = XEv.zs[i];\n    zstop = XEv.zs[itop];\n\n\n    if (XBlock.BotLeft[ib] == ib)//The lower half is a boundary \n    {\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            zsbot = XEv.zs[read];\n\n        }\n\n        if (XBlock.BotRight[ib] == ib) // boundary on the top half too\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);\n\n                zsbot = XEv.zs[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                zsbot = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.BotLeft[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam.halowidth, blkmemwidth, ix, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n        zsbot = XEv.zs[read];\n\n\n\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = ix * 2;\n            int bb = XBlock.BotLeft[ib];\n\n            ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), bb);\n            ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), bb);\n            it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), bb);\n            itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), bb);\n\n            zsbot = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.BotRight[ib] == ib)\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);\n\n                zsbot = XEv.zs[read];\n            }\n        }\n        else\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                zsbot = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + XParam.blkwidth / 2;\n        T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n        ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n        it = memloc(XParam.halowidth, blkmemwidth, jj - 1, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n        itr = memloc(XParam.halowidth, blkmemwidth, jj - 1, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n\n        zsbot = BilinearInterpolation(XEv.zs[itr], XEv.zs[it], XEv.zs[ir], XEv.zs[ii], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.75));\n    }\n\n\n    if (utils::sq(dzsdyi) &gt; utils::sq(XGrad.dzbdy[i]))\n    {\n        T botzs, topzs;\n        botzs = zsi - XEv.h[i] - delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n        topzs = zsi - XEv.h[i] + delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n\n        if (botzs &gt; zsbot || topzs &gt; zstop)\n        {\n            XGrad.dzsdy[i] = XGrad.dhdy[i] + XGrad.dzbdy[i];\n        }\n\n    }\n\n\n}\n\ntemplate &lt;class T&gt; void WetsloperesetHaloBotCPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int iy = -1;\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n\n\n        unsigned int ib = XBlock.active[ibl];\n\n\n\n        int i, jj, ii, ir, it, itr;\n\n        int lev = XBlock.level[ib];\n\n        T delta = calcres(XParam.delta, lev);\n\n        for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n        {\n\n\n            i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n            int itop, read;\n            itop = memloc(XParam.halowidth, blkmemwidth, ix, iy + 1, ib);\n\n            T zsi, zstop, zsbot;\n\n            T dzsdyi = XGrad.dzsdy[i];\n\n            zsi = XEv.zs[i];\n            zstop = XEv.zs[itop];\n\n\n            if (XBlock.BotLeft[ib] == ib)//The lower half is a boundary \n            {\n                if (ix &lt; (XParam.blkwidth / 2))\n                {\n\n                    read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n                    zsbot = XEv.zs[read];\n\n                }\n\n                if (XBlock.BotRight[ib] == ib) // boundary on the top half too\n                {\n                    if (ix &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n\n                        read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);\n\n                        zsbot = XEv.zs[read];\n                    }\n                }\n                else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n                {\n\n                    if (ix &gt;= (XParam.blkwidth / 2))\n                    {\n\n                        jj = (ix - XParam.blkwidth / 2) * 2;\n                        ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                        ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                        it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                        itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                        zsbot = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n\n                    }\n                }\n            }\n            else if (XBlock.level[ib] == XBlock.level[XBlock.BotLeft[ib]]) // LeftTop block does not exist\n            {\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n                zsbot = XEv.zs[read];\n\n\n\n            }\n            else if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n            {\n\n                if (ix &lt; (XParam.blkwidth / 2))\n                {\n\n                    jj = ix * 2;\n                    int bb = XBlock.BotLeft[ib];\n\n                    ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), bb);\n                    ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), bb);\n                    it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), bb);\n                    itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), bb);\n\n                    zsbot = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n                }\n                //now find out aboy lefttop block\n                if (XBlock.BotRight[ib] == ib)\n                {\n                    if (ix &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n\n                        read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);\n\n                        zsbot = XEv.zs[read];\n                    }\n                }\n                else\n                {\n                    if (ix &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n                        jj = (ix - XParam.blkwidth / 2) * 2;\n                        ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                        ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                        it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                        itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                        zsbot = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n                    }\n                }\n\n            }\n            else if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n            {\n                jj = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? ftoi(ceil(ix * (T)0.5)) : ftoi(ceil(ix * (T)0.5) + XParam.blkwidth / 2);\n                T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj - 1, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj - 1, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n\n                zsbot = BilinearInterpolation(XEv.zs[itr], XEv.zs[it], XEv.zs[ir], XEv.zs[ii], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.75));\n            }\n\n\n            if (utils::sq(dzsdyi) &gt; utils::sq(XGrad.dzbdy[i]))\n            {\n                T botzs, topzs;\n                botzs = zsi - XEv.h[i] - delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n                topzs = zsi - XEv.h[i] + delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n\n                if (botzs &gt; zsbot || topzs &gt; zstop)\n                {\n                    XGrad.dzsdy[i] = XGrad.dhdy[i] + XGrad.dzbdy[i];\n                }\n\n            }\n        }\n\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void WetsloperesetHaloTopGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int iy = XParam.blkwidth;\n    int ix = threadIdx.x;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i, jj, ii, ir, it, itr;\n\n    int lev = XBlock.level[ib];\n\n    T delta = calcres(XParam.delta, lev);\n\n\n    i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n    int ibot, read;\n\n    ibot = memloc(XParam.halowidth, blkmemwidth, ix, iy - 1, ib);\n\n    T zsi, zstop, zsbot;\n\n    zsi = XEv.zs[i];\n    zsbot = XEv.zs[ibot];\n\n    T dzsdyi = XGrad.dzsdy[i];\n\n\n    if (XBlock.TopLeft[ib] == ib)//The lower half is a boundary \n    {\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            zstop = XEv.zs[read];\n\n        }\n\n        if (XBlock.TopRight[ib] == ib) // boundary on the top half too\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n                zstop = XEv.zs[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, XBlock.TopRight[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, XBlock.TopRight[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, XBlock.TopRight[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, XBlock.TopRight[ib]);\n\n                zstop = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.TopLeft[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam.halowidth, blkmemwidth, ix, 1, XBlock.TopLeft[ib]);\n        zstop = XEv.zs[read];\n\n\n\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = ix * 2;\n            int bb = XBlock.TopLeft[ib];;\n\n            ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, bb);\n            ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, bb);\n            it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, bb);\n            itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, bb);\n\n            zstop = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.TopRight[ib] == ib)\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n                zstop = XEv.zs[read];\n            }\n        }\n        else\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, XBlock.TopRight[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, XBlock.TopRight[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, XBlock.TopRight[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, XBlock.TopRight[ib]);\n\n                zstop = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + XParam.blkwidth / 2;\n        T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam.halowidth, blkmemwidth, jj, 0, XBlock.TopLeft[ib]);\n        ir = memloc(XParam.halowidth, blkmemwidth, jj, 1, XBlock.TopLeft[ib]);\n        it = memloc(XParam.halowidth, blkmemwidth, jj - 1, 0, XBlock.TopLeft[ib]);\n        itr = memloc(XParam.halowidth, blkmemwidth, jj - 1, 1, XBlock.TopLeft[ib]);\n\n        zstop = BilinearInterpolation(XEv.zs[it], XEv.zs[itr], XEv.zs[ii], XEv.zs[ir], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.25));\n    }\n\n\n    if (utils::sq(dzsdyi) &gt; utils::sq(XGrad.dzbdy[i]))\n    {\n        T botzs, topzs;\n        botzs = zsi - XEv.h[i] - delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n        topzs = zsi - XEv.h[i] + delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n\n        if (botzs &gt; zsbot || topzs &gt; zstop)\n        {\n            XGrad.dzsdy[i] = XGrad.dhdy[i] + XGrad.dzbdy[i];\n        }\n\n    }\n\n\n}\n\n\ntemplate &lt;class T&gt;  void WetsloperesetHaloTopCPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int iy = XParam.blkwidth;\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        unsigned int ib = XBlock.active[ibl];\n\n        int i, jj, ii, ir, it, itr;\n\n        int lev = XBlock.level[ib];\n\n        T delta = calcres(XParam.delta, lev);\n\n        for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n        {\n\n            i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n            int ibot, read;\n\n            ibot = memloc(XParam.halowidth, blkmemwidth, ix, iy - 1, ib);\n\n            T zsi, zstop, zsbot;\n\n            zsi = XEv.zs[i];\n            zsbot = XEv.zs[ibot];\n\n            T dzsdyi = XGrad.dzsdy[i];\n\n\n            if (XBlock.TopLeft[ib] == ib)//The lower half is a boundary \n            {\n                if (ix &lt; (XParam.blkwidth / 2))\n                {\n\n                    read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n                    zstop = XEv.zs[read];\n\n                }\n\n                if (XBlock.TopRight[ib] == ib) // boundary on the top half too\n                {\n                    if (ix &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n\n                        read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n                        zstop = XEv.zs[read];\n                    }\n                }\n                else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n                {\n\n                    if (ix &gt;= (XParam.blkwidth / 2))\n                    {\n\n                        jj = (ix - XParam.blkwidth / 2) * 2;\n                        ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, XBlock.TopRight[ib]);\n                        ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, XBlock.TopRight[ib]);\n                        it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, XBlock.TopRight[ib]);\n                        itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, XBlock.TopRight[ib]);\n\n                        zstop = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n\n                    }\n                }\n            }\n            else if (XBlock.level[ib] == XBlock.level[XBlock.TopLeft[ib]]) // LeftTop block does not exist\n            {\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, 1, XBlock.TopLeft[ib]);\n                zstop = XEv.zs[read];\n\n\n\n            }\n            else if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n            {\n\n                if (ix &lt; (XParam.blkwidth / 2))\n                {\n\n                    jj = ix * 2;\n                    int bb = XBlock.TopLeft[ib];;\n\n                    ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, bb);\n                    ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, bb);\n                    it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, bb);\n                    itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, bb);\n\n                    zstop = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n                }\n                //now find out aboy lefttop block\n                if (XBlock.TopRight[ib] == ib)\n                {\n                    if (ix &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n\n                        read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n                        zstop = XEv.zs[read];\n                    }\n                }\n                else\n                {\n                    if (ix &gt;= (XParam.blkwidth / 2))\n                    {\n                        //\n                        jj = (ix - XParam.blkwidth / 2) * 2;\n                        ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, XBlock.TopRight[ib]);\n                        ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, XBlock.TopRight[ib]);\n                        it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, XBlock.TopRight[ib]);\n                        itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, XBlock.TopRight[ib]);\n\n                        zstop = T(0.25) * (XEv.zs[ii] + XEv.zs[ir] + XEv.zs[it] + XEv.zs[itr]);\n                    }\n                }\n\n            }\n            else if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n            {\n                jj = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? ftoi(ceil(ix * (T)0.5)) : ftoi(ceil(ix * (T)0.5) + XParam.blkwidth / 2);\n                T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, 0, XBlock.TopLeft[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, 1, XBlock.TopLeft[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj - 1, 0, XBlock.TopLeft[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj - 1, 1, XBlock.TopLeft[ib]);\n\n                zstop = BilinearInterpolation(XEv.zs[it], XEv.zs[itr], XEv.zs[ii], XEv.zs[ir], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.25));\n            }\n\n\n            if (utils::sq(dzsdyi) &gt; utils::sq(XGrad.dzbdy[i]))\n            {\n                T botzs, topzs;\n                botzs = zsi - XEv.h[i] - delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n                topzs = zsi - XEv.h[i] + delta * T(0.5) * (dzsdyi - XGrad.dhdy[i]);\n\n                if (botzs &gt; zsbot || topzs &gt; zstop)\n                {\n                    XGrad.dzsdy[i] = XGrad.dhdy[i] + XGrad.dzbdy[i];\n                }\n\n            }\n        }\n    }\n\n\n}\n\ntemplate &lt;class T&gt; void gradientHalo(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    int ib;\n    //int xplus;\n\n    //T delta;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            gradientHaloLeft(XParam, XBlock, ib, iy, a, dadx, dady);\n            gradientHaloRight(XParam, XBlock, ib, iy, a, dadx, dady);\n        }\n        for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n        {\n            gradientHaloBot(XParam, XBlock, ib, ix, a, dadx, dady);\n            gradientHaloTop(XParam, XBlock, ib, ix, a, dadx, dady);\n        }\n    }\n}\n\ntemplate &lt;class T&gt; void gradientHaloGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    dim3 blockDimL(1, XParam.blkwidth, 1);\n    dim3 blockDimB(XParam.blkwidth, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n\n    gradientHaloLeftGPU &lt;&lt;&lt; gridDim, blockDimL, 0 &gt;&gt;&gt; (XParam, XBlock, a, dadx, dady);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradientHaloRightGPU &lt;&lt;&lt; gridDim, blockDimL, 0 &gt;&gt;&gt; (XParam, XBlock, a, dadx, dady);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradientHaloBotGPU &lt;&lt;&lt; gridDim, blockDimB, 0 &gt;&gt;&gt; (XParam, XBlock, a, dadx, dady);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradientHaloTopGPU &lt;&lt;&lt; gridDim, blockDimB, 0 &gt;&gt;&gt; (XParam, XBlock, a, dadx, dady);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n}\n\ntemplate &lt;class T&gt; void gradientHaloGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    const int num_streams = 4;\n\n    cudaStream_t streams[num_streams];\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n    }\n\n    dim3 blockDimL(2, XParam.blkwidth, 1);\n    dim3 blockDimB(XParam.blkwidth, 2, 1);\n    dim3 gridDim(ceil(XParam.nblk/2), 1, 1);\n\n\n    gradientHaloLeftGPUnew &lt;&lt;&lt; gridDim, blockDimL, 0, streams[0] &gt;&gt;&gt; (XParam, XBlock, a, dadx, dady);\n\n\n    gradientHaloRightGPUnew &lt;&lt;&lt; gridDim, blockDimL, 0, streams[1] &gt;&gt;&gt; (XParam, XBlock, a, dadx, dady);\n\n\n    gradientHaloBotGPUnew &lt;&lt;&lt; gridDim, blockDimB, 0, streams[2] &gt;&gt;&gt; (XParam, XBlock, a, dadx, dady);\n\n\n    gradientHaloTopGPUnew &lt;&lt;&lt; gridDim, blockDimB, 0, streams[3] &gt;&gt;&gt; (XParam, XBlock, a, dadx, dady);\n\n    //CUDA_CHECK(cudaDeviceSynchronize());\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamDestroy(streams[i]);\n    }\n\n\n}\n\ntemplate &lt;class T&gt; void gradientHaloLeft(Param XParam, BlockP&lt;T&gt;XBlock, int ib, int iy, T* a, T* dadx, T* dady)\n{\n    int i, ix, jj, ii, ir, it, itr;\n    int xplus, read;\n\n    T delta, aright, aleft;\n\n    ix = -1;\n\n    i = memloc(XParam, ix, iy, ib);\n    xplus = memloc(XParam, ix + 1, iy, ib);\n\n\n    aright = a[xplus];\n\n\n\n    delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n    if (XBlock.LeftBot[ib] == ib)//The lower half is a boundary \n    {\n        if ( iy &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam, 0, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            aleft = a[read];\n        }\n\n        if (XBlock.LeftTop[ib] == ib) // boundary on the top half too\n        {\n            if ( iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam, 0, iy, ib);\n\n                aleft = a[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                ir = memloc(XParam, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                it = memloc(XParam, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                itr = memloc(XParam, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.LeftBot[ib]]) // LeftTop block does not exist\n    {\n\n            read = memloc(XParam, (XParam.blkwidth - 2), iy, XBlock.LeftBot[ib]);\n            aleft = a[read];\n\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (iy &lt; (XParam.blkwidth / 2))\n        {   \n\n            jj = iy * 2;\n            int bb = XBlock.LeftBot[ib];\n\n            ii = memloc(XParam, (XParam.blkwidth - 3), jj, bb);\n            ir = memloc(XParam, (XParam.blkwidth - 4), jj, bb);\n            it = memloc(XParam, (XParam.blkwidth - 3), jj + 1, bb);\n            itr = memloc(XParam, (XParam.blkwidth - 4), jj + 1, bb);\n\n            aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.LeftTop[ib] == ib)\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam, 0, iy, ib);\n\n                aleft = a[read];\n            }\n        }\n        else\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                ir = memloc(XParam, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                it = memloc(XParam, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                itr = memloc(XParam, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib ? ftoi(ceil(iy * (T)0.5)) : ftoi(ceil(iy * (T)0.5) + XParam.blkwidth / 2);\n        //T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.75) : T(0.25);// This is the wrong way around\n        T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75); // This is right (e.g. at iy==0 use 0.75 at iy==1 use 0.25)\n\n        ii = memloc(XParam, (XParam.blkwidth - 1), jj, XBlock.LeftBot[ib]);\n        ir = memloc(XParam, (XParam.blkwidth - 2), jj, XBlock.LeftBot[ib]);\n        it = memloc(XParam, (XParam.blkwidth - 1), jj - 1, XBlock.LeftBot[ib]);\n        itr = memloc(XParam, (XParam.blkwidth - 2), jj - 1, XBlock.LeftBot[ib]);\n\n        aleft = BilinearInterpolation(a[itr], a[ir], a[it], a[ii], T(0.0), T(1.0), T(0.0), T(1.0), T(0.75), jr);\n    }\n\n\n\n\n\n    dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n    //dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n\n}\n\ntemplate &lt;class T&gt; void gradientHaloRight(Param XParam, BlockP&lt;T&gt;XBlock, int ib, int iy, T* a, T* dadx, T* dady)\n{\n    int i, ix, jj, ii, ir, it, itr;\n    int xminus, read;\n\n    T delta, aright, aleft;\n\n    ix = 16;\n\n    i = memloc(XParam, ix, iy, ib);\n    xminus = memloc(XParam, ix - 1, iy, ib);\n\n\n    aleft = a[xminus];\n\n\n\n    delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n    if (XBlock.RightBot[ib] == ib)//The lower half is a boundary \n    {\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam, XParam.blkwidth -1, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            aright = a[read];\n        }\n\n        if (XBlock.RightTop[ib] == ib) // boundary on the top half too\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam, XParam.blkwidth - 1, iy, ib);\n\n                aright = a[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of righttopib is levelib+1\n        {\n\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, 3, jj, XBlock.RightTop[ib]);\n                ir = memloc(XParam, 2, jj, XBlock.RightTop[ib]);\n                it = memloc(XParam, 3, jj + 1, XBlock.RightTop[ib]);\n                itr = memloc(XParam, 2, jj + 1, XBlock.RightTop[ib]);\n\n                aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.RightBot[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam, 1, iy, XBlock.RightBot[ib]);\n        aright = a[read];\n\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = iy * 2;\n            int bb = XBlock.RightBot[ib];\n\n            ii = memloc(XParam, 3, jj, bb);\n            ir = memloc(XParam, 2, jj, bb);\n            it = memloc(XParam, 3, jj + 1, bb);\n            itr = memloc(XParam, 2, jj + 1, bb);\n\n            aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.RightTop[ib] == ib)\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam, XParam.blkwidth - 1, iy, ib);\n\n                aright = a[read];\n            }\n        }\n        else\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, 3, jj, XBlock.RightTop[ib]);\n                ir = memloc(XParam, 2, jj, XBlock.RightTop[ib]);\n                it = memloc(XParam, 3, jj + 1, XBlock.RightTop[ib]);\n                itr = memloc(XParam, 2, jj + 1, XBlock.RightTop[ib]);\n\n                aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? ftoi(ceil(iy * (T)0.5)) : ftoi(ceil(iy * (T)0.5) + XParam.blkwidth / 2);\n        T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam, 0, jj, XBlock.RightBot[ib]);\n        ir = memloc(XParam, 1, jj, XBlock.RightBot[ib]);\n        it = memloc(XParam, 0, jj - 1, XBlock.RightBot[ib]);\n        itr = memloc(XParam, 1, jj - 1, XBlock.RightBot[ib]);\n\n        aright = BilinearInterpolation(a[it], a[ii], a[itr], a[ir], T(0.0), T(1.0), T(0.0), T(1.0), T(0.25), jr);\n    }\n\n\n\n\n\n    dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n    //dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n\n}\n\ntemplate &lt;class T&gt; void gradientHaloBot(Param XParam, BlockP&lt;T&gt;XBlock, int ib, int ix, T* a, T* dadx, T* dady)\n{\n    int i, iy, jj, ii, ir, it, itr;\n    int yplus, read;\n\n    T delta, atop, abot;\n\n    iy = -1;\n\n    i = memloc(XParam, ix, iy, ib);\n    yplus = memloc(XParam, ix , iy + 1, ib);\n\n\n\n\n    atop = a[yplus];\n\n\n\n    delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n    if (XBlock.BotLeft[ib] == ib)//The lower half is a boundary \n    {\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam, ix, 0, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            abot = a[read];\n\n        }\n\n        if (XBlock.BotRight[ib] == ib) // boundary on the top half too\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam, ix, 0, ib);\n\n                abot = a[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                ir = memloc(XParam, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                it = memloc(XParam, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                itr = memloc(XParam, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.BotLeft[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam, ix, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n        abot = a[read];\n\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = ix * 2;\n            int bb = XBlock.BotLeft[ib];\n\n            ii = memloc(XParam, jj, (XParam.blkwidth - 3), bb);\n            ir = memloc(XParam, jj, (XParam.blkwidth - 4), bb);\n            it = memloc(XParam, jj + 1, (XParam.blkwidth - 3), bb);\n            itr = memloc(XParam, jj + 1, (XParam.blkwidth - 4), bb);\n\n            abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.BotRight[ib] == ib)\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam, ix, 0, ib);\n\n                abot = a[read];\n            }\n        }\n        else\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                ir = memloc(XParam, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                it = memloc(XParam, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                itr = memloc(XParam, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? ftoi(ceil(ix * (T)0.5)) : ftoi(ceil(ix * (T)0.5) + XParam.blkwidth / 2);\n        T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam, jj, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n        ir = memloc(XParam, jj, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n        it = memloc(XParam, jj - 1, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n        itr = memloc(XParam, jj - 1, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n\n        abot = BilinearInterpolation(a[itr], a[it], a[ir], a[ii], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.75));\n    }\n\n\n\n\n\n    //dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n    dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n\n}\n\ntemplate &lt;class T&gt; void gradientHaloTop(Param XParam, BlockP&lt;T&gt;XBlock, int ib, int ix, T* a, T* dadx, T* dady)\n{\n    int i, iy, jj, ii, ir, it, itr;\n    int yminus, read;\n\n    T delta, atop, abot;\n\n    iy = XParam.blkwidth;\n\n    i = memloc(XParam, ix, iy, ib);\n    yminus = memloc(XParam, ix, XParam.blkwidth-1, ib);\n\n\n\n\n    abot = a[yminus];\n\n\n\n    delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n    if (XBlock.TopLeft[ib] == ib)//The lower half is a boundary \n    {\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam, ix, XParam.blkwidth - 1, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            atop = a[read];\n\n        }\n\n        if (XBlock.TopRight[ib] == ib) // boundary on the top half too\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam, ix, XParam.blkwidth - 1, ib);\n\n                atop = a[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, jj, 3, XBlock.TopRight[ib]);\n                ir = memloc(XParam, jj, 2, XBlock.TopRight[ib]);\n                it = memloc(XParam, jj + 1, 3, XBlock.TopRight[ib]);\n                itr = memloc(XParam, jj + 1, 2, XBlock.TopRight[ib]);\n\n                atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.TopLeft[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam, ix, 1, XBlock.TopLeft[ib]);\n        atop = a[read];\n\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = ix * 2;\n            int bb = XBlock.TopLeft[ib];\n\n            ii = memloc(XParam, jj, 3, bb);\n            ir = memloc(XParam, jj, 2, bb);\n            it = memloc(XParam, jj + 1, 3, bb);\n            itr = memloc(XParam, jj + 1, 2, bb);\n\n            atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.TopRight[ib] == ib)\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam, ix, XParam.blkwidth - 1, ib);\n\n                atop = a[read];\n            }\n        }\n        else\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, jj, 3, XBlock.TopRight[ib]);\n                ir = memloc(XParam, jj, 2, XBlock.TopRight[ib]);\n                it = memloc(XParam, jj + 1, 3, XBlock.TopRight[ib]);\n                itr = memloc(XParam, jj + 1, 2, XBlock.TopRight[ib]);\n\n                atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? ftoi(ceil(ix * (T)0.5)) : ftoi(ceil(ix * (T)0.5) + XParam.blkwidth / 2);\n        T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam, jj, 0, XBlock.TopLeft[ib]);\n        ir = memloc(XParam, jj, 1, XBlock.TopLeft[ib]);\n        it = memloc(XParam, jj - 1, 0, XBlock.TopLeft[ib]);\n        itr = memloc(XParam, jj - 1, 1, XBlock.TopLeft[ib]);\n\n        atop = BilinearInterpolation(a[it], a[itr], a[ii], a[ir], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.25));\n    }\n\n\n\n\n\n    //dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n    dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n\n}\n\n\ntemplate &lt;class T&gt; __global__ void gradientHaloLeftGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int ix = -1;\n    int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n    int i, jj, ii, ir, it, itr;\n    int xplus, read;\n\n    T delta, aright, aleft;\n\n\n\n    i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n    xplus = memloc(XParam.halowidth, blkmemwidth, ix + 1, iy, ib);\n\n\n    aright = a[xplus];\n\n\n\n    delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n    if (XBlock.LeftBot[ib] == ib)//The lower half is a boundary \n    {\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            aleft = a[read];\n        }\n\n        if (XBlock.LeftTop[ib] == ib) // boundary on the top half too\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);\n\n                aleft = a[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.LeftBot[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), iy, XBlock.LeftBot[ib]);\n        aleft = a[read];\n\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = iy * 2;\n            int bb = XBlock.LeftBot[ib];\n\n            ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, bb);\n            ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, bb);\n            it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, bb);\n            itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, bb);\n\n            aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.LeftTop[ib] == ib)\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);\n\n                aleft = a[read];\n            }\n        }\n        else\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + XParam.blkwidth / 2;\n        T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 1), jj, XBlock.LeftBot[ib]);\n        ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), jj, XBlock.LeftBot[ib]);\n        it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 1), jj - 1, XBlock.LeftBot[ib]);\n        itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), jj - 1, XBlock.LeftBot[ib]);\n\n        aleft = BilinearInterpolation(a[itr], a[ir], a[it], a[ii], T(0.0), T(1.0), T(0.0), T(1.0), T(0.75), jr);\n    }\n\n\n\n\n\n    dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n    //dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n\n}\n\ntemplate &lt;class T&gt; __global__ void gradientHaloLeftGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int ix = -1;\n    int iy = threadIdx.y;\n\n    int ibl = threadIdx.x + blockIdx.x * blockDim.x;;\n    if (ibl &lt; XParam.nblk)\n    {\n\n        int ib = XBlock.active[ibl];\n        int i, jj, ii, ir, it, itr;\n        int xplus, read;\n\n        T delta, aright, aleft;\n\n\n\n        i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n        xplus = memloc(XParam.halowidth, blkmemwidth, ix + 1, iy, ib);\n\n\n        aright = a[xplus];\n\n\n\n        delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n        if (XBlock.LeftBot[ib] == ib)//The lower half is a boundary \n        {\n            if (iy &lt; (XParam.blkwidth / 2))\n            {\n\n                read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n                aleft = a[read];\n            }\n\n            if (XBlock.LeftTop[ib] == ib) // boundary on the top half too\n            {\n                if (iy &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n\n                    read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);\n\n                    aleft = a[read];\n                }\n            }\n            else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n            {\n\n                if (iy &gt;= (XParam.blkwidth / 2))\n                {\n\n                    jj = (iy - XParam.blkwidth / 2) * 2;\n                    ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                    ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                    it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                    itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                    aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n                }\n            }\n        }\n        else if (XBlock.level[ib] == XBlock.level[XBlock.LeftBot[ib]]) // LeftTop block does not exist\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), iy, XBlock.LeftBot[ib]);\n            aleft = a[read];\n\n        }\n        else if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])\n        {\n\n            if (iy &lt; (XParam.blkwidth / 2))\n            {\n\n                jj = iy * 2;\n                int bb = XBlock.LeftBot[ib];\n\n                ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, bb);\n                ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, bb);\n                it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, bb);\n                itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, bb);\n\n                aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n            //now find out aboy lefttop block\n            if (XBlock.LeftTop[ib] == ib)\n            {\n                if (iy &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n\n                    read = memloc(XParam.halowidth, blkmemwidth, 0, iy, ib);\n\n                    aleft = a[read];\n                }\n            }\n            else\n            {\n                if (iy &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n                    jj = (iy - XParam.blkwidth / 2) * 2;\n                    ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj, XBlock.LeftTop[ib]);\n                    ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj, XBlock.LeftTop[ib]);\n                    it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 3), jj + 1, XBlock.LeftTop[ib]);\n                    itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 4), jj + 1, XBlock.LeftTop[ib]);\n\n                    aleft = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n\n        }\n        else if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n        {\n            jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + XParam.blkwidth / 2;\n            T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n            ii = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 1), jj, XBlock.LeftBot[ib]);\n            ir = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), jj, XBlock.LeftBot[ib]);\n            it = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 1), jj - 1, XBlock.LeftBot[ib]);\n            itr = memloc(XParam.halowidth, blkmemwidth, (XParam.blkwidth - 2), jj - 1, XBlock.LeftBot[ib]);\n\n            aleft = BilinearInterpolation(a[itr], a[ir], a[it], a[ii], T(0.0), T(1.0), T(0.0), T(1.0), T(0.75), jr);\n        }\n\n\n\n\n\n        dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n        //dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void gradientHaloRightGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int ix = XParam.blkwidth;\n    int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n    int i, jj, ii, ir, it, itr;\n    int xminus, read;\n\n    T delta, aright, aleft;\n\n\n\n    i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n    xminus = memloc(XParam.halowidth, blkmemwidth, ix - 1, iy, ib);\n\n\n    aleft = a[xminus];\n\n\n\n    delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n    if (XBlock.RightBot[ib] == ib)//The lower half is a boundary \n    {\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            aright = a[read];;\n        }\n\n        if (XBlock.RightTop[ib] == ib) // boundary on the top half too\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);\n\n                aright = a[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, XBlock.RightTop[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, XBlock.RightTop[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, XBlock.RightTop[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, XBlock.RightTop[ib]);\n\n                aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.RightBot[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam.halowidth, blkmemwidth, 1, iy, XBlock.RightBot[ib]);\n        aright = a[read];\n\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (iy &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = iy * 2;\n            int bb = XBlock.RightBot[ib];\n\n            ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, bb);\n            ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, bb);\n            it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, bb);\n            itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, bb);\n\n            aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.RightTop[ib] == ib)\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);\n\n                aright = a[read];\n            }\n        }\n        else\n        {\n            if (iy &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (iy - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, XBlock.RightTop[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, XBlock.RightTop[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, XBlock.RightTop[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, XBlock.RightTop[ib]);\n\n                aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + XParam.blkwidth / 2;\n        T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightBot[ib]);\n        ir = memloc(XParam.halowidth, blkmemwidth, 1, jj, XBlock.RightBot[ib]);\n        it = memloc(XParam.halowidth, blkmemwidth, 0, jj - 1, XBlock.RightBot[ib]);\n        itr = memloc(XParam.halowidth, blkmemwidth, 1, jj - 1, XBlock.RightBot[ib]);\n\n        aright = BilinearInterpolation(a[it], a[ii], a[itr], a[ir], T(0.0), T(1.0), T(0.0), T(1.0), T(0.25), jr);\n    }\n\n\n\n\n\n    dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n    //dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n\n}\n\ntemplate &lt;class T&gt; __global__ void gradientHaloRightGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int ix = XParam.blkwidth;\n    int iy = threadIdx.y;\n    int ibl = threadIdx.x + blockIdx.x * blockDim.x;;\n    if (ibl &lt; XParam.nblk)\n    {\n        int ib = XBlock.active[ibl];\n        int i, jj, ii, ir, it, itr;\n        int xminus, read;\n\n        T delta, aright, aleft;\n\n\n\n        i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n        xminus = memloc(XParam.halowidth, blkmemwidth, ix - 1, iy, ib);\n\n\n        aleft = a[xminus];\n\n\n\n        delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n        if (XBlock.RightBot[ib] == ib)//The lower half is a boundary \n        {\n            if (iy &lt; (XParam.blkwidth / 2))\n            {\n\n                read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n                aright = a[read];;\n            }\n\n            if (XBlock.RightTop[ib] == ib) // boundary on the top half too\n            {\n                if (iy &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n\n                    read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);\n\n                    aright = a[read];\n                }\n            }\n            else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n            {\n\n                if (iy &gt;= (XParam.blkwidth / 2))\n                {\n\n                    jj = (iy - XParam.blkwidth / 2) * 2;\n                    ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, XBlock.RightTop[ib]);\n                    ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, XBlock.RightTop[ib]);\n                    it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, XBlock.RightTop[ib]);\n                    itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, XBlock.RightTop[ib]);\n\n                    aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n                }\n            }\n        }\n        else if (XBlock.level[ib] == XBlock.level[XBlock.RightBot[ib]]) // LeftTop block does not exist\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, 1, iy, XBlock.RightBot[ib]);\n            aright = a[read];\n\n        }\n        else if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])\n        {\n\n            if (iy &lt; (XParam.blkwidth / 2))\n            {\n\n                jj = iy * 2;\n                int bb = XBlock.RightBot[ib];\n\n                ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, bb);\n                ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, bb);\n                it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, bb);\n                itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, bb);\n\n                aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n            //now find out aboy lefttop block\n            if (XBlock.RightTop[ib] == ib)\n            {\n                if (iy &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n\n                    read = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, iy, ib);\n\n                    aright = a[read];\n                }\n            }\n            else\n            {\n                if (iy &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n                    jj = (iy - XParam.blkwidth / 2) * 2;\n                    ii = memloc(XParam.halowidth, blkmemwidth, 3, jj, XBlock.RightTop[ib]);\n                    ir = memloc(XParam.halowidth, blkmemwidth, 2, jj, XBlock.RightTop[ib]);\n                    it = memloc(XParam.halowidth, blkmemwidth, 3, jj + 1, XBlock.RightTop[ib]);\n                    itr = memloc(XParam.halowidth, blkmemwidth, 2, jj + 1, XBlock.RightTop[ib]);\n\n                    aright = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n\n        }\n        else if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n        {\n            jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + XParam.blkwidth / 2;\n            T jr = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.25) : T(0.75);\n\n            ii = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightBot[ib]);\n            ir = memloc(XParam.halowidth, blkmemwidth, 1, jj, XBlock.RightBot[ib]);\n            it = memloc(XParam.halowidth, blkmemwidth, 0, jj - 1, XBlock.RightBot[ib]);\n            itr = memloc(XParam.halowidth, blkmemwidth, 1, jj - 1, XBlock.RightBot[ib]);\n\n            aright = BilinearInterpolation(a[it], a[ii], a[itr], a[ir], T(0.0), T(1.0), T(0.0), T(1.0), T(0.25), jr);\n        }\n\n\n\n\n\n        dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n        //dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void gradientHaloBotGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int iy = -1;\n    int ix = threadIdx.x;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n\n    int i, jj, ii, ir, it, itr;\n    int yplus, read;\n\n    T delta, atop, abot;\n\n\n    i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n    yplus = memloc(XParam.halowidth, blkmemwidth, ix, iy + 1, ib);\n\n\n\n\n    atop = a[yplus];\n\n\n\n    delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n    if (XBlock.BotLeft[ib] == ib)//The lower half is a boundary \n    {\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            abot = a[read];\n\n        }\n\n        if (XBlock.BotRight[ib] == ib) // boundary on the top half too\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);\n\n                abot = a[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.BotLeft[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam.halowidth, blkmemwidth, ix, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n        abot = a[read];\n\n\n\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = ix * 2;\n            int bb = XBlock.BotLeft[ib];\n\n            ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), bb);\n            ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), bb);\n            it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), bb);\n            itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), bb);\n\n            abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.BotRight[ib] == ib)\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);\n\n                abot = a[read];\n            }\n        }\n        else\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + XParam.blkwidth / 2;\n        T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n        ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n        it = memloc(XParam.halowidth, blkmemwidth, jj - 1, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n        itr = memloc(XParam.halowidth, blkmemwidth, jj - 1, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n\n        abot = BilinearInterpolation(a[itr], a[it], a[ir], a[ii], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.75));\n    }\n\n\n\n\n\n    //dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n    dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n\n}\n\ntemplate &lt;class T&gt; __global__ void gradientHaloBotGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int iy = -1;\n    int ix = threadIdx.x;\n    int ibl = threadIdx.y + blockIdx.x * blockDim.y;\n    if (ibl &lt; XParam.nblk)\n    {\n        int ib = XBlock.active[ibl];\n\n\n        int i, jj, ii, ir, it, itr;\n        int yplus, read;\n\n        T delta, atop, abot;\n\n\n        i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n        yplus = memloc(XParam.halowidth, blkmemwidth, ix, iy + 1, ib);\n\n\n\n\n        atop = a[yplus];\n\n\n\n        delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n        if (XBlock.BotLeft[ib] == ib)//The lower half is a boundary \n        {\n            if (ix &lt; (XParam.blkwidth / 2))\n            {\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n                abot = a[read];\n\n            }\n\n            if (XBlock.BotRight[ib] == ib) // boundary on the top half too\n            {\n                if (ix &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n\n                    read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);\n\n                    abot = a[read];\n                }\n            }\n            else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n            {\n\n                if (ix &gt;= (XParam.blkwidth / 2))\n                {\n\n                    jj = (ix - XParam.blkwidth / 2) * 2;\n                    ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                    ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                    it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                    itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                    abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n                }\n            }\n        }\n        else if (XBlock.level[ib] == XBlock.level[XBlock.BotLeft[ib]]) // LeftTop block does not exist\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, ix, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n            abot = a[read];\n\n\n\n        }\n        else if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n        {\n\n            if (ix &lt; (XParam.blkwidth / 2))\n            {\n\n                jj = ix * 2;\n                int bb = XBlock.BotLeft[ib];\n\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), bb);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), bb);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), bb);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), bb);\n\n                abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n            //now find out aboy lefttop block\n            if (XBlock.BotRight[ib] == ib)\n            {\n                if (ix &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n\n                    read = memloc(XParam.halowidth, blkmemwidth, ix, 0, ib);\n\n                    abot = a[read];\n                }\n            }\n            else\n            {\n                if (ix &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n                    jj = (ix - XParam.blkwidth / 2) * 2;\n                    ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                    ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n                    it = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 3), XBlock.BotRight[ib]);\n                    itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, (XParam.blkwidth - 4), XBlock.BotRight[ib]);\n\n                    abot = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n\n        }\n        else if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n        {\n            jj = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + XParam.blkwidth / 2;\n            T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n            ii = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n            ir = memloc(XParam.halowidth, blkmemwidth, jj, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n            it = memloc(XParam.halowidth, blkmemwidth, jj - 1, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n            itr = memloc(XParam.halowidth, blkmemwidth, jj - 1, (XParam.blkwidth - 2), XBlock.BotLeft[ib]);\n\n            abot = BilinearInterpolation(a[itr], a[it], a[ir], a[ii], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.75));\n        }\n\n\n\n\n\n        //dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n        dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void gradientHaloTopGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int iy = XParam.blkwidth;\n    int ix = threadIdx.x;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n\n    int i, jj, ii, ir, it, itr;\n    int yminus, read;\n\n    T delta, atop, abot;\n\n\n    i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n    yminus = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n\n\n\n    abot = a[yminus];\n\n\n\n    delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n    if (XBlock.TopLeft[ib] == ib)//The lower half is a boundary \n    {\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n            atop = a[read];\n\n        }\n\n        if (XBlock.TopRight[ib] == ib) // boundary on the top half too\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n                atop = a[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, XBlock.TopRight[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, XBlock.TopRight[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, XBlock.TopRight[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, XBlock.TopRight[ib]);\n\n                atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.TopLeft[ib]]) // LeftTop block does not exist\n    {\n\n        read = memloc(XParam.halowidth, blkmemwidth, ix, 1, XBlock.TopLeft[ib]);\n        atop = a[read];\n\n\n\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        if (ix &lt; (XParam.blkwidth / 2))\n        {\n\n            jj = ix * 2;\n            int bb = XBlock.TopLeft[ib];;\n\n            ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, bb);\n            ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, bb);\n            it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, bb);\n            itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, bb);\n\n            atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.TopRight[ib] == ib)\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n                atop = a[read];\n            }\n        }\n        else\n        {\n            if (ix &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                jj = (ix - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, XBlock.TopRight[ib]);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, XBlock.TopRight[ib]);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, XBlock.TopRight[ib]);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, XBlock.TopRight[ib]);\n\n                atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        jj = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + XParam.blkwidth / 2;\n        T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n        ii = memloc(XParam.halowidth, blkmemwidth, jj, 0, XBlock.TopLeft[ib]);\n        ir = memloc(XParam.halowidth, blkmemwidth, jj, 1, XBlock.TopLeft[ib]);\n        it = memloc(XParam.halowidth, blkmemwidth, jj - 1, 0, XBlock.TopLeft[ib]);\n        itr = memloc(XParam.halowidth, blkmemwidth, jj - 1, 1, XBlock.TopLeft[ib]);\n\n        atop = BilinearInterpolation(a[it], a[itr], a[ii], a[ir], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.25));\n    }\n\n\n\n\n\n    //dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n    dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n\n}\n\ntemplate &lt;class T&gt; __global__ void gradientHaloTopGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady)\n{\n    unsigned int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    //unsigned int blksize = XParam.blkmemwidth * XParam.blkmemwidth;\n    int iy = XParam.blkwidth;\n    int ix = threadIdx.x;\n\n\n    int ibl = threadIdx.y + blockIdx.x * blockDim.y;\n    if (ibl &lt; XParam.nblk)\n    {\n        int ib = XBlock.active[ibl];\n\n\n        int i, jj, ii, ir, it, itr;\n        int yminus, read;\n\n        T delta, atop, abot;\n\n\n        i = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n        yminus = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n\n\n\n        abot = a[yminus];\n\n\n\n        delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n\n        if (XBlock.TopLeft[ib] == ib)//The lower half is a boundary \n        {\n            if (ix &lt; (XParam.blkwidth / 2))\n            {\n\n                read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);// or memloc(XParam, -1, j, ib) but they should be the same\n\n                atop = a[read];\n\n            }\n\n            if (XBlock.TopRight[ib] == ib) // boundary on the top half too\n            {\n                if (ix &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n\n                    read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n                    atop = a[read];\n                }\n            }\n            else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n            {\n\n                if (ix &gt;= (XParam.blkwidth / 2))\n                {\n\n                    jj = (ix - XParam.blkwidth / 2) * 2;\n                    ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, XBlock.TopRight[ib]);\n                    ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, XBlock.TopRight[ib]);\n                    it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, XBlock.TopRight[ib]);\n                    itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, XBlock.TopRight[ib]);\n\n                    atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n\n                }\n            }\n        }\n        else if (XBlock.level[ib] == XBlock.level[XBlock.TopLeft[ib]]) // LeftTop block does not exist\n        {\n\n            read = memloc(XParam.halowidth, blkmemwidth, ix, 1, XBlock.TopLeft[ib]);\n            atop = a[read];\n\n\n\n        }\n        else if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n        {\n\n            if (ix &lt; (XParam.blkwidth / 2))\n            {\n\n                jj = ix * 2;\n                int bb = XBlock.TopLeft[ib];;\n\n                ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, bb);\n                ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, bb);\n                it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, bb);\n                itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, bb);\n\n                atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n            //now find out aboy lefttop block\n            if (XBlock.TopRight[ib] == ib)\n            {\n                if (ix &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n\n                    read = memloc(XParam.halowidth, blkmemwidth, ix, XParam.blkwidth - 1, ib);\n\n                    atop = a[read];\n                }\n            }\n            else\n            {\n                if (ix &gt;= (XParam.blkwidth / 2))\n                {\n                    //\n                    jj = (ix - XParam.blkwidth / 2) * 2;\n                    ii = memloc(XParam.halowidth, blkmemwidth, jj, 3, XBlock.TopRight[ib]);\n                    ir = memloc(XParam.halowidth, blkmemwidth, jj, 2, XBlock.TopRight[ib]);\n                    it = memloc(XParam.halowidth, blkmemwidth, jj + 1, 3, XBlock.TopRight[ib]);\n                    itr = memloc(XParam.halowidth, blkmemwidth, jj + 1, 2, XBlock.TopRight[ib]);\n\n                    atop = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n\n        }\n        else if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n        {\n            jj = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + XParam.blkwidth / 2;\n            T jr = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.25) : T(0.75);\n\n            ii = memloc(XParam.halowidth, blkmemwidth, jj, 0, XBlock.TopLeft[ib]);\n            ir = memloc(XParam.halowidth, blkmemwidth, jj, 1, XBlock.TopLeft[ib]);\n            it = memloc(XParam.halowidth, blkmemwidth, jj - 1, 0, XBlock.TopLeft[ib]);\n            itr = memloc(XParam.halowidth, blkmemwidth, jj - 1, 1, XBlock.TopLeft[ib]);\n\n            atop = BilinearInterpolation(a[it], a[itr], a[ii], a[ir], T(0.0), T(1.0), T(0.0), T(1.0), jr, T(0.25));\n        }\n\n\n\n\n\n        //dadx[i] = minmod2(T(XParam.theta), aleft, a[i], aright) / delta;\n        dady[i] = minmod2(T(XParam.theta), abot, a[i], atop) / delta;\n    }\n}\n</code></pre>"},{"location":"BGFlood/_gradients_8h/","title":"File Gradients.h","text":""},{"location":"BGFlood/_gradients_8h/#file-gradientsh","title":"File Gradients.h","text":"<p>FileList &gt; src &gt; Gradients.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Setup_GPU.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Halo.h\"</code></li> </ul>"},{"location":"BGFlood/_gradients_8h/#public-functions","title":"Public Functions","text":"Type Name __global__ void WetsloperesetHaloBotGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) GPU kernel to reset the wet slope limiter at the bottom halo boundary. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. __global__ void WetsloperesetHaloLeftGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) Device kernel to apply wet slope limiters to gradients of surface elevation at the left halo boundary. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. __global__ void WetsloperesetHaloRightGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) Device kernel to apply wet slope limiters to gradients of surface elevation at the right halo boundary. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. __global__ void WetsloperesetHaloTopGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) GPU kernel to reset the wet slope limiter at the top halo boundary. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. __global__ void WetsloperesetXGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) Device kernel to apply wet slope limiters to gradients of surface elevation in the x-direction. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. __global__ void WetsloperesetYGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) Device kernel to apply wet slope limiters to gradients of surface elevation in the y-direction. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. __global__ void gradient (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx, T * dady) Device kernel for calculating gradients for an evolving parameter using the minmod limiter. void gradientC (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) CPU function for calculating gradients using the minmod limiter. Computes spatial derivatives in x and y directions for a given variable. void gradientCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) CPU function to compute gradients for all evolving parameters, handle halo regions, and apply wet-dry fixes. Calculates spatial derivatives for height, surface elevation, and velocity components. Also manages halo regions and applies wet-dry fixes if necessary. void gradientGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) Entry point for gradient of evolving variables calculation on the GPU. void gradientGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, T * zb) Alternative GPU gradient calculation using shared memory kernels and CUDA streams. void gradientHalo (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) CPU function to compute gradients at the halo boundaries of all active blocks. This function iterates over all active blocks and computes the gradients at their halo boundaries using finite difference approximations. __global__ void gradientHaloBotGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU kernel to compute the gradient at the bottom halo boundary of blocks. This kernel calculates the x and y derivatives at the bottom edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. __global__ void gradientHaloBotGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU kernel to compute the gradient at the bottom halo boundary of blocks. This kernel calculates the x and y derivatives at the bottom edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. void gradientHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU function to compute gradients at the halo boundaries of all active blocks. This function launches CUDA kernels to compute the gradients at the halo boundaries of all active blocks using parallel processing. __global__ void gradientHaloLeftGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU kernel to compute the gradient at the left halo boundary of blocks. This kernel calculates the x and y derivatives at the left edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. __global__ void gradientHaloLeftGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU kernel to compute the gradient at the left halo boundary of blocks. This kernel calculates the x and y derivatives at the left edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. __global__ void gradientHaloRightGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU kernel to compute the gradient at the right halo boundary of blocks. This kernel calculates the x and y derivatives at the right edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. __global__ void gradientHaloRightGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU kernel to compute the gradient at the right halo boundary of blocks. This kernel calculates the x and y derivatives at the right edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. __global__ void gradientHaloTopGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU kernel to compute the gradient at the top halo boundary of blocks. This kernel calculates the x and y derivatives at the top edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. __global__ void gradientHaloTopGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, T * a, T * dadx, T * dady) GPU kernel to compute the gradient at the top halo boundary of blocks. This kernel calculates the x and y derivatives at the top edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. __global__ void gradientSM (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx, T * dady) Deprecated shared memory device kernel for gradient calculation. __global__ void gradientSMB (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx, T * dady) Shared memory device kernel for gradient calculation (variant B). __global__ void gradientSMC (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx, T * dady) Shared memory device kernel for gradient calculation (variant C). __global__ void gradientedgeX (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dadx) Device kernel for calculating gradients for an evolving parameter using the minmod limiter only at a fixed column (i.e. fixed ix). __global__ void gradientedgeY (int halowidth, int * active, int * level, T theta, T dx, T * a, T * dady) Device kernel for calculating gradients for an evolving parameter using the minmod limiter only at a fixed row (i.e. fixed iy)."},{"location":"BGFlood/_gradients_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_gradients_8h/#function-wetsloperesethalobotgpu","title":"function WetsloperesetHaloBotGPU","text":"<p>GPU kernel to reset the wet slope limiter at the bottom halo boundary. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </p><pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetHaloBotGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>Note:</p> <p>This kernel specifically handles the bottom halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the bottom surface elevation needed for the wet slope limiter. </p>"},{"location":"BGFlood/_gradients_8h/#function-wetsloperesethaloleftgpu","title":"function WetsloperesetHaloLeftGPU","text":"<p>Device kernel to apply wet slope limiters to gradients of surface elevation at the left halo boundary. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </p><pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetHaloLeftGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>Note:</p> <p>This kernel specifically handles the left halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the left surface elevation needed for the wet slope limiter. </p>"},{"location":"BGFlood/_gradients_8h/#function-wetsloperesethalorightgpu","title":"function WetsloperesetHaloRightGPU","text":"<p>Device kernel to apply wet slope limiters to gradients of surface elevation at the right halo boundary. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </p><pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetHaloRightGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>Note:</p> <p>This kernel specifically handles the right halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the right surface elevation needed for the wet slope limiter. </p>"},{"location":"BGFlood/_gradients_8h/#function-wetsloperesethalotopgpu","title":"function WetsloperesetHaloTopGPU","text":"<p>GPU kernel to reset the wet slope limiter at the top halo boundary. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </p><pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetHaloTopGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>Note:</p> <p>This kernel specifically handles the top halo boundary, where special care is needed due to the absence of neighboring blocks on that side. The logic accounts for various configurations of neighboring blocks to correctly compute the top surface elevation needed for the wet slope limiter. </p>"},{"location":"BGFlood/_gradients_8h/#function-wetsloperesetxgpu","title":"function WetsloperesetXGPU","text":"<p>Device kernel to apply wet slope limiters to gradients of surface elevation in the x-direction. Adjusts x-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </p><pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetXGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_gradients_8h/#function-wetsloperesetygpu","title":"function WetsloperesetYGPU","text":"<p>Device kernel to apply wet slope limiters to gradients of surface elevation in the y-direction. Adjusts y-derivative gradients to prevent non-physical slopes in wet-dry transition zones. </p><pre><code>template&lt;class T&gt;\n__global__ void WetsloperesetYGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_gradients_8h/#function-gradient","title":"function gradient","text":"<p>Device kernel for calculating gradients for an evolving parameter using the minmod limiter. </p><pre><code>template&lt;class T&gt;\n__global__ void gradient (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Computes spatial derivatives in x and y directions for a given variable.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Width of halo region </li> <li><code>active</code> Active block indices </li> <li><code>level</code> Block refinement levels </li> <li><code>theta</code> Limiter parameter </li> <li><code>dx</code> Grid spacing </li> <li><code>a</code> Input variable array </li> <li><code>dadx</code> Output gradient in x </li> <li><code>dady</code> Output gradient in y </li> </ul>"},{"location":"BGFlood/_gradients_8h/#function-gradientc","title":"function gradientC","text":"<p>CPU function for calculating gradients using the minmod limiter. Computes spatial derivatives in x and y directions for a given variable. </p><pre><code>template&lt;class T&gt;\nvoid gradientC (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Input variable array </li> <li><code>dadx</code> Output gradient in x </li> <li><code>dady</code> Output gradient in y </li> </ul>"},{"location":"BGFlood/_gradients_8h/#function-gradientcpu","title":"function gradientCPU","text":"<p>CPU function to compute gradients for all evolving parameters, handle halo regions, and apply wet-dry fixes. Calculates spatial derivatives for height, surface elevation, and velocity components. Also manages halo regions and applies wet-dry fixes if necessary. </p><pre><code>template&lt;class T&gt;\nvoid gradientCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>XEv</code> Evolving parameters (height, surface elevation, velocities) </li> <li><code>XGrad</code> Gradient storage for the evolving parameters </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_gradients_8h/#function-gradientgpu","title":"function gradientGPU","text":"<p>Entry point for gradient of evolving variables calculation on the GPU. </p><pre><code>template&lt;class T&gt;\nvoid gradientGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Calculates gradients of evolving variables using CUDA kernels and synchronizes device operations. Handles halo filling and elevation conservation if required.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradient variables </li> <li><code>zb</code> Bed elevation array</li> </ul> <p>Wrapping function to calculate gradien of evolving variables on GPU This function is the entry point to the gradient functions on the GPU </p>"},{"location":"BGFlood/_gradients_8h/#function-gradientgpunew","title":"function gradientGPUnew","text":"<p>Alternative GPU gradient calculation using shared memory kernels and CUDA streams. </p><pre><code>template&lt;class T&gt;\nvoid gradientGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    T * zb\n) \n</code></pre> <p>Uses gradientSMC kernels and handles halo filling, elevation conservation, and wet/dry prolongation.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradient variables </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_gradients_8h/#function-gradienthalo","title":"function gradientHalo","text":"<p>CPU function to compute gradients at the halo boundaries of all active blocks. This function iterates over all active blocks and computes the gradients at their halo boundaries using finite difference approximations. </p><pre><code>template&lt;class T&gt;\nvoid gradientHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This function calls specific functions to handle each of the four halo boundaries (left, right, bottom, top) for each block. It ensures that gradients are accurately computed at the edges of the computational domain, which is crucial for maintaining solution accuracy and stability. The function assumes that the input arrays are properly allocated and sized according to the simulation parameters. The gradient computations are performed using central differences where possible, and one-sided differences at the boundaries. The function is templated to support different data types (e.g., float, double). </p> <p>See also: gradientHaloLeft, gradientHaloRight, gradientHaloBot, gradientHaloTop </p>"},{"location":"BGFlood/_gradients_8h/#function-gradienthalobotgpu","title":"function gradientHaloBotGPU","text":"<p>GPU kernel to compute the gradient at the bottom halo boundary of blocks. This kernel calculates the x and y derivatives at the bottom edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientHaloBotGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8h/#function-gradienthalobotgpunew","title":"function gradientHaloBotGPUnew","text":"<p>GPU kernel to compute the gradient at the bottom halo boundary of blocks. This kernel calculates the x and y derivatives at the bottom edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientHaloBotGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8h/#function-gradienthalogpu","title":"function gradientHaloGPU","text":"<p>GPU function to compute gradients at the halo boundaries of all active blocks. This function launches CUDA kernels to compute the gradients at the halo boundaries of all active blocks using parallel processing. </p><pre><code>template&lt;class T&gt;\nvoid gradientHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This function sets up the CUDA grid and block dimensions and launches specific kernels to handle each of the four halo boundaries (left, right, bottom, top) for all active blocks. It ensures that gradients are accurately computed at the edges of the computational domain, which is crucial for maintaining solution accuracy and stability. The function assumes that the input arrays are properly allocated and sized according to the simulation parameters. The gradient computations are performed using central differences where possible, and one-sided differences at the boundaries. The function is templated to support different data types (e.g., float, double). </p> <p>See also: gradientHaloLeftGPU, gradientHaloRightGPU, gradientHaloBotGPU, gradientHaloTopGPU </p> <p>See also: gradientHaloLeft, gradientHaloRight, gradientHaloBot, gradientHaloTop </p>"},{"location":"BGFlood/_gradients_8h/#function-gradienthaloleftgpu","title":"function gradientHaloLeftGPU","text":"<p>GPU kernel to compute the gradient at the left halo boundary of blocks. This kernel calculates the x and y derivatives at the left edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientHaloLeftGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8h/#function-gradienthaloleftgpunew","title":"function gradientHaloLeftGPUnew","text":"<p>GPU kernel to compute the gradient at the left halo boundary of blocks. This kernel calculates the x and y derivatives at the left edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientHaloLeftGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8h/#function-gradienthalorightgpu","title":"function gradientHaloRightGPU","text":"<p>GPU kernel to compute the gradient at the right halo boundary of blocks. This kernel calculates the x and y derivatives at the right edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientHaloRightGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8h/#function-gradienthalorightgpunew","title":"function gradientHaloRightGPUnew","text":"<p>GPU kernel to compute the gradient at the right halo boundary of blocks. This kernel calculates the x and y derivatives at the right edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientHaloRightGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8h/#function-gradienthalotopgpu","title":"function gradientHaloTopGPU","text":"<p>GPU kernel to compute the gradient at the top halo boundary of blocks. This kernel calculates the x and y derivatives at the top edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientHaloTopGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8h/#function-gradienthalotopgpunew","title":"function gradientHaloTopGPUnew","text":"<p>GPU kernel to compute the gradient at the top halo boundary of blocks. This kernel calculates the x and y derivatives at the top edge of each block using finite difference approximations, taking into account the presence of neighboring blocks and their levels. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientHaloTopGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block information </li> <li><code>a</code> Array containing the variable for which gradients are to be computed </li> <li><code>dadx</code> Array to store the computed x-derivative gradients </li> <li><code>dady</code> Array to store the computed y-derivative gradients </li> </ul> <p>Note:</p> <p>This kernel handles various configurations of neighboring blocks, including cases where neighboring blocks are at different levels of refinement </p>"},{"location":"BGFlood/_gradients_8h/#function-gradientsm","title":"function gradientSM","text":"<p>Deprecated shared memory device kernel for gradient calculation. </p><pre><code>template&lt;class T&gt;\n__global__ void gradientSM (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Uses shared memory for stencil operations; slower than the standard kernel.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Width of halo region </li> <li><code>active</code> Active block indices </li> <li><code>level</code> Block refinement levels </li> <li><code>theta</code> Limiter parameter </li> <li><code>dx</code> Grid spacing </li> <li><code>a</code> Input variable array </li> <li><code>dadx</code> Output gradient in x </li> <li><code>dady</code> Output gradient in y </li> </ul>"},{"location":"BGFlood/_gradients_8h/#function-gradientsmb","title":"function gradientSMB","text":"<p>Shared memory device kernel for gradient calculation (variant B). </p><pre><code>template&lt;class T&gt;\n__global__ void gradientSMB (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Uses a fixed shared memory tile for stencil operations; only computes gradients for interior points.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Width of halo region </li> <li><code>active</code> Active block indices </li> <li><code>level</code> Block refinement levels </li> <li><code>theta</code> Limiter parameter </li> <li><code>dx</code> Grid spacing </li> <li><code>a</code> Input variable array </li> <li><code>dadx</code> Output gradient in x </li> <li><code>dady</code> Output gradient in y </li> </ul>"},{"location":"BGFlood/_gradients_8h/#function-gradientsmc","title":"function gradientSMC","text":"<p>Shared memory device kernel for gradient calculation (variant C). </p><pre><code>template&lt;class T&gt;\n__global__ void gradientSMC (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx,\n    T * dady\n) \n</code></pre> <p>Uses a flat shared memory array for stencil operations; computes gradients for all points.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Width of halo region </li> <li><code>active</code> Active block indices </li> <li><code>level</code> Block refinement levels </li> <li><code>theta</code> Limiter parameter </li> <li><code>dx</code> Grid spacing </li> <li><code>a</code> Input variable array </li> <li><code>dadx</code> Output gradient in x </li> <li><code>dady</code> Output gradient in y </li> </ul>"},{"location":"BGFlood/_gradients_8h/#function-gradientedgex","title":"function gradientedgeX","text":"<p>Device kernel for calculating gradients for an evolving parameter using the minmod limiter only at a fixed column (i.e. fixed ix). </p><pre><code>template&lt;class T&gt;\n__global__ void gradientedgeX (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dadx\n) \n</code></pre> <p>Computes x-derivative for a specific column using the minmod limiter.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Width of halo region </li> <li><code>active</code> Active block indices </li> <li><code>level</code> Block refinement levels </li> <li><code>theta</code> Limiter parameter </li> <li><code>dx</code> Grid spacing </li> <li><code>a</code> Input variable array </li> <li><code>dadx</code> Output gradient in x </li> </ul>"},{"location":"BGFlood/_gradients_8h/#function-gradientedgey","title":"function gradientedgeY","text":"<p>Device kernel for calculating gradients for an evolving parameter using the minmod limiter only at a fixed row (i.e. fixed iy). </p><pre><code>template&lt;class T&gt;\n__global__ void gradientedgeY (\n    int halowidth,\n    int * active,\n    int * level,\n    T theta,\n    T dx,\n    T * a,\n    T * dady\n) \n</code></pre> <p>Computes y-derivative for a specific row using the minmod limiter.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>halowidth</code> Width of halo region </li> <li><code>active</code> Active block indices </li> <li><code>level</code> Block refinement levels </li> <li><code>theta</code> Limiter parameter </li> <li><code>dx</code> Grid spacing </li> <li><code>a</code> Input variable array </li> <li><code>dady</code> Output gradient in y </li> </ul> <p>The documentation for this class was generated from the following file <code>src/Gradients.h</code></p>"},{"location":"BGFlood/_gradients_8h_source/","title":"File Gradients.h","text":""},{"location":"BGFlood/_gradients_8h_source/#file-gradientsh","title":"File Gradients.h","text":"<p>File List &gt; src &gt; Gradients.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef GRADIENTS_H\n#define GRADIENTS_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"Util_CPU.h\"\n#include \"Setup_GPU.h\"\n#include \"MemManagement.h\"\n#include \"Halo.h\"\n\n// CPU specific functions\ntemplate &lt;class T&gt; void gradientCPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\ntemplate &lt;class T&gt; void gradientC(Param XParam, BlockP&lt;T&gt; XBlock, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; void gradientHalo(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\n\n// GPU specific functions\ntemplate &lt;class T&gt; void gradientGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\ntemplate &lt;class T&gt; void gradientGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\ntemplate &lt;class T&gt; __global__ void gradient(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientSM(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientSMB(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientSMC(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientedgeX(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dadx);\ntemplate &lt;class T&gt; __global__ void gradientedgeY(int halowidth, int* active, int* level, T theta, T dx, T* a, T* dady);\ntemplate &lt;class T&gt; void gradientHaloGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\n\ntemplate &lt;class T&gt; __global__ void WetsloperesetXGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\ntemplate &lt;class T&gt; __global__ void WetsloperesetYGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\n\ntemplate &lt;class T&gt; __global__ void WetsloperesetHaloLeftGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\ntemplate &lt;class T&gt; __global__ void WetsloperesetHaloRightGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\ntemplate &lt;class T&gt; __global__ void WetsloperesetHaloBotGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\ntemplate &lt;class T&gt; __global__ void WetsloperesetHaloTopGPU(Param XParam, BlockP&lt;T&gt;XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, T* zb);\n\n\ntemplate &lt;class T&gt; __global__ void gradientHaloLeftGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientHaloRightGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientHaloTopGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientHaloBotGPU(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\n\ntemplate &lt;class T&gt; __global__ void gradientHaloLeftGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientHaloRightGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientHaloTopGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\ntemplate &lt;class T&gt; __global__ void gradientHaloBotGPUnew(Param XParam, BlockP&lt;T&gt;XBlock, T* a, T* dadx, T* dady);\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/","title":"File GridManip.cu","text":""},{"location":"BGFlood/_grid_manip_8cu/#file-gridmanipcu","title":"File GridManip.cu","text":"<p>FileList &gt; src &gt; GridManip.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"GridManip.h\"</code></li> </ul>"},{"location":"BGFlood/_grid_manip_8cu/#public-functions","title":"Public Functions","text":"Type Name void Copy2CartCPU (int nx, int ny, T * dest, T * src) Copy values from source to destination for a Cartesian grid. template void Copy2CartCPU&lt; bool &gt; (int nx, int ny, bool * dest, bool * src)  template void Copy2CartCPU&lt; double &gt; (int nx, int ny, double * dest, double * src)  template void Copy2CartCPU&lt; float &gt; (int nx, int ny, float * dest, float * src)  template void Copy2CartCPU&lt; int &gt; (int nx, int ny, int * dest, int * src)  void CopyArrayBUQ (Param XParam, BlockP&lt; F &gt; XBlock, T * source, T *&amp; dest) Copy values from source array to destination array for all blocks. void CopyArrayBUQ (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; source, EvolvingP&lt; T &gt; &amp; dest) Copy all evolving variables from source to destination. void CopyArrayBUQ (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; source, EvolvingP_M&lt; T &gt; &amp; dest) Copy all evolving variables and compute derived quantities (U, hU). template void CopyArrayBUQ&lt; bool, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, bool * source, bool *&amp; dest)  template void CopyArrayBUQ&lt; bool, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, bool * source, bool *&amp; dest)  template void CopyArrayBUQ&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; source, EvolvingP&lt; double &gt; &amp; dest)  template void CopyArrayBUQ&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; source, EvolvingP_M&lt; double &gt; &amp; dest)  template void CopyArrayBUQ&lt; double, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * source, double *&amp; dest)  template void CopyArrayBUQ&lt; double, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, double * source, double *&amp; dest)  template void CopyArrayBUQ&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; source, EvolvingP&lt; float &gt; &amp; dest)  template void CopyArrayBUQ&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; source, EvolvingP_M&lt; float &gt; &amp; dest)  template void CopyArrayBUQ&lt; float, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, float * source, float *&amp; dest)  template void CopyArrayBUQ&lt; float, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * source, float *&amp; dest)  template void CopyArrayBUQ&lt; int, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, int * source, int *&amp; dest)  template void CopyArrayBUQ&lt; int, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, int * source, int *&amp; dest)  void InitArrayBUQ (Param XParam, BlockP&lt; F &gt; XBlock, T initval, T *&amp; Arr) Initialize a block-structured array with a given value. template void InitArrayBUQ&lt; bool, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, bool initval, bool *&amp; Arr)  template void InitArrayBUQ&lt; bool, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, bool initval, bool *&amp; Arr)  template void InitArrayBUQ&lt; double, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double initval, double *&amp; Arr)  template void InitArrayBUQ&lt; double, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, double initval, double *&amp; Arr)  template void InitArrayBUQ&lt; float, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, float initval, float *&amp; Arr)  template void InitArrayBUQ&lt; float, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float initval, float *&amp; Arr)  template void InitArrayBUQ&lt; int, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, int initval, int *&amp; Arr)  template void InitArrayBUQ&lt; int, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, int initval, int *&amp; Arr)  void InitBlkBUQ (Param XParam, BlockP&lt; F &gt; XBlock, T initval, T *&amp; Arr) Initialize a block-level array with a given value. template void InitBlkBUQ&lt; bool, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, bool initval, bool *&amp; Arr)  template void InitBlkBUQ&lt; bool, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, bool initval, bool *&amp; Arr)  template void InitBlkBUQ&lt; double, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double initval, double *&amp; Arr)  template void InitBlkBUQ&lt; double, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, double initval, double *&amp; Arr)  template void InitBlkBUQ&lt; float, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, float initval, float *&amp; Arr)  template void InitBlkBUQ&lt; float, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float initval, float *&amp; Arr)  template void InitBlkBUQ&lt; int, double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, int initval, int *&amp; Arr)  template void InitBlkBUQ&lt; int, float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, int initval, int *&amp; Arr)  void InterpstepCPU (int nx, int ny, int hdstep, F totaltime, F hddt, T *&amp; Ux, T * Uo, T * Un) CPU routine for time interpolation of solution arrays. template void InterpstepCPU&lt; double, double &gt; (int nx, int ny, int hdstep, double totaltime, double hddt, double *&amp; Ux, double * Uo, double * Un)  template void InterpstepCPU&lt; double, float &gt; (int nx, int ny, int hdstep, float totaltime, float hddt, double *&amp; Ux, double * Uo, double * Un)  template void InterpstepCPU&lt; float, double &gt; (int nx, int ny, int hdstep, double totaltime, double hddt, float *&amp; Ux, float * Uo, float * Un)  template void InterpstepCPU&lt; float, float &gt; (int nx, int ny, int hdstep, float totaltime, float hddt, float *&amp; Ux, float * Uo, float * Un)  template void InterpstepCPU&lt; int, double &gt; (int nx, int ny, int hdstep, double totaltime, double hddt, int *&amp; Ux, int * Uo, int * Un)  template void InterpstepCPU&lt; int, float &gt; (int nx, int ny, int hdstep, float totaltime, float hddt, int *&amp; Ux, int * Uo, int * Un)  __global__ void InterpstepGPU (int nx, int ny, T totaltime, T beforetime, T aftertime, T * Ux, T * Uo, T * Un) GPU kernel for time interpolation of solution arrays. template __global__ void InterpstepGPU&lt; double &gt; (int nx, int ny, double totaltime, double beforetime, double aftertime, double * Ux, double * Uo, double * Un)  template __global__ void InterpstepGPU&lt; float &gt; (int nx, int ny, float totaltime, float beforetime, float aftertime, float * Ux, float * Uo, float * Un)  T blockmean (T x, T y, T dx, F forcing) Compute block mean value for (x, y) over grid spacing dx. void interp2BUQ (Param XParam, BlockP&lt; T &gt; XBlock, F forcing, T *&amp; z) Interpolate values from forcing map to block array using bilinear interpolation. void interp2BUQ (Param XParam, BlockP&lt; T &gt; XBlock, std::vector&lt; StaticForcingP&lt; float &gt;&gt; forcing, T * z) Interpolate values from multiple forcing maps to block array using bilinear interpolation. T interp2BUQ (T x, T y, T dx, F forcing) Interpolate value at (x, y) using either bilinear or blockmean interpolation. T interp2BUQ (T x, T y, F forcing) Bilinear interpolation for value at (x, y) from forcing map. template void interp2BUQ&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, std::vector&lt; StaticForcingP&lt; float &gt;&gt; forcing, double * z)  template void interp2BUQ&lt; double, DynForcingP&lt; float &gt; &gt; (Param XParam, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; forcing, double *&amp; z)  template double interp2BUQ&lt; double, DynForcingP&lt; float &gt; &gt; (double x, double y, DynForcingP&lt; float &gt; forcing)  template void interp2BUQ&lt; double, StaticForcingP&lt; float &gt; &gt; (Param XParam, BlockP&lt; double &gt; XBlock, StaticForcingP&lt; float &gt; forcing, double *&amp; z)  template double interp2BUQ&lt; double, StaticForcingP&lt; float &gt; &gt; (double x, double y, StaticForcingP&lt; float &gt; forcing)  template double interp2BUQ&lt; double, StaticForcingP&lt; int &gt; &gt; (double x, double y, StaticForcingP&lt; int &gt; forcing)  template void interp2BUQ&lt; double, deformmap&lt; float &gt; &gt; (Param XParam, BlockP&lt; double &gt; XBlock, deformmap&lt; float &gt; forcing, double *&amp; z)  template double interp2BUQ&lt; double, deformmap&lt; float &gt; &gt; (double x, double y, deformmap&lt; float &gt; forcing)  template void interp2BUQ&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, std::vector&lt; StaticForcingP&lt; float &gt;&gt; forcing, float * z)  template void interp2BUQ&lt; float, DynForcingP&lt; float &gt; &gt; (Param XParam, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; forcing, float *&amp; z)  template float interp2BUQ&lt; float, DynForcingP&lt; float &gt; &gt; (float x, float y, DynForcingP&lt; float &gt; forcing)  template void interp2BUQ&lt; float, StaticForcingP&lt; float &gt; &gt; (Param XParam, BlockP&lt; float &gt; XBlock, StaticForcingP&lt; float &gt; forcing, float *&amp; z)  template float interp2BUQ&lt; float, StaticForcingP&lt; float &gt; &gt; (float x, float y, StaticForcingP&lt; float &gt; forcing)  template float interp2BUQ&lt; float, StaticForcingP&lt; int &gt; &gt; (float x, float y, StaticForcingP&lt; int &gt; forcing)  template void interp2BUQ&lt; float, deformmap&lt; float &gt; &gt; (Param XParam, BlockP&lt; float &gt; XBlock, deformmap&lt; float &gt; forcing, float *&amp; z)  template float interp2BUQ&lt; float, deformmap&lt; float &gt; &gt; (float x, float y, deformmap&lt; float &gt; forcing)  void setedges (Param XParam, BlockP&lt; T &gt; XBlock, T *&amp; zb) Set edge values for bathymetry array at domain boundaries. template void setedges&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double *&amp; zb)  template void setedges&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float *&amp; zb)  void setedgessideBT (Param XParam, int ib, int blkA, int blkB, int jread, int jwrite, T *&amp; zb) Set bottom/top edge values for bathymetry array. void setedgessideLR (Param XParam, int ib, int blkA, int blkB, int iread, int iwrite, T *&amp; zb) Set left/right edge values for bathymetry array."},{"location":"BGFlood/_grid_manip_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_grid_manip_8cu/#function-copy2cartcpu","title":"function Copy2CartCPU","text":"<p>Copy values from source to destination for a Cartesian grid. </p><pre><code>template&lt;class T&gt;\nvoid Copy2CartCPU (\n    int nx,\n    int ny,\n    T * dest,\n    T * src\n) \n</code></pre> <p>Copies all values from src to dest for a regular Cartesian grid.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x grid points </li> <li><code>ny</code> Number of y grid points </li> <li><code>dest</code> Destination array </li> <li><code>src</code> Source array </li> </ul>"},{"location":"BGFlood/_grid_manip_8cu/#function-copy2cartcpu-bool","title":"function Copy2CartCPU&lt; bool &gt;","text":"<pre><code>template void Copy2CartCPU&lt; bool &gt; (\n    int nx,\n    int ny,\n    bool * dest,\n    bool * src\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-copy2cartcpu-double","title":"function Copy2CartCPU&lt; double &gt;","text":"<pre><code>template void Copy2CartCPU&lt; double &gt; (\n    int nx,\n    int ny,\n    double * dest,\n    double * src\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-copy2cartcpu-float","title":"function Copy2CartCPU&lt; float &gt;","text":"<pre><code>template void Copy2CartCPU&lt; float &gt; (\n    int nx,\n    int ny,\n    float * dest,\n    float * src\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-copy2cartcpu-int","title":"function Copy2CartCPU&lt; int &gt;","text":"<pre><code>template void Copy2CartCPU&lt; int &gt; (\n    int nx,\n    int ny,\n    int * dest,\n    int * src\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-copyarraybuq","title":"function CopyArrayBUQ","text":"<p>Copy values from source array to destination array for all blocks. </p><pre><code>template&lt;class T, class F&gt;\nvoid CopyArrayBUQ (\n    Param XParam,\n    BlockP &lt; F &gt; XBlock,\n    T * source,\n    T *&amp; dest\n) \n</code></pre> <p>Copies all elements for each active block from source to dest.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> <li><code>F</code> Block type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>source</code> Source array </li> <li><code>dest</code> Destination array </li> </ul>"},{"location":"BGFlood/_grid_manip_8cu/#function-copyarraybuq_1","title":"function CopyArrayBUQ","text":"<p>Copy all evolving variables from source to destination. </p><pre><code>template&lt;class T&gt;\nvoid CopyArrayBUQ (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; source,\n    EvolvingP &lt; T &gt; &amp; dest\n) \n</code></pre> <p>Copies h, u, v, zs arrays for all blocks.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>source</code> Source evolving variables </li> <li><code>dest</code> Destination evolving variables </li> </ul>"},{"location":"BGFlood/_grid_manip_8cu/#function-copyarraybuq_2","title":"function CopyArrayBUQ","text":"<p>Copy all evolving variables and compute derived quantities (U, hU). </p><pre><code>template&lt;class T&gt;\nvoid CopyArrayBUQ (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; source,\n    EvolvingP_M &lt; T &gt; &amp; dest\n) \n</code></pre> <p>Copies h, u, v, zs arrays and computes U and hU for all blocks.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>source</code> Source evolving variables </li> <li><code>dest</code> Destination evolving variables (with derived quantities) </li> </ul>"},{"location":"BGFlood/_grid_manip_8cu/#function-copyarraybuq-bool-double","title":"function CopyArrayBUQ&lt; bool, double &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; bool, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    bool * source,\n    bool *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-copyarraybuq-bool-float","title":"function CopyArrayBUQ&lt; bool, float &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; bool, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    bool * source,\n    bool *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-copyarraybuq-double","title":"function CopyArrayBUQ&lt; double &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; source,\n    EvolvingP &lt; double &gt; &amp; dest\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-copyarraybuq-double_1","title":"function CopyArrayBUQ&lt; double &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; source,\n    EvolvingP_M &lt; double &gt; &amp; dest\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-copyarraybuq-double-double","title":"function CopyArrayBUQ&lt; double, double &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; double, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * source,\n    double *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-copyarraybuq-double-float","title":"function CopyArrayBUQ&lt; double, float &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; double, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    double * source,\n    double *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-copyarraybuq-float","title":"function CopyArrayBUQ&lt; float &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; source,\n    EvolvingP &lt; float &gt; &amp; dest\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-copyarraybuq-float_1","title":"function CopyArrayBUQ&lt; float &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; source,\n    EvolvingP_M &lt; float &gt; &amp; dest\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-copyarraybuq-float-double","title":"function CopyArrayBUQ&lt; float, double &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; float, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    float * source,\n    float *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-copyarraybuq-float-float","title":"function CopyArrayBUQ&lt; float, float &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; float, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * source,\n    float *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-copyarraybuq-int-double","title":"function CopyArrayBUQ&lt; int, double &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; int, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    int * source,\n    int *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-copyarraybuq-int-float","title":"function CopyArrayBUQ&lt; int, float &gt;","text":"<pre><code>template void CopyArrayBUQ&lt; int, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    int * source,\n    int *&amp; dest\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-initarraybuq","title":"function InitArrayBUQ","text":"<p>Initialize a block-structured array with a given value. </p><pre><code>template&lt;class T, class F&gt;\nvoid InitArrayBUQ (\n    Param XParam,\n    BlockP &lt; F &gt; XBlock,\n    T initval,\n    T *&amp; Arr\n) \n</code></pre> <p>Sets all elements of Arr for each active block to initval.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float, double, int, bool) </li> <li><code>F</code> Block type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>initval</code> Value to initialize </li> <li><code>Arr</code> Array to initialize </li> </ul>"},{"location":"BGFlood/_grid_manip_8cu/#function-initarraybuq-bool-double","title":"function InitArrayBUQ&lt; bool, double &gt;","text":"<pre><code>template void InitArrayBUQ&lt; bool, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    bool initval,\n    bool *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-initarraybuq-bool-float","title":"function InitArrayBUQ&lt; bool, float &gt;","text":"<pre><code>template void InitArrayBUQ&lt; bool, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    bool initval,\n    bool *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-initarraybuq-double-double","title":"function InitArrayBUQ&lt; double, double &gt;","text":"<pre><code>template void InitArrayBUQ&lt; double, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double initval,\n    double *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-initarraybuq-double-float","title":"function InitArrayBUQ&lt; double, float &gt;","text":"<pre><code>template void InitArrayBUQ&lt; double, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    double initval,\n    double *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-initarraybuq-float-double","title":"function InitArrayBUQ&lt; float, double &gt;","text":"<pre><code>template void InitArrayBUQ&lt; float, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    float initval,\n    float *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-initarraybuq-float-float","title":"function InitArrayBUQ&lt; float, float &gt;","text":"<pre><code>template void InitArrayBUQ&lt; float, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float initval,\n    float *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-initarraybuq-int-double","title":"function InitArrayBUQ&lt; int, double &gt;","text":"<pre><code>template void InitArrayBUQ&lt; int, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    int initval,\n    int *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-initarraybuq-int-float","title":"function InitArrayBUQ&lt; int, float &gt;","text":"<pre><code>template void InitArrayBUQ&lt; int, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    int initval,\n    int *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-initblkbuq","title":"function InitBlkBUQ","text":"<p>Initialize a block-level array with a given value. </p><pre><code>template&lt;class T, class F&gt;\nvoid InitBlkBUQ (\n    Param XParam,\n    BlockP &lt; F &gt; XBlock,\n    T initval,\n    T *&amp; Arr\n) \n</code></pre> <p>Sets each block's entry in Arr to initval.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> <li><code>F</code> Block type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>initval</code> Value to initialize </li> <li><code>Arr</code> Array to initialize </li> </ul>"},{"location":"BGFlood/_grid_manip_8cu/#function-initblkbuq-bool-double","title":"function InitBlkBUQ&lt; bool, double &gt;","text":"<pre><code>template void InitBlkBUQ&lt; bool, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    bool initval,\n    bool *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-initblkbuq-bool-float","title":"function InitBlkBUQ&lt; bool, float &gt;","text":"<pre><code>template void InitBlkBUQ&lt; bool, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    bool initval,\n    bool *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-initblkbuq-double-double","title":"function InitBlkBUQ&lt; double, double &gt;","text":"<pre><code>template void InitBlkBUQ&lt; double, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double initval,\n    double *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-initblkbuq-double-float","title":"function InitBlkBUQ&lt; double, float &gt;","text":"<pre><code>template void InitBlkBUQ&lt; double, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    double initval,\n    double *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-initblkbuq-float-double","title":"function InitBlkBUQ&lt; float, double &gt;","text":"<pre><code>template void InitBlkBUQ&lt; float, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    float initval,\n    float *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-initblkbuq-float-float","title":"function InitBlkBUQ&lt; float, float &gt;","text":"<pre><code>template void InitBlkBUQ&lt; float, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float initval,\n    float *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-initblkbuq-int-double","title":"function InitBlkBUQ&lt; int, double &gt;","text":"<pre><code>template void InitBlkBUQ&lt; int, double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    int initval,\n    int *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-initblkbuq-int-float","title":"function InitBlkBUQ&lt; int, float &gt;","text":"<pre><code>template void InitBlkBUQ&lt; int, float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    int initval,\n    int *&amp; Arr\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interpstepcpu","title":"function InterpstepCPU","text":"<p>CPU routine for time interpolation of solution arrays. </p><pre><code>template&lt;class T, class F&gt;\nvoid InterpstepCPU (\n    int nx,\n    int ny,\n    int hdstep,\n    F totaltime,\n    F hddt,\n    T *&amp; Ux,\n    T * Uo,\n    T * Un\n) \n</code></pre> <p>Interpolates between Uo and Un to compute Ux at a given time step.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> <li><code>F</code> Time type </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x grid points </li> <li><code>ny</code> Number of y grid points </li> <li><code>hdstep</code> Time step index </li> <li><code>totaltime</code> Total simulation time </li> <li><code>hddt</code> Time step size </li> <li><code>Ux</code> Output array </li> <li><code>Uo</code> Previous solution array </li> <li><code>Un</code> Next solution array </li> </ul>"},{"location":"BGFlood/_grid_manip_8cu/#function-interpstepcpu-double-double","title":"function InterpstepCPU&lt; double, double &gt;","text":"<pre><code>template void InterpstepCPU&lt; double, double &gt; (\n    int nx,\n    int ny,\n    int hdstep,\n    double totaltime,\n    double hddt,\n    double *&amp; Ux,\n    double * Uo,\n    double * Un\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interpstepcpu-double-float","title":"function InterpstepCPU&lt; double, float &gt;","text":"<pre><code>template void InterpstepCPU&lt; double, float &gt; (\n    int nx,\n    int ny,\n    int hdstep,\n    float totaltime,\n    float hddt,\n    double *&amp; Ux,\n    double * Uo,\n    double * Un\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interpstepcpu-float-double","title":"function InterpstepCPU&lt; float, double &gt;","text":"<pre><code>template void InterpstepCPU&lt; float, double &gt; (\n    int nx,\n    int ny,\n    int hdstep,\n    double totaltime,\n    double hddt,\n    float *&amp; Ux,\n    float * Uo,\n    float * Un\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interpstepcpu-float-float","title":"function InterpstepCPU&lt; float, float &gt;","text":"<pre><code>template void InterpstepCPU&lt; float, float &gt; (\n    int nx,\n    int ny,\n    int hdstep,\n    float totaltime,\n    float hddt,\n    float *&amp; Ux,\n    float * Uo,\n    float * Un\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interpstepcpu-int-double","title":"function InterpstepCPU&lt; int, double &gt;","text":"<pre><code>template void InterpstepCPU&lt; int, double &gt; (\n    int nx,\n    int ny,\n    int hdstep,\n    double totaltime,\n    double hddt,\n    int *&amp; Ux,\n    int * Uo,\n    int * Un\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interpstepcpu-int-float","title":"function InterpstepCPU&lt; int, float &gt;","text":"<pre><code>template void InterpstepCPU&lt; int, float &gt; (\n    int nx,\n    int ny,\n    int hdstep,\n    float totaltime,\n    float hddt,\n    int *&amp; Ux,\n    int * Uo,\n    int * Un\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interpstepgpu","title":"function InterpstepGPU","text":"<p>GPU kernel for time interpolation of solution arrays. </p><pre><code>template&lt;class T&gt;\n__global__ void InterpstepGPU (\n    int nx,\n    int ny,\n    T totaltime,\n    T beforetime,\n    T aftertime,\n    T * Ux,\n    T * Uo,\n    T * Un\n) \n</code></pre> <p>Interpolates between Uo and Un to compute Ux at a given time using shared memory.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x grid points </li> <li><code>ny</code> Number of y grid points </li> <li><code>totaltime</code> Total simulation time </li> <li><code>beforetime</code> Previous time </li> <li><code>aftertime</code> Next time </li> <li><code>Ux</code> Output array </li> <li><code>Uo</code> Previous solution array </li> <li><code>Un</code> Next solution array </li> </ul>"},{"location":"BGFlood/_grid_manip_8cu/#function-interpstepgpu-double","title":"function InterpstepGPU&lt; double &gt;","text":"<pre><code>template __global__ void InterpstepGPU&lt; double &gt; (\n    int nx,\n    int ny,\n    double totaltime,\n    double beforetime,\n    double aftertime,\n    double * Ux,\n    double * Uo,\n    double * Un\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interpstepgpu-float","title":"function InterpstepGPU&lt; float &gt;","text":"<pre><code>template __global__ void InterpstepGPU&lt; float &gt; (\n    int nx,\n    int ny,\n    float totaltime,\n    float beforetime,\n    float aftertime,\n    float * Ux,\n    float * Uo,\n    float * Un\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-blockmean","title":"function blockmean","text":"<p>Compute block mean value for (x, y) over grid spacing dx. </p><pre><code>template&lt;class T, class F&gt;\nT blockmean (\n    T x,\n    T y,\n    T dx,\n    F forcing\n) \n</code></pre> <p>Averages values in the forcing map over the block centered at (x, y).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> <li><code>F</code> Forcing type </li> </ul> <p>Parameters:</p> <ul> <li><code>x</code> X coordinate </li> <li><code>y</code> Y coordinate </li> <li><code>dx</code> Grid spacing </li> <li><code>forcing</code> Forcing map </li> </ul> <p>Returns:</p> <p>Block mean value </p>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq","title":"function interp2BUQ","text":"<p>Interpolate values from forcing map to block array using bilinear interpolation. </p><pre><code>template&lt;class T, class F&gt;\nvoid interp2BUQ (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    F forcing,\n    T *&amp; z\n) \n</code></pre> <p>Fills z array for each block using bilinear interpolation from forcing map(s).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> <li><code>F</code> Forcing type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>forcing</code> Forcing map(s) </li> <li><code>z</code> Output array </li> </ul>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq_1","title":"function interp2BUQ","text":"<p>Interpolate values from multiple forcing maps to block array using bilinear interpolation. </p><pre><code>template&lt;class T&gt;\nvoid interp2BUQ (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    std::vector&lt; StaticForcingP &lt; float &gt;&gt; forcing,\n    T * z\n) \n</code></pre> <p>Fills z array for each block using bilinear interpolation from multiple forcing maps.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>forcing</code> Vector of forcing maps </li> <li><code>z</code> Output array </li> </ul>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq_2","title":"function interp2BUQ","text":"<p>Interpolate value at (x, y) using either bilinear or blockmean interpolation. </p><pre><code>template&lt;class T, class F&gt;\nT interp2BUQ (\n    T x,\n    T y,\n    T dx,\n    F forcing\n) \n</code></pre> <p>Chooses interpolation method based on grid spacing dx.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> <li><code>F</code> Forcing type </li> </ul> <p>Parameters:</p> <ul> <li><code>x</code> X coordinate </li> <li><code>y</code> Y coordinate </li> <li><code>dx</code> Grid spacing </li> <li><code>forcing</code> Forcing map </li> </ul> <p>Returns:</p> <p>Interpolated value </p>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq_3","title":"function interp2BUQ","text":"<p>Bilinear interpolation for value at (x, y) from forcing map. </p><pre><code>template&lt;class T, class F&gt;\nT interp2BUQ (\n    T x,\n    T y,\n    F forcing\n) \n</code></pre> <p>Performs bilinear interpolation using surrounding grid points in forcing map.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> <li><code>F</code> Forcing type </li> </ul> <p>Parameters:</p> <ul> <li><code>x</code> X coordinate </li> <li><code>y</code> Y coordinate </li> <li><code>forcing</code> Forcing map </li> </ul> <p>Returns:</p> <p>Interpolated value </p>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq-double","title":"function interp2BUQ&lt; double &gt;","text":"<pre><code>template void interp2BUQ&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    std::vector&lt; StaticForcingP &lt; float &gt;&gt; forcing,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq-double-dynforcingp-float","title":"function interp2BUQ&lt; double, DynForcingP&lt; float &gt; &gt;","text":"<pre><code>template void interp2BUQ&lt; double, DynForcingP&lt; float &gt; &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; forcing,\n    double *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq-double-dynforcingp-float_1","title":"function interp2BUQ&lt; double, DynForcingP&lt; float &gt; &gt;","text":"<pre><code>template double interp2BUQ&lt; double, DynForcingP&lt; float &gt; &gt; (\n    double x,\n    double y,\n    DynForcingP &lt; float &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq-double-staticforcingp-float","title":"function interp2BUQ&lt; double, StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template void interp2BUQ&lt; double, StaticForcingP&lt; float &gt; &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    StaticForcingP &lt; float &gt; forcing,\n    double *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq-double-staticforcingp-float_1","title":"function interp2BUQ&lt; double, StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template double interp2BUQ&lt; double, StaticForcingP&lt; float &gt; &gt; (\n    double x,\n    double y,\n    StaticForcingP &lt; float &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq-double-staticforcingp-int","title":"function interp2BUQ&lt; double, StaticForcingP&lt; int &gt; &gt;","text":"<pre><code>template double interp2BUQ&lt; double, StaticForcingP&lt; int &gt; &gt; (\n    double x,\n    double y,\n    StaticForcingP &lt; int &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq-double-deformmap-float","title":"function interp2BUQ&lt; double, deformmap&lt; float &gt; &gt;","text":"<pre><code>template void interp2BUQ&lt; double, deformmap&lt; float &gt; &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    deformmap &lt; float &gt; forcing,\n    double *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq-double-deformmap-float_1","title":"function interp2BUQ&lt; double, deformmap&lt; float &gt; &gt;","text":"<pre><code>template double interp2BUQ&lt; double, deformmap&lt; float &gt; &gt; (\n    double x,\n    double y,\n    deformmap &lt; float &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq-float","title":"function interp2BUQ&lt; float &gt;","text":"<pre><code>template void interp2BUQ&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    std::vector&lt; StaticForcingP &lt; float &gt;&gt; forcing,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq-float-dynforcingp-float","title":"function interp2BUQ&lt; float, DynForcingP&lt; float &gt; &gt;","text":"<pre><code>template void interp2BUQ&lt; float, DynForcingP&lt; float &gt; &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; forcing,\n    float *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq-float-dynforcingp-float_1","title":"function interp2BUQ&lt; float, DynForcingP&lt; float &gt; &gt;","text":"<pre><code>template float interp2BUQ&lt; float, DynForcingP&lt; float &gt; &gt; (\n    float x,\n    float y,\n    DynForcingP &lt; float &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq-float-staticforcingp-float","title":"function interp2BUQ&lt; float, StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template void interp2BUQ&lt; float, StaticForcingP&lt; float &gt; &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    StaticForcingP &lt; float &gt; forcing,\n    float *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq-float-staticforcingp-float_1","title":"function interp2BUQ&lt; float, StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template float interp2BUQ&lt; float, StaticForcingP&lt; float &gt; &gt; (\n    float x,\n    float y,\n    StaticForcingP &lt; float &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq-float-staticforcingp-int","title":"function interp2BUQ&lt; float, StaticForcingP&lt; int &gt; &gt;","text":"<pre><code>template float interp2BUQ&lt; float, StaticForcingP&lt; int &gt; &gt; (\n    float x,\n    float y,\n    StaticForcingP &lt; int &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq-float-deformmap-float","title":"function interp2BUQ&lt; float, deformmap&lt; float &gt; &gt;","text":"<pre><code>template void interp2BUQ&lt; float, deformmap&lt; float &gt; &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    deformmap &lt; float &gt; forcing,\n    float *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-interp2buq-float-deformmap-float_1","title":"function interp2BUQ&lt; float, deformmap&lt; float &gt; &gt;","text":"<pre><code>template float interp2BUQ&lt; float, deformmap&lt; float &gt; &gt; (\n    float x,\n    float y,\n    deformmap &lt; float &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-setedges","title":"function setedges","text":"<p>Set edge values for bathymetry array at domain boundaries. </p><pre><code>template&lt;class T&gt;\nvoid setedges (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; zb\n) \n</code></pre> <p>Copies values from interior to boundary cells for blocks with no neighbor.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_grid_manip_8cu/#function-setedges-double","title":"function setedges&lt; double &gt;","text":"<pre><code>template void setedges&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-setedges-float","title":"function setedges&lt; float &gt;","text":"<pre><code>template void setedges&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_grid_manip_8cu/#function-setedgessidebt","title":"function setedgessideBT","text":"<p>Set bottom/top edge values for bathymetry array. </p><pre><code>template&lt;class T&gt;\nvoid setedgessideBT (\n    Param XParam,\n    int ib,\n    int blkA,\n    int blkB,\n    int jread,\n    int jwrite,\n    T *&amp; zb\n) \n</code></pre> <p>Copies values from interior to boundary cells for bottom/top edges.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>ib</code> Block index </li> <li><code>blkA</code> Neighbor block A </li> <li><code>blkB</code> Neighbor block B </li> <li><code>jread</code> Index to read from </li> <li><code>jwrite</code> Index to write to </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_grid_manip_8cu/#function-setedgessidelr","title":"function setedgessideLR","text":"<p>Set left/right edge values for bathymetry array. </p><pre><code>template&lt;class T&gt;\nvoid setedgessideLR (\n    Param XParam,\n    int ib,\n    int blkA,\n    int blkB,\n    int iread,\n    int iwrite,\n    T *&amp; zb\n) \n</code></pre> <p>Copies values from interior to boundary cells for left/right edges.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>ib</code> Block index </li> <li><code>blkA</code> Neighbor block A </li> <li><code>blkB</code> Neighbor block B </li> <li><code>iread</code> Index to read from </li> <li><code>iwrite</code> Index to write to </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>The documentation for this class was generated from the following file <code>src/GridManip.cu</code></p>"},{"location":"BGFlood/_grid_manip_8cu_source/","title":"File GridManip.cu","text":""},{"location":"BGFlood/_grid_manip_8cu_source/#file-gridmanipcu","title":"File GridManip.cu","text":"<p>File List &gt; src &gt; GridManip.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n// This code contains an adaptation of the St Venant equation from Basilisk     //\n// See                                                                          //\n// http://basilisk.fr/src/saint-venant.h and                                    //\n// S. Popinet. Quadtree-adaptive tsunami modelling. Ocean Dynamics,             //\n// doi: 61(9) : 1261 - 1285, 2011                                               //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //\n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n\n#include \"GridManip.h\"\n\n\n\n\n#include \"GridManip.h\"\n\ntemplate &lt;class T,class F&gt; void InitArrayBUQ(Param XParam, BlockP&lt;F&gt; XBlock,  T initval, T*&amp; Arr)\n{\n    int ib, n;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                //n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                n = memloc(XParam, i, j, ib);\n                Arr[n] = initval;\n            }\n        }\n    }\n}\n\ntemplate void InitArrayBUQ&lt;float,float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float initval, float*&amp; Arr);\ntemplate void InitArrayBUQ&lt;double, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, double initval, double*&amp; Arr);\ntemplate void InitArrayBUQ&lt;int, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, int initval, int*&amp; Arr);\ntemplate void InitArrayBUQ&lt;bool, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, bool initval, bool*&amp; Arr);\n\ntemplate void InitArrayBUQ&lt;float, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, float initval, float*&amp; Arr);\ntemplate void InitArrayBUQ&lt;double, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double initval, double*&amp; Arr);\ntemplate void InitArrayBUQ&lt;int, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, int initval, int*&amp; Arr);\ntemplate void InitArrayBUQ&lt;bool, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, bool initval, bool*&amp; Arr);\n\n\n\ntemplate &lt;class T, class F&gt; void InitBlkBUQ(Param XParam, BlockP&lt;F&gt; XBlock, T initval, T*&amp; Arr)\n{\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n\n                Arr[ib] = initval;\n\n    }\n}\n\ntemplate void InitBlkBUQ&lt;bool, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, bool initval, bool*&amp; Arr);\ntemplate void InitBlkBUQ&lt;int, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, int initval, int*&amp; Arr);\ntemplate void InitBlkBUQ&lt;float, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float initval, float*&amp; Arr);\ntemplate void InitBlkBUQ&lt;double, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, double initval, double*&amp; Arr);\n\ntemplate void InitBlkBUQ&lt;bool, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, bool initval, bool*&amp; Arr);\ntemplate void InitBlkBUQ&lt;int, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, int initval, int*&amp; Arr);\ntemplate void InitBlkBUQ&lt;float, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, float initval, float*&amp; Arr);\ntemplate void InitBlkBUQ&lt;double, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double initval, double*&amp; Arr);\n\n\ntemplate &lt;class T,class F&gt; void CopyArrayBUQ(Param XParam,BlockP&lt;F&gt; XBlock, T* source, T* &amp; dest)\n{\n    int ib,n;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n\n\n                dest[n] = source[n];\n            }\n        }\n    }\n}\ntemplate void CopyArrayBUQ&lt;bool, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, bool* source, bool*&amp; dest);\ntemplate void CopyArrayBUQ&lt;int, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, int* source, int*&amp; dest);\ntemplate void CopyArrayBUQ&lt;float, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* source, float*&amp; dest);\ntemplate void CopyArrayBUQ&lt;double, float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, double* source, double*&amp; dest);\n\ntemplate void CopyArrayBUQ&lt;bool, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, bool* source, bool*&amp; dest);\ntemplate void CopyArrayBUQ&lt;int, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, int* source, int*&amp; dest);\ntemplate void CopyArrayBUQ&lt;float, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, float* source, float*&amp; dest);\ntemplate void CopyArrayBUQ&lt;double, double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* source, double*&amp; dest);\n\n\ntemplate &lt;class T&gt; void CopyArrayBUQ(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; source, EvolvingP&lt;T&gt;&amp; dest)\n{\n    CopyArrayBUQ(XParam, XBlock, source.h, dest.h);\n    CopyArrayBUQ(XParam, XBlock, source.u, dest.u);\n    CopyArrayBUQ(XParam, XBlock, source.v, dest.v);\n    CopyArrayBUQ(XParam, XBlock, source.zs, dest.zs);\n}\ntemplate void CopyArrayBUQ&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; source, EvolvingP&lt;float&gt;&amp; dest);\ntemplate void CopyArrayBUQ&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; source, EvolvingP&lt;double&gt;&amp; dest);\n\ntemplate &lt;class T&gt; void CopyArrayBUQ(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; source, EvolvingP_M&lt;T&gt;&amp; dest)\n{\n    CopyArrayBUQ(XParam, XBlock, source.h, dest.h);\n    CopyArrayBUQ(XParam, XBlock, source.u, dest.u);\n    CopyArrayBUQ(XParam, XBlock, source.v, dest.v);\n    CopyArrayBUQ(XParam, XBlock, source.zs, dest.zs);\n    // For U and hU:\n    int ib, n;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                dest.U[n] = sqrt((source.u[n]*source.u[n]) + (source.v[n]*source.v[n]));\n                dest.hU[n] = source.h[n] * dest.U[n];\n            }\n        }\n    }\n\n}\ntemplate void CopyArrayBUQ&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; source, EvolvingP_M&lt;float&gt;&amp; dest);\ntemplate void CopyArrayBUQ&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; source, EvolvingP_M&lt;double&gt;&amp; dest);\n\n\ntemplate &lt;class T&gt;  void setedges(Param XParam, BlockP&lt;T&gt; XBlock, T *&amp;zb)\n{\n    // template &lt;class T&gt; void setedges(int nblk, int nx, int ny, double xo, double yo, double dx, int * leftblk, int *rightblk, int * topblk, int* botblk, double *blockxo, double * blockyo, T *&amp;zb)\n\n    // here the bathy of the outter most cells of the domain are \"set\" to the same value as the second outter most.\n    // this also applies to the blocks with no neighbour\n    for (int bl = 0; bl &lt; XParam.nblk; bl++)\n    {\n        int ib = XBlock.active[bl];\n        // Now check each corner of each block\n        //printf(\"bl=%i\\t ib=%i\\t,LB=%i\\t,LT=%i\\t,RB=%i\\t,RT=%i\\t,TL=%i\\t,TR=%i\\t,BL=%i\\t,BR=%i\\n \", bl, ib, XBlock.LeftBot[ib], XBlock.LeftTop[ib], XBlock.RightBot[ib], XBlock.RightTop[ib], XBlock.TopLeft[ib], XBlock.TopRight[ib], XBlock.BotLeft[ib], XBlock.BotRight[ib]);\n\n        // Left\n        setedgessideLR(XParam, ib, XBlock.LeftBot[ib], XBlock.LeftTop[ib], 1, 0, zb);\n\n        // Right\n        setedgessideLR(XParam, ib, XBlock.RightBot[ib], XBlock.RightTop[ib], XParam.blkwidth - 2, XParam.blkwidth - 1, zb);\n\n        // Top\n        setedgessideBT(XParam, ib, XBlock.TopLeft[ib], XBlock.TopRight[ib], XParam.blkwidth - 2, XParam.blkwidth - 1, zb);\n\n        // Bot\n        setedgessideBT(XParam, ib, XBlock.BotLeft[ib], XBlock.BotRight[ib], 1, 0, zb);\n\n\n    }\n}\ntemplate void setedges&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float*&amp; zb);\ntemplate void setedges&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double*&amp; zb);\n\ntemplate &lt;class T&gt;  void setedgessideLR(Param XParam, int ib,int blkA, int blkB, int iread, int iwrite, T*&amp; zb)\n{\n    if (blkA == ib || blkA == ib)\n    {\n        int n, k;\n        int jstart, jend;\n        jstart = (blkA == ib) ? 0 : XParam.blkwidth / 2;\n        jend = (blkB == ib) ? XParam.blkwidth : XParam.blkwidth / 2;\n\n        for (int j = jstart; j &lt; jend; j++)\n        {\n            // read value at n and write at k\n            n = (iread + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            k = (iwrite + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            zb[k] = zb[n];\n\n        }\n    }\n}\n\ntemplate &lt;class T&gt;  void setedgessideBT(Param XParam, int ib, int blkA, int blkB, int jread, int jwrite, T*&amp; zb)\n{\n    if (blkA == ib || blkB == ib)\n    {\n        int n, k;\n        int istart, iend;\n        istart = (blkA == ib) ? 0 : XParam.blkwidth / 2;\n        iend = (blkB == ib) ? XParam.blkwidth : XParam.blkwidth / 2;\n\n        for (int i = istart; i &lt; iend; i++)\n        {\n            // read value at n and write at k\n            n = (i + XParam.halowidth) + (jread + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            k = (i + XParam.halowidth) + (jwrite + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            zb[k] = zb[n];\n\n        }\n    }\n}\n\n\ntemplate &lt;class T, class F&gt; void interp2BUQ(Param XParam, BlockP&lt;T&gt; XBlock, F forcing, T*&amp; z)\n{\n    // This function interpolates the values in bathy maps or roughness map to cf using a bilinear interpolation\n\n    T x, y;\n    int n;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XBlock.active[ibl];\n\n        double blkdx = calcres(XParam.dx, XBlock.level[ib]);\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                n = (i+XParam.halowidth) + (j+XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                x = T(XParam.xo + XBlock.xo[ib] + i * blkdx);\n                y = T(XParam.yo + XBlock.yo[ib] + j * blkdx);\n\n                z[n] = interp2BUQ(x, y, T(blkdx), forcing);\n\n            }\n        }\n    }\n}\ntemplate void interp2BUQ&lt;float, StaticForcingP&lt;float&gt;&gt;(Param XParam, BlockP&lt;float&gt; XBlock, StaticForcingP&lt;float&gt; forcing, float*&amp; z);\ntemplate void interp2BUQ&lt;double, StaticForcingP&lt;float&gt;&gt;(Param XParam, BlockP&lt;double&gt; XBlock, StaticForcingP&lt;float&gt; forcing, double*&amp; z);\n//template void interp2BUQ&lt;float, StaticForcingP&lt;float&gt;&gt;(Param XParam, BlockP&lt;float&gt; XBlock, std::vector&lt;StaticForcingP&lt;float&gt;&gt; forcing, float*&amp; z);\n//template void interp2BUQ&lt;double, StaticForcingP&lt;float&gt;&gt;(Param XParam, BlockP&lt;double&gt; XBlock, StaticForcingP&lt;float&gt; forcing, double*&amp; z);\ntemplate void interp2BUQ&lt;float, deformmap&lt;float&gt;&gt;(Param XParam, BlockP&lt;float&gt; XBlock, deformmap&lt;float&gt; forcing, float*&amp; z);\ntemplate void interp2BUQ&lt;double, deformmap&lt;float&gt;&gt;(Param XParam, BlockP&lt;double&gt; XBlock, deformmap&lt;float&gt; forcing, double*&amp; z);\ntemplate void interp2BUQ&lt;float, DynForcingP&lt;float&gt;&gt;(Param XParam, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; forcing, float*&amp; z);\ntemplate void interp2BUQ&lt;double, DynForcingP&lt;float&gt;&gt;(Param XParam, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; forcing, double*&amp; z);\n\ntemplate &lt;class T&gt; void interp2BUQ(Param XParam, BlockP&lt;T&gt; XBlock, std::vector&lt;StaticForcingP&lt;float&gt;&gt; forcing, T* z)\n{\n    // This function interpolates the values in bathy maps or roughness map to cf using a bilinear interpolation\n\n    T x, y;\n    int n;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XBlock.active[ibl];\n\n        double blkdx = calcres(XParam.dx, XBlock.level[ib]);\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                x = T(XParam.xo + XBlock.xo[ib] + i * blkdx);\n                y = T(XParam.yo + XBlock.yo[ib] + j * blkdx);\n\n                // Interpolate to fill in values from the whole domain (even if the domain outspan the domain fo the bathy)\n                z[n] = interp2BUQ(x, y, T(blkdx), forcing[0]);\n\n                // now interpolat to other grids\n                if (forcing.size() &gt; 1)\n                {\n                    for (int nf = 1; nf &lt; forcing.size(); nf++)\n                    {\n                        if (x &gt;= forcing[nf].xo &amp;&amp; x &lt;= forcing[nf].xmax &amp;&amp; y &gt;= forcing[nf].yo &amp;&amp; y &lt;= forcing[nf].ymax)\n                        {\n                            T interpval= interp2BUQ(x, y, T(blkdx), forcing[nf]);\n\n                            //if (isnan(interpval))\n                            //{\n                            //  log(\"NAN detected\");\n                            //}\n\n                            if (!isnan(interpval))\n                            {\n                                z[n] = interp2BUQ(x, y, T(blkdx), forcing[nf]);\n                            }\n                            //else\n                            //{\n                            //  z[n] = -999.0;\n                            //}\n                            //{\n                            //  log(\"NAN detected: Z=\"+std::to_string(z[n]));\n                            //}\n\n                        }\n                    }\n                }\n\n\n            }\n        }\n    }\n}\ntemplate void interp2BUQ&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, std::vector&lt;StaticForcingP&lt;float&gt;&gt; forcing, float* z);\ntemplate void interp2BUQ&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, std::vector&lt;StaticForcingP&lt;float&gt;&gt; forcing, double* z);\n\n\ntemplate &lt;class T, class F&gt; T interp2BUQ(T x, T y, T dx, F forcing)\n{\n    T z;\n    if (dx &lt;= T(forcing.dx)) // bilinear interpolation\n    {\n        z = interp2BUQ(x, y, forcing);\n    }\n    else //blockmean interpolation\n    {\n        z = blockmean(x, y, dx, forcing);\n    }\n    return z;\n}\n\n\ntemplate &lt;class T, class F&gt; T blockmean(T x, T y,T dx, F forcing)\n{\n    double xmin, xmax, ymin, ymax;\n    T z;\n    int imin,imax,jmin,jmax,ni, nj,cfi,cfj;\n\n\n    xmin = x - dx * 0.5;\n    xmax = x + dx * 0.5;\n    ymin = y - dx * 0.5;\n    ymax = y + dx * 0.5;\n\n    imin = max(ftoi(floor((xmin - forcing.xo) / forcing.dx)), 0);\n    imax = min(ftoi(floor((xmax - forcing.xo) / forcing.dx)), forcing.nx - 1);\n\n    jmin = max(ftoi(floor((ymin - forcing.yo) / forcing.dy)), 0);\n    jmax = min(ftoi(floor((ymax - forcing.yo) / forcing.dy)), forcing.ny - 1);\n\n    //printf(\"imin=%d; imax=%d, jmin=%d, jmax=%d\\t\",imin, imax, jmin, jmax);\n\n    ni = max(imax - imin + 1, 1);\n    nj = max(jmax - jmin + 1, 1);\n\n\n    //printf(\"ni=%d; nj=%d\\n\", ni, nj);\n    z = 0.0;\n    for (int i = 0; i &lt; ni; i++)\n    {\n        for (int j = 0; j &lt; nj; j++)\n        {\n            cfi = min(imin + i, forcing.nx - 1);\n            cfj = min(jmin + j, forcing.ny - 1);\n            z = z + forcing.val[cfi + cfj * forcing.nx];\n        }\n\n    }\n\n    z = z / (ni * nj);\n\n\n    return z;\n\n}\n\ntemplate &lt;class T, class F&gt; T interp2BUQ(T x, T y, F forcing)\n{\n    //this is safer!\n\n    double xi, yi;\n\n    xi = utils::max(utils::min(double(x), forcing.xmax), forcing.xo);\n    yi = utils::max(utils::min(double(y), forcing.ymax), forcing.yo);\n    // cells that falls off this domain are assigned\n    double x1, x2, y1, y2;\n    double q11, q12, q21, q22;\n    int cfi, cfip, cfj, cfjp;\n\n\n\n    cfi = utils::min(utils::max((int)floor((xi - forcing.xo) / forcing.dx), 0), forcing.nx - 2);\n    cfip = cfi + 1;\n\n    x1 = forcing.xo + forcing.dx * cfi;\n    x2 = forcing.xo + forcing.dx * cfip;\n\n    cfj = utils::min(utils::max((int)floor((yi - forcing.yo) / forcing.dy), 0), forcing.ny - 2);\n    cfjp = cfj + 1;\n\n    y1 = forcing.yo + forcing.dy * cfj;\n    y2 = forcing.yo + forcing.dy * cfjp;\n\n    q11 = forcing.val[cfi + cfj * forcing.nx];\n    q12 = forcing.val[cfi + cfjp * forcing.nx];\n    q21 = forcing.val[cfip + cfj * forcing.nx];\n    q22 = forcing.val[cfip + cfjp * forcing.nx];\n\n    return T(BilinearInterpolation(q11, q12, q21, q22, x1, x2, y1, y2, xi, yi));\n\n\n}\ntemplate float interp2BUQ&lt;float, StaticForcingP&lt;float&gt;&gt;(float x, float y, StaticForcingP&lt;float&gt; forcing);\ntemplate double interp2BUQ&lt;double, StaticForcingP&lt;float&gt;&gt;(double x, double y, StaticForcingP&lt;float&gt; forcing);\ntemplate float interp2BUQ&lt;float, StaticForcingP&lt;int&gt;&gt;(float x, float y, StaticForcingP&lt;int&gt; forcing);\ntemplate double interp2BUQ&lt;double, StaticForcingP&lt;int&gt;&gt;(double x, double y, StaticForcingP&lt;int&gt; forcing);\ntemplate float interp2BUQ&lt;float, deformmap&lt;float&gt;&gt;(float x, float y, deformmap&lt;float&gt; forcing);\ntemplate double interp2BUQ&lt;double, deformmap&lt;float&gt;&gt;(double x, double y, deformmap&lt;float&gt; forcing);\ntemplate float interp2BUQ&lt;float, DynForcingP&lt;float&gt;&gt;(float x, float y, DynForcingP&lt;float&gt; forcing);\ntemplate double interp2BUQ&lt;double, DynForcingP&lt;float&gt;&gt;(double x, double y, DynForcingP&lt;float&gt; forcing);\n\n\ntemplate &lt;class T, class F&gt; void InterpstepCPU(int nx, int ny, int hdstep, F totaltime, F hddt, T *&amp;Ux, T *Uo, T *Un)\n{\n    //float fac = 1.0;\n    T Uxo, Uxn;\n\n    /*Ums[tx]=Umask[ix];*/\n\n\n\n\n    for (int i = 0; i &lt; nx; i++)\n    {\n        for (int j = 0; j &lt; ny; j++)\n        {\n            Uxo = Uo[i + nx*j];\n            Uxn = Un[i + nx*j];\n\n            Ux[i + nx*j] = T(Uxo + (totaltime - hddt*hdstep)*(Uxn - Uxo) / hddt);\n        }\n    }\n}\ntemplate void InterpstepCPU&lt;int,float&gt;(int nx, int ny, int hdstep, float totaltime, float hddt, int *&amp;Ux, int *Uo, int *Un);\ntemplate void InterpstepCPU&lt;float, float&gt;(int nx, int ny, int hdstep, float totaltime, float hddt, float *&amp;Ux, float *Uo, float *Un);\ntemplate void InterpstepCPU&lt;double, float&gt;(int nx, int ny, int hdstep, float totaltime, float hddt, double *&amp;Ux, double *Uo, double *Un);\ntemplate void InterpstepCPU&lt;int, double&gt;(int nx, int ny, int hdstep, double totaltime, double hddt, int*&amp; Ux, int* Uo, int* Un);\ntemplate void InterpstepCPU&lt;float, double&gt;(int nx, int ny, int hdstep, double totaltime, double hddt, float*&amp; Ux, float* Uo, float* Un);\ntemplate void InterpstepCPU&lt;double, double&gt;(int nx, int ny, int hdstep, double totaltime, double hddt, double*&amp; Ux, double* Uo, double* Un);\n\n\ntemplate &lt;class T&gt; __global__ void InterpstepGPU(int nx, int ny, T totaltime, T beforetime, T aftertime, T*Ux, T* Uo, T* Un)\n{\n    unsigned int ix = blockIdx.x * blockDim.x + threadIdx.x;\n    unsigned int iy = blockIdx.y * blockDim.y + threadIdx.y;\n    unsigned int tx = threadIdx.x;\n    unsigned int ty = threadIdx.y;\n\n    __shared__ T Uxo[16][16];\n    __shared__ T Uxn[16][16];\n    //  __shared__ float Ums[16];\n\n    T hddt = aftertime - beforetime;\n\n    if (ix &lt; nx &amp;&amp; iy &lt; ny)\n    {\n        Uxo[tx][ty] = Uo[ix + nx * iy];\n        Uxn[tx][ty] = Un[ix + nx * iy];\n\n        Ux[ix + nx * iy] = Uxo[tx][ty] + (totaltime - beforetime) * (Uxn[tx][ty] - Uxo[tx][ty]) / (hddt);\n    }\n}\n//template __global__ void InterpstepGPU&lt;int&gt;(int nx, int ny, int hdstp, T totaltime, T hddt, T* Ux, T* Uo, T* Un);\ntemplate __global__ void InterpstepGPU&lt;float&gt;(int nx, int ny, float totaltime, float beforetime, float aftertime, float* Ux, float* Uo, float* Un);\ntemplate __global__ void InterpstepGPU&lt;double&gt;(int nx, int ny, double totaltime, double beforetime, double aftertime, double* Ux, double* Uo, double* Un);\n\n\n\ntemplate &lt;class T&gt; void Copy2CartCPU(int nx, int ny, T* dest, T* src)\n{\n    for (int i = 0; i &lt; nx; i++)\n    {\n        for (int j = 0; j &lt; ny; j++)\n        {\n            dest[i + nx * j] = src[i + nx * j];\n        }\n    }\n}\ntemplate void Copy2CartCPU&lt;int&gt;(int nx, int ny, int* dest, int* src);\ntemplate void Copy2CartCPU&lt;bool&gt;(int nx, int ny, bool* dest, bool* src);\ntemplate void Copy2CartCPU&lt;float&gt;(int nx, int ny, float* dest, float* src);\ntemplate void Copy2CartCPU&lt;double&gt;(int nx, int ny, double* dest, double* src);\n</code></pre>"},{"location":"BGFlood/_grid_manip_8h/","title":"File GridManip.h","text":""},{"location":"BGFlood/_grid_manip_8h/#file-gridmaniph","title":"File GridManip.h","text":"<p>FileList &gt; src &gt; GridManip.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> </ul>"},{"location":"BGFlood/_grid_manip_8h/#public-functions","title":"Public Functions","text":"Type Name void Copy2CartCPU (int nx, int ny, T * dest, T * src) Copy values from source to destination for a Cartesian grid. void CopyArrayBUQ (Param XParam, BlockP&lt; F &gt; XBlock, T * source, T *&amp; dest) Copy values from source array to destination array for all blocks. void CopyArrayBUQ (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; source, EvolvingP&lt; T &gt; &amp; dest) Copy all evolving variables from source to destination. void CopyArrayBUQ (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; source, EvolvingP_M&lt; T &gt; &amp; dest) Copy all evolving variables and compute derived quantities (U, hU). void InitArrayBUQ (Param XParam, BlockP&lt; F &gt; XBlock, T initval, T *&amp; Arr) Initialize a block-structured array with a given value. void InitBlkBUQ (Param XParam, BlockP&lt; F &gt; XBlock, T initval, T *&amp; Arr) Initialize a block-level array with a given value. void InterpstepCPU (int nx, int ny, int hdstep, F totaltime, F hddt, T *&amp; Ux, T * Uo, T * Un) CPU routine for time interpolation of solution arrays. __global__ void InterpstepGPU (int nx, int ny, T totaltime, T beforetime, T aftertime, T * Ux, T * Uo, T * Un) GPU kernel for time interpolation of solution arrays. void interp2BUQ (Param XParam, BlockP&lt; T &gt; XBlock, std::vector&lt; StaticForcingP&lt; float &gt;&gt; forcing, T * z) Interpolate values from multiple forcing maps to block array using bilinear interpolation. void interp2BUQ (Param XParam, BlockP&lt; T &gt; XBlock, F forcing, T *&amp; z) Interpolate values from forcing map to block array using bilinear interpolation. T interp2BUQ (T x, T y, F forcing) Bilinear interpolation for value at (x, y) from forcing map. T interp2BUQ (T x, T y, T dx, F forcing) Interpolate value at (x, y) using either bilinear or blockmean interpolation. void setedges (Param XParam, BlockP&lt; T &gt; XBlock, T *&amp; zb) Set edge values for bathymetry array at domain boundaries."},{"location":"BGFlood/_grid_manip_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_grid_manip_8h/#function-copy2cartcpu","title":"function Copy2CartCPU","text":"<p>Copy values from source to destination for a Cartesian grid. </p><pre><code>template&lt;class T&gt;\nvoid Copy2CartCPU (\n    int nx,\n    int ny,\n    T * dest,\n    T * src\n) \n</code></pre> <p>Copies all values from src to dest for a regular Cartesian grid.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x grid points </li> <li><code>ny</code> Number of y grid points </li> <li><code>dest</code> Destination array </li> <li><code>src</code> Source array </li> </ul>"},{"location":"BGFlood/_grid_manip_8h/#function-copyarraybuq","title":"function CopyArrayBUQ","text":"<p>Copy values from source array to destination array for all blocks. </p><pre><code>template&lt;class T, class F&gt;\nvoid CopyArrayBUQ (\n    Param XParam,\n    BlockP &lt; F &gt; XBlock,\n    T * source,\n    T *&amp; dest\n) \n</code></pre> <p>Copies all elements for each active block from source to dest.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> <li><code>F</code> Block type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>source</code> Source array </li> <li><code>dest</code> Destination array </li> </ul>"},{"location":"BGFlood/_grid_manip_8h/#function-copyarraybuq_1","title":"function CopyArrayBUQ","text":"<p>Copy all evolving variables from source to destination. </p><pre><code>template&lt;class T&gt;\nvoid CopyArrayBUQ (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; source,\n    EvolvingP &lt; T &gt; &amp; dest\n) \n</code></pre> <p>Copies h, u, v, zs arrays for all blocks.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>source</code> Source evolving variables </li> <li><code>dest</code> Destination evolving variables </li> </ul>"},{"location":"BGFlood/_grid_manip_8h/#function-copyarraybuq_2","title":"function CopyArrayBUQ","text":"<p>Copy all evolving variables and compute derived quantities (U, hU). </p><pre><code>template&lt;class T&gt;\nvoid CopyArrayBUQ (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; source,\n    EvolvingP_M &lt; T &gt; &amp; dest\n) \n</code></pre> <p>Copies h, u, v, zs arrays and computes U and hU for all blocks.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>source</code> Source evolving variables </li> <li><code>dest</code> Destination evolving variables (with derived quantities) </li> </ul>"},{"location":"BGFlood/_grid_manip_8h/#function-initarraybuq","title":"function InitArrayBUQ","text":"<p>Initialize a block-structured array with a given value. </p><pre><code>template&lt;class T, class F&gt;\nvoid InitArrayBUQ (\n    Param XParam,\n    BlockP &lt; F &gt; XBlock,\n    T initval,\n    T *&amp; Arr\n) \n</code></pre> <p>Sets all elements of Arr for each active block to initval.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float, double, int, bool) </li> <li><code>F</code> Block type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>initval</code> Value to initialize </li> <li><code>Arr</code> Array to initialize </li> </ul>"},{"location":"BGFlood/_grid_manip_8h/#function-initblkbuq","title":"function InitBlkBUQ","text":"<p>Initialize a block-level array with a given value. </p><pre><code>template&lt;class T, class F&gt;\nvoid InitBlkBUQ (\n    Param XParam,\n    BlockP &lt; F &gt; XBlock,\n    T initval,\n    T *&amp; Arr\n) \n</code></pre> <p>Sets each block's entry in Arr to initval.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> <li><code>F</code> Block type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>initval</code> Value to initialize </li> <li><code>Arr</code> Array to initialize </li> </ul>"},{"location":"BGFlood/_grid_manip_8h/#function-interpstepcpu","title":"function InterpstepCPU","text":"<p>CPU routine for time interpolation of solution arrays. </p><pre><code>template&lt;class T, class F&gt;\nvoid InterpstepCPU (\n    int nx,\n    int ny,\n    int hdstep,\n    F totaltime,\n    F hddt,\n    T *&amp; Ux,\n    T * Uo,\n    T * Un\n) \n</code></pre> <p>Interpolates between Uo and Un to compute Ux at a given time step.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> <li><code>F</code> Time type </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x grid points </li> <li><code>ny</code> Number of y grid points </li> <li><code>hdstep</code> Time step index </li> <li><code>totaltime</code> Total simulation time </li> <li><code>hddt</code> Time step size </li> <li><code>Ux</code> Output array </li> <li><code>Uo</code> Previous solution array </li> <li><code>Un</code> Next solution array </li> </ul>"},{"location":"BGFlood/_grid_manip_8h/#function-interpstepgpu","title":"function InterpstepGPU","text":"<p>GPU kernel for time interpolation of solution arrays. </p><pre><code>template&lt;class T&gt;\n__global__ void InterpstepGPU (\n    int nx,\n    int ny,\n    T totaltime,\n    T beforetime,\n    T aftertime,\n    T * Ux,\n    T * Uo,\n    T * Un\n) \n</code></pre> <p>Interpolates between Uo and Un to compute Ux at a given time using shared memory.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x grid points </li> <li><code>ny</code> Number of y grid points </li> <li><code>totaltime</code> Total simulation time </li> <li><code>beforetime</code> Previous time </li> <li><code>aftertime</code> Next time </li> <li><code>Ux</code> Output array </li> <li><code>Uo</code> Previous solution array </li> <li><code>Un</code> Next solution array </li> </ul>"},{"location":"BGFlood/_grid_manip_8h/#function-interp2buq","title":"function interp2BUQ","text":"<p>Interpolate values from multiple forcing maps to block array using bilinear interpolation. </p><pre><code>template&lt;class T&gt;\nvoid interp2BUQ (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    std::vector&lt; StaticForcingP &lt; float &gt;&gt; forcing,\n    T * z\n) \n</code></pre> <p>Fills z array for each block using bilinear interpolation from multiple forcing maps.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>forcing</code> Vector of forcing maps </li> <li><code>z</code> Output array </li> </ul>"},{"location":"BGFlood/_grid_manip_8h/#function-interp2buq_1","title":"function interp2BUQ","text":"<p>Interpolate values from forcing map to block array using bilinear interpolation. </p><pre><code>template&lt;class T, class F&gt;\nvoid interp2BUQ (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    F forcing,\n    T *&amp; z\n) \n</code></pre> <p>Fills z array for each block using bilinear interpolation from forcing map(s).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> <li><code>F</code> Forcing type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>forcing</code> Forcing map(s) </li> <li><code>z</code> Output array </li> </ul>"},{"location":"BGFlood/_grid_manip_8h/#function-interp2buq_2","title":"function interp2BUQ","text":"<p>Bilinear interpolation for value at (x, y) from forcing map. </p><pre><code>template&lt;class T, class F&gt;\nT interp2BUQ (\n    T x,\n    T y,\n    F forcing\n) \n</code></pre> <p>Performs bilinear interpolation using surrounding grid points in forcing map.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> <li><code>F</code> Forcing type </li> </ul> <p>Parameters:</p> <ul> <li><code>x</code> X coordinate </li> <li><code>y</code> Y coordinate </li> <li><code>forcing</code> Forcing map </li> </ul> <p>Returns:</p> <p>Interpolated value </p>"},{"location":"BGFlood/_grid_manip_8h/#function-interp2buq_3","title":"function interp2BUQ","text":"<p>Interpolate value at (x, y) using either bilinear or blockmean interpolation. </p><pre><code>template&lt;class T, class F&gt;\nT interp2BUQ (\n    T x,\n    T y,\n    T dx,\n    F forcing\n) \n</code></pre> <p>Chooses interpolation method based on grid spacing dx.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> <li><code>F</code> Forcing type </li> </ul> <p>Parameters:</p> <ul> <li><code>x</code> X coordinate </li> <li><code>y</code> Y coordinate </li> <li><code>dx</code> Grid spacing </li> <li><code>forcing</code> Forcing map </li> </ul> <p>Returns:</p> <p>Interpolated value </p>"},{"location":"BGFlood/_grid_manip_8h/#function-setedges","title":"function setedges","text":"<p>Set edge values for bathymetry array at domain boundaries. </p><pre><code>template&lt;class T&gt;\nvoid setedges (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; zb\n) \n</code></pre> <p>Copies values from interior to boundary cells for blocks with no neighbor.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>The documentation for this class was generated from the following file <code>src/GridManip.h</code></p>"},{"location":"BGFlood/_grid_manip_8h_source/","title":"File GridManip.h","text":""},{"location":"BGFlood/_grid_manip_8h_source/#file-gridmaniph","title":"File GridManip.h","text":"<p>File List &gt; src &gt; GridManip.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef GRIDMANIP_H\n#define GRIDMANIP_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Util_CPU.h\"\n#include \"Forcing.h\"\n#include \"Arrays.h\"\n#include \"MemManagement.h\"\n\ntemplate &lt;class T, class F&gt; void CopyArrayBUQ(Param XParam, BlockP&lt;F&gt; XBlock, T* source, T*&amp; dest);\ntemplate &lt;class T&gt; void CopyArrayBUQ(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; source, EvolvingP&lt;T&gt;&amp; dest);\ntemplate &lt;class T&gt; void CopyArrayBUQ(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; source, EvolvingP_M&lt;T&gt;&amp; dest);\ntemplate &lt;class T, class F&gt; void InitArrayBUQ(Param XParam, BlockP&lt;F&gt; XBlock, T initval, T*&amp; Arr);\ntemplate &lt;class T, class F&gt; void InitBlkBUQ(Param XParam, BlockP&lt;F&gt; XBlock, T initval, T*&amp; Arr);\ntemplate &lt;class T&gt;  void setedges(Param XParam, BlockP&lt;T&gt; XBlock, T*&amp; zb);\n\n\ntemplate &lt;class T&gt; void interp2BUQ(Param XParam, BlockP&lt;T&gt; XBlock, std::vector&lt;StaticForcingP&lt;float&gt;&gt; forcing, T* z);\ntemplate &lt;class T, class F&gt; void interp2BUQ(Param XParam, BlockP&lt;T&gt; XBlock, F forcing, T*&amp; z);\ntemplate &lt;class T, class F&gt; T interp2BUQ(T x, T y, F forcing);\ntemplate &lt;class T, class F&gt; T interp2BUQ(T x, T y, T dx, F forcing);\n\ntemplate &lt;class T, class F&gt; void InterpstepCPU(int nx, int ny, int hdstep, F totaltime, F hddt, T*&amp; Ux, T* Uo, T* Un);\n//template &lt;class T&gt; __global__ void InterpstepGPU(int nx, int ny, int hdstp, T totaltime, T hddt, T* Ux, T* Uo, T* Un);\ntemplate &lt;class T&gt; __global__ void InterpstepGPU(int nx, int ny, T totaltime, T beforetime, T aftertime, T* Ux, T* Uo, T* Un);\n\ntemplate &lt;class T&gt; void Copy2CartCPU(int nx, int ny, T* dest, T* src);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_halo_8cu/","title":"File Halo.cu","text":""},{"location":"BGFlood/_halo_8cu/#file-halocu","title":"File Halo.cu","text":"<p>FileList &gt; src &gt; Halo.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Halo.h\"</code></li> </ul>"},{"location":"BGFlood/_halo_8cu/#public-functions","title":"Public Functions","text":"Type Name void HaloFluxCPUBT (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for applying halo flux correction on the left and right boundaries of all active blocks on GPU. void HaloFluxCPULR (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z) CPU function for applying halo flux correction on the left and right boundaries. __global__ void HaloFluxGPUBT (Param XParam, BlockP&lt; T &gt; XBlock, T * z) GPU kernel for applying halo flux correction on the top and bottom boundaries of all active blocks. __global__ void HaloFluxGPUBTnew (Param XParam, BlockP&lt; T &gt; XBlock, T * z) GPU kernel for applying halo flux correction on the top and bottom boundaries of all active blocks. __global__ void HaloFluxGPULR (Param XParam, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for applying halo flux correction on the left and right boundaries of all active blocks. __global__ void HaloFluxGPULRnew (Param XParam, BlockP&lt; T &gt; XBlock, T * z) GPU kernel for applying halo flux correction on the left and right boundaries of all active blocks. void RecalculateZs (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) Recalculate water surface after recalculating the values on the halo on the CPU. template void RecalculateZs&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template void RecalculateZs&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  __global__ void RecalculateZsGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  template __global__ void RecalculateZsGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template __global__ void RecalculateZsGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  void Recalculatehh (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) Recalculate water depth after recalculating the values on the halo on the CPU. template void Recalculatehh&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template void Recalculatehh&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  void bndmaskGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, FluxP&lt; T &gt; Flux) Wrapping function for applying boundary masks to flux variables on GPU. template void bndmaskGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, FluxP&lt; double &gt; Flux)  template void bndmaskGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, FluxP&lt; float &gt; Flux)  void fillBot (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z) Function to fill the bottom halo region of a block, handling various neighbor configurations. __global__ void fillBot (int halowidth, int * active, int * level, int * botleft, int * botright, int * topleft, int * lefttop, int * righttop, T * a) CUDA kernel to fill the bottom halo region of blocks in parallel, handling various neighbor configurations. template __global__ void fillBot&lt; double &gt; (int halowidth, int * active, int * level, int * botleft, int * botright, int * topleft, int * lefttop, int * righttop, double * a)  template __global__ void fillBot&lt; float &gt; (int halowidth, int * active, int * level, int * botleft, int * botright, int * topleft, int * lefttop, int * righttop, float * a)  void fillBotFlux (Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z) Fills the bottom halo region of a block, handling various neighbor configurations. __global__ void fillBotnew (int halowidth, int nblk, int * active, int * level, int * botleft, int * botright, int * topleft, int * lefttop, int * righttop, T * a) CUDA kernel to fill the bottom halo region of blocks in parallel for new refinement, handling various neighbor configurations, new version. template __global__ void fillBotnew&lt; double &gt; (int halowidth, int nblk, int * active, int * level, int * botleft, int * botright, int * topleft, int * lefttop, int * righttop, double * a)  template __global__ void fillBotnew&lt; float &gt; (int halowidth, int nblk, int * active, int * level, int * botleft, int * botright, int * topleft, int * lefttop, int * righttop, float * a)  void fillCorners (Param XParam, BlockP&lt; T &gt; XBlock, T *&amp; z) Function to fill the corner halo regions for all active blocks. void fillCorners (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; &amp; Xev) Function to fill the corner halo regions for all active blocks and all evolving variables. void fillCorners (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z) Function to fill the corner halo regions for a specific block, handling various neighbor configurations. template void fillCorners&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double *&amp; z)  template void fillCorners&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; &amp; Xev)  template void fillCorners&lt; double &gt; (Param XParam, int ib, BlockP&lt; double &gt; XBlock, double *&amp; z)  template void fillCorners&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float *&amp; z)  template void fillCorners&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; &amp; Xev)  template void fillCorners&lt; float &gt; (Param XParam, int ib, BlockP&lt; float &gt; XBlock, float *&amp; z)  __global__ void fillCornersGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z) CUDA kernel to fill the corner halo regions for all active blocks in parallel, handling various neighbor configurations. template __global__ void fillCornersGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z)  template __global__ void fillCornersGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z)  void fillHalo (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) Wrapping function for calculating halos for each block and each variable on CPU. void fillHalo (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev) Wrapping function for calculating halos for each block and each variable on CPU. void fillHalo (Param XParam, BlockP&lt; T &gt; XBlock, GradientsP&lt; T &gt; Grad) Wrapping function for calculating halos for each block and each variable on CPU. void fillHalo (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux) Wrapping function for calculating flux halos for each block and each variable on CPU. template void fillHalo&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template void fillHalo&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev)  template void fillHalo&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, GradientsP&lt; double &gt; Grad)  template void fillHalo&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, FluxP&lt; double &gt; Flux)  template void fillHalo&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  template void fillHalo&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev)  template void fillHalo&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, GradientsP&lt; float &gt; Grad)  template void fillHalo&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, FluxP&lt; float &gt; Flux)  void fillHaloBTFluxC (Param XParam, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating flux for halos for each block of a single variable on GPU. template void fillHaloBTFluxC&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z)  template void fillHaloBTFluxC&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z)  void fillHaloBotTopGPU (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z) Wrapping function for calculating flux for halos for each block of a single variable on GPU. template void fillHaloBotTopGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double * z)  template void fillHaloBotTopGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float * z)  void fillHaloBotTopGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z) Wrapping function for calculating flux for halos for each block of a single variable on GPU. New version. template void fillHaloBotTopGPUnew&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double * z)  template void fillHaloBotTopGPUnew&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float * z)  void fillHaloC (Param XParam, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating halos for each block of a single variable on CPU. template void fillHaloC&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z)  template void fillHaloC&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z)  void fillHaloD (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating halos on CPU on every side of a block of a single variable. template void fillHaloD&lt; double &gt; (Param XParam, int ib, BlockP&lt; double &gt; XBlock, double * z)  template void fillHaloD&lt; float &gt; (Param XParam, int ib, BlockP&lt; float &gt; XBlock, float * z)  void fillHaloF (Param XParam, bool doProlongation, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating flux in the halos for a block and a single variable on CPU. template void fillHaloF&lt; double &gt; (Param XParam, bool doProlongation, BlockP&lt; double &gt; XBlock, double * z)  template void fillHaloF&lt; float &gt; (Param XParam, bool doProlongation, BlockP&lt; float &gt; XBlock, float * z)  void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z) Wrapping function for calculating halos for each block of a single variable on GPU. void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating halos for each block of a single variable on GPU. void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev) Wrapping function for calculating halos for each block and each variable on GPU. void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) Wrapping function for calculating halos for each block and each variable on GPU. void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, GradientsP&lt; T &gt; Grad) Wrapping function for calculating halos for each block and each variable on GPU. void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux) Wrapping function for calculating flux halos for each block and each variable on GPU. template void fillHaloGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double * z)  template void fillHaloGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z)  template void fillHaloGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev)  template void fillHaloGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; Xev, double * zb)  template void fillHaloGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, GradientsP&lt; double &gt; Grad)  template void fillHaloGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, FluxP&lt; double &gt; Flux)  template void fillHaloGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float * z)  template void fillHaloGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z)  template void fillHaloGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev)  template void fillHaloGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; Xev, float * zb)  template void fillHaloGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, GradientsP&lt; float &gt; Grad)  template void fillHaloGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, FluxP&lt; float &gt; Flux)  void fillHaloGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z) Wrapping function for calculating halos for each block of a single variable on GPU. New version. template void fillHaloGPUnew&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double * z)  template void fillHaloGPUnew&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float * z)  void fillHaloLRFluxC (Param XParam, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating flux for halos for each block of a single variable on GPU. template void fillHaloLRFluxC&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z)  template void fillHaloLRFluxC&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z)  void fillHaloLeftRightGPU (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z) Wrapping function for calculating for halos for each block of a single variable on GPU. template void fillHaloLeftRightGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double * z)  template void fillHaloLeftRightGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float * z)  void fillHaloLeftRightGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z) Wrapping function for calculating for halos for each block of a single variable on GPU. New version. template void fillHaloLeftRightGPUnew&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double * z)  template void fillHaloLeftRightGPUnew&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float * z)  void fillHaloTopRightC (Param XParam, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating flux for halos for each block of a single variable on GPU. template void fillHaloTopRightC&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z)  template void fillHaloTopRightC&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z)  void fillHaloTopRightGPU (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z) Wrapping function for calculating flux for halos for each block of a single variable on GPU. template void fillHaloTopRightGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, cudaStream_t stream, double * z)  template void fillHaloTopRightGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, cudaStream_t stream, float * z)  void fillLeft (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z) Applying halo flux correction on the left boundaries of all active blocks on GPU. __global__ void fillLeft (int halowidth, int * active, int * level, int * leftbot, int * lefttop, int * rightbot, int * botright, int * topright, T * a) GPU kernel for applying halo flux correction on the left boundaries of all active blocks. template __global__ void fillLeft&lt; double &gt; (int halowidth, int * active, int * level, int * leftbot, int * lefttop, int * rightbot, int * botright, int * topright, double * a)  template __global__ void fillLeft&lt; float &gt; (int halowidth, int * active, int * level, int * leftbot, int * lefttop, int * rightbot, int * botright, int * topright, float * a)  void fillLeftFlux (Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z) CPU function for applying halo flux correction on the left boundaries of a specific block. __global__ void fillLeftnew (int halowidth, int nblk, int * active, int * level, int * leftbot, int * lefttop, int * rightbot, int * botright, int * topright, T * a) New way of filling the left halo 2 blocks at a time to maximize GPU occupancy. template __global__ void fillLeftnew&lt; double &gt; (int halowidth, int nblk, int * active, int * level, int * leftbot, int * lefttop, int * rightbot, int * botright, int * topright, double * a)  template __global__ void fillLeftnew&lt; float &gt; (int halowidth, int nblk, int * active, int * level, int * leftbot, int * lefttop, int * rightbot, int * botright, int * topright, float * a)  void fillRight (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z) Fills the right halo region of a block. __global__ void fillRight (int halowidth, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, T * a) CUDA kernel to fill the right halo region of blocks in parallel. template __global__ void fillRight&lt; double &gt; (int halowidth, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, double * a)  template __global__ void fillRight&lt; float &gt; (int halowidth, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, float * a)  void fillRightFlux (Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z) Function to fill the right halo region of a block, handling various neighbor configurations. __global__ void fillRightFlux (int halowidth, bool doProlongation, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, T * a) CUDA kernel to fill the right halo region of blocks in parallel for flux variables, handling various neighbor configurations. template void fillRightFlux&lt; double &gt; (Param XParam, bool doProlongation, int ib, BlockP&lt; double &gt; XBlock, double *&amp; z)  template __global__ void fillRightFlux&lt; double &gt; (int halowidth, bool doProlongation, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, double * a)  template void fillRightFlux&lt; float &gt; (Param XParam, bool doProlongation, int ib, BlockP&lt; float &gt; XBlock, float *&amp; z)  template __global__ void fillRightFlux&lt; float &gt; (int halowidth, bool doProlongation, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, float * a)  __global__ void fillRightnew (int halowidth, int nblk, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, T * a) CUDA kernel to fill the right halo region of blocks in parallel (new version). template __global__ void fillRightnew&lt; double &gt; (int halowidth, int nblk, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, double * a)  template __global__ void fillRightnew&lt; float &gt; (int halowidth, int nblk, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, float * a)  void fillTop (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z) Fills the top halo region of a block, handling various neighbor configurations. __global__ void fillTop (int halowidth, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, T * a) CUDA kernel to fill the top halo region of blocks in parallel for new refinement, handling various neighbor configurations, new version. template __global__ void fillTop&lt; double &gt; (int halowidth, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, double * a)  template __global__ void fillTop&lt; float &gt; (int halowidth, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, float * a)  void fillTopFlux (Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z) Function to fill the top halo region of a block for new refinement, handling various neighbor configurations. __global__ void fillTopFlux (int halowidth, bool doProlongation, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, T * a) CUDA kernel to fill the top halo region of blocks in parallel for new refinement, handling various neighbor configurations, new version. template void fillTopFlux&lt; double &gt; (Param XParam, bool doProlongation, int ib, BlockP&lt; double &gt; XBlock, double *&amp; z)  template __global__ void fillTopFlux&lt; double &gt; (int halowidth, bool doProlongation, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, double * a)  template void fillTopFlux&lt; float &gt; (Param XParam, bool doProlongation, int ib, BlockP&lt; float &gt; XBlock, float *&amp; z)  template __global__ void fillTopFlux&lt; float &gt; (int halowidth, bool doProlongation, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, float * a)  __global__ void fillTopnew (int halowidth, int nblk, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, T * a)  template __global__ void fillTopnew&lt; double &gt; (int halowidth, int nblk, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, double * a)  template __global__ void fillTopnew&lt; float &gt; (int halowidth, int nblk, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, float * a)  void refine_linear (Param XParam, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy) Wrapping function for refining all sides of active blocks using linear reconstruction. template void refine_linear&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template void refine_linear&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  void refine_linearGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy) Wrapping function for refining all sides of active blocks using linear reconstruction on GPU. template void refine_linearGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template void refine_linearGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  void refine_linear_Bot (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy) Refine a block on the bottom side using linear reconstruction. template void refine_linear_Bot&lt; double &gt; (Param XParam, int ib, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template void refine_linear_Bot&lt; float &gt; (Param XParam, int ib, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  __global__ void refine_linear_BotGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy) GPU kernel to refine a block on the bottom side using linear reconstruction. template __global__ void refine_linear_BotGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template __global__ void refine_linear_BotGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  void refine_linear_Left (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy) Refine a block on the left side using linear reconstruction. template void refine_linear_Left&lt; double &gt; (Param XParam, int ib, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template void refine_linear_Left&lt; float &gt; (Param XParam, int ib, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  __global__ void refine_linear_LeftGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy) GPU kernel to refine a block on the left side using linear reconstruction. template __global__ void refine_linear_LeftGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template __global__ void refine_linear_LeftGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  void refine_linear_Right (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy) Refine a block on the right side using linear reconstruction. template void refine_linear_Right&lt; double &gt; (Param XParam, int ib, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template void refine_linear_Right&lt; float &gt; (Param XParam, int ib, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  __global__ void refine_linear_RightGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy) GPU kernel to refine a block on the right side using linear reconstruction. template __global__ void refine_linear_RightGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template __global__ void refine_linear_RightGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  void refine_linear_Top (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy) Refine a block on the top side using linear reconstruction. template void refine_linear_Top&lt; double &gt; (Param XParam, int ib, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template void refine_linear_Top&lt; float &gt; (Param XParam, int ib, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)  __global__ void refine_linear_TopGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy) GPU kernel to refine a block on the top side using linear reconstruction. template __global__ void refine_linear_TopGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z, double * dzdx, double * dzdy)  template __global__ void refine_linear_TopGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z, float * dzdx, float * dzdy)"},{"location":"BGFlood/_halo_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_halo_8cu/#function-halofluxcpubt","title":"function HaloFluxCPUBT","text":"<p>Wrapping function for applying halo flux correction on the left and right boundaries of all active blocks on GPU. </p><pre><code>template&lt;class T&gt;\nvoid HaloFluxCPUBT (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li> <p><code>XParam</code> The model parameters </p> </li> <li> <p><code>XBlock</code> The block structure containing the block information </p> </li> <li><code>z</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-halofluxcpulr","title":"function HaloFluxCPULR","text":"<p>CPU function for applying halo flux correction on the left and right boundaries. </p><pre><code>template&lt;class T&gt;\nvoid HaloFluxCPULR (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>ib</code> The index of the block </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-halofluxgpubt","title":"function HaloFluxGPUBT","text":"<p>GPU kernel for applying halo flux correction on the top and bottom boundaries of all active blocks. </p><pre><code>template&lt;class T&gt;\n__global__ void HaloFluxGPUBT (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-halofluxgpubtnew","title":"function HaloFluxGPUBTnew","text":"<p>GPU kernel for applying halo flux correction on the top and bottom boundaries of all active blocks. </p><pre><code>template&lt;class T&gt;\n__global__ void HaloFluxGPUBTnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-halofluxgpulr","title":"function HaloFluxGPULR","text":"<p>Wrapping function for applying halo flux correction on the left and right boundaries of all active blocks. </p><pre><code>template&lt;class T&gt;\n__global__ void HaloFluxGPULR (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-halofluxgpulrnew","title":"function HaloFluxGPULRnew","text":"<p>GPU kernel for applying halo flux correction on the left and right boundaries of all active blocks. </p><pre><code>template&lt;class T&gt;\n__global__ void HaloFluxGPULRnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-recalculatezs","title":"function RecalculateZs","text":"<p>Recalculate water surface after recalculating the values on the halo on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid RecalculateZs (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre> <p>Recalculate water surface after recalculating the values on the halo on the GPU.</p> <p>!</p>"},{"location":"BGFlood/_halo_8cu/#description","title":"Description","text":"<p>Recalculate water surface after recalculating the values on the halo on the CPU. zb (bottom elevation) on each halo is calculated at the start of the loop or as part of the initial condition. When conserve-elevation is not required, only h is recalculated on the halo at ever 1/2 steps.   zs then needs to be recalculated to obtain a mass-conservative solution (if zs is conserved then mass conservation is not garanteed)</p> <p>Warning:</p> <p>This function calculate zs everywhere in the block... this is a bit unecessary. Instead it should recalculate only where there is a prolongation or a restiction</p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Xev</code> The evolving structure containing the evolving variables </li> <li><code>zb</code> The bottom elevation variable </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double)</li> </ul> <p>!</p>"},{"location":"BGFlood/_halo_8cu/#description_1","title":"Description","text":"<p>Recalculate water surface after recalculating the values on the halo on the CPU. zb (bottom elevation) on each halo is calculated at the start of the loop or as part of the initial condition. When conserve-elevation is not required, only h is recalculated on the halo at ever 1/2 steps. zs then needs to be recalculated to obtain a mass-conservative solution (if zs is conserved then mass conservation is not garanteed)</p> <p>Warning:</p> <p>This function calculate zs everywhere in the block... this is a bit unecessary. Instead it should recalculate only where there is a prolongation or a restiction </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Xev</code> The evolving structure containing the evolving variables </li> <li><code>zb</code> The bottom elevation variable </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-recalculatezs-double","title":"function RecalculateZs&lt; double &gt;","text":"<pre><code>template void RecalculateZs&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-recalculatezs-float","title":"function RecalculateZs&lt; float &gt;","text":"<pre><code>template void RecalculateZs&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-recalculatezsgpu","title":"function RecalculateZsGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void RecalculateZsGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-recalculatezsgpu-double","title":"function RecalculateZsGPU&lt; double &gt;","text":"<pre><code>template __global__ void RecalculateZsGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-recalculatezsgpu-float","title":"function RecalculateZsGPU&lt; float &gt;","text":"<pre><code>template __global__ void RecalculateZsGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-recalculatehh","title":"function Recalculatehh","text":"<p>Recalculate water depth after recalculating the values on the halo on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid Recalculatehh (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#description_2","title":"Description","text":"<p>Recalculate water depth after recalculating the values on the halo on the CPU. zb (bottom elevation) on each halo is calculated at the start of the loop or as part of the initial condition. When conserve-elevation is not required, only h is recalculated on the halo at ever 1/2 steps. zs then needs to be recalculated to obtain a mass-conservative solution (if zs is conserved then mass conservation is not garanteed) </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Xev</code> The evolving structure containing the evolving variables </li> <li><code>zb</code> The bottom elevation variable </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-recalculatehh-double","title":"function Recalculatehh&lt; double &gt;","text":"<pre><code>template void Recalculatehh&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-recalculatehh-float","title":"function Recalculatehh&lt; float &gt;","text":"<pre><code>template void Recalculatehh&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-bndmaskgpu","title":"function bndmaskGPU","text":"<p>Wrapping function for applying boundary masks to flux variables on GPU. </p><pre><code>template&lt;class T&gt;\nvoid bndmaskGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Xev</code> The evolving structure containing the evolving variables </li> <li><code>Flux</code> The flux structure containing the flux variables </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-bndmaskgpu-double","title":"function bndmaskGPU&lt; double &gt;","text":"<pre><code>template void bndmaskGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    FluxP &lt; double &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-bndmaskgpu-float","title":"function bndmaskGPU&lt; float &gt;","text":"<pre><code>template void bndmaskGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    FluxP &lt; float &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillbot","title":"function fillBot","text":"<p>Function to fill the bottom halo region of a block, handling various neighbor configurations. </p><pre><code>template&lt;class T&gt;\nvoid fillBot (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameters of the grid and blocks </li> <li><code>ib</code> The index of the current block </li> <li><code>XBlock</code> The block structure containing neighbor information </li> <li><code>z</code> The variable to be refined </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillbot_1","title":"function fillBot","text":"<p>CUDA kernel to fill the bottom halo region of blocks in parallel, handling various neighbor configurations. </p><pre><code>template&lt;class T&gt;\n__global__ void fillBot (\n    int halowidth,\n    int * active,\n    int * level,\n    int * botleft,\n    int * botright,\n    int * topleft,\n    int * lefttop,\n    int * righttop,\n    T * a\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>botleft</code> The array of bottom left neighbor block indices </li> <li><code>botright</code> The array of bottom right neighbor block indices </li> <li><code>topleft</code> The array of top left neighbor block indices </li> <li><code>lefttop</code> The array of left top neighbor block indices </li> <li><code>righttop</code> The array of right top neighbor block indices </li> <li><code>a</code> The variable to be refined </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillbot-double","title":"function fillBot&lt; double &gt;","text":"<pre><code>template __global__ void fillBot&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    int * botleft,\n    int * botright,\n    int * topleft,\n    int * lefttop,\n    int * righttop,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillbot-float","title":"function fillBot&lt; float &gt;","text":"<pre><code>template __global__ void fillBot&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    int * botleft,\n    int * botright,\n    int * topleft,\n    int * lefttop,\n    int * righttop,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillbotflux","title":"function fillBotFlux","text":"<p>Fills the bottom halo region of a block, handling various neighbor configurations. </p><pre><code>template&lt;class T&gt;\nvoid fillBotFlux (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameters of the grid/block structure </li> <li><code>doProlongation</code> Flag indicating whether to perform prolongation </li> <li><code>ib</code> The index of the current block </li> <li><code>XBlock</code> The block structure containing neighbor information </li> <li><code>z</code> The variable to be refined </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillbotnew","title":"function fillBotnew","text":"<p>CUDA kernel to fill the bottom halo region of blocks in parallel for new refinement, handling various neighbor configurations, new version. </p><pre><code>template&lt;class T&gt;\n__global__ void fillBotnew (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * botleft,\n    int * botright,\n    int * topleft,\n    int * lefttop,\n    int * righttop,\n    T * a\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>nblk</code> The number of active blocks </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>botleft</code> The array of bottom left neighbor block indices </li> <li><code>botright</code> The array of bottom right neighbor block indices </li> <li><code>topleft</code> The array of top left neighbor block indices </li> <li><code>lefttop</code> The array of left top neighbor block indices </li> <li><code>righttop</code> The array of right top neighbor block indices </li> <li><code>a</code> The variable to be refined </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillbotnew-double","title":"function fillBotnew&lt; double &gt;","text":"<pre><code>template __global__ void fillBotnew&lt; double &gt; (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * botleft,\n    int * botright,\n    int * topleft,\n    int * lefttop,\n    int * righttop,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillbotnew-float","title":"function fillBotnew&lt; float &gt;","text":"<pre><code>template __global__ void fillBotnew&lt; float &gt; (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * botleft,\n    int * botright,\n    int * topleft,\n    int * lefttop,\n    int * righttop,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillcorners","title":"function fillCorners","text":"<p>Function to fill the corner halo regions for all active blocks. </p><pre><code>template&lt;class T&gt;\nvoid fillCorners (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameters of the grid and blocks </li> <li><code>XBlock</code> The structure containing block neighbor information </li> <li><code>z</code> The variable to be processed </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillcorners_1","title":"function fillCorners","text":"<p>Function to fill the corner halo regions for all active blocks and all evolving variables. </p><pre><code>template&lt;class T&gt;\nvoid fillCorners (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; &amp; Xev\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameters of the grid and blocks </li> <li><code>XBlock</code> The structure containing block neighbor information </li> <li><code>Xev</code> The structure containing evolving variables </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type of the variables (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillcorners_2","title":"function fillCorners","text":"<p>Function to fill the corner halo regions for a specific block, handling various neighbor configurations. </p><pre><code>template&lt;class T&gt;\nvoid fillCorners (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameters of the grid and blocks </li> <li><code>ib</code> The index of the block to be processed </li> <li><code>XBlock</code> The structure containing block neighbor information </li> <li><code>z</code> The variable to be processed </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillcorners-double","title":"function fillCorners&lt; double &gt;","text":"<pre><code>template void fillCorners&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillcorners-double_1","title":"function fillCorners&lt; double &gt;","text":"<pre><code>template void fillCorners&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; &amp; Xev\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillcorners-double_2","title":"function fillCorners&lt; double &gt;","text":"<pre><code>template void fillCorners&lt; double &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; double &gt; XBlock,\n    double *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillcorners-float","title":"function fillCorners&lt; float &gt;","text":"<pre><code>template void fillCorners&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillcorners-float_1","title":"function fillCorners&lt; float &gt;","text":"<pre><code>template void fillCorners&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; &amp; Xev\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillcorners-float_2","title":"function fillCorners&lt; float &gt;","text":"<pre><code>template void fillCorners&lt; float &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; float &gt; XBlock,\n    float *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillcornersgpu","title":"function fillCornersGPU","text":"<p>CUDA kernel to fill the corner halo regions for all active blocks in parallel, handling various neighbor configurations. </p><pre><code>template&lt;class T&gt;\n__global__ void fillCornersGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameters of the grid and blocks </li> <li><code>XBlock</code> The structure containing block neighbor information </li> <li><code>z</code> The variable to be processed </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillcornersgpu-double","title":"function fillCornersGPU&lt; double &gt;","text":"<pre><code>template __global__ void fillCornersGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillcornersgpu-float","title":"function fillCornersGPU&lt; float &gt;","text":"<pre><code>template __global__ void fillCornersGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalo","title":"function fillHalo","text":"<p>Wrapping function for calculating halos for each block and each variable on CPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#description_3","title":"Description","text":"<p>This function is a wraping fuction of the halo functions on CPU. It is called from the main Halo function. It uses multithreading to calculate the halos of the 4 variables in parallel. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Xev</code> The evolving structure containing the evolving variables </li> <li><code>zb</code> The bottom elevation variable </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillhalo_1","title":"function fillHalo","text":"<p>Wrapping function for calculating halos for each block and each variable on CPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#description_4","title":"Description","text":"<p>This function is a wraping fuction of the halo functions on CPU. It is called from the main Halo function. It uses multithreading to calculate the halos of the 4 variables in parallel. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Xev</code> The evolving structure containing the evolving variables </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillhalo_2","title":"function fillHalo","text":"<p>Wrapping function for calculating halos for each block and each variable on CPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    GradientsP &lt; T &gt; Grad\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#description_5","title":"Description","text":"<p>This function is a wrapping function of the halo functions on CPU. It is called from the main Halo function. It uses multithreading to calculate the halos of the 4 variables in parallel. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Grad</code> The gradients structure containing the gradients </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillhalo_3","title":"function fillHalo","text":"<p>Wrapping function for calculating flux halos for each block and each variable on CPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Flux</code> The flux structure containing the flux variables </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillhalo-double","title":"function fillHalo&lt; double &gt;","text":"<pre><code>template void fillHalo&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalo-double_1","title":"function fillHalo&lt; double &gt;","text":"<pre><code>template void fillHalo&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalo-double_2","title":"function fillHalo&lt; double &gt;","text":"<pre><code>template void fillHalo&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    GradientsP &lt; double &gt; Grad\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalo-double_3","title":"function fillHalo&lt; double &gt;","text":"<pre><code>template void fillHalo&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    FluxP &lt; double &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalo-float","title":"function fillHalo&lt; float &gt;","text":"<pre><code>template void fillHalo&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalo-float_1","title":"function fillHalo&lt; float &gt;","text":"<pre><code>template void fillHalo&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalo-float_2","title":"function fillHalo&lt; float &gt;","text":"<pre><code>template void fillHalo&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    GradientsP &lt; float &gt; Grad\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalo-float_3","title":"function fillHalo&lt; float &gt;","text":"<pre><code>template void fillHalo&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    FluxP &lt; float &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalobtfluxc","title":"function fillHaloBTFluxC","text":"<p>Wrapping function for calculating flux for halos for each block of a single variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloBTFluxC (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to work on </li> </ul> <p>Note:</p> <p>For flux term and actually most terms, only top and right neighbours are needed! </p>"},{"location":"BGFlood/_halo_8cu/#function-fillhalobtfluxc-double","title":"function fillHaloBTFluxC&lt; double &gt;","text":"<pre><code>template void fillHaloBTFluxC&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalobtfluxc-float","title":"function fillHaloBTFluxC&lt; float &gt;","text":"<pre><code>template void fillHaloBTFluxC&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalobottopgpu","title":"function fillHaloBotTopGPU","text":"<p>Wrapping function for calculating flux for halos for each block of a single variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloBotTopGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#description_6","title":"Description","text":"<p>This function is a wraping function of the halo flux functions on GPU. It is called from the main Halo GPU function. The present imnplementation is naive and slow one that calls the rather complex fillLeft type functions </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>stream</code> The cuda stream to use </li> <li><code>z</code> The variable to work on </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillhalobottopgpu-double","title":"function fillHaloBotTopGPU&lt; double &gt;","text":"<pre><code>template void fillHaloBotTopGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    cudaStream_t stream,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalobottopgpu-float","title":"function fillHaloBotTopGPU&lt; float &gt;","text":"<pre><code>template void fillHaloBotTopGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    cudaStream_t stream,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalobottopgpunew","title":"function fillHaloBotTopGPUnew","text":"<p>Wrapping function for calculating flux for halos for each block of a single variable on GPU. New version. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloBotTopGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#description_7","title":"Description","text":"<p>This function is a wraping function of the halo flux functions on GPU. It is called from the main Halo GPU function. The present imnplementation is naive and slow one that calls the rather complex fillLeft type functions </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>stream</code> The cuda stream to use </li> <li><code>z</code> The variable to work on </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillhalobottopgpunew-double","title":"function fillHaloBotTopGPUnew&lt; double &gt;","text":"<pre><code>template void fillHaloBotTopGPUnew&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    cudaStream_t stream,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalobottopgpunew-float","title":"function fillHaloBotTopGPUnew&lt; float &gt;","text":"<pre><code>template void fillHaloBotTopGPUnew&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    cudaStream_t stream,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhaloc","title":"function fillHaloC","text":"<p>Wrapping function for calculating halos for each block of a single variable on CPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloC (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>!</p>"},{"location":"BGFlood/_halo_8cu/#description_8","title":"Description","text":"<p>This function is a wraping fuction of the halo functions on CPU. It is called from the main Halo CPU function. This is layer 2 of 3 wrap so the candy doesn't stick too much. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to work on </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillhaloc-double","title":"function fillHaloC&lt; double &gt;","text":"<pre><code>template void fillHaloC&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhaloc-float","title":"function fillHaloC&lt; float &gt;","text":"<pre><code>template void fillHaloC&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalod","title":"function fillHaloD","text":"<p>Wrapping function for calculating halos on CPU on every side of a block of a single variable. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloD (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>!</p>"},{"location":"BGFlood/_halo_8cu/#description_9","title":"Description","text":"<p>This fuction is a wraping fuction of the halo functions for CPU. It is called from another wraping function to keep things clean. In a sense this is the third (and last) layer of wrapping</p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>ib</code> The block index to work on </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to work on </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillhalod-double","title":"function fillHaloD&lt; double &gt;","text":"<pre><code>template void fillHaloD&lt; double &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalod-float","title":"function fillHaloD&lt; float &gt;","text":"<pre><code>template void fillHaloD&lt; float &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalof","title":"function fillHaloF","text":"<p>Wrapping function for calculating flux in the halos for a block and a single variable on CPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloF (\n    Param XParam,\n    bool doProlongation,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>! </p> <p>Deprecated</p> <p>This function is was never sucessful and will never be used. It is fundamentally flawed because is doesn't preserve the balance of fluxes on the restiction interface. It should be deleted soon.</p>"},{"location":"BGFlood/_halo_8cu/#function-fillhalof-double","title":"function fillHaloF&lt; double &gt;","text":"<pre><code>template void fillHaloF&lt; double &gt; (\n    Param XParam,\n    bool doProlongation,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalof-float","title":"function fillHaloF&lt; float &gt;","text":"<pre><code>template void fillHaloF&lt; float &gt; (\n    Param XParam,\n    bool doProlongation,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu","title":"function fillHaloGPU","text":"<p>Wrapping function for calculating halos for each block of a single variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre> <p>!</p>"},{"location":"BGFlood/_halo_8cu/#description_10","title":"Description","text":"<p>This function is a wraping fuction of the halo functions on GPU. It is called from the main Halo GPU function. The present imnplementation is naive and slow one that calls the rather complex fillLeft type functions </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>stream</code> The cuda stream to use </li> <li><code>z</code> The variable to work on </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu_1","title":"function fillHaloGPU","text":"<p>Wrapping function for calculating halos for each block of a single variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>Deprecated</p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>stream</code> The cuda stream to use </li> <li><code>z</code> The variable to work on </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu_2","title":"function fillHaloGPU","text":"<p>Wrapping function for calculating halos for each block and each variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Xev</code> The evolving structure containing the evolving variables </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu_3","title":"function fillHaloGPU","text":"<p>Wrapping function for calculating halos for each block and each variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#description_11","title":"Description","text":"<p>This function is a wraping fuction of the halo functions on GPU. It is called from the main Halo GPU function. It uses multiple cuda streams to calculate the halos of the 4 variables in parallel. After filling the halos, it applies either the elevation conservation or wet-dry fix if enabled in parameters. Finally, it recalculates the surface elevation zs based on the updated water depth h and bottom elevation zb. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Xev</code> The evolving structure containing the evolving variables </li> <li><code>zb</code> The bottom elevation variable </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu_4","title":"function fillHaloGPU","text":"<p>Wrapping function for calculating halos for each block and each variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    GradientsP &lt; T &gt; Grad\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Grad</code> The gradients structure containing the gradients </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu_5","title":"function fillHaloGPU","text":"<p>Wrapping function for calculating flux halos for each block and each variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Flux</code> The flux structure containing the flux variables </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu-double","title":"function fillHaloGPU&lt; double &gt;","text":"<pre><code>template void fillHaloGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    cudaStream_t stream,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu-double_1","title":"function fillHaloGPU&lt; double &gt;","text":"<pre><code>template void fillHaloGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu-double_2","title":"function fillHaloGPU&lt; double &gt;","text":"<pre><code>template void fillHaloGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu-double_3","title":"function fillHaloGPU&lt; double &gt;","text":"<pre><code>template void fillHaloGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; Xev,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu-double_4","title":"function fillHaloGPU&lt; double &gt;","text":"<pre><code>template void fillHaloGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    GradientsP &lt; double &gt; Grad\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu-double_5","title":"function fillHaloGPU&lt; double &gt;","text":"<pre><code>template void fillHaloGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    FluxP &lt; double &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu-float","title":"function fillHaloGPU&lt; float &gt;","text":"<pre><code>template void fillHaloGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    cudaStream_t stream,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu-float_1","title":"function fillHaloGPU&lt; float &gt;","text":"<pre><code>template void fillHaloGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu-float_2","title":"function fillHaloGPU&lt; float &gt;","text":"<pre><code>template void fillHaloGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu-float_3","title":"function fillHaloGPU&lt; float &gt;","text":"<pre><code>template void fillHaloGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; Xev,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu-float_4","title":"function fillHaloGPU&lt; float &gt;","text":"<pre><code>template void fillHaloGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    GradientsP &lt; float &gt; Grad\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpu-float_5","title":"function fillHaloGPU&lt; float &gt;","text":"<pre><code>template void fillHaloGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    FluxP &lt; float &gt; Flux\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpunew","title":"function fillHaloGPUnew","text":"<p>Wrapping function for calculating halos for each block of a single variable on GPU. New version. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>stream</code> The cuda stream to use </li> <li><code>z</code> The variable to work on </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpunew-double","title":"function fillHaloGPUnew&lt; double &gt;","text":"<pre><code>template void fillHaloGPUnew&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    cudaStream_t stream,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalogpunew-float","title":"function fillHaloGPUnew&lt; float &gt;","text":"<pre><code>template void fillHaloGPUnew&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    cudaStream_t stream,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalolrfluxc","title":"function fillHaloLRFluxC","text":"<p>Wrapping function for calculating flux for halos for each block of a single variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloLRFluxC (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to work on </li> </ul> <p>Note:</p> <p>For flux term and actually most terms, only top and right neighbours are needed! </p>"},{"location":"BGFlood/_halo_8cu/#function-fillhalolrfluxc-double","title":"function fillHaloLRFluxC&lt; double &gt;","text":"<pre><code>template void fillHaloLRFluxC&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalolrfluxc-float","title":"function fillHaloLRFluxC&lt; float &gt;","text":"<pre><code>template void fillHaloLRFluxC&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhaloleftrightgpu","title":"function fillHaloLeftRightGPU","text":"<p>Wrapping function for calculating for halos for each block of a single variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloLeftRightGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>stream</code> The cuda stream to use </li> <li><code>z</code> The variable to work on </li> </ul> <p>Note:</p> <p>For flux term and actually most terms, only top and right neighbours are needed! </p>"},{"location":"BGFlood/_halo_8cu/#function-fillhaloleftrightgpu-double","title":"function fillHaloLeftRightGPU&lt; double &gt;","text":"<pre><code>template void fillHaloLeftRightGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    cudaStream_t stream,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhaloleftrightgpu-float","title":"function fillHaloLeftRightGPU&lt; float &gt;","text":"<pre><code>template void fillHaloLeftRightGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    cudaStream_t stream,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhaloleftrightgpunew","title":"function fillHaloLeftRightGPUnew","text":"<p>Wrapping function for calculating for halos for each block of a single variable on GPU. New version. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloLeftRightGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>stream</code> The cuda stream to use </li> <li><code>z</code> The variable to work on </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillhaloleftrightgpunew-double","title":"function fillHaloLeftRightGPUnew&lt; double &gt;","text":"<pre><code>template void fillHaloLeftRightGPUnew&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    cudaStream_t stream,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhaloleftrightgpunew-float","title":"function fillHaloLeftRightGPUnew&lt; float &gt;","text":"<pre><code>template void fillHaloLeftRightGPUnew&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    cudaStream_t stream,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalotoprightc","title":"function fillHaloTopRightC","text":"<p>Wrapping function for calculating flux for halos for each block of a single variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloTopRightC (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#description_12","title":"Description","text":"<p>This function is a wraping function of the halo flux functions on GPU. It is called from the main Halo GPU function. The present imnplementation is naive and slow one that calls the rather complex fillLeft type functions </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to work on </li> </ul> <p>Note:</p> <p>For flux term and actually most terms, only top and right neighbours are needed! </p>"},{"location":"BGFlood/_halo_8cu/#function-fillhalotoprightc-double","title":"function fillHaloTopRightC&lt; double &gt;","text":"<pre><code>template void fillHaloTopRightC&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalotoprightc-float","title":"function fillHaloTopRightC&lt; float &gt;","text":"<pre><code>template void fillHaloTopRightC&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalotoprightgpu","title":"function fillHaloTopRightGPU","text":"<p>Wrapping function for calculating flux for halos for each block of a single variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloTopRightGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li> <p><code>XBlock</code> The block structure containing the block information </p> </li> <li> <p><code>stream</code> The cuda stream to use </p> </li> <li><code>z</code> The variable to work on </li> </ul> <p>Note:</p> <p>For flux term and actually most terms, only top and right neighbours are needed! </p>"},{"location":"BGFlood/_halo_8cu/#function-fillhalotoprightgpu-double","title":"function fillHaloTopRightGPU&lt; double &gt;","text":"<pre><code>template void fillHaloTopRightGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    cudaStream_t stream,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillhalotoprightgpu-float","title":"function fillHaloTopRightGPU&lt; float &gt;","text":"<pre><code>template void fillHaloTopRightGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    cudaStream_t stream,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillleft","title":"function fillLeft","text":"<p>Applying halo flux correction on the left boundaries of all active blocks on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillLeft (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>ib</code> The block index </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillleft_1","title":"function fillLeft","text":"<p>GPU kernel for applying halo flux correction on the left boundaries of all active blocks. </p><pre><code>template&lt;class T&gt;\n__global__ void fillLeft (\n    int halowidth,\n    int * active,\n    int * level,\n    int * leftbot,\n    int * lefttop,\n    int * rightbot,\n    int * botright,\n    int * topright,\n    T * a\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>leftbot</code> The array of left bottom neighbor block indices </li> <li><code>lefttop</code> The array of left top neighbor block indices </li> <li><code>rightbot</code> The array of right bottom neighbor block indices </li> <li><code>botright</code> The array of bottom right neighbor block indices </li> <li><code>topright</code> The array of top right neighbor block indices </li> <li><code>a</code> The variable to be refined </li> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillleft-double","title":"function fillLeft&lt; double &gt;","text":"<pre><code>template __global__ void fillLeft&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    int * leftbot,\n    int * lefttop,\n    int * rightbot,\n    int * botright,\n    int * topright,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillleft-float","title":"function fillLeft&lt; float &gt;","text":"<pre><code>template __global__ void fillLeft&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    int * leftbot,\n    int * lefttop,\n    int * rightbot,\n    int * botright,\n    int * topright,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillleftflux","title":"function fillLeftFlux","text":"<p>CPU function for applying halo flux correction on the left boundaries of a specific block. </p><pre><code>template&lt;class T&gt;\nvoid fillLeftFlux (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The simulation parameters </li> <li><code>doProlongation</code> Flag indicating whether to perform prolongation </li> <li><code>ib</code> The index of the block to process </li> <li><code>XBlock</code> The block structure containing neighbor information </li> <li><code>z</code> The variable to be refined </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillleftnew","title":"function fillLeftnew","text":"<p>New way of filling the left halo 2 blocks at a time to maximize GPU occupancy. </p><pre><code>template&lt;class T&gt;\n__global__ void fillLeftnew (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * leftbot,\n    int * lefttop,\n    int * rightbot,\n    int * botright,\n    int * topright,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#description_13","title":"Description","text":"<p>This fuction is a wraping fuction of the halo functions for CPU. It is called from another wraping function to keep things clean. In a sense this is the third (and last) layer of wrapping</p> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>nblk</code> The number of active blocks </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>leftbot</code> The array of left bottom neighbor block indices </li> <li><code>lefttop</code> The array of left top neighbor block indices </li> <li><code>rightbot</code> The array of right bottom neighbor block indices </li> <li><code>botright</code> The array of bottom right neighbor block indices </li> <li><code>topright</code> The array of top right neighbor block indices </li> <li><code>a</code> The variable to be refined </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillleftnew-double","title":"function fillLeftnew&lt; double &gt;","text":"<pre><code>template __global__ void fillLeftnew&lt; double &gt; (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * leftbot,\n    int * lefttop,\n    int * rightbot,\n    int * botright,\n    int * topright,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillleftnew-float","title":"function fillLeftnew&lt; float &gt;","text":"<pre><code>template __global__ void fillLeftnew&lt; float &gt; (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * leftbot,\n    int * lefttop,\n    int * rightbot,\n    int * botright,\n    int * topright,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillright","title":"function fillRight","text":"<p>Fills the right halo region of a block. </p><pre><code>template&lt;class T&gt;\nvoid fillRight (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The simulation parameters </li> <li><code>ib</code> The index of the block to process </li> <li><code>XBlock</code> The block structure containing neighbor information </li> <li><code>z</code> The variable to be refined </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillright_1","title":"function fillRight","text":"<p>CUDA kernel to fill the right halo region of blocks in parallel. </p><pre><code>template&lt;class T&gt;\n__global__ void fillRight (\n    int halowidth,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    T * a\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>rightbot</code> The array of right bottom neighbor block indices </li> <li><code>righttop</code> The array of right top neighbor block indices </li> <li><code>leftbot</code> The array of left bottom neighbor block indices </li> <li><code>botleft</code> The array of bottom left neighbor block indices </li> <li><code>topleft</code> The array of top left neighbor block indices </li> <li><code>a</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillright-double","title":"function fillRight&lt; double &gt;","text":"<pre><code>template __global__ void fillRight&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillright-float","title":"function fillRight&lt; float &gt;","text":"<pre><code>template __global__ void fillRight&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillrightflux","title":"function fillRightFlux","text":"<p>Function to fill the right halo region of a block, handling various neighbor configurations. </p><pre><code>template&lt;class T&gt;\nvoid fillRightFlux (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameters of the grid and blocks </li> <li><code>doProlongation</code> Flag indicating whether to perform prolongation </li> <li><code>ib</code> The index of the current block </li> <li><code>XBlock</code> The block structure containing neighbor information </li> <li><code>z</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillrightflux_1","title":"function fillRightFlux","text":"<p>CUDA kernel to fill the right halo region of blocks in parallel for flux variables, handling various neighbor configurations. </p><pre><code>template&lt;class T&gt;\n__global__ void fillRightFlux (\n    int halowidth,\n    bool doProlongation,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    T * a\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>doProlongation</code> Flag indicating whether to perform prolongation </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>rightbot</code> The array of right bottom neighbor block indices </li> <li><code>righttop</code> The array of right top neighbor block indices </li> <li><code>leftbot</code> The array of left bottom neighbor block indices </li> <li><code>botleft</code> The array of bottom left neighbor block indices </li> <li><code>topleft</code> The array of top left neighbor block indices </li> <li><code>a</code> The variable to be refined </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillrightflux-double","title":"function fillRightFlux&lt; double &gt;","text":"<pre><code>template void fillRightFlux&lt; double &gt; (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; double &gt; XBlock,\n    double *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillrightflux-double_1","title":"function fillRightFlux&lt; double &gt;","text":"<pre><code>template __global__ void fillRightFlux&lt; double &gt; (\n    int halowidth,\n    bool doProlongation,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillrightflux-float","title":"function fillRightFlux&lt; float &gt;","text":"<pre><code>template void fillRightFlux&lt; float &gt; (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; float &gt; XBlock,\n    float *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillrightflux-float_1","title":"function fillRightFlux&lt; float &gt;","text":"<pre><code>template __global__ void fillRightFlux&lt; float &gt; (\n    int halowidth,\n    bool doProlongation,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillrightnew","title":"function fillRightnew","text":"<p>CUDA kernel to fill the right halo region of blocks in parallel (new version). </p><pre><code>template&lt;class T&gt;\n__global__ void fillRightnew (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    T * a\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>nblk</code> The number of active blocks </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>rightbot</code> The array of right bottom neighbor block indices </li> <li><code>righttop</code> The array of right top neighbor block indices </li> <li><code>leftbot</code> The array of left bottom neighbor block indices </li> <li><code>botleft</code> The array of bottom left neighbor block indices </li> <li><code>topleft</code> The array of top left neighbor block indices </li> <li><code>a</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-fillrightnew-double","title":"function fillRightnew&lt; double &gt;","text":"<pre><code>template __global__ void fillRightnew&lt; double &gt; (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-fillrightnew-float","title":"function fillRightnew&lt; float &gt;","text":"<pre><code>template __global__ void fillRightnew&lt; float &gt; (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-filltop","title":"function fillTop","text":"<p>Fills the top halo region of a block, handling various neighbor configurations. </p><pre><code>template&lt;class T&gt;\nvoid fillTop (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameters of the grid/block structure </li> <li><code>ib</code> The index of the current block </li> <li><code>XBlock</code> The block structure containing neighbor information </li> <li><code>z</code> The variable to be refined </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-filltop_1","title":"function fillTop","text":"<p>CUDA kernel to fill the top halo region of blocks in parallel for new refinement, handling various neighbor configurations, new version. </p><pre><code>template&lt;class T&gt;\n__global__ void fillTop (\n    int halowidth,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    T * a\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>topleft</code> The array of top left neighbor block indices </li> <li><code>topright</code> The array of top right neighbor block indices </li> <li><code>botleft</code> The array of bottom left neighbor block indices </li> <li><code>leftbot</code> The array of left bottom neighbor block indices </li> <li><code>rightbot</code> The array of right bottom neighbor block indices </li> <li><code>a</code> The variable to be refined </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-filltop-double","title":"function fillTop&lt; double &gt;","text":"<pre><code>template __global__ void fillTop&lt; double &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-filltop-float","title":"function fillTop&lt; float &gt;","text":"<pre><code>template __global__ void fillTop&lt; float &gt; (\n    int halowidth,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-filltopflux","title":"function fillTopFlux","text":"<p>Function to fill the top halo region of a block for new refinement, handling various neighbor configurations. </p><pre><code>template&lt;class T&gt;\nvoid fillTopFlux (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameters of the grid and blocks </li> <li><code>doProlongation</code> Flag indicating whether to perform prolongation </li> <li><code>ib</code> The index of the block to be processed </li> <li><code>XBlock</code> The structure containing block neighbor information </li> <li><code>z</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-filltopflux_1","title":"function fillTopFlux","text":"<p>CUDA kernel to fill the top halo region of blocks in parallel for new refinement, handling various neighbor configurations, new version. </p><pre><code>template&lt;class T&gt;\n__global__ void fillTopFlux (\n    int halowidth,\n    bool doProlongation,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    T * a\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>doProlongation</code> Flag indicating whether to perform prolongation </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>topleft</code> The array of top left neighbor block indices </li> <li><code>topright</code> The array of top right neighbor block indices </li> <li><code>botleft</code> The array of bottom left neighbor block indices </li> <li><code>leftbot</code> The array of left bottom neighbor block indices </li> <li><code>rightbot</code> The array of right bottom neighbor block indices </li> <li><code>a</code> The variable to be refined </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-filltopflux-double","title":"function fillTopFlux&lt; double &gt;","text":"<pre><code>template void fillTopFlux&lt; double &gt; (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; double &gt; XBlock,\n    double *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-filltopflux-double_1","title":"function fillTopFlux&lt; double &gt;","text":"<pre><code>template __global__ void fillTopFlux&lt; double &gt; (\n    int halowidth,\n    bool doProlongation,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-filltopflux-float","title":"function fillTopFlux&lt; float &gt;","text":"<pre><code>template void fillTopFlux&lt; float &gt; (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; float &gt; XBlock,\n    float *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-filltopflux-float_1","title":"function fillTopFlux&lt; float &gt;","text":"<pre><code>template __global__ void fillTopFlux&lt; float &gt; (\n    int halowidth,\n    bool doProlongation,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-filltopnew","title":"function fillTopnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillTopnew (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-filltopnew-double","title":"function fillTopnew&lt; double &gt;","text":"<pre><code>template __global__ void fillTopnew&lt; double &gt; (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    double * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-filltopnew-float","title":"function fillTopnew&lt; float &gt;","text":"<pre><code>template __global__ void fillTopnew&lt; float &gt; (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    float * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear","title":"function refine_linear","text":"<p>Wrapping function for refining all sides of active blocks using linear reconstruction. </p><pre><code>template&lt;class T&gt;\nvoid refine_linear (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> <li><code>dzdx</code> The gradient of z in the x direction </li> <li><code>dzdy</code> The gradient of z in the y direction </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear-double","title":"function refine_linear&lt; double &gt;","text":"<pre><code>template void refine_linear&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear-float","title":"function refine_linear&lt; float &gt;","text":"<pre><code>template void refine_linear&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_lineargpu","title":"function refine_linearGPU","text":"<p>Wrapping function for refining all sides of active blocks using linear reconstruction on GPU. </p><pre><code>template&lt;class T&gt;\nvoid refine_linearGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> <li><code>dzdx</code> The gradient of z in the x direction </li> <li><code>dzdy</code> The gradient of z in the y direction </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-refine_lineargpu-double","title":"function refine_linearGPU&lt; double &gt;","text":"<pre><code>template void refine_linearGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_lineargpu-float","title":"function refine_linearGPU&lt; float &gt;","text":"<pre><code>template void refine_linearGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_bot","title":"function refine_linear_Bot","text":"<p>Refine a block on the bottom side using linear reconstruction. </p><pre><code>template&lt;class T&gt;\nvoid refine_linear_Bot (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#description_14","title":"Description","text":"<p>This function refines a block on the bottom side using linear reconstruction. It checks if the neighboring block on the bottom is at a coarser level. If so, it calculates the new values for the bottom boundary of the current block using the gradients in the x and y directions. The new values are computed based on the distance to the neighboring block and the gradients, ensuring a smooth transition between different resolution levels. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>ib</code> The index of the current block </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> <li><code>dzdx</code> The gradient of z in the x direction </li> <li><code>dzdy</code> The gradient of z in the y direction </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_bot-double","title":"function refine_linear_Bot&lt; double &gt;","text":"<pre><code>template void refine_linear_Bot&lt; double &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_bot-float","title":"function refine_linear_Bot&lt; float &gt;","text":"<pre><code>template void refine_linear_Bot&lt; float &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_botgpu","title":"function refine_linear_BotGPU","text":"<p>GPU kernel to refine a block on the bottom side using linear reconstruction. </p><pre><code>template&lt;class T&gt;\n__global__ void refine_linear_BotGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#description_15","title":"Description","text":"<p>This GPU kernel refines a block on the bottom side using linear reconstruction. It checks if the neighboring block on the bottom is at a coarser level. If so, it calculates the new values for the bottom boundary of the current block using the gradients in the x and y directions. The new values are computed based on the distance to the neighboring block and the gradients, ensuring a smooth transition between different resolution levels. Each thread processes a specific column of the block, allowing for parallel computation across multiple blocks. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> <li><code>dzdx</code> The gradient of z in the x direction </li> <li><code>dzdy</code> The gradient of z in the y direction </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_botgpu-double","title":"function refine_linear_BotGPU&lt; double &gt;","text":"<pre><code>template __global__ void refine_linear_BotGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_botgpu-float","title":"function refine_linear_BotGPU&lt; float &gt;","text":"<pre><code>template __global__ void refine_linear_BotGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_left","title":"function refine_linear_Left","text":"<p>Refine a block on the left side using linear reconstruction. </p><pre><code>template&lt;class T&gt;\nvoid refine_linear_Left (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#description_16","title":"Description","text":"<p>This function refines a block on the left side using linear reconstruction. It checks if the neighboring block on the left is at a coarser level. If so, it calculates the new values for the left boundary of the current block using the gradients in the x and y directions. The new values are computed based on the distance to the neighboring block and the gradients, ensuring a smooth transition between different resolution levels. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>ib</code> The index of the current block </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> <li><code>dzdx</code> The gradient of z in the x direction </li> <li><code>dzdy</code> The gradient of z in the y direction </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_left-double","title":"function refine_linear_Left&lt; double &gt;","text":"<pre><code>template void refine_linear_Left&lt; double &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_left-float","title":"function refine_linear_Left&lt; float &gt;","text":"<pre><code>template void refine_linear_Left&lt; float &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_leftgpu","title":"function refine_linear_LeftGPU","text":"<p>GPU kernel to refine a block on the left side using linear reconstruction. </p><pre><code>template&lt;class T&gt;\n__global__ void refine_linear_LeftGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#description_17","title":"Description","text":"<p>This GPU kernel refines a block on the left side using linear reconstruction. It checks if the neighboring block on the left is at a coarser level. If so, it calculates the new values for the left boundary of the current block using the gradients in the x and y directions. The new values are computed based on the distance to the neighboring block and the gradients, ensuring a smooth transition between different resolution levels. Each thread processes a specific row of the block, allowing for parallel computation across multiple blocks. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> <li><code>dzdx</code> The gradient of z in the x direction </li> <li><code>dzdy</code> The gradient of z in the y direction </li> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_leftgpu-double","title":"function refine_linear_LeftGPU&lt; double &gt;","text":"<pre><code>template __global__ void refine_linear_LeftGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_leftgpu-float","title":"function refine_linear_LeftGPU&lt; float &gt;","text":"<pre><code>template __global__ void refine_linear_LeftGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_right","title":"function refine_linear_Right","text":"<p>Refine a block on the right side using linear reconstruction. </p><pre><code>template&lt;class T&gt;\nvoid refine_linear_Right (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#description_18","title":"Description","text":"<p>This function refines a block on the right side using linear reconstruction. It checks if the neighboring block on the right is at a coarser level. If so, it calculates the new values for the right boundary of the current block using the gradients in the x and y directions. The new values are computed based on the distance to the neighboring block and the gradients, ensuring a smooth transition between different resolution levels. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>ib</code> The index of the current block </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> <li><code>dzdx</code> The gradient of z in the x direction </li> <li><code>dzdy</code> The gradient of z in the y direction </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_right-double","title":"function refine_linear_Right&lt; double &gt;","text":"<pre><code>template void refine_linear_Right&lt; double &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_right-float","title":"function refine_linear_Right&lt; float &gt;","text":"<pre><code>template void refine_linear_Right&lt; float &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_rightgpu","title":"function refine_linear_RightGPU","text":"<p>GPU kernel to refine a block on the right side using linear reconstruction. </p><pre><code>template&lt;class T&gt;\n__global__ void refine_linear_RightGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#description_19","title":"Description","text":"<p>This GPU kernel refines a block on the right side using linear reconstruction. It checks if the neighboring block on the right is at a coarser level. If so, it calculates the new values for the right boundary of the current block using the gradients in the x and y directions. The new values are computed based on the distance to the neighboring block and the gradients, ensuring a smooth transition between different resolution levels. Each thread processes a specific row of the block, allowing for parallel computation across multiple blocks. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> <li><code>dzdx</code> The gradient of z in the x direction </li> <li><code>dzdy</code> The gradient of z in the y direction </li> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_rightgpu-double","title":"function refine_linear_RightGPU&lt; double &gt;","text":"<pre><code>template __global__ void refine_linear_RightGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_rightgpu-float","title":"function refine_linear_RightGPU&lt; float &gt;","text":"<pre><code>template __global__ void refine_linear_RightGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_top","title":"function refine_linear_Top","text":"<p>Refine a block on the top side using linear reconstruction. </p><pre><code>template&lt;class T&gt;\nvoid refine_linear_Top (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#description_20","title":"Description","text":"<p>This function refines a block on the top side using linear reconstruction. It checks if the neighboring block on the top is at a coarser level. If so, it calculates the new values for the top boundary of the current block using the gradients in the x and y directions. The new values are computed based on the distance to the neighboring block and the gradients, ensuring a smooth transition between different resolution levels. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>ib</code> The index of the current block </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> <li><code>dzdx</code> The gradient of z in the x direction </li> <li><code>dzdy</code> The gradient of z in the y direction </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_top-double","title":"function refine_linear_Top&lt; double &gt;","text":"<pre><code>template void refine_linear_Top&lt; double &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_top-float","title":"function refine_linear_Top&lt; float &gt;","text":"<pre><code>template void refine_linear_Top&lt; float &gt; (\n    Param XParam,\n    int ib,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_topgpu","title":"function refine_linear_TopGPU","text":"<p>GPU kernel to refine a block on the top side using linear reconstruction. </p><pre><code>template&lt;class T&gt;\n__global__ void refine_linear_TopGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#description_21","title":"Description","text":"<p>This GPU kernel refines a block on the top side using linear reconstruction. It checks if the neighboring block on the top is at a coarser level. If so, it calculates the new values for the top boundary of the current block using the gradients in the x and y directions. The new values are computed based on the distance to the neighboring block and the gradients, ensuring a smooth transition between different resolution levels. Each thread processes a specific column of the block, allowing for parallel computation across multiple blocks. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> <li><code>dzdx</code> The gradient of z in the x direction </li> <li><code>dzdy</code> The gradient of z in the y direction </li> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_topgpu-double","title":"function refine_linear_TopGPU&lt; double &gt;","text":"<pre><code>template __global__ void refine_linear_TopGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z,\n    double * dzdx,\n    double * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8cu/#function-refine_linear_topgpu-float","title":"function refine_linear_TopGPU&lt; float &gt;","text":"<pre><code>template __global__ void refine_linear_TopGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z,\n    float * dzdx,\n    float * dzdy\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Halo.cu</code></p>"},{"location":"BGFlood/_halo_8cu_source/","title":"File Halo.cu","text":""},{"location":"BGFlood/_halo_8cu_source/#file-halocu","title":"File Halo.cu","text":"<p>File List &gt; src &gt; Halo.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Halo.h\"\n\n\ntemplate &lt;class T&gt; void fillHaloD(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z)\n{\n\n\n    fillLeft(XParam, ib, XBlock, z);\n    fillRight(XParam, ib, XBlock, z);\n    fillTop(XParam, ib, XBlock, z);\n    fillBot(XParam, ib, XBlock, z);\n    //fill bot\n    //fill top\n\n\n}\ntemplate void fillHaloD&lt;double&gt;(Param XParam, int ib, BlockP&lt;double&gt; XBlock, double* z);\ntemplate void fillHaloD&lt;float&gt;(Param XParam, int ib, BlockP&lt;float&gt; XBlock, float* z);\n\ntemplate &lt;class T&gt; void fillHaloC(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        fillHaloD(XParam, ib, XBlock, z);\n    }\n}\ntemplate void fillHaloC&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z);\ntemplate void fillHaloC&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z);\n\ntemplate &lt;class T&gt; void RecalculateZs(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb)\n{\n    int ib, n;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        /*\n        //We only need to recalculate zs on the halo side \n        for (int n = -1; n &lt;= (XParam.blkwidth); n++)\n        {\n            left = memloc(XParam.halowidth, XParam.blkmemwidth, -1, n, ib);\n            right = memloc(XParam.halowidth, XParam.blkmemwidth, XParam.blkwidth, n, ib);\n            top = memloc(XParam.halowidth, XParam.blkmemwidth, n, XParam.blkwidth, ib);\n            bot = memloc(XParam.halowidth, XParam.blkmemwidth, n, -1, ib);\n\n            Xev.zs[left] = zb[left] + Xev.h[left];\n            Xev.zs[right] = zb[right] + Xev.h[right];\n            Xev.zs[top] = zb[top] + Xev.h[top];\n            Xev.zs[bot] = zb[bot] + Xev.h[bot];\n\n            //printf(\"n=%d; zsold=%f; zsnew=%f (zb=%f + h=%f)\\n\",n, Xev.zs[n], zb[n] + Xev.h[n], zb[n] , Xev.h[n]);\n        }\n        */\n\n        // Recalculate zs everywhere maybe we only need to do that on the halo ?\n        for (int j = -1; j &lt; (XParam.blkwidth+1); j++)\n        {\n            for (int i = -1; i &lt; (XParam.blkwidth+1); i++)\n            {\n                n = memloc(XParam.halowidth,XParam.blkmemwidth, i, j, ib);\n                Xev.zs[n] = zb[n] + Xev.h[n];\n            }\n        }\n\n    }\n}\ntemplate void RecalculateZs&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float* zb);\ntemplate void RecalculateZs&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, double* zb);\n\ntemplate &lt;class T&gt; void Recalculatehh(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb)\n{\n    int ib, n;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        /*\n        //We only need to recalculate zs on the halo side\n        for (int n = -1; n &lt;= (XParam.blkwidth); n++)\n        {\n            left = memloc(XParam.halowidth, XParam.blkmemwidth, -1, n, ib);\n            right = memloc(XParam.halowidth, XParam.blkmemwidth, XParam.blkwidth, n, ib);\n            top = memloc(XParam.halowidth, XParam.blkmemwidth, n, XParam.blkwidth, ib);\n            bot = memloc(XParam.halowidth, XParam.blkmemwidth, n, -1, ib);\n\n            Xev.zs[left] = zb[left] + Xev.h[left];\n            Xev.zs[right] = zb[right] + Xev.h[right];\n            Xev.zs[top] = zb[top] + Xev.h[top];\n            Xev.zs[bot] = zb[bot] + Xev.h[bot];\n\n            //printf(\"n=%d; zsold=%f; zsnew=%f (zb=%f + h=%f)\\n\",n, Xev.zs[n], zb[n] + Xev.h[n], zb[n] , Xev.h[n]);\n        }\n        */\n\n        // Recalculate zs everywhere maybe we only need to do that on the halo ?\n        for (int j = -1; j &lt; (XParam.blkwidth + 1); j++)\n        {\n            for (int i = -1; i &lt; (XParam.blkwidth + 1); i++)\n            {\n                n = memloc(XParam.halowidth, XParam.blkmemwidth, i, j, ib);\n\n                Xev.h[n] = max(Xev.zs[n]- zb[n],(T)0.0) ;\n            }\n        }\n\n    }\n}\ntemplate void Recalculatehh&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float* zb);\ntemplate void Recalculatehh&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, double* zb);\n\n\ntemplate &lt;class T&gt; __global__ void RecalculateZsGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb)\n{\n    unsigned int blkmemwidth = XParam.blkmemwidth;\n\n    int ix = threadIdx.x -1;\n    int iy = threadIdx.y -1;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int  n;\n\n    //ib = XBlock.active[ibl];\n\n    n = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n    Xev.zs[n] = zb[n] + Xev.h[n];\n    /*\n    if(zb[n] &lt; XParam.eps)\n    {\n        printf(\"ix=%d, iy=%d, ib=%d, n=%d; zsold=%f; zsnew=%f (zb=%f + h=%f)\\n\",ix,iy,ib, n, Xev.zs[n], zb[n] + Xev.h[n], zb[n], Xev.h[n]);\n    }\n    */\n\n}\ntemplate __global__ void RecalculateZsGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float* zb);\ntemplate __global__ void RecalculateZsGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, double* zb);\n\ntemplate &lt;class T&gt; void fillHaloF(Param XParam, bool doProlongation, BlockP&lt;T&gt; XBlock, T* z)\n{\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        fillLeftFlux(XParam, doProlongation, ib, XBlock, z);\n        fillBotFlux(XParam, doProlongation, ib, XBlock, z);\n        fillRightFlux(XParam, doProlongation, ib, XBlock, z);\n        fillTopFlux(XParam, doProlongation, ib, XBlock, z);\n\n    }\n}\ntemplate void fillHaloF&lt;float&gt;(Param XParam, bool doProlongation, BlockP&lt;float&gt; XBlock, float* z);\ntemplate void fillHaloF&lt;double&gt;(Param XParam, bool doProlongation, BlockP&lt;double&gt; XBlock, double* z);\n\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z)\n{\n\n    dim3 blockDimHaloLR(1, XParam.blkwidth, 1);\n    dim3 blockDimHaloBT(XParam.blkwidth, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    fillLeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, z);\n    //fillLeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    fillRight &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    //fillRight &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    fillBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, z);\n    //fillBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0&gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    fillTop &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    //fillTop &lt;&lt;&lt;gridDim, blockDimHaloBT, 0&gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    //CUDA_CHECK(cudaStreamSynchronize(stream));\n\n}\ntemplate void fillHaloGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, cudaStream_t stream, double* z);\ntemplate void fillHaloGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, cudaStream_t stream, float* z);\n\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock,  T* z)\n{\n\n    dim3 blockDimHaloLR(1, XParam.blkwidth, 1);\n    dim3 blockDimHaloBT(XParam.blkwidth, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    fillLeft &lt;&lt; &lt;gridDim, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, z);\n    //fillLeft &lt;&lt; &lt;gridDim, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    fillRight &lt;&lt; &lt;gridDim, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    //fillRight &lt;&lt; &lt;gridDim, blockDimHaloLR, 0 &gt;&gt; &gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    fillBot &lt;&lt; &lt;gridDim, blockDimHaloBT, 0 &gt;&gt; &gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, z);\n    //fillBot &lt;&lt; &lt;gridDim, blockDimHaloBT, 0&gt;&gt; &gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    fillTop &lt;&lt; &lt;gridDim, blockDimHaloBT, 0 &gt;&gt; &gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    //fillTop &lt;&lt; &lt;gridDim, blockDimHaloBT, 0&gt;&gt; &gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    //CUDA_CHECK(cudaStreamSynchronize(stream));\n\n}\ntemplate void fillHaloGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock,double* z);\ntemplate void fillHaloGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z);\n\n\ntemplate &lt;class T&gt; void fillHaloGPUnew(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z)\n{\n    dim3 blockDimHaloLR(1, XParam.blkwidth, 1);\n    dim3 blockDimHaloBT(XParam.blkwidth, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    dim3 blockDimHaloLRx2(2, XParam.blkwidth, 1);\n    dim3 blockDimHaloBTx2(XParam.blkwidth, 2, 1);\n    dim3 gridDimx2(ceil(XParam.nblk/2), 1, 1);\n\n    //fillLeftnew &lt;&lt;&lt;gridDimx2, blockDimHaloLRx2, 0&gt;&gt;&gt; (XParam.halowidth, XParam.nblk, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, z);\n    fillLeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    //fillRightnew &lt;&lt;&lt;gridDimx2, blockDimHaloLRx2, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.nblk, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    fillRight &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    //fillBotnew &lt;&lt;&lt;gridDimx2, blockDimHaloBTx2, 0&gt;&gt;&gt; (XParam.halowidth, XParam.nblk, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, z);\n    fillBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0&gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    //fillTopnew &lt;&lt;&lt;gridDimx2, blockDimHaloBTx2, 0 &gt;&gt;&gt; (XParam.halowidth, XParam.nblk, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    fillTop &lt;&lt;&lt;gridDim, blockDimHaloBT, 0&gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    //CUDA_CHECK(cudaStreamSynchronize(stream));\n\n}\ntemplate void fillHaloGPUnew&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, cudaStream_t stream, double* z);\ntemplate void fillHaloGPUnew&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, cudaStream_t stream, float* z);\n\n\ntemplate &lt;class T&gt; void fillHaloTopRightC(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    // for flux term and actually most terms, only top and right neighbours are needed!\n\n    //fillLeft(XParam, ib, XBlock, z);\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        HaloFluxCPULR(XParam, ib, XBlock, z);\n        HaloFluxCPUBT(XParam, ib, XBlock, z);\n\n        //fillRightFlux(XParam,true, ib, XBlock, z);\n        //fillTopFlux(XParam,true, ib, XBlock, z);\n\n    }\n\n\n\n}\ntemplate void fillHaloTopRightC&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z);\ntemplate void fillHaloTopRightC&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z);\n\ntemplate &lt;class T&gt; void fillHaloLRFluxC(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    // for flux term and actually most terms, only top and right neighbours are needed!\n\n    //fillLeft(XParam, ib, XBlock, z);\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        HaloFluxCPULR(XParam, ib, XBlock, z);\n        //HaloFluxCPUBT(XParam, ib, XBlock, z);\n\n        //fillRightFlux(XParam,true, ib, XBlock, z);\n        //fillTopFlux(XParam,true, ib, XBlock, z);\n\n    }\n\n\n\n}\ntemplate void fillHaloLRFluxC&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z);\ntemplate void fillHaloLRFluxC&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z);\n\ntemplate &lt;class T&gt; void fillHaloBTFluxC(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    // for flux term and actually most terms, only top and right neighbours are needed!\n\n    //fillLeft(XParam, ib, XBlock, z);\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        //HaloFluxCPULR(XParam, ib, XBlock, z);\n        HaloFluxCPUBT(XParam, ib, XBlock, z);\n\n        //fillRightFlux(XParam,true, ib, XBlock, z);\n        //fillTopFlux(XParam,true, ib, XBlock, z);\n\n    }\n\n\n\n}\ntemplate void fillHaloBTFluxC&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z);\ntemplate void fillHaloBTFluxC&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z);\n\n\ntemplate &lt;class T&gt; void fillHaloTopRightGPU(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z)\n{\n\n    dim3 blockDimHaloLR(1, 16, 1);\n    dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n\n    //fillLeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, a);\n    //fillRightFlux &lt;&lt;&lt;gridDim, blockDimHaloLR, 0, stream &gt;&gt;&gt; (XParam.halowidth,false, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    HaloFluxGPULR &lt;&lt;&lt;gridDim, blockDimHaloLR, 0, stream &gt;&gt;&gt; (XParam, XBlock, z);\n\n    //fillBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, a);\n    //fillTopFlux &lt;&lt;&lt;gridDim, blockDimHaloBT, 0, stream &gt;&gt;&gt; (XParam.halowidth,false, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    HaloFluxGPUBT &lt;&lt;&lt;gridDim, blockDimHaloBT, 0, stream &gt;&gt;&gt; (XParam, XBlock, z);\n    CUDA_CHECK(cudaStreamSynchronize(stream));\n\n}\ntemplate void fillHaloTopRightGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, cudaStream_t stream, double* z);\ntemplate void fillHaloTopRightGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, cudaStream_t stream, float* z);\n\n\ntemplate &lt;class T&gt; void fillHaloLeftRightGPU(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z)\n{\n\n    dim3 blockDimHaloLR(1, 16, 1);\n    //dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n\n    //fillLeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, a);\n    //fillRightFlux &lt;&lt;&lt;gridDim, blockDimHaloLR, 0, stream &gt;&gt;&gt; (XParam.halowidth,false, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    HaloFluxGPULR &lt;&lt;&lt;gridDim, blockDimHaloLR, 0, stream &gt;&gt;&gt; (XParam, XBlock, z);\n\n    //fillBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, a);\n    //fillTopFlux &lt;&lt;&lt;gridDim, blockDimHaloBT, 0, stream &gt;&gt;&gt; (XParam.halowidth,false, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    //HaloFluxGPUBT &lt;&lt;&lt;gridDim, blockDimHaloBT, 0, stream &gt;&gt;&gt; (XParam, XBlock, z);\n    //CUDA_CHECK(cudaStreamSynchronize(stream));\n\n}\ntemplate void fillHaloLeftRightGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, cudaStream_t stream, double* z);\ntemplate void fillHaloLeftRightGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, cudaStream_t stream, float* z);\n\n\ntemplate &lt;class T&gt; void fillHaloLeftRightGPUnew(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z)\n{\n\n    dim3 blockDimHaloLR(2, 16, 1);\n    //dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDim(ceil(XParam.nblk/2), 1, 1);\n\n    HaloFluxGPULRnew &lt;&lt;&lt;gridDim, blockDimHaloLR, 0, stream &gt;&gt;&gt; (XParam, XBlock, z);\n\n\n\n}\ntemplate void fillHaloLeftRightGPUnew&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, cudaStream_t stream, double* z);\ntemplate void fillHaloLeftRightGPUnew&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, cudaStream_t stream, float* z);\n\ntemplate &lt;class T&gt; void fillHaloBotTopGPU(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z)\n{\n\n    //dim3 blockDimHaloLR(1, 16, 1);\n    dim3 blockDimHaloBT(16, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n\n    //fillLeft &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.LeftBot, XBlock.LeftTop, XBlock.RightBot, XBlock.BotRight, XBlock.TopRight, a);\n    //fillRightFlux &lt;&lt;&lt;gridDim, blockDimHaloLR, 0, stream &gt;&gt;&gt; (XParam.halowidth,false, XBlock.active, XBlock.level, XBlock.RightBot, XBlock.RightTop, XBlock.LeftBot, XBlock.BotLeft, XBlock.TopLeft, z);\n    //HaloFluxGPULR &lt;&lt;&lt;gridDim, blockDimHaloLR, 0, stream &gt;&gt;&gt; (XParam, XBlock, z);\n\n    //fillBot &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XBlock.level, XBlock.BotLeft, XBlock.BotRight, XBlock.TopLeft, XBlock.LeftTop, XBlock.RightTop, a);\n    //fillTopFlux &lt;&lt;&lt;gridDim, blockDimHaloBT, 0, stream &gt;&gt;&gt; (XParam.halowidth,false, XBlock.active, XBlock.level, XBlock.TopLeft, XBlock.TopRight, XBlock.BotLeft, XBlock.LeftBot, XBlock.RightBot, z);\n    HaloFluxGPUBT &lt;&lt;&lt;gridDim, blockDimHaloBT, 0, stream &gt;&gt;&gt; (XParam, XBlock, z);\n    //CUDA_CHECK(cudaStreamSynchronize(stream));\n\n}\ntemplate void fillHaloBotTopGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, cudaStream_t stream, double* z);\ntemplate void fillHaloBotTopGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, cudaStream_t stream, float* z);\n\ntemplate &lt;class T&gt; void fillHaloBotTopGPUnew(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z)\n{\n\n    //dim3 blockDimHaloLR(1, 16, 1);\n    dim3 blockDimHaloBT(16, 2, 1);\n    dim3 gridDim(ceil(XParam.nblk/2), 1, 1);\n\n\n    HaloFluxGPUBTnew &lt;&lt;&lt;gridDim, blockDimHaloBT, 0, stream &gt;&gt;&gt; (XParam, XBlock, z);\n\n\n}\ntemplate void fillHaloBotTopGPUnew&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, cudaStream_t stream, double* z);\ntemplate void fillHaloBotTopGPUnew&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, cudaStream_t stream, float* z);\n\n\ntemplate &lt;class T&gt; void fillHalo(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T*zb)\n{\n\n\n        std::thread t0(fillHaloC&lt;T&gt;,XParam, XBlock, Xev.h);\n        std::thread t1(fillHaloC&lt;T&gt;,XParam, XBlock, Xev.zs);\n        //std::thread t2(fillHaloF&lt;T&gt;,XParam,true, XBlock, Xev.u);\n        //std::thread t3(fillHaloF&lt;T&gt;,XParam,true, XBlock, Xev.v);\n\n        std::thread t2(fillHaloC&lt;T&gt;, XParam, XBlock, Xev.u);\n        std::thread t3(fillHaloC&lt;T&gt;, XParam, XBlock, Xev.v);\n\n        t0.join();\n        t1.join();\n        t2.join();\n        t3.join();\n\n        if (XParam.conserveElevation)\n        {\n            conserveElevation(XParam, XBlock, Xev, zb);\n        }\n        else if (XParam.wetdryfix)\n        {\n            WetDryRestriction(XParam, XBlock, Xev, zb);\n        }\n\n        RecalculateZs(XParam, XBlock, Xev, zb);\n\n        maskbnd(XParam, XBlock, Xev, zb);\n\n}\ntemplate void fillHalo&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, float *zb);\ntemplate void fillHalo&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev,double * zb);\n\ntemplate &lt;class T&gt; void fillHalo(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev)\n{\n\n    std::thread t0(fillHaloC&lt;T&gt;, XParam, XBlock, Xev.h);\n    std::thread t1(fillHaloC&lt;T&gt;, XParam, XBlock, Xev.zs);\n    std::thread t2(fillHaloF&lt;T&gt;, XParam, true, XBlock, Xev.u);\n    std::thread t3(fillHaloF&lt;T&gt;, XParam, true, XBlock, Xev.v);\n\n    t0.join();\n    t1.join();\n    t2.join();\n    t3.join();\n\n\n    //maskbnd(XParam, XBlock, Xev, zb);\n\n}\ntemplate void fillHalo&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev);\ntemplate void fillHalo&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev);\n\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev)\n{\n    const int num_streams = 4;\n\n    cudaStream_t streams[num_streams];\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n    }\n\n\n    fillHaloGPU(XParam, XBlock, streams[0], Xev.h);\n    fillHaloGPU(XParam, XBlock, streams[1], Xev.zs);\n    fillHaloGPU(XParam, XBlock, streams[2], Xev.u);\n    fillHaloGPU(XParam, XBlock, streams[3], Xev.v);\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamDestroy(streams[i]);\n    }\n}\ntemplate void fillHaloGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev);\ntemplate void fillHaloGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev);\n\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev,T * zb)\n{\n    const int num_streams = 4;\n    dim3 blockDimHalo(XParam.blkwidth,1, 1);\n\n    dim3 gridDim(XBlock.mask.nblk, 1, 1);\n\n    dim3 blockDimfull(XParam.blkmemwidth, XParam.blkmemwidth, 1);\n    dim3 gridDimfull(XParam.nblk, 1, 1);\n\n    cudaStream_t streams[num_streams];\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n    }\n\n\n    fillHaloGPU(XParam, XBlock, streams[0], Xev.h);\n    fillHaloGPU(XParam, XBlock, streams[1], Xev.zs);\n    fillHaloGPU(XParam, XBlock, streams[2], Xev.u);\n    fillHaloGPU(XParam, XBlock, streams[3], Xev.v);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    if (XParam.conserveElevation)\n    {\n        conserveElevationGPU(XParam, XBlock, Xev, zb);\n    }\n    else if (XParam.wetdryfix)\n    {\n        WetDryRestrictionGPU(XParam, XBlock, Xev, zb);\n    }\n\n    RecalculateZsGPU &lt;&lt;&lt; gridDimfull, blockDimfull, 0 &gt;&gt;&gt; (XParam, XBlock, Xev, zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    //if (XBlock.mask.nblk &gt; 0)\n    //{\n    //  maskbndGPUleft &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[0] &gt;&gt;&gt; (XParam, XBlock, Xev, zb);\n    //  maskbndGPUtop &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[1] &gt;&gt;&gt; (XParam, XBlock, Xev, zb);\n    //  maskbndGPUright &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[2] &gt;&gt;&gt; (XParam, XBlock, Xev, zb);\n    //  maskbndGPUtop &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[3] &gt;&gt;&gt; (XParam, XBlock, Xev, zb);\n\n    //  //CUDA_CHECK(cudaDeviceSynchronize());\n    //}\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamDestroy(streams[i]);\n    }\n\n\n}\ntemplate void fillHaloGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev,float *zb);\ntemplate void fillHaloGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev,double* zb);\n\ntemplate &lt;class T&gt; void fillHalo(Param XParam, BlockP&lt;T&gt; XBlock, GradientsP&lt;T&gt; Grad)\n{\n\n    /*\n    std::thread t0(fillHaloF&lt;T&gt;,XParam, true, XBlock, Grad.dhdx);\n    std::thread t1(fillHaloF&lt;T&gt;,XParam, true, XBlock, Grad.dudx);\n    std::thread t2(fillHaloF&lt;T&gt;,XParam, true, XBlock, Grad.dvdx);\n    std::thread t3(fillHaloF&lt;T&gt;,XParam, true, XBlock, Grad.dzsdx);\n\n    std::thread t4(fillHaloF&lt;T&gt;,XParam, true, XBlock, Grad.dhdy);\n    std::thread t5(fillHaloF&lt;T&gt;,XParam, true, XBlock, Grad.dudy);\n    std::thread t6(fillHaloF&lt;T&gt;,XParam, true, XBlock, Grad.dvdy);\n    std::thread t7(fillHaloF&lt;T&gt;,XParam, true, XBlock, Grad.dzsdy);\n\n    */\n    std::thread t0(fillHaloC&lt;T&gt;, XParam, XBlock, Grad.dhdx);\n    std::thread t1(fillHaloC&lt;T&gt;, XParam, XBlock, Grad.dudx);\n    std::thread t2(fillHaloC&lt;T&gt;, XParam, XBlock, Grad.dvdx);\n    std::thread t3(fillHaloC&lt;T&gt;, XParam, XBlock, Grad.dzsdx);\n\n    std::thread t4(fillHaloC&lt;T&gt;, XParam, XBlock, Grad.dhdy);\n    std::thread t5(fillHaloC&lt;T&gt;, XParam, XBlock, Grad.dudy);\n    std::thread t6(fillHaloC&lt;T&gt;, XParam, XBlock, Grad.dvdy);\n    std::thread t7(fillHaloC&lt;T&gt;, XParam, XBlock, Grad.dzsdy);\n\n    t0.join();\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n    t5.join();\n    t6.join();\n    t7.join();\n\n\n}\ntemplate void fillHalo&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, GradientsP&lt;float&gt; Grad);\ntemplate void fillHalo&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, GradientsP&lt;double&gt; Grad);\n\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, GradientsP&lt;T&gt; Grad)\n{\n    const int num_streams = 8;\n\n    cudaStream_t streams[num_streams];\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n    }\n\n    fillHaloGPU(XParam, XBlock, streams[0], Grad.dhdx);\n    fillHaloGPU(XParam, XBlock, streams[2], Grad.dudx);\n    fillHaloGPU(XParam, XBlock, streams[3], Grad.dvdx);\n    fillHaloGPU(XParam, XBlock, streams[4], Grad.dzsdx);\n\n    fillHaloGPU(XParam, XBlock, streams[5], Grad.dhdy);\n    fillHaloGPU(XParam, XBlock, streams[6], Grad.dudy);\n    fillHaloGPU(XParam, XBlock, streams[7], Grad.dvdy);\n    fillHaloGPU(XParam, XBlock, streams[1], Grad.dzsdy);\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamDestroy(streams[i]);\n    }\n\n}\ntemplate void fillHaloGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, GradientsP&lt;float&gt; Grad);\ntemplate void fillHaloGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, GradientsP&lt;double&gt; Grad);\n\n\ntemplate &lt;class T&gt; void fillHalo(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux)\n{\n\n\n    //std::thread t0(fillHaloTopRightC&lt;T&gt;,XParam, XBlock, Flux.Fhu);\n    //std::thread t1(fillHaloTopRightC&lt;T&gt;,XParam, XBlock, Flux.Fhv);\n    //std::thread t2(fillHaloTopRightC&lt;T&gt;,XParam, XBlock, Flux.Fqux);\n    //std::thread t3(fillHaloTopRightC&lt;T&gt;, XParam, XBlock, Flux.Fquy);\n\n    //std::thread t4(fillHaloTopRightC&lt;T&gt;, XParam, XBlock, Flux.Fqvx);\n    //std::thread t5(fillHaloTopRightC&lt;T&gt;, XParam, XBlock, Flux.Fqvy);\n    //std::thread t6(fillHaloTopRightC&lt;T&gt;, XParam, XBlock, Flux.Su);\n    //std::thread t7(fillHaloTopRightC&lt;T&gt;, XParam, XBlock, Flux.Sv);\n\n    std::thread t0(fillHaloLRFluxC&lt;T&gt;, XParam, XBlock, Flux.Fhu);\n    std::thread t1(fillHaloLRFluxC&lt;T&gt;, XParam, XBlock, Flux.Fqux);\n    std::thread t2(fillHaloLRFluxC&lt;T&gt;, XParam, XBlock, Flux.Su);\n\n    std::thread t6(fillHaloLRFluxC&lt;T&gt;, XParam, XBlock, Flux.Fqvx);\n\n    std::thread t3(fillHaloBTFluxC&lt;T&gt;, XParam, XBlock, Flux.Fhv);\n    std::thread t4(fillHaloBTFluxC&lt;T&gt;, XParam, XBlock, Flux.Fqvy);\n    std::thread t5(fillHaloBTFluxC&lt;T&gt;, XParam, XBlock, Flux.Sv);\n\n    std::thread t7(fillHaloBTFluxC&lt;T&gt;, XParam, XBlock, Flux.Fquy);\n\n    t0.join();\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n    t5.join();\n    t6.join();\n    t7.join();\n\n}\ntemplate void fillHalo&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, FluxP&lt;float&gt; Flux);\ntemplate void fillHalo&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, FluxP&lt;double&gt; Flux);\n\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux)\n{\n    const int num_streams = 8;\n\n    cudaStream_t streams[num_streams];\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n    }\n\n    dim3 blockDimHalo(XParam.blkwidth, 1, 1);\n\n    dim3 gridDim(XBlock.mask.nblk, 1, 1);\n\n\n    fillHaloLeftRightGPUnew(XParam, XBlock, streams[0], Flux.Fhu);\n    fillHaloLeftRightGPUnew(XParam, XBlock, streams[1], Flux.Su);\n    fillHaloLeftRightGPUnew(XParam, XBlock, streams[2], Flux.Fqux);\n    fillHaloLeftRightGPUnew(XParam, XBlock, streams[3], Flux.Fqvx);\n\n\n\n    fillHaloBotTopGPUnew(XParam, XBlock, streams[4], Flux.Fquy);\n    fillHaloBotTopGPUnew(XParam, XBlock, streams[5], Flux.Fqvy);\n    fillHaloBotTopGPUnew(XParam, XBlock, streams[6], Flux.Fhv);\n    fillHaloBotTopGPUnew(XParam, XBlock, streams[7], Flux.Sv);\n\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamSynchronize(streams[i]);\n    }\n    // Below has now moved to its own function\n    //if (XBlock.mask.nblk &gt; 0)\n    //{\n    //  maskbndGPUFluxleft &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[0] &gt;&gt;&gt; (XParam, XBlock, Flux);\n    //  maskbndGPUFluxtop &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[1] &gt;&gt;&gt; (XParam, XBlock, Flux);\n    //  maskbndGPUFluxright &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[2] &gt;&gt;&gt; (XParam, XBlock, Flux);\n    //  maskbndGPUFluxbot &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[3] &gt;&gt;&gt; (XParam, XBlock, Flux);\n\n    //  //CUDA_CHECK(cudaDeviceSynchronize());\n    //}\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamDestroy(streams[i]);\n    }\n\n\n}\ntemplate void fillHaloGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, FluxP&lt;float&gt; Flux);\ntemplate void fillHaloGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, FluxP&lt;double&gt; Flux);\n\ntemplate &lt;class T&gt; void bndmaskGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, FluxP&lt;T&gt; Flux)\n{\n    const int num_streams = 8;\n\n    cudaStream_t streams[num_streams];\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        CUDA_CHECK(cudaStreamCreate(&amp;streams[i]));\n    }\n\n    dim3 blockDimHalo(XParam.blkwidth, 1, 1);\n\n    dim3 gridDim(XBlock.mask.nblk, 1, 1);\n    if (XBlock.mask.nblk &gt; 0)\n    {\n        maskbndGPUFluxleft &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[0] &gt;&gt;&gt; (XParam, XBlock, Xev, Flux);\n        maskbndGPUFluxtop &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[1] &gt;&gt;&gt; (XParam, XBlock,  Flux);\n        maskbndGPUFluxright &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[2] &gt;&gt;&gt; (XParam, XBlock,  Flux);\n        maskbndGPUFluxbot &lt;&lt;&lt;gridDim, blockDimHalo, 0, streams[3] &gt;&gt;&gt; (XParam, XBlock, Flux);\n\n        //CUDA_CHECK(cudaDeviceSynchronize());\n    }\n\n    for (int i = 0; i &lt; num_streams; i++)\n    {\n        cudaStreamDestroy(streams[i]);\n    }\n\n}\ntemplate void bndmaskGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; Xev, FluxP&lt;float&gt; Flux);\ntemplate void bndmaskGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; Xev, FluxP&lt;double&gt; Flux);\n\n//template &lt;class T&gt; void refine_linearCPU(Param XParam, int ib, bool isLR, bool isoposit, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n//{\n//  int Neighblock, Mirrorblock;\n//\n//  int ir = isoposit ? 0 : XParam.blkwidth - 1;\n//  int iw = isoposit ? XParam.blkwidth : -1;\n//  if (isLR)\n//  {\n//      Neighblock = isoposit ? XBlock.RightBot[ib] : XBlock.LeftBot[ib];\n//      Mirrorblock = isoposit ? XBlock.LeftBot[Neighblock] : XBlock.RightBot[Neighblock]\n//  }\n//  else\n//  {\n//      Neighblock = isoposit ? XBlock.TopLeft[ib] : XBlock.BotLeft[ib];\n//      Mirrorblock = isoposit ? XBlock.BotLeft[Neighblock] : XBlock.TopLeft[Neighblock]\n//  }\n//\n//  if (XBlock.level[Neighblock] &lt; XBlock.level[ib])\n//  {\n//      double ilevdx = calcres(XParam.dx, XBlock.level[ib]) * T(0.25);\n//      for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n//      {\n//          int jj = Mirrorblock == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + XParam.blkwidth / 2;\n//          int il = isLR ? memloc(XParam, ir, jj, Neighblock) : memloc(XParam, jj, ir, Neighblock);\n//          int write = isLR ? memloc(XParam, iw, j, ib) : memloc(XParam, j, iw, ib);\n//          T faclr = T(-1.0);\n//          T facbt = floor(j * (T)0.5) * T(2.0) &gt; j ? 1.0 : -1.0;\n//\n//          T newz = z[il] + (faclr * dzdx[il] + facbt * dzdy[il]) * ilevdx;\n//\n//          z[write] = newz;\n//\n//\n//      }\n//  }\n//}\n//template void refine_linearCPU&lt;float&gt;(Param XParam, int ib, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\n//template void refine_linearCPU&lt;double&gt;(Param XParam, int ib, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\ntemplate &lt;class T&gt; void refine_linear_Left(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z, T * dzdx, T * dzdy)\n{\n    if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib])\n    {\n\n        double ilevdx = calcres(XParam.delta, XBlock.level[ib])*T(0.5);\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            int jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib ? ftoi(floor(j * (T)0.5)) : ftoi(floor(j * (T)0.5) + XParam.blkwidth / 2);\n            int il = memloc(XParam, XParam.blkwidth - 1, jj , XBlock.LeftBot[ib]);\n            int write = memloc(XParam, -1, j, ib);\n            T faclr = T(1.0);\n            T facbt = floor(j * (T)0.5) * T(2.0) &lt; (j-T(0.01)) ? 1.0 : -1.0;\n\n            T newz = z[il] + (faclr*dzdx[il]+facbt*dzdy[il]) * ilevdx;\n\n            z[write] = newz;\n\n\n        }\n    }\n}\ntemplate void refine_linear_Left&lt;float&gt;(Param XParam, int ib, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate void refine_linear_Left&lt;double&gt;(Param XParam, int ib, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\n\ntemplate &lt;class T&gt; __global__ void refine_linear_LeftGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z, T* dzdx,T*dzdy)\n{\n    int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = 0;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n\n\n\n    if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib])\n    {\n        int j = iy;\n\n        double ilevdx = calcres(XParam.delta, XBlock.level[ib]) * T(0.5);\n\n\n        int jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib ? floor(j * (T)0.5) : floor(j * (T)0.5) + XParam.blkwidth / 2;\n        int il = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth - 1, jj, XBlock.LeftBot[ib]);\n        int write = memloc(XParam.halowidth, blkmemwidth, -1, j, ib);\n        T faclr = T(1.0);\n        T facbt = floor(j * (T)0.5) * T(2.0) &lt; (j - T(0.01)) ? 1.0 : -1.0;\n\n        T newz = z[il] + (faclr * dzdx[il] + facbt * dzdy[il]) * ilevdx;\n\n        z[write] = newz;\n\n\n\n    }\n}\ntemplate __global__ void refine_linear_LeftGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate __global__ void refine_linear_LeftGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\n\ntemplate &lt;class T&gt; void refine_linear_Right(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n{\n    if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib])\n    {\n\n        T ilevdx = calcres(T(XParam.delta), XBlock.level[ib] ) * T(0.5);\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            int jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? ftoi(floor(j * (T)0.5)) : ftoi(floor(j * (T)0.5) + XParam.blkwidth / 2);\n            int il = memloc(XParam, 0, jj , XBlock.RightBot[ib]);\n            int write = memloc(XParam, XParam.blkwidth, j, ib);\n            T faclr = T(-1.0);\n            T facbt = floor(j * (T)0.5) * T(2.0) &lt; (j - T(0.01)) ? 1.0 : -1.0;\n\n            T newz = z[il] + (faclr * dzdx[il] + facbt * dzdy[il]) * ilevdx;\n\n            z[write] = newz;\n\n\n        }\n    }\n}\ntemplate void refine_linear_Right&lt;float&gt;(Param XParam, int ib, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate void refine_linear_Right&lt;double&gt;(Param XParam, int ib, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\ntemplate &lt;class T&gt; __global__ void refine_linear_RightGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n{\n    unsigned int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n\n\n    if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib])\n    {\n\n        double ilevdx = calcres(XParam.delta, XBlock.level[ib]) * T(0.5);\n\n        int j = iy;\n        int jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? floor(j * (T)0.5) : floor(j * (T)0.5) + XParam.blkwidth / 2;\n        int il = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightBot[ib]);\n        int write = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, j, ib);\n\n        T faclr = T(-1.0);\n        T facbt = floor(j * (T)0.5) * T(2.0) &lt; (j - T(0.01)) ? 1.0 : -1.0;\n\n        T newz = z[il] + (faclr * dzdx[il] + facbt * dzdy[il]) * ilevdx;\n\n        z[write] = newz;\n\n\n\n    }\n}\ntemplate __global__ void refine_linear_RightGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate __global__ void refine_linear_RightGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\ntemplate &lt;class T&gt; void refine_linear_Bot(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n{\n    if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib])\n    {\n\n        T ilevdx = calcres(T(XParam.delta), XBlock.level[ib]) * T(0.5);\n\n        for (int i = 0; i &lt; XParam.blkwidth; i++)\n        {\n            int ii = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? ftoi(floor(i * (T)0.5)) : ftoi(floor(i * (T)0.5) + XParam.blkwidth / 2);\n            int jl = memloc(XParam,  ii, XParam.blkwidth - 1, XBlock.BotLeft[ib]);\n            int write = memloc(XParam, i, -1, ib);\n\n            T facbt = T(1.0);\n            T faclr = floor(i * (T)0.5) * T(2.0) &lt; (i - T(0.01)) ? 1.0 : -1.0;\n\n            T newz = z[jl] + (faclr * dzdx[jl] + facbt * dzdy[jl]) * ilevdx;\n\n            z[write] = newz;\n\n\n        }\n    }\n}\ntemplate void refine_linear_Bot&lt;float&gt;(Param XParam, int ib, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate void refine_linear_Bot&lt;double&gt;(Param XParam, int ib, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\ntemplate &lt;class T&gt; __global__ void refine_linear_BotGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n{\n    int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n\n    int ix = threadIdx.x;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib])\n    {\n\n        double ilevdx = calcres(XParam.delta, XBlock.level[ib]) * T(0.5);\n\n        int i = ix;\n        int ii = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? floor(i * (T)0.5) : floor(i * (T)0.5) + XParam.blkwidth / 2;\n        int jl = memloc(XParam.halowidth, blkmemwidth, ii, XParam.blkwidth - 1, XBlock.BotLeft[ib]);\n        int write = memloc(XParam.halowidth, blkmemwidth, i, -1, ib);\n\n        T facbt = T(1.0);\n        T faclr = floor(i * (T)0.5) * T(2.0) &lt; (i - T(0.01)) ? 1.0 : -1.0;\n\n        T newz = z[jl] + (faclr * dzdx[jl] + facbt * dzdy[jl]) * ilevdx;\n\n        z[write] = newz;\n\n\n\n    }\n}\ntemplate __global__ void refine_linear_BotGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate __global__ void refine_linear_BotGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\ntemplate &lt;class T&gt; void refine_linear_Top(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n{\n    if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib])\n    {\n\n        double ilevdx = calcres(XParam.delta, XBlock.level[ib]) * T(0.5);\n\n        for (int i = 0; i &lt; XParam.blkwidth; i++)\n        {\n            int ii = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? ftoi(floor(i * (T)0.5)) : ftoi(floor(i * (T)0.5) + XParam.blkwidth / 2);\n            int jl = memloc(XParam, ii , 0, XBlock.TopLeft[ib]);\n            int write = memloc(XParam, i, XParam.blkwidth, ib);\n\n            T facbt = T(-1.0);\n            T faclr = floor(i * (T)0.5) * T(2.0) &lt; (i - T(0.01)) ? 1.0 : -1.0;\n\n            T newz = z[jl] + (faclr * dzdx[jl] + facbt * dzdy[jl]) * ilevdx;\n\n            z[write] = newz;\n\n\n        }\n    }\n}\ntemplate void refine_linear_Top&lt;float&gt;(Param XParam, int ib, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate void refine_linear_Top&lt;double&gt;(Param XParam, int ib, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\ntemplate &lt;class T&gt; __global__ void refine_linear_TopGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n{\n    int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n\n    int ix = threadIdx.x;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n    if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib])\n    {\n\n        double ilevdx = calcres(XParam.delta, XBlock.level[ib]) * T(0.5);\n\n    int i = ix;\n        int ii = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? floor(i * (T)0.5) : floor(i * (T)0.5) + XParam.blkwidth / 2;\n        int jl = memloc(XParam.halowidth, blkmemwidth, ii , 0, XBlock.TopLeft[ib]);\n        int write = memloc(XParam.halowidth, blkmemwidth, i, XParam.blkwidth, ib);\n\n        T facbt = T(-1.0);\n        T faclr = floor(i * (T)0.5) * T(2.0) &lt; (i - T(0.01)) ? 1.0 : -1.0;\n\n        T newz = z[jl] + (faclr * dzdx[jl] + facbt * dzdy[jl]) * ilevdx;\n\n        z[write] = newz;\n\n\n\n    }\n}\ntemplate __global__ void refine_linear_TopGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate __global__ void refine_linear_TopGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\ntemplate &lt;class T&gt; void refine_linear(Param XParam, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n{\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        refine_linear_Left(XParam, ib, XBlock, z, dzdx, dzdy);\n        refine_linear_Right(XParam, ib, XBlock, z, dzdx, dzdy);\n        refine_linear_Top(XParam, ib, XBlock, z, dzdx, dzdy);\n        refine_linear_Bot(XParam, ib, XBlock, z, dzdx, dzdy);\n    }\n}\ntemplate void refine_linear&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate void refine_linear&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\ntemplate &lt;class T&gt; void refine_linearGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy)\n{\n    dim3 blockDimHaloLR(1, XParam.blkwidth, 1);\n    dim3 blockDimHaloBT(XParam.blkwidth, 1, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    refine_linear_LeftGPU&lt;&lt;&lt;gridDim, blockDimHaloLR, 0&gt;&gt;&gt;(XParam, XBlock, z, dzdx, dzdy);\n    refine_linear_RightGPU &lt;&lt;&lt;gridDim, blockDimHaloLR, 0 &gt;&gt;&gt; (XParam, XBlock, z, dzdx, dzdy);\n    refine_linear_TopGPU &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, z, dzdx, dzdy);\n    refine_linear_BotGPU &lt;&lt;&lt;gridDim, blockDimHaloBT, 0 &gt;&gt;&gt; (XParam, XBlock, z, dzdx, dzdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n}\ntemplate void refine_linearGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z, float* dzdx, float* dzdy);\ntemplate void refine_linearGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z, double* dzdx, double* dzdy);\n\ntemplate &lt;class T&gt; void HaloFluxCPULR(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T *z)\n{\n    int jj, i,il,itl;\n    if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n            //\n            i = memloc(XParam, 0, j, ib);\n\n\n            jj = j*2;\n            il = memloc(XParam, XParam.blkwidth, jj, XBlock.LeftBot[ib]);\n            itl = memloc(XParam, XParam.blkwidth, jj+1, XBlock.LeftBot[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.LeftTop[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n        {\n            //\n            i = memloc(XParam, 0, j, ib);\n\n\n            jj = (j - XParam.blkwidth / 2) * 2;\n            il = memloc(XParam, XParam.blkwidth, jj, XBlock.LeftTop[ib]);\n            itl = memloc(XParam, XParam.blkwidth, jj + 1, XBlock.LeftTop[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n            //\n            i = memloc(XParam, XParam.blkwidth, j, ib);\n\n\n            jj = j * 2;\n            il = memloc(XParam, 0, jj, XBlock.RightBot[ib]);\n            itl = memloc(XParam, 0, jj + 1, XBlock.RightBot[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.RightTop[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n        {\n\n            jj = (j - XParam.blkwidth / 2) * 2;\n            //\n            i = memloc(XParam, XParam.blkwidth, j, ib);\n\n\n            il = memloc(XParam, 0, jj, XBlock.RightTop[ib]);\n            itl = memloc(XParam, 0, jj + 1, XBlock.RightTop[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n}\n\ntemplate &lt;class T&gt; __global__  void HaloFluxGPULR(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    int jj, i, il, itl;\n    int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = 0;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n\n    int j = iy;\n\n\n    if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n\n        if (j&lt; (XParam.blkwidth / 2))\n        {\n            //\n            i = memloc(XParam.halowidth, blkmemwidth, 0, j, ib);\n\n\n            jj = j * 2;\n            il = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, jj, XBlock.LeftBot[ib]);\n            itl = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, jj + 1, XBlock.LeftBot[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.LeftTop[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n\n        if (j &gt;= (XParam.blkwidth / 2))\n        {\n            //\n            i = memloc(XParam.halowidth, blkmemwidth, 0, j, ib);\n\n\n            jj = (j - XParam.blkwidth / 2) * 2;\n            il = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, jj, XBlock.LeftTop[ib]);\n            itl = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, jj + 1, XBlock.LeftTop[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n\n        if (j &lt; (XParam.blkwidth / 2))\n        {\n            //\n            i = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, j, ib);\n\n\n            jj = j * 2;\n            il = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightBot[ib]);\n            itl = memloc(XParam.halowidth, blkmemwidth, 0, jj + 1, XBlock.RightBot[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.RightTop[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        if (j &gt;= (XParam.blkwidth / 2))\n        {\n\n            jj = (j - XParam.blkwidth / 2) * 2;\n            //\n            i = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, j, ib);\n\n\n            il = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightTop[ib]);\n            itl = memloc(XParam.halowidth, blkmemwidth, 0, jj + 1, XBlock.RightTop[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n}\n\ntemplate &lt;class T&gt; __global__  void HaloFluxGPULRnew(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    int jj, i, il, itl;\n    int blkmemwidth = blockDim.y + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = 0;\n    int iy = threadIdx.y;\n    int ibl = threadIdx.x + blockIdx.x * blockDim.x;\n    if (ibl &lt; XParam.nblk)\n    {\n\n        int ib = XBlock.active[ibl];\n\n\n        int j = iy;\n\n\n        if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n        {\n\n            if (j &lt; (XParam.blkwidth / 2))\n            {\n                //\n                i = memloc(XParam.halowidth, blkmemwidth, 0, j, ib);\n\n\n                jj = j * 2;\n                il = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, jj, XBlock.LeftBot[ib]);\n                itl = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, jj + 1, XBlock.LeftBot[ib]);\n\n                z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n            }\n            //\n        }\n        if (XBlock.level[XBlock.LeftTop[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n        {\n\n            if (j &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                i = memloc(XParam.halowidth, blkmemwidth, 0, j, ib);\n\n\n                jj = (j - XParam.blkwidth / 2) * 2;\n                il = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, jj, XBlock.LeftTop[ib]);\n                itl = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, jj + 1, XBlock.LeftTop[ib]);\n\n                z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n            }\n            //\n        }\n        if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n        {\n\n            if (j &lt; (XParam.blkwidth / 2))\n            {\n                //\n                i = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, j, ib);\n\n\n                jj = j * 2;\n                il = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightBot[ib]);\n                itl = memloc(XParam.halowidth, blkmemwidth, 0, jj + 1, XBlock.RightBot[ib]);\n\n                z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n            }\n            //\n        }\n        if (XBlock.level[XBlock.RightTop[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n        {\n            if (j &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (j - XParam.blkwidth / 2) * 2;\n                //\n                i = memloc(XParam.halowidth, blkmemwidth, XParam.blkwidth, j, ib);\n\n\n                il = memloc(XParam.halowidth, blkmemwidth, 0, jj, XBlock.RightTop[ib]);\n                itl = memloc(XParam.halowidth, blkmemwidth, 0, jj + 1, XBlock.RightTop[ib]);\n\n                z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n            }\n            //\n        }\n    }\n}\n\ntemplate &lt;class T&gt; void HaloFluxCPUBT(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z)\n{\n    int jj, i, il, itl;\n    if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n            //\n            i = memloc(XParam, j, 0, ib);\n\n\n            jj = j * 2;\n            il = memloc(XParam, jj, XParam.blkwidth,  XBlock.BotLeft[ib]);\n            itl = memloc(XParam, jj+1, XParam.blkwidth,  XBlock.BotLeft[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.BotRight[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n        {\n            //\n            i = memloc(XParam, j, 0, ib);\n\n\n            jj = (j - XParam.blkwidth / 2) * 2;\n            il = memloc(XParam,  jj, XParam.blkwidth, XBlock.BotRight[ib]);\n            itl = memloc(XParam,  jj + 1, XParam.blkwidth, XBlock.BotRight[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n            //\n            i = memloc(XParam, j, XParam.blkwidth, ib);\n\n\n            jj = j * 2;\n            il = memloc(XParam, jj, 0,  XBlock.TopLeft[ib]);\n            itl = memloc(XParam, jj + 1, 0, XBlock.TopLeft[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.TopRight[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n        {\n\n            jj = (j - XParam.blkwidth / 2) * 2;\n            //\n            i = memloc(XParam, j, XParam.blkwidth, ib);\n\n\n            il = memloc(XParam, jj, 0, XBlock.TopRight[ib]);\n            itl = memloc(XParam, jj + 1, 0, XBlock.TopRight[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void HaloFluxGPUBT(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    int jj, i, il, itl;\n    int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    //unsigned int iy = threadIdx.x;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int j = ix;\n\n    if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        if (j &lt; (XParam.blkwidth / 2))\n        {\n            //\n            i = memloc(XParam.halowidth, blkmemwidth, j, 0, ib);\n\n\n            jj = j * 2;\n            il = memloc(XParam.halowidth, blkmemwidth, jj, XParam.blkwidth, XBlock.BotLeft[ib]);\n            itl = memloc(XParam.halowidth, blkmemwidth, jj + 1, XParam.blkwidth, XBlock.BotLeft[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.BotRight[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        if (j &gt;= (XParam.blkwidth / 2))\n        {\n            //\n            i = memloc(XParam.halowidth, blkmemwidth, j, 0, ib);\n\n\n            jj = (j - XParam.blkwidth / 2) * 2;\n            il = memloc(XParam.halowidth, blkmemwidth, jj, XParam.blkwidth, XBlock.BotRight[ib]);\n            itl = memloc(XParam.halowidth, blkmemwidth, jj + 1, XParam.blkwidth, XBlock.BotRight[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        if (j &lt; (XParam.blkwidth / 2))\n        {\n            //\n            i = memloc(XParam.halowidth, blkmemwidth, j, XParam.blkwidth, ib);\n\n\n            jj = j * 2;\n            il = memloc(XParam.halowidth, blkmemwidth, jj, 0, XBlock.TopLeft[ib]);\n            itl = memloc(XParam.halowidth, blkmemwidth, jj + 1, 0, XBlock.TopLeft[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n    if (XBlock.level[XBlock.TopRight[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n    {\n        if (j &gt;= (XParam.blkwidth / 2))\n        {\n\n            jj = (j - XParam.blkwidth / 2) * 2;\n            //\n            i = memloc(XParam.halowidth, blkmemwidth, j, XParam.blkwidth, ib);\n\n\n            il = memloc(XParam.halowidth, blkmemwidth, jj, 0, XBlock.TopRight[ib]);\n            itl = memloc(XParam.halowidth, blkmemwidth, jj + 1, 0, XBlock.TopRight[ib]);\n\n            z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n        }\n        //\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void HaloFluxGPUBTnew(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    int jj, i, il, itl;\n    int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    //unsigned int iy = threadIdx.x;\n    int ibl = threadIdx.y + blockIdx.x * blockDim.y;\n    if (ibl &lt; XParam.nblk)\n    {\n\n\n\n        int ib = XBlock.active[ibl];\n\n        int j = ix;\n\n        if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n        {\n            if (j &lt; (XParam.blkwidth / 2))\n            {\n                //\n                i = memloc(XParam.halowidth, blkmemwidth, j, 0, ib);\n\n\n                jj = j * 2;\n                il = memloc(XParam.halowidth, blkmemwidth, jj, XParam.blkwidth, XBlock.BotLeft[ib]);\n                itl = memloc(XParam.halowidth, blkmemwidth, jj + 1, XParam.blkwidth, XBlock.BotLeft[ib]);\n\n                z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n            }\n            //\n        }\n        if (XBlock.level[XBlock.BotRight[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n        {\n            if (j &gt;= (XParam.blkwidth / 2))\n            {\n                //\n                i = memloc(XParam.halowidth, blkmemwidth, j, 0, ib);\n\n\n                jj = (j - XParam.blkwidth / 2) * 2;\n                il = memloc(XParam.halowidth, blkmemwidth, jj, XParam.blkwidth, XBlock.BotRight[ib]);\n                itl = memloc(XParam.halowidth, blkmemwidth, jj + 1, XParam.blkwidth, XBlock.BotRight[ib]);\n\n                z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n            }\n            //\n        }\n        if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n        {\n            if (j &lt; (XParam.blkwidth / 2))\n            {\n                //\n                i = memloc(XParam.halowidth, blkmemwidth, j, XParam.blkwidth, ib);\n\n\n                jj = j * 2;\n                il = memloc(XParam.halowidth, blkmemwidth, jj, 0, XBlock.TopLeft[ib]);\n                itl = memloc(XParam.halowidth, blkmemwidth, jj + 1, 0, XBlock.TopLeft[ib]);\n\n                z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n            }\n            //\n        }\n        if (XBlock.level[XBlock.TopRight[ib]] &gt; XBlock.level[ib])//The lower half is a boundary \n        {\n            if (j &gt;= (XParam.blkwidth / 2))\n            {\n\n                jj = (j - XParam.blkwidth / 2) * 2;\n                //\n                i = memloc(XParam.halowidth, blkmemwidth, j, XParam.blkwidth, ib);\n\n\n                il = memloc(XParam.halowidth, blkmemwidth, jj, 0, XBlock.TopRight[ib]);\n                itl = memloc(XParam.halowidth, blkmemwidth, jj + 1, 0, XBlock.TopRight[ib]);\n\n                z[i] = T(0.5) * (z[il] + z[itl]);\n\n\n\n\n\n            }\n            //\n        }\n    }\n}\n\n\ntemplate &lt;class T&gt; void fillLeft(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* &amp;z)\n{\n    int jj,bb;\n    int read, write;\n    int ii, ir, it, itr;\n\n\n    if (XBlock.LeftBot[ib] == ib)//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n\n            read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            write = memloc(XParam, -1, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            z[write] = z[read];\n        }\n\n        if (XBlock.LeftTop[ib] == ib) // boundary on the top half too\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, -1, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                write = memloc(XParam, -1, j, ib);\n                jj = (j - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, (XParam.blkwidth - 1), jj, XBlock.LeftTop[ib]);\n                ir = memloc(XParam, (XParam.blkwidth - 2), jj, XBlock.LeftTop[ib]);\n                it = memloc(XParam, (XParam.blkwidth - 1), jj + 1, XBlock.LeftTop[ib]);\n                itr = memloc(XParam, (XParam.blkwidth - 2), jj + 1, XBlock.LeftTop[ib]);\n\n                z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[ XBlock.LeftBot[ib] ]) // LeftTop block does not exist\n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n\n            write = memloc(XParam, -1, j, ib);\n            read = memloc(XParam, (XParam.blkwidth - 1), j, XBlock.LeftBot[ib]);\n            z[write] = z[read];\n        }\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib] ]&gt; XBlock.level[ib])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n\n            write = memloc(XParam, -1, j, ib);\n\n            jj = j * 2;\n            bb = XBlock.LeftBot[ib];\n\n            ii = memloc(XParam, (XParam.blkwidth - 1), jj, bb);\n            ir = memloc(XParam, (XParam.blkwidth - 2), jj, bb);\n            it = memloc(XParam, (XParam.blkwidth - 1), jj + 1, bb);\n            itr = memloc(XParam, (XParam.blkwidth - 2), jj + 1, bb);\n\n            z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.LeftTop[ib] == ib)\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, -1, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n                jj = (j - (XParam.blkwidth / 2)) * 2;\n                bb = XBlock.LeftTop[ib];\n\n                //read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, -1, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                //z[write] = z[read];\n                ii = memloc(XParam, (XParam.blkwidth - 1), jj, bb);\n                ir = memloc(XParam, (XParam.blkwidth - 2), jj, bb);\n                it = memloc(XParam, (XParam.blkwidth - 1), jj + 1, bb);\n                itr = memloc(XParam, (XParam.blkwidth - 2), jj + 1, bb);\n\n                z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            write = memloc(XParam, -1, j, ib);\n\n            T w1, w2, w3;\n\n\n            int jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib? ftoi(ceil(j * (T)0.5)): ftoi(ceil(j * (T)0.5)+ XParam.blkwidth/2);\n            w1 = T(1.0 / 3.0);\n            w2 = ceil(j * (T)0.5) * 2 &gt; j ? T(1.0 / 6.0) : T(0.5);\n            w3 = ceil(j * (T)0.5) * 2 &gt; j ? T(0.5) : T(1.0 / 6.0);\n\n            ii= memloc(XParam, 0, j, ib);\n            ir= memloc(XParam, XParam.blkwidth-1, jj, XBlock.LeftBot[ib]);\n            it = memloc(XParam, XParam.blkwidth-1, jj - 1, XBlock.LeftBot[ib]);\n            //2 scenarios here ib is the rightbot neighbour of the leftbot block or ib is the righttop neighbour\n            if (XBlock.RightBot[XBlock.LeftBot[ib]] == ib)\n            {\n                if (j == 0)\n                {\n                    if (XBlock.BotRight[XBlock.LeftBot[ib]] == XBlock.LeftBot[ib]) // no botom of leftbot block\n                    {\n                        w3 = T(0.5) * (T(1.0) - w1);\n                        w2 = w3;\n                        it = ir;\n\n                    }\n                    else if (XBlock.level[XBlock.BotRight[XBlock.LeftBot[ib]]] &lt; XBlock.level[XBlock.LeftBot[ib]]) // exists but is coarser\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(5.0 / 10.0);\n                        w3 = T(1.0 / 10.0);\n                        it = memloc(XParam, XParam.blkwidth-1, XParam.blkwidth - 1, XBlock.BotRight[XBlock.LeftBot[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.BotRight[XBlock.LeftBot[ib]]] == XBlock.level[XBlock.LeftBot[ib]]) // exists with same level\n                    {\n                        it = memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 1, XBlock.BotRight[XBlock.LeftBot[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.BotRight[XBlock.LeftBot[ib]]] &gt; XBlock.level[XBlock.LeftBot[ib]]) // exists with higher level\n                    {\n                        w1 = T(1.0 / 4.0);\n                        w2 = T(1.0 / 2.0);\n                        w3 = T(1.0 / 4.0);\n                        it = memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 1, XBlock.BotRight[XBlock.LeftBot[ib]]);\n                    }\n\n\n                }\n\n\n            }\n            else//righttopleftif == ib\n            {\n                if (j == (XParam.blkwidth - 1))\n                {\n                    if (XBlock.TopRight[XBlock.LeftTop[ib]] == XBlock.LeftTop[ib]) // no botom of leftbot block\n                    {\n                        w3 = T(0.5*(1.0-w1));\n                        w2 = w3;\n                        ir = it;\n\n                    }\n                    else if (XBlock.level[XBlock.TopRight[XBlock.LeftTop[ib]]] &lt; XBlock.level[XBlock.LeftTop[ib]]) // exists but is coarser\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(1.0 / 10.0);\n                        w3 = T(5.0 / 10.0);\n                        ir = memloc(XParam, XParam.blkwidth - 1,0, XBlock.TopRight[XBlock.LeftTop[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.TopRight[XBlock.LeftTop[ib]]] == XBlock.level[XBlock.LeftTop[ib]]) // exists with same level\n                    {\n                        ir = memloc(XParam, XParam.blkwidth - 1, 0, XBlock.TopRight[XBlock.LeftTop[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.TopRight[XBlock.LeftTop[ib]]] &gt; XBlock.level[XBlock.LeftTop[ib]]) // exists with higher level\n                    {\n                        w1 = T(1.0 / 4.0);\n                        w2 = T(1.0 / 2.0);\n                        w3 = T(1.0 / 4.0);\n                        ir = memloc(XParam, XParam.blkwidth - 1, 0, XBlock.TopRight[XBlock.LeftTop[ib]]);\n                    }\n                }\n                //\n            }\n\n\n            z[write] = w1 * z[ii] + w2 * z[ir] + w3 * z[it];\n\n\n\n        }\n    }\n\n\n\n}\n\n\ntemplate &lt;class T&gt; __global__ void fillLeft(int halowidth, int* active, int * level, int* leftbot, int * lefttop, int * rightbot, int* botright,int * topright, T * a)\n{\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = 0;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = active[ibl];\n\n    int lev = level[ib];\n    int LB = leftbot[ib];\n    int LT = lefttop[ib];\n\n    int RBLB = rightbot[LB];\n    int BRLB = botright[LB];\n    int TRLT = topright[LT];\n\n    int levBRLB = level[BRLB];\n    int levTRLT = level[TRLT];\n    int levLB = level[LB];\n    int levLT = level[LT];\n    int write = memloc(halowidth, blkmemwidth, -1, iy, ib);\n    int read;\n    int jj, ii, ir, it, itr;\n    T a_read;\n    T w1, w2, w3;\n\n    if (LB == ib)\n    {\n        if (iy &lt; (blockDim.y / 2))\n        {\n            read = memloc(halowidth, blkmemwidth, 0, iy, ib);\n            a_read = a[read];\n        }\n        else\n        {\n            if (LT == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, 0, iy, ib);\n                a_read = a[read];\n\n            }\n            else\n            {\n\n                jj = (iy - (blockDim.y / 2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj, LT);\n                ir = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj, LT);\n                it = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj + 1, LT);\n                itr = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj + 1, LT);\n\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n\n    }\n    else if (levLB == lev )\n    {\n        read = memloc(halowidth, blkmemwidth, (blockDim.y - 1), iy, LB);\n        a_read = a[read];\n    }\n    else if (levLB &gt; lev)\n    {\n        if (iy &lt; (blockDim.y / 2))\n        {\n            jj = iy * 2;\n            ii = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj, LB);\n            ir = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj, LB);\n            it = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj + 1, LB);\n            itr = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj + 1, LB);\n            a_read= T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        else\n        {\n            if (LT == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, 0, iy, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (iy - (blockDim.y / 2)) * 2;\n\n                ii = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj, LT);\n                ir = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj, LT);\n                it = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj + 1, LT);\n                itr = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj + 1, LT);\n\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n    }\n    else if (levLB &lt; lev)\n    {\n        jj = RBLB==ib? ceil(iy * (T)0.5): ceil(iy * (T)0.5) + blockDim.y / 2;\n        w1 = (T)1.0 / (T)3.0;\n        w2 = ceil(iy * (T)0.5) * 2 &gt; iy ? T(1.0 / 6.0) : T(0.5);\n        w3 = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.5) : T(1.0 / 6.0);\n\n        ii = memloc(halowidth, blkmemwidth, 0, iy, ib);\n        ir = memloc(halowidth, blkmemwidth, blockDim.y - 1, jj, LB);\n        it = memloc(halowidth, blkmemwidth, blockDim.y - 1, jj - 1, LB);\n        if (RBLB == ib)\n        {\n            if (iy == 0)\n            {\n                if (BRLB == LB)\n                {\n                    w3 = (T)0.5 * (1.0 - w1);\n                    w2 = w3;\n                    it = ir;\n                }\n                else if (levBRLB &lt; levLB)\n                {\n                    w1 = T(4.0 / 10.0);\n                    w2 = T(5.0 / 10.0);\n                    w3 = T(1.0 / 10.0);\n                    it = memloc(halowidth, blkmemwidth, blockDim.y - 1, blockDim.y - 1, BRLB);\n\n                }\n                else if (levBRLB == levLB)\n                {\n                    it = memloc(halowidth, blkmemwidth, blockDim.y - 1, blockDim.y - 1, BRLB);\n                }\n                else if (levBRLB &gt; levLB)\n                {\n                    w1 = T(1.0 / 4.0);\n                    w2 = T(1.0 / 2.0);\n                    w3 = T(1.0 / 4.0);\n                    it = memloc(halowidth, blkmemwidth, blockDim.y - 1, blockDim.y - 1, BRLB);\n                }\n            }\n        }\n        else\n        {\n            if (iy == (blockDim.y - 1))\n            {\n                if (TRLT == LT)\n                {\n                    w3 = 0.5 * (1.0 - w1);\n                    w2 = w3;\n                    ir = it;\n                }\n                else if (levTRLT &lt; levLT)\n                {\n                    w1 = 4.0 / 10.0;\n                    w2 = 1.0 / 10.0;\n                    w3 = 5.0 / 10.0;\n                    ir = memloc(halowidth, blkmemwidth, blockDim.y - 1, 0, TRLT);\n                }\n                else if (levTRLT == levLT)\n                {\n                    ir = memloc(halowidth, blkmemwidth, blockDim.y - 1, 0, TRLT);\n                }\n                else if (levTRLT &gt; levLT)\n                {\n                    w1 = 1.0 / 4.0;\n                    w2 = 1.0 / 2.0;\n                    w3 = 1.0 / 4.0;\n                    ir = memloc(halowidth, blkmemwidth, blockDim.y - 1, 0, TRLT);\n\n                }\n            }\n        }\n        a_read = w1 * a[ii] + w2 * a[ir] + w3 * a[it];\n    }\n\n    a[write] = a_read;\n}\ntemplate __global__ void fillLeft&lt;float&gt;(int halowidth, int* active, int* level, int* leftbot, int* lefttop, int* rightbot, int* botright, int* topright, float* a);\ntemplate __global__ void fillLeft&lt;double&gt;(int halowidth, int* active, int* level, int* leftbot, int* lefttop, int* rightbot, int* botright, int* topright, double* a);\n\ntemplate &lt;class T&gt; __global__ void fillLeftnew(int halowidth, int nblk, int* active, int* level, int* leftbot, int* lefttop, int* rightbot, int* botright, int* topright, T* a)\n{\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = 0;\n    int iy = threadIdx.y;\n    //need to take min of ibl or total number of blks in case nblk is not dividable by 2\n    int ibl = threadIdx.x + blockIdx.x * blockDim.x;;\n    if (ibl &lt; nblk)\n    {\n\n\n        int ib = active[ibl];\n\n        int lev = level[ib];\n        int LB = leftbot[ib];\n        int LT = lefttop[ib];\n\n        int RBLB = rightbot[LB];\n        int BRLB = botright[LB];\n        int TRLT = topright[LT];\n\n        int levBRLB = level[BRLB];\n        int levTRLT = level[TRLT];\n        int levLB = level[LB];\n        int levLT = level[LT];\n        int write = memloc(halowidth, blkmemwidth, -1, iy, ib);\n        int read;\n        int jj, ii, ir, it, itr;\n        T a_read;\n        T w1, w2, w3;\n\n        if (LB == ib)\n        {\n            if (iy &lt; (blockDim.y / 2))\n            {\n                read = memloc(halowidth, blkmemwidth, 0, iy, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                if (LT == ib)\n                {\n                    read = memloc(halowidth, blkmemwidth, 0, iy, ib);\n                    a_read = a[read];\n\n                }\n                else\n                {\n\n                    jj = (iy - (blockDim.y / 2)) * 2;\n                    ii = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj, LT);\n                    ir = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj, LT);\n                    it = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj + 1, LT);\n                    itr = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj + 1, LT);\n\n                    a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n\n        }\n        else if (levLB == lev)\n        {\n            read = memloc(halowidth, blkmemwidth, (blockDim.y - 1), iy, LB);\n            a_read = a[read];\n        }\n        else if (levLB &gt; lev)\n        {\n            if (iy &lt; (blockDim.y / 2))\n            {\n                jj = iy * 2;\n                ii = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj, LB);\n                ir = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj, LB);\n                it = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj + 1, LB);\n                itr = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj + 1, LB);\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n            else\n            {\n                if (LT == ib)\n                {\n                    read = memloc(halowidth, blkmemwidth, 0, iy, ib);\n                    a_read = a[read];\n                }\n                else\n                {\n                    jj = (iy - (blockDim.y / 2)) * 2;\n\n                    ii = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj, LT);\n                    ir = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj, LT);\n                    it = memloc(halowidth, blkmemwidth, (blockDim.y - 1), jj + 1, LT);\n                    itr = memloc(halowidth, blkmemwidth, (blockDim.y - 2), jj + 1, LT);\n\n                    a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n        }\n        else if (levLB &lt; lev)\n        {\n            jj = RBLB == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + blockDim.y / 2;\n            w1 = (T)1.0 / (T)3.0;\n            w2 = ceil(iy * (T)0.5) * 2 &gt; iy ? T(1.0 / 6.0) : T(0.5);\n            w3 = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.5) : T(1.0 / 6.0);\n\n            ii = memloc(halowidth, blkmemwidth, 0, iy, ib);\n            ir = memloc(halowidth, blkmemwidth, blockDim.y - 1, jj, LB);\n            it = memloc(halowidth, blkmemwidth, blockDim.y - 1, jj - 1, LB);\n            if (RBLB == ib)\n            {\n                if (iy == 0)\n                {\n                    if (BRLB == LB)\n                    {\n                        w3 = (T)0.5 * (1.0 - w1);\n                        w2 = w3;\n                        it = ir;\n                    }\n                    else if (levBRLB &lt; levLB)\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(5.0 / 10.0);\n                        w3 = T(1.0 / 10.0);\n                        it = memloc(halowidth, blkmemwidth, blockDim.y - 1, blockDim.y - 1, BRLB);\n\n                    }\n                    else if (levBRLB == levLB)\n                    {\n                        it = memloc(halowidth, blkmemwidth, blockDim.y - 1, blockDim.y - 1, BRLB);\n                    }\n                    else if (levBRLB &gt; levLB)\n                    {\n                        w1 = T(1.0 / 4.0);\n                        w2 = T(1.0 / 2.0);\n                        w3 = T(1.0 / 4.0);\n                        it = memloc(halowidth, blkmemwidth, blockDim.y - 1, blockDim.y - 1, BRLB);\n                    }\n                }\n            }\n            else\n            {\n                if (iy == (blockDim.y - 1))\n                {\n                    if (TRLT == LT)\n                    {\n                        w3 = 0.5 * (1.0 - w1);\n                        w2 = w3;\n                        ir = it;\n                    }\n                    else if (levTRLT &lt; levLT)\n                    {\n                        w1 = 4.0 / 10.0;\n                        w2 = 1.0 / 10.0;\n                        w3 = 5.0 / 10.0;\n                        ir = memloc(halowidth, blkmemwidth, blockDim.y - 1, 0, TRLT);\n                    }\n                    else if (levTRLT == levLT)\n                    {\n                        ir = memloc(halowidth, blkmemwidth, blockDim.y - 1, 0, TRLT);\n                    }\n                    else if (levTRLT &gt; levLT)\n                    {\n                        w1 = 1.0 / 4.0;\n                        w2 = 1.0 / 2.0;\n                        w3 = 1.0 / 4.0;\n                        ir = memloc(halowidth, blkmemwidth, blockDim.y - 1, 0, TRLT);\n\n                    }\n                }\n            }\n            a_read = w1 * a[ii] + w2 * a[ir] + w3 * a[it];\n        }\n\n        a[write] = a_read;\n    }\n}\ntemplate __global__ void fillLeftnew&lt;float&gt;(int halowidth, int nblk, int* active, int* level, int* leftbot, int* lefttop, int* rightbot, int* botright, int* topright, float* a);\ntemplate __global__ void fillLeftnew&lt;double&gt;(int halowidth, int nblk, int* active, int* level, int* leftbot, int* lefttop, int* rightbot, int* botright, int* topright, double* a);\n\ntemplate &lt;class T&gt; void fillLeftFlux(Param XParam, bool doProlongation, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    int jj, bb;\n    int read, write;\n    int ii,  it;\n\n\n    if (XBlock.LeftBot[ib] == ib)//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n\n            read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            write = memloc(XParam, -1, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            z[write] = z[read];\n        }\n\n        if (XBlock.LeftTop[ib] == ib) // boundary on the top half too\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, -1, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                write = memloc(XParam, -1, j, ib);\n                jj = (j - XParam.blkwidth / 2) * 2;\n                ii = memloc(XParam, (XParam.blkwidth - 1), jj, XBlock.LeftTop[ib]);\n                //ir = memloc(XParam, (XParam.blkwidth - 2), jj, XBlock.LeftTop[ib]);\n                it = memloc(XParam, (XParam.blkwidth - 1), jj + 1, XBlock.LeftTop[ib]);\n                //itr = memloc(XParam, (XParam.blkwidth - 2), jj + 1, XBlock.LeftTop[ib]);\n\n                z[write] = T(0.5) * (z[ii]  + z[it]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.LeftBot[ib]]) // LeftTop block does not exist\n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n\n            write = memloc(XParam, -1, j, ib);\n            read = memloc(XParam, (XParam.blkwidth - 1), j, XBlock.LeftBot[ib]);\n            z[write] = z[read];\n        }\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n\n            write = memloc(XParam, -1, j, ib);\n\n            jj = j * 2;\n            bb = XBlock.LeftBot[ib];\n\n            ii = memloc(XParam, (XParam.blkwidth - 1), jj, bb);\n            //ir = memloc(XParam, (XParam.blkwidth - 2), jj, bb);\n            it = memloc(XParam, (XParam.blkwidth - 1), jj + 1, bb);\n            //itr = memloc(XParam, (XParam.blkwidth - 2), jj + 1, bb);\n\n            z[write] = T(0.5) * (z[ii] + z[it]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.LeftTop[ib] == ib)\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, -1, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n                jj = (j - 8) * 2;\n                bb = XBlock.LeftTop[ib];\n\n                //read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, -1, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                //z[write] = z[read];\n                ii = memloc(XParam, (XParam.blkwidth - 1), jj, bb);\n                //ir = memloc(XParam, (XParam.blkwidth - 2), jj, bb);\n                it = memloc(XParam, (XParam.blkwidth - 1), jj + 1, bb);\n                //itr = memloc(XParam, (XParam.blkwidth - 2), jj + 1, bb);\n\n                z[write] = T(0.5) * (z[ii] + z[it]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.LeftBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            write = memloc(XParam, -1, j, ib);\n\n            //T w1, w2, w3;\n\n\n            int jj = XBlock.RightBot[XBlock.LeftBot[ib]] == ib ? ftoi(ceil(j * (T)0.5)) : ftoi(ceil(j * (T)0.5) + XParam.blkwidth / 2);\n\n\n            ii = memloc(XParam, XParam.blkwidth - 1, jj, XBlock.LeftBot[ib]);\n            if (doProlongation)\n                z[write] = z[ii];\n\n\n\n        }\n    }\n\n\n\n}\n\n\ntemplate &lt;class T&gt; void fillRight(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    int jj, bb;\n    int read, write;\n    int ii, ir, it, itr;\n\n\n    if (XBlock.RightBot[ib] == ib)//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n\n            read = memloc(XParam, XParam.blkwidth-1, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            write = memloc(XParam, XParam.blkwidth, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            z[write] = z[read];\n        }\n\n        if (XBlock.RightTop[ib] == ib) // boundary on the top half too\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, XParam.blkwidth - 1, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, XParam.blkwidth, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n\n\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                write = memloc(XParam, XParam.blkwidth, j, ib);\n                jj = (j - (XParam.blkwidth / 2)) * 2;\n                ii = memloc(XParam, 0, jj, XBlock.RightTop[ib]);\n                ir = memloc(XParam, 1, jj, XBlock.RightTop[ib]);\n                it = memloc(XParam, 0, jj + 1, XBlock.RightTop[ib]);\n                itr = memloc(XParam, 1, jj + 1, XBlock.RightTop[ib]);\n\n                z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.RightBot[ib]]) // LeftTop block does not exist\n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n\n            write = memloc(XParam, XParam.blkwidth, j, ib);\n            read = memloc(XParam, 0, j, XBlock.RightBot[ib]);\n            z[write] = z[read];\n        }\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n\n            write = memloc(XParam, XParam.blkwidth, j, ib);\n\n            jj = j * 2;\n            bb = XBlock.RightBot[ib];\n\n            ii = memloc(XParam, 0, jj, bb);\n            ir = memloc(XParam, 1, jj, bb);\n            it = memloc(XParam, 0, jj + 1, bb);\n            itr = memloc(XParam, 1, jj + 1, bb);\n\n            z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.RightTop[ib] == ib)\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, XParam.blkwidth-1, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, XParam.blkwidth, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n                jj = (j - (XParam.blkwidth / 2)) * 2;\n                bb = XBlock.RightTop[ib];\n\n                //read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, XParam.blkwidth, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                //z[write] = z[read];\n                ii = memloc(XParam, 0, jj, bb);\n                ir = memloc(XParam, 1, jj, bb);\n                it = memloc(XParam, 0, jj + 1, bb);\n                itr = memloc(XParam, 1, jj + 1, bb);\n\n                z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            write = memloc(XParam, XParam.blkwidth, j, ib);\n\n            T w1, w2, w3;\n\n\n            int jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? ftoi(ceil(j * (T)0.5)) : ftoi(ceil(j * (T)0.5) + XParam.blkwidth / 2);\n            w1 = T(1.0 / 3.0);\n            w2 = ceil(j * (T)0.5) * 2 &gt; j ? T(1.0 / 6.0) : T(0.5);\n            w3 = ceil(j * (T)0.5) * 2 &gt; j ? T(0.5) : T(1.0 / 6.0);\n\n            ii = memloc(XParam, XParam.blkwidth-1, j, ib);\n            ir = memloc(XParam, 0, jj, XBlock.RightBot[ib]);\n            it = memloc(XParam, 0, jj - 1, XBlock.RightBot[ib]);\n            //2 scenarios here ib is the leftbot neighbour of the rightbot block or ib is the lefttop neighbour\n            if (XBlock.LeftBot[XBlock.RightBot[ib]] == ib)\n            {\n                if (j == 0)\n                {\n                    if (XBlock.BotLeft[XBlock.RightBot[ib]] == XBlock.RightBot[ib]) // no botom of leftbot block\n                    {\n                        w3 = T(0.5 * (1.0 - w1));\n                        w2 = w3;\n                        it = ir;\n\n                    }\n                    else if (XBlock.level[XBlock.BotLeft[XBlock.RightBot[ib]]] &lt; XBlock.level[XBlock.RightBot[ib]]) // exists but is coarser\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(5.0 / 10.0);\n                        w3 = T(1.0 / 10.0);\n                        it = memloc(XParam, 0, XParam.blkwidth - 1, XBlock.BotLeft[XBlock.RightBot[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.BotLeft[XBlock.RightBot[ib]]] == XBlock.level[XBlock.RightBot[ib]]) // exists with same level\n                    {\n                        it = memloc(XParam, 0, XParam.blkwidth - 1, XBlock.BotLeft[XBlock.RightBot[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.BotLeft[XBlock.RightBot[ib]]] &gt; XBlock.level[XBlock.RightBot[ib]]) // exists with higher level\n                    {\n                        w1 = T(1.0 / 4.0);\n                        w2 = T(1.0 / 2.0);\n                        w3 = T(1.0 / 4.0);\n                        it = memloc(XParam, 0, XParam.blkwidth - 1, XBlock.BotLeft[XBlock.RightBot[ib]]);\n                    }\n\n\n                }\n\n\n            }\n            else//\n            {\n                if (j == (XParam.blkwidth - 1))\n                {\n                    if (XBlock.TopLeft[XBlock.RightTop[ib]] == XBlock.RightTop[ib]) // no botom of leftbot block\n                    {\n                        w3 = T(0.5 * (1.0 - w1));\n                        w2 = w3;\n                        ir = it;\n\n                    }\n                    else if (XBlock.level[XBlock.TopLeft[XBlock.RightTop[ib]]] &lt; XBlock.level[XBlock.RightTop[ib]]) // exists but is coarser\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(1.0 / 10.0);\n                        w3 = T(5.0 / 10.0);\n                        ir = memloc(XParam, 0, 0, XBlock.TopLeft[XBlock.RightTop[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.TopLeft[XBlock.RightTop[ib]]] == XBlock.level[XBlock.RightTop[ib]]) // exists with same level\n                    {\n                        ir = memloc(XParam, 0, 0, XBlock.TopLeft[XBlock.RightTop[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.TopLeft[XBlock.RightTop[ib]]] &gt; XBlock.level[XBlock.RightTop[ib]]) // exists with higher level\n                    {\n                        w1 = 1.0 / 4.0;\n                        w2 = 1.0 / 2.0;\n                        w3 = 1.0 / 4.0;\n                        ir = memloc(XParam, 0, 0, XBlock.TopLeft[XBlock.RightTop[ib]]);\n                    }\n                }\n                //\n            }\n\n\n            z[write] = w1 * z[ii] + w2 * z[ir] + w3 * z[it];\n        }\n    }\n\n\n\n}\n\n\ntemplate &lt;class T&gt; __global__ void fillRight(int halowidth, int* active, int* level, int * rightbot,int* righttop,int * leftbot,int*botleft,int* topleft, T* a)\n{\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = blockDim.y - 1;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = active[ibl];\n\n    int RB = rightbot[ib];\n    int RT = righttop[ib];\n    //int LB = leftbot[ib];\n    //int BL = botleft[ib];\n    int LBRB = leftbot[RB];\n    int TLRT = topleft[RT];\n    int BLRB = botleft[RB];\n\n\n    int lev = level[ib];\n    int levRB = level[RB];\n    int levRT = level[RT];\n    int levBLRB = level[BLRB];\n    int levTLRT = level[TLRT];\n\n    int write = memloc(halowidth, blkmemwidth, blockDim.y, iy, ib);\n    int read;\n    int jj, ii, ir, it, itr;\n    T a_read;\n    T w1, w2, w3;\n\n\n    if (RB == ib)\n    {\n        if (iy &lt; (blockDim.y / 2))\n        {\n            read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n            a_read = a[read];\n        }\n        else\n        {\n            if (RT == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (iy - (blockDim.y / 2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, 0, jj, RT);\n                ir = memloc(halowidth, blkmemwidth, 1, jj, RT);\n                it = memloc(halowidth, blkmemwidth, 0, jj + 1, RT);\n                itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RT);\n\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n    }\n    else if (levRB == lev)\n    {\n        read = memloc(halowidth, blkmemwidth, 0, iy, RB);\n        a_read = a[read];\n    }\n    else if (levRB &gt; lev)\n    {\n        if (iy &lt; (blockDim.y / 2))\n        {\n            jj = iy * 2;\n\n\n            ii = memloc(halowidth, blkmemwidth, 0, jj, RB);\n            ir = memloc(halowidth, blkmemwidth, 1, jj, RB);\n            it = memloc(halowidth, blkmemwidth, 0, jj + 1, RB);\n            itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RB);\n\n            a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        else\n        {\n            if (RT == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (iy - (blockDim.y / 2)) * 2;\n\n                ii = memloc(halowidth, blkmemwidth, 0, jj, RT);\n                ir = memloc(halowidth, blkmemwidth, 1, jj, RT);\n                it = memloc(halowidth, blkmemwidth, 0, jj + 1, RT);\n                itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RT);\n\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n    }\n    else if (levRB &lt; lev)\n    {\n        //\n        jj = LBRB == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + blockDim.y / 2;\n        w1 = 1.0 / 3.0;\n        w2 = ceil(iy * (T)0.5) * 2 &gt; iy ? T(1.0 / 6.0) : T(0.5);\n        w3 = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.5) : T(1.0 / 6.0);\n        ii = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n        ir = memloc(halowidth, blkmemwidth, 0, jj, RB);\n        it = memloc(halowidth, blkmemwidth, 0, jj - 1, RB);\n        if (LBRB == ib)\n        {\n            if (iy == 0)\n            {\n                if (BLRB == RB)\n                {\n                    w3 = 0.5 * (1.0 - w1);\n                    w2 = w3;\n                    it = ir;\n                }\n                else if (levBLRB &lt; levRB)\n                {\n                    w1 = 4.0 / 10.0;\n                    w2 = 5.0 / 10.0;\n                    w3 = 1.0 / 10.0;\n                    it = memloc(halowidth, blkmemwidth, 0, blockDim.y - 1, BLRB);\n                }\n                else if (levBLRB == levRB)\n                {\n                    it = memloc(halowidth, blkmemwidth, 0, blockDim.y - 1, BLRB);\n                }\n                else if (levBLRB &gt; levRB)\n                {\n                    w1 = 1.0 / 4.0;\n                    w2 = 1.0 / 2.0;\n                    w3 = 1.0 / 4.0;\n                    it = memloc(halowidth, blkmemwidth, 0, blockDim.y - 1, BLRB);\n                }\n            }\n        }\n        else\n        {\n            if (iy == (blockDim.y - 1))\n            {\n                if (TLRT == RT)\n                {\n                    w3 = 0.5 * (1.0 - w1);\n                    w2 = w3;\n                    ir = it;\n                }\n                else if (levTLRT &lt; levRT)\n                {\n                    w1 = 4.0 / 10.0;\n                    w2 = 1.0 / 10.0;\n                    w3 = 5.0 / 10.0;\n                    ir = memloc(halowidth, blkmemwidth, 0, 0, TLRT);\n                }\n                else if (levTLRT == levRT)\n                {\n                    ir = memloc(halowidth, blkmemwidth, 0, 0, TLRT);\n                }\n                else if (levTLRT &gt; levRT)\n                {\n                    w1 = 1.0 / 4.0;\n                    w2 = 1.0 / 2.0;\n                    w3 = 1.0 / 4.0;\n                    ir = memloc(halowidth, blkmemwidth, 0, 0, TLRT);\n                }\n            }\n        }\n\n        a_read= w1 * a[ii] + w2 * a[ir] + w3 * a[it];\n    }\n    a[write] = a_read;\n}\n\ntemplate __global__ void fillRight&lt;float&gt;(int halowidth, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, float* a);\ntemplate __global__ void fillRight&lt;double&gt;(int halowidth, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, double* a);\n\ntemplate &lt;class T&gt; __global__ void fillRightnew(int halowidth,int nblk, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, T* a)\n{\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = blockDim.y - 1;\n    int iy = threadIdx.y;\n    int ibl = threadIdx.x + blockIdx.x * blockDim.x;\n    if (ibl &lt; nblk)\n    {\n        int ib = active[ibl];\n\n        int RB = rightbot[ib];\n        int RT = righttop[ib];\n        //int LB = leftbot[ib];\n        //int BL = botleft[ib];\n        int LBRB = leftbot[RB];\n        int TLRT = topleft[RT];\n        int BLRB = botleft[RB];\n\n\n        int lev = level[ib];\n        int levRB = level[RB];\n        int levRT = level[RT];\n        int levBLRB = level[BLRB];\n        int levTLRT = level[TLRT];\n\n        int write = memloc(halowidth, blkmemwidth, blockDim.y, iy, ib);\n        int read;\n        int jj, ii, ir, it, itr;\n        T a_read;\n        T w1, w2, w3;\n\n\n        if (RB == ib)\n        {\n            if (iy &lt; (blockDim.y / 2))\n            {\n                read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                if (RT == ib)\n                {\n                    read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n                    a_read = a[read];\n                }\n                else\n                {\n                    jj = (iy - (blockDim.y / 2)) * 2;\n                    ii = memloc(halowidth, blkmemwidth, 0, jj, RT);\n                    ir = memloc(halowidth, blkmemwidth, 1, jj, RT);\n                    it = memloc(halowidth, blkmemwidth, 0, jj + 1, RT);\n                    itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RT);\n\n                    a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n        }\n        else if (levRB == lev)\n        {\n            read = memloc(halowidth, blkmemwidth, 0, iy, RB);\n            a_read = a[read];\n        }\n        else if (levRB &gt; lev)\n        {\n            if (iy &lt; (blockDim.y / 2))\n            {\n                jj = iy * 2;\n\n\n                ii = memloc(halowidth, blkmemwidth, 0, jj, RB);\n                ir = memloc(halowidth, blkmemwidth, 1, jj, RB);\n                it = memloc(halowidth, blkmemwidth, 0, jj + 1, RB);\n                itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RB);\n\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n            else\n            {\n                if (RT == ib)\n                {\n                    read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n                    a_read = a[read];\n                }\n                else\n                {\n                    jj = (iy - (blockDim.y / 2)) * 2;\n\n                    ii = memloc(halowidth, blkmemwidth, 0, jj, RT);\n                    ir = memloc(halowidth, blkmemwidth, 1, jj, RT);\n                    it = memloc(halowidth, blkmemwidth, 0, jj + 1, RT);\n                    itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RT);\n\n                    a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n        }\n        else if (levRB &lt; lev)\n        {\n            //\n            jj = LBRB == ib ? ceil(iy * (T)0.5) : ceil(iy * (T)0.5) + blockDim.y / 2;\n            w1 = 1.0 / 3.0;\n            w2 = ceil(iy * (T)0.5) * 2 &gt; iy ? T(1.0 / 6.0) : T(0.5);\n            w3 = ceil(iy * (T)0.5) * 2 &gt; iy ? T(0.5) : T(1.0 / 6.0);\n            ii = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n            ir = memloc(halowidth, blkmemwidth, 0, jj, RB);\n            it = memloc(halowidth, blkmemwidth, 0, jj - 1, RB);\n            if (LBRB == ib)\n            {\n                if (iy == 0)\n                {\n                    if (BLRB == RB)\n                    {\n                        w3 = 0.5 * (1.0 - w1);\n                        w2 = w3;\n                        it = ir;\n                    }\n                    else if (levBLRB &lt; levRB)\n                    {\n                        w1 = 4.0 / 10.0;\n                        w2 = 5.0 / 10.0;\n                        w3 = 1.0 / 10.0;\n                        it = memloc(halowidth, blkmemwidth, 0, blockDim.y - 1, BLRB);\n                    }\n                    else if (levBLRB == levRB)\n                    {\n                        it = memloc(halowidth, blkmemwidth, 0, blockDim.y - 1, BLRB);\n                    }\n                    else if (levBLRB &gt; levRB)\n                    {\n                        w1 = 1.0 / 4.0;\n                        w2 = 1.0 / 2.0;\n                        w3 = 1.0 / 4.0;\n                        it = memloc(halowidth, blkmemwidth, 0, blockDim.y - 1, BLRB);\n                    }\n                }\n            }\n            else\n            {\n                if (iy == (blockDim.y - 1))\n                {\n                    if (TLRT == RT)\n                    {\n                        w3 = 0.5 * (1.0 - w1);\n                        w2 = w3;\n                        ir = it;\n                    }\n                    else if (levTLRT &lt; levRT)\n                    {\n                        w1 = 4.0 / 10.0;\n                        w2 = 1.0 / 10.0;\n                        w3 = 5.0 / 10.0;\n                        ir = memloc(halowidth, blkmemwidth, 0, 0, TLRT);\n                    }\n                    else if (levTLRT == levRT)\n                    {\n                        ir = memloc(halowidth, blkmemwidth, 0, 0, TLRT);\n                    }\n                    else if (levTLRT &gt; levRT)\n                    {\n                        w1 = 1.0 / 4.0;\n                        w2 = 1.0 / 2.0;\n                        w3 = 1.0 / 4.0;\n                        ir = memloc(halowidth, blkmemwidth, 0, 0, TLRT);\n                    }\n                }\n            }\n\n            a_read = w1 * a[ii] + w2 * a[ir] + w3 * a[it];\n        }\n        a[write] = a_read;\n    }\n}\n\ntemplate __global__ void fillRightnew&lt;float&gt;(int halowidth, int nblk, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, float* a);\ntemplate __global__ void fillRightnew&lt;double&gt;(int halowidth, int nblk, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, double* a);\n\n\ntemplate &lt;class T&gt; void fillRightFlux(Param XParam, bool doProlongation, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    int jj, bb;\n    int read, write;\n    int ii, it;\n\n\n    if (XBlock.RightBot[ib] == ib)//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n\n            read = memloc(XParam, XParam.blkwidth - 1, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            write = memloc(XParam, XParam.blkwidth, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            z[write] = z[read];\n        }\n\n        if (XBlock.RightTop[ib] == ib) // boundary on the top half too\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, XParam.blkwidth - 1, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, XParam.blkwidth, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                write = memloc(XParam, XParam.blkwidth, j, ib);\n                jj = (j - 8) * 2;\n                ii = memloc(XParam, 0, jj, XBlock.RightTop[ib]);\n                //ir = memloc(XParam, 1, jj, XBlock.RightTop[ib]);\n                it = memloc(XParam, 0, jj + 1, XBlock.RightTop[ib]);\n                //itr = memloc(XParam, 1, jj + 1, XBlock.RightTop[ib]);\n\n                z[write] = T(0.5) * (z[ii] + z[it]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.RightBot[ib]]) // LeftTop block does not exist\n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n\n            write = memloc(XParam, XParam.blkwidth, j, ib);\n            read = memloc(XParam, 0, j, XBlock.RightBot[ib]);\n            z[write] = z[read];\n        }\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &gt; XBlock.level[ib])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n\n            write = memloc(XParam, XParam.blkwidth, j, ib);\n\n            jj = j * 2;\n            bb = XBlock.RightBot[ib];\n\n            ii = memloc(XParam, 0, jj, bb);\n            //ir = memloc(XParam, 1, jj, bb);\n            it = memloc(XParam, 0, jj + 1, bb);\n            //itr = memloc(XParam, 1, jj + 1, bb);\n\n            //z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n            z[write] = T(0.5) * (z[ii] + z[it]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.RightTop[ib] == ib)\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, XParam.blkwidth - 1, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, XParam.blkwidth, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n                jj = (j - 8) * 2;\n                bb = XBlock.RightTop[ib];\n\n                //read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, XParam.blkwidth, j, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                //z[write] = z[read];\n                ii = memloc(XParam, 0, jj, bb);\n                //ir = memloc(XParam, 1, jj, bb);\n                it = memloc(XParam, 0, jj + 1, bb);\n                //itr = memloc(XParam, 1, jj + 1, bb);\n                z[write] = T(0.5) * (z[ii] + z[it]);\n                //z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.RightBot[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            write = memloc(XParam, XParam.blkwidth, j, ib);\n\n\n            int jj = XBlock.LeftBot[XBlock.RightBot[ib]] == ib ? ftoi(floor(j * (T)0.5)) : ftoi(floor(j * (T)0.5) + XParam.blkwidth / 2);\n\n            ii = memloc(XParam, 0, jj, XBlock.RightBot[ib]);\n            if (doProlongation)\n                z[write] = z[ii];\n        }\n    }\n\n\n\n}\n\ntemplate void fillRightFlux&lt;float&gt;(Param XParam, bool doProlongation, int ib, BlockP&lt;float&gt; XBlock, float*&amp; z);\ntemplate void fillRightFlux&lt;double&gt;(Param XParam, bool doProlongation, int ib, BlockP&lt;double&gt; XBlock, double*&amp; z);\n\n\ntemplate &lt;class T&gt; __global__ void fillRightFlux(int halowidth, bool doProlongation, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, T* a)\n{\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    //unsigned int ix = blockDim.y - 1;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = active[ibl];\n\n    int RB = rightbot[ib];\n    int RT = righttop[ib];\n    //int LB = leftbot[ib];\n    //int BL = botleft[ib];\n    int LBRB = leftbot[RB];\n    //int TLRT = topleft[RT];\n    //int BLRB = botleft[RB];\n\n\n    int lev = level[ib];\n    int levRB = level[RB];\n    //int levRT = level[RT];\n    //int levBLRB = level[BLRB];\n    //int levTLRT = level[TLRT];\n\n    int write = memloc(halowidth, blkmemwidth, blockDim.y, iy, ib);\n    int read;\n    int jj, ii, ir, it;\n    T a_read;\n    //T w1, w2;\n\n\n    if (RB == ib)\n    {\n        if (iy &lt; (blockDim.y / 2))\n        {\n            read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n            a_read = a[read];\n        }\n        else\n        {\n            if (RT == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (iy - (blockDim.y / 2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, 0, jj, RT);\n                //ir = memloc(halowidth, blkmemwidth, 1, jj, RT);\n                it = memloc(halowidth, blkmemwidth, 0, jj + 1, RT);\n                //itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RT);\n\n                a_read = T(0.5) * (a[ii] + a[it]);\n            }\n        }\n    }\n    else if (levRB == lev)\n    {\n        read = memloc(halowidth, blkmemwidth, 0, iy, RB);\n        a_read = a[read];\n    }\n    else if (levRB &gt; lev)\n    {\n        if (iy &lt; (blockDim.y / 2))\n        {\n            jj = iy * 2;\n\n\n            ii = memloc(halowidth, blkmemwidth, 0, jj, RB);\n            //ir = memloc(halowidth, blkmemwidth, 1, jj, RB);\n            it = memloc(halowidth, blkmemwidth, 0, jj + 1, RB);\n            //itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RB);\n\n            a_read = T(0.5) * (a[ii] + a[it]);\n        }\n        else\n        {\n            if (RT == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, blockDim.y - 1, iy, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (iy - (blockDim.y / 2)) * 2;\n\n                ii = memloc(halowidth, blkmemwidth, 0, jj, RT);\n                //ir = memloc(halowidth, blkmemwidth, 1, jj, RT);\n                it = memloc(halowidth, blkmemwidth, 0, jj + 1, RT);\n                //itr = memloc(halowidth, blkmemwidth, 1, jj + 1, RT);\n\n                a_read = T(0.5) * (a[ii] + a[it] );\n            }\n        }\n    }\n    else if (levRB &lt; lev)\n    {\n        //\n        jj = LBRB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n\n\n        ir = memloc(halowidth, blkmemwidth, 0, jj, RB);\n\n        if (doProlongation)\n            a_read = a[ir];\n\n        else\n            a_read = a[write];\n    }\n    a[write] = a_read;\n}\ntemplate __global__ void fillRightFlux&lt;float&gt;(int halowidth, bool doProlongation, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, float* a);\ntemplate __global__ void fillRightFlux&lt;double&gt;(int halowidth, bool doProlongation, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, double* a);\n\n\ntemplate &lt;class T&gt; void fillBot(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    int jj, bb;\n    int read, write;\n    int ii, ir, it, itr;\n\n\n    if (XBlock.BotLeft[ib] == ib)//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n\n            read = memloc(XParam, j, 0, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            write = memloc(XParam, j, -1, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            z[write] = z[read];\n        }\n\n        if (XBlock.BotRight[ib] == ib) // boundary on the top half too\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, j, 0, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, -1, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                write = memloc(XParam,j, -1, ib);\n                jj = (j - 8) * 2;\n                ii = memloc(XParam,jj, (XParam.blkwidth - 1), XBlock.BotRight[ib]);\n                ir = memloc(XParam,jj, (XParam.blkwidth - 2), XBlock.BotRight[ib]);\n                it = memloc(XParam,jj+1, (XParam.blkwidth - 1), XBlock.BotRight[ib]);\n                itr = memloc(XParam,jj+1, (XParam.blkwidth - 2), XBlock.BotRight[ib]);\n\n                z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.BotLeft[ib]]) // LeftTop block does not exist\n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n\n            write = memloc(XParam,j, -1, ib);\n            read = memloc(XParam, j, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n            z[write] = z[read];\n        }\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n\n            write = memloc(XParam, j, -1, ib);\n\n            jj = j * 2;\n            bb = XBlock.BotLeft[ib];\n\n            ii = memloc(XParam, jj, (XParam.blkwidth - 1), bb);\n            ir = memloc(XParam, jj, (XParam.blkwidth - 2), bb);\n            it = memloc(XParam, jj + 1, (XParam.blkwidth - 1), bb);\n            itr = memloc(XParam, jj + 1, (XParam.blkwidth - 2), bb);\n\n            z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n        }\n        //now find out aboy botright block\n        if (XBlock.BotRight[ib] == ib)\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, j, 0, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, -1, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n                jj = (j - 8) * 2;\n                bb = XBlock.BotRight[ib];\n\n                //read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, -1, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                //z[write] = z[read];\n                ii = memloc(XParam, jj, (XParam.blkwidth - 1), bb);\n                ir = memloc(XParam, jj, (XParam.blkwidth - 2), bb);\n                it = memloc(XParam, jj + 1, (XParam.blkwidth - 1), bb);\n                itr = memloc(XParam, jj + 1, (XParam.blkwidth - 2), bb);\n\n                z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            write = memloc(XParam, j, -1, ib);\n\n            T w1, w2, w3;\n\n\n            int jj = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? ftoi(ceil(j * (T)0.5)) : ftoi(ceil(j * (T)0.5) + XParam.blkwidth / 2);\n            w1 = T(1.0 / 3.0);\n            w2 = ceil(j * (T)0.5) * 2 &gt; j ? T(1.0 / 6.0) : T(0.5);\n            w3 = ceil(j * (T)0.5) * 2 &gt; j ? T(0.5) : T(1.0 / 6.0);\n\n            ii = memloc(XParam, j, 0, ib);\n            ir = memloc(XParam, jj, XParam.blkwidth - 1, XBlock.BotLeft[ib]);\n            it = memloc(XParam, jj -1, XParam.blkwidth - 1, XBlock.BotLeft[ib]);\n            //2 scenarios here ib is the rightbot neighbour of the leftbot block or ib is the righttop neighbour\n            if (XBlock.TopLeft[XBlock.BotLeft[ib]] == ib)\n            {\n                if (j == 0)\n                {\n                    if (XBlock.LeftTop[XBlock.BotLeft[ib]] == XBlock.BotLeft[ib]) // no botom of leftbot block\n                    {\n                        w3 = T(0.5 * (1.0 - w1));\n                        w2 = w3;\n                        it = ir;\n\n                    }\n                    else if (XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]] &lt; XBlock.level[XBlock.BotLeft[ib]]) // exists but is coarser\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(5.0 / 10.0);\n                        w3 = T(1.0 / 10.0);\n                        it = memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 1, XBlock.LeftTop[XBlock.BotLeft[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]] == XBlock.level[XBlock.BotLeft[ib]]) // exists with same level\n                    {\n                        it = memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 1, XBlock.LeftTop[XBlock.BotLeft[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]] &gt; XBlock.level[XBlock.BotLeft[ib]]) // exists with higher level\n                    {\n                        w1 = T(1.0 / 4.0);\n                        w2 = T(1.0 / 2.0);\n                        w3 = T(1.0 / 4.0);\n                        it = memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 1, XBlock.LeftTop[XBlock.BotLeft[ib]]);\n                    }\n\n\n                }\n\n\n            }\n            else//righttopleftif == ib\n            {\n                if (j == (XParam.blkwidth - 1))\n                {\n                    if (XBlock.RightTop[XBlock.BotRight[ib]] == XBlock.BotRight[ib]) // no botom of leftbot block\n                    {\n                        w3 = T(0.5 * (1.0 - w1));\n                        w2 = w3;\n                        ir = it;\n\n                    }\n                    else if (XBlock.level[XBlock.RightTop[XBlock.BotRight[ib]]] &lt; XBlock.level[XBlock.BotRight[ib]]) // exists but is coarser\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(1.0 / 10.0);\n                        w3 = T(5.0 / 10.0);\n                        ir = memloc(XParam, 0,XParam.blkwidth - 1, XBlock.RightTop[XBlock.BotRight[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.RightTop[XBlock.BotRight[ib]]] == XBlock.level[XBlock.BotRight[ib]]) // exists with same level\n                    {\n                        ir = memloc(XParam,0, XParam.blkwidth - 1, XBlock.RightTop[XBlock.BotRight[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.RightTop[XBlock.BotRight[ib]]] &gt; XBlock.level[XBlock.BotRight[ib]]) // exists with higher level\n                    {\n                        w1 = T(1.0 / 4.0);\n                        w2 = T(1.0 / 2.0);\n                        w3 = T(1.0 / 4.0);\n                        ir = memloc(XParam,0,XParam.blkwidth - 1, XBlock.RightTop[XBlock.BotRight[ib]]);\n                    }\n                }\n                //\n            }\n\n\n            z[write] = w1 * z[ii] + w2 * z[ir] + w3 * z[it];\n        }\n    }\n\n\n\n}\n\ntemplate &lt;class T&gt; __global__ void fillBot(int halowidth, int* active, int* level, int* botleft, int* botright, int* topleft, int* lefttop, int* righttop, T* a)\n{\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    //unsigned int iy = 0;\n    int ibl = blockIdx.x;\n\n    int ib = active[ibl];\n\n    int BL = botleft[ib];\n    int BR = botright[ib];\n    int TLBL = topleft[BL];\n    int LTBL = lefttop[BL];\n    int RTBR = righttop[BR];\n\n    int lev = level[ib];\n    int levBL = level[BL];\n    int levBR = level[BR];\n    int levLTBL = level[LTBL];\n    int levRTBR = level[RTBR];\n\n    int write = memloc(halowidth, blkmemwidth, ix, -1, ib);\n    int read;\n    int jj, ii, ir, it, itr;\n    T a_read;\n    T w1, w2, w3;\n    if (BL == ib)\n    {\n        if (ix &lt; (blockDim.x / 2))\n        {\n            read = memloc(halowidth, blkmemwidth, ix, 0, ib);\n            a_read = a[read];\n        }\n        else\n        {\n            if (BR == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, ix, 0, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (ix - (blockDim.x/2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 1), BR);\n                ir = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 2), BR);\n                it = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 1), BR);\n                itr = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 2), BR);\n                a_read = T(0.25)* (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n    }\n    else if (levBL == lev)\n    {\n        read = memloc(halowidth, blkmemwidth, ix, (blockDim.x - 1), BL);\n        a_read = a[read];\n    }\n    else if (levBL &gt; lev)\n    {\n        if (ix &lt; (blockDim.x / 2))\n        {\n            jj = ix * 2;\n            ii = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 1), BL);\n            ir = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 2), BL);\n            it = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 1), BL);\n            itr = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 2), BL);\n            a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        else\n        {\n            if (BR == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, ix, 0, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (ix - (blockDim.x/2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 1), BR);\n                ir = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 2), BR);\n                it = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 1), BR);\n                itr = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 2), BR);\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n    }\n    else if (levBL &lt; lev)\n    {\n        jj = TLBL == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + blockDim.x / 2;\n        w1 = 1.0 / 3.0;\n        w2 = ceil(ix * (T)0.5) * 2 &gt; ix ? T(1.0 / 6.0) : T(0.5);\n        w3 = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.5) : T(1.0 / 6.0);\n\n        ii = memloc(halowidth, blkmemwidth, ix, 0, ib);\n        ir = memloc(halowidth, blkmemwidth, jj, blockDim.x - 1, BL);\n        it = memloc(halowidth, blkmemwidth, jj - 1, blockDim.x - 1, BL);\n\n        if (TLBL == ib)\n        {\n            if (ix == 0)\n            {\n                if (LTBL == BL)\n                {\n                    w3 = 0.5 * (1.0 - w1);\n                    w2 = w3;\n                    it = ir;\n                }\n                else if (levLTBL &lt; levBL)\n                {\n                    w1 = 4.0 / 10.0;\n                    w2 = 5.0 / 10.0;\n                    w3 = 1.0 / 10.0;\n                    it = memloc(halowidth, blkmemwidth, blockDim.x - 1, blockDim.x - 1, LTBL);\n                }\n                else if (levLTBL == levBL)\n                {\n                    it = memloc(halowidth, blkmemwidth, blockDim.x - 1, blockDim.x - 1, LTBL);\n                }\n                else if (levLTBL &gt; levBL)\n                {\n                    w1 = 1.0 / 4.0;\n                    w2 = 1.0 / 2.0;\n                    w3 = 1.0 / 4.0;\n                    it = memloc(halowidth, blkmemwidth, blockDim.x - 1, blockDim.x - 1, LTBL);\n                }\n            }\n        }\n        else\n        {\n            if (ix == (blockDim.x - 1))\n            {\n                if (RTBR == BR)\n                {\n                    w3 = 0.5 * (1.0 - w1);\n                    w2 = w3;\n                    ir = it;\n                }\n                else if (levRTBR &lt; levBR)\n                {\n                    w1 = 4.0 / 10.0;\n                    w2 = 1.0 / 10.0;\n                    w3 = 5.0 / 10.0;\n                    ir = memloc(halowidth, blkmemwidth,0, blockDim.x - 1, RTBR);\n                }\n                else if (levRTBR == levBR)\n                {\n                    ir = memloc(halowidth, blkmemwidth,0, blockDim.x - 1, RTBR);\n                }\n                else if (levRTBR &gt; levBR)\n                {\n                    w1 = 1.0 / 4.0;\n                    w2 = 1.0 / 2.0;\n                    w3 = 1.0 / 4.0;\n                    ir = memloc(halowidth, blkmemwidth, 0, blockDim.x - 1, RTBR);\n                }\n            }\n        }\n        a_read = w1 * a[ii] + w2 * a[ir] + w3 * a[it];\n    }\n    a[write] = a_read;\n\n}\ntemplate __global__ void fillBot&lt;float&gt;(int halowidth, int* active, int* level, int* botleft, int* botright, int* topleft, int* lefttop, int* righttop, float* a);\ntemplate __global__ void fillBot&lt;double&gt;(int halowidth, int* active, int* level, int* botleft, int* botright, int* topleft, int* lefttop, int* righttop, double* a);\n\ntemplate &lt;class T&gt; __global__ void fillBotnew(int halowidth, int nblk, int* active, int* level, int* botleft, int* botright, int* topleft, int* lefttop, int* righttop, T* a)\n{\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    //unsigned int iy = 0;\n    int ibl = threadIdx.y + blockIdx.x * blockDim.y;\n    if (ibl &lt; nblk)\n    {\n        int ib = active[ibl];\n\n        int BL = botleft[ib];\n        int BR = botright[ib];\n        int TLBL = topleft[BL];\n        int LTBL = lefttop[BL];\n        int RTBR = righttop[BR];\n\n        int lev = level[ib];\n        int levBL = level[BL];\n        int levBR = level[BR];\n        int levLTBL = level[LTBL];\n        int levRTBR = level[RTBR];\n\n        int write = memloc(halowidth, blkmemwidth, ix, -1, ib);\n        int read;\n        int jj, ii, ir, it, itr;\n        T a_read;\n        T w1, w2, w3;\n        if (BL == ib)\n        {\n            if (ix &lt; (blockDim.x / 2))\n            {\n                read = memloc(halowidth, blkmemwidth, ix, 0, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                if (BR == ib)\n                {\n                    read = memloc(halowidth, blkmemwidth, ix, 0, ib);\n                    a_read = a[read];\n                }\n                else\n                {\n                    jj = (ix - (blockDim.x / 2)) * 2;\n                    ii = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 1), BR);\n                    ir = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 2), BR);\n                    it = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 1), BR);\n                    itr = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 2), BR);\n                    a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n        }\n        else if (levBL == lev)\n        {\n            read = memloc(halowidth, blkmemwidth, ix, (blockDim.x - 1), BL);\n            a_read = a[read];\n        }\n        else if (levBL &gt; lev)\n        {\n            if (ix &lt; (blockDim.x / 2))\n            {\n                jj = ix * 2;\n                ii = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 1), BL);\n                ir = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 2), BL);\n                it = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 1), BL);\n                itr = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 2), BL);\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n            else\n            {\n                if (BR == ib)\n                {\n                    read = memloc(halowidth, blkmemwidth, ix, 0, ib);\n                    a_read = a[read];\n                }\n                else\n                {\n                    jj = (ix - (blockDim.x / 2)) * 2;\n                    ii = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 1), BR);\n                    ir = memloc(halowidth, blkmemwidth, jj, (blockDim.x - 2), BR);\n                    it = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 1), BR);\n                    itr = memloc(halowidth, blkmemwidth, jj + 1, (blockDim.x - 2), BR);\n                    a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n        }\n        else if (levBL &lt; lev)\n        {\n            jj = TLBL == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + blockDim.x / 2;\n            w1 = 1.0 / 3.0;\n            w2 = ceil(ix * (T)0.5) * 2 &gt; ix ? T(1.0 / 6.0) : T(0.5);\n            w3 = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.5) : T(1.0 / 6.0);\n\n            ii = memloc(halowidth, blkmemwidth, ix, 0, ib);\n            ir = memloc(halowidth, blkmemwidth, jj, blockDim.x - 1, BL);\n            it = memloc(halowidth, blkmemwidth, jj - 1, blockDim.x - 1, BL);\n\n            if (TLBL == ib)\n            {\n                if (ix == 0)\n                {\n                    if (LTBL == BL)\n                    {\n                        w3 = 0.5 * (1.0 - w1);\n                        w2 = w3;\n                        it = ir;\n                    }\n                    else if (levLTBL &lt; levBL)\n                    {\n                        w1 = 4.0 / 10.0;\n                        w2 = 5.0 / 10.0;\n                        w3 = 1.0 / 10.0;\n                        it = memloc(halowidth, blkmemwidth, blockDim.x - 1, blockDim.x - 1, LTBL);\n                    }\n                    else if (levLTBL == levBL)\n                    {\n                        it = memloc(halowidth, blkmemwidth, blockDim.x - 1, blockDim.x - 1, LTBL);\n                    }\n                    else if (levLTBL &gt; levBL)\n                    {\n                        w1 = 1.0 / 4.0;\n                        w2 = 1.0 / 2.0;\n                        w3 = 1.0 / 4.0;\n                        it = memloc(halowidth, blkmemwidth, blockDim.x - 1, blockDim.x - 1, LTBL);\n                    }\n                }\n            }\n            else\n            {\n                if (ix == (blockDim.x - 1))\n                {\n                    if (RTBR == BR)\n                    {\n                        w3 = 0.5 * (1.0 - w1);\n                        w2 = w3;\n                        ir = it;\n                    }\n                    else if (levRTBR &lt; levBR)\n                    {\n                        w1 = 4.0 / 10.0;\n                        w2 = 1.0 / 10.0;\n                        w3 = 5.0 / 10.0;\n                        ir = memloc(halowidth, blkmemwidth, 0, blockDim.x - 1, RTBR);\n                    }\n                    else if (levRTBR == levBR)\n                    {\n                        ir = memloc(halowidth, blkmemwidth, 0, blockDim.x - 1, RTBR);\n                    }\n                    else if (levRTBR &gt; levBR)\n                    {\n                        w1 = 1.0 / 4.0;\n                        w2 = 1.0 / 2.0;\n                        w3 = 1.0 / 4.0;\n                        ir = memloc(halowidth, blkmemwidth, 0, blockDim.x - 1, RTBR);\n                    }\n                }\n            }\n            a_read = w1 * a[ii] + w2 * a[ir] + w3 * a[it];\n        }\n        a[write] = a_read;\n    }\n\n}\ntemplate __global__ void fillBotnew&lt;float&gt;(int halowidth, int nblk, int* active, int* level, int* botleft, int* botright, int* topleft, int* lefttop, int* righttop, float* a);\ntemplate __global__ void fillBotnew&lt;double&gt;(int halowidth, int nblk, int* active, int* level, int* botleft, int* botright, int* topleft, int* lefttop, int* righttop, double* a);\n\ntemplate &lt;class T&gt; void fillBotFlux(Param XParam, bool doProlongation, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    int jj, bb;\n    int read, write;\n    int ii, ir, it;\n\n\n    if (XBlock.BotLeft[ib] == ib)//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n\n            read = memloc(XParam, j, 0, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            write = memloc(XParam, j, -1, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            z[write] = z[read];\n        }\n\n        if (XBlock.BotRight[ib] == ib) // boundary on the top half too\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, j, 0, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, -1, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                write = memloc(XParam, j, -1, ib);\n                jj = (j - 8) * 2;\n                ii = memloc(XParam, jj, (XParam.blkwidth - 1), XBlock.BotRight[ib]);\n                //ir = memloc(XParam, jj, (XParam.blkwidth - 2), XBlock.BotRight[ib]);\n                it = memloc(XParam, jj + 1, (XParam.blkwidth - 1), XBlock.BotRight[ib]);\n                //itr = memloc(XParam, jj + 1, (XParam.blkwidth - 2), XBlock.BotRight[ib]);\n\n                z[write] = T(0.5) * (z[ii] + z[it] );\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.BotLeft[ib]]) // LeftTop block does not exist\n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n\n            write = memloc(XParam, j, -1, ib);\n            read = memloc(XParam, j, (XParam.blkwidth - 1), XBlock.BotLeft[ib]);\n            z[write] = z[read];\n        }\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n\n            write = memloc(XParam, j, -1, ib);\n\n            jj = j * 2;\n            bb = XBlock.BotLeft[ib];\n\n            ii = memloc(XParam, jj, (XParam.blkwidth - 1), bb);\n            //ir = memloc(XParam, jj, (XParam.blkwidth - 2), bb);\n            it = memloc(XParam, jj + 1, (XParam.blkwidth - 1), bb);\n            //itr = memloc(XParam, jj + 1, (XParam.blkwidth - 2), bb);\n\n            z[write] = T(0.5) * (z[ii] + z[it]);\n        }\n        //now find out aboy botright block\n        if (XBlock.BotRight[ib] == ib)\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, j, 0, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, -1, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n                jj = (j - 8) * 2;\n                bb = XBlock.BotRight[ib];\n\n                //read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, -1, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                //z[write] = z[read];\n                ii = memloc(XParam, jj, (XParam.blkwidth - 1), bb);\n                //ir = memloc(XParam, jj, (XParam.blkwidth - 2), bb);\n                it = memloc(XParam, jj + 1, (XParam.blkwidth - 1), bb);\n                //itr = memloc(XParam, jj + 1, (XParam.blkwidth - 2), bb);\n\n                z[write] = T(0.5) * (z[ii]  + z[it] );\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.BotLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            write = memloc(XParam, j, -1, ib);\n\n            //T w1, w2, w3;\n\n\n            int jj = XBlock.TopLeft[XBlock.BotLeft[ib]] == ib ? ftoi(ceil(j * (T)0.5)) : ftoi(ceil(j * (T)0.5) + XParam.blkwidth / 2);\n\n\n            //ii = memloc(XParam, j, 0, ib);\n            ir = memloc(XParam, jj, XParam.blkwidth - 1, XBlock.BotLeft[ib]);\n            if(doProlongation)\n                z[write] = z[ir];\n        }\n    }\n\n\n\n}\n\ntemplate &lt;class T&gt; void fillTop(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    int jj, bb;\n    int read, write;\n    int ii, ir, it, itr;\n\n\n    if (XBlock.TopLeft[ib] == ib)//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n\n            read = memloc(XParam,j, XParam.blkwidth - 1, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            write = memloc(XParam,j, XParam.blkwidth, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            z[write] = z[read];\n        }\n\n        if (XBlock.TopRight[ib] == ib) // boundary on the top half too\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, j, XParam.blkwidth - 1, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, XParam.blkwidth, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                write = memloc(XParam, j, XParam.blkwidth, ib);\n                jj = (j - (XParam.blkwidth / 2)) * 2;\n                ii = memloc(XParam, jj, 0, XBlock.TopRight[ib]);\n                ir = memloc(XParam, jj, 1, XBlock.TopRight[ib]);\n                it = memloc(XParam, jj + 1, 0, XBlock.TopRight[ib]);\n                itr = memloc(XParam, jj + 1, 1, XBlock.TopRight[ib]);\n\n                z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.TopLeft[ib]]) // LeftTop block does not exist\n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n\n            write = memloc(XParam, j, XParam.blkwidth, ib);\n            read = memloc(XParam, j, 0, XBlock.TopLeft[ib]);\n            z[write] = z[read];\n        }\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n\n            write = memloc(XParam, j, XParam.blkwidth, ib);\n\n            jj = j * 2;\n            bb = XBlock.TopLeft[ib];\n\n            ii = memloc(XParam,jj, 0, bb);\n            ir = memloc(XParam,jj, 1, bb);\n            it = memloc(XParam,jj + 1, 0, bb);\n            itr = memloc(XParam,jj + 1, 1, bb);\n\n            z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.TopRight[ib] == ib)\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam,j, XParam.blkwidth - 1, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, XParam.blkwidth, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n                jj = (j - (XParam.blkwidth / 2)) * 2;\n                bb = XBlock.TopRight[ib];\n\n                //read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j , XParam.blkwidth, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                //z[write] = z[read];\n                ii = memloc(XParam,jj, 0, bb);\n                ir = memloc(XParam,jj, 1, bb);\n                it = memloc(XParam,jj + 1, 0, bb);\n                itr = memloc(XParam,jj + 1, 1, bb);\n\n                z[write] = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            write = memloc(XParam,j, XParam.blkwidth, ib);\n\n            T w1, w2, w3;\n\n\n            int jj = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? ftoi(ceil(j * (T)0.5)) : ftoi(ceil(j * (T)0.5) + XParam.blkwidth / 2);\n            w1 = T(1.0 / 3.0);\n            w2 = ceil(j * (T)0.5) * 2 &gt; j ? T(1.0 / 6.0) : T(0.5);\n            w3 = ceil(j * (T)0.5) * 2 &gt; j ? T(0.5) : T(1.0 / 6.0);\n\n            ii = memloc(XParam,j, XParam.blkwidth - 1, ib);\n            ir = memloc(XParam,jj, 0,  XBlock.TopLeft[ib]);\n            it = memloc(XParam,jj-1, 0, XBlock.TopLeft[ib]);\n            //2 scenarios here ib is the leftbot neighbour of the rightbot block or ib is the lefttop neighbour\n            if (XBlock.BotLeft[XBlock.TopLeft[ib]] == ib)\n            {\n                if (j == 0)\n                {\n                    if (XBlock.LeftBot[XBlock.TopLeft[ib]] == XBlock.TopLeft[ib]) // no botom of leftbot block\n                    {\n                        w3 = T(0.5 * (1.0 - w1));\n                        w2 = w3;\n                        it = ir;\n\n                    }\n                    else if (XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]] &lt; XBlock.level[XBlock.TopLeft[ib]]) // exists but is coarser\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(5.0 / 10.0);\n                        w3 = T(1.0 / 10.0);\n                        it = memloc(XParam, XParam.blkwidth - 1,0, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]] == XBlock.level[XBlock.TopLeft[ib]]) // exists with same level\n                    {\n                        it = memloc(XParam,  XParam.blkwidth - 1,0, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]] &gt; XBlock.level[XBlock.TopLeft[ib]]) // exists with higher level\n                    {\n                        w1 = T(1.0 / 4.0);\n                        w2 = T(1.0 / 2.0);\n                        w3 = T(1.0 / 4.0);\n                        it = memloc(XParam, XParam.blkwidth - 1, 0, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n                    }\n\n\n                }\n\n\n            }\n            else//\n            {\n                if (j == (XParam.blkwidth - 1))\n                {\n                    if (XBlock.RightBot[XBlock.TopRight[ib]] == XBlock.TopRight[ib]) // no botom of leftbot block\n                    {\n                        w3 = T(0.5 * (1.0 - w1));\n                        w2 = w3;\n                        ir = it;\n\n                    }\n                    else if (XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]] &lt; XBlock.level[XBlock.TopRight[ib]]) // exists but is coarser\n                    {\n                        w1 = T(4.0 / 10.0);\n                        w2 = T(1.0 / 10.0);\n                        w3 = T(5.0 / 10.0);\n                        ir = memloc(XParam, 0, 0, XBlock.RightBot[XBlock.TopRight[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]] == XBlock.level[XBlock.TopRight[ib]]) // exists with same level\n                    {\n                        ir = memloc(XParam, 0, 0, XBlock.RightBot[XBlock.TopRight[ib]]);\n                    }\n                    else if (XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]] &gt; XBlock.level[XBlock.TopRight[ib]]) // exists with higher level\n                    {\n                        w1 = T(1.0 / 4.0);\n                        w2 = T(1.0 / 2.0);\n                        w3 = T(1.0 / 4.0);\n                        ir = memloc(XParam, 0,0, XBlock.RightBot[XBlock.TopRight[ib]]);\n                    }\n                }\n                //\n            }\n\n\n            z[write] = w1 * z[ii] + w2 * z[ir] + w3 * z[it];\n        }\n    }\n\n\n\n}\n\ntemplate &lt;class T&gt; __global__ void fillTop(int halowidth, int* active, int* level,int * topleft, int * topright,int * botleft, int* leftbot, int* rightbot,  T* a)\n{\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    //unsigned int iy = blockDim.x-1;\n    int ibl = blockIdx.x;\n    int ib = active[ibl];\n\n    int TL = topleft[ib];\n    int TR = topright[ib];\n    int LBTL = leftbot[TL];\n    int BLTL = botleft[TL];\n    int RBTR = rightbot[TR];\n\n\n    int lev = level[ib];\n    int levTL = level[TL];\n    int levTR = level[TR];\n    int levLBTL = level[LBTL];\n    int levRBTR = level[RBTR];\n\n    int write = memloc(halowidth, blkmemwidth, ix, blockDim.x, ib);\n    int read;\n    int jj, ii, ir, it, itr;\n    T a_read;\n    T w1, w2, w3;\n\n    if (TL == ib)\n    {\n        if (ix &lt; (blockDim.x / 2))\n        {\n            read = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n            a_read = a[read];\n        }\n        else\n        {\n            if (TR == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (ix - (blockDim.x / 2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, jj, 0, TR);\n                ir = memloc(halowidth, blkmemwidth, jj, 1, TR);\n                it = memloc(halowidth, blkmemwidth, jj + 1, 0, TR);\n                itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TR);\n\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n    }\n    else if (levTL == lev)\n    {\n        read = memloc(halowidth, blkmemwidth, ix, 0, TL);\n        a_read = a[read];\n    }\n    else if (levTL &gt; lev)\n    {\n        if (ix &lt; (blockDim.x / 2))\n        {\n            jj = ix * 2;\n\n\n            ii = memloc(halowidth, blkmemwidth, jj, 0, TL);\n            ir = memloc(halowidth, blkmemwidth, jj, 1, TL);\n            it = memloc(halowidth, blkmemwidth, jj + 1, 0, TL);\n            itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TL);\n            a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n        }\n        else\n        {\n            if (TR == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, ix, blockDim.x-1, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (ix - (blockDim.x / 2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, jj, 0, TR);\n                ir = memloc(halowidth, blkmemwidth, jj, 1, TR);\n                it = memloc(halowidth, blkmemwidth, jj + 1, 0, TR);\n                itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TR);\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n        }\n    }\n    else if (levTL &lt; lev)\n    {\n        jj = BLTL == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + blockDim.x / 2;\n        w1 = 1.0 / 3.0;\n        w2 = ceil(ix * (T)0.5) * 2 &gt; ix ? T(1.0 / 6.0) : T(0.5);\n        w3 = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.5) : T(1.0 / 6.0);\n        ii = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n        ir = memloc(halowidth, blkmemwidth, jj, 0, TL);\n        it = memloc(halowidth, blkmemwidth, jj - 1, 0, TL);\n        if (BLTL == ib)\n        {\n            if (ix == 0)\n            {\n                if (LBTL == TL)\n                {\n                    w3 = 0.5 * (1.0 - w1);\n                    w2 = w3;\n                    it = ir;\n                }\n                else if (levLBTL &lt; levTL)\n                {\n                    w1 = 4.0 / 10.0;\n                    w2 = 5.0 / 10.0;\n                    w3 = 1.0 / 10.0;\n                    it = memloc(halowidth, blkmemwidth, blockDim.x - 1, 0, LBTL);\n                }\n                else if (levLBTL == levTL)\n                {\n                    it = memloc(halowidth, blkmemwidth, blockDim.x - 1, 0, LBTL);\n                }\n                else if (levLBTL &gt; levTL)\n                {\n                    w1 = 1.0 / 4.0;\n                    w2 = 1.0 / 2.0;\n                    w3 = 1.0 / 4.0;\n                    it = memloc(halowidth, blkmemwidth, blockDim.x - 1, 0, LBTL);\n                }\n            }\n        }\n        else\n        {\n            if (ix == blockDim.x - 1)\n            {\n                if (RBTR == TR)\n                {\n                    w3 = 0.5 * (1.0 - w1);\n                    w2 = w3;\n                    ir = it;\n                }\n                else if (levRBTR &lt; levTR)\n                {\n                    w1 = 4.0 / 10.0;\n                    w2 = 1.0 / 10.0;\n                    w3 = 5.0 / 10.0;\n                    ir = memloc(halowidth, blkmemwidth, 0, 0, RBTR);\n                }\n                else if (levRBTR == levTR)\n                {\n                    ir = memloc(halowidth, blkmemwidth, 0, 0, RBTR);\n                }\n                else if (levRBTR &gt; levTR)\n                {\n                    w1 = 1.0 / 4.0;\n                    w2 = 1.0 / 2.0;\n                    w3 = 1.0 / 4.0;\n                    ir = memloc(halowidth, blkmemwidth,0, 0, RBTR);\n                }\n            }\n        }\n        a_read= w1 * a[ii] + w2 * a[ir] + w3 * a[it];\n    }\n    a[write] = a_read;\n}\n\ntemplate __global__ void fillTop&lt;float&gt;(int halowidth, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, float* a);\ntemplate __global__ void fillTop&lt;double&gt;(int halowidth, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, double* a);\n\n/***\n * @brief CUDA kernel to fill the top halo region of blocks in parallel for new refinement, handling various neighbor configurations, new version\n * @param halowidth The width of the halo region\n * @param nblk The number of active blocks\n * @param active The array of active block indices\n * @param level The array of block levels\n * @param topleft The array of top left neighbor block indices\n * @param topright The array of top right neighbor block indices\n * @param botleft The array of bottom left neighbor block indices\n * @param leftbot The array of left bottom neighbor block indices\n * @param rightbot The array of right bottom neighbor block indices\n * @param a The variable to be refined\n * \n */\ntemplate &lt;class T&gt; __global__ void fillTopnew(int halowidth, int nblk, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, T* a)\n{\n    int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    //unsigned int iy = blockDim.x-1;\n    int ibl = threadIdx.y + blockIdx.x * blockDim.y;\n    if (ibl &lt; nblk)\n    {\n        int ib = active[ibl];\n\n        int TL = topleft[ib];\n        int TR = topright[ib];\n        int LBTL = leftbot[TL];\n        int BLTL = botleft[TL];\n        int RBTR = rightbot[TR];\n\n\n        int lev = level[ib];\n        int levTL = level[TL];\n        int levTR = level[TR];\n        int levLBTL = level[LBTL];\n        int levRBTR = level[RBTR];\n\n        int write = memloc(halowidth, blkmemwidth, ix, blockDim.x, ib);\n        int read;\n        int jj, ii, ir, it, itr;\n        T a_read;\n        T w1, w2, w3;\n\n        if (TL == ib)\n        {\n            if (ix &lt; (blockDim.x / 2))\n            {\n                read = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                if (TR == ib)\n                {\n                    read = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n                    a_read = a[read];\n                }\n                else\n                {\n                    jj = (ix - (blockDim.x / 2)) * 2;\n                    ii = memloc(halowidth, blkmemwidth, jj, 0, TR);\n                    ir = memloc(halowidth, blkmemwidth, jj, 1, TR);\n                    it = memloc(halowidth, blkmemwidth, jj + 1, 0, TR);\n                    itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TR);\n\n                    a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n        }\n        else if (levTL == lev)\n        {\n            read = memloc(halowidth, blkmemwidth, ix, 0, TL);\n            a_read = a[read];\n        }\n        else if (levTL &gt; lev)\n        {\n            if (ix &lt; (blockDim.x / 2))\n            {\n                jj = ix * 2;\n\n\n                ii = memloc(halowidth, blkmemwidth, jj, 0, TL);\n                ir = memloc(halowidth, blkmemwidth, jj, 1, TL);\n                it = memloc(halowidth, blkmemwidth, jj + 1, 0, TL);\n                itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TL);\n                a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n            }\n            else\n            {\n                if (TR == ib)\n                {\n                    read = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n                    a_read = a[read];\n                }\n                else\n                {\n                    jj = (ix - (blockDim.x / 2)) * 2;\n                    ii = memloc(halowidth, blkmemwidth, jj, 0, TR);\n                    ir = memloc(halowidth, blkmemwidth, jj, 1, TR);\n                    it = memloc(halowidth, blkmemwidth, jj + 1, 0, TR);\n                    itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TR);\n                    a_read = T(0.25) * (a[ii] + a[ir] + a[it] + a[itr]);\n                }\n            }\n        }\n        else if (levTL &lt; lev)\n        {\n            jj = BLTL == ib ? ceil(ix * (T)0.5) : ceil(ix * (T)0.5) + blockDim.x / 2;\n            w1 = 1.0 / 3.0;\n            w2 = ceil(ix * (T)0.5) * 2 &gt; ix ? T(1.0 / 6.0) : T(0.5);\n            w3 = ceil(ix * (T)0.5) * 2 &gt; ix ? T(0.5) : T(1.0 / 6.0);\n            ii = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n            ir = memloc(halowidth, blkmemwidth, jj, 0, TL);\n            it = memloc(halowidth, blkmemwidth, jj - 1, 0, TL);\n            if (BLTL == ib)\n            {\n                if (ix == 0)\n                {\n                    if (LBTL == TL)\n                    {\n                        w3 = 0.5 * (1.0 - w1);\n                        w2 = w3;\n                        it = ir;\n                    }\n                    else if (levLBTL &lt; levTL)\n                    {\n                        w1 = 4.0 / 10.0;\n                        w2 = 5.0 / 10.0;\n                        w3 = 1.0 / 10.0;\n                        it = memloc(halowidth, blkmemwidth, blockDim.x - 1, 0, LBTL);\n                    }\n                    else if (levLBTL == levTL)\n                    {\n                        it = memloc(halowidth, blkmemwidth, blockDim.x - 1, 0, LBTL);\n                    }\n                    else if (levLBTL &gt; levTL)\n                    {\n                        w1 = 1.0 / 4.0;\n                        w2 = 1.0 / 2.0;\n                        w3 = 1.0 / 4.0;\n                        it = memloc(halowidth, blkmemwidth, blockDim.x - 1, 0, LBTL);\n                    }\n                }\n            }\n            else\n            {\n                if (ix == blockDim.x - 1)\n                {\n                    if (RBTR == TR)\n                    {\n                        w3 = 0.5 * (1.0 - w1);\n                        w2 = w3;\n                        ir = it;\n                    }\n                    else if (levRBTR &lt; levTR)\n                    {\n                        w1 = 4.0 / 10.0;\n                        w2 = 1.0 / 10.0;\n                        w3 = 5.0 / 10.0;\n                        ir = memloc(halowidth, blkmemwidth, 0, 0, RBTR);\n                    }\n                    else if (levRBTR == levTR)\n                    {\n                        ir = memloc(halowidth, blkmemwidth, 0, 0, RBTR);\n                    }\n                    else if (levRBTR &gt; levTR)\n                    {\n                        w1 = 1.0 / 4.0;\n                        w2 = 1.0 / 2.0;\n                        w3 = 1.0 / 4.0;\n                        ir = memloc(halowidth, blkmemwidth, 0, 0, RBTR);\n                    }\n                }\n            }\n            a_read = w1 * a[ii] + w2 * a[ir] + w3 * a[it];\n        }\n        a[write] = a_read;\n    }\n}\n\ntemplate __global__ void fillTopnew&lt;float&gt;(int halowidth, int nblk, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, float* a);\ntemplate __global__ void fillTopnew&lt;double&gt;(int halowidth, int nblk, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, double* a);\n\ntemplate &lt;class T&gt; void fillTopFlux(Param XParam, bool doProlongation, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    int jj, bb;\n    int read, write;\n    int ii, ir, it;\n\n\n    if (XBlock.TopLeft[ib] == ib)//The lower half is a boundary \n    {\n        for (int j = 0; j &lt; (XParam.blkwidth / 2); j++)\n        {\n\n            read = memloc(XParam, j, XParam.blkwidth - 1, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            write = memloc(XParam, j, XParam.blkwidth, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n            z[write] = z[read];\n        }\n\n        if (XBlock.TopRight[ib] == ib) // boundary on the top half too\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, j, XParam.blkwidth - 1, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, XParam.blkwidth, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else // boundary is only on the bottom half and implicitely level of lefttopib is levelib+1\n        {\n\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                write = memloc(XParam, j, XParam.blkwidth, ib);\n                jj = (j - (XParam.blkwidth / 2)) * 2;\n                ii = memloc(XParam, jj, 0, XBlock.TopRight[ib]);\n                //ir = memloc(XParam, jj, 1, XBlock.TopRight[ib]);\n                it = memloc(XParam, jj + 1, 0, XBlock.TopRight[ib]);\n                //itr = memloc(XParam, jj + 1, 1, XBlock.TopRight[ib]);\n\n                z[write] = T(0.5) * (z[ii] + z[it] );\n\n            }\n        }\n    }\n    else if (XBlock.level[ib] == XBlock.level[XBlock.TopLeft[ib]]) // LeftTop block does not exist\n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            //\n\n            write = memloc(XParam, j, XParam.blkwidth, ib);\n            read = memloc(XParam, j, 0, XBlock.TopLeft[ib]);\n            z[write] = z[read];\n        }\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &gt; XBlock.level[ib])\n    {\n\n        for (int j = 0; j &lt; XParam.blkwidth / 2; j++)\n        {\n\n            write = memloc(XParam, j, XParam.blkwidth, ib);\n\n            jj = j * 2;\n            bb = XBlock.TopLeft[ib];\n\n            ii = memloc(XParam, jj, 0, bb);\n            //ir = memloc(XParam, jj, 1, bb);\n            it = memloc(XParam, jj + 1, 0, bb);\n            //itr = memloc(XParam, jj + 1, 1, bb);\n\n            z[write] = T(0.5) * (z[ii]  + z[it]);\n        }\n        //now find out aboy lefttop block\n        if (XBlock.TopRight[ib] == ib)\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n\n                read = memloc(XParam, j, XParam.blkwidth - 1, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, XParam.blkwidth, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                z[write] = z[read];\n            }\n        }\n        else\n        {\n            for (int j = (XParam.blkwidth / 2); j &lt; (XParam.blkwidth); j++)\n            {\n                //\n                jj = (j - (XParam.blkwidth / 2)) * 2;\n                bb = XBlock.TopRight[ib];\n\n                //read = memloc(XParam, 0, j, ib);// 1 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                write = memloc(XParam, j, XParam.blkwidth, ib); //0 + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                //z[write] = z[read];\n                ii = memloc(XParam, jj, 0, bb);\n                //ir = memloc(XParam, jj, 1, bb);\n                it = memloc(XParam, jj + 1, 0, bb);\n                //itr = memloc(XParam, jj + 1, 1, bb);\n\n                z[write] = T(0.5) * (z[ii]  + z[it]);\n            }\n        }\n\n    }\n    else if (XBlock.level[XBlock.TopLeft[ib]] &lt; XBlock.level[ib]) // Neighbour is coarser; using barycentric interpolation (weights are precalculated) for the Halo \n    {\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            write = memloc(XParam, j, XParam.blkwidth, ib);\n            int jj = XBlock.BotLeft[XBlock.TopLeft[ib]] == ib ? ftoi(floor(j * (T)0.5)) : ftoi(floor(j * (T)0.5) + XParam.blkwidth / 2);\n\n            ir = memloc(XParam, jj, 0, XBlock.TopLeft[ib]);\n\n            if (doProlongation)\n                z[write] = z[ir];\n\n        }\n    }\n\n\n\n}\ntemplate void fillTopFlux&lt;float&gt;(Param XParam, bool doProlongation, int ib, BlockP&lt;float&gt; XBlock, float*&amp; z);\ntemplate void fillTopFlux&lt;double&gt;(Param XParam, bool doProlongation, int ib, BlockP&lt;double&gt; XBlock, double*&amp; z);\n\ntemplate &lt;class T&gt; __global__ void fillTopFlux(int halowidth, bool doProlongation, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, T* a)\n{\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    //unsigned int iy = blockDim.x - 1;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = active[ibl];\n\n    int TL = topleft[ib];\n    int TR = topright[ib];\n    //int LBTL = leftbot[TL];\n    int BLTL = botleft[TL];\n    //int RBTR = rightbot[TR];\n\n\n    int lev = level[ib];\n    int levTL = level[TL];\n    //int levTR = level[TR];\n    //int levLBTL = level[LBTL];\n    //int levRBTR = level[RBTR];\n\n    int write = memloc(halowidth, blkmemwidth, ix, blockDim.x, ib);\n    int read;\n    int jj, ii, ir, it;\n    T a_read;\n    //T w1, w2, w3;\n\n    if (TL == ib)\n    {\n        if (ix &lt; (blockDim.x / 2))\n        {\n            read = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n            a_read = a[read];\n        }\n        else\n        {\n            if (TR == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (ix - (blockDim.x / 2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, jj, 0, TR);\n                //ir = memloc(halowidth, blkmemwidth, jj, 1, TR);\n                it = memloc(halowidth, blkmemwidth, jj + 1, 0, TR);\n                //itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TR);\n\n                a_read = T(0.5) * (a[ii]  + a[it] );\n            }\n        }\n    }\n    else if (levTL == lev)\n    {\n        read = memloc(halowidth, blkmemwidth, ix, 0, TL);\n        a_read = a[read];\n    }\n    else if (levTL &gt; lev)\n    {\n        if (ix &lt; (blockDim.x / 2))\n        {\n            jj = ix * 2;\n\n\n            ii = memloc(halowidth, blkmemwidth, jj, 0, TL);\n            //ir = memloc(halowidth, blkmemwidth, jj, 1, TL);\n            it = memloc(halowidth, blkmemwidth, jj + 1, 0, TL);\n            //itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TL);\n            a_read = T(0.5) * (a[ii] + a[it]);\n        }\n        else\n        {\n            if (TR == ib)\n            {\n                read = memloc(halowidth, blkmemwidth, ix, blockDim.x - 1, ib);\n                a_read = a[read];\n            }\n            else\n            {\n                jj = (ix - (blockDim.x / 2)) * 2;\n                ii = memloc(halowidth, blkmemwidth, jj, 0, TR);\n                //ir = memloc(halowidth, blkmemwidth, jj, 1, TR);\n                it = memloc(halowidth, blkmemwidth, jj + 1, 0, TR);\n                //itr = memloc(halowidth, blkmemwidth, jj + 1, 1, TR);\n                a_read = T(0.5) * (a[ii] + a[it]);\n            }\n        }\n    }\n    else if (levTL &lt; lev)\n    {\n        jj = BLTL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n\n        ir = memloc(halowidth, blkmemwidth, jj, 0, TL);\n        if (doProlongation)\n            a_read = a[ir];\n        else\n            a_read =  a[write];\n    }\n    a[write] = a_read;\n}\n\ntemplate __global__ void fillTopFlux&lt;float&gt;(int halowidth, bool doProlongation, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, float* a);\ntemplate __global__ void fillTopFlux&lt;double&gt;(int halowidth, bool doProlongation, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, double* a);\n\n\ntemplate &lt;class T&gt; void fillCorners(Param XParam, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    int ib;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        fillCorners(XParam, ib, XBlock, z);\n\n    }\n\n}\ntemplate void fillCorners&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float*&amp; z);\ntemplate void fillCorners&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double*&amp; z);\n\n\ntemplate &lt;class T&gt; void fillCorners(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt;&amp; Xev)\n{\n    int ib;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        fillCorners(XParam, ib, XBlock, Xev.h);\n        fillCorners(XParam, ib, XBlock, Xev.zs);\n        fillCorners(XParam, ib, XBlock, Xev.u);\n        fillCorners(XParam, ib, XBlock, Xev.v);\n    }\n\n}\ntemplate void fillCorners&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt;&amp; Xev);\ntemplate void fillCorners&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt;&amp; Xev);\n\n\ntemplate &lt;class T&gt; void fillCorners(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z)\n{\n    // Run only this function after the filling the other bit of halo (i.e. fctn fillleft...)\n    // Most of the time the cormers are not needed. they are when refining a cell! \n\n\n    T zz;\n    int write;\n    int ii, ir, it, itr;\n\n\n    // Bottom left corner\n    write = memloc(XParam, -1, -1, ib);\n    //check that there is a block there and if there is calculate the value depending on the level of that block\n    if (XBlock.LeftTop[XBlock.BotLeft[ib]] == XBlock.BotLeft[ib]) // There is no block\n    {\n        zz = T(0.5) * (z[memloc(XParam, -1, 0, ib)] + z[memloc(XParam, 0, -1, ib)]);\n    }\n    else if (XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]] == XBlock.level[ib])\n    {\n        zz = z[memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 1, XBlock.LeftTop[XBlock.BotLeft[ib]])];\n    }\n    else if (XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]] &gt; XBlock.level[ib])\n    {\n        ii = memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 1, XBlock.LeftTop[XBlock.BotLeft[ib]]);\n        ir = memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 2, XBlock.LeftTop[XBlock.BotLeft[ib]]);\n        it = memloc(XParam, XParam.blkwidth - 2, XParam.blkwidth - 1, XBlock.LeftTop[XBlock.BotLeft[ib]]);\n        itr = memloc(XParam, XParam.blkwidth - 2, XParam.blkwidth - 2, XBlock.LeftTop[XBlock.BotLeft[ib]]);\n\n        zz = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n    }\n    else if (XBlock.level[XBlock.LeftTop[XBlock.BotLeft[ib]]] &lt; XBlock.level[ib])\n    {\n        ii = memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth - 1, XBlock.LeftTop[XBlock.BotLeft[ib]]);\n        ir = memloc(XParam, - 1, 0, ib);\n        it = memloc(XParam,0, - 1, ib);\n        zz = T(0.5) * z[ii] + T(0.25) * (z[ir] + z[it]);\n    }\n\n    z[write] = zz;\n\n    // Top Left corner\n    write = memloc(XParam, -1, XParam.blkwidth, ib);\n    //check that there is a block there and if there is calculate the value depending on the level of that block\n    if (XBlock.LeftBot[XBlock.TopLeft[ib]] == XBlock.TopLeft[ib]) // There is no block\n    {\n        zz = T(0.5) * (z[memloc(XParam, -1, XParam.blkwidth-1, ib)] + z[memloc(XParam, 0, XParam.blkwidth, ib)]);\n    }\n    else if (XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]] == XBlock.level[ib])\n    {\n        zz = z[memloc(XParam, XParam.blkwidth - 1, 0, XBlock.LeftBot[XBlock.TopLeft[ib]])];\n    }\n    else if (XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]] &gt; XBlock.level[ib])\n    {\n        ii = memloc(XParam, XParam.blkwidth - 1, 0, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n        ir = memloc(XParam, XParam.blkwidth - 1, 1, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n        it = memloc(XParam, XParam.blkwidth - 2, 0, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n        itr = memloc(XParam, XParam.blkwidth - 2, 1, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n\n        zz = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n    }\n    else if (XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]] &lt; XBlock.level[ib])\n    {\n        ii = memloc(XParam, XParam.blkwidth - 1, 0, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n        ir = memloc(XParam, -1, XParam.blkwidth - 1, ib);\n        it = memloc(XParam, 0, XParam.blkwidth, ib);\n        zz = T(0.5) * z[ii] + T(0.25) * (z[ir] + z[it]);\n    }\n\n    z[write] = zz;\n\n    //Top Right corner\n    write = memloc(XParam, XParam.blkwidth, XParam.blkwidth, ib);\n    //check that there is a block there and if there is calculate the value depending on the level of that block\n    if (XBlock.RightBot[XBlock.TopRight[ib]] == XBlock.TopRight[ib]) // There is no block\n    {\n        zz = T(0.5) * (z[memloc(XParam, XParam.blkwidth, XParam.blkwidth - 1, ib)] + z[memloc(XParam, XParam.blkwidth - 1, XParam.blkwidth, ib)]);\n    }\n    else if (XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]] == XBlock.level[ib])\n    {\n        zz = z[memloc(XParam, 0, 0, XBlock.RightBot[XBlock.TopRight[ib]])];\n    }\n    else if (XBlock.level[XBlock.RightBot[XBlock.TopRight[ib]]] &gt; XBlock.level[ib])\n    {\n        ii = memloc(XParam, 0, 0, XBlock.RightBot[XBlock.TopRight[ib]]);\n        ir = memloc(XParam, 0, 1, XBlock.RightBot[XBlock.TopRight[ib]]);\n        it = memloc(XParam, 1, 0, XBlock.RightBot[XBlock.TopRight[ib]]);\n        itr = memloc(XParam, 1, 1, XBlock.RightBot[XBlock.TopRight[ib]]);\n\n        zz = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n    }\n    else if (XBlock.level[XBlock.LeftBot[XBlock.TopLeft[ib]]] &lt; XBlock.level[ib])\n    {\n        ii = memloc(XParam, 0, 0, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n        ir = memloc(XParam, XParam.blkwidth, XParam.blkwidth - 1, ib);\n        it = memloc(XParam, XParam.blkwidth-1, XParam.blkwidth, ib);\n        zz = T(0.5) * z[ii] + T(0.25) * ( z[ir] +  z[it]);\n    }\n\n    z[write] = zz;\n\n    //Bot Right corner\n    write = memloc(XParam, XParam.blkwidth, -1, ib);\n    //check that there is a block there and if there is calculate the value depending on the level of that block\n    if (XBlock.RightBot[XBlock.BotRight[ib]] == XBlock.BotRight[ib]) // There is no block\n    {\n        zz = T(0.5) * (z[memloc(XParam, XParam.blkwidth-1, - 1, ib)] + z[memloc(XParam, XParam.blkwidth , 0, ib)]);\n    }\n    else if (XBlock.level[XBlock.RightBot[XBlock.BotRight[ib]]] == XBlock.level[ib])\n    {\n        zz = z[memloc(XParam, 0, XParam.blkwidth - 1, XBlock.RightBot[XBlock.BotRight[ib]])];\n    }\n    else if (XBlock.level[XBlock.RightBot[XBlock.BotRight[ib]]] &gt; XBlock.level[ib])\n    {\n        ii = memloc(XParam, 0, XParam.blkwidth - 1, XBlock.RightBot[XBlock.BotRight[ib]]);\n        ir = memloc(XParam, 0, XParam.blkwidth - 2, XBlock.RightBot[XBlock.BotRight[ib]]);\n        it = memloc(XParam, 1, XParam.blkwidth - 1, XBlock.RightBot[XBlock.BotRight[ib]]);\n        itr = memloc(XParam, 1, XParam.blkwidth - 2, XBlock.RightBot[XBlock.BotRight[ib]]);\n\n        zz = T(0.25) * (z[ii] + z[ir] + z[it] + z[itr]);\n    }\n    else if (XBlock.level[XBlock.RightBot[XBlock.BotRight[ib]]] &lt; XBlock.level[ib])\n    {\n        ii = memloc(XParam, 0, XParam.blkwidth - 1, XBlock.LeftBot[XBlock.TopLeft[ib]]);\n        ir = memloc(XParam, XParam.blkwidth - 1, -1, ib);\n        it = memloc(XParam, XParam.blkwidth, 0, ib);\n        zz = T(0.5) * z[ii] + T(0.25) * (z[ir] + z[it]);\n    }\n\n    z[write] = zz;\n\n}\ntemplate void fillCorners&lt;float&gt;(Param XParam, int ib, BlockP&lt;float&gt; XBlock, float*&amp; z);\ntemplate void fillCorners&lt;double&gt;(Param XParam, int ib, BlockP&lt;double&gt; XBlock, double*&amp; z);\n\ntemplate &lt;class T&gt; __global__ void fillCornersGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    int blkmemwidth = XParam.blkwidth + XParam.halowidth * 2;\n    int halowidth = XParam.halowidth;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    //int iy = threadIdx.y;\n    //unsigned int iy = blockDim.x-1;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int TL = XBlock.TopLeft[ib];\n    int TR = XBlock.TopRight[ib];\n    int LB = XBlock.LeftBot[ib];\n    int LT = XBlock.LeftTop[ib];\n    int BL = XBlock.BotLeft[ib];\n    int BR = XBlock.BotRight[ib];\n    int RB = XBlock.RightBot[ib];\n    int RT = XBlock.RightTop[ib];\n\n    //int LBTL = XBlock.leftbot[TL];\n    //int BLTL = XBlock.botleft[TL];\n    //int RBTR = XBlock.rightbot[TR];\n\n    int iout, ii;\n\n\n    if (ix == 0)\n    {\n        // Bot left corner\n\n        iout = memloc(halowidth, blkmemwidth, -1, -1, ib);\n\n\n        if (BL == ib &amp;&amp; LB == ib)//\n        {\n            ii = memloc(halowidth, blkmemwidth, 0, 0, ib);\n        }\n        else\n        {\n            if (BL != ib)\n            {\n                ii = memloc(halowidth, blkmemwidth, -1, XParam.blkwidth - 1, BL);\n            }\n            else\n            {\n                ii = memloc(halowidth, blkmemwidth, XParam.blkwidth - 1, -1, LB);\n            }\n\n        }\n        z[iout] = z[ii];\n    }\n    if (ix == 1)\n    {\n\n        // Top left corner\n        iout = memloc(halowidth, blkmemwidth, -1, XParam.blkwidth, ib);\n        if (TL == ib &amp;&amp; LT == ib)//\n        {\n            ii = memloc(halowidth, blkmemwidth, 0, XParam.blkwidth - 1, ib);\n        }\n        else\n        {\n            if (TL != ib)\n            {\n                ii = memloc(halowidth, blkmemwidth, -1, 0, TL);\n            }\n            else\n            {\n                ii = memloc(halowidth, blkmemwidth, XParam.blkwidth, XParam.blkwidth - 1, LT);\n            }\n\n        }\n        z[iout] = z[ii];\n\n    }\n    if (ix == 2)\n    {\n        // Top right corner\n        iout = memloc(halowidth, blkmemwidth, XParam.blkwidth, XParam.blkwidth, ib);\n        if (TR == ib &amp;&amp; RT == ib)//\n        {\n            ii = memloc(halowidth, blkmemwidth, XParam.blkwidth - 1, XParam.blkwidth - 1, ib);\n        }\n        else\n        {\n            if (TR != ib)\n            {\n                ii = memloc(halowidth, blkmemwidth, XParam.blkwidth, 0, TR);\n            }\n            else\n            {\n                ii = memloc(halowidth, blkmemwidth, 0, XParam.blkwidth, RT);\n            }\n\n        }\n        z[iout] = z[ii];\n\n    }\n    if (ix == 3)\n    {\n        // Bot right corner\n        iout = memloc(halowidth, blkmemwidth, XParam.blkwidth, -1, ib);\n        if (BR == ib &amp;&amp; RB == ib)//\n        {\n            ii = memloc(halowidth, blkmemwidth, XParam.blkwidth - 1, 0, ib);\n        }\n        else\n        {\n            if (BR != ib)\n            {\n                ii = memloc(halowidth, blkmemwidth, XParam.blkwidth, XParam.blkwidth - 1, BR);\n            }\n            else\n            {\n                ii = memloc(halowidth, blkmemwidth, 0, -1, RB);\n            }\n\n        }\n        z[iout] = z[ii];\n    }\n\n}\ntemplate __global__ void fillCornersGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z);\ntemplate __global__ void fillCornersGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z);\n</code></pre>"},{"location":"BGFlood/_halo_8h/","title":"File Halo.h","text":""},{"location":"BGFlood/_halo_8h/#file-haloh","title":"File Halo.h","text":"<p>FileList &gt; src &gt; Halo.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Mesh.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Boundary.h\"</code></li> <li><code>#include \"ConserveElevation.h\"</code></li> </ul>"},{"location":"BGFlood/_halo_8h/#public-functions","title":"Public Functions","text":"Type Name __global__ void HaloFluxGPUBT (Param XParam, BlockP&lt; T &gt; XBlock, T * z) GPU kernel for applying halo flux correction on the top and bottom boundaries of all active blocks. __global__ void HaloFluxGPUBTnew (Param XParam, BlockP&lt; T &gt; XBlock, T * z) GPU kernel for applying halo flux correction on the top and bottom boundaries of all active blocks. __global__ void HaloFluxGPULR (Param XParam, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for applying halo flux correction on the left and right boundaries of all active blocks. __global__ void HaloFluxGPULRnew (Param XParam, BlockP&lt; T &gt; XBlock, T * z) GPU kernel for applying halo flux correction on the left and right boundaries of all active blocks. void RecalculateZs (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) Recalculate water surface after recalculating the values on the halo on the CPU. __global__ void RecalculateZsGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb)  void Recalculatehh (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) Recalculate water depth after recalculating the values on the halo on the CPU. void bndmaskGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, FluxP&lt; T &gt; Flux) Wrapping function for applying boundary masks to flux variables on GPU. void fillBot (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z) Function to fill the bottom halo region of a block, handling various neighbor configurations. __global__ void fillBot (int halowidth, int * active, int * level, int * botleft, int * botright, int * topleft, int * lefttop, int * righttop, T * a) CUDA kernel to fill the bottom halo region of blocks in parallel, handling various neighbor configurations. __global__ void fillBotnew (int halowidth, int nblk, int * active, int * level, int * botleft, int * botright, int * topleft, int * lefttop, int * righttop, T * a) CUDA kernel to fill the bottom halo region of blocks in parallel for new refinement, handling various neighbor configurations, new version. void fillCorners (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z) Function to fill the corner halo regions for a specific block, handling various neighbor configurations. void fillCorners (Param XParam, BlockP&lt; T &gt; XBlock, T *&amp; z) Function to fill the corner halo regions for all active blocks. void fillCorners (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; &amp; Xev) Function to fill the corner halo regions for all active blocks and all evolving variables. __global__ void fillCornersGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z) CUDA kernel to fill the corner halo regions for all active blocks in parallel, handling various neighbor configurations. void fillHalo (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) Wrapping function for calculating halos for each block and each variable on CPU. void fillHalo (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev) Wrapping function for calculating halos for each block and each variable on CPU. void fillHalo (Param XParam, BlockP&lt; T &gt; XBlock, GradientsP&lt; T &gt; Grad) Wrapping function for calculating halos for each block and each variable on CPU. void fillHalo (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux) Wrapping function for calculating flux halos for each block and each variable on CPU. void fillHaloC (Param XParam, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating halos for each block of a single variable on CPU. void fillHaloF (Param XParam, bool doProlongation, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating flux in the halos for a block and a single variable on CPU. void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z) Wrapping function for calculating halos for each block of a single variable on GPU. void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating halos for each block of a single variable on GPU. void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev) Wrapping function for calculating halos for each block and each variable on GPU. void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; Xev, T * zb) Wrapping function for calculating halos for each block and each variable on GPU. void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, GradientsP&lt; T &gt; Grad) Wrapping function for calculating halos for each block and each variable on GPU. void fillHaloGPU (Param XParam, BlockP&lt; T &gt; XBlock, FluxP&lt; T &gt; Flux) Wrapping function for calculating flux halos for each block and each variable on GPU. void fillHaloGPUnew (Param XParam, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z) Wrapping function for calculating halos for each block of a single variable on GPU. New version. void fillHaloTopRightC (Param XParam, BlockP&lt; T &gt; XBlock, T * z) Wrapping function for calculating flux for halos for each block of a single variable on GPU. void fillHaloTopRightGPU (Param XParam, bool doprolong, BlockP&lt; T &gt; XBlock, cudaStream_t stream, T * z)  void fillLeft (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z) Applying halo flux correction on the left boundaries of all active blocks on GPU. __global__ void fillLeft (int halowidth, int * active, int * level, int * leftbot, int * lefttop, int * rightbot, int * botright, int * topright, T * a) GPU kernel for applying halo flux correction on the left boundaries of all active blocks. __global__ void fillLeftnew (int halowidth, int nblk, int * active, int * level, int * leftbot, int * lefttop, int * rightbot, int * botright, int * topright, T * a) New way of filling the left halo 2 blocks at a time to maximize GPU occupancy. void fillRight (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z) Fills the right halo region of a block. __global__ void fillRight (int halowidth, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, T * a) CUDA kernel to fill the right halo region of blocks in parallel. void fillRightFlux (Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z) Function to fill the right halo region of a block, handling various neighbor configurations. __global__ void fillRightFlux (int halowidth, bool doProlongation, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, T * a) CUDA kernel to fill the right halo region of blocks in parallel for flux variables, handling various neighbor configurations. __global__ void fillRightnew (int halowidth, int nblk, int * active, int * level, int * rightbot, int * righttop, int * leftbot, int * botleft, int * topleft, T * a) CUDA kernel to fill the right halo region of blocks in parallel (new version). void fillTop (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z) Fills the top halo region of a block, handling various neighbor configurations. __global__ void fillTop (int halowidth, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, T * a) CUDA kernel to fill the top halo region of blocks in parallel for new refinement, handling various neighbor configurations, new version. void fillTopFlux (Param XParam, bool doProlongation, int ib, BlockP&lt; T &gt; XBlock, T *&amp; z) Function to fill the top halo region of a block for new refinement, handling various neighbor configurations. __global__ void fillTopFlux (int halowidth, bool doProlongation, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, T * a) CUDA kernel to fill the top halo region of blocks in parallel for new refinement, handling various neighbor configurations, new version. __global__ void fillTopnew (int halowidth, int nblk, int * active, int * level, int * topleft, int * topright, int * botleft, int * leftbot, int * rightbot, T * a)  void refine_linear (Param XParam, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy) Wrapping function for refining all sides of active blocks using linear reconstruction. void refine_linearGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy) Wrapping function for refining all sides of active blocks using linear reconstruction on GPU. void refine_linear_Bot (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z, T * dzdy)  void refine_linear_Left (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z, T * dzdx, T * dzdy) Refine a block on the left side using linear reconstruction. void refine_linear_Right (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z, T * dzdx)  void refine_linear_Top (Param XParam, int ib, BlockP&lt; T &gt; XBlock, T * z, T * dzdy)"},{"location":"BGFlood/_halo_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_halo_8h/#function-halofluxgpubt","title":"function HaloFluxGPUBT","text":"<p>GPU kernel for applying halo flux correction on the top and bottom boundaries of all active blocks. </p><pre><code>template&lt;class T&gt;\n__global__ void HaloFluxGPUBT (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-halofluxgpubtnew","title":"function HaloFluxGPUBTnew","text":"<p>GPU kernel for applying halo flux correction on the top and bottom boundaries of all active blocks. </p><pre><code>template&lt;class T&gt;\n__global__ void HaloFluxGPUBTnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-halofluxgpulr","title":"function HaloFluxGPULR","text":"<p>Wrapping function for applying halo flux correction on the left and right boundaries of all active blocks. </p><pre><code>template&lt;class T&gt;\n__global__ void HaloFluxGPULR (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-halofluxgpulrnew","title":"function HaloFluxGPULRnew","text":"<p>GPU kernel for applying halo flux correction on the left and right boundaries of all active blocks. </p><pre><code>template&lt;class T&gt;\n__global__ void HaloFluxGPULRnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-recalculatezs","title":"function RecalculateZs","text":"<p>Recalculate water surface after recalculating the values on the halo on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid RecalculateZs (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre> <p>Recalculate water surface after recalculating the values on the halo on the GPU.</p> <p>!</p>"},{"location":"BGFlood/_halo_8h/#description","title":"Description","text":"<p>Recalculate water surface after recalculating the values on the halo on the CPU. zb (bottom elevation) on each halo is calculated at the start of the loop or as part of the initial condition. When conserve-elevation is not required, only h is recalculated on the halo at ever 1/2 steps.   zs then needs to be recalculated to obtain a mass-conservative solution (if zs is conserved then mass conservation is not garanteed)</p> <p>Warning:</p> <p>This function calculate zs everywhere in the block... this is a bit unecessary. Instead it should recalculate only where there is a prolongation or a restiction</p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Xev</code> The evolving structure containing the evolving variables </li> <li><code>zb</code> The bottom elevation variable </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double)</li> </ul> <p>!</p>"},{"location":"BGFlood/_halo_8h/#description_1","title":"Description","text":"<p>Recalculate water surface after recalculating the values on the halo on the CPU. zb (bottom elevation) on each halo is calculated at the start of the loop or as part of the initial condition. When conserve-elevation is not required, only h is recalculated on the halo at ever 1/2 steps. zs then needs to be recalculated to obtain a mass-conservative solution (if zs is conserved then mass conservation is not garanteed)</p> <p>Warning:</p> <p>This function calculate zs everywhere in the block... this is a bit unecessary. Instead it should recalculate only where there is a prolongation or a restiction </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Xev</code> The evolving structure containing the evolving variables </li> <li><code>zb</code> The bottom elevation variable </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-recalculatezsgpu","title":"function RecalculateZsGPU","text":"<pre><code>template&lt;class T&gt;\n__global__ void RecalculateZsGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8h/#function-recalculatehh","title":"function Recalculatehh","text":"<p>Recalculate water depth after recalculating the values on the halo on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid Recalculatehh (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8h/#description_2","title":"Description","text":"<p>Recalculate water depth after recalculating the values on the halo on the CPU. zb (bottom elevation) on each halo is calculated at the start of the loop or as part of the initial condition. When conserve-elevation is not required, only h is recalculated on the halo at ever 1/2 steps. zs then needs to be recalculated to obtain a mass-conservative solution (if zs is conserved then mass conservation is not garanteed) </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Xev</code> The evolving structure containing the evolving variables </li> <li><code>zb</code> The bottom elevation variable </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-bndmaskgpu","title":"function bndmaskGPU","text":"<p>Wrapping function for applying boundary masks to flux variables on GPU. </p><pre><code>template&lt;class T&gt;\nvoid bndmaskGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Xev</code> The evolving structure containing the evolving variables </li> <li><code>Flux</code> The flux structure containing the flux variables </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillbot","title":"function fillBot","text":"<p>Function to fill the bottom halo region of a block, handling various neighbor configurations. </p><pre><code>template&lt;class T&gt;\nvoid fillBot (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameters of the grid and blocks </li> <li><code>ib</code> The index of the current block </li> <li><code>XBlock</code> The block structure containing neighbor information </li> <li><code>z</code> The variable to be refined </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillbot_1","title":"function fillBot","text":"<p>CUDA kernel to fill the bottom halo region of blocks in parallel, handling various neighbor configurations. </p><pre><code>template&lt;class T&gt;\n__global__ void fillBot (\n    int halowidth,\n    int * active,\n    int * level,\n    int * botleft,\n    int * botright,\n    int * topleft,\n    int * lefttop,\n    int * righttop,\n    T * a\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>botleft</code> The array of bottom left neighbor block indices </li> <li><code>botright</code> The array of bottom right neighbor block indices </li> <li><code>topleft</code> The array of top left neighbor block indices </li> <li><code>lefttop</code> The array of left top neighbor block indices </li> <li><code>righttop</code> The array of right top neighbor block indices </li> <li><code>a</code> The variable to be refined </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillbotnew","title":"function fillBotnew","text":"<p>CUDA kernel to fill the bottom halo region of blocks in parallel for new refinement, handling various neighbor configurations, new version. </p><pre><code>template&lt;class T&gt;\n__global__ void fillBotnew (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * botleft,\n    int * botright,\n    int * topleft,\n    int * lefttop,\n    int * righttop,\n    T * a\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>nblk</code> The number of active blocks </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>botleft</code> The array of bottom left neighbor block indices </li> <li><code>botright</code> The array of bottom right neighbor block indices </li> <li><code>topleft</code> The array of top left neighbor block indices </li> <li><code>lefttop</code> The array of left top neighbor block indices </li> <li><code>righttop</code> The array of right top neighbor block indices </li> <li><code>a</code> The variable to be refined </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillcorners","title":"function fillCorners","text":"<p>Function to fill the corner halo regions for a specific block, handling various neighbor configurations. </p><pre><code>template&lt;class T&gt;\nvoid fillCorners (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameters of the grid and blocks </li> <li><code>ib</code> The index of the block to be processed </li> <li><code>XBlock</code> The structure containing block neighbor information </li> <li><code>z</code> The variable to be processed </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillcorners_1","title":"function fillCorners","text":"<p>Function to fill the corner halo regions for all active blocks. </p><pre><code>template&lt;class T&gt;\nvoid fillCorners (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameters of the grid and blocks </li> <li><code>XBlock</code> The structure containing block neighbor information </li> <li><code>z</code> The variable to be processed </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillcorners_2","title":"function fillCorners","text":"<p>Function to fill the corner halo regions for all active blocks and all evolving variables. </p><pre><code>template&lt;class T&gt;\nvoid fillCorners (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; &amp; Xev\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameters of the grid and blocks </li> <li><code>XBlock</code> The structure containing block neighbor information </li> <li><code>Xev</code> The structure containing evolving variables </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type of the variables (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillcornersgpu","title":"function fillCornersGPU","text":"<p>CUDA kernel to fill the corner halo regions for all active blocks in parallel, handling various neighbor configurations. </p><pre><code>template&lt;class T&gt;\n__global__ void fillCornersGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameters of the grid and blocks </li> <li><code>XBlock</code> The structure containing block neighbor information </li> <li><code>z</code> The variable to be processed </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillhalo","title":"function fillHalo","text":"<p>Wrapping function for calculating halos for each block and each variable on CPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8h/#description_3","title":"Description","text":"<p>This function is a wraping fuction of the halo functions on CPU. It is called from the main Halo function. It uses multithreading to calculate the halos of the 4 variables in parallel. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Xev</code> The evolving structure containing the evolving variables </li> <li><code>zb</code> The bottom elevation variable </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillhalo_1","title":"function fillHalo","text":"<p>Wrapping function for calculating halos for each block and each variable on CPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev\n) \n</code></pre>"},{"location":"BGFlood/_halo_8h/#description_4","title":"Description","text":"<p>This function is a wraping fuction of the halo functions on CPU. It is called from the main Halo function. It uses multithreading to calculate the halos of the 4 variables in parallel. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Xev</code> The evolving structure containing the evolving variables </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillhalo_2","title":"function fillHalo","text":"<p>Wrapping function for calculating halos for each block and each variable on CPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    GradientsP &lt; T &gt; Grad\n) \n</code></pre>"},{"location":"BGFlood/_halo_8h/#description_5","title":"Description","text":"<p>This function is a wrapping function of the halo functions on CPU. It is called from the main Halo function. It uses multithreading to calculate the halos of the 4 variables in parallel. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Grad</code> The gradients structure containing the gradients </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillhalo_3","title":"function fillHalo","text":"<p>Wrapping function for calculating flux halos for each block and each variable on CPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHalo (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Flux</code> The flux structure containing the flux variables </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillhaloc","title":"function fillHaloC","text":"<p>Wrapping function for calculating halos for each block of a single variable on CPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloC (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>!</p>"},{"location":"BGFlood/_halo_8h/#description_6","title":"Description","text":"<p>This function is a wraping fuction of the halo functions on CPU. It is called from the main Halo CPU function. This is layer 2 of 3 wrap so the candy doesn't stick too much. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to work on </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillhalof","title":"function fillHaloF","text":"<p>Wrapping function for calculating flux in the halos for a block and a single variable on CPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloF (\n    Param XParam,\n    bool doProlongation,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>! </p> <p>Deprecated</p> <p>This function is was never sucessful and will never be used. It is fundamentally flawed because is doesn't preserve the balance of fluxes on the restiction interface. It should be deleted soon.</p>"},{"location":"BGFlood/_halo_8h/#function-fillhalogpu","title":"function fillHaloGPU","text":"<p>Wrapping function for calculating halos for each block of a single variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre> <p>!</p>"},{"location":"BGFlood/_halo_8h/#description_7","title":"Description","text":"<p>This function is a wraping fuction of the halo functions on GPU. It is called from the main Halo GPU function. The present imnplementation is naive and slow one that calls the rather complex fillLeft type functions </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>stream</code> The cuda stream to use </li> <li><code>z</code> The variable to work on </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillhalogpu_1","title":"function fillHaloGPU","text":"<p>Wrapping function for calculating halos for each block of a single variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>Deprecated</p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>stream</code> The cuda stream to use </li> <li><code>z</code> The variable to work on </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillhalogpu_2","title":"function fillHaloGPU","text":"<p>Wrapping function for calculating halos for each block and each variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Xev</code> The evolving structure containing the evolving variables </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillhalogpu_3","title":"function fillHaloGPU","text":"<p>Wrapping function for calculating halos for each block and each variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; Xev,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_halo_8h/#description_8","title":"Description","text":"<p>This function is a wraping fuction of the halo functions on GPU. It is called from the main Halo GPU function. It uses multiple cuda streams to calculate the halos of the 4 variables in parallel. After filling the halos, it applies either the elevation conservation or wet-dry fix if enabled in parameters. Finally, it recalculates the surface elevation zs based on the updated water depth h and bottom elevation zb. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Xev</code> The evolving structure containing the evolving variables </li> <li><code>zb</code> The bottom elevation variable </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillhalogpu_4","title":"function fillHaloGPU","text":"<p>Wrapping function for calculating halos for each block and each variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    GradientsP &lt; T &gt; Grad\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Grad</code> The gradients structure containing the gradients </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillhalogpu_5","title":"function fillHaloGPU","text":"<p>Wrapping function for calculating flux halos for each block and each variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    FluxP &lt; T &gt; Flux\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>Flux</code> The flux structure containing the flux variables </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillhalogpunew","title":"function fillHaloGPUnew","text":"<p>Wrapping function for calculating halos for each block of a single variable on GPU. New version. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloGPUnew (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>stream</code> The cuda stream to use </li> <li><code>z</code> The variable to work on </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillhalotoprightc","title":"function fillHaloTopRightC","text":"<p>Wrapping function for calculating flux for halos for each block of a single variable on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillHaloTopRightC (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8h/#description_9","title":"Description","text":"<p>This function is a wraping function of the halo flux functions on GPU. It is called from the main Halo GPU function. The present imnplementation is naive and slow one that calls the rather complex fillLeft type functions </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to work on </li> </ul> <p>Note:</p> <p>For flux term and actually most terms, only top and right neighbours are needed! </p>"},{"location":"BGFlood/_halo_8h/#function-fillhalotoprightgpu","title":"function fillHaloTopRightGPU","text":"<pre><code>template&lt;class T&gt;\nvoid fillHaloTopRightGPU (\n    Param XParam,\n    bool doprolong,\n    BlockP &lt; T &gt; XBlock,\n    cudaStream_t stream,\n    T * z\n) \n</code></pre>"},{"location":"BGFlood/_halo_8h/#function-fillleft","title":"function fillLeft","text":"<p>Applying halo flux correction on the left boundaries of all active blocks on GPU. </p><pre><code>template&lt;class T&gt;\nvoid fillLeft (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>ib</code> The block index </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillleft_1","title":"function fillLeft","text":"<p>GPU kernel for applying halo flux correction on the left boundaries of all active blocks. </p><pre><code>template&lt;class T&gt;\n__global__ void fillLeft (\n    int halowidth,\n    int * active,\n    int * level,\n    int * leftbot,\n    int * lefttop,\n    int * rightbot,\n    int * botright,\n    int * topright,\n    T * a\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>leftbot</code> The array of left bottom neighbor block indices </li> <li><code>lefttop</code> The array of left top neighbor block indices </li> <li><code>rightbot</code> The array of right bottom neighbor block indices </li> <li><code>botright</code> The array of bottom right neighbor block indices </li> <li><code>topright</code> The array of top right neighbor block indices </li> <li><code>a</code> The variable to be refined </li> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillleftnew","title":"function fillLeftnew","text":"<p>New way of filling the left halo 2 blocks at a time to maximize GPU occupancy. </p><pre><code>template&lt;class T&gt;\n__global__ void fillLeftnew (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * leftbot,\n    int * lefttop,\n    int * rightbot,\n    int * botright,\n    int * topright,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8h/#description_10","title":"Description","text":"<p>This fuction is a wraping fuction of the halo functions for CPU. It is called from another wraping function to keep things clean. In a sense this is the third (and last) layer of wrapping</p> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>nblk</code> The number of active blocks </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>leftbot</code> The array of left bottom neighbor block indices </li> <li><code>lefttop</code> The array of left top neighbor block indices </li> <li><code>rightbot</code> The array of right bottom neighbor block indices </li> <li><code>botright</code> The array of bottom right neighbor block indices </li> <li><code>topright</code> The array of top right neighbor block indices </li> <li><code>a</code> The variable to be refined </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillright","title":"function fillRight","text":"<p>Fills the right halo region of a block. </p><pre><code>template&lt;class T&gt;\nvoid fillRight (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The simulation parameters </li> <li><code>ib</code> The index of the block to process </li> <li><code>XBlock</code> The block structure containing neighbor information </li> <li><code>z</code> The variable to be refined </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillright_1","title":"function fillRight","text":"<p>CUDA kernel to fill the right halo region of blocks in parallel. </p><pre><code>template&lt;class T&gt;\n__global__ void fillRight (\n    int halowidth,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    T * a\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>rightbot</code> The array of right bottom neighbor block indices </li> <li><code>righttop</code> The array of right top neighbor block indices </li> <li><code>leftbot</code> The array of left bottom neighbor block indices </li> <li><code>botleft</code> The array of bottom left neighbor block indices </li> <li><code>topleft</code> The array of top left neighbor block indices </li> <li><code>a</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillrightflux","title":"function fillRightFlux","text":"<p>Function to fill the right halo region of a block, handling various neighbor configurations. </p><pre><code>template&lt;class T&gt;\nvoid fillRightFlux (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameters of the grid and blocks </li> <li><code>doProlongation</code> Flag indicating whether to perform prolongation </li> <li><code>ib</code> The index of the current block </li> <li><code>XBlock</code> The block structure containing neighbor information </li> <li><code>z</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillrightflux_1","title":"function fillRightFlux","text":"<p>CUDA kernel to fill the right halo region of blocks in parallel for flux variables, handling various neighbor configurations. </p><pre><code>template&lt;class T&gt;\n__global__ void fillRightFlux (\n    int halowidth,\n    bool doProlongation,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    T * a\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>doProlongation</code> Flag indicating whether to perform prolongation </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>rightbot</code> The array of right bottom neighbor block indices </li> <li><code>righttop</code> The array of right top neighbor block indices </li> <li><code>leftbot</code> The array of left bottom neighbor block indices </li> <li><code>botleft</code> The array of bottom left neighbor block indices </li> <li><code>topleft</code> The array of top left neighbor block indices </li> <li><code>a</code> The variable to be refined </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-fillrightnew","title":"function fillRightnew","text":"<p>CUDA kernel to fill the right halo region of blocks in parallel (new version). </p><pre><code>template&lt;class T&gt;\n__global__ void fillRightnew (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * rightbot,\n    int * righttop,\n    int * leftbot,\n    int * botleft,\n    int * topleft,\n    T * a\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>nblk</code> The number of active blocks </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>rightbot</code> The array of right bottom neighbor block indices </li> <li><code>righttop</code> The array of right top neighbor block indices </li> <li><code>leftbot</code> The array of left bottom neighbor block indices </li> <li><code>botleft</code> The array of bottom left neighbor block indices </li> <li><code>topleft</code> The array of top left neighbor block indices </li> <li><code>a</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-filltop","title":"function fillTop","text":"<p>Fills the top halo region of a block, handling various neighbor configurations. </p><pre><code>template&lt;class T&gt;\nvoid fillTop (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameters of the grid/block structure </li> <li><code>ib</code> The index of the current block </li> <li><code>XBlock</code> The block structure containing neighbor information </li> <li><code>z</code> The variable to be refined </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-filltop_1","title":"function fillTop","text":"<p>CUDA kernel to fill the top halo region of blocks in parallel for new refinement, handling various neighbor configurations, new version. </p><pre><code>template&lt;class T&gt;\n__global__ void fillTop (\n    int halowidth,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    T * a\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>topleft</code> The array of top left neighbor block indices </li> <li><code>topright</code> The array of top right neighbor block indices </li> <li><code>botleft</code> The array of bottom left neighbor block indices </li> <li><code>leftbot</code> The array of left bottom neighbor block indices </li> <li><code>rightbot</code> The array of right bottom neighbor block indices </li> <li><code>a</code> The variable to be refined </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-filltopflux","title":"function fillTopFlux","text":"<p>Function to fill the top halo region of a block for new refinement, handling various neighbor configurations. </p><pre><code>template&lt;class T&gt;\nvoid fillTopFlux (\n    Param XParam,\n    bool doProlongation,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameters of the grid and blocks </li> <li><code>doProlongation</code> Flag indicating whether to perform prolongation </li> <li><code>ib</code> The index of the block to be processed </li> <li><code>XBlock</code> The structure containing block neighbor information </li> <li><code>z</code> The variable to be refined </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-filltopflux_1","title":"function fillTopFlux","text":"<p>CUDA kernel to fill the top halo region of blocks in parallel for new refinement, handling various neighbor configurations, new version. </p><pre><code>template&lt;class T&gt;\n__global__ void fillTopFlux (\n    int halowidth,\n    bool doProlongation,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    T * a\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>halowidth</code> The width of the halo region </li> <li><code>doProlongation</code> Flag indicating whether to perform prolongation </li> <li><code>active</code> The array of active block indices </li> <li><code>level</code> The array of block levels </li> <li><code>topleft</code> The array of top left neighbor block indices </li> <li><code>topright</code> The array of top right neighbor block indices </li> <li><code>botleft</code> The array of bottom left neighbor block indices </li> <li><code>leftbot</code> The array of left bottom neighbor block indices </li> <li><code>rightbot</code> The array of right bottom neighbor block indices </li> <li><code>a</code> The variable to be refined </li> <li><code>T</code> The data type of the variable (e.g., float, double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-filltopnew","title":"function fillTopnew","text":"<pre><code>template&lt;class T&gt;\n__global__ void fillTopnew (\n    int halowidth,\n    int nblk,\n    int * active,\n    int * level,\n    int * topleft,\n    int * topright,\n    int * botleft,\n    int * leftbot,\n    int * rightbot,\n    T * a\n) \n</code></pre>"},{"location":"BGFlood/_halo_8h/#function-refine_linear","title":"function refine_linear","text":"<p>Wrapping function for refining all sides of active blocks using linear reconstruction. </p><pre><code>template&lt;class T&gt;\nvoid refine_linear (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> <li><code>dzdx</code> The gradient of z in the x direction </li> <li><code>dzdy</code> The gradient of z in the y direction </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-refine_lineargpu","title":"function refine_linearGPU","text":"<p>Wrapping function for refining all sides of active blocks using linear reconstruction on GPU. </p><pre><code>template&lt;class T&gt;\nvoid refine_linearGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> <li><code>dzdx</code> The gradient of z in the x direction </li> <li><code>dzdy</code> The gradient of z in the y direction </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-refine_linear_bot","title":"function refine_linear_Bot","text":"<pre><code>template&lt;class T&gt;\nvoid refine_linear_Bot (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8h/#function-refine_linear_left","title":"function refine_linear_Left","text":"<p>Refine a block on the left side using linear reconstruction. </p><pre><code>template&lt;class T&gt;\nvoid refine_linear_Left (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx,\n    T * dzdy\n) \n</code></pre>"},{"location":"BGFlood/_halo_8h/#description_11","title":"Description","text":"<p>This function refines a block on the left side using linear reconstruction. It checks if the neighboring block on the left is at a coarser level. If so, it calculates the new values for the left boundary of the current block using the gradients in the x and y directions. The new values are computed based on the distance to the neighboring block and the gradients, ensuring a smooth transition between different resolution levels. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> The model parameters </li> <li><code>ib</code> The index of the current block </li> <li><code>XBlock</code> The block structure containing the block information </li> <li><code>z</code> The variable to be refined </li> <li><code>dzdx</code> The gradient of z in the x direction </li> <li><code>dzdy</code> The gradient of z in the y direction </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> The data type (float or double) </li> </ul>"},{"location":"BGFlood/_halo_8h/#function-refine_linear_right","title":"function refine_linear_Right","text":"<pre><code>template&lt;class T&gt;\nvoid refine_linear_Right (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdx\n) \n</code></pre>"},{"location":"BGFlood/_halo_8h/#function-refine_linear_top","title":"function refine_linear_Top","text":"<pre><code>template&lt;class T&gt;\nvoid refine_linear_Top (\n    Param XParam,\n    int ib,\n    BlockP &lt; T &gt; XBlock,\n    T * z,\n    T * dzdy\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Halo.h</code></p>"},{"location":"BGFlood/_halo_8h_source/","title":"File Halo.h","text":""},{"location":"BGFlood/_halo_8h_source/#file-haloh","title":"File Halo.h","text":"<p>File List &gt; src &gt; Halo.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef HALO_H\n#define HALO_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"Mesh.h\"\n#include \"MemManagement.h\"\n#include \"Boundary.h\"\n#include \"ConserveElevation.h\"\n\ntemplate &lt;class T&gt; void fillHaloC(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\ntemplate &lt;class T&gt; void fillHaloF(Param XParam, bool doProlongation, BlockP&lt;T&gt; XBlock, T* z);\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z);\ntemplate &lt;class T&gt; void fillHaloGPUnew(Param XParam, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z);\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\n\ntemplate &lt;class T&gt; void fillHalo(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev,T*zb);\ntemplate &lt;class T&gt; void fillHalo(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev);\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev);\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\n\ntemplate &lt;class T&gt; void fillHalo(Param XParam, BlockP&lt;T&gt; XBlock, GradientsP&lt;T&gt; Grad);\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, GradientsP&lt;T&gt; Grad);\n\ntemplate &lt;class T&gt; void fillHalo(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux);\ntemplate &lt;class T&gt; void fillHaloGPU(Param XParam, BlockP&lt;T&gt; XBlock, FluxP&lt;T&gt; Flux);\n\ntemplate &lt;class T&gt; void fillHaloTopRightC(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\ntemplate &lt;class T&gt; void fillHaloTopRightGPU(Param XParam, bool doprolong, BlockP&lt;T&gt; XBlock, cudaStream_t stream, T* z);\n\ntemplate &lt;class T&gt; void bndmaskGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, FluxP&lt;T&gt; Flux);\n\ntemplate &lt;class T&gt; void fillLeft(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z);\ntemplate &lt;class T&gt; void fillRight(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z);\ntemplate &lt;class T&gt; void fillBot(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z);\ntemplate &lt;class T&gt; void fillTop(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z);\n\ntemplate &lt;class T&gt; void fillTopFlux(Param XParam, bool doProlongation, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z);\ntemplate &lt;class T&gt; void fillRightFlux(Param XParam, bool doProlongation, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z);\n\ntemplate &lt;class T&gt; void fillCorners(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T*&amp; z);\n\ntemplate &lt;class T&gt; void fillCorners(Param XParam, BlockP&lt;T&gt; XBlock, T*&amp; z);\ntemplate &lt;class T&gt; void fillCorners(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt;&amp; Xev);\n\ntemplate &lt;class T&gt; void RecalculateZs(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\ntemplate &lt;class T&gt; __global__ void RecalculateZsGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\n\ntemplate &lt;class T&gt; void Recalculatehh(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; Xev, T* zb);\n\ntemplate &lt;class T&gt; void refine_linear(Param XParam, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy);\ntemplate &lt;class T&gt; void refine_linearGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy);\n\ntemplate &lt;class T&gt; void refine_linear_Left(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z, T* dzdx, T* dzdy);\ntemplate &lt;class T&gt; void refine_linear_Top(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z, T* dzdy);\ntemplate &lt;class T&gt; void refine_linear_Bot(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z, T* dzdy);\ntemplate &lt;class T&gt; void refine_linear_Right(Param XParam, int ib, BlockP&lt;T&gt; XBlock, T* z, T* dzdx);\n\n// GPU versions\ntemplate &lt;class T&gt; __global__ void fillLeft(int halowidth, int* active, int* level, int* leftbot, int* lefttop, int* rightbot, int* botright, int* topright, T* a);\ntemplate &lt;class T&gt; __global__ void fillRight(int halowidth, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, T* a);\ntemplate &lt;class T&gt; __global__ void fillBot(int halowidth, int* active, int* level, int* botleft, int* botright, int* topleft, int* lefttop, int* righttop, T* a);\ntemplate &lt;class T&gt; __global__ void fillTop(int halowidth, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, T* a);\n\ntemplate &lt;class T&gt; __global__ void fillLeftnew(int halowidth, int nblk, int* active, int* level, int* leftbot, int* lefttop, int* rightbot, int* botright, int* topright, T* a);\ntemplate &lt;class T&gt; __global__ void fillRightnew(int halowidth, int nblk, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, T* a);\ntemplate &lt;class T&gt; __global__ void fillBotnew(int halowidth, int nblk, int* active, int* level, int* botleft, int* botright, int* topleft, int* lefttop, int* righttop, T* a);\ntemplate &lt;class T&gt; __global__ void fillTopnew(int halowidth, int nblk, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, T* a);\n\ntemplate &lt;class T&gt; __global__ void fillTopFlux(int halowidth, bool doProlongation, int* active, int* level, int* topleft, int* topright, int* botleft, int* leftbot, int* rightbot, T* a);\ntemplate &lt;class T&gt; __global__ void fillRightFlux(int halowidth, bool doProlongation, int* active, int* level, int* rightbot, int* righttop, int* leftbot, int* botleft, int* topleft, T* a);\n\n\ntemplate &lt;class T&gt; __global__  void HaloFluxGPULR(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\ntemplate &lt;class T&gt; __global__ void HaloFluxGPUBT(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\n\ntemplate &lt;class T&gt; __global__  void HaloFluxGPULRnew(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\ntemplate &lt;class T&gt; __global__ void HaloFluxGPUBTnew(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\n\ntemplate &lt;class T&gt; __global__ void fillCornersGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_init_evolv_8cu/","title":"File InitEvolv.cu","text":""},{"location":"BGFlood/_init_evolv_8cu/#file-initevolvcu","title":"File InitEvolv.cu","text":"<p>FileList &gt; src &gt; InitEvolv.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"InitEvolv.h\"</code></li> </ul>"},{"location":"BGFlood/_init_evolv_8cu/#public-functions","title":"Public Functions","text":"Type Name int AddZSoffset (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; &amp; XEv, T * zb) Add offset to surface elevation (zs) and update water depth (h). int coldstart (Param XParam, BlockP&lt; T &gt; XBlock, T * zb, EvolvingP&lt; T &gt; &amp; XEv) Cold start initialization of evolving variables. void initevolv (Param XParam, BlockP&lt; T &gt; XBlock, Forcing&lt; float &gt; XForcing, EvolvingP&lt; T &gt; &amp; XEv, T *&amp; zb) Initialize evolving variables for the simulation. template void initevolv&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, Forcing&lt; float &gt; XForcing, EvolvingP&lt; double &gt; &amp; XEv, double *&amp; zb)  template void initevolv&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, Forcing&lt; float &gt; XForcing, EvolvingP&lt; float &gt; &amp; XEv, float *&amp; zb)  int readhotstartfile (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; &amp; XEv, T *&amp; zb) Read hotstart file and initialize evolving variables and bathymetry. template int readhotstartfile&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; &amp; XEv, double *&amp; zb)  template int readhotstartfile&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; &amp; XEv, float *&amp; zb)  int readhotstartfileBG (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; &amp; XEv, T *&amp; zb) Read BG_Flood hotstart file and extract block attributes. void warmstart (Param XParam, Forcing&lt; float &gt; XForcing, BlockP&lt; T &gt; XBlock, T * zb, EvolvingP&lt; T &gt; &amp; XEv) Warm start initialization using boundary conditions and interpolation. void warmstartold (Param XParam, Forcing&lt; float &gt; XForcing, BlockP&lt; T &gt; XBlock, T * zb, EvolvingP&lt; T &gt; &amp; XEv) Legacy warm start initialization using inverse distance to boundaries."},{"location":"BGFlood/_init_evolv_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_init_evolv_8cu/#function-addzsoffset","title":"function AddZSoffset","text":"<p>Add offset to surface elevation (zs) and update water depth (h). </p><pre><code>template&lt;class T&gt;\nint AddZSoffset (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; &amp; XEv,\n    T * zb\n) \n</code></pre> <p>Applies zsoffset to zs and updates h for all blocks where h &gt; eps.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables (input/output) </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>Returns:</p> <p>Success flag (1 if successful) </p>"},{"location":"BGFlood/_init_evolv_8cu/#function-coldstart","title":"function coldstart","text":"<p>Cold start initialization of evolving variables. </p><pre><code>template&lt;class T&gt;\nint coldstart (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * zb,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre> <p>Sets initial water level, velocity, and bathymetry arrays for all blocks using specified zsinit and zsoffset.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>zb</code> Bathymetry array </li> <li><code>XEv</code> Evolving variables (output) </li> </ul> <p>Returns:</p> <p>Success flag (1 if successful) </p>"},{"location":"BGFlood/_init_evolv_8cu/#function-initevolv","title":"function initevolv","text":"<p>Initialize evolving variables for the simulation. </p><pre><code>template&lt;class T&gt;\nvoid initevolv (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    Forcing &lt; float &gt; XForcing,\n    EvolvingP &lt; T &gt; &amp; XEv,\n    T *&amp; zb\n) \n</code></pre> <p>Handles hotstart, coldstart, and warmstart initialization of water level, velocity, and bathymetry arrays. Applies offsets and boundary conditions as needed.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XForcing</code> Forcing/boundary conditions </li> <li><code>XEv</code> Evolving variables (output) </li> <li><code>zb</code> Bathymetry array (input/output) </li> </ul>"},{"location":"BGFlood/_init_evolv_8cu/#function-initevolv-double","title":"function initevolv&lt; double &gt;","text":"<pre><code>template void initevolv&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    Forcing &lt; float &gt; XForcing,\n    EvolvingP &lt; double &gt; &amp; XEv,\n    double *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_init_evolv_8cu/#function-initevolv-float","title":"function initevolv&lt; float &gt;","text":"<pre><code>template void initevolv&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    Forcing &lt; float &gt; XForcing,\n    EvolvingP &lt; float &gt; &amp; XEv,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_init_evolv_8cu/#function-readhotstartfile","title":"function readhotstartfile","text":"<p>Read hotstart file and initialize evolving variables and bathymetry. </p><pre><code>template&lt;class T&gt;\nint readhotstartfile (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; &amp; XEv,\n    T *&amp; zb\n) \n</code></pre> <p>Reads NetCDF hotstart file, extracts variables, and fills arrays for all blocks. Handles missing variables and applies edge corrections.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables (output) </li> <li><code>zb</code> Bathymetry array (output) </li> </ul> <p>Returns:</p> <p>Success flag (1 if successful, 0 if fallback to cold start) </p>"},{"location":"BGFlood/_init_evolv_8cu/#function-readhotstartfile-double","title":"function readhotstartfile&lt; double &gt;","text":"<pre><code>template int readhotstartfile&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; &amp; XEv,\n    double *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_init_evolv_8cu/#function-readhotstartfile-float","title":"function readhotstartfile&lt; float &gt;","text":"<pre><code>template int readhotstartfile&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; &amp; XEv,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_init_evolv_8cu/#function-readhotstartfilebg","title":"function readhotstartfileBG","text":"<p>Read BG_Flood hotstart file and extract block attributes. </p><pre><code>template&lt;class T&gt;\nint readhotstartfileBG (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; &amp; XEv,\n    T *&amp; zb\n) \n</code></pre> <p>Opens NetCDF hotstart file, checks for BG_Flood attribute, and closes file.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>Returns:</p> <p>Status code </p>"},{"location":"BGFlood/_init_evolv_8cu/#function-warmstart","title":"function warmstart","text":"<p>Warm start initialization using boundary conditions and interpolation. </p><pre><code>template&lt;class T&gt;\nvoid warmstart (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    BlockP &lt; T &gt; XBlock,\n    T * zb,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre> <p>Sets initial water level, velocity, and bathymetry arrays for all blocks using boundary segments and atmospheric pressure forcing.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XForcing</code> Forcing/boundary conditions </li> <li><code>XBlock</code> Block parameters </li> <li><code>zb</code> Bathymetry array </li> <li><code>XEv</code> Evolving variables (output) </li> </ul>"},{"location":"BGFlood/_init_evolv_8cu/#function-warmstartold","title":"function warmstartold","text":"<p>Legacy warm start initialization using inverse distance to boundaries. </p><pre><code>template&lt;class T&gt;\nvoid warmstartold (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    BlockP &lt; T &gt; XBlock,\n    T * zb,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre> <p>Sets initial water level, velocity, and bathymetry arrays for all blocks using inverse distance interpolation from boundaries.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XForcing</code> Forcing/boundary conditions </li> <li><code>XBlock</code> Block parameters </li> <li><code>zb</code> Bathymetry array </li> <li><code>XEv</code> Evolving variables (output) </li> </ul> <p>The documentation for this class was generated from the following file <code>src/InitEvolv.cu</code></p>"},{"location":"BGFlood/_init_evolv_8cu_source/","title":"File InitEvolv.cu","text":""},{"location":"BGFlood/_init_evolv_8cu_source/#file-initevolvcu","title":"File InitEvolv.cu","text":"<p>File List &gt; src &gt; InitEvolv.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //    \n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n\n#include \"InitEvolv.h\"\n\n#include \"InitEvolv.h\"\n\ntemplate &lt;class T&gt; void initevolv(Param XParam, BlockP&lt;T&gt; XBlock,Forcing&lt;float&gt; XForcing, EvolvingP&lt;T&gt; &amp;XEv,T* &amp;zb)\n{\n    //move this to a subroutine\n    int hotstartsucess = 0;\n    if (!XParam.hotstartfile.empty())\n    {\n        // hotstart\n        log(\"\\tHotstart file used : \" + XParam.hotstartfile);\n\n        hotstartsucess = readhotstartfile(XParam, XBlock, XEv, zb);\n\n        //add offset if present\n        if (T(XParam.zsoffset) != T(0.0)) // apply specified zsoffset\n        {\n            printf(\"\\t\\tadd offset to zs and hh... \");\n            //\n            AddZSoffset(XParam, XBlock, XEv, zb);\n\n        }\n\n\n        if (hotstartsucess == 0)\n        {\n            printf(\"\\t\\tFailed...  \");\n            write_text_to_log_file(\"\\tHotstart failed switching to cold start\");\n        }\n    }\n\n\n\n    if (XParam.hotstartfile.empty() || hotstartsucess == 0)\n    {\n        //printf(\"Cold start  \");\n        //log(\"Cold start\");\n        //Cold start\n        // 2 options:\n        //      (1) if zsinit is set, then apply zsinit everywhere\n        //      (2) zsinit is not set so interpolate from boundaries. (if no boundaries were specified set zsinit to zeros and apply case (1))\n\n        //Param defaultParam;\n\n        //case 0 (i.e. zsinint not specified by user and no boundaries were specified)\n        bool bndison = false;\n        for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n        {\n            if (XForcing.bndseg[iseg].on)\n            {\n                bndison = true;\n            }\n        }\n\n\n\n        if (std::isnan(XParam.zsinit) &amp;&amp; (!bndison)) //zsinit is default\n        {\n            XParam.zsinit = 0.0; // better default value than nan\n        }\n\n        //case 1 cold start\n\n        if (!std::isnan(XParam.zsinit)) // apply specified zsinit\n        {\n            log(\"\\tCold start\");\n            int coldstartsucess = 0;\n            coldstartsucess = coldstart(XParam, XBlock, zb, XEv);\n\n        }\n        // case 2 warm start\n        else // lukewarm start i.e. inv. dist interpolation of zs at bnds // Argggh!\n        {\n            log(\"\\tWarm start\");\n            warmstart(XParam, XForcing, XBlock, zb, XEv);\n\n        }// end else\n\n    }\n}\ntemplate void initevolv&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, Forcing&lt;float&gt; XForcing, EvolvingP&lt;float&gt; &amp;XEv, float* &amp;zb);\ntemplate void initevolv&lt;double&gt;(Param XParam, BlockP&lt; double &gt; XBlock, Forcing&lt;float&gt; XForcing, EvolvingP&lt; double &gt; &amp;XEv, double* &amp;zb);\n\n\ntemplate &lt;class T&gt;\nint coldstart(Param XParam, BlockP&lt;T&gt; XBlock, T* zb, EvolvingP&lt;T&gt; &amp; XEv)\n{\n    T zzini = std::isnan(XParam.zsinit)? T(0.0): T(XParam.zsinit);\n    T zzoffset = T(XParam.zsoffset);\n\n\n\n    int coldstartsucess = 0;\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n\n                XEv.u[n] = T(0.0);\n                XEv.v[n] = T(0.0);\n                //zb[n] = 0.0f;\n                XEv.zs[n] = utils::max(zzini + zzoffset, zb[n]);\n\n                //if (i &gt;= 64 &amp;&amp; i &lt; 82)\n                //{\n                //  zs[n] = max(zsbnd+0.2f, zb[i + j*nx]);\n                //}\n                XEv.h[n] = utils::max(XEv.zs[n] - zb[n], T(0.0));//0.0 or XParam.eps ??\n            }\n        }\n    }\n\n    coldstartsucess = 1;\n    return coldstartsucess;\n}\n\ntemplate &lt;class T&gt;\nvoid warmstart(Param XParam, Forcing&lt;float&gt; XForcing, BlockP&lt;T&gt; XBlock, T* zb, EvolvingP&lt;T&gt;&amp; XEv)\n{\n    int nuni=0;\n    int ndyn=0;\n\n    T zsbnduni=T(0.0);\n    T zsbnd;\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n        if (XForcing.bndseg[iseg].on)\n        {\n            if (XForcing.bndseg[iseg].uniform)\n            {\n                nuni++;\n\n                int SLstepinbnd = 1;\n\n                double difft = XForcing.bndseg[iseg].data[SLstepinbnd].time - XParam.totaltime;\n                while (difft &lt; 0.0)\n                {\n                    SLstepinbnd++;\n                    difft = XForcing.bndseg[iseg].data[SLstepinbnd].time - XParam.totaltime;\n                }\n\n                //itime = SLstepinbnd - 1.0 + (totaltime - bndseg.data[SLstepinbnd - 1].time) / (bndseg.data[SLstepinbnd].time - bndseg.data[SLstepinbnd - 1].time);\n                zsbnduni = zsbnduni + interptime(XForcing.bndseg[iseg].data[SLstepinbnd].wspeed, XForcing.bndseg[iseg].data[SLstepinbnd - 1].wspeed, XForcing.bndseg[iseg].data[SLstepinbnd].time - XForcing.bndseg[iseg].data[SLstepinbnd - 1].time, XParam.totaltime - XForcing.bndseg[iseg].data[SLstepinbnd - 1].time);\n\n            }\n            else\n            {\n                ndyn++;\n                Forcingthisstep(XParam, XParam.totaltime, XForcing.bndseg[iseg].WLmap);\n            }\n        }\n    }\n    if (nuni &gt; 0)\n    {\n        zsbnduni = zsbnduni / nuni;\n    }\n\n    int ib;\n    double xi, yi;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n\n                double levdx = calcres(XParam.dx, XBlock.level[ib]);\n                xi = XParam.xo + XBlock.xo[ib] + i * levdx;\n                yi = XParam.yo + XBlock.yo[ib] + j * levdx;\n\n                zsbnd = zsbnduni;\n\n                if (ndyn &gt; 0)\n                {\n                    zsbnd = zsbnduni * nuni;\n\n                    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n                    {\n                        if (XForcing.bndseg[iseg].on &amp;&amp; !XForcing.bndseg[iseg].uniform)\n                        {\n                            //\n                            zsbnd = zsbnd + float(interp2BUQ(xi, yi, XForcing.bndseg[iseg].WLmap));\n                        }\n                    }\n\n                    zsbnd = zsbnd / (nuni + ndyn);\n                }\n\n                if (XParam.atmpforcing)\n                {\n                    float atmpi;\n\n                    if (XForcing.Atmp.uniform)\n                    {\n                        atmpi = float(XForcing.Atmp.nowvalue);\n                    }\n                    else\n                    {\n                        atmpi = float(interp2BUQ(xi, yi, XForcing.Atmp));\n                    }\n                    zsbnd = zsbnd - (atmpi - (T)XParam.Paref) * (T)XParam.Pa2m;\n                }\n\n                XEv.zs[n] = utils::max(zsbnd, zb[n]);\n                XEv.h[n] = utils::max(XEv.zs[n] - zb[n], T(0.0));\n                XEv.u[n] = T(0.0);\n                XEv.v[n] = T(0.0);\n            }\n        }\n    }\n\n}\n\n\ntemplate &lt;class T&gt;\nvoid warmstartold(Param XParam,Forcing&lt;float&gt; XForcing, BlockP&lt;T&gt; XBlock, T* zb, EvolvingP&lt;T&gt;&amp; XEv)\n{\n    // This function read water level boundary if they have been setup and calculate the distance to the boundary \n    // toward the end the water level value is calculated as an inverse distance to the available boundaries.\n    // While this may look convoluted its working quite simply.\n    // look for each boundary side and calculate the closest water level value and the distance to that value\n\n    double zsleft = 0.0;\n    double zsright = 0.0;\n    double zstop = 0.0;\n    double zsbot = 0.0;\n    T zsbnd = 0.0;\n\n    double distleft, distright, disttop, distbot;\n\n    double lefthere = 0.0;\n    double righthere = 0.0;\n    double tophere = 0.0;\n    double bothere = 0.0;\n\n    double xi, yi, jj, ii;\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n\n                double levdx = calcres(XParam.dx, XBlock.level[ib]);\n                xi = XParam.xo + XBlock.xo[ib] + i * levdx;\n                yi = XParam.yo + XBlock.yo[ib] + j * levdx;\n\n                disttop = max((XParam.ymax - yi) / levdx, 0.1);//max((double)(ny - 1) - j, 0.1);// WTF is that 0.1? // distleft cannot be 0 //theoretical minumun is 0.5?\n                distbot = max((yi - XParam.yo) / levdx, 0.1);\n                distleft = max((xi - XParam.xo) / levdx, 0.1);//max((double)i, 0.1);\n                distright = max((XParam.xmax - xi) / levdx, 0.1);//max((double)(nx - 1) - i, 0.1);\n\n                jj = (yi - XParam.yo) / (XParam.ymax - XParam.yo);\n                ii = (xi - XParam.xo) / (XParam.xmax - XParam.xo);\n\n                if (XForcing.left.on)\n                {\n                    lefthere = 1.0;\n                    int SLstepinbnd = 1;\n\n\n\n                    // Do this for all the corners\n                    //Needs limiter in case WLbnd is empty\n                    double difft = XForcing.left.data[SLstepinbnd].time - XParam.totaltime;\n\n                    while (difft &lt; 0.0)\n                    {\n                        SLstepinbnd++;\n                        difft = XForcing.left.data[SLstepinbnd].time - XParam.totaltime;\n                    }\n                    std::vector&lt;double&gt; zsbndvec;\n                    for (int k = 0; k &lt; XForcing.left.data[SLstepinbnd].wlevs.size(); k++)\n                    {\n                        zsbndvec.push_back(interptime(XForcing.left.data[SLstepinbnd].wlevs[k], XForcing.left.data[SLstepinbnd - 1].wlevs[k], XForcing.left.data[SLstepinbnd].time - XForcing.left.data[SLstepinbnd - 1].time, XParam.totaltime - XForcing.left.data[SLstepinbnd - 1].time));\n\n                    }\n                    if (zsbndvec.size() == 1)\n                    {\n                        zsleft = zsbndvec[0];\n                    }\n                    else\n                    {\n                        int iprev = utils::min(utils::max((int)floor(jj * (zsbndvec.size() - 1)), 0), (int)zsbndvec.size() - 2);\n                        int inext = iprev + 1;\n                        // here interp time is used to interpolate to the right node rather than in time...\n                        zsleft = interptime(zsbndvec[inext], zsbndvec[iprev], 1.0, (double)(jj * (zsbndvec.size() - 1) - iprev));\n                    }\n\n                }\n\n                if (XForcing.right.on)\n                {\n                    int SLstepinbnd = 1;\n                    righthere = 1.0;\n\n\n                    // Do this for all the corners\n                    //Needs limiter in case WLbnd is empty\n                    double difft = XForcing.right.data[SLstepinbnd].time - XParam.totaltime;\n\n                    while (difft &lt; 0.0)\n                    {\n                        SLstepinbnd++;\n                        difft = XForcing.right.data[SLstepinbnd].time - XParam.totaltime;\n                    }\n                    std::vector&lt;double&gt; zsbndvec;\n                    for (int k = 0; k &lt; XForcing.right.data[SLstepinbnd].wlevs.size(); k++)\n                    {\n                        zsbndvec.push_back(interptime(XForcing.right.data[SLstepinbnd].wlevs[k], XForcing.right.data[SLstepinbnd - 1].wlevs[k], XForcing.right.data[SLstepinbnd].time - XForcing.right.data[SLstepinbnd - 1].time, XParam.totaltime - XForcing.right.data[SLstepinbnd - 1].time));\n\n                    }\n                    if (zsbndvec.size() == 1)\n                    {\n                        zsright = zsbndvec[0];\n                    }\n                    else\n                    {\n                        int iprev = utils::min(utils::max((int)floor(jj * (zsbndvec.size() - 1)), 0), (int)zsbndvec.size() - 2);\n                        int inext = iprev + 1;\n                        // here interp time is used to interpolate to the right node rather than in time...\n                        zsright = interptime(zsbndvec[inext], zsbndvec[iprev], 1.0, (double)(jj * (zsbndvec.size() - 1) - iprev));\n                    }\n\n\n                }\n                if (XForcing.bot.on)\n                {\n                    int SLstepinbnd = 1;\n                    bothere = 1.0;\n\n\n\n\n                    // Do this for all the corners\n                    //Needs limiter in case WLbnd is empty\n                    double difft = XForcing.bot.data[SLstepinbnd].time - XParam.totaltime;\n\n                    while (difft &lt; 0.0)\n                    {\n                        SLstepinbnd++;\n                        difft = XForcing.bot.data[SLstepinbnd].time - XParam.totaltime;\n                    }\n                    std::vector&lt;double&gt; zsbndvec;\n                    for (int k = 0; k &lt; XForcing.bot.data[SLstepinbnd].wlevs.size(); k++)\n                    {\n                        zsbndvec.push_back(interptime(XForcing.bot.data[SLstepinbnd].wlevs[k], XForcing.bot.data[SLstepinbnd - 1].wlevs[k], XForcing.bot.data[SLstepinbnd].time - XForcing.bot.data[SLstepinbnd - 1].time, XParam.totaltime - XForcing.bot.data[SLstepinbnd - 1].time));\n\n                    }\n                    if (zsbndvec.size() == 1)\n                    {\n                        zsbot = zsbndvec[0];\n                    }\n                    else\n                    {\n                        int iprev = utils::min(utils::max((int)floor(ii * (zsbndvec.size() - 1)), 0), (int)zsbndvec.size() - 2);\n                        int inext = iprev + 1;\n                        // here interp time is used to interpolate to the right node rather than in time...\n                        zsbot = interptime(zsbndvec[inext], zsbndvec[iprev], 1.0, (double)(ii * (zsbndvec.size() - 1) - iprev));\n                    }\n\n                }\n                if (XForcing.top.on)\n                {\n                    int SLstepinbnd = 1;\n                    tophere = 1.0;\n\n\n\n\n                    // Do this for all the corners\n                    //Needs limiter in case WLbnd is empty\n                    double difft = XForcing.top.data[SLstepinbnd].time - XParam.totaltime;\n\n                    while (difft &lt; 0.0)\n                    {\n                        SLstepinbnd++;\n                        difft = XForcing.top.data[SLstepinbnd].time - XParam.totaltime;\n                    }\n                    std::vector&lt;double&gt; zsbndvec;\n                    for (int k= 0; k &lt; XForcing.top.data[SLstepinbnd].wlevs.size(); k++)\n                    {\n                        zsbndvec.push_back(interptime(XForcing.top.data[SLstepinbnd].wlevs[k], XForcing.top.data[SLstepinbnd - 1].wlevs[k], XForcing.top.data[SLstepinbnd].time - XForcing.top.data[SLstepinbnd - 1].time, XParam.totaltime - XForcing.top.data[SLstepinbnd - 1].time));\n\n                    }\n                    if (zsbndvec.size() == 1)\n                    {\n                        zstop = zsbndvec[0];\n                    }\n                    else\n                    {\n                        int iprev = utils::min(utils::max((int)floor(ii * (zsbndvec.size() - 1)), 0), (int)zsbndvec.size() - 2);\n                        int inext = iprev + 1;\n                        // here interp time is used to interpolate to the right node rather than in time...\n                        zstop = interptime(zsbndvec[inext], zsbndvec[iprev], 1.0, (double)(ii * (zsbndvec.size() - 1) - iprev));\n                    }\n\n                }\n\n\n                zsbnd = T(((zsleft / distleft) * lefthere + (zsright / distright) * righthere + (zstop / disttop) * tophere + (zsbot / distbot) * bothere) / ((1.0 / distleft) * lefthere + (1.0 / distright) * righthere + (1.0 / disttop) * tophere + (1.0 / distbot) * bothere));\n\n                if (XParam.atmpforcing)\n                {\n                    float atmpi;\n\n                    if (XForcing.Atmp.uniform)\n                    {\n                        atmpi = float(XForcing.Atmp.nowvalue);\n                    }\n                    else\n                    {\n                        atmpi = float(interp2BUQ(xi, yi, XForcing.Atmp));\n                    }\n                    zsbnd = zsbnd - (atmpi- (T)XParam.Paref) * (T)XParam.Pa2m;\n                }\n\n                XEv.zs[n] = utils::max(zsbnd, zb[n]);\n                XEv.h[n] = utils::max(XEv.zs[n] - zb[n], T(0.0));\n                XEv.u[n] = T(0.0);\n                XEv.v[n] = T(0.0);\n\n\n\n            }\n        }\n    }\n}\n\n\ntemplate &lt;class T&gt;\nint AddZSoffset(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; &amp;XEv, T*zb)\n{\n    int success = 1;\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = memloc(XParam, i, j, ib);\n\n                if (XEv.h[n] &gt; XParam.eps)\n                {\n\n                    XEv.zs[n] = max(XEv.zs[n] + T(XParam.zsoffset), zb[n]);\n\n                    XEv.h[n] = utils::max(XEv.zs[n] - zb[n], T(0.0));\n                }\n            }\n\n        }\n    }\n\n    return success;\n}\n\n\ntemplate &lt;class T&gt;\nint readhotstartfileBG(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt;&amp; XEv, T*&amp; zb)\n{\n    int status;\n    int ncid;\n    //int dimids[NC_MAX_VAR_DIMS];   // dimension IDs \n    int ib;\n    //double scalefac = 1.0;\n    //double offset = 0.0;\n\n    std::string zbname, zsname, hname, uname, vname, xname, yname;\n    // Open the file for read access\n    //netCDF::NcFile dataFile(XParam.hotstartfile, NcFile::read);\n\n    bool isBG_Flood = false;\n\n    int BG_vers = -999;\n\n    // read ncfile attribute and see if BG_flood global attribute exists.\n    //Open NC file\n    printf(\"Open file...\");\n    status = nc_open(XParam.hotstartfile.c_str(), NC_NOWRITE, &amp;ncid);\n\n    status = nc_get_att_int(ncid, NC_GLOBAL, \"BG_Flood\", &amp;BG_vers);\n\n    //isBG_Flood = BG_vers &gt;= 0)\n\n    status = nc_close(ncid);\n\n\n\n}\n\ntemplate &lt;class T&gt;\nint readhotstartfile(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt;&amp; XEv, T*&amp; zb)\n{\n    int status;\n    int ncid;\n    //int dimids[NC_MAX_VAR_DIMS];   // dimension IDs \n    int ib;\n    //double scalefac = 1.0;\n    //double offset = 0.0;\n\n    std::string zbname, zsname, hname, uname, vname, xname, yname;\n    // Open the file for read access\n    //netCDF::NcFile dataFile(XParam.hotstartfile, NcFile::read);\n\n\n    //Open NC file\n    printf(\"Open file...\");\n    status = nc_open(XParam.hotstartfile.c_str(), NC_NOWRITE, &amp;ncid);\n\n\n    //bool isBG_Flood = false;\n\n    // read ncfile attribute and see if BG_flood global attribute exists.\n\n    //if it exist read each level separatly otherwise look for the following variables \n\n    if (status != NC_NOERR) handle_ncerror(status);\n    zbname = checkncvarname(ncid, \"zb\", \"z\", \"ZB\", \"Z\", \"zb_P0\");\n    zsname = checkncvarname(ncid, \"zs\", \"eta\", \"ZS\", \"ETA\", \"zs_P0\");\n    hname = checkncvarname(ncid, \"h\", \"hh\", \"hhh\", \"hhhh\", \"h_P0\");\n    uname = checkncvarname(ncid, \"u\", \"uu\", \"uvel\", \"UVEL\", \"u_P0\");\n    vname = checkncvarname(ncid, \"v\", \"vv\", \"vvel\", \"VVEL\", \"v_P0\");\n\n    //by default we assume that the x axis is called \"xx\" but that is not sure \"x\" shoudl be accepted and so does \"lon\" for spherical grid\n    // The folowing section figure out which one is in the file and if none exits with the netcdf error\n    // default name is \"xx\"\n    //xname = checkncvarname(ncid, \"x\", \"xx\",\"lon\",\"Lon\");\n    //yname = checkncvarname(ncid, \"y\", \"yy\", \"lat\", \"Lat\");\n\n    status = nc_close(ncid);\n\n\n    // First we should read x and y coordinates\n    // Just as with other variables we expect the file follow the output naming convention of \"xx\" and \"yy\" both as a dimension and a variable\n    StaticForcingP&lt;float&gt; zbhotstart, zshotstart, hhotstart, uhotstart, vhotstart;\n\n    // Read hotstart block info if it exist\n    // By default reuse mesh-layout\n    // for now we pretend hotstart are just unifomr maesh layout\n\n\n\n    //if hotstart has zb variable overright the previous ne\n    //printf(\"Found variables: \");\n    if (!zbname.empty())\n    {\n        //zb is set\n        zbhotstart = readfileinfo(XParam.hotstartfile + \"?\" + zbname, zbhotstart);\n\n        readstaticforcing(XParam.hotstep, zbhotstart);\n        interp2BUQ(XParam, XBlock, zbhotstart, zb);\n\n        //because we set the edges around empty blocks we need the set the edges for zs too\n        // otherwise we create some gitantic waves at the edges of empty blocks\n        setedges(XParam, XBlock, zb);\n\n\n\n    }\n    // second check if zs or hh are in the file\n\n\n    //zs Section\n    if (!zsname.empty())\n    {\n        log(\" zs... \");\n\n        zshotstart = readfileinfo(XParam.hotstartfile + \"?\" + zsname, zshotstart);\n        //readforcingmaphead(zshotstart);\n        readstaticforcing(XParam.hotstep, zshotstart);\n\n        interp2BUQ(XParam, XBlock, zshotstart, XEv.zs);\n\n        setedges(XParam, XBlock, XEv.zs);\n\n        //setedges(XParam.nblk, leftblk, rightblk, topblk, botblk, zs);\n\n        //check sanity\n        for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n        {\n            ib = XBlock.active[ibl];\n            for (int j = 0; j &lt; XParam.blkwidth; j++)\n            {\n                for (int i = 0; i &lt; XParam.blkwidth; i++)\n                {\n                    int n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                    XEv.zs[n] = utils::max(XEv.zs[n], zb[n]);\n                    //unpacked_value = packed_value * scale_factor + add_offset\n                }\n            }\n        }\n\n\n    }\n    else\n    {\n        //Variable not found\n        //It's ok if hh is specified\n        log(\"zs not found in hotstart file. Looking for hh... \");\n\n    }\n\n    //hh section\n    if (!hname.empty())\n    {\n        log(\"h... \");\n        hhotstart = readfileinfo(XParam.hotstartfile + \"?\" + hname, hhotstart);\n        //readforcingmaphead(zshotstart);\n        readstaticforcing(XParam.hotstep, hhotstart);\n\n        interp2BUQ(XParam, XBlock, hhotstart, XEv.h);\n\n        setedges(XParam, XBlock, XEv.h);\n\n        //if zs was not specified\n        if (zsname.empty())\n        {\n            for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n            {\n                ib = XBlock.active[ibl];\n                for (int j = 0; j &lt; XParam.blkwidth; j++)\n                {\n                    for (int i = 0; i &lt; XParam.blkwidth; i++)\n                    {\n                        int n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                        XEv.zs[n] = zb[n] + XEv.h[n];\n                        //unpacked_value = packed_value * scale_factor + add_offset\n                    }\n                }\n            }\n\n        }\n\n\n\n    }\n    else\n    {\n        //if both zs and h were not specified\n        if (zsname.empty() &amp;&amp; hname.empty())\n        {\n            //Variable not found\n            //It's ok if hh is specified\n            log(\"neither zs nor hh were found in hotstart file. this is not a valid hotstart file. using a cold start instead\");\n            return 0;\n        }\n        else\n        {\n            //zs was specified but not h\n            for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n            {\n                ib = XBlock.active[ibl];\n                for (int j = 0; j &lt; XParam.blkwidth; j++)\n                {\n                    for (int i = 0; i &lt; XParam.blkwidth; i++)\n                    {\n                        int n = memloc(XParam, i, j, ib);\n\n\n                        XEv.h[n] = utils::max(XEv.zs[n] - zb[n], T(0.0));\n                    }\n\n                }\n            }\n\n        }\n    }\n\n    //u Section\n\n    if (!uname.empty())\n    {\n        log(\"u... \");\n        uhotstart = readfileinfo(XParam.hotstartfile + \"?\" + uname, uhotstart);\n        //readforcingmaphead(zshotstart);\n        readstaticforcing(XParam.hotstep, uhotstart);\n\n        interp2BUQ(XParam, XBlock, uhotstart, XEv.u);\n\n        setedges(XParam, XBlock, XEv.u);\n\n    }\n    else\n    {\n        InitArrayBUQ(XParam, XBlock, (T)0.0, XEv.u);\n    }\n\n    //vv section\n\n    if (!vname.empty())\n    {\n        log(\"v... \");\n        vhotstart = readfileinfo(XParam.hotstartfile + \"?\" + vname, vhotstart);\n        //readforcingmaphead(zshotstart);\n        readstaticforcing(XParam.hotstep, vhotstart);\n\n        interp2BUQ(XParam, XBlock, vhotstart, XEv.v);\n\n        setedges(XParam, XBlock, XEv.v);\n\n\n    }\n    else\n    {\n        InitArrayBUQ(XParam,XBlock, (T)0.0, XEv.v);\n    }\n    //status = nc_get_var_float(ncid, hh_id, zb);\n    status = nc_close(ncid);\n\n\n\n    return 1;\n\n}\ntemplate int readhotstartfile&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt;&amp; XEv, float*&amp; zb);\ntemplate int readhotstartfile&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt;&amp; XEv, double*&amp; zb);\n//template int readhotstartfile&lt;float&gt;(Param XParam, int * leftblk, int *rightblk, int * topblk, int* botblk, double * blockxo, double * blockyo, float * &amp;zs, float * &amp;zb, float * &amp;hh, float *&amp;uu, float * &amp;vv);\n\n//template int readhotstartfile&lt;double&gt;(Param XParam, int * leftblk, int *rightblk, int * topblk, int* botblk, double * blockxo, double * blockyo, double * &amp;zs, double * &amp;zb, double * &amp;hh, double *&amp;uu, double * &amp;vv);\n</code></pre>"},{"location":"BGFlood/_init_evolv_8h/","title":"File InitEvolv.h","text":""},{"location":"BGFlood/_init_evolv_8h/#file-initevolvh","title":"File InitEvolv.h","text":"<p>FileList &gt; src &gt; InitEvolv.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"GridManip.h\"</code></li> <li><code>#include \"Read_netcdf.h\"</code></li> <li><code>#include \"ReadForcing.h\"</code></li> <li><code>#include \"Updateforcing.h\"</code></li> </ul>"},{"location":"BGFlood/_init_evolv_8h/#public-functions","title":"Public Functions","text":"Type Name int AddZSoffset (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; &amp; XEv, T * zb) Add offset to surface elevation (zs) and update water depth (h). int coldstart (Param XParam, BlockP&lt; T &gt; XBlock, T * zb, EvolvingP&lt; T &gt; &amp; XEv) Cold start initialization of evolving variables. void initevolv (Param XParam, BlockP&lt; T &gt; XBlock, Forcing&lt; float &gt; XForcing, EvolvingP&lt; T &gt; &amp; XEv, T *&amp; zb) Initialize evolving variables for the simulation. int readhotstartfile (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; &amp; XEv, T *&amp; zb) Read hotstart file and initialize evolving variables and bathymetry. void warmstart (Param XParam, Forcing&lt; float &gt; XForcing, BlockP&lt; T &gt; XBlock, T * zb, EvolvingP&lt; T &gt; &amp; XEv) Warm start initialization using boundary conditions and interpolation."},{"location":"BGFlood/_init_evolv_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_init_evolv_8h/#function-addzsoffset","title":"function AddZSoffset","text":"<p>Add offset to surface elevation (zs) and update water depth (h). </p><pre><code>template&lt;class T&gt;\nint AddZSoffset (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; &amp; XEv,\n    T * zb\n) \n</code></pre> <p>Applies zsoffset to zs and updates h for all blocks where h &gt; eps.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables (input/output) </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>Returns:</p> <p>Success flag (1 if successful) </p>"},{"location":"BGFlood/_init_evolv_8h/#function-coldstart","title":"function coldstart","text":"<p>Cold start initialization of evolving variables. </p><pre><code>template&lt;class T&gt;\nint coldstart (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * zb,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre> <p>Sets initial water level, velocity, and bathymetry arrays for all blocks using specified zsinit and zsoffset.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>zb</code> Bathymetry array </li> <li><code>XEv</code> Evolving variables (output) </li> </ul> <p>Returns:</p> <p>Success flag (1 if successful) </p>"},{"location":"BGFlood/_init_evolv_8h/#function-initevolv","title":"function initevolv","text":"<p>Initialize evolving variables for the simulation. </p><pre><code>template&lt;class T&gt;\nvoid initevolv (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    Forcing &lt; float &gt; XForcing,\n    EvolvingP &lt; T &gt; &amp; XEv,\n    T *&amp; zb\n) \n</code></pre> <p>Handles hotstart, coldstart, and warmstart initialization of water level, velocity, and bathymetry arrays. Applies offsets and boundary conditions as needed.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XForcing</code> Forcing/boundary conditions </li> <li><code>XEv</code> Evolving variables (output) </li> <li><code>zb</code> Bathymetry array (input/output) </li> </ul>"},{"location":"BGFlood/_init_evolv_8h/#function-readhotstartfile","title":"function readhotstartfile","text":"<p>Read hotstart file and initialize evolving variables and bathymetry. </p><pre><code>template&lt;class T&gt;\nint readhotstartfile (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; &amp; XEv,\n    T *&amp; zb\n) \n</code></pre> <p>Reads NetCDF hotstart file, extracts variables, and fills arrays for all blocks. Handles missing variables and applies edge corrections.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables (output) </li> <li><code>zb</code> Bathymetry array (output) </li> </ul> <p>Returns:</p> <p>Success flag (1 if successful, 0 if fallback to cold start) </p>"},{"location":"BGFlood/_init_evolv_8h/#function-warmstart","title":"function warmstart","text":"<p>Warm start initialization using boundary conditions and interpolation. </p><pre><code>template&lt;class T&gt;\nvoid warmstart (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    BlockP &lt; T &gt; XBlock,\n    T * zb,\n    EvolvingP &lt; T &gt; &amp; XEv\n) \n</code></pre> <p>Sets initial water level, velocity, and bathymetry arrays for all blocks using boundary segments and atmospheric pressure forcing.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XForcing</code> Forcing/boundary conditions </li> <li><code>XBlock</code> Block parameters </li> <li><code>zb</code> Bathymetry array </li> <li><code>XEv</code> Evolving variables (output) </li> </ul> <p>The documentation for this class was generated from the following file <code>src/InitEvolv.h</code></p>"},{"location":"BGFlood/_init_evolv_8h_source/","title":"File InitEvolv.h","text":""},{"location":"BGFlood/_init_evolv_8h_source/#file-initevolvh","title":"File InitEvolv.h","text":"<p>File List &gt; src &gt; InitEvolv.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef INITEVOLV_H\n#define INITEVOLV_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"Write_txtlog.h\"\n#include \"GridManip.h\"\n#include \"Read_netcdf.h\"\n#include \"ReadForcing.h\"\n#include \"Updateforcing.h\"\n\n\ntemplate &lt;class T&gt; void initevolv(Param XParam, BlockP&lt;T&gt; XBlock, Forcing&lt;float&gt; XForcing, EvolvingP&lt;T&gt;&amp; XEv, T*&amp; zb);\ntemplate &lt;class T&gt; int coldstart(Param XParam, BlockP&lt;T&gt; XBlock, T* zb, EvolvingP&lt;T&gt;&amp; XEv);\ntemplate &lt;class T&gt; void warmstart(Param XParam, Forcing&lt;float&gt; XForcing, BlockP&lt;T&gt; XBlock, T* zb, EvolvingP&lt;T&gt;&amp; XEv);\ntemplate &lt;class T&gt; int AddZSoffset(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt;&amp; XEv, T* zb);\n\ntemplate &lt;class T&gt; int readhotstartfile(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt;&amp; XEv, T*&amp; zb);\n\n// End of global definition;\n#endif\n</code></pre>"},{"location":"BGFlood/_initial_conditions_8cu/","title":"File InitialConditions.cu","text":""},{"location":"BGFlood/_initial_conditions_8cu/#file-initialconditionscu","title":"File InitialConditions.cu","text":"<p>FileList &gt; src &gt; InitialConditions.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"InitialConditions.h\"</code></li> <li><code>#include \"Input.h\"</code></li> </ul>"},{"location":"BGFlood/_initial_conditions_8cu/#public-functions","title":"Public Functions","text":"Type Name void Calcbndblks (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; T &gt; XBlock) Calculates the number of blocks on each boundary of the domain. void FindTSoutNodes (Param &amp; XParam, BlockP&lt; T &gt; XBlock, BndblockP&lt; T &gt; &amp; bnd) Finds and assigns output nodes to blocks for time series output. template void FindTSoutNodes&lt; double &gt; (Param &amp; XParam, BlockP&lt; double &gt; XBlock, BndblockP&lt; double &gt; &amp; bnd)  template void FindTSoutNodes&lt; float &gt; (Param &amp; XParam, BlockP&lt; float &gt; XBlock, BndblockP&lt; float &gt; &amp; bnd)  void Findbndblks (Param XParam, Model&lt; T &gt; XModel, Forcing&lt; float &gt; &amp; XForcing) Finds which blocks on the model edge belong to a side boundary. void Findoutzoneblks (Param &amp; XParam, BlockP&lt; T &gt; &amp; XBlock) Finds and assigns blocks to output zones based on user-defined rectangular areas. template void Findoutzoneblks&lt; double &gt; (Param &amp; XParam, BlockP&lt; double &gt; &amp; XBlock)  template void Findoutzoneblks&lt; float &gt; (Param &amp; XParam, BlockP&lt; float &gt; &amp; XBlock)  std::vector&lt; double &gt; GetTimeOutput (T_output time_info) Creates a vector of output times from the input time structure. void InitRivers (Param XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel) Initializes river discharge areas and assigns river information to model blocks. template void InitRivers&lt; double &gt; (Param XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; double &gt; &amp; XModel)  template void InitRivers&lt; float &gt; (Param XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; float &gt; &amp; XModel)  void InitTSOutput (Param XParam) Initializes time series output files for specified nodes. void Initbndblks (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; T &gt; XBlock) Initializes boundary block assignments and segment information. void InitialConditions (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel) Initializes model parameters, bathymetry, friction, initial conditions, and output variables. template void InitialConditions&lt; double &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; double &gt; &amp; XModel)  template void InitialConditions&lt; float &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; float &gt; &amp; XModel)  void Initmaparray (Model&lt; T &gt; &amp; XModel) Initializes output variable maps and metadata for the simulation. template void Initmaparray&lt; double &gt; (Model&lt; double &gt; &amp; XModel)  template void Initmaparray&lt; float &gt; (Model&lt; float &gt; &amp; XModel)  void Initoutzone (Param &amp; XParam, BlockP&lt; T &gt; &amp; XBlock) Initializes output zones for the simulation domain. template void Initoutzone&lt; double &gt; (Param &amp; XParam, BlockP&lt; double &gt; &amp; XBlock)  template void Initoutzone&lt; float &gt; (Param &amp; XParam, BlockP&lt; float &gt; &amp; XBlock)  void InitzbgradientCPU (Param XParam, Model&lt; T &gt; XModel) Initializes bathymetry gradient and halo on CPU. template void InitzbgradientCPU&lt; double &gt; (Param XParam, Model&lt; double &gt; XModel)  template void InitzbgradientCPU&lt; float &gt; (Param XParam, Model&lt; float &gt; XModel)  void InitzbgradientGPU (Param XParam, Model&lt; T &gt; XModel) Initializes bathymetry gradient and halo on GPU. template void InitzbgradientGPU&lt; double &gt; (Param XParam, Model&lt; double &gt; XModel)  template void InitzbgradientGPU&lt; float &gt; (Param XParam, Model&lt; float &gt; XModel)  void RectCornerBlk (Param &amp; XParam, BlockP&lt; T &gt; &amp; XBlock, double xo, double yo, double xmax, double ymax, bool isEps, std::vector&lt; int &gt; &amp; cornerblk) Finds the blocks containing the corners of a rectangular box (for output zone definition). void calcactiveCellCPU (Param XParam, BlockP&lt; T &gt; XBlock, Forcing&lt; float &gt; &amp; XForcing, T * zb) Calculates active cells in the domain based on mask elevation and area of interest. __global__ void calcactiveCellGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * zb) CUDA kernel to calculate active cells on the GPU based on mask elevation. void initOutputTimes (Param XParam, std::vector&lt; double &gt; &amp; OutputT, BlockP&lt; T &gt; &amp; XBlock) Compiles and sorts output times for map outputs, including zone outputs. void initinfiltration (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * initLoss, T * hgw) Initializes infiltration loss array for each cell. void initoutput (Param &amp; XParam, Model&lt; T &gt; &amp; XModel) Initializes output arrays and maps for the simulation."},{"location":"BGFlood/_initial_conditions_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_initial_conditions_8cu/#function-calcbndblks","title":"function Calcbndblks","text":"<p>Calculates the number of blocks on each boundary of the domain. </p><pre><code>template&lt;class T&gt;\nvoid Calcbndblks (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; T &gt; XBlock\n) \n</code></pre> <p>Updates counts for left, right, top, and bottom boundaries and stores them in the forcing and parameter structures.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XForcing</code> Forcing data (float) </li> <li><code>XBlock</code> Block parameters </li> </ul>"},{"location":"BGFlood/_initial_conditions_8cu/#function-findtsoutnodes","title":"function FindTSoutNodes","text":"<p>Finds and assigns output nodes to blocks for time series output. </p><pre><code>template&lt;class T&gt;\nvoid FindTSoutNodes (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; XBlock,\n    BndblockP &lt; T &gt; &amp; bnd\n) \n</code></pre> <p>Determines which block each output node belongs to and updates the boundary block structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>bnd</code> Boundary block structure </li> </ul>"},{"location":"BGFlood/_initial_conditions_8cu/#function-findtsoutnodes-double","title":"function FindTSoutNodes&lt; double &gt;","text":"<pre><code>template void FindTSoutNodes&lt; double &gt; (\n    Param &amp; XParam,\n    BlockP &lt; double &gt; XBlock,\n    BndblockP &lt; double &gt; &amp; bnd\n) \n</code></pre>"},{"location":"BGFlood/_initial_conditions_8cu/#function-findtsoutnodes-float","title":"function FindTSoutNodes&lt; float &gt;","text":"<pre><code>template void FindTSoutNodes&lt; float &gt; (\n    Param &amp; XParam,\n    BlockP &lt; float &gt; XBlock,\n    BndblockP &lt; float &gt; &amp; bnd\n) \n</code></pre>"},{"location":"BGFlood/_initial_conditions_8cu/#function-findbndblks","title":"function Findbndblks","text":"<p>Finds which blocks on the model edge belong to a side boundary. </p><pre><code>template&lt;class T&gt;\nvoid Findbndblks (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre> <p>Populates arrays for blocks on each side boundary and updates the forcing structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XModel</code> Model data </li> <li><code>XForcing</code> Forcing data (float)</li> </ul> <p>Find which block on the model edge belongs to a \"side boundary\" </p>"},{"location":"BGFlood/_initial_conditions_8cu/#function-findoutzoneblks","title":"function Findoutzoneblks","text":"<p>Finds and assigns blocks to output zones based on user-defined rectangular areas. </p><pre><code>template&lt;class T&gt;\nvoid Findoutzoneblks (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre> <p>Determines which blocks belong to each output zone, computes zone boundaries, and updates the block structure. Initialise all storage involving parameters of the outzone objects</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> </ul>"},{"location":"BGFlood/_initial_conditions_8cu/#function-findoutzoneblks-double","title":"function Findoutzoneblks&lt; double &gt;","text":"<pre><code>template void Findoutzoneblks&lt; double &gt; (\n    Param &amp; XParam,\n    BlockP &lt; double &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/_initial_conditions_8cu/#function-findoutzoneblks-float","title":"function Findoutzoneblks&lt; float &gt;","text":"<pre><code>template void Findoutzoneblks&lt; float &gt; (\n    Param &amp; XParam,\n    BlockP &lt; float &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/_initial_conditions_8cu/#function-gettimeoutput","title":"function GetTimeOutput","text":"<p>Creates a vector of output times from the input time structure. </p><pre><code>std::vector&lt; double &gt; GetTimeOutput (\n    T_output time_info\n) \n</code></pre> <p>Combines independent values and time steps from the input structure.</p> <p>Parameters:</p> <ul> <li><code>time_info</code> Time output structure </li> </ul> <p>Returns:</p> <p>Vector of output times </p>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initrivers","title":"function InitRivers","text":"<p>Initializes river discharge areas and assigns river information to model blocks. </p><pre><code>template&lt;class T&gt;\nvoid InitRivers (\n    Param XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Identifies grid cells affected by river discharge, calculates discharge areas, and sets up river-block relationships.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XForcing</code> Forcing data (float) </li> <li><code>XModel</code> Model data </li> </ul>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initrivers-double","title":"function InitRivers&lt; double &gt;","text":"<pre><code>template void InitRivers&lt; double &gt; (\n    Param XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initrivers-float","title":"function InitRivers&lt; float &gt;","text":"<pre><code>template void InitRivers&lt; float &gt; (\n    Param XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_initial_conditions_8cu/#function-inittsoutput","title":"function InitTSOutput","text":"<p>Initializes time series output files for specified nodes. </p><pre><code>void InitTSOutput (\n    Param XParam\n) \n</code></pre> <p>Creates and overwrites output files for each node in the time series output list.</p> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> </ul>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initbndblks","title":"function Initbndblks","text":"<p>Initializes boundary block assignments and segment information. </p><pre><code>template&lt;class T&gt;\nvoid Initbndblks (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; T &gt; XBlock\n) \n</code></pre> <p>Finds boundary blocks, assigns them to segments, and allocates arrays for segment sides and flow.</p> <ul> <li> <p>Initialise bnd blk assign block to their relevant segment allocate memory...</p> </li> <li> <p>Find all the boundary blocks(block with themselves as neighbours)</p> </li> <li>make an array to store which segment they belong to</li> </ul> <p>If any bnd segment was specified * scan each block and find which (if any) segment they belong to For each segment Calculate bbox if inbbox calc inpoly if inpoly overwrite assingned segment with new one * Calculate nblk per segment &amp; allocate (do for each segment) * fill segment and side arrays for each segments</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XForcing</code> Forcing data (float) </li> <li><code>XBlock</code> Block parameters </li> </ul>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initialconditions","title":"function InitialConditions","text":"<p>Initializes model parameters, bathymetry, friction, initial conditions, and output variables. </p><pre><code>template&lt;class T&gt;\nvoid InitialConditions (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Sets up the initial state of the simulation, including bathymetry, friction maps, evolving variables, river forcing, boundary blocks, active cells, and output arrays.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XForcing</code> Forcing data (float) </li> <li><code>XModel</code> Model data </li> </ul>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initialconditions-double","title":"function InitialConditions&lt; double &gt;","text":"<pre><code>template void InitialConditions&lt; double &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initialconditions-float","title":"function InitialConditions&lt; float &gt;","text":"<pre><code>template void InitialConditions&lt; float &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initmaparray","title":"function Initmaparray","text":"<p>Initializes output variable maps and metadata for the simulation. </p><pre><code>template&lt;class T&gt;\nvoid Initmaparray (\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Sets up output variable names, units, and long names for all tracked quantities in the model.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XModel</code> Model data </li> </ul>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initmaparray-double","title":"function Initmaparray&lt; double &gt;","text":"<pre><code>template void Initmaparray&lt; double &gt; (\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initmaparray-float","title":"function Initmaparray&lt; float &gt;","text":"<pre><code>template void Initmaparray&lt; float &gt; (\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initoutzone","title":"function Initoutzone","text":"<p>Initializes output zones for the simulation domain. </p><pre><code>template&lt;class T&gt;\nvoid Initoutzone (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre> <p>Sets up output zones based on user input or defaults to the full domain if none specified.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> </ul>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initoutzone-double","title":"function Initoutzone&lt; double &gt;","text":"<pre><code>template void Initoutzone&lt; double &gt; (\n    Param &amp; XParam,\n    BlockP &lt; double &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initoutzone-float","title":"function Initoutzone&lt; float &gt;","text":"<pre><code>template void Initoutzone&lt; float &gt; (\n    Param &amp; XParam,\n    BlockP &lt; float &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initzbgradientcpu","title":"function InitzbgradientCPU","text":"<p>Initializes bathymetry gradient and halo on CPU. </p><pre><code>template&lt;class T&gt;\nvoid InitzbgradientCPU (\n    Param XParam,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Computes gradients and refines bathymetry for the model blocks on the CPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XModel</code> Model data </li> </ul>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initzbgradientcpu-double","title":"function InitzbgradientCPU&lt; double &gt;","text":"<pre><code>template void InitzbgradientCPU&lt; double &gt; (\n    Param XParam,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initzbgradientcpu-float","title":"function InitzbgradientCPU&lt; float &gt;","text":"<pre><code>template void InitzbgradientCPU&lt; float &gt; (\n    Param XParam,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initzbgradientgpu","title":"function InitzbgradientGPU","text":"<p>Initializes bathymetry gradient and halo on GPU. </p><pre><code>template&lt;class T&gt;\nvoid InitzbgradientGPU (\n    Param XParam,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Computes gradients and refines bathymetry for the model blocks using CUDA streams and kernels.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XModel</code> Model data </li> </ul>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initzbgradientgpu-double","title":"function InitzbgradientGPU&lt; double &gt;","text":"<pre><code>template void InitzbgradientGPU&lt; double &gt; (\n    Param XParam,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initzbgradientgpu-float","title":"function InitzbgradientGPU&lt; float &gt;","text":"<pre><code>template void InitzbgradientGPU&lt; float &gt; (\n    Param XParam,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_initial_conditions_8cu/#function-rectcornerblk","title":"function RectCornerBlk","text":"<p>Finds the blocks containing the corners of a rectangular box (for output zone definition). </p><pre><code>template&lt;class T&gt;\nvoid RectCornerBlk (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; &amp; XBlock,\n    double xo,\n    double yo,\n    double xmax,\n    double ymax,\n    bool isEps,\n    std::vector&lt; int &gt; &amp; cornerblk\n) \n</code></pre> <p>Returns indices of blocks through \"cornerblk\" at the corners of the rectangle, starting from bottom left and turning clockwise.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>xo</code> X start </li> <li><code>yo</code> Y start </li> <li><code>xmax</code> X end </li> <li><code>ymax</code> Y end </li> <li><code>isEps</code> Whether to use epsilon margin </li> <li><code>cornerblk</code> Vector to store corner block indices</li> </ul> <p>Find the block containing the border of a rectangular box (used for the defining the output zones) The indice of the blocks are returned through \"cornerblk\" from bottom left turning in the clockwise direction </p>"},{"location":"BGFlood/_initial_conditions_8cu/#function-calcactivecellcpu","title":"function calcactiveCellCPU","text":"<p>Calculates active cells in the domain based on mask elevation and area of interest. </p><pre><code>template&lt;class T&gt;\nvoid calcactiveCellCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    Forcing &lt; float &gt; &amp; XForcing,\n    T * zb\n) \n</code></pre> <p>Sets the active cell flag for each cell, removing rain from masked and boundary cells as needed.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XForcing</code> Forcing data (float) </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_initial_conditions_8cu/#function-calcactivecellgpu","title":"function calcactiveCellGPU","text":"<p>CUDA kernel to calculate active cells on the GPU based on mask elevation. </p><pre><code>template&lt;class T&gt;\n__global__ void calcactiveCellGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * zb\n) \n</code></pre> <p>Sets the active cell flag for each cell in the block using GPU parallelism.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initoutputtimes","title":"function initOutputTimes","text":"<p>Compiles and sorts output times for map outputs, including zone outputs. </p><pre><code>template&lt;class T&gt;\nvoid initOutputTimes (\n    Param XParam,\n    std::vector&lt; double &gt; &amp; OutputT,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre> <p>Combines times from the main output structure and all zone outputs, sorts and removes duplicates, and assigns to output arrays.</p> <p>Creation of a vector for times requiering a map output Compilations of vectors and independent times from the general input and the different zones outputs</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>OutputT</code> Output times vector </li> <li><code>XBlock</code> Block parameters </li> </ul>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initinfiltration","title":"function initinfiltration","text":"<p>Initializes infiltration loss array for each cell. </p><pre><code>template&lt;class T&gt;\nvoid initinfiltration (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * initLoss,\n    T * hgw\n) \n</code></pre> <p>Sets initial infiltration loss to zero for wet cells.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>h</code> Water depth array </li> <li><code>initLoss</code> Initial loss array </li> <li><code>hgw</code> Groundwater head array </li> </ul>"},{"location":"BGFlood/_initial_conditions_8cu/#function-initoutput","title":"function initoutput","text":"<p>Initializes output arrays and maps for the simulation. </p><pre><code>template&lt;class T&gt;\nvoid initoutput (\n    Param &amp; XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Sets up storage for evolving parameters, output zones, and output files.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XModel</code> Model data </li> </ul> <p>The documentation for this class was generated from the following file <code>src/InitialConditions.cu</code></p>"},{"location":"BGFlood/_initial_conditions_8cu_source/","title":"File InitialConditions.cu","text":""},{"location":"BGFlood/_initial_conditions_8cu_source/#file-initialconditionscu","title":"File InitialConditions.cu","text":"<p>File List &gt; src &gt; InitialConditions.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //    \n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n\n#include \"InitialConditions.h\"\n#include \"Input.h\"\n\ntemplate &lt;class T&gt; void InitialConditions(Param &amp;XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;T&gt; &amp;XModel)\n{\n    //=====================================\n    // Initialise Bathy data\n\n    interp2BUQ(XParam, XModel.blocks, XForcing.Bathy, XModel.zb);\n\n    // Set edges\n    setedges(XParam, XModel.blocks, XModel.zb);\n\n\n    //=====================================\n    // Initialise Friction map\n\n    if (!XForcing.cf.empty())\n    {\n        interp2BUQ(XParam, XModel.blocks, XForcing.cf, XModel.cf);\n    }\n    else\n    {\n        InitArrayBUQ(XParam, XModel.blocks, (T)XParam.cf, XModel.cf);\n    }\n    // Set edges of friction map\n    setedges(XParam, XModel.blocks, XModel.cf);\n\n\n\n\n    //=====================================\n    // Initial Condition\n\n    log(\"\\nInitial condition:\");\n    // First calculate the initial values for Evolving parameters (i.e. zs, h, u and v)\n    initevolv(XParam, XModel.blocks,XForcing, XModel.evolv, XModel.zb);\n    CopyArrayBUQ(XParam, XModel.blocks, XModel.evolv, XModel.evolv_o);\n\n    // Initialise the topography slope and halo\n    InitzbgradientCPU(XParam, XModel);\n\n    //=====================================\n    // Initial forcing\n    InitRivers(XParam, XForcing, XModel);\n\n    //=====================================\n    // Initial bndinfo\n    //Calcbndblks(XParam, XForcing, XModel.blocks);\n    //Findbndblks(XParam, XModel, XForcing);\n    Initbndblks(XParam, XForcing, XModel.blocks);\n\n\n    //=====================================\n    // Calculate Active cells\n    calcactiveCellCPU(XParam, XModel.blocks, XForcing, XModel.zb);\n\n    //=====================================\n    // Initialise the rain losses map\n\n    if (XParam.infiltration)\n    {\n        if (!XForcing.il.inputfile.empty())\n        {\n            interp2BUQ(XParam, XModel.blocks, XForcing.il, XModel.il);\n        }\n        else\n        {\n            InitArrayBUQ(XParam, XModel.blocks, (T)XParam.il, XModel.il);\n        }\n        if (!XForcing.cl.inputfile.empty())\n        {\n            interp2BUQ(XParam, XModel.blocks, XForcing.cl, XModel.cl);\n        }\n        else\n        {\n            InitArrayBUQ(XParam, XModel.blocks, (T)XParam.cl, XModel.cl);\n        }\n        // Set edges of friction map\n        setedges(XParam, XModel.blocks, XModel.il);\n        setedges(XParam, XModel.blocks, XModel.cl);\n        InitArrayBUQ(XParam, XModel.blocks, T(0.0), XModel.hgw);\n\n        // Initialise infiltration to IL where h is already wet\n        initinfiltration(XParam, XModel.blocks, XModel.evolv.h, XModel.il, XModel.hgw);\n    }\n\n    //=====================================\n    // Initialize output variables\n    initoutput(XParam, XModel);\n\n    // Initialise Output times' vector\n    initOutputTimes(XParam, XModel.OutputT, XModel.blocks);\n}\ntemplate void InitialConditions&lt;float&gt;(Param &amp;XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;float&gt; &amp;XModel);\ntemplate void InitialConditions&lt;double&gt;(Param &amp;XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;double&gt; &amp;XModel);\n\ntemplate &lt;class T&gt; void InitzbgradientCPU(Param XParam, Model&lt;T&gt; XModel)\n{\n\n\n    fillHaloC(XParam, XModel.blocks, XModel.zb);\n    gradientC(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    gradientHalo(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n\n    refine_linear(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    gradientHalo(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n\n\n}\ntemplate void InitzbgradientCPU&lt;double&gt;(Param XParam, Model&lt;double&gt; XModel);\ntemplate void InitzbgradientCPU&lt;float&gt;(Param XParam, Model&lt;float&gt; XModel);\n\ntemplate &lt;class T&gt; void InitzbgradientGPU(Param XParam, Model&lt;T&gt; XModel)\n{\n    const int num_streams = 4;\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n\n    cudaStream_t streams[num_streams];\n\n\n    CUDA_CHECK(cudaStreamCreate(&amp;streams[0]));\n\n    fillHaloGPU(XParam, XModel.blocks, streams[0], XModel.zb);\n\n    cudaStreamDestroy(streams[0]);\n\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradientHaloGPU(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n\n    refine_linearGPU(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel.blocks.active, XModel.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradientHaloGPU(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n}\ntemplate void InitzbgradientGPU&lt;double&gt;(Param XParam, Model&lt;double&gt; XModel);\ntemplate void InitzbgradientGPU&lt;float&gt;(Param XParam, Model&lt;float&gt; XModel);\n\ntemplate &lt;class T&gt; void initoutput(Param &amp;XParam, Model&lt;T&gt; &amp;XModel)\n{\n\n\n    //FILE* fsSLTS;\n    // Initialise all storage involving parameters\n    //CopyArrayBUQ(XParam, XModel.blocks, XModel.evolv, XModel.evolv_o);\n    if (XParam.outmax)\n    {\n        CopyArrayBUQ(XParam, XModel.blocks, XModel.evolv, XModel.evmax);\n    }\n    if (XParam.outmean)\n    {\n        CopyArrayBUQ(XParam, XModel.blocks, XModel.evolv, XModel.evmean);\n    }\n    if (XParam.outtwet)\n    {\n        InitArrayBUQ(XParam, XModel.blocks, T(0.0), XModel.wettime);\n    }\n\n    if (XParam.TSnodesout.size() &gt; 0)\n    {\n        FindTSoutNodes(XParam, XModel.blocks, XModel.bndblk);\n    }\n\n\n    //==============================\n    // Init. map array\n    Initmaparray(XModel);\n    // Init. zones for output\n    Initoutzone(XParam, XModel.blocks);\n\n    //==============================\n    // Setup output netcdf file\n    //XParam = creatncfileBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo);\n\n\n}\n\nvoid InitTSOutput(Param XParam)\n{\n    for (int o = 0; o &lt; XParam.TSnodesout.size(); o++)\n    {\n        FILE* fsSLTS;\n\n        //Overwrite existing files\n        fsSLTS = fopen(XParam.TSnodesout[o].outname.c_str(), \"w\");\n        fprintf(fsSLTS, \"# x=%f\\ty=%f\\ti=%d\\tj=%d\\tblock=%d\\t%s\\n\", XParam.TSnodesout[o].x, XParam.TSnodesout[o].y, XParam.TSnodesout[o].i, XParam.TSnodesout[o].j, XParam.TSnodesout[o].block, XParam.TSnodesout[o].outname.c_str());\n\n        fprintf(fsSLTS, \"# time[s]\\tzs[m]\\th[m]\\tu[m/s]\\tv[m/s]\\n\");\n\n        fclose(fsSLTS);\n\n\n    }\n}\n\ntemplate &lt;class T&gt; void FindTSoutNodes(Param&amp; XParam, BlockP&lt;T&gt; XBlock, BndblockP&lt;T&gt; &amp; bnd)\n{\n    int ib;\n    T levdx,x,y,blkxmin,blkxmax,blkymin,blkymax,dxblk;\n    bnd.nblkTs = int(XParam.TSnodesout.size());\n\n    AllocateCPU(bnd.nblkTs, 1, bnd.Tsout);\n\n    // Initialise all storage involving parameters\n\n\n    for (int o = 0; o &lt; XParam.TSnodesout.size(); o++)\n    {\n\n\n        //find the block where point belongs\n        for (int blk = 0; blk &lt; XParam.nblk; blk++)\n        {\n\n            ib = XBlock.active[blk];\n            levdx = T(calcres(XParam.dx,XBlock.level[ib]));\n\n            x = (T)XParam.TSnodesout[o].x;\n            y = (T)XParam.TSnodesout[o].y;\n\n            dxblk = (T)(XParam.blkwidth) * levdx;\n\n            blkxmin = ((T)XParam.xo + XBlock.xo[ib] - T(0.5) * levdx);\n            blkymin = ((T)XParam.yo + XBlock.yo[ib] - T(0.5) * levdx);\n\n            blkxmax = (blkxmin + dxblk);\n            blkymax = (blkymin + dxblk);\n\n\n            if (x &gt; blkxmin &amp;&amp; x &lt;= blkxmax &amp;&amp; y &gt; blkymin &amp;&amp; y &lt;= blkymax)\n            {\n                XParam.TSnodesout[o].block = ib;\n                XParam.TSnodesout[o].i = min(max((int)round((XParam.TSnodesout[o].x - (XParam.xo + XBlock.xo[ib])) / levdx), 0), XParam.blkwidth - 1);\n                XParam.TSnodesout[o].j = min(max((int)round((XParam.TSnodesout[o].y - (XParam.yo + XBlock.yo[ib])) / levdx), 0), XParam.blkwidth - 1);\n                break;\n            }\n        }\n        bnd.Tsout[o] = ib;\n    }\n\n\n}\ntemplate void FindTSoutNodes&lt;float&gt;(Param&amp; XParam, BlockP&lt;float&gt; XBlock, BndblockP&lt;float&gt;&amp; bnd);\ntemplate void FindTSoutNodes&lt;double&gt;(Param&amp; XParam, BlockP&lt;double&gt; XBlock, BndblockP&lt;double&gt;&amp; bnd);\n\n\n\ntemplate &lt;class T&gt; void InitRivers(Param XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;T&gt; &amp;XModel)\n{\n    //========================\n    // River discharge\n\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        //\n        double xl, yb, xr, yt, xi,yi ;\n        int ib;\n        double levdx, levdelta;\n        double dischargeArea;\n        log(\"\\tInitializing rivers\");\n        //For each rivers\n        for (int Rin = 0; Rin &lt; XForcing.rivers.size(); Rin++)\n        {\n            dischargeArea = 0.0;\n            // find the cells where the river discharge will be applied\n            std::vector&lt;int&gt; idis, jdis, blockdis;\n            for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n            {\n                ib = XModel.blocks.active[ibl];\n                levdx = calcres(XParam.dx, XModel.blocks.level[ib]);\n                levdelta = calcres(XParam.delta, XModel.blocks.level[ib]);\n                for (int j = 0; j &lt; XParam.blkwidth; j++)\n                {\n                    for (int i = 0; i &lt; XParam.blkwidth; i++)\n                    {\n                        //int n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n                        xi = XParam.xo + XModel.blocks.xo[ib] + i * levdx;\n                        yi = XParam.yo + XModel.blocks.yo[ib] + j * levdx;\n\n\n\n                        xl = xi - 0.5 * levdx;\n                        yb = yi - 0.5 * levdx;\n\n                        xr = xi + 0.5 * levdx;\n                        yt = yi + 0.5 * levdx;\n                        // the conditions are that the discharge area as defined by the user have to include at least a model grid node\n                        // This could be really annoying and there should be a better way to deal wiith this like polygon intersection\n                        //if (xx &gt;= XForcing.rivers[Rin].xstart &amp;&amp; xx &lt;= XForcing.rivers[Rin].xend &amp;&amp; yy &gt;= XForcing.rivers[Rin].ystart &amp;&amp; yy &lt;= XForcing.rivers[Rin].yend)\n                        if (OBBdetect(xl, xr, yb, yt, XForcing.rivers[Rin].xstart, XForcing.rivers[Rin].xend, XForcing.rivers[Rin].ystart, XForcing.rivers[Rin].yend))\n                        {\n\n                            // This cell belongs to the river discharge area\n                            idis.push_back(i);\n                            jdis.push_back(j);\n                            blockdis.push_back(ib);\n                            if (XParam.spherical)\n                            {\n                                dischargeArea = dischargeArea + spharea(XParam.Radius, xi, yi, levdx);\n                            }\n                            else\n                            {\n                                dischargeArea = dischargeArea + levdelta * levdelta;\n                            }\n                        }\n                    }\n                }\n\n            }\n\n\n\n                XForcing.rivers[Rin].i = idis;\n                XForcing.rivers[Rin].j = jdis;\n                XForcing.rivers[Rin].block = blockdis;\n                XForcing.rivers[Rin].disarea = dischargeArea; // That is valid for spherical grids\n\n\n\n        }\n\n        for (auto it = XForcing.rivers.begin(); it != XForcing.rivers.end(); it++)\n        {\n\n            if (it-&gt;disarea == 0.0)\n            {\n                log(\"Warning river outside active model domain found. This river has been removed!\\n\");\n                XForcing.rivers.erase(it--);\n            }\n        }\n\n\n        //Now identify sort and unique blocks where rivers are being inserted\n        std::vector&lt;int&gt; activeRiverBlk;\n\n        for (int Rin = 0; Rin &lt; XForcing.rivers.size(); Rin++)\n        {\n\n            activeRiverBlk.insert(std::end(activeRiverBlk), std::begin(XForcing.rivers[Rin].block), std::end(XForcing.rivers[Rin].block));\n        }\n        std::sort(activeRiverBlk.begin(), activeRiverBlk.end());\n        activeRiverBlk.erase(std::unique(activeRiverBlk.begin(), activeRiverBlk.end()), activeRiverBlk.end());\n        if (activeRiverBlk.size() &gt; size_t(XModel.bndblk.nblkriver))\n        {\n            ReallocArray(activeRiverBlk.size(), 1, XModel.bndblk.river);\n            XModel.bndblk.nblkriver = int(activeRiverBlk.size());\n        }\n\n\n\n        for (int b = 0; b &lt; activeRiverBlk.size(); b++)\n        {\n            XModel.bndblk.river[b] = activeRiverBlk[b];\n        }\n\n        // Setup the river info\n\n        int nburmax = activeRiverBlk.size();\n        int nribmax = 0;\n        for (int b = 0; b &lt; activeRiverBlk.size(); b++)\n        {\n            int bur = activeRiverBlk[b];\n            int nriverinblock = 0;\n            for (int Rin = 0; Rin &lt; XForcing.rivers.size(); Rin++)\n            {\n                std::vector&lt;int&gt; uniqblockforriver = XForcing.rivers[Rin].block;\n\n                std::sort(uniqblockforriver.begin(), uniqblockforriver.end());\n                uniqblockforriver.erase(std::unique(uniqblockforriver.begin(), uniqblockforriver.end()), uniqblockforriver.end());\n\n                for (int bir = 0; bir &lt; uniqblockforriver.size(); bir++)\n                {\n                    if (uniqblockforriver[bir] == bur)\n                    {\n                        nriverinblock = nriverinblock + 1;\n                    }\n                }\n\n            }\n            nribmax = max(nribmax, nriverinblock);\n        }\n\n        // Allocate Qnow as pinned memory\n        AllocateMappedMemCPU(XForcing.rivers.size(), 1, XParam.GPUDEVICE,XModel.bndblk.Riverinfo.qnow);\n        AllocateCPU(nribmax, nburmax, XModel.bndblk.Riverinfo.xstart, XModel.bndblk.Riverinfo.xend, XModel.bndblk.Riverinfo.ystart, XModel.bndblk.Riverinfo.yend);\n        FillCPU(nribmax, nburmax, T(-1.0), XModel.bndblk.Riverinfo.xstart);\n        FillCPU(nribmax, nburmax, T(-1.0), XModel.bndblk.Riverinfo.xend);\n        FillCPU(nribmax, nburmax, T(-1.0), XModel.bndblk.Riverinfo.ystart);\n        FillCPU(nribmax, nburmax, T(-1.0), XModel.bndblk.Riverinfo.yend);\n\n\n\n        // Allocate XXbidir and Xridib\n        ReallocArray(nribmax, nburmax, XModel.bndblk.Riverinfo.Xbidir);\n        ReallocArray(nribmax, nburmax, XModel.bndblk.Riverinfo.Xridib);\n\n        // Fill them with a flag value \n        FillCPU(nribmax, nburmax, -1, XModel.bndblk.Riverinfo.Xbidir);\n        FillCPU(nribmax, nburmax, -1, XModel.bndblk.Riverinfo.Xridib);\n\n        //Xbidir is an array that stores block id where n rivers apply\n        //along the row of Xbidir block id is unique. meaning that a block id ith two river injection will appear on two seperate row of Xbidir\n        //The number of column (size of row 1) in xbidir is nburmax = length(uniq(blockwith river injected))\n        //\n\n        //Xridib is an array that stores River id that a river is injected for the corresponding block id in Xbidir\n\n\n        XModel.bndblk.Riverinfo.nribmax = nribmax;\n        XModel.bndblk.Riverinfo.nburmax = nburmax;\n\n        std::vector&lt;RiverBlk&gt; blocksalreadyin;\n        RiverBlk emptyvec;\n        for (int iblk = 0; iblk &lt; nribmax; iblk++)\n        {\n\n            blocksalreadyin.push_back(emptyvec);\n\n        }\n\n        //(n, 10)\n        // \n        std::vector&lt;int&gt; iriv(nribmax,0);\n        for (int Rin = 0; Rin &lt; XForcing.rivers.size(); Rin++)\n        {\n            std::vector&lt;int&gt; uniqblockforriver = XForcing.rivers[Rin].block;\n\n            std::sort(uniqblockforriver.begin(), uniqblockforriver.end());\n            uniqblockforriver.erase(std::unique(uniqblockforriver.begin(), uniqblockforriver.end()), uniqblockforriver.end());\n\n\n\n            for (int bir = 0; bir &lt; uniqblockforriver.size(); bir++)\n            {\n\n                for (int iribm = 0; iribm &lt; nribmax; iribm++)\n                {\n\n                    if (std::find(blocksalreadyin[iribm].block.begin(), blocksalreadyin[iribm].block.end(), uniqblockforriver[bir]) != blocksalreadyin[iribm].block.end())\n                    {\n                        //block found already listed in that line;\n\n                        continue;\n                    }\n                    else\n                    {\n                        //not found;\n                        // write to the array\n                        XModel.bndblk.Riverinfo.Xbidir[iriv[iribm] + iribm * nburmax] = uniqblockforriver[bir];\n                        XModel.bndblk.Riverinfo.Xridib[iriv[iribm] + iribm * nburmax] = Rin;\n\n                        iriv[iribm] = iriv[iribm] + 1;\n\n                        // add it to the list \n                        blocksalreadyin[iribm].block.push_back(uniqblockforriver[bir]);\n\n\n\n                        break;\n                    }\n                }\n\n            }\n\n        }\n        for (int iribm = 0; iribm &lt; nribmax; iribm++)\n        {\n            for (int ibur = 0; ibur &lt; nburmax; ibur++)\n            {\n                int indx = ibur + iribm * nburmax;\n                int Rin = XModel.bndblk.Riverinfo.Xridib[indx];\n                if (Rin &gt; -1)\n                {\n                    XModel.bndblk.Riverinfo.xstart[indx] = XForcing.rivers[Rin].xstart;\n                    XModel.bndblk.Riverinfo.xend[indx] = XForcing.rivers[Rin].xend;\n                    XModel.bndblk.Riverinfo.ystart[indx] = XForcing.rivers[Rin].ystart;\n                    XModel.bndblk.Riverinfo.yend[indx] = XForcing.rivers[Rin].yend;\n                }\n            }\n        }\n\n\n\n\n    }\n\n\n}\n\ntemplate void InitRivers&lt;float&gt;(Param XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;float&gt; &amp;XModel);\ntemplate void InitRivers&lt;double&gt;(Param XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;double&gt; &amp;XModel);\n\n\ntemplate&lt;class T&gt; void Initmaparray(Model&lt;T&gt;&amp; XModel)\n{\n    //Main Parameters\n    XModel.OutputVarMap[\"zb\"] = XModel.zb;\n    XModel.Outvarlongname[\"zb\"] = \"Ground elevation above datum\";\n    XModel.Outvarstdname[\"zb\"] = \"ground_elevation_above_datum\";\n    XModel.Outvarunits[\"zb\"] = \"m\";\n\n\n    XModel.OutputVarMap[\"u\"] = XModel.evolv.u;\n    XModel.Outvarlongname[\"u\"] = \"Water velocity in x-direction\";// zonal\n    XModel.Outvarstdname[\"u\"] = \"u_velocity\";\n    XModel.Outvarunits[\"u\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"v\"] = XModel.evolv.v;\n    XModel.Outvarlongname[\"v\"] = \"Velocity in y-direction\";// meridional\n    XModel.Outvarstdname[\"v\"] = \"v_velocity\";\n    XModel.Outvarunits[\"v\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"zs\"] = XModel.evolv.zs;\n    XModel.Outvarlongname[\"zs\"] = \"Water surface elevation above datum\";\n    XModel.Outvarstdname[\"zs\"] = \"water_surface_elevation\";\n    XModel.Outvarunits[\"zs\"] = \"m\";\n\n    XModel.OutputVarMap[\"h\"] = XModel.evolv.h;\n    XModel.Outvarlongname[\"h\"] = \"Water depth\";\n    XModel.Outvarstdname[\"h\"] = \"water_depth\";\n    XModel.Outvarunits[\"h\"] = \"m\";\n\n    //Mean Max parameters\n    XModel.OutputVarMap[\"hmean\"] = XModel.evmean.h;\n    XModel.Outvarlongname[\"hmean\"] = \"Mean water depth since last output\";\n    XModel.Outvarstdname[\"hmean\"] = \"mean_water_depth\";\n    XModel.Outvarunits[\"hmean\"] = \"m\";\n\n    XModel.OutputVarMap[\"hmax\"] = XModel.evmax.h;\n    XModel.Outvarlongname[\"hmax\"] = \"Maximum water depth since simulation start\";\n    XModel.Outvarstdname[\"hmax\"] = \"maximum_water_depth\";\n    XModel.Outvarunits[\"hmax\"] = \"m\";\n\n    XModel.OutputVarMap[\"zsmean\"] = XModel.evmean.zs;\n    XModel.Outvarlongname[\"zsmean\"] = \"Mean water elevation above datum since last output\";\n    XModel.Outvarstdname[\"zsmean\"] = \"mean_water_elevation\";\n    XModel.Outvarunits[\"zsmean\"] = \"m\";\n\n    XModel.OutputVarMap[\"zsmax\"] = XModel.evmax.zs;\n    XModel.Outvarlongname[\"zsmax\"] = \"Maximum water elevation above datum since simulation start\";\n    XModel.Outvarstdname[\"zsmax\"] = \"maximum_water_elevation\";\n    XModel.Outvarunits[\"zsmax\"] = \"m\";\n\n    XModel.OutputVarMap[\"umean\"] = XModel.evmean.u;\n    XModel.Outvarlongname[\"umean\"] = \"Mean velocity in x-direction since last output\";\n    XModel.Outvarstdname[\"umean\"] = \"mean_u_velocity\";\n    XModel.Outvarunits[\"umean\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"umax\"] = XModel.evmax.u;\n    XModel.Outvarlongname[\"umax\"] = \"Maximum velocity in x-direction since simulation start\";\n    XModel.Outvarstdname[\"umax\"] = \"maximum_u_velocity\";\n    XModel.Outvarunits[\"umax\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"vmean\"] = XModel.evmean.v;\n    XModel.Outvarlongname[\"vmean\"] = \"Mean velocity in y-direction since last output\";\n    XModel.Outvarstdname[\"vmean\"] = \"mean_v_velocity\";\n    XModel.Outvarunits[\"vmean\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"vmax\"] = XModel.evmax.v;\n    XModel.Outvarlongname[\"vmax\"] = \"Maximum velocity in y-direction since simulation start\";\n    XModel.Outvarstdname[\"vmax\"] = \"maximum_v_velocity\";\n    XModel.Outvarunits[\"vmax\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"Umean\"] = XModel.evmean.U;\n    XModel.Outvarlongname[\"Umean\"] = \"Mean velocity magnitude since last output\";\n    XModel.Outvarstdname[\"Umean\"] = \"mean_velocity\";\n    XModel.Outvarunits[\"Umean\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"Umax\"] = XModel.evmax.U;\n    XModel.Outvarlongname[\"Umax\"] = \"Maximum velocity magnitude since simulation start\";\n    XModel.Outvarstdname[\"Umax\"] = \"maximum_velocity\";\n    XModel.Outvarunits[\"Umax\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"hUmean\"] = XModel.evmean.hU;\n    XModel.Outvarlongname[\"hUmean\"] = \"Mean depth times velocity since last output\";\n    XModel.Outvarstdname[\"hUmean\"] = \"mean_depth_velocity\";\n    XModel.Outvarunits[\"hUmean\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"hUmax\"] = XModel.evmax.hU;\n    XModel.Outvarlongname[\"hUmax\"] = \"Maximum depth times velocity since simulation start\";\n    XModel.Outvarstdname[\"hUmax\"] = \"maximum_depth_velocity\";\n    XModel.Outvarunits[\"hUmax\"] = \"m2 s-1\";\n\n    //others\n\n    XModel.OutputVarMap[\"uo\"] = XModel.evolv_o.u;\n    XModel.Outvarlongname[\"uo\"] = \"Velocity in x-direction from previous half-step\";\n    XModel.Outvarstdname[\"uo\"] = \"previous_u_velocity\";\n    XModel.Outvarunits[\"uo\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"vo\"] = XModel.evolv_o.v;\n    XModel.Outvarlongname[\"vo\"] = \"Velocity in y-direction from previous half-step\";\n    XModel.Outvarstdname[\"vo\"] = \"previous_v_velocity\";\n    XModel.Outvarunits[\"vo\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"zso\"] = XModel.evolv_o.zs;\n    XModel.Outvarlongname[\"zso\"] = \"Water elevation above datum from previous half-step\";\n    XModel.Outvarstdname[\"zso\"] = \"previous_water_elevation\";\n    XModel.Outvarunits[\"zso\"] = \"m\";\n\n    XModel.OutputVarMap[\"ho\"] = XModel.evolv_o.h;\n    XModel.Outvarlongname[\"ho\"] = \"Water depth from previous half-step\";\n    XModel.Outvarstdname[\"ho\"] = \"previous_water_depth\";\n    XModel.Outvarunits[\"ho\"] = \"m\";\n\n    // Gradients\n\n    XModel.OutputVarMap[\"dhdx\"] = XModel.grad.dhdx;\n    XModel.Outvarlongname[\"dhdx\"] = \"Water depth gradient in x-direction\";\n    XModel.Outvarstdname[\"dhdx\"] = \"water_depth_gradient_x_direction\";\n    XModel.Outvarunits[\"dhdx\"] = \"m/m\";\n\n    XModel.OutputVarMap[\"dhdy\"] = XModel.grad.dhdy;\n    XModel.Outvarlongname[\"dhdy\"] = \"Water depth gradient in y-direction\";\n    XModel.Outvarstdname[\"dhdy\"] = \"water_depth_gradient_y_direction\";\n    XModel.Outvarunits[\"dhdy\"] = \"m/m\";\n\n    XModel.OutputVarMap[\"dudx\"] = XModel.grad.dudx;\n    XModel.Outvarlongname[\"dudx\"] = \"u-velocity gradient in x-direction\";\n    XModel.Outvarstdname[\"dudx\"] = \"u_velocity_gradient_x_direction\";\n    XModel.Outvarunits[\"dudx\"] = \"m s-1/m\";\n\n    XModel.OutputVarMap[\"dudy\"] = XModel.grad.dudy;\n    XModel.Outvarlongname[\"dudy\"] = \"u-velocity gradient in y-direction\";\n    XModel.Outvarstdname[\"dudy\"] = \"u_velocity_gradient_y_direction\";\n    XModel.Outvarunits[\"dudy\"] = \"m s-1/m\";\n\n    XModel.OutputVarMap[\"dvdx\"] = XModel.grad.dvdx;\n    XModel.Outvarlongname[\"dvdx\"] = \"v-velocity gradient in x-direction\";\n    XModel.Outvarstdname[\"dvdx\"] = \"v_velocity_gradient_x_direction\";\n    XModel.Outvarunits[\"dvdx\"] = \"m s-1/m\";\n\n    XModel.OutputVarMap[\"dvdy\"] = XModel.grad.dvdy;\n    XModel.Outvarlongname[\"dvdy\"] = \"v-velocity gradient in y-direction\";\n    XModel.Outvarstdname[\"dvdy\"] = \"v_velocity_gradient_y_direction\";\n    XModel.Outvarunits[\"dvdy\"] = \"m s-1/m\";\n\n    XModel.OutputVarMap[\"dzsdx\"] = XModel.grad.dzsdx;\n    XModel.Outvarlongname[\"dzsdx\"] = \"Water surface gradient in x-direction\";\n    XModel.Outvarstdname[\"dzsdx\"] = \"water_surface_gradient_x_direction\";\n    XModel.Outvarunits[\"dzsdx\"] = \"m/m\";\n\n    XModel.OutputVarMap[\"dzsdy\"] = XModel.grad.dzsdy;\n    XModel.Outvarlongname[\"dzsdy\"] = \"Water surface gradient in y-direction\";\n    XModel.Outvarstdname[\"dzsdy\"] = \"water_surface_gradient_y_direction\";\n    XModel.Outvarunits[\"dzsdy\"] = \"m/m\";\n\n    XModel.OutputVarMap[\"dzbdx\"] = XModel.grad.dzbdx;\n    XModel.Outvarlongname[\"dzbdx\"] = \"ground elevation gradient in x-direction\";\n    XModel.Outvarstdname[\"dzbdx\"] = \"ground_surface_gradient_x_direction\";\n    XModel.Outvarunits[\"dzbdx\"] = \"m/m\";\n\n    XModel.OutputVarMap[\"dzbdy\"] = XModel.grad.dzbdy;\n    XModel.Outvarlongname[\"dzbdy\"] = \"ground slope in y-direction\";\n    XModel.Outvarstdname[\"dzbdy\"] = \"ground_surface_gradient_y_direction\";\n    XModel.Outvarunits[\"dzbdy\"] = \"m/m\";\n\n    //Flux\n    XModel.OutputVarMap[\"Fhu\"] = XModel.flux.Fhu;\n    XModel.Outvarlongname[\"Fhu\"] = \"Fhu flux term in x-direction\";\n    XModel.Outvarstdname[\"Fhu\"] = \"Fh_x_direction\";\n    XModel.Outvarunits[\"Fhu\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"Fhv\"] = XModel.flux.Fhv;\n    XModel.Outvarlongname[\"Fhv\"] = \"Fhv flux term in y-direction\";\n    XModel.Outvarstdname[\"Fhv\"] = \"Fh_y_direction\";\n    XModel.Outvarunits[\"Fhv\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"Fqux\"] = XModel.flux.Fqux;\n    XModel.Outvarlongname[\"Fqux\"] = \"Fqux flux term in x-direction\";\n    XModel.Outvarstdname[\"Fqux\"] = \"Fqu_x_direction\";\n    XModel.Outvarunits[\"Fqux\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"Fqvy\"] = XModel.flux.Fqvy;\n    XModel.Outvarlongname[\"Fqvy\"] = \"Fqvy flux term in y-direction\";\n    XModel.Outvarstdname[\"Fqvy\"] = \"Fqv_y_direction\";\n    XModel.Outvarunits[\"Fqvy\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"Fquy\"] = XModel.flux.Fquy;\n    XModel.Outvarlongname[\"Fquy\"] = \"Fquy flux term in y-direction\";\n    XModel.Outvarstdname[\"Fquy\"] = \"Fqu_y_direction\";\n    XModel.Outvarunits[\"Fquy\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"Fqvx\"] = XModel.flux.Fqvx;\n    XModel.Outvarlongname[\"Fqvx\"] = \"Fqvx flux term in x-direction\";\n    XModel.Outvarstdname[\"Fqvx\"] = \"Fqv_x_direction\";\n    XModel.Outvarunits[\"Fqvx\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"Su\"] = XModel.flux.Su;\n    XModel.Outvarlongname[\"Su\"] = \"Topography source term un x-direction\";\n    XModel.Outvarstdname[\"Su\"] = \"Topo_source_x_direction\";\n    XModel.Outvarunits[\"Su\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"Sv\"] = XModel.flux.Sv;\n    XModel.Outvarlongname[\"Sv\"] = \"Topography source term un y-direction\";\n    XModel.Outvarstdname[\"Sv\"] = \"Topo_source_y_direction\";\n    XModel.Outvarunits[\"Sv\"] = \"m2 s-1\";\n\n    XModel.OutputVarMap[\"Fux\"] = XModel.fluxml.Fux;\n    XModel.Outvarlongname[\"Fux\"] = \"Flux term Fu x-direction\";\n    XModel.Outvarstdname[\"Fux\"] = \"Flux_term_Fu_x_direction\";\n    XModel.Outvarunits[\"Fux\"] = \"m3 s-1\";\n\n    XModel.OutputVarMap[\"Fuy\"] = XModel.fluxml.Fuy;\n    XModel.Outvarlongname[\"Fuy\"] = \"Flux term Fu y-direction\";\n    XModel.Outvarstdname[\"Fuy\"] = \"Flux_term_Fu_y_direction\";\n    XModel.Outvarunits[\"Fuy\"] = \"m3 s-1\";\n\n    XModel.OutputVarMap[\"Fvx\"] = XModel.fluxml.Fvx;\n    XModel.Outvarlongname[\"Fvx\"] = \"Flux term Fv x-direction\";\n    XModel.Outvarstdname[\"Fvx\"] = \"Flux_term_Fv_x_direction\";\n    XModel.Outvarunits[\"Fvx\"] = \"m3 s-1\";\n\n    XModel.OutputVarMap[\"Fvy\"] = XModel.fluxml.Fvy;\n    XModel.Outvarlongname[\"Fvy\"] = \"Flux term Fv y-direction\";\n    XModel.Outvarstdname[\"Fvy\"] = \"Flux_term_Fv_y_direction\";\n    XModel.Outvarunits[\"Fvy\"] = \"m3 s-1\";\n\n    XModel.OutputVarMap[\"hau\"] = XModel.fluxml.hau;\n    XModel.Outvarlongname[\"hau\"] = \"Acceleration term hau x-direction\";\n    XModel.Outvarstdname[\"hau\"] = \"Acceleration_term_hau_x_direction\";\n    XModel.Outvarunits[\"hau\"] = \"m2 s-2\";\n\n    XModel.OutputVarMap[\"hav\"] = XModel.fluxml.hav;\n    XModel.Outvarlongname[\"hav\"] = \"Acceleration term hav y-direction\";\n    XModel.Outvarstdname[\"hav\"] = \"Acceleration_term_hav_y_direction\";\n    XModel.Outvarunits[\"hav\"] = \"m2 s-2\";\n\n    XModel.OutputVarMap[\"hfu\"] = XModel.fluxml.hfu;\n    XModel.Outvarlongname[\"hfu\"] = \"Flux term hfu x-direction\";\n    XModel.Outvarstdname[\"hfu\"] = \"Flux_term_hfu_x_direction\";\n    XModel.Outvarunits[\"hfu\"] = \"m3 s-1\";\n\n    XModel.OutputVarMap[\"hfv\"] = XModel.fluxml.hfv;\n    XModel.Outvarlongname[\"hfv\"] = \"Flux term hfv y-direction\";\n    XModel.Outvarstdname[\"hfv\"] = \"Flux_term_hfv_y_direction\";\n    XModel.Outvarunits[\"hfv\"] = \"m3 s-1\";\n\n    XModel.OutputVarMap[\"hu\"] = XModel.fluxml.hu;\n    XModel.Outvarlongname[\"hu\"] = \"Flux term hu x-direction\";\n    XModel.Outvarstdname[\"hu\"] = \"Flux_term_hu_x_direction\";\n    XModel.Outvarunits[\"hu\"] = \"m3 s-1\";\n\n    XModel.OutputVarMap[\"hv\"] = XModel.fluxml.hv;\n    XModel.Outvarlongname[\"hv\"] = \"Flux term hv y-direction\";\n    XModel.Outvarstdname[\"hv\"] = \"Flux_term_hv_y_direction\";\n    XModel.Outvarunits[\"hv\"] = \"m3 s-1\";\n\n    //Advance\n    XModel.OutputVarMap[\"dh\"] = XModel.adv.dh;\n    XModel.Outvarlongname[\"dh\"] = \"rate of change in water depth\";\n    XModel.Outvarstdname[\"dh\"] = \"rate_change_water_depth\";\n    XModel.Outvarunits[\"dh\"] = \"m s-1\";\n\n    XModel.OutputVarMap[\"dhu\"] = XModel.adv.dhu;\n    XModel.Outvarlongname[\"dhu\"] = \"changes in flux n x-direction\";\n    XModel.Outvarstdname[\"dhu\"] = \"rate_change_flux_x_direction\";\n    XModel.Outvarunits[\"dhu\"] = \"m3 s-1/s\";\n\n    XModel.OutputVarMap[\"dhv\"] = XModel.adv.dhv;\n    XModel.Outvarlongname[\"dhv\"] = \"changes in flux n y-direction\";\n    XModel.Outvarstdname[\"dhv\"] = \"rate_change_flux_y_direction\";\n    XModel.Outvarunits[\"dhv\"] = \"m3 s-1/s\";\n\n    XModel.OutputVarMap[\"cf\"] = XModel.cf;\n    XModel.Outvarlongname[\"cf\"] = \"Roughness\";\n    XModel.Outvarunits[\"cf\"] = \"m\";\n\n    XModel.OutputVarMap[\"il\"] = XModel.il;\n    XModel.Outvarlongname[\"il\"] = \"Initial loss water from inflitration\";\n    XModel.Outvarunits[\"il\"] = \"mm\";\n\n    XModel.OutputVarMap[\"cl\"] = XModel.cl;\n    XModel.Outvarlongname[\"cl\"] = \"Continung loss water from inflitration\";\n    XModel.Outvarunits[\"cl\"] = \"mm h-1\";\n\n    XModel.OutputVarMap[\"hgw\"] = XModel.hgw;\n    XModel.Outvarlongname[\"hgw\"] = \"Groundwater height\";\n    XModel.Outvarunits[\"hgw\"] = \"m\";\n\n    XModel.OutputVarMap[\"Patm\"] = XModel.Patm;\n    XModel.Outvarlongname[\"Patm\"] = \"Atmospheric pressure\";\n    XModel.Outvarunits[\"Patm\"] = \"m\";\n\n    XModel.OutputVarMap[\"datmpdx\"] = XModel.datmpdx;\n    XModel.Outvarlongname[\"datmpdx\"] = \"Atmospheric pressure gradient in x-direction\";\n    XModel.Outvarunits[\"datmpdx\"] = \"m/m\";\n\n    XModel.OutputVarMap[\"datmpdy\"] = XModel.datmpdy;\n    XModel.Outvarlongname[\"datmpdy\"] = \"Atmospheric pressure gradient in y-direction\";\n    XModel.Outvarunits[\"datmpdy\"] = \"m/m\";\n\n    //XModel.OutputVarMap[\"U\"] = XModel.U;\n\n    XModel.OutputVarMap[\"twet\"] = XModel.wettime;\n    XModel.Outvarlongname[\"twet\"] = \"time since the cell has been wet\";\n    XModel.Outvarunits[\"twet\"] = \"s\";\n    //XModel.OutputVarMap[\"vort\"] = XModel.vort;\n}\n\ntemplate void Initmaparray&lt;float&gt;(Model&lt;float&gt;&amp; XModel);\ntemplate void Initmaparray&lt;double&gt;(Model&lt;double&gt;&amp; XModel);\n\n\n// Initialise all storage involving parameters of the outzone objects\ntemplate &lt;class T&gt; void Findoutzoneblks(Param&amp; XParam, BlockP&lt;T&gt;&amp; XBlock)\n{\n    int ib, i;\n    T levdx;\n    std::vector&lt;int&gt; cornerblk; //index of the blocks at the corner of the zone \n    outzoneP Xzone; //info on outzone given by the user\n    outzoneB XzoneB; //info on outzone computed and used actually for writing nc files\n    //double eps;\n\n    // Find the blocks to output and the corners of this area for each zone\n    for (int o = 0; o &lt; XParam.outzone.size(); o++)\n    {\n\n        Xzone = XParam.outzone[o];\n\n        XzoneB.xo = Xzone.xstart;\n        XzoneB.yo = Xzone.ystart;\n        XzoneB.xmax = Xzone.xend;\n        XzoneB.ymax = Xzone.yend;\n\n        std::vector&lt;int&gt; blkzone;\n        double xl, xr, yb, yt;\n\n        int nblk = 0;\n        /*\n        cornerblk = { 0, 0, 0, 0 };\n        // Find the blocks to output for each zone (and the corner of this area) \n        //\n        //We want the samller rectangular area, composed of full blocks, \n        //containing the area defined by the user. \n        //- If all the blocks have the same resolution, at least a part of the block\n        //must be inside the user defined rectangular\n        // -If there is blocks of different resolutions in the area, the corners of the area\n        // must be defined first to have a rectangular zone. Then, a new pass through all blocks\n        // identify the blocks inside this new defined zone.\n\n\n        //Getting the new area's corners\n\n        //Initialisation of the corners blocks on the domain boundaries\n        //in case of the border given by user being out of the domain\n        RectCornerBlk(XParam, XBlock, XParam.xo, XParam.yo, XParam.xmax, XParam.ymax, true, cornerblk);\n\n        //Getting the corners blocks of the rectangle given by the user\n        RectCornerBlk(XParam, XBlock, XParam.outzone[o].xstart, XParam.outzone[o].ystart, XParam.outzone[o].xend, XParam.outzone[o].yend, false, cornerblk);\n\n\n        //left edge border\n        int il = (XBlock.level[cornerblk[0]] &lt; XBlock.level[cornerblk[1]]) ? cornerblk[0] : cornerblk[1];\n        levdx = calcres(XParam.dx, XBlock.level[il]);\n        XzoneB.xo = XParam.xo + XBlock.xo[il] - levdx / 2;\n        //bottom edge border\n        int ib = (XBlock.level[cornerblk[0]] &lt; XBlock.level[cornerblk[3]]) ? cornerblk[0] : cornerblk[3];\n        levdx = calcres(XParam.dx, XBlock.level[ib]);\n        XzoneB.yo = XParam.yo + XBlock.yo[ib] - levdx / 2;\n        //right edge border\n        int ir = (XBlock.level[cornerblk[2]] &lt; XBlock.level[cornerblk[3]]) ? cornerblk[2] : cornerblk[3];\n        levdx = calcres(XParam.dx, XBlock.level[ir]);\n        XzoneB.xmax = XParam.xo + XBlock.xo[ir] + (XParam.blkwidth - 1) * levdx + levdx/2;\n        //top edge border\n        int it = (XBlock.level[cornerblk[1]] &lt; XBlock.level[cornerblk[2]]) ? cornerblk[1] : cornerblk[2];\n        levdx = calcres(XParam.dx, XBlock.level[it]);\n        XzoneB.ymax = XParam.yo + XBlock.yo[it] + (XParam.blkwidth - 1) * levdx + levdx/2;\n\n\n        if (XParam.maxlevel != XParam.minlevel) //if adapatation\n        {\n\n            //This minimal rectangular can include only part of blocks depending of resolution.\n            //the blocks containing the corners are found and the larger block impose its border on each side\n\n            //In order of avoiding rounding error, a slightly smaller rectangular is used\n            RectCornerBlk(XParam, XBlock, XzoneB.xo, XzoneB.yo, XzoneB.xmax, XzoneB.ymax, true, cornerblk);\n\n\n            // for each side, the border is imposed by the larger block (the \"further out\" one) if adaptative,\n            // if the grid is.\n\n            //left edge border\n            int il = (XBlock.level[cornerblk[0]] &lt; XBlock.level[cornerblk[1]]) ? cornerblk[0] : cornerblk[1];\n            levdx = calcres(XParam.dx, XBlock.level[il]);\n            XzoneB.xo = XParam.xo + XBlock.xo[il] - levdx/2;\n            //bottom edge border\n            int ib = (XBlock.level[cornerblk[0]] &lt; XBlock.level[cornerblk[3]]) ? cornerblk[0] : cornerblk[3];\n            levdx = calcres(XParam.dx, XBlock.level[ib]);\n            XzoneB.yo = XParam.yo + XBlock.yo[ib] - levdx/2;\n            //right edge border\n            int ir = (XBlock.level[cornerblk[2]] &lt; XBlock.level[cornerblk[3]]) ? cornerblk[2] : cornerblk[3];\n            levdx = calcres(XParam.dx, XBlock.level[ir]);\n            XzoneB.xmax = XParam.xo + XBlock.xo[ir] + (XParam.blkwidth - 1) * levdx + levdx/2;\n            //top edge border\n            int it = (XBlock.level[cornerblk[1]] &lt; XBlock.level[cornerblk[2]]) ? cornerblk[1] : cornerblk[2];\n            levdx = calcres(XParam.dx, XBlock.level[it]);\n            XzoneB.ymax = XParam.yo + XBlock.yo[it] + (XParam.blkwidth - 1) * levdx + levdx/2;\n        }\n        */\n        // Get the list of all blocks in the zone and the maximum and minimum level of refinement\n        int maxlevel = XParam.minlevel;\n        int minlevel = XParam.maxlevel;\n\n        for (i = 0; i &lt; XParam.nblk; i++)\n        {\n            ib = XBlock.active[i];\n            levdx = calcres(XParam.dx, XBlock.level[ib]);\n\n            // get the corners' locations of the block (center of the corner cell)\n            xl = XParam.xo + XBlock.xo[ib];\n            yb = XParam.yo + XBlock.yo[ib];\n            xr = XParam.xo + XBlock.xo[ib] + (XParam.blkwidth - 1) * levdx;\n            yt = XParam.yo + XBlock.yo[ib] + (XParam.blkwidth - 1) * levdx;\n\n            // Checking if at least one part of the a cell of the block is \n            // inside the area defined by the user.\n            if (OBBdetect(xl, xr, yb, yt, Xzone.xstart, Xzone.xend, Xzone.ystart, Xzone.yend))\n            {\n                // This block belongs to the output zone defined by the user\n                blkzone.push_back(ib);\n                nblk++;\n\n                XzoneB.xo = min(XzoneB.xo,XParam.xo + XBlock.xo[ib] - levdx / 2);\n                XzoneB.xmax = max(XzoneB.xmax, XParam.xo + XBlock.xo[ib] + (XParam.blkwidth - 1) * levdx + levdx / 2);\n                XzoneB.yo = min(XzoneB.yo, XParam.yo + XBlock.yo[ib] - levdx / 2);\n                XzoneB.ymax = max(XzoneB.ymax, XParam.yo + XBlock.yo[ib] + (XParam.blkwidth - 1) * levdx + levdx / 2);\n\n                //min/max levels\n                if (XBlock.level[ib] &gt; maxlevel) { maxlevel = XBlock.level[ib]; }\n                if (XBlock.level[ib] &lt; minlevel) { minlevel = XBlock.level[ib]; }\n            }\n\n\n        }\n        XzoneB.nblk = nblk;\n        XzoneB.maxlevel = maxlevel;\n        XzoneB.minlevel = minlevel;\n\n\n        AllocateCPU(blkzone.size(), 1, XzoneB.blk);\n        for (int b = 0; b &lt; blkzone.size(); b++)\n        {\n            XzoneB.blk[b] = blkzone[b];\n        }\n        XzoneB.outname = XParam.outzone[o].outname;\n\n        //All the zone informatin has been integrated in a outzoneB structure,\n        // and pushed back to the initial variable.\n        // If this variable has already be constructed and adjusted here (after adaptation for example),\n        // just modify the variable\n\n        if (XBlock.outZone.size() &lt; XParam.outzone.size())\n        {\n            XBlock.outZone.push_back(XzoneB);\n        }\n        else\n        {\n            XBlock.outZone[o] = XzoneB;\n        }\n    }\n\n}\ntemplate void Findoutzoneblks&lt;float&gt;(Param&amp; XParam, BlockP&lt;float&gt;&amp; XBlock);\ntemplate void Findoutzoneblks&lt;double&gt;(Param&amp; XParam, BlockP&lt;double&gt;&amp; XBlock);\n\ntemplate &lt;class T&gt; void Initoutzone(Param&amp; XParam, BlockP&lt;T&gt;&amp; XBlock)\n{\n    //The domain full domain is defined as the output zone by default \n    //(and the blocks have been initialised by default)\n    // If a zone for the output has been requested by the user, the blocks in the \n    // zone and the corners are computed here:\n\n    if (XParam.outzone.size() &gt; 0)\n    {\n        XBlock.outZone.reserve(XParam.outzone.size()); //to avoid a change of location of memory if not enought space\n        Findoutzoneblks(XParam, XBlock);\n    }\n    else\n    {\n        outzoneB XzoneB;\n        std::vector&lt;int&gt; blksall;\n        //Define the full domain as a zone\n        XzoneB.outname = XParam.outfile; //.assign(XParam.outfile);\n        XzoneB.xo = XParam.xo;\n        XzoneB.yo = XParam.yo;\n        XzoneB.xmax = XParam.xmax;\n        XzoneB.ymax = XParam.ymax;\n        XzoneB.nblk = XParam.nblk;\n        XzoneB.maxlevel = XParam.maxlevel;\n        XzoneB.minlevel = XParam.minlevel;\n        XzoneB.OutputT = { XParam.totaltime, XParam.endtime };\n        AllocateCPU(XParam.nblk, 1, XzoneB.blk);\n        int I = 0;\n        for (int ib = 0; ib &lt; XParam.nblk; ib++)\n        {\n            XzoneB.blk[ib] = XBlock.active[ib];\n        }\n\n        if (XBlock.outZone.size() &gt; 0) //If adaptative, the zone need to be written over\n        {\n            XBlock.outZone[0] = XzoneB;\n        }\n        else\n        {\n            XBlock.outZone.push_back(XzoneB);\n        }\n\n    }\n}\ntemplate void Initoutzone&lt;float&gt;(Param&amp; XParam, BlockP&lt;float&gt;&amp; XBlock);\ntemplate void Initoutzone&lt;double&gt;(Param&amp; XParam, BlockP&lt;double&gt;&amp; XBlock);\n\n\ntemplate &lt;class T&gt; void Initbndblks(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing, BlockP&lt;T&gt; XBlock)\n{\n    //if(XForcing.bndseg.size()&gt;0)\n\n    std::vector&lt;int&gt; bndblks;\n    std::vector&lt;int&gt; bndsegment;\n    // 1. Find all the boundary blocks (block with themselves as neighbours)\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n\n        bool testbot = (XBlock.BotLeft[ib] == ib) || (XBlock.BotRight[ib] == ib) || (XBlock.TopLeft[ib] == ib) || (XBlock.TopRight[ib] == ib) || (XBlock.LeftTop[ib] == ib) || (XBlock.LeftBot[ib] == ib) || (XBlock.RightTop[ib] == ib) || (XBlock.RightBot[ib] == ib);\n        if (testbot)\n        {\n            T dxlev = calcres(XParam.dx, XBlock.level[ib]);\n\n            bndblks.push_back(ib);\n            bndsegment.push_back(XForcing.bndseg.size()-1); // i.e. by default the block doesn't belong to a segment so it belongs to collector (last) segemnt\n            //loop through all but the last bnd seg which is meant for block that are not in any segments\n            for (int s = 0; s &lt; XForcing.bndseg.size()-1; s++)\n            {\n                bool inpoly=blockinpoly(T(XParam.xo + XBlock.xo[ib]), T(XParam.yo + XBlock.yo[ib]), dxlev, XParam.blkwidth, XForcing.bndseg[s].poly);\n\n                if (inpoly)\n                {\n                    bndsegment.back() = s;\n                }\n\n            }\n\n\n\n        }\n\n\n    }\n\n\n    for (int s = 0; s &lt; XForcing.bndseg.size(); s++)\n    {\n        int segcount = 0;\n        int leftcount = 0;\n        int rightcount = 0;\n        int topcount = 0;\n        int botcount = 0;\n\n        for (int ibl = 0; ibl &lt; bndblks.size(); ibl++)\n        {\n            int ib = bndblks[ibl];\n            if (bndsegment[ibl] == s)\n            {\n                segcount++;\n\n                if ((XBlock.BotLeft[ib] == ib) || (XBlock.BotRight[ib] == ib))\n                {\n                    botcount++;\n                }\n                if ((XBlock.TopLeft[ib] == ib) || (XBlock.TopRight[ib] == ib))\n                {\n                    topcount++;\n                }\n                if ((XBlock.LeftBot[ib] == ib) || (XBlock.LeftTop[ib] == ib))\n                {\n                    leftcount++;\n                }\n                if ((XBlock.RightBot[ib] == ib) || (XBlock.RightTop[ib] == ib))\n                {\n                    rightcount++;\n                }\n            }\n        }\n        XForcing.bndseg[s].nblk = segcount;\n\n        log(\"\\nBoundary Segment \" + std::to_string(s) + \" : \" + XForcing.bndseg[s].inputfile + \" has \" + std::to_string(segcount) + \" blocks \");\n\n        XForcing.bndseg[s].left.nblk = leftcount;\n        XForcing.bndseg[s].right.nblk = rightcount;\n        XForcing.bndseg[s].top.nblk = topcount;\n        XForcing.bndseg[s].bot.nblk = botcount;\n\n        //allocate array\n        //ReallocArray(int nblk, int blksize, T * &amp;zb)\n        ReallocArray(leftcount, 1, XForcing.bndseg[s].left.blk);\n        ReallocArray(rightcount, 1, XForcing.bndseg[s].right.blk);\n        ReallocArray(topcount, 1, XForcing.bndseg[s].top.blk);\n        ReallocArray(botcount, 1, XForcing.bndseg[s].bot.blk);\n\n        ReallocArray(leftcount, XParam.blkwidth, XForcing.bndseg[s].left.qmean);\n        ReallocArray(rightcount, XParam.blkwidth, XForcing.bndseg[s].right.qmean);\n        ReallocArray(topcount, XParam.blkwidth, XForcing.bndseg[s].top.qmean);\n        ReallocArray(botcount, XParam.blkwidth, XForcing.bndseg[s].bot.qmean);\n\n        FillCPU(leftcount, XParam.blkwidth, 0.0f, XForcing.bndseg[s].left.qmean);\n        FillCPU(rightcount, XParam.blkwidth, 0.0f, XForcing.bndseg[s].right.qmean);\n        FillCPU(topcount, XParam.blkwidth, 0.0f, XForcing.bndseg[s].top.qmean);\n        FillCPU(botcount, XParam.blkwidth, 0.0f, XForcing.bndseg[s].bot.qmean);\n\n        leftcount = 0;\n        rightcount = 0;\n        topcount = 0;\n        botcount = 0;\n\n        for (int ibl = 0; ibl &lt; bndblks.size(); ibl++)\n        {\n            int ib = bndblks[ibl];\n\n            if (bndsegment[ibl] == s)\n            {\n                if ((XBlock.BotLeft[ib] == ib) || (XBlock.BotRight[ib] == ib))\n                {\n                    XForcing.bndseg[s].bot.blk[botcount] = ib;\n                    botcount++;\n                }\n                if ((XBlock.TopLeft[ib] == ib) || (XBlock.TopRight[ib] == ib))\n                {\n                    XForcing.bndseg[s].top.blk[topcount] = ib;\n                    topcount++;\n                }\n                if ((XBlock.LeftBot[ib] == ib) || (XBlock.LeftTop[ib] == ib))\n                {\n                    XForcing.bndseg[s].left.blk[leftcount] = ib;\n                    leftcount++;\n                }\n                if ((XBlock.RightBot[ib] == ib) || (XBlock.RightTop[ib] == ib))\n                {\n                    XForcing.bndseg[s].right.blk[rightcount] = ib;\n                    rightcount++;\n                }\n\n            }\n\n        }\n\n\n\n    }\n\n\n}\n\ntemplate &lt;class T&gt; void Calcbndblks(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing, BlockP&lt;T&gt; XBlock)\n{\n    //=====================================\n    // Find how many blocks are on each bnds\n    int blbr = 0, blbb = 0, blbl = 0, blbt = 0;\n    T leftxo, rightxo, topyo, botyo;\n\n    T initlevdx = calcres(XParam.dx, XParam.initlevel);\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //double espdist = 0.00000001;///WARMING\n\n        int ib = XBlock.active[ibl];\n\n        T levdx = calcres(XParam.dx, XBlock.level[ib]);\n\n        leftxo = XBlock.xo[ib]; // in adaptive this shoulbe be a range \n\n        //leftyo =XBlock.yo[ib];\n        rightxo = XBlock.xo[ib] + (XParam.blkwidth - 1) * levdx;\n        //rightyo = XBlock.yo[ib];\n        //topxo = XBlock.xo[ib];\n        topyo = XBlock.yo[ib] + (XParam.blkwidth - 1) * levdx;\n        //botxo = XBlock.xo[ib];\n        botyo = XBlock.yo[ib];\n\n        if ((rightxo - (XParam.xmax-XParam.xo)) &gt; (-1.0 * levdx))\n        {\n            //\n            blbr++;\n            //bndrightblk[blbr] = bl;\n\n        }\n\n        if ((topyo - (XParam.ymax - XParam.yo)) &gt; (-1.0 * levdx))\n        {\n            //\n            blbt++;\n            //bndtopblk[blbt] = bl;\n\n        }\n        if (botyo &lt; levdx)\n        {\n            //\n            blbb++;\n            //bndbotblk[blbb] = bl;\n\n        }\n        if (leftxo &lt; levdx)\n        {\n            //\n            blbl++;\n            //bndleftblk[blbl] = bl;\n\n        }\n    }\n\n    // fill\n    XForcing.left.nblk = blbl;\n    XForcing.right.nblk = blbr;\n    XForcing.top.nblk = blbt;\n    XForcing.bot.nblk = blbb;\n\n\n    XParam.nbndblkleft = blbl;\n    XParam.nbndblkright = blbr;\n    XParam.nbndblktop = blbt;\n    XParam.nbndblkbot = blbb;\n\n\n}\n\n\ntemplate &lt;class T&gt; void Findbndblks(Param XParam, Model&lt;T&gt; XModel,Forcing&lt;float&gt; &amp;XForcing)\n{\n    //=====================================\n    // Find how many blocks are on each bnds\n    int blbr = 0, blbb = 0, blbl = 0, blbt = 0;\n    BlockP&lt;T&gt; XBlock = XModel.blocks;\n    T initlevdx = calcres(XParam.dx, XParam.initlevel);\n    T leftxo, rightxo, topyo, botyo;\n\n\n    // Reallocate array if necessary\n    ReallocArray(XParam.nbndblkleft, 1, XForcing.left.blks);\n    ReallocArray(XParam.nbndblkright, 1, XForcing.right.blks);\n    ReallocArray(XParam.nbndblktop, 1, XForcing.top.blks);\n    ReallocArray(XParam.nbndblkbot, 1, XForcing.bot.blks);\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //double espdist = 0.00000001;///WARMING\n\n        int ib = XBlock.active[ibl];\n        T levdx = calcres(XParam.dx, XModel.blocks.level[ib]);\n\n\n        leftxo = XBlock.xo[ib]; // in adaptive this shoulbe be a range \n\n        //leftyo = XBlock.yo[ib];\n        rightxo = XBlock.xo[ib] + (XParam.blkwidth - 1) * levdx;\n        //rightyo = XBlock.yo[ib];\n        //topxo = XBlock.xo[ib];\n        topyo = XBlock.yo[ib] + (XParam.blkwidth - 1) * levdx;\n        //botxo = XBlock.xo[ib];\n        botyo = XBlock.yo[ib];\n\n        if ((rightxo - (XParam.xmax-XParam.xo)) &gt; (-1.0 * levdx))\n        {\n            //\n            XForcing.right.blks[blbr] = ib;\n            blbr++;\n\n        }\n\n        if ((topyo - (XParam.ymax-XParam.yo)) &gt; (-1.0 * levdx))\n        {\n            //\n            XForcing.top.blks[blbt] = ib;\n            blbt++;\n\n        }\n        if (botyo &lt; levdx)\n        {\n            //\n            XForcing.bot.blks[blbb] = ib;\n            blbb++;\n\n        }\n        if (leftxo &lt; levdx)\n        {\n            //\n            XForcing.left.blks[blbl] = ib;\n            blbl++;\n\n        }\n    }\n\n\n\n\n}\n\ntemplate &lt;class T&gt; void RectCornerBlk(Param&amp; XParam, BlockP&lt;T&gt;&amp; XBlock, double xo, double yo, double xmax, double ymax, bool isEps, std::vector&lt;int&gt;&amp; cornerblk)\n{\n\n    int ib;\n    T levdx;\n    double xl, yb, xr, yt;\n    double eps = 0.0;\n\n    for (int i = 0; i &lt; XParam.nblk; i++)\n    {\n        ib = XBlock.active[i];\n        levdx = calcres(XParam.dx, XBlock.level[ib]);\n\n        // margin to search for block boundaries, to avoid machine error if rectangle corner are supposed to\n        // be on blocks edges\n\n        if (isEps == true)\n        {\n            eps = levdx/3;\n        }\n\n        // get the corners' locations of the block (edge of the corner cell)\n        xl = XParam.xo + XBlock.xo[ib] - levdx/2;\n        yb = XParam.yo + XBlock.yo[ib] - levdx/2;\n        xr = XParam.xo + XBlock.xo[ib] + (XParam.blkwidth - 1) * levdx + levdx/2;\n        yt = XParam.yo + XBlock.yo[ib] + (XParam.blkwidth - 1) * levdx + levdx/2;\n\n        // Getting the bottom left corner coordinate of the output area\n        if (xo + eps &gt;= xl &amp;&amp; xo + eps &lt;= xr &amp;&amp; yo + eps &gt;= yb &amp;&amp; yo + eps &lt;= yt)\n        {\n            cornerblk[0] = ib;\n        }\n        // Getting the top left corner coordinate of the output area\n        if (xo + eps &gt;= xl &amp;&amp; xo + eps &lt;= xr &amp;&amp; ymax - eps &gt;= yb &amp;&amp; ymax - eps &lt;= yt)\n        {\n            cornerblk[1] = ib;\n        }\n        // Getting the top right corner coordinate of the output area\n        if (xmax - eps &gt;= xl &amp;&amp; xmax - eps &lt;= xr &amp;&amp; ymax - eps &gt;= yb &amp;&amp; ymax - eps &lt;= yt)\n        {\n            cornerblk[2] = ib;\n        }\n        // Getting the bottom right corner coordinate of the output area\n        if (xmax - eps &gt;= xl &amp;&amp; xmax - eps &lt;= xr &amp;&amp; yo + eps &gt;= yb &amp;&amp; yo + eps &lt;= yt)\n        {\n            cornerblk[3] = ib;\n        }\n\n    }\n\n}\n\ntemplate &lt;class T&gt; void calcactiveCellCPU(Param XParam, BlockP&lt;T&gt; XBlock, Forcing&lt;float&gt;&amp; XForcing, T* zb)\n{\n    int ib,n,wn;\n\n    // Remove rain from area above mask elevatio\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                double levdx = calcres(XParam.dx, XBlock.level[ib]);\n                double x = XParam.xo + XBlock.xo[ib] + i * levdx;\n                double y = XParam.yo + XBlock.yo[ib] + j * levdx;\n                wn = 1;\n                if (XForcing.AOI.active)\n                {\n                    wn = wn_PnPoly(x, y, XForcing.AOI.poly);\n                }\n                n = memloc(XParam, i, j, ib);\n                if (zb[n] &lt; XParam.mask &amp;&amp; wn != 0)\n                {\n                    XBlock.activeCell[n] = 1;\n                }\n                else\n                {\n                    XBlock.activeCell[n] = 0;\n                }\n            }\n        }\n    }\n\n    //bool Modif = false;\n    if (XParam.rainbnd== false) {\n        // Remove rain from boundary cells\n        for (int ibl = 0; ibl &lt; XParam.nbndblkleft; ibl++)\n        {\n            ib = XForcing.left.blks[ibl];\n            for (int j = 0; j &lt; XParam.blkwidth; j++)\n            {\n                n = memloc(XParam, 0, j, ib);\n                XBlock.activeCell[n] = 0;\n\n                n = memloc(XParam, 1, j, ib);\n                XBlock.activeCell[n] = 0;\n            }\n        }\n        for (int ibl = 0; ibl &lt; XParam.nbndblkright; ibl++)\n        {\n            ib = XForcing.right.blks[ibl];\n            for (int j = 0; j &lt; XParam.blkwidth; j++)\n            {\n                n = memloc(XParam, XParam.blkwidth - 1, j, ib);\n                XBlock.activeCell[n] = 0;\n\n                n = memloc(XParam, XParam.blkwidth - 2, j, ib);\n                XBlock.activeCell[n] = 0;\n            }\n        }\n        for (int ibl = 0; ibl &lt; XParam.nbndblkbot; ibl++)\n        {\n            ib = XForcing.bot.blks[ibl];\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                n = memloc(XParam, i, 0, ib);\n                XBlock.activeCell[n] = 0;\n\n                n = memloc(XParam, i, 1, ib);\n                XBlock.activeCell[n] = 0;\n            }\n        }\n        for (int ibl = 0; ibl &lt; XParam.nbndblktop; ibl++)\n        {\n            ib = XForcing.top.blks[ibl];\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                n = memloc(XParam, i, XParam.blkwidth - 1, ib);\n                XBlock.activeCell[n] = 0;\n\n                n = memloc(XParam, i, XParam.blkwidth - 2, ib);\n                XBlock.activeCell[n] = 0;\n            }\n        }\n    }\n\n}\n\n\ntemplate &lt;class T&gt; __global__ void calcactiveCellGPU(Param XParam, BlockP&lt;T&gt; XBlock, T *zb)\n{\n    unsigned int blkmemwidth = blockDim.x + XParam.halowidth * 2;\n    unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int n = memloc(XParam.halowidth, blkmemwidth, ix, iy, ib);\n\n    if (zb[n] &lt; XParam.mask)\n    {\n        XBlock.activeCell[n] = 1;\n    }\n    else\n    {\n        XBlock.activeCell[n] = 0;\n    }\n}\n\ntemplate &lt;class T&gt; void initinfiltration(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* initLoss ,T* hgw)\n{\n//Initialisation to 0 (cold or hot start)\n\n\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = (i + XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n\n                if (h[n] &gt; XParam.eps)\n                {\n                    initLoss[n]=T(0.0);\n                }\n\n            }\n        }\n    }\n}\n\n// Create a vector of times steps from the input structure Toutput\nstd::vector&lt;double&gt; GetTimeOutput(T_output time_info)\n{\n    //std::vector&lt;double&gt; time_vect;\n    //double time;\n\n    //Add independant values\n    //if (!time_info.val.empty())\n    //{\n    //  time_vect = time_info.val;\n    //}\n\n    //Add timesteps from the vector \n    //time = time_info.init;\n    //while (time &lt; time_info.end)\n    //{\n    //  time_vect.push_back(time);\n    //  time += time_info.tstep;\n    //}\n\n    //Add last timesteps from the vector definition\n    //time_vect.push_back(time_info.end);\n\n    return(time_info.val);\n}\n\n\n\n// Creation of a vector for times requiering a map output\n// Compilations of vectors and independent times from the general input\n// and the different zones outputs\ntemplate &lt;class T&gt; void initOutputTimes(Param XParam, std::vector&lt;double&gt;&amp; OutputT, BlockP&lt;T&gt;&amp; XBlock)\n{\n    std::vector&lt;double&gt; times;\n    std::vector&lt;double&gt; times_partial;\n\n    times_partial = GetTimeOutput(XParam.Toutput);\n    //printf(\"Time partial:\\n\");\n    //for (int k = 0; k &lt; times_partial.size(); k++)\n    //{\n    //  printf(\"%f, \", times_partial[k]);\n    //}\n    //printf(\"\\n\");\n\n    times.insert(times.end(), times_partial.begin(), times_partial.end());\n\n    // if zoneOutputs, add their contribution\n    if (XParam.outzone.size() &gt; 0)\n    {\n        for (int ii = 0; ii &lt; XParam.outzone.size(); ii++)\n        {\n            times_partial = GetTimeOutput(XParam.outzone[ii].Toutput);\n\n            //Add to main vector\n            times.insert(times.end(), times_partial.begin(), times_partial.end());\n            //Sort and remove duplicate before saving in outZone struct\n            std::sort(times_partial.begin(), times_partial.end());\n            times_partial.erase(unique(times_partial.begin(), times_partial.end()), times_partial.end());\n\n            XBlock.outZone[ii].OutputT = times_partial;\n        }\n    }\n    else //If not zoneoutput, output zone saved in zoneoutput structure\n    {\n        std::sort(times_partial.begin(), times_partial.end());\n        times_partial.erase(unique(times_partial.begin(), times_partial.end()), times_partial.end());\n\n        XBlock.outZone[0].OutputT = times_partial;\n    }\n\n    // Sort the times for output\n    std::sort(times.begin(), times.end());\n    times.erase(unique(times.begin(), times.end()), times.end());\n\n    printf(\"Output Times:\\n\");\n    for (int k = 0; k &lt; times.size(); k++)\n    {\n        printf(\"%e, \", times[k]);\n    }\n    printf(\"\\n\");\n\n\n\n    OutputT = times;\n}\n</code></pre>"},{"location":"BGFlood/_initial_conditions_8h/","title":"File InitialConditions.h","text":""},{"location":"BGFlood/_initial_conditions_8h/#file-initialconditionsh","title":"File InitialConditions.h","text":"<p>FileList &gt; src &gt; InitialConditions.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"GridManip.h\"</code></li> <li><code>#include \"InitEvolv.h\"</code></li> <li><code>#include \"Gradients.h\"</code></li> <li><code>#include \"Spherical.h\"</code></li> </ul>"},{"location":"BGFlood/_initial_conditions_8h/#public-functions","title":"Public Functions","text":"Type Name void Calcbndblks (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; T &gt; XBlock) Calculates the number of blocks on each boundary of the domain. void FindTSoutNodes (Param &amp; XParam, BlockP&lt; T &gt; XBlock, BndblockP&lt; T &gt; &amp; bnd) Finds and assigns output nodes to blocks for time series output. void Findbndblks (Param XParam, Model&lt; T &gt; XModel, Forcing&lt; float &gt; &amp; XForcing) Finds which blocks on the model edge belong to a side boundary. void InitRivers (Param XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel) Initializes river discharge areas and assigns river information to model blocks. void InitTSOutput (Param XParam) Initializes time series output files for specified nodes. void InitialConditions (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel) Initializes model parameters, bathymetry, friction, initial conditions, and output variables. void Initmaparray (Model&lt; T &gt; &amp; XModel) Initializes output variable maps and metadata for the simulation. void Initoutzone (Param &amp; XParam, BlockP&lt; T &gt; &amp; XBlock) Initializes output zones for the simulation domain. void InitzbgradientCPU (Param XParam, Model&lt; T &gt; XModel) Initializes bathymetry gradient and halo on CPU. void InitzbgradientGPU (Param XParam, Model&lt; T &gt; XModel) Initializes bathymetry gradient and halo on GPU. void calcactiveCellCPU (Param XParam, BlockP&lt; T &gt; XBlock, Forcing&lt; float &gt; &amp; XForcing, T * zb) Calculates active cells in the domain based on mask elevation and area of interest. void initOutputTimes (Param XParam, std::vector&lt; double &gt; &amp; OutputT, BlockP&lt; T &gt; &amp; XBlock) Compiles and sorts output times for map outputs, including zone outputs. void initoutput (Param &amp; XParam, Model&lt; T &gt; &amp; XModel) Initializes output arrays and maps for the simulation."},{"location":"BGFlood/_initial_conditions_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_initial_conditions_8h/#function-calcbndblks","title":"function Calcbndblks","text":"<p>Calculates the number of blocks on each boundary of the domain. </p><pre><code>template&lt;class T&gt;\nvoid Calcbndblks (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; T &gt; XBlock\n) \n</code></pre> <p>Updates counts for left, right, top, and bottom boundaries and stores them in the forcing and parameter structures.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XForcing</code> Forcing data (float) </li> <li><code>XBlock</code> Block parameters </li> </ul>"},{"location":"BGFlood/_initial_conditions_8h/#function-findtsoutnodes","title":"function FindTSoutNodes","text":"<p>Finds and assigns output nodes to blocks for time series output. </p><pre><code>template&lt;class T&gt;\nvoid FindTSoutNodes (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; XBlock,\n    BndblockP &lt; T &gt; &amp; bnd\n) \n</code></pre> <p>Determines which block each output node belongs to and updates the boundary block structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>bnd</code> Boundary block structure </li> </ul>"},{"location":"BGFlood/_initial_conditions_8h/#function-findbndblks","title":"function Findbndblks","text":"<p>Finds which blocks on the model edge belong to a side boundary. </p><pre><code>template&lt;class T&gt;\nvoid Findbndblks (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre> <p>Populates arrays for blocks on each side boundary and updates the forcing structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XModel</code> Model data </li> <li><code>XForcing</code> Forcing data (float)</li> </ul> <p>Find which block on the model edge belongs to a \"side boundary\" </p>"},{"location":"BGFlood/_initial_conditions_8h/#function-initrivers","title":"function InitRivers","text":"<p>Initializes river discharge areas and assigns river information to model blocks. </p><pre><code>template&lt;class T&gt;\nvoid InitRivers (\n    Param XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Identifies grid cells affected by river discharge, calculates discharge areas, and sets up river-block relationships.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XForcing</code> Forcing data (float) </li> <li><code>XModel</code> Model data </li> </ul>"},{"location":"BGFlood/_initial_conditions_8h/#function-inittsoutput","title":"function InitTSOutput","text":"<p>Initializes time series output files for specified nodes. </p><pre><code>void InitTSOutput (\n    Param XParam\n) \n</code></pre> <p>Creates and overwrites output files for each node in the time series output list.</p> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> </ul>"},{"location":"BGFlood/_initial_conditions_8h/#function-initialconditions","title":"function InitialConditions","text":"<p>Initializes model parameters, bathymetry, friction, initial conditions, and output variables. </p><pre><code>template&lt;class T&gt;\nvoid InitialConditions (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Sets up the initial state of the simulation, including bathymetry, friction maps, evolving variables, river forcing, boundary blocks, active cells, and output arrays.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XForcing</code> Forcing data (float) </li> <li><code>XModel</code> Model data </li> </ul>"},{"location":"BGFlood/_initial_conditions_8h/#function-initmaparray","title":"function Initmaparray","text":"<p>Initializes output variable maps and metadata for the simulation. </p><pre><code>template&lt;class T&gt;\nvoid Initmaparray (\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Sets up output variable names, units, and long names for all tracked quantities in the model.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XModel</code> Model data </li> </ul>"},{"location":"BGFlood/_initial_conditions_8h/#function-initoutzone","title":"function Initoutzone","text":"<p>Initializes output zones for the simulation domain. </p><pre><code>template&lt;class T&gt;\nvoid Initoutzone (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre> <p>Sets up output zones based on user input or defaults to the full domain if none specified.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> </ul>"},{"location":"BGFlood/_initial_conditions_8h/#function-initzbgradientcpu","title":"function InitzbgradientCPU","text":"<p>Initializes bathymetry gradient and halo on CPU. </p><pre><code>template&lt;class T&gt;\nvoid InitzbgradientCPU (\n    Param XParam,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Computes gradients and refines bathymetry for the model blocks on the CPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XModel</code> Model data </li> </ul>"},{"location":"BGFlood/_initial_conditions_8h/#function-initzbgradientgpu","title":"function InitzbgradientGPU","text":"<p>Initializes bathymetry gradient and halo on GPU. </p><pre><code>template&lt;class T&gt;\nvoid InitzbgradientGPU (\n    Param XParam,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Computes gradients and refines bathymetry for the model blocks using CUDA streams and kernels.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XModel</code> Model data </li> </ul>"},{"location":"BGFlood/_initial_conditions_8h/#function-calcactivecellcpu","title":"function calcactiveCellCPU","text":"<p>Calculates active cells in the domain based on mask elevation and area of interest. </p><pre><code>template&lt;class T&gt;\nvoid calcactiveCellCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    Forcing &lt; float &gt; &amp; XForcing,\n    T * zb\n) \n</code></pre> <p>Sets the active cell flag for each cell, removing rain from masked and boundary cells as needed.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XForcing</code> Forcing data (float) </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_initial_conditions_8h/#function-initoutputtimes","title":"function initOutputTimes","text":"<p>Compiles and sorts output times for map outputs, including zone outputs. </p><pre><code>template&lt;class T&gt;\nvoid initOutputTimes (\n    Param XParam,\n    std::vector&lt; double &gt; &amp; OutputT,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre> <p>Combines times from the main output structure and all zone outputs, sorts and removes duplicates, and assigns to output arrays.</p> <p>Creation of a vector for times requiering a map output Compilations of vectors and independent times from the general input and the different zones outputs</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>OutputT</code> Output times vector </li> <li><code>XBlock</code> Block parameters </li> </ul>"},{"location":"BGFlood/_initial_conditions_8h/#function-initoutput","title":"function initoutput","text":"<p>Initializes output arrays and maps for the simulation. </p><pre><code>template&lt;class T&gt;\nvoid initoutput (\n    Param &amp; XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Sets up storage for evolving parameters, output zones, and output files.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XModel</code> Model data </li> </ul> <p>The documentation for this class was generated from the following file <code>src/InitialConditions.h</code></p>"},{"location":"BGFlood/_initial_conditions_8h_source/","title":"File InitialConditions.h","text":""},{"location":"BGFlood/_initial_conditions_8h_source/#file-initialconditionsh","title":"File InitialConditions.h","text":"<p>File List &gt; src &gt; InitialConditions.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef INITIALCONDITION_H\n#define INITIALCONDITION_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"Write_txtlog.h\"\n#include \"GridManip.h\"\n#include \"InitEvolv.h\"\n#include \"Gradients.h\"\n#include \"Spherical.h\"\n\n\ntemplate &lt;class T&gt; void InitialConditions(Param &amp;XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;T&gt; &amp;XModel);\n\ntemplate &lt;class T&gt; void InitRivers(Param XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;T&gt; &amp;XModel);\ntemplate&lt;class T&gt; void Initmaparray(Model&lt;T&gt; &amp;XModel);\ntemplate &lt;class T&gt; void initoutput(Param &amp;XParam, Model&lt;T&gt;&amp; XModel);\nvoid InitTSOutput(Param XParam);\n//template &lt;class T&gt; void Initbnds(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel);\n\ntemplate &lt;class T&gt; void FindTSoutNodes(Param&amp; XParam, BlockP&lt;T&gt; XBlock, BndblockP&lt;T&gt;&amp; bnd);\ntemplate &lt;class T&gt; void Calcbndblks(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing, BlockP&lt;T&gt; XBlock);\ntemplate &lt;class T&gt; void Findbndblks(Param XParam, Model&lt;T&gt; XModel, Forcing&lt;float&gt;&amp; XForcing);\ntemplate &lt;class T&gt; void Initoutzone(Param&amp; XParam, BlockP&lt;T&gt;&amp; XBlock);\n\ntemplate &lt;class T&gt; void InitzbgradientCPU(Param XParam, Model&lt;T&gt; XModel);\ntemplate &lt;class T&gt; void InitzbgradientGPU(Param XParam, Model&lt;T&gt; XModel);\n\ntemplate &lt;class T&gt; void calcactiveCellCPU(Param XParam, BlockP&lt;T&gt; XBlock, Forcing&lt;float&gt;&amp; XForcing, T* zb);\n\ntemplate &lt;class T&gt; void initOutputTimes(Param XParam, std::vector&lt;double&gt;&amp; OutputT, BlockP&lt;T&gt;&amp; XBlock);\n// End of global definition;\n#endif\n</code></pre>"},{"location":"BGFlood/_input_8h/","title":"File Input.h","text":""},{"location":"BGFlood/_input_8h/#file-inputh","title":"File Input.h","text":"<p>FileList &gt; src &gt; Input.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> </ul>"},{"location":"BGFlood/_input_8h/#classes","title":"Classes","text":"Type Name class Flowin class Mapparam class Pointout class Polygon class River class SLTS class TSoutnode class T_output class Vertex class Windin class inputmap class outzoneP <p>The documentation for this class was generated from the following file <code>src/Input.h</code></p>"},{"location":"BGFlood/_input_8h_source/","title":"File Input.h","text":""},{"location":"BGFlood/_input_8h_source/#file-inputh","title":"File Input.h","text":"<p>File List &gt; src &gt; Input.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef INPUT_H\n#define INPUT_H\n\n#include \"General.h\"\n\n// Timeseries output\nclass TSoutnode {\npublic:\n    int i, j, block;\n    double x, y;\n    std::string outname;\n};\n\n// Flexible definition of time outputs\nclass T_output {\npublic: \n    double init = NAN;\n    double tstep = NAN;\n    double end = NAN;\n    std::vector&lt;std::string&gt; inputstr;\n    std::vector&lt;double&gt; val;\n};\n\n// Special output zones for nc files, informatin given by the user\nclass outzoneP {\npublic:\n    //std::vector&lt;int&gt; blocks; // one zone will spread across multiple blocks (entire blocks containing a part of the area will be output)\n    double xstart, xend, ystart, yend; // definition of the zone needed for special nc output (rectangular zone) by the user\n    //double xo, xmax, yo, ymax; // Real zone for output (because we output full blocks)\n    std::string outname; // name for the output file (one for each zone)\n    T_output Toutput; // time for outputs for the zone\n};\n\nclass Flowin {\npublic:\n    double time, q;\n};\n\nclass Mapparam {\npublic:\n\n};\n\nclass River {\npublic:\n    std::vector&lt;int&gt; i, j, block; // one river can spring across multiple cells\n    double disarea; // discharge area\n    double xstart,xend, ystart,yend; // location of the discharge as a rectangle\n    double to, tmax;\n    std::string Riverflowfile; // river flow input time[s] flow in m3/s\n    std::vector&lt;Flowin&gt; flowinput; // vector to store the data of the river flow input file\n\n};\n\nclass inputmap {\npublic:\n    int nx = 0;\n    int ny= 0;\n    double xo = 0.0;\n    double yo = 0.0;\n    double xmax = 0.0;\n    double ymax = 0.0;\n    double dx = 0.0;\n    double dy = 0.0;\n    double grdalpha=0.0;\n    double denanval = NAN;\n    bool flipxx = false;\n    bool flipyy = false;\n    std::string inputfile;\n    std::string extension;\n    std::string varname;\n};\n\nclass SLTS {\npublic:\n    double time;\n    std::vector&lt;double&gt; wlevs;\n    std::vector&lt;double&gt; uuvel;\n    std::vector&lt;double&gt; vvvel;\n\n};\n\nclass Windin {\npublic:\n    double time;\n    double wspeed;\n    double wdirection;\n    double uwind;\n    double vwind;\n\n\n};\n\n\n// used as vector class to store Time series outputs\nclass Pointout {\npublic:\n    double time, zs, h, u,v;\n};\n\nclass Vertex {\npublic:\n    double x, y;\n};\n\nclass Polygon {\npublic:\n    double xmin, xmax, ymin, ymax;\n    std::vector&lt;Vertex&gt; vertices;\n};\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/","title":"File Kurganov.cu","text":""},{"location":"BGFlood/_kurganov_8cu/#file-kurganovcu","title":"File Kurganov.cu","text":"<p>FileList &gt; src &gt; Kurganov.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Kurganov.h\"</code></li> </ul>"},{"location":"BGFlood/_kurganov_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ void AddSlopeSourceXCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * zb) Host function for adding topographic slope source terms in X direction. template __host__ void AddSlopeSourceXCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * zb)  template __host__ void AddSlopeSourceXCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * zb)  __global__ void AddSlopeSourceXGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * zb) CUDA kernel for adding topographic slope source terms in X direction. template __global__ void AddSlopeSourceXGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * zb)  template __global__ void AddSlopeSourceXGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * zb)  __host__ void AddSlopeSourceYCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * zb) Host function for adding topographic slope source terms in Y direction. template __host__ void AddSlopeSourceYCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * zb)  template __host__ void AddSlopeSourceYCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * zb)  __global__ void AddSlopeSourceYGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * zb) CUDA kernel for adding topographic slope source terms in Y direction. template __global__ void AddSlopeSourceYGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * zb)  template __global__ void AddSlopeSourceYGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * zb)  __host__ __device__ T KurgSolver (T g, T delta, T epsi, T CFL, T cm, T fm, T hp, T hm, T up, T um, T &amp; fh, T &amp; fu) Kurganov-Petrova approximate Riemann solver for fluxes and time step. __host__ void updateKurgXATMCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb, T * Patm, T * dPdx) Host function for updating X-direction fluxes with atmospheric pressure effects. template __host__ void updateKurgXATMCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb, double * Patm, double * dPdx)  template __host__ void updateKurgXATMCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb, float * Patm, float * dPdx)  __global__ void updateKurgXATMGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb, T * Patm, T * dPdx) CUDA kernel for updating X-direction fluxes with atmospheric pressure effects. template __global__ void updateKurgXATMGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb, double * Patm, double * dPdx)  template __global__ void updateKurgXATMGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb, float * Patm, float * dPdx)  __host__ void updateKurgXCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) Host function for updating X-direction fluxes using the Kurganov scheme. template __host__ void updateKurgXCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb)  template __host__ void updateKurgXCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb)  __global__ void updateKurgXGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) CUDA kernel for updating X-direction fluxes using the Kurganov scheme. template __global__ void updateKurgXGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb)  template __global__ void updateKurgXGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb)  __host__ void updateKurgYATMCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb, T * Patm, T * dPdy) Host function for updating Y-direction fluxes with atmospheric pressure effects. template __host__ void updateKurgYATMCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb, double * Patm, double * dPdy)  template __host__ void updateKurgYATMCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb, float * Patm, float * dPdy)  __global__ void updateKurgYATMGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb, T * Patm, T * dPdy) CUDA kernel for updating Y-direction fluxes with atmospheric pressure effects. template __global__ void updateKurgYATMGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb, double * Patm, double * dPdy)  template __global__ void updateKurgYATMGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb, float * Patm, float * dPdy)  __host__ void updateKurgYCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) Host function for updating Y-direction fluxes using the Kurganov scheme. template __host__ void updateKurgYCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb)  template __host__ void updateKurgYCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb)  __global__ void updateKurgYGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) CUDA kernel for updating Y-direction fluxes using the Kurganov scheme. template __global__ void updateKurgYGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb)  template __global__ void updateKurgYGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb)"},{"location":"BGFlood/_kurganov_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_kurganov_8cu/#function-addslopesourcexcpu","title":"function AddSlopeSourceXCPU","text":"<p>Host function for adding topographic slope source terms in X direction. </p><pre><code>template&lt;class T&gt;\n__host__ void AddSlopeSourceXCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * zb\n) \n</code></pre> <p>Updates fluxes with slope source terms for well-balanced solutions on CPU (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_kurganov_8cu/#function-addslopesourcexcpu-double","title":"function AddSlopeSourceXCPU&lt; double &gt;","text":"<pre><code>template __host__ void AddSlopeSourceXCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-addslopesourcexcpu-float","title":"function AddSlopeSourceXCPU&lt; float &gt;","text":"<pre><code>template __host__ void AddSlopeSourceXCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-addslopesourcexgpu","title":"function AddSlopeSourceXGPU","text":"<p>CUDA kernel for adding topographic slope source terms in X direction. </p><pre><code>template&lt;class T&gt;\n__global__ void AddSlopeSourceXGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * zb\n) \n</code></pre> <p>Updates fluxes with slope source terms for well-balanced solutions (based on Kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_kurganov_8cu/#function-addslopesourcexgpu-double","title":"function AddSlopeSourceXGPU&lt; double &gt;","text":"<pre><code>template __global__ void AddSlopeSourceXGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-addslopesourcexgpu-float","title":"function AddSlopeSourceXGPU&lt; float &gt;","text":"<pre><code>template __global__ void AddSlopeSourceXGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-addslopesourceycpu","title":"function AddSlopeSourceYCPU","text":"<p>Host function for adding topographic slope source terms in Y direction. </p><pre><code>template&lt;class T&gt;\n__host__ void AddSlopeSourceYCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * zb\n) \n</code></pre> <p>Updates fluxes with slope source terms for well-balanced solutions in Y direction on CPU (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_kurganov_8cu/#function-addslopesourceycpu-double","title":"function AddSlopeSourceYCPU&lt; double &gt;","text":"<pre><code>template __host__ void AddSlopeSourceYCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-addslopesourceycpu-float","title":"function AddSlopeSourceYCPU&lt; float &gt;","text":"<pre><code>template __host__ void AddSlopeSourceYCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-addslopesourceygpu","title":"function AddSlopeSourceYGPU","text":"<p>CUDA kernel for adding topographic slope source terms in Y direction. </p><pre><code>template&lt;class T&gt;\n__global__ void AddSlopeSourceYGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * zb\n) \n</code></pre> <p>Updates fluxes with slope source terms for well-balanced solutions in Y direction (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_kurganov_8cu/#function-addslopesourceygpu-double","title":"function AddSlopeSourceYGPU&lt; double &gt;","text":"<pre><code>template __global__ void AddSlopeSourceYGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-addslopesourceygpu-float","title":"function AddSlopeSourceYGPU&lt; float &gt;","text":"<pre><code>template __global__ void AddSlopeSourceYGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-kurgsolver","title":"function KurgSolver","text":"<p>Kurganov-Petrova approximate Riemann solver for fluxes and time step. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T KurgSolver (\n    T g,\n    T delta,\n    T epsi,\n    T CFL,\n    T cm,\n    T fm,\n    T hp,\n    T hm,\n    T up,\n    T um,\n    T &amp; fh,\n    T &amp; fu\n) \n</code></pre> <p>Computes fluxes and time step for the Kurganov scheme given left/right states and velocities (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>g</code> Gravity </li> <li><code>delta</code> Cell size </li> <li><code>epsi</code> Small epsilon for stability </li> <li><code>CFL</code> CFL number </li> <li><code>cm</code> Metric coefficient </li> <li><code>fm</code> Flux metric </li> <li><code>hp</code> Water depth (plus side) </li> <li><code>hm</code> Water depth (minus side) </li> <li><code>up</code> Velocity (plus side) </li> <li><code>um</code> Velocity (minus side) </li> <li><code>fh</code> Output: flux for h </li> <li><code>fu</code> Output: flux for u </li> </ul> <p>Returns:</p> <p>Time step </p>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgxatmcpu","title":"function updateKurgXATMCPU","text":"<p>Host function for updating X-direction fluxes with atmospheric pressure effects. </p><pre><code>template&lt;class T&gt;\n__host__ void updateKurgXATMCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb,\n    T * Patm,\n    T * dPdx\n) \n</code></pre> <p>Computes fluxes and time step constraints for each cell in the X direction on CPU, including atmospheric pressure terms (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>dtmax</code> Maximum time step array </li> <li><code>zb</code> Bathymetry array </li> <li><code>Patm</code> Atmospheric pressure array </li> <li><code>dPdx</code> Pressure gradient array </li> </ul>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgxatmcpu-double","title":"function updateKurgXATMCPU&lt; double &gt;","text":"<pre><code>template __host__ void updateKurgXATMCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb,\n    double * Patm,\n    double * dPdx\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgxatmcpu-float","title":"function updateKurgXATMCPU&lt; float &gt;","text":"<pre><code>template __host__ void updateKurgXATMCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb,\n    float * Patm,\n    float * dPdx\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgxatmgpu","title":"function updateKurgXATMGPU","text":"<p>CUDA kernel for updating X-direction fluxes with atmospheric pressure effects. </p><pre><code>template&lt;class T&gt;\n__global__ void updateKurgXATMGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb,\n    T * Patm,\n    T * dPdx\n) \n</code></pre> <p>Computes fluxes and time step constraints for each cell in the X direction, including atmospheric pressure terms (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>dtmax</code> Maximum time step array </li> <li><code>zb</code> Bathymetry array </li> <li><code>Patm</code> Atmospheric pressure array </li> <li><code>dPdx</code> Pressure gradient array </li> </ul>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgxatmgpu-double","title":"function updateKurgXATMGPU&lt; double &gt;","text":"<pre><code>template __global__ void updateKurgXATMGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb,\n    double * Patm,\n    double * dPdx\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgxatmgpu-float","title":"function updateKurgXATMGPU&lt; float &gt;","text":"<pre><code>template __global__ void updateKurgXATMGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb,\n    float * Patm,\n    float * dPdx\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgxcpu","title":"function updateKurgXCPU","text":"<p>Host function for updating X-direction fluxes using the Kurganov scheme. </p><pre><code>template&lt;class T&gt;\n__host__ void updateKurgXCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre> <p>Computes fluxes and time step constraints for each cell in the X direction on CPU (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>dtmax</code> Maximum time step array </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgxcpu-double","title":"function updateKurgXCPU&lt; double &gt;","text":"<pre><code>template __host__ void updateKurgXCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgxcpu-float","title":"function updateKurgXCPU&lt; float &gt;","text":"<pre><code>template __host__ void updateKurgXCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgxgpu","title":"function updateKurgXGPU","text":"<p>CUDA kernel for updating X-direction fluxes using the Kurganov scheme. </p><pre><code>template&lt;class T&gt;\n__global__ void updateKurgXGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre> <p>Computes fluxes and time step constraints for each cell in the X direction (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>dtmax</code> Maximum time step array </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgxgpu-double","title":"function updateKurgXGPU&lt; double &gt;","text":"<pre><code>template __global__ void updateKurgXGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgxgpu-float","title":"function updateKurgXGPU&lt; float &gt;","text":"<pre><code>template __global__ void updateKurgXGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgyatmcpu","title":"function updateKurgYATMCPU","text":"<p>Host function for updating Y-direction fluxes with atmospheric pressure effects. </p><pre><code>template&lt;class T&gt;\n__host__ void updateKurgYATMCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb,\n    T * Patm,\n    T * dPdy\n) \n</code></pre> <p>Computes fluxes and time step constraints for each cell in the Y direction on CPU, including atmospheric pressure terms (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>dtmax</code> Maximum time step array </li> <li><code>zb</code> Bathymetry array </li> <li><code>Patm</code> Atmospheric pressure array </li> <li><code>dPdy</code> Pressure gradient array </li> </ul>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgyatmcpu-double","title":"function updateKurgYATMCPU&lt; double &gt;","text":"<pre><code>template __host__ void updateKurgYATMCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb,\n    double * Patm,\n    double * dPdy\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgyatmcpu-float","title":"function updateKurgYATMCPU&lt; float &gt;","text":"<pre><code>template __host__ void updateKurgYATMCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb,\n    float * Patm,\n    float * dPdy\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgyatmgpu","title":"function updateKurgYATMGPU","text":"<p>CUDA kernel for updating Y-direction fluxes with atmospheric pressure effects. </p><pre><code>template&lt;class T&gt;\n__global__ void updateKurgYATMGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb,\n    T * Patm,\n    T * dPdy\n) \n</code></pre> <p>Computes fluxes and time step constraints for each cell in the Y direction, including atmospheric pressure terms (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>dtmax</code> Maximum time step array </li> <li><code>zb</code> Bathymetry array </li> <li><code>Patm</code> Atmospheric pressure array </li> <li><code>dPdy</code> Pressure gradient array </li> </ul>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgyatmgpu-double","title":"function updateKurgYATMGPU&lt; double &gt;","text":"<pre><code>template __global__ void updateKurgYATMGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb,\n    double * Patm,\n    double * dPdy\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgyatmgpu-float","title":"function updateKurgYATMGPU&lt; float &gt;","text":"<pre><code>template __global__ void updateKurgYATMGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb,\n    float * Patm,\n    float * dPdy\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgycpu","title":"function updateKurgYCPU","text":"<p>Host function for updating Y-direction fluxes using the Kurganov scheme. </p><pre><code>template&lt;class T&gt;\n__host__ void updateKurgYCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre> <p>Computes fluxes and time step constraints for each cell in the Y direction on CPU (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>dtmax</code> Maximum time step array </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgycpu-double","title":"function updateKurgYCPU&lt; double &gt;","text":"<pre><code>template __host__ void updateKurgYCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgycpu-float","title":"function updateKurgYCPU&lt; float &gt;","text":"<pre><code>template __host__ void updateKurgYCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgygpu","title":"function updateKurgYGPU","text":"<p>CUDA kernel for updating Y-direction fluxes using the Kurganov scheme. </p><pre><code>template&lt;class T&gt;\n__global__ void updateKurgYGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre> <p>Computes fluxes and time step constraints for each cell in the Y direction (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>dtmax</code> Maximum time step array </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgygpu-double","title":"function updateKurgYGPU&lt; double &gt;","text":"<pre><code>template __global__ void updateKurgYGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_kurganov_8cu/#function-updatekurgygpu-float","title":"function updateKurgYGPU&lt; float &gt;","text":"<pre><code>template __global__ void updateKurgYGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Kurganov.cu</code></p>"},{"location":"BGFlood/_kurganov_8cu_source/","title":"File Kurganov.cu","text":""},{"location":"BGFlood/_kurganov_8cu_source/#file-kurganovcu","title":"File Kurganov.cu","text":"<p>File List &gt; src &gt; Kurganov.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Kurganov.h\"\n\n\ntemplate &lt;class T&gt; __global__ void updateKurgXGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T*zb)\n{\n\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int RB, LBRB, LB, RBLB, levRB, levLB;\n    RB = XBlock.RightBot[ib];\n    levRB = XBlock.level[RB];\n    LBRB = XBlock.LeftBot[RB];\n\n    LB = XBlock.LeftBot[ib];\n    levLB = XBlock.level[LB];\n    RBLB = XBlock.RightBot[LB];\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps)+epsi;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n    // This is based on kurganov and Petrova 2007\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix-1, iy, ib);\n\n    T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n    T dhdxi = XGrad.dhdx[i];\n    T dhdxmin = XGrad.dhdx[ileft];\n    T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T fmu = T(1.0);\n\n    T hi = XEv.h[i];\n\n    T hn = XEv.h[ileft];\n\n\n    if (hi &gt; eps || hn &gt; eps)\n    {\n        T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm, sl, sr,ga;\n\n        // along X\n        dx = delta * T(0.5);\n        zi = XEv.zs[i] - hi;\n\n        //printf(\"%f\\n\", zi);\n\n\n        //zl = zi - dx*(dzsdx[i] - dhdx[i]);\n        zl = zi - dx * (XGrad.dzsdx[i] - dhdxi);\n        //printf(\"%f\\n\", zl);\n\n        zn = XEv.zs[ileft] - hn;\n\n        //printf(\"%f\\n\", zn);\n        zr = zn + dx * (XGrad.dzsdx[ileft] - dhdxmin);\n\n\n        zlr = max(zl, zr);\n\n        //hl = hi - dx*dhdx[i];\n        hl = hi - dx * dhdxi;\n        up = XEv.u[i] - dx * XGrad.dudx[i];\n        hp = max(T(0.0), hl + zl - zlr);\n\n        hr = hn + dx * dhdxmin;\n        um = XEv.u[ileft] + dx * XGrad.dudx[ileft];\n        hm = max(T(0.0), hr + zr - zlr);\n\n        ga = g * T(0.5);\n\n        T fh, fu, fv, dt;\n\n\n        //solver below also modifies fh and fu\n        dt = KurgSolver(g, delta, epsi, CFL, cm, fmu, hp, hm, up, um, fh, fu);\n\n        if (dt &lt; dtmax[i])\n        {\n            dtmax[i] = dt;\n        }\n\n\n\n\n        if (fh &gt; T(0.0))\n        {\n            fv = (XEv.v[ileft] + dx * XGrad.dvdx[ileft]) * fh;// Eq 3.7 third term? (X direction)\n        }\n        else\n        {\n            fv = (XEv.v[i] - dx * XGrad.dvdx[i]) * fh;\n        }\n        //fv = (fh &gt; 0.f ? vv[xminus + iy*nx] + dx*dvdx[xminus + iy*nx] : vv[i] - dx*dvdx[i])*fh;\n        //dtmax needs to be stored in an array and reduced at the end\n        //dtmax = dtmaxf;\n        //dtmaxtmp = min(dtmax, dtmaxtmp);\n        /*if (ix == 11 &amp;&amp; iy == 0)\n        {\n            printf(\"a=%f\\t b=%f\\t c=%f\\t d=%f\\n\", ap*(qm*um + ga*hm2), -am*(qp*up + ga*hp2),( ap*(qm*um + g*sq(hm) / 2.0f) - am*(qp*up + g*sq(hp) / 2.0f) + ap*am*(qp - qm) ) *ad/100.0f, ad);\n        }\n        */\n        /*\n        #### Topographic source term\n\n        In the case of adaptive refinement, care must be taken to ensure\n        well-balancing at coarse/fine faces (see [notes/balanced.tm]()). */\n        if ((ix == blockDim.y) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = LBRB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n            int iright = memloc(halowidth, blkmemwidth, 0, jj, RB);;\n            hi = XEv.h[iright];\n            zi = zb[iright];\n        }\n        if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = RBLB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n            int ilc = memloc(halowidth, blkmemwidth, blockDim.y - 1, jj, LB);\n            hn = XEv.h[ilc];\n            zn = zb[ilc];\n        }\n\n        sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n        sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n        XFlux.Fhu[i] = fmu * fh;\n        XFlux.Fqux[i] = fmu * (fu - sl);\n        XFlux.Su[i] = fmu * (fu - sr);\n        XFlux.Fqvx[i] = fmu * fv;\n    }\n    else\n    {\n        dtmax[i] = T(1.0) / epsi;\n        XFlux.Fhu[i] = T(0.0);\n        XFlux.Fqux[i] = T(0.0);\n        XFlux.Su[i] = T(0.0);\n        XFlux.Fqvx[i] = T(0.0);\n    }\n\n\n\n\n}\ntemplate __global__ void updateKurgXGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb);\ntemplate __global__ void updateKurgXGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double *zb);\n\ntemplate &lt;class T&gt; __global__ void updateKurgXATMGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb, T* Patm, T*dPdx)\n{\n\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int RB, LBRB, LB, RBLB, levRB, levLB;\n    RB = XBlock.RightBot[ib];\n    levRB = XBlock.level[RB];\n    LBRB = XBlock.LeftBot[RB];\n\n    LB = XBlock.LeftBot[ib];\n    levLB = XBlock.level[LB];\n    RBLB = XBlock.RightBot[LB];\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n    // This is based on kurganov and Petrova 2007\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n    T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n\n    T dhdxi = XGrad.dhdx[i];\n    T dhdxmin = XGrad.dhdx[ileft];\n    T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T fmu = T(1.0);\n\n    T hi = XEv.h[i];\n\n    T hn = XEv.h[ileft];\n\n\n    if (hi &gt; eps || hn &gt; eps)\n    {\n        T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm, sl, sr, ga;\n\n        // along X\n        dx = delta * T(0.5);\n        zi = XEv.zs[i] - hi + XParam.Pa2m * Patm[i];\n\n        //printf(\"%f\\n\", zi);\n\n\n        //zl = zi - dx*(dzsdx[i] - dhdx[i]);\n        zl = zi - dx * (XGrad.dzsdx[i] - dhdxi + XParam.Pa2m * dPdx[i]);\n        //printf(\"%f\\n\", zl);\n\n        zn = XEv.zs[ileft] - hn + XParam.Pa2m * Patm[ileft];\n\n        //printf(\"%f\\n\", zn);\n        zr = zn + dx * (XGrad.dzsdx[ileft] - dhdxmin + XParam.Pa2m * dPdx[ileft]);\n\n\n        zlr = max(zl, zr);\n\n        //hl = hi - dx*dhdx[i];\n        hl = hi - dx * dhdxi;\n        up = XEv.u[i] - dx * XGrad.dudx[i];\n        hp = max(T(0.0), hl + zl - zlr);\n\n        hr = hn + dx * dhdxmin;\n        um = XEv.u[ileft] + dx * XGrad.dudx[ileft];\n        hm = max(T(0.0), hr + zr - zlr);\n\n        ga = g * T(0.5);\n\n        T fh, fu, fv, dt;\n\n\n        //solver below also modifies fh and fu\n        dt = KurgSolver(g, delta, epsi, CFL, cm, fmu, hp, hm, up, um, fh, fu);\n\n        if (dt &lt; dtmax[i])\n        {\n            dtmax[i] = dt;\n        }\n\n\n\n\n        if (fh &gt; T(0.0))\n        {\n            fv = (XEv.v[ileft] + dx * XGrad.dvdx[ileft]) * fh;// Eq 3.7 third term? (X direction)\n        }\n        else\n        {\n            fv = (XEv.v[i] - dx * XGrad.dvdx[i]) * fh;\n        }\n        //fv = (fh &gt; 0.f ? vv[xminus + iy*nx] + dx*dvdx[xminus + iy*nx] : vv[i] - dx*dvdx[i])*fh;\n        //dtmax needs to be stored in an array and reduced at the end\n        //dtmax = dtmaxf;\n        //dtmaxtmp = min(dtmax, dtmaxtmp);\n        /*if (ix == 11 &amp;&amp; iy == 0)\n        {\n            printf(\"a=%f\\t b=%f\\t c=%f\\t d=%f\\n\", ap*(qm*um + ga*hm2), -am*(qp*up + ga*hp2),( ap*(qm*um + g*sq(hm) / 2.0f) - am*(qp*up + g*sq(hp) / 2.0f) + ap*am*(qp - qm) ) *ad/100.0f, ad);\n        }\n        */\n        /*\n        #### Topographic source term\n\n        In the case of adaptive refinement, care must be taken to ensure\n        well-balancing at coarse/fine faces (see [notes/balanced.tm]()). */\n        if ((ix == blockDim.y) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = LBRB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n            int iright = memloc(halowidth, blkmemwidth, 0, jj, RB);;\n            hi = XEv.h[iright];\n            zi = zb[iright] + XParam.Pa2m * Patm[iright];\n        }\n        if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = RBLB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n            int ilc = memloc(halowidth, blkmemwidth, blockDim.y - 1, jj, LB);\n            hn = XEv.h[ilc];\n            zn = zb[ilc] + XParam.Pa2m * Patm[ilc];\n        }\n\n        sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n        sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n        XFlux.Fhu[i] = fmu * fh;\n        XFlux.Fqux[i] = fmu * (fu - sl);\n        XFlux.Su[i] = fmu * (fu - sr);\n        XFlux.Fqvx[i] = fmu * fv;\n    }\n    else\n    {\n        dtmax[i] = T(1.0) / epsi;\n        XFlux.Fhu[i] = T(0.0);\n        XFlux.Fqux[i] = T(0.0);\n        XFlux.Su[i] = T(0.0);\n        XFlux.Fqvx[i] = T(0.0);\n    }\n\n\n\n\n}\ntemplate __global__ void updateKurgXATMGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb, float* Patm, float* dPdx);\ntemplate __global__ void updateKurgXATMGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double* zb, double* Patm, double* dPdx);\n\n\ntemplate &lt;class T&gt; __global__ void AddSlopeSourceXGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T * zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n    // neighbours for source term\n    int RB, LBRB, LB, RBLB, levRB, levLB;\n    RB = XBlock.RightBot[ib];\n    levRB = XBlock.level[RB];\n    LBRB = XBlock.LeftBot[RB];\n\n    LB = XBlock.LeftBot[ib];\n    levLB = XBlock.level[LB];\n    RBLB = XBlock.RightBot[LB];\n\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n\n    T ga = T(0.5) * g;\n\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n\n    T dhdxi = XGrad.dhdx[i];\n    T dhdxmin = XGrad.dhdx[ileft];\n    //T cm = T(1.0);\n    T fmu = T(1.0);\n\n    T dx, zi, zl, zn, zr, zlr, hl, hp, hr, hm;\n\n    T hi = XEv.h[i];\n\n    T hn = XEv.h[ileft];\n\n    if (hi &gt; eps || hn &gt; eps)\n    {\n\n        // along X these are same as in Kurgannov\n        dx = delta * T(0.5);\n        zi = XEv.zs[i] - hi;\n\n        zl = zi - dx * (XGrad.dzsdx[i] - dhdxi);\n\n        zn = XEv.zs[ileft] - hn;\n\n        zr = zn + dx * (XGrad.dzsdx[ileft] - dhdxmin);\n\n        zlr = max(zl, zr);\n\n        hl = hi - dx * dhdxi;\n        hp = max(T(0.0), hl + zl - zlr);\n\n        hr = hn + dx * dhdxmin;\n        hm = max(T(0.0), hr + zr - zlr);\n\n\n        //#### Topographic source term\n        //In the case of adaptive refinement, care must be taken to ensure\n        //  well - balancing at coarse / fine faces(see[notes / balanced.tm]()). * /\n\n        if ((ix == blockDim.y) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = LBRB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n            int iright = memloc(halowidth, blkmemwidth, 0, jj, RB);;\n            hi = XEv.h[iright];\n            zi = zb[iright];\n        }\n        if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = RBLB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n            int ilc = memloc(halowidth, blkmemwidth, blockDim.y - 1, jj, LB);\n            hn = XEv.h[ilc];\n            zn = zb[ilc];\n        }\n\n        T sl, sr;\n        sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n        sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n        XFlux.Fqux[i] = XFlux.Fqux[i] - fmu * sl;\n        XFlux.Su[i] = XFlux.Su[i] - fmu * sr;\n    }\n}\ntemplate __global__ void AddSlopeSourceXGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* zb);\ntemplate __global__ void AddSlopeSourceXGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* zb);\n\ntemplate &lt;class T&gt; __host__ void updateKurgXCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T*zb)\n{\n\n\n    T delta;\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps)+epsi;\n    T ybo;\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    int RB, LBRB, LB, RBLB, levRB, levLB;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        int lev = XBlock.level[ib];\n        delta = calcres(T(XParam.delta), lev);\n\n        ybo = T(XParam.yo + XBlock.yo[ib]);\n\n        // neighbours for source term\n\n        RB = XBlock.RightBot[ib];\n        levRB = XBlock.level[RB];\n        LBRB = XBlock.LeftBot[RB];\n\n        LB = XBlock.LeftBot[ib];\n        levLB = XBlock.level[LB];\n        RBLB = XBlock.RightBot[LB];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth + XParam.halowidth); ix++)\n            {\n\n\n\n\n                // This is based on kurganov and Petrova 2007\n\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n\n                T dhdxi = XGrad.dhdx[i];\n                T dhdxmin = XGrad.dhdx[ileft];\n                T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);;\n                T fmu = T(1.0);\n\n                T hi = XEv.h[i];\n\n                T hn = XEv.h[ileft];\n\n\n                if (hi &gt; eps || hn &gt; eps)\n                {\n                    T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm,ga;\n\n                    // along X\n                    dx = delta * T(0.5);\n                    zi = XEv.zs[i] - hi;\n\n                    //printf(\"%f\\n\", zi);\n\n\n                    //zl = zi - dx*(dzsdx[i] - dhdx[i]);\n                    zl = zi - dx * (XGrad.dzsdx[i] - dhdxi);\n                    //printf(\"%f\\n\", zl);\n\n                    zn = XEv.zs[ileft] - hn;\n\n                    //printf(\"%f\\n\", zn);\n                    zr = zn + dx * (XGrad.dzsdx[ileft] - dhdxmin);\n\n\n                    zlr = max(zl, zr);\n\n                    //hl = hi - dx*dhdx[i];\n                    hl = hi - dx * dhdxi;\n                    up = XEv.u[i] - dx * XGrad.dudx[i];\n                    hp = max(T(0.0), hl + zl - zlr);\n\n                    hr = hn + dx * dhdxmin;\n                    um = XEv.u[ileft] + dx * XGrad.dudx[ileft];\n                    hm = max(T(0.0), hr + zr - zlr);\n\n                    ga = g * T(0.5);\n                    T fh, fu, fv, sl, sr, dt;\n\n                    //solver below also modifies fh and fu\n                    dt = KurgSolver(g, delta, epsi, CFL, cm, fmu, hp, hm, up, um, fh, fu);\n\n                    if (dt &lt; dtmax[i])\n                    {\n                        dtmax[i] = dt;\n                    }\n\n\n\n\n                    if (fh &gt; T(0.0))\n                    {\n                        fv = (XEv.v[ileft] + dx * XGrad.dvdx[ileft]) * fh;// Eq 3.7 third term? (X direction)\n                    }\n                    else\n                    {\n                        fv = (XEv.v[i] - dx * XGrad.dvdx[i]) * fh;\n                    }\n                    //fv = (fh &gt; 0.f ? vv[xminus + iy*nx] + dx*dvdx[xminus + iy*nx] : vv[i] - dx*dvdx[i])*fh;\n                    //dtmax needs to be stored in an array and reduced at the end\n                    //dtmax = dtmaxf;\n                    //dtmaxtmp = min(dtmax, dtmaxtmp);\n                    /*if (ix == 11 &amp;&amp; iy == 0)\n                    {\n                        printf(\"a=%f\\t b=%f\\t c=%f\\t d=%f\\n\", ap*(qm*um + ga*hm2), -am*(qp*up + ga*hp2),( ap*(qm*um + g*sq(hm) / 2.0f) - am*(qp*up + g*sq(hp) / 2.0f) + ap*am*(qp - qm) ) *ad/100.0f, ad);\n                    }\n                    */\n                    /*\n                    #### Topographic source term\n\n                    In the case of adaptive refinement, care must be taken to ensure\n                    well-balancing at coarse/fine faces (see [notes/balanced.tm]()). */\n\n                    if ((ix == XParam.blkwidth) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n                    {\n                        int jj = LBRB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n                        int iright = memloc(halowidth, blkmemwidth, 0, jj, RB);;\n                        hi = XEv.h[iright];\n                        zi = zb[iright];\n                    }\n                    if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo if you \n                    {\n                        int jj = RBLB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n                        int ilc = memloc(halowidth, blkmemwidth, XParam.blkwidth - 1, jj, LB);\n                        //int ilc = memloc(halowidth, blkmemwidth, -1, iy, ib);\n                        hn = XEv.h[ilc];\n                        zn = zb[ilc];\n                    }\n\n                    sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n                    sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n                    XFlux.Fhu[i] = fmu * fh;\n                    XFlux.Fqux[i] = fmu * (fu - sl);\n                    XFlux.Su[i] = fmu * (fu - sr);\n                    XFlux.Fqvx[i] = fmu * fv;\n                }\n                else\n                {\n                    dtmax[i] = T(1.0) / epsi;\n                    XFlux.Fhu[i] = T(0.0);\n                    XFlux.Fqux[i] = T(0.0);\n                    XFlux.Su[i] = T(0.0);\n                    XFlux.Fqvx[i] = T(0.0);\n                }\n\n            }\n        }\n    }\n\n\n}\ntemplate __host__ void updateKurgXCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float *zb);\ntemplate __host__ void updateKurgXCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double *zb);\n\ntemplate &lt;class T&gt; __host__ void updateKurgXATMCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb,T* Patm,T*dPdx)\n{\n\n\n    T delta;\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n\n    T ybo;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    int RB, LBRB, LB, RBLB, levRB, levLB;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        int lev = XBlock.level[ib];\n        delta = calcres(T(XParam.delta), lev);\n\n        // neighbours for source term\n\n        RB = XBlock.RightBot[ib];\n        levRB = XBlock.level[RB];\n        LBRB = XBlock.LeftBot[RB];\n\n        LB = XBlock.LeftBot[ib];\n        levLB = XBlock.level[LB];\n        RBLB = XBlock.RightBot[LB];\n\n        ybo = T(XParam.yo + XBlock.yo[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth + XParam.halowidth); ix++)\n            {\n\n\n\n\n                // This is based on kurganov and Petrova 2007\n\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n\n                T dhdxi = XGrad.dhdx[i];\n                T dhdxmin = XGrad.dhdx[ileft];\n                T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);;\n                T fmu = T(1.0);\n\n                T hi = XEv.h[i];\n\n                T hn = XEv.h[ileft];\n\n\n                if (hi &gt; eps || hn &gt; eps)\n                {\n                    T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm, ga;\n\n                    // along X\n                    dx = delta * T(0.5);\n                    zi = XEv.zs[i] - hi + T(XParam.Pa2m) * Patm[i];\n\n                    //printf(\"%f\\n\", zi);\n\n\n                    //zl = zi - dx*(dzsdx[i] - dhdx[i]);\n                    zl = zi - dx * (XGrad.dzsdx[i] - dhdxi + T(XParam.Pa2m) * dPdx[i]);\n                    //printf(\"%f\\n\", zl);\n\n                    zn = XEv.zs[ileft] - hn + T(XParam.Pa2m) * Patm[ileft];\n\n                    //printf(\"%f\\n\", zn);\n                    zr = zn + dx * (XGrad.dzsdx[ileft] - dhdxmin + T(XParam.Pa2m) * dPdx[ileft]);\n\n\n                    zlr = max(zl, zr);\n\n                    //hl = hi - dx*dhdx[i];\n                    hl = hi - dx * dhdxi;\n                    up = XEv.u[i] - dx * XGrad.dudx[i];\n                    hp = max(T(0.0), hl + zl - zlr);\n\n                    hr = hn + dx * dhdxmin;\n                    um = XEv.u[ileft] + dx * XGrad.dudx[ileft];\n                    hm = max(T(0.0), hr + zr - zlr);\n\n                    ga = g * T(0.5);\n                    T fh, fu, fv, sl, sr, dt;\n\n                    //solver below also modifies fh and fu\n                    dt = KurgSolver(g, delta, epsi, CFL, cm, fmu, hp, hm, up, um, fh, fu);\n\n                    if (dt &lt; dtmax[i])\n                    {\n                        dtmax[i] = dt;\n                    }\n\n\n\n\n                    if (fh &gt; T(0.0))\n                    {\n                        fv = (XEv.v[ileft] + dx * XGrad.dvdx[ileft]) * fh;// Eq 3.7 third term? (X direction)\n                    }\n                    else\n                    {\n                        fv = (XEv.v[i] - dx * XGrad.dvdx[i]) * fh;\n                    }\n                    //fv = (fh &gt; 0.f ? vv[xminus + iy*nx] + dx*dvdx[xminus + iy*nx] : vv[i] - dx*dvdx[i])*fh;\n                    //dtmax needs to be stored in an array and reduced at the end\n                    //dtmax = dtmaxf;\n                    //dtmaxtmp = min(dtmax, dtmaxtmp);\n                    /*if (ix == 11 &amp;&amp; iy == 0)\n                    {\n                        printf(\"a=%f\\t b=%f\\t c=%f\\t d=%f\\n\", ap*(qm*um + ga*hm2), -am*(qp*up + ga*hp2),( ap*(qm*um + g*sq(hm) / 2.0f) - am*(qp*up + g*sq(hp) / 2.0f) + ap*am*(qp - qm) ) *ad/100.0f, ad);\n                    }\n                    */\n                    /*\n                    #### Topographic source term\n\n                    In the case of adaptive refinement, care must be taken to ensure\n                    well-balancing at coarse/fine faces (see [notes/balanced.tm]()). */\n\n                    if ((ix == XParam.blkwidth) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n                    {\n                        int jj = LBRB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n                        int iright = memloc(halowidth, blkmemwidth, 0, jj, RB);;\n                        hi = XEv.h[iright];\n                        zi = zb[iright] + T(XParam.Pa2m) * Patm[iright];\n                    }\n                    if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo if you \n                    {\n                        int jj = RBLB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n                        int ilc = memloc(halowidth, blkmemwidth, XParam.blkwidth - 1, jj, LB);\n                        //int ilc = memloc(halowidth, blkmemwidth, -1, iy, ib);\n                        hn = XEv.h[ilc];\n                        zn = zb[ilc] + T(XParam.Pa2m) * Patm[ilc];\n                    }\n\n                    sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n                    sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n                    XFlux.Fhu[i] = fmu * fh;\n                    XFlux.Fqux[i] = fmu * (fu - sl);\n                    XFlux.Su[i] = fmu * (fu - sr);\n                    XFlux.Fqvx[i] = fmu * fv;\n                }\n                else\n                {\n                    dtmax[i] = T(1.0) / epsi;\n                    XFlux.Fhu[i] = T(0.0);\n                    XFlux.Fqux[i] = T(0.0);\n                    XFlux.Su[i] = T(0.0);\n                    XFlux.Fqvx[i] = T(0.0);\n                }\n\n            }\n        }\n    }\n\n\n}\ntemplate __host__ void updateKurgXATMCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb, float* Patm, float* dPdx);\ntemplate __host__ void updateKurgXATMCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double* zb, double* Patm, double* dPdx);\n\n\ntemplate &lt;class T&gt; __host__ void AddSlopeSourceXCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* zb)\n{\n    T delta;\n    //T g = T(XParam.g);\n    //T CFL = T(XParam.CFL);\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        int lev = XBlock.level[ib];\n        delta = T(calcres(XParam.delta, lev));\n\n        // neighbours for source term\n        int RB, LBRB, LB, RBLB, levRB, levLB;\n        RB = XBlock.RightBot[ib];\n        levRB = XBlock.level[RB];\n        LBRB = XBlock.LeftBot[RB];\n\n        LB = XBlock.LeftBot[ib];\n        levLB = XBlock.level[LB];\n        RBLB = XBlock.RightBot[LB];\n\n\n\n        //T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n        //T eps = T(XParam.eps) + epsi;\n\n        T g = T(XParam.g);\n        T ga = T(0.5) * g;\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth + XParam.halowidth); ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n\n                T dhdxi = XGrad.dhdx[i];\n                T dhdxmin = XGrad.dhdx[ileft];\n                //T cm = T(1.0);\n                T fmu = T(1.0);\n\n                T dx, zi, zl, zn, zr, zlr, hl, hp, hr, hm;\n\n                T hi = XEv.h[i];\n\n                T hn = XEv.h[ileft];\n\n                if (hi &gt; eps || hn &gt; eps)\n                {\n\n                    // along X these are same as in Kurgannov\n                    dx = delta * T(0.5);\n                    zi = XEv.zs[i] - hi;\n\n                    zl = zi - dx * (XGrad.dzsdx[i] - dhdxi);\n\n                    zn = XEv.zs[ileft] - hn;\n\n                    zr = zn + dx * (XGrad.dzsdx[ileft] - dhdxmin);\n\n                    zlr = max(zl, zr);\n\n                    hl = hi - dx * dhdxi;\n                    hp = max(T(0.0), hl + zl - zlr);\n\n                    hr = hn + dx * dhdxmin;\n                    hm = max(T(0.0), hr + zr - zlr);\n\n\n                    //#### Topographic source term\n                    //In the case of adaptive refinement, care must be taken to ensure\n                    //  well - balancing at coarse / fine faces(see[notes / balanced.tm]()). * /\n\n                    if ((ix == XParam.blkwidth) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n                    {\n                        int jj = LBRB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n                        int iright = memloc(halowidth, blkmemwidth, 0, jj, RB);;\n                        hi = XEv.h[iright];\n                        zi = zb[iright];\n                    }\n                    if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo if you \n                    {\n                        int jj = RBLB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n                        int ilc = memloc(halowidth, blkmemwidth, XParam.blkwidth - 1, jj, LB);\n                        hn = XEv.h[ilc];\n                        zn = zb[ilc];\n                    }\n\n                    T sl, sr;\n                    sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n                    sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n                    XFlux.Fqux[i] = XFlux.Fqux[i] - fmu * sl;\n                    XFlux.Su[i] = XFlux.Su[i] - fmu * sr;\n                }\n            }\n        }\n    }\n}\ntemplate __host__ void AddSlopeSourceXCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* zb);\ntemplate __host__ void AddSlopeSourceXCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* zb);\n\n\n\n\ntemplate &lt;class T&gt; __global__ void updateKurgYGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n    int TL, BLTL, BL, TLBL, levTL, levBL;\n    TL = XBlock.TopLeft[ib];\n    levTL = XBlock.level[TL];\n    BLTL = XBlock.BotLeft[TL];\n\n    BL = XBlock.BotLeft[ib];\n    levBL = XBlock.level[BL];\n    TLBL = XBlock.TopLeft[BL];\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps)+epsi;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ibot = memloc(halowidth, blkmemwidth, ix , iy-1, ib);\n\n    T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, T(iy)) : T(1.0);\n\n    T dhdyi = XGrad.dhdy[i];\n    T dhdymin = XGrad.dhdy[ibot];\n    T hi = XEv.h[i];\n    T hn = XEv.h[ibot];\n    T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm,ga;\n\n\n\n    if (hi &gt; eps || hn &gt; eps)\n    {\n        hn = XEv.h[ibot];\n        dx = delta * T(0.5);\n        zi = XEv.zs[i] - hi;\n        zl = zi - dx * (XGrad.dzsdy[i] - dhdyi);\n        zn = XEv.zs[ibot] - hn;\n        zr = zn + dx * (XGrad.dzsdy[ibot] - dhdymin);\n        zlr = max(zl, zr);\n\n        hl = hi - dx * dhdyi;\n        up = XEv.v[i] - dx * XGrad.dvdy[i];\n        hp = max(T(0.0), hl + zl - zlr);\n\n        hr = hn + dx * dhdymin;\n        um = XEv.v[ibot] + dx * XGrad.dvdy[ibot];\n        hm = max(T(0.0), hr + zr - zlr);\n\n\n        ga = g * T(0.5);\n\n        T fh, fu, fv, sl, sr, dt;\n\n        //solver below also modifies fh and fu\n        dt = KurgSolver(g, delta, epsi, CFL, cm, fmv, hp, hm, up, um, fh, fu);\n\n        if (dt &lt; dtmax[i])\n        {\n            dtmax[i] = dt;\n        }\n\n\n\n        if (fh &gt; T(0.0))\n        {\n            fv = (XEv.u[ibot] + dx * XGrad.dudy[ibot]) * fh;\n        }\n        else\n        {\n            fv = (XEv.u[i] - dx * XGrad.dudy[i]) * fh;\n        }\n        //fv = (fh &gt; 0.f ? uu[ix + yminus*nx] + dx*dudy[ix + yminus*nx] : uu[i] - dx*dudy[i])*fh;\n        //sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n        //sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n        //#### Topographic source term\n        //In the case of adaptive refinement, care must be taken to ensure\n        //  well - balancing at coarse / fine faces(see[notes / balanced.tm]()). * /\n\n        if ((iy == blockDim.x) &amp;&amp; levTL &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = BLTL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n            int itop = memloc(halowidth, blkmemwidth, jj, 0, TL);;\n            hi = XEv.h[itop];\n            zi = zb[itop];\n        }\n        if ((iy == 0) &amp;&amp; levBL &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = TLBL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n            int ibc = memloc(halowidth, blkmemwidth, jj, blockDim.x - 1, BL);\n            hn = XEv.h[ibc];\n            zn = zb[ibc];\n        }\n\n        sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n        sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n        XFlux.Fhv[i] = fmv * fh;\n        XFlux.Fqvy[i] = fmv * (fu - sl);\n        XFlux.Sv[i] = fmv * (fu - sr);\n        XFlux.Fquy[i] = fmv * fv;\n    }\n    else\n    {\n        dtmax[i] = T(1.0) / epsi;\n        XFlux.Fhv[i] = T(0.0);\n        XFlux.Fqvy[i] = T(0.0);\n        XFlux.Sv[i] = T(0.0);\n        XFlux.Fquy[i] = T(0.0);\n    }\n\n}\ntemplate __global__ void updateKurgYGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb);\ntemplate __global__ void updateKurgYGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double *zb);\n\n\ntemplate &lt;class T&gt; __global__ void updateKurgYATMGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb, T* Patm,T* dPdy)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n    int TL, BLTL, BL, TLBL, levTL, levBL;\n    TL = XBlock.TopLeft[ib];\n    levTL = XBlock.level[TL];\n    BLTL = XBlock.BotLeft[TL];\n\n    BL = XBlock.BotLeft[ib];\n    levBL = XBlock.level[BL];\n    TLBL = XBlock.TopLeft[BL];\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n\n    T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, T(iy)) : T(1.0);\n\n    T dhdyi = XGrad.dhdy[i];\n    T dhdymin = XGrad.dhdy[ibot];\n    T hi = XEv.h[i];\n    T hn = XEv.h[ibot];\n    T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm, ga;\n\n\n\n    if (hi &gt; eps || hn &gt; eps)\n    {\n        hn = XEv.h[ibot];\n        dx = delta * T(0.5);\n\n        //zi = XEv.zs[i] - hi;\n        //zl = zi - dx * (XGrad.dzsdy[i] - dhdyi);\n        //zn = XEv.zs[ibot] - hn;\n        //zr = zn + dx * (XGrad.dzsdy[ibot] - dhdymin);\n\n        zi = XEv.zs[i] - hi + XParam.Pa2m * Patm[i];\n        zl = zi - dx * (XGrad.dzsdy[i] - dhdyi + XParam.Pa2m * dPdy[i]);\n        zn = XEv.zs[ibot] - hn + XParam.Pa2m * Patm[ibot];\n        zr = zn + dx * (XGrad.dzsdy[ibot] - dhdymin + XParam.Pa2m * dPdy[ibot]);\n\n        zlr = max(zl, zr);\n\n        hl = hi - dx * dhdyi;\n        up = XEv.v[i] - dx * XGrad.dvdy[i];\n        hp = max(T(0.0), hl + zl - zlr);\n\n        hr = hn + dx * dhdymin;\n        um = XEv.v[ibot] + dx * XGrad.dvdy[ibot];\n        hm = max(T(0.0), hr + zr - zlr);\n\n\n        ga = g * T(0.5);\n\n        T fh, fu, fv, sl, sr, dt;\n\n        //solver below also modifies fh and fu\n        dt = KurgSolver(g, delta, epsi, CFL, cm, fmv, hp, hm, up, um, fh, fu);\n\n        if (dt &lt; dtmax[i])\n        {\n            dtmax[i] = dt;\n        }\n\n\n\n        if (fh &gt; T(0.0))\n        {\n            fv = (XEv.u[ibot] + dx * XGrad.dudy[ibot]) * fh;\n        }\n        else\n        {\n            fv = (XEv.u[i] - dx * XGrad.dudy[i]) * fh;\n        }\n        //fv = (fh &gt; 0.f ? uu[ix + yminus*nx] + dx*dudy[ix + yminus*nx] : uu[i] - dx*dudy[i])*fh;\n        //sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n        //sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n        //#### Topographic source term\n        //In the case of adaptive refinement, care must be taken to ensure\n        //  well - balancing at coarse / fine faces(see[notes / balanced.tm]()). * /\n\n        if ((iy == blockDim.x) &amp;&amp; levTL &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = BLTL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n            int itop = memloc(halowidth, blkmemwidth, jj, 0, TL);;\n            hi = XEv.h[itop];\n            zi = zb[itop] + XParam.Pa2m * Patm[itop];\n        }\n        if ((iy == 0) &amp;&amp; levBL &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = TLBL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n            int ibc = memloc(halowidth, blkmemwidth, jj, blockDim.x - 1, BL);\n            hn = XEv.h[ibc];\n            zn = zb[ibc] + +XParam.Pa2m * Patm[ibc];\n        }\n\n        sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n        sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n        XFlux.Fhv[i] = fmv * fh;\n        XFlux.Fqvy[i] = fmv * (fu - sl);\n        XFlux.Sv[i] = fmv * (fu - sr);\n        XFlux.Fquy[i] = fmv * fv;\n    }\n    else\n    {\n        dtmax[i] = T(1.0) / epsi;\n        XFlux.Fhv[i] = T(0.0);\n        XFlux.Fqvy[i] = T(0.0);\n        XFlux.Sv[i] = T(0.0);\n        XFlux.Fquy[i] = T(0.0);\n    }\n\n}\ntemplate __global__ void updateKurgYATMGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb, float* Patm, float* dPdy);\ntemplate __global__ void updateKurgYATMGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double* zb, double* Patm, double* dPdy);\n\n\n\ntemplate &lt;class T&gt; __global__ void AddSlopeSourceYGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n    // neighbours for source term\n    int TL, BLTL, BL, TLBL, levTL, levBL;\n    TL = XBlock.TopLeft[ib];\n    levTL = XBlock.level[TL];\n    BLTL = XBlock.BotLeft[TL];\n\n    BL = XBlock.BotLeft[ib];\n    levBL = XBlock.level[BL];\n    TLBL = XBlock.TopLeft[BL];\n\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T ga = T(0.5) * g;\n\n    T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n\n\n\n    //T cm = T(1.0);\n    T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, T(iy)) : T(1.0);\n\n    T dx, zi, zl, zn, zr, zlr, hl, hp, hr, hm;\n\n    T dhdyi = XGrad.dhdy[i];\n    T dhdymin = XGrad.dhdy[ibot];\n    T hi = XEv.h[i];\n    T hn = XEv.h[ibot];\n\n\n    if (hi &gt; eps || hn &gt; eps)\n    {\n\n        // along X these are same as in Kurgannov\n        dx = delta * T(0.5);\n        zi = XEv.zs[i] - hi;\n\n        zl = zi - dx * (XGrad.dzsdy[i] - dhdyi);\n        zn = XEv.zs[ibot] - hn;\n        zr = zn + dx * (XGrad.dzsdy[ibot] - dhdymin);\n        zlr = max(zl, zr);\n\n        hl = hi - dx * dhdyi;\n        hp = max(T(0.0), hl + zl - zlr);\n\n        hr = hn + dx * dhdymin;\n        hm = max(T(0.0), hr + zr - zlr);\n\n\n        //#### Topographic source term\n        //In the case of adaptive refinement, care must be taken to ensure\n        //  well - balancing at coarse / fine faces(see[notes / balanced.tm]()). * /\n\n        if ((iy == blockDim.x) &amp;&amp; levTL &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = BLTL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n            int itop = memloc(halowidth, blkmemwidth, jj, 0, TL);;\n            hi = XEv.h[itop];\n            zi = zb[itop];\n        }\n        if ((iy == 0) &amp;&amp; levBL &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = TLBL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n            int ibc = memloc(halowidth, blkmemwidth, jj, blockDim.x - 1, BL);\n            hn = XEv.h[ibc];\n            zn = zb[ibc];\n        }\n\n        T sl, sr;\n        sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n        sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n        XFlux.Fqvy[i] = XFlux.Fqvy[i] - fmv * sl;\n        XFlux.Sv[i] = XFlux.Sv[i] - fmv * sr;\n    }\n}\ntemplate __global__ void AddSlopeSourceYGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* zb);\ntemplate __global__ void AddSlopeSourceYGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* zb);\n\n\n\n\ntemplate &lt;class T&gt; __host__ void updateKurgYCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax,T*zb)\n{\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps)+epsi;\n    T delta;\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T ybo;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    int TL, BLTL, BL, TLBL, levTL, levBL, lev;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n\n\n\n        TL = XBlock.TopLeft[ib];\n        levTL = XBlock.level[TL];\n        BLTL = XBlock.BotLeft[TL];\n\n        BL = XBlock.BotLeft[ib];\n        levBL = XBlock.level[BL];\n        TLBL = XBlock.TopLeft[BL];\n\n        lev = XBlock.level[ib];\n\n        delta = T(calcres(XParam.delta, lev));\n\n        ybo = T(XParam.yo + XBlock.yo[ib]);\n\n        for (int iy = 0; iy &lt; (XParam.blkwidth + XParam.halowidth); iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n\n                T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n                T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, T(iy)) : T(1.0);\n\n                T dhdyi = XGrad.dhdy[i];\n                T dhdymin = XGrad.dhdy[ibot];\n                T hi = XEv.h[i];\n                T hn = XEv.h[ibot];\n                T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm, ga;\n\n\n\n\n                if (hi &gt; eps || hn &gt; eps)\n                {\n                    hn = XEv.h[ibot];\n                    dx = delta * T(0.5);\n                    zi = XEv.zs[i] - hi;\n                    zl = zi - dx * (XGrad.dzsdy[i] - dhdyi);\n                    zn = XEv.zs[ibot] - hn;\n                    zr = zn + dx * (XGrad.dzsdy[ibot] - dhdymin);\n                    zlr = max(zl, zr);\n\n                    hl = hi - dx * dhdyi;\n                    up = XEv.v[i] - dx * XGrad.dvdy[i];\n                    hp = max(T(0.0), hl + zl - zlr);\n\n                    hr = hn + dx * dhdymin;\n                    um = XEv.v[ibot] + dx * XGrad.dvdy[ibot];\n                    hm = max(T(0.0), hr + zr - zlr);\n\n\n                    ga = g * T(0.5);\n\n                    T fh, fu, fv, sl, sr, dt;\n\n                    //solver below also modifies fh and fu\n                    dt = KurgSolver(g, delta, epsi, CFL, cm, fmv, hp, hm, up, um, fh, fu);\n\n                    if (dt &lt; dtmax[i])\n                    {\n                        dtmax[i] = dt;\n                    }\n\n\n\n                    if (fh &gt; T(0.0))\n                    {\n                        fv = (XEv.u[ibot] + dx * XGrad.dudy[ibot]) * fh;\n                    }\n                    else\n                    {\n                        fv = (XEv.u[i] - dx * XGrad.dudy[i]) * fh;\n                    }\n                    //fv = (fh &gt; 0.f ? uu[ix + yminus*nx] + dx*dudy[ix + yminus*nx] : uu[i] - dx*dudy[i])*fh;\n                    if ((iy == XParam.blkwidth) &amp;&amp; levTL &lt; lev)//(ix==16) i.e. in the top halo\n                    {\n                        int jj = BLTL == ib ? ftoi(floor(ix * (T)0.5)) : ftoi(floor(ix * (T)0.5) + XParam.blkwidth / 2);\n                        int itop = memloc(halowidth, blkmemwidth, jj, 0, TL);\n                        hi = XEv.h[itop];\n                        zi = zb[itop];\n                    }\n                    if ((iy == 0) &amp;&amp; levBL &lt; lev)//(ix==16) i.e. in the bot halo\n                    {\n                        int jj = TLBL == ib ? ftoi(floor(ix * (T)0.5)) : ftoi(floor(ix * (T)0.5) + XParam.blkwidth / 2);\n                        int ibc = memloc(halowidth, blkmemwidth, jj, XParam.blkwidth - 1, BL);\n                        hn = XEv.h[ibc];\n                        zn = zb[ibc];\n                    }\n\n                    sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n                    sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n                    XFlux.Fhv[i] = fmv * fh;\n                    XFlux.Fqvy[i] = fmv *  (fu - sl);\n                    XFlux.Sv[i] = fmv * (fu - sr);\n                    XFlux.Fquy[i] = fmv * fv;\n                }\n                else\n                {\n                    dtmax[i] = T(1.0) / epsi;\n                    XFlux.Fhv[i] = T(0.0);\n                    XFlux.Fqvy[i] = T(0.0);\n                    XFlux.Sv[i] = T(0.0);\n                    XFlux.Fquy[i] = T(0.0);\n                }\n            }\n        }\n    }\n}\ntemplate __host__ void updateKurgYCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float *zb);\ntemplate __host__ void updateKurgYCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double *zb);\n\ntemplate &lt;class T&gt; __host__ void updateKurgYATMCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb, T* Patm, T* dPdy)\n{\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n    T delta;\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T ybo;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    int TL, BLTL, BL, TLBL, levTL, levBL, lev;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n\n\n\n        TL = XBlock.TopLeft[ib];\n        levTL = XBlock.level[TL];\n        BLTL = XBlock.BotLeft[TL];\n\n        BL = XBlock.BotLeft[ib];\n        levBL = XBlock.level[BL];\n        TLBL = XBlock.TopLeft[BL];\n\n        lev = XBlock.level[ib];\n\n        delta = T(calcres(XParam.delta, lev));\n\n        ybo = T(XParam.yo + XBlock.yo[ib]);\n\n        for (int iy = 0; iy &lt; (XParam.blkwidth + XParam.halowidth); iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n\n                T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n                T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, T(iy)) : T(1.0);\n\n                T dhdyi = XGrad.dhdy[i];\n                T dhdymin = XGrad.dhdy[ibot];\n                T hi = XEv.h[i];\n                T hn = XEv.h[ibot];\n                T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm, ga;\n\n\n\n\n                if (hi &gt; eps || hn &gt; eps)\n                {\n                    hn = XEv.h[ibot];\n                    dx = delta * T(0.5);\n\n\n                    //zi = XEv.zs[i] - hi;\n                    //zl = zi - dx * (XGrad.dzsdy[i] - dhdyi);\n                    //zn = XEv.zs[ibot] - hn;\n                    //zr = zn + dx * (XGrad.dzsdy[ibot] - dhdymin);\n\n                    zi = XEv.zs[i] - hi + T(XParam.Pa2m) * Patm[i];\n                    zl = zi - dx * (XGrad.dzsdy[i] - dhdyi + T(XParam.Pa2m) * dPdy[i]);\n                    zn = XEv.zs[ibot] - hn + T(XParam.Pa2m) * Patm[ibot];\n                    zr = zn + dx * (XGrad.dzsdy[ibot] - dhdymin + T(XParam.Pa2m) * dPdy[ibot]);\n\n                    zlr = max(zl, zr);\n\n                    hl = hi - dx * dhdyi;\n                    up = XEv.v[i] - dx * XGrad.dvdy[i];\n                    hp = max(T(0.0), hl + zl - zlr);\n\n                    hr = hn + dx * dhdymin;\n                    um = XEv.v[ibot] + dx * XGrad.dvdy[ibot];\n                    hm = max(T(0.0), hr + zr - zlr);\n\n\n                    ga = g * T(0.5);\n\n                    T fh, fu, fv, sl, sr, dt;\n\n                    //solver below also modifies fh and fu\n                    dt = KurgSolver(g, delta, epsi, CFL, cm, fmv, hp, hm, up, um, fh, fu);\n\n                    if (dt &lt; dtmax[i])\n                    {\n                        dtmax[i] = dt;\n                    }\n\n\n\n                    if (fh &gt; T(0.0))\n                    {\n                        fv = (XEv.u[ibot] + dx * XGrad.dudy[ibot]) * fh;\n                    }\n                    else\n                    {\n                        fv = (XEv.u[i] - dx * XGrad.dudy[i]) * fh;\n                    }\n                    //fv = (fh &gt; 0.f ? uu[ix + yminus*nx] + dx*dudy[ix + yminus*nx] : uu[i] - dx*dudy[i])*fh;\n                    if ((iy == XParam.blkwidth) &amp;&amp; levTL &lt; lev)//(ix==16) i.e. in the top halo\n                    {\n                        int jj = BLTL == ib ? ftoi(floor(ix * (T)0.5)) : ftoi(floor(ix * (T)0.5) + XParam.blkwidth / 2);\n                        int itop = memloc(halowidth, blkmemwidth, jj, 0, TL);\n                        hi = XEv.h[itop];\n                        zi = zb[itop] + T(XParam.Pa2m) * Patm[itop];\n                    }\n                    if ((iy == 0) &amp;&amp; levBL &lt; lev)//(ix==16) i.e. in the bot halo\n                    {\n                        int jj = TLBL == ib ? ftoi(floor(ix * (T)0.5)) : ftoi(floor(ix * (T)0.5) + XParam.blkwidth / 2);\n                        int ibc = memloc(halowidth, blkmemwidth, jj, XParam.blkwidth - 1, BL);\n                        hn = XEv.h[ibc];\n                        zn = zb[ibc] + T(XParam.Pa2m) * Patm[ibc];\n                    }\n\n                    sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n                    sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n                    XFlux.Fhv[i] = fmv * fh;\n                    XFlux.Fqvy[i] = fmv * (fu - sl);\n                    XFlux.Sv[i] = fmv * (fu - sr);\n                    XFlux.Fquy[i] = fmv * fv;\n                }\n                else\n                {\n                    dtmax[i] = T(1.0) / epsi;\n                    XFlux.Fhv[i] = T(0.0);\n                    XFlux.Fqvy[i] = T(0.0);\n                    XFlux.Sv[i] = T(0.0);\n                    XFlux.Fquy[i] = T(0.0);\n                }\n            }\n        }\n    }\n}\ntemplate __host__ void updateKurgYATMCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb, float* Patm, float* dPdy);\ntemplate __host__ void updateKurgYATMCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double* zb, double* Patm, double* dPdy);\n\n\ntemplate &lt;class T&gt; __host__ void AddSlopeSourceYCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* zb)\n{\n    T delta;\n    T g = T(XParam.g);\n    T ga = T(0.5) * g;\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n\n    T ybo;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n\n        int lev = XBlock.level[ib];\n        delta = T(calcres(XParam.delta, lev));\n        // neighbours for source term\n        int TL, BLTL, BL, TLBL, levTL, levBL;\n        TL = XBlock.TopLeft[ib];\n        levTL = XBlock.level[TL];\n        BLTL = XBlock.BotLeft[TL];\n\n        BL = XBlock.BotLeft[ib];\n        levBL = XBlock.level[BL];\n        TLBL = XBlock.TopLeft[BL];\n\n        ybo = T(XParam.yo + XBlock.yo[ib]);\n\n\n\n        for (int iy = 0; iy &lt; (XParam.blkwidth + XParam.halowidth); iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n\n\n\n                //T cm = T(1.0);\n                T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, T(iy)) : T(1.0);\n\n                T dx, zi, zl, zn, zr, zlr, hl, hp, hr, hm;\n\n                T dhdyi = XGrad.dhdy[i];\n                T dhdymin = XGrad.dhdy[ibot];\n                T hi = XEv.h[i];\n                T hn = XEv.h[ibot];\n\n\n                if (hi &gt; eps || hn &gt; eps)\n                {\n\n                    // along X these are same as in Kurgannov\n                    dx = delta * T(0.5);\n                    zi = XEv.zs[i] - hi;\n\n                    zl = zi - dx * (XGrad.dzsdy[i] - dhdyi);\n                    zn = XEv.zs[ibot] - hn;\n                    zr = zn + dx * (XGrad.dzsdy[ibot] - dhdymin);\n                    zlr = max(zl, zr);\n\n                    hl = hi - dx * dhdyi;\n                    hp = max(T(0.0), hl + zl - zlr);\n\n                    hr = hn + dx * dhdymin;\n                    hm = max(T(0.0), hr + zr - zlr);\n\n\n                    //#### Topographic source term\n                    //In the case of adaptive refinement, care must be taken to ensure\n                    //  well - balancing at coarse / fine faces(see[notes / balanced.tm]()). * /\n\n                    if ((iy == XParam.blkwidth) &amp;&amp; levTL &lt; lev)//(ix==16) i.e. in the right halo\n                    {\n                        int jj = BLTL == ib ? ftoi(floor(ix * (T)0.5)) : ftoi(floor(ix * (T)0.5) + XParam.blkwidth / 2);\n                        int itop = memloc(halowidth, blkmemwidth, jj, 0, TL);;\n                        hi = XEv.h[itop];\n                        zi = zb[itop];\n                    }\n                    if ((iy == 0) &amp;&amp; levBL &lt; lev)//(ix==16) i.e. in the right halo\n                    {\n                        int jj = TLBL == ib ? ftoi(floor(ix * (T)0.5)) : ftoi(floor(ix * (T)0.5) + XParam.blkwidth / 2);\n                        int ibc = memloc(halowidth, blkmemwidth, jj, XParam.blkwidth - 1, BL);\n                        hn = XEv.h[ibc];\n                        zn = zb[ibc];\n                    }\n\n                    T sl, sr;\n                    sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n                    sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n\n                    XFlux.Fqvy[i] = XFlux.Fqvy[i] - fmv * sl;\n                    XFlux.Sv[i] = XFlux.Sv[i] - fmv * sr;\n                }\n            }\n        }\n    }\n}\ntemplate __host__ void AddSlopeSourceYCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* zb);\ntemplate __host__ void AddSlopeSourceYCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* zb);\n\n\n\ntemplate &lt;class T&gt; __host__ __device__ T KurgSolver(T g, T delta,T epsi, T CFL, T cm, T fm,  T hp, T hm, T up,T um, T &amp;fh, T &amp;fu)\n{\n    T dt;\n\n    //We can now call one of the approximate Riemann solvers to get the fluxes.\n    T cp, cmo, ap, am, qm, qp, a, dlt, ad, hm2, hp2, ga, apm;\n\n\n    cp = sqrt(g * hp);\n    cmo = sqrt(g * hm);\n\n    ap = max(max(up + cp, um + cmo), T(0.0));\n    //ap = max(ap, 0.0f);\n\n    am = min(min(up - cp, um - cmo), T(0.0));\n    //am = min(am, 0.0f);\n    ad = T(1.0) / (ap - am);\n    //Correct for spurious currents in really shallow depth\n    qm = hm * um;\n    qp = hp * up;\n    //qm = hm*um*(sqrtf(2.0f) / sqrtf(1.0f + max(1.0f, powf(epsc / hm, 4.0f))));\n    //qp = hp*up*(sqrtf(2.0f) / sqrtf(1.0f + max(1.0f, powf(epsc / hp, 4.0f))));\n\n    hm2 = hm * hm;\n    hp2 = hp * hp;\n    a = max(ap, -am);\n    ga = g * T(0.5);\n    apm = ap * am;\n    dlt = delta * cm / fm;\n\n    if (a &gt; epsi)\n    {\n        fh = (ap * qm - am * qp + apm * (hp - hm)) * ad;// H  in eq. 2.24 or eq 3.7 for F(h)\n        fu = (ap * (qm * um + ga * hm2) - am * (qp * up + ga * hp2) + apm * (qp - qm)) * ad;// Eq 3.7 second term (Y direction)\n        dt = CFL * dlt / a;\n\n\n    }\n    else\n    {\n        fh = T(0.0);\n        fu = T(0.0);\n        dt = T(1.0) / epsi;\n    }\n    return dt;\n}\n</code></pre>"},{"location":"BGFlood/_kurganov_8h/","title":"File Kurganov.h","text":""},{"location":"BGFlood/_kurganov_8h/#file-kurganovh","title":"File Kurganov.h","text":"<p>FileList &gt; src &gt; Kurganov.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Spherical.h\"</code></li> </ul>"},{"location":"BGFlood/_kurganov_8h/#public-functions","title":"Public Functions","text":"Type Name __host__ void AddSlopeSourceXCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * zb) Host function for adding topographic slope source terms in X direction. __global__ void AddSlopeSourceXGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * zb) CUDA kernel for adding topographic slope source terms in X direction. __host__ void AddSlopeSourceYCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * zb) Host function for adding topographic slope source terms in Y direction. __global__ void AddSlopeSourceYGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * zb) CUDA kernel for adding topographic slope source terms in Y direction. __host__ __device__ T KurgSolver (T g, T delta, T epsi, T CFL, T cm, T fm, T hp, T hm, T up, T um, T &amp; fh, T &amp; fu) Kurganov-Petrova approximate Riemann solver for fluxes and time step. __host__ void updateKurgXATMCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb, T * Patm, T * dPdx) Host function for updating X-direction fluxes with atmospheric pressure effects. __global__ void updateKurgXATMGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb, T * Patm, T * dPdx) CUDA kernel for updating X-direction fluxes with atmospheric pressure effects. __host__ void updateKurgXCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) Host function for updating X-direction fluxes using the Kurganov scheme. __global__ void updateKurgXGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) CUDA kernel for updating X-direction fluxes using the Kurganov scheme. __host__ void updateKurgYATMCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb, T * Patm, T * dPdy) Host function for updating Y-direction fluxes with atmospheric pressure effects. __global__ void updateKurgYATMGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb, T * Patm, T * dPdy) CUDA kernel for updating Y-direction fluxes with atmospheric pressure effects. __host__ void updateKurgYCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) Host function for updating Y-direction fluxes using the Kurganov scheme. __global__ void updateKurgYGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) CUDA kernel for updating Y-direction fluxes using the Kurganov scheme."},{"location":"BGFlood/_kurganov_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_kurganov_8h/#function-addslopesourcexcpu","title":"function AddSlopeSourceXCPU","text":"<p>Host function for adding topographic slope source terms in X direction. </p><pre><code>template&lt;class T&gt;\n__host__ void AddSlopeSourceXCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * zb\n) \n</code></pre> <p>Updates fluxes with slope source terms for well-balanced solutions on CPU (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_kurganov_8h/#function-addslopesourcexgpu","title":"function AddSlopeSourceXGPU","text":"<p>CUDA kernel for adding topographic slope source terms in X direction. </p><pre><code>template&lt;class T&gt;\n__global__ void AddSlopeSourceXGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * zb\n) \n</code></pre> <p>Updates fluxes with slope source terms for well-balanced solutions (based on Kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_kurganov_8h/#function-addslopesourceycpu","title":"function AddSlopeSourceYCPU","text":"<p>Host function for adding topographic slope source terms in Y direction. </p><pre><code>template&lt;class T&gt;\n__host__ void AddSlopeSourceYCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * zb\n) \n</code></pre> <p>Updates fluxes with slope source terms for well-balanced solutions in Y direction on CPU (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_kurganov_8h/#function-addslopesourceygpu","title":"function AddSlopeSourceYGPU","text":"<p>CUDA kernel for adding topographic slope source terms in Y direction. </p><pre><code>template&lt;class T&gt;\n__global__ void AddSlopeSourceYGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * zb\n) \n</code></pre> <p>Updates fluxes with slope source terms for well-balanced solutions in Y direction (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_kurganov_8h/#function-kurgsolver","title":"function KurgSolver","text":"<p>Kurganov-Petrova approximate Riemann solver for fluxes and time step. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T KurgSolver (\n    T g,\n    T delta,\n    T epsi,\n    T CFL,\n    T cm,\n    T fm,\n    T hp,\n    T hm,\n    T up,\n    T um,\n    T &amp; fh,\n    T &amp; fu\n) \n</code></pre> <p>Computes fluxes and time step for the Kurganov scheme given left/right states and velocities (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>g</code> Gravity </li> <li><code>delta</code> Cell size </li> <li><code>epsi</code> Small epsilon for stability </li> <li><code>CFL</code> CFL number </li> <li><code>cm</code> Metric coefficient </li> <li><code>fm</code> Flux metric </li> <li><code>hp</code> Water depth (plus side) </li> <li><code>hm</code> Water depth (minus side) </li> <li><code>up</code> Velocity (plus side) </li> <li><code>um</code> Velocity (minus side) </li> <li><code>fh</code> Output: flux for h </li> <li><code>fu</code> Output: flux for u </li> </ul> <p>Returns:</p> <p>Time step </p>"},{"location":"BGFlood/_kurganov_8h/#function-updatekurgxatmcpu","title":"function updateKurgXATMCPU","text":"<p>Host function for updating X-direction fluxes with atmospheric pressure effects. </p><pre><code>template&lt;class T&gt;\n__host__ void updateKurgXATMCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb,\n    T * Patm,\n    T * dPdx\n) \n</code></pre> <p>Computes fluxes and time step constraints for each cell in the X direction on CPU, including atmospheric pressure terms (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>dtmax</code> Maximum time step array </li> <li><code>zb</code> Bathymetry array </li> <li><code>Patm</code> Atmospheric pressure array </li> <li><code>dPdx</code> Pressure gradient array </li> </ul>"},{"location":"BGFlood/_kurganov_8h/#function-updatekurgxatmgpu","title":"function updateKurgXATMGPU","text":"<p>CUDA kernel for updating X-direction fluxes with atmospheric pressure effects. </p><pre><code>template&lt;class T&gt;\n__global__ void updateKurgXATMGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb,\n    T * Patm,\n    T * dPdx\n) \n</code></pre> <p>Computes fluxes and time step constraints for each cell in the X direction, including atmospheric pressure terms (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>dtmax</code> Maximum time step array </li> <li><code>zb</code> Bathymetry array </li> <li><code>Patm</code> Atmospheric pressure array </li> <li><code>dPdx</code> Pressure gradient array </li> </ul>"},{"location":"BGFlood/_kurganov_8h/#function-updatekurgxcpu","title":"function updateKurgXCPU","text":"<p>Host function for updating X-direction fluxes using the Kurganov scheme. </p><pre><code>template&lt;class T&gt;\n__host__ void updateKurgXCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre> <p>Computes fluxes and time step constraints for each cell in the X direction on CPU (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>dtmax</code> Maximum time step array </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_kurganov_8h/#function-updatekurgxgpu","title":"function updateKurgXGPU","text":"<p>CUDA kernel for updating X-direction fluxes using the Kurganov scheme. </p><pre><code>template&lt;class T&gt;\n__global__ void updateKurgXGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre> <p>Computes fluxes and time step constraints for each cell in the X direction (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>dtmax</code> Maximum time step array </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_kurganov_8h/#function-updatekurgyatmcpu","title":"function updateKurgYATMCPU","text":"<p>Host function for updating Y-direction fluxes with atmospheric pressure effects. </p><pre><code>template&lt;class T&gt;\n__host__ void updateKurgYATMCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb,\n    T * Patm,\n    T * dPdy\n) \n</code></pre> <p>Computes fluxes and time step constraints for each cell in the Y direction on CPU, including atmospheric pressure terms (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>dtmax</code> Maximum time step array </li> <li><code>zb</code> Bathymetry array </li> <li><code>Patm</code> Atmospheric pressure array </li> <li><code>dPdy</code> Pressure gradient array </li> </ul>"},{"location":"BGFlood/_kurganov_8h/#function-updatekurgyatmgpu","title":"function updateKurgYATMGPU","text":"<p>CUDA kernel for updating Y-direction fluxes with atmospheric pressure effects. </p><pre><code>template&lt;class T&gt;\n__global__ void updateKurgYATMGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb,\n    T * Patm,\n    T * dPdy\n) \n</code></pre> <p>Computes fluxes and time step constraints for each cell in the Y direction, including atmospheric pressure terms (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>dtmax</code> Maximum time step array </li> <li><code>zb</code> Bathymetry array </li> <li><code>Patm</code> Atmospheric pressure array </li> <li><code>dPdy</code> Pressure gradient array </li> </ul>"},{"location":"BGFlood/_kurganov_8h/#function-updatekurgycpu","title":"function updateKurgYCPU","text":"<p>Host function for updating Y-direction fluxes using the Kurganov scheme. </p><pre><code>template&lt;class T&gt;\n__host__ void updateKurgYCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre> <p>Computes fluxes and time step constraints for each cell in the Y direction on CPU (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>dtmax</code> Maximum time step array </li> <li><code>zb</code> Bathymetry array </li> </ul>"},{"location":"BGFlood/_kurganov_8h/#function-updatekurgygpu","title":"function updateKurgYGPU","text":"<p>CUDA kernel for updating Y-direction fluxes using the Kurganov scheme. </p><pre><code>template&lt;class T&gt;\n__global__ void updateKurgYGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre> <p>Computes fluxes and time step constraints for each cell in the Y direction (based on kurganov and Petrova 2007).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XBlock</code> Block parameters </li> <li><code>XEv</code> Evolving variables </li> <li><code>XGrad</code> Gradients </li> <li><code>XFlux</code> Fluxes </li> <li><code>dtmax</code> Maximum time step array </li> <li><code>zb</code> Bathymetry array </li> </ul> <p>The documentation for this class was generated from the following file <code>src/Kurganov.h</code></p>"},{"location":"BGFlood/_kurganov_8h_source/","title":"File Kurganov.h","text":""},{"location":"BGFlood/_kurganov_8h_source/#file-kurganovh","title":"File Kurganov.h","text":"<p>File List &gt; src &gt; Kurganov.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef KURGANOV_H\n#define KURGANOV_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"Util_CPU.h\"\n#include \"Spherical.h\"\n\ntemplate &lt;class T&gt; __global__ void updateKurgXGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __global__ void AddSlopeSourceXGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* zb);\n\ntemplate &lt;class T&gt; __host__ void updateKurgXCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __host__ void AddSlopeSourceXCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* zb);\n\n\ntemplate &lt;class T&gt; __global__ void updateKurgYGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __global__ void AddSlopeSourceYGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* zb);\n\ntemplate &lt;class T&gt; __host__ void updateKurgYCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __host__ void AddSlopeSourceYCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* zb);\n\ntemplate &lt;class T&gt; __global__ void updateKurgXATMGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb, T* Patm, T* dPdx);\ntemplate &lt;class T&gt; __host__ void updateKurgXATMCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb, T* Patm, T* dPdx);\n\ntemplate &lt;class T&gt; __global__ void updateKurgYATMGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb, T* Patm, T* dPdy);\ntemplate &lt;class T&gt; __host__ void updateKurgYATMCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb, T* Patm, T* dPdy);\n\n\ntemplate &lt;class T&gt; __host__ __device__ T KurgSolver(T g, T delta, T epsi, T CFL, T cm, T fm, T hp, T hm, T up, T um, T&amp; fh, T&amp; fu);\n\n#endif\n</code></pre>"},{"location":"BGFlood/_mainloop_8cu/","title":"File Mainloop.cu","text":""},{"location":"BGFlood/_mainloop_8cu/#file-mainloopcu","title":"File Mainloop.cu","text":"<p>FileList &gt; src &gt; Mainloop.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Mainloop.h\"</code></li> </ul>"},{"location":"BGFlood/_mainloop_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ void CalcInitdtCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEvolv, T * dtmax) Calculate initial time step values on the CPU for all blocks and nodes. __global__ void CalcInitdtGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEvolv, T * dtmax) CUDA kernel to calculate initial time step values on the GPU for all blocks and nodes. void CrashDetection (Param &amp; XParam, Loop&lt; T &gt; XLoop, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Detects simulation crash due to small time steps and generates a crash report. void DebugLoop (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; &amp; XModel, Model&lt; T &gt; &amp; XModel_g) Debugging loop for the flood model. template void DebugLoop&lt; double &gt; (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; &amp; XModel, Model&lt; double &gt; &amp; XModel_g)  template void DebugLoop&lt; float &gt; (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; &amp; XModel, Model&lt; float &gt; &amp; XModel_g)  Loop&lt; T &gt; InitLoop (Param &amp; XParam, Model&lt; T &gt; &amp; XModel) Initialize the simulation loop structure. void MainLoop (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; &amp; XModel, Model&lt; T &gt; &amp; XModel_g) Main simulation loop for the flood model. template void MainLoop&lt; double &gt; (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; &amp; XModel, Model&lt; double &gt; &amp; XModel_g)  template void MainLoop&lt; float &gt; (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; &amp; XModel, Model&lt; float &gt; &amp; XModel_g)  __host__ double initdt (Param XParam, Loop&lt; T &gt; XLoop, Model&lt; T &gt; XModel) Initialize the simulation time step. template __host__ double initdt&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, Model&lt; double &gt; XModel)  template __host__ double initdt&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, Model&lt; float &gt; XModel)  void mapoutput (Param XParam, Loop&lt; T &gt; &amp; XLoop, Model&lt; T &gt; &amp; XModel, Model&lt; T &gt; XModel_g) Output map data at specified simulation times. void pointoutputstep (Param XParam, Loop&lt; T &gt; &amp; XLoop, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Output time series data for specified nodes. void printstatus (T totaltime, T dt) Print the current simulation time and time step to the console. __global__ void storeTSout (Param XParam, int noutnodes, int outnode, int istep, int blknode, int inode, int jnode, int * blkTS, EvolvingP&lt; T &gt; XEv, T * store) CUDA kernel to store time series output for specified nodes. void updateBnd (Param XParam, Loop&lt; T &gt; XLoop, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Update boundary conditions for the simulation."},{"location":"BGFlood/_mainloop_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_mainloop_8cu/#function-calcinitdtcpu","title":"function CalcInitdtCPU","text":"<p>Calculate initial time step values on the CPU for all blocks and nodes. </p><pre><code>template&lt;class T&gt;\n__host__ void CalcInitdtCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEvolv,\n    T * dtmax\n) \n</code></pre> <p>Computes the maximum allowable time step for each cell based on local water depth and cell resolution.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>XEvolv</code> Evolving state variables </li> <li><code>dtmax</code> Output array for maximum time step per cell </li> </ul>"},{"location":"BGFlood/_mainloop_8cu/#function-calcinitdtgpu","title":"function CalcInitdtGPU","text":"<p>CUDA kernel to calculate initial time step values on the GPU for all blocks and nodes. </p><pre><code>template&lt;class T&gt;\n__global__ void CalcInitdtGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEvolv,\n    T * dtmax\n) \n</code></pre> <p>Computes the maximum allowable time step for each cell using GPU parallelism.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>XEvolv</code> Evolving state variables </li> <li><code>dtmax</code> Output array for maximum time step per cell </li> </ul>"},{"location":"BGFlood/_mainloop_8cu/#function-crashdetection","title":"function CrashDetection","text":"<p>Detects simulation crash due to small time steps and generates a crash report. </p><pre><code>template&lt;class T&gt;\nvoid CrashDetection (\n    Param &amp; XParam,\n    Loop &lt; T &gt; XLoop,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>If the time step falls below the minimum allowed value before the simulation end time, stops the model and writes output variables to a crash report file. Handles both CPU and GPU data transfer for output variables.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters (may be modified) </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XModel</code> Model state (CPU) </li> <li><code>XModel_g</code> Model state (GPU) </li> </ul>"},{"location":"BGFlood/_mainloop_8cu/#function-debugloop","title":"function DebugLoop","text":"<p>Debugging loop for the flood model. </p><pre><code>template&lt;class T&gt;\nvoid DebugLoop (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; &amp; XModel,\n    Model &lt; T &gt; &amp; XModel_g\n) \n</code></pre> <p>Used to debug and wrap the debug flow engine. Runs a fixed number of steps and outputs diagnostic information. Handles both CPU and GPU execution paths.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data (float) </li> <li><code>XModel</code> Model state (CPU) </li> <li><code>XModel_g</code> Model state (GPU) </li> </ul>"},{"location":"BGFlood/_mainloop_8cu/#function-debugloop-double","title":"function DebugLoop&lt; double &gt;","text":"<pre><code>template void DebugLoop&lt; double &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; &amp; XModel,\n    Model &lt; double &gt; &amp; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_mainloop_8cu/#function-debugloop-float","title":"function DebugLoop&lt; float &gt;","text":"<pre><code>template void DebugLoop&lt; float &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; &amp; XModel,\n    Model &lt; float &gt; &amp; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_mainloop_8cu/#function-initloop","title":"function InitLoop","text":"<p>Initialize the simulation loop structure. </p><pre><code>template&lt;class T&gt;\nLoop &lt; T &gt; InitLoop (\n    Param &amp; XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Sets up loop control variables, output buffers, and initial time step.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model state </li> </ul> <p>Returns:</p> <p>Initialized loop control structure </p>"},{"location":"BGFlood/_mainloop_8cu/#function-mainloop","title":"function MainLoop","text":"<p>Main simulation loop for the flood model. </p><pre><code>template&lt;class T&gt;\nvoid MainLoop (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; &amp; XModel,\n    Model &lt; T &gt; &amp; XModel_g\n) \n</code></pre> <p>Advances the simulation in time, applying boundary conditions, forcing, core engine, output, and crash detection. Handles both CPU and GPU execution paths.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data (float) </li> <li><code>XModel</code> Model state (CPU) </li> <li><code>XModel_g</code> Model state (GPU) </li> </ul>"},{"location":"BGFlood/_mainloop_8cu/#function-mainloop-double","title":"function MainLoop&lt; double &gt;","text":"<pre><code>template void MainLoop&lt; double &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; &amp; XModel,\n    Model &lt; double &gt; &amp; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_mainloop_8cu/#function-mainloop-float","title":"function MainLoop&lt; float &gt;","text":"<pre><code>template void MainLoop&lt; float &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; &amp; XModel,\n    Model &lt; float &gt; &amp; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_mainloop_8cu/#function-initdt","title":"function initdt","text":"<p>Initialize the simulation time step. </p><pre><code>template&lt;class T&gt;\n__host__ double initdt (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Calculates the initial time step based on user input or model parameters. Uses either a user-specified value or computes a safe initial value based on water depth and cell resolution.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XModel</code> Model state </li> </ul> <p>Returns:</p> <p>Initial time step value </p>"},{"location":"BGFlood/_mainloop_8cu/#function-initdt-double","title":"function initdt&lt; double &gt;","text":"<pre><code>template __host__ double initdt&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_mainloop_8cu/#function-initdt-float","title":"function initdt&lt; float &gt;","text":"<pre><code>template __host__ double initdt&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_mainloop_8cu/#function-mapoutput","title":"function mapoutput","text":"<p>Output map data at specified simulation times. </p><pre><code>template&lt;class T&gt;\nvoid mapoutput (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Model &lt; T &gt; &amp; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Saves model state to NetCDF files when output times are reached, handling both CPU and GPU data transfer.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XModel</code> Model state (CPU) </li> <li><code>XModel_g</code> Model state (GPU) </li> </ul>"},{"location":"BGFlood/_mainloop_8cu/#function-pointoutputstep","title":"function pointoutputstep","text":"<p>Output time series data for specified nodes. </p><pre><code>template&lt;class T&gt;\nvoid pointoutputstep (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Collects and writes time series output for selected nodes, handling both CPU and GPU data paths and buffer management.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XModel</code> Model state (CPU) </li> <li><code>XModel_g</code> Model state (GPU) </li> </ul>"},{"location":"BGFlood/_mainloop_8cu/#function-printstatus","title":"function printstatus","text":"<p>Print the current simulation time and time step to the console. </p><pre><code>template&lt;class T&gt;\nvoid printstatus (\n    T totaltime,\n    T dt\n) \n</code></pre> <p>Displays the total simulation time and current time step in a formatted manner.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>totaltime</code> Current simulation time </li> <li><code>dt</code> Current time step </li> </ul>"},{"location":"BGFlood/_mainloop_8cu/#function-storetsout","title":"function storeTSout","text":"<p>CUDA kernel to store time series output for specified nodes. </p><pre><code>template&lt;class T&gt;\n__global__ void storeTSout (\n    Param XParam,\n    int noutnodes,\n    int outnode,\n    int istep,\n    int blknode,\n    int inode,\n    int jnode,\n    int * blkTS,\n    EvolvingP &lt; T &gt; XEv,\n    T * store\n) \n</code></pre> <p>Writes evolving variables for selected nodes and time steps to output storage array.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>noutnodes</code> Number of output nodes </li> <li><code>outnode</code> Output node index </li> <li><code>istep</code> Time step index </li> <li><code>blknode</code> Block index </li> <li><code>inode</code> Node i-index </li> <li><code>jnode</code> Node j-index </li> <li><code>blkTS</code> Block time series mapping </li> <li><code>XEv</code> Evolving state variables </li> <li><code>store</code> Output storage array </li> </ul>"},{"location":"BGFlood/_mainloop_8cu/#function-updatebnd","title":"function updateBnd","text":"<p>Update boundary conditions for the simulation. </p><pre><code>template&lt;class T&gt;\nvoid updateBnd (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Applies boundary flows for each segment, handling both CPU and GPU execution paths.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XForcing</code> Forcing data (float) </li> <li><code>XModel</code> Model state (CPU) </li> <li><code>XModel_g</code> Model state (GPU) </li> </ul> <p>The documentation for this class was generated from the following file <code>src/Mainloop.cu</code></p>"},{"location":"BGFlood/_mainloop_8cu_source/","title":"File Mainloop.cu","text":""},{"location":"BGFlood/_mainloop_8cu_source/#file-mainloopcu","title":"File Mainloop.cu","text":"<p>File List &gt; src &gt; Mainloop.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Mainloop.h\"\n\n\n\ntemplate &lt;class T&gt; void MainLoop(Param &amp;XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel, Model&lt;T&gt; &amp;XModel_g)\n{\n\n    log(\"Initialising model main loop\");\n\n    Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n\n    //Define some useful variables \n    Initmeanmax(XParam, XLoop, XModel, XModel_g);\n\n    // Check for map output (output initialisation if needed)\n    mapoutput(XParam, XLoop, XModel, XModel_g);\n\n    log(\"\\t\\tCompleted\");\n    log(\"Model Running...\");\n\n    while (XLoop.totaltime &lt; XParam.endtime)\n    {\n        // Bnd stuff here\n        //updateBnd(XParam, XLoop, XForcing, XModel, XModel_g);\n\n\n        // Calculate dynamic forcing at this step\n        updateforcing(XParam, XLoop, XForcing);\n\n        // Core engine\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            if (XParam.engine == 5)\n            {\n                FlowMLGPU(XParam, XLoop, XForcing, XModel_g);\n            }\n            else\n            {\n                FlowGPU(XParam, XLoop, XForcing, XModel_g);\n            }\n        }\n        else\n        {\n            FlowCPU(XParam, XLoop, XForcing, XModel);\n        }\n\n\n        // Time keeping\n        XLoop.totaltime = XLoop.totaltime + XLoop.dt;\n        //log(\"timestep = \" + std::to_string(XLoop.totaltime));\n\n        // Detected if the model crashed\n        CrashDetection(XParam, XLoop, XModel, XModel_g);\n\n        // Apply tsunami deformation if any (this needs to happen after totaltime has been incremented)\n        deformstep(XParam, XLoop, XForcing.deform, XModel, XModel_g);\n\n        // Do Sum &amp; Max variables Here\n        Calcmeanmax(XParam, XLoop, XModel, XModel_g);\n\n        // Check &amp; collect TSoutput\n        pointoutputstep(XParam, XLoop, XModel, XModel_g);\n\n        // Check for map output\n        mapoutput(XParam, XLoop, XModel, XModel_g);\n\n        // Reset mean/Max if needed\n        resetmeanmax(XParam, XLoop, XModel, XModel_g);\n\n\n\n\n        printstatus(XLoop.totaltime, XLoop.dt);\n    }\n\n\n\n\n}\ntemplate void MainLoop&lt;float&gt;(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;float&gt;&amp; XModel, Model&lt;float&gt;&amp; XModel_g);\ntemplate void MainLoop&lt;double&gt;(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;double&gt;&amp; XModel, Model&lt;double&gt;&amp; XModel_g);\n\n\n\ntemplate &lt;class T&gt; void DebugLoop(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel, Model&lt;T&gt;&amp; XModel_g)\n{\n\n    log(\"Initialising model main loop\");\n\n    Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n\n    //Define some useful variables \n    Initmeanmax(XParam, XLoop, XModel, XModel_g);\n\n    // fill halo for zb\n    // only need to do that once \n    fillHaloC(XParam, XModel.blocks, XModel.zb);\n    gradientC(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    gradientHalo(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        dim3 blockDim(16, 16, 1);\n        dim3 gridDim(XParam.nblk, 1, 1);\n        CUDA_CHECK(cudaStreamCreate(&amp;XLoop.streams[0]));\n        fillHaloGPU(XParam, XModel_g.blocks, XLoop.streams[0], XModel_g.zb);\n        cudaStreamDestroy(XLoop.streams[0]);\n\n        gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XModel_g.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel_g.zb, XModel_g.grad.dzbdx, XModel_g.grad.dzbdy);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        gradientHaloGPU(XParam, XModel_g.blocks, XModel_g.zb, XModel_g.grad.dzbdx, XModel_g.grad.dzbdy);\n\n    }\n\n\n\n    log(\"\\t\\tCompleted\");\n    log(\"Model Running...\");\n    while (XLoop.nstep &lt; 100)\n    {\n        // Bnd stuff here\n        updateBnd(XParam, XLoop, XForcing, XModel, XModel_g);\n\n\n        // Calculate Forcing at this step\n        updateforcing(XParam, XLoop, XForcing);\n\n        // Core engine\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            //HalfStepGPU(XParam, XLoop, XForcing, XModel_g);\n        }\n        else\n        {\n            HalfStepCPU(XParam, XLoop, XForcing, XModel);\n        }\n\n        // Time keeping\n        XLoop.totaltime = XLoop.totaltime + XLoop.dt;\n\n        // Force output at every step\n        XLoop.nextoutputtime = XLoop.totaltime;\n\n        // Apply tsunami deformation if any (this needs to happen after totaltime has been incremented)\n        deformstep(XParam, XLoop, XForcing.deform, XModel, XModel_g);\n\n        // Do Sum &amp; Max variables Here\n        Calcmeanmax(XParam, XLoop, XModel, XModel_g);\n\n        // Check &amp; collect TSoutput\n        pointoutputstep(XParam, XLoop, XModel, XModel_g);\n\n        // Check for map output\n        mapoutput(XParam, XLoop, XModel, XModel_g);\n\n        // Reset mean/Max if needed\n        resetmeanmax(XParam, XLoop, XModel, XModel_g);\n\n        printstatus(XLoop.totaltime, XLoop.dt);\n        XLoop.nstep++;\n    }\n\n\n\n\n}\ntemplate void DebugLoop&lt;float&gt;(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;float&gt;&amp; XModel, Model&lt;float&gt;&amp; XModel_g);\ntemplate void DebugLoop&lt;double&gt;(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;double&gt;&amp; XModel, Model&lt;double&gt;&amp; XModel_g);\n\n\n\n\ntemplate &lt;class T&gt; Loop&lt;T&gt; InitLoop(Param &amp;XParam, Model&lt;T&gt; &amp;XModel)\n{\n    Loop&lt;T&gt; XLoop;\n    XLoop.atmpuni = T(XParam.Paref);\n    XLoop.totaltime = XParam.totaltime;\n    XLoop.nextoutputtime = XModel.OutputT[0];\n\n    // Prepare output files\n    InitSave2Netcdf(XParam, XModel);\n    InitTSOutput(XParam);\n    // Add empty row for each output point\n    // This will allow for the loop to each point to work later\n    for (int o = 0; o &lt; XParam.TSnodesout.size(); o++)\n    {\n        XLoop.TSAllout.push_back(std::vector&lt;Pointout&gt;());\n    }\n\n    // GPU stuff\n    //if (XParam.GPUDEVICE &gt;= 0)\n    //{\n        //XLoop.blockDim = (16, 16, 1);\n        //XLoop.gridDim = (XParam.nblk, 1, 1);\n    //}\n\n    //XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.hugenegval = T(-1.0)* XLoop.hugeposval;\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n\n    XLoop.dtmax = initdt(XParam, XLoop, XModel);\n    //XLoop.dtmin = XLoop.dtmax;\n\n    return XLoop;\n\n}\n\ntemplate &lt;class T&gt; void updateBnd(Param XParam, Loop&lt;T&gt; XLoop, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    for (int ibndseg = 0; ibndseg &lt; XForcing.bndseg.size(); ibndseg++)\n    {\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n\n\n            Flowbnd(XParam, XLoop, XModel_g.blocks, XForcing.left, XForcing.Atmp, XModel_g.evolv);\n            Flowbnd(XParam, XLoop, XModel_g.blocks, XForcing.right, XForcing.Atmp, XModel_g.evolv);\n            Flowbnd(XParam, XLoop, XModel_g.blocks, XForcing.top, XForcing.Atmp, XModel_g.evolv);\n            Flowbnd(XParam, XLoop, XModel_g.blocks, XForcing.bot, XForcing.Atmp, XModel_g.evolv);\n\n        }\n        else\n        {\n            Flowbnd(XParam, XLoop, XModel.blocks, XForcing.left, XForcing.Atmp, XModel.evolv);\n            Flowbnd(XParam, XLoop, XModel.blocks, XForcing.right, XForcing.Atmp, XModel.evolv);\n            Flowbnd(XParam, XLoop, XModel.blocks, XForcing.top, XForcing.Atmp, XModel.evolv);\n            Flowbnd(XParam, XLoop, XModel.blocks, XForcing.bot, XForcing.Atmp, XModel.evolv);\n        }\n    }\n}\n\n\n\n\ntemplate &lt;class T&gt; void mapoutput(Param XParam, Loop&lt;T&gt; &amp;XLoop, Model&lt;T&gt;&amp; XModel, Model&lt;T&gt; XModel_g)\n{\n    XLoop.nstepout++;\n    double tiny = 0.0000001;\n    /*\n    if  (abs(XLoop.nextoutputtime - XParam.totaltime) &lt; tiny)\n    {\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n            {\n                CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[XParam.outvars[ivar]], XModel_g.OutputVarMap[XParam.outvars[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n            }\n        }\n\n        SaveInitialisation2Netcdf(XParam, XModel);\n\n        XLoop.indNextoutputtime++;\n        if (XLoop.indNextoutputtime &lt; XModel.OutputT.size())\n        {\n            XLoop.nextoutputtime = min(XModel.OutputT[XLoop.indNextoutputtime], XParam.endtime);\n\n        }\n\n        XLoop.nstepout = 0;\n\n    }\n    */\n    if (XLoop.nextoutputtime - XLoop.totaltime &lt;= XLoop.dt * tiny)\n    {\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n            {\n                CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[XParam.outvars[ivar]], XModel_g.OutputVarMap[XParam.outvars[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n            }\n        }\n\n        Save2Netcdf(XParam, XLoop, XModel);\n\n        XLoop.indNextoutputtime++;\n        if (XLoop.indNextoutputtime &lt; XModel.OutputT.size())\n        {\n            XLoop.nextoutputtime = min(XModel.OutputT[XLoop.indNextoutputtime], XParam.endtime);\n\n        }\n\n        XLoop.nstepout = 0;\n    }\n\n\n}\n\ntemplate &lt;class T&gt; void pointoutputstep(Param XParam, Loop&lt;T&gt; &amp;XLoop, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    //\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XModel.bndblk.nblkTs, 1, 1);\n    FILE* fsSLTS;\n    if (XParam.GPUDEVICE&gt;=0)\n    {\n\n        for (int o = 0; o &lt; XParam.TSnodesout.size(); o++)\n        {\n            //\n            Pointout stepread;\n\n            stepread.time = XLoop.totaltime;\n            stepread.zs = 0.0;// That is a bit useless\n            stepread.h = 0.0;\n            stepread.u = 0.0;\n            stepread.v = 0.0;\n            XLoop.TSAllout[o].push_back(stepread);\n\n\n            storeTSout &lt;&lt;&lt;gridDim, blockDim, 0 &gt;&gt;&gt; (XParam,(int)XParam.TSnodesout.size(), o, XLoop.nTSsteps, XParam.TSnodesout[o].block, XParam.TSnodesout[o].i, XParam.TSnodesout[o].j, XModel_g.bndblk.Tsout, XModel_g.evolv, XModel_g.TSstore);\n            CUDA_CHECK(cudaDeviceSynchronize());\n        }\n        //CUDA_CHECK(cudaDeviceSynchronize());\n    }\n    else\n    {\n        for (int o = 0; o &lt; XParam.TSnodesout.size(); o++)\n        {\n            //\n            Pointout stepread;\n\n            int i = memloc(XParam.halowidth, XParam.blkmemwidth, XParam.TSnodesout[o].i, XParam.TSnodesout[o].j, XParam.TSnodesout[o].block);\n\n            stepread.time = XLoop.totaltime;\n            stepread.zs = XModel.evolv.zs[i];\n            stepread.h = XModel.evolv.h[i];;\n            stepread.u = XModel.evolv.u[i];;\n            stepread.v = XModel.evolv.v[i];;\n            XLoop.TSAllout[o].push_back(stepread);\n\n        }\n    }\n    XLoop.nTSsteps++;\n\n    // if the buffer is full or if the model is complete\n    if ((XLoop.nTSsteps + 1) * XParam.TSnodesout.size() * 4 &gt; XParam.maxTSstorage || XParam.endtime - XLoop.totaltime &lt;= XLoop.dt * 0.00001f)\n    {\n\n        //Flush to disk\n        if (XParam.GPUDEVICE &gt;= 0 &amp;&amp; XParam.TSnodesout.size() &gt; 0)\n        {\n            CUDA_CHECK(cudaMemcpy(XModel.TSstore, XModel_g.TSstore, XParam.maxTSstorage * sizeof(T), cudaMemcpyDeviceToHost));\n            int oo;\n\n            for (int o = 0; o &lt; XParam.TSnodesout.size(); o++)\n            {\n                for (int istep = 0; istep &lt; XLoop.TSAllout[o].size(); istep++)\n                {\n                    oo = o * 4 + istep * int(XParam.TSnodesout.size()) * 4;\n                    //\n                    XLoop.TSAllout[o][istep].h = XModel.TSstore[0 + oo];\n                    XLoop.TSAllout[o][istep].zs = XModel.TSstore[1 + oo];\n                    XLoop.TSAllout[o][istep].u = XModel.TSstore[2 + oo];\n                    XLoop.TSAllout[o][istep].v = XModel.TSstore[3 + oo];\n                }\n            }\n\n        }\n        for (int o = 0; o &lt; XParam.TSnodesout.size(); o++)\n        {\n            fsSLTS = fopen(XParam.TSnodesout[o].outname.c_str(), \"a\");\n\n\n            for (int n = 0; n &lt; XLoop.nTSsteps; n++)\n            {\n                //\n\n\n                fprintf(fsSLTS, \"%f\\t%.4f\\t%.4f\\t%.4f\\t%.4f\\n\", XLoop.TSAllout[o][n].time, XLoop.TSAllout[o][n].zs, XLoop.TSAllout[o][n].h, XLoop.TSAllout[o][n].u, XLoop.TSAllout[o][n].v);\n\n\n            }\n            fclose(fsSLTS);\n            //reset output buffer\n            XLoop.TSAllout[o].clear();\n        }\n        // Reset buffer counter\n        XLoop.nTSsteps = 0;\n\n\n\n\n    }\n}\n\n\ntemplate &lt;class T&gt; __global__ void storeTSout(Param XParam,int noutnodes, int outnode, int istep,int blknode, int inode,int jnode, int * blkTS, EvolvingP&lt;T&gt; XEv, T* store)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = blkTS[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    //printf(\"ib=%d; ix=%d; iy=%d; blknode=%d; inode=%d; jnode=%d\\n\", ib, ix,iy,blknode,inode,jnode);\n\n    if (ib == blknode &amp;&amp; ix == inode &amp;&amp; iy == jnode)\n    {\n        store[0 + outnode * 4 + istep * noutnodes * 4] = XEv.h[i];\n        store[1 + outnode * 4 + istep * noutnodes * 4] = XEv.zs[i];\n        store[2 + outnode * 4 + istep * noutnodes * 4] = XEv.u[i];\n        store[3 + outnode * 4 + istep * noutnodes * 4] = XEv.v[i];\n\n\n\n        //printf(\"XEv.h[i]=%f; store[h]=%f\\n\", XEv.h[i], store[0 + outnode * 4 + istep * noutnodes * 4]);\n    }\n}\n\n\ntemplate &lt;class T&gt; __host__ double initdt(Param XParam, Loop&lt;T&gt; XLoop, Model&lt;T&gt; XModel)\n{\n    //dim3 blockDim = (XParam.blkwidth, XParam.blkwidth, 1);\n    //dim3 gridDim = (XParam.nblk, 1, 1);\n\n    double initdt;\n\n    XLoop.dtmax = XLoop.hugeposval;\n\n    //to limit the initial time steps (by user input)\n    if (XParam.dtinit &gt; 0)\n    {\n        XLoop.dtmax = XParam.dtinit / 1.5;\n    }\n    else\n    {\n        // WARNING here we specify at least an initial time step if there was 10.0m of water at the highest resolution cell.\n        // The modle will recalculate the optimal dt in subsequent step;\n        XLoop.dtmax = calcres(XParam.delta, XParam.maxlevel) / (sqrt(XParam.g * 10.0));\n    }\n\n    //BlockP&lt;T&gt; XBlock = XModel.blocks;\n\n    /*\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        CalcInitdtGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, XModel.evolv, XModel.time.dtmax);\n        initdt = double(CalctimestepGPU(XParam, XLoop, XModel.blocks, XModel.time));\n    }\n    else\n    {\n    */\n        CalcInitdtCPU(XParam, XModel.blocks, XModel.evolv, XModel.time.dtmax);\n        initdt = double(CalctimestepCPU(XParam, XLoop, XModel.blocks, XModel.time));\n\n    //}\n\n\n    return initdt;\n}\ntemplate __host__ double initdt&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, Model&lt;float&gt; XModel);\ntemplate __host__ double initdt&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, Model&lt;double&gt; XModel);\n\ntemplate &lt;class T&gt; __host__ void CalcInitdtCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEvolv, T* dtmax)\n{\n    int ib;\n    T delta;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        delta = calcres(T(XParam.delta), XBlock.level[ib]);\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                dtmax[i] = delta / sqrt(T(XParam.g) * std::max(XEvolv.h[i],T(XParam.eps)));\n            }\n        }\n    }\n}\n\ntemplate &lt;class T&gt; __global__ void CalcInitdtGPU(Param XParam, BlockP&lt;T&gt; XBlock,EvolvingP&lt;T&gt; XEvolv, T* dtmax)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    T delta = calcres(XParam.delta, XBlock.level[ib]);\n\n    dtmax[i] = delta / sqrt(XParam.g * max(XEvolv.h[i],T(XParam.eps)));\n}\n\n\ntemplate &lt;class T&gt; void printstatus(T totaltime, T dt)\n{\n    std::cout &lt;&lt; \"\\r\\e[K\" &lt;&lt; std::flush;\n    std::cout &lt;&lt; \"\\rtotaltime = \"&lt;&lt; std::to_string(totaltime) &lt;&lt; \"   dt = \" &lt;&lt; std::to_string(dt) &lt;&lt; std::flush;\n    std::cout &lt;&lt; \"\\r\" &lt;&lt; std::flush;\n    //std::cout &lt;&lt; std::endl; // all done\n}\n\ntemplate &lt;class T&gt; void CrashDetection(Param&amp; XParam, Loop&lt;T&gt; XLoop, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    if ((XLoop.dt &lt; XParam.dtmin) &amp;&amp; (XLoop.totaltime &lt; XParam.endtime))\n    {\n        // stop the model\n        XParam.endtime = XLoop.totaltime;\n        XLoop.nextoutputtime = XLoop.totaltime;\n\n        log(\" \\n \");\n        log(\"\\t\\tModel CRASHED: time steps (\" + std::to_string(XLoop.dt) + \") inferior to \" + std::to_string(XParam.dtmin) + \"\\n\");\n\n        std::vector&lt;std::string&gt; outvi = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"ho\",\"vo\",\"uo\",\"zso\" };\n        std::vector&lt;std::string&gt; outvold = XParam.outvars;\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            for (int ivar = 0; ivar &lt; outvi.size(); ivar++)\n            {\n                CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[outvi[ivar]], XModel_g.OutputVarMap[outvi[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n            }\n        }\n        std::vector&lt;std::string&gt; extvec = split(XModel.blocks.outZone[0].outname, '.');\n        std::string newname, oldname;\n\n        oldname = XParam.outfile;\n\n        newname = extvec[0];\n        for (int nstin = 1; nstin &lt; extvec.size() - 1; nstin++)\n        {\n            // This is in case there are \".\" in the file name that do not relate to the file extension\"\n            newname = newname + \".\" + extvec[nstin];\n        }\n        newname = newname + \"_CrashReport.nc\";\n\n        //XParam.outfile = newname;\n        XParam.outvars = outvi;\n\n\n        outzoneB XzoneB;\n        std::vector&lt;int&gt; blksall;\n        //Define the full domain as a zone\n        XzoneB.outname = newname; //.assign(XParam.outfile);\n        XzoneB.xo = XParam.xo;\n        XzoneB.yo = XParam.yo;\n        XzoneB.xmax = XParam.xmax;\n        XzoneB.ymax = XParam.ymax;\n        XzoneB.nblk = XParam.nblk;\n        XzoneB.maxlevel = XParam.maxlevel;\n        XzoneB.minlevel = XParam.minlevel;\n        AllocateCPU(XParam.nblk, 1, XzoneB.blk);\n        int I = 0;\n        for (int ib = 0; ib &lt; XParam.nblk; ib++)\n        {\n            XzoneB.blk[ib] = XModel.blocks.active[ib];\n        }\n        //InitSave2Netcdf(XParam, XModel);\n        creatncfileBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, XzoneB);\n        writenctimestep(XzoneB.outname, XParam.totaltime);\n        for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n        {\n            defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, XParam.outvars[ivar], 3, XModel.OutputVarMap[XParam.outvars[ivar]], XzoneB);\n        }\n        XParam.outvars = outvold;\n        //XParam.outfile = oldname;\n\n\n\n    }\n    //double weight = 0.25;\n    //log(\"\\t\\tdt=\" + std::to_string(XLoop.dt) + \", dtmin=\" + std::to_string(XLoop.dtmin) + \"\\n\");\n    //XLoop.dtmin = weight * XLoop.dt + (1 - weight) * XLoop.dtmin;\n\n}\n</code></pre>"},{"location":"BGFlood/_mainloop_8h/","title":"File Mainloop.h","text":""},{"location":"BGFlood/_mainloop_8h/#file-mainlooph","title":"File Mainloop.h","text":"<p>FileList &gt; src &gt; Mainloop.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Mesh.h\"</code></li> <li><code>#include \"Write_netcdf.h\"</code></li> <li><code>#include \"InitialConditions.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Boundary.h\"</code></li> <li><code>#include \"FlowGPU.h\"</code></li> <li><code>#include \"FlowCPU.h\"</code></li> <li><code>#include \"Meanmax.h\"</code></li> <li><code>#include \"Updateforcing.h\"</code></li> <li><code>#include \"FlowMLGPU.h\"</code></li> </ul>"},{"location":"BGFlood/_mainloop_8h/#public-functions","title":"Public Functions","text":"Type Name void DebugLoop (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; &amp; XModel, Model&lt; T &gt; &amp; XModel_g) Debugging loop for the flood model. Loop&lt; T &gt; InitLoop (Param &amp; XParam, Model&lt; T &gt; &amp; XModel) Initialize the simulation loop structure. void MainLoop (Param &amp; XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; &amp; XModel, Model&lt; T &gt; &amp; XModel_g) Main simulation loop for the flood model. __host__ double initdt (Param XParam, Loop&lt; T &gt; XLoop, Model&lt; T &gt; XModel) Initialize the simulation time step. void printstatus (T totaltime, T dt) Print the current simulation time and time step to the console. __global__ void storeTSout (Param XParam, int noutnodes, int outnode, int istep, int blknode, int inode, int jnode, int * blkTS, EvolvingP&lt; T &gt; XEv, T * store) CUDA kernel to store time series output for specified nodes."},{"location":"BGFlood/_mainloop_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_mainloop_8h/#function-debugloop","title":"function DebugLoop","text":"<p>Debugging loop for the flood model. </p><pre><code>template&lt;class T&gt;\nvoid DebugLoop (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; &amp; XModel,\n    Model &lt; T &gt; &amp; XModel_g\n) \n</code></pre> <p>Used to debug and wrap the debug flow engine. Runs a fixed number of steps and outputs diagnostic information. Handles both CPU and GPU execution paths.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data (float) </li> <li><code>XModel</code> Model state (CPU) </li> <li><code>XModel_g</code> Model state (GPU) </li> </ul>"},{"location":"BGFlood/_mainloop_8h/#function-initloop","title":"function InitLoop","text":"<p>Initialize the simulation loop structure. </p><pre><code>template&lt;class T&gt;\nLoop &lt; T &gt; InitLoop (\n    Param &amp; XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Sets up loop control variables, output buffers, and initial time step.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model state </li> </ul> <p>Returns:</p> <p>Initialized loop control structure </p>"},{"location":"BGFlood/_mainloop_8h/#function-mainloop","title":"function MainLoop","text":"<p>Main simulation loop for the flood model. </p><pre><code>template&lt;class T&gt;\nvoid MainLoop (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; &amp; XModel,\n    Model &lt; T &gt; &amp; XModel_g\n) \n</code></pre> <p>Advances the simulation in time, applying boundary conditions, forcing, core engine, output, and crash detection. Handles both CPU and GPU execution paths.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data (float) </li> <li><code>XModel</code> Model state (CPU) </li> <li><code>XModel_g</code> Model state (GPU) </li> </ul>"},{"location":"BGFlood/_mainloop_8h/#function-initdt","title":"function initdt","text":"<p>Initialize the simulation time step. </p><pre><code>template&lt;class T&gt;\n__host__ double initdt (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Calculates the initial time step based on user input or model parameters. Uses either a user-specified value or computes a safe initial value based on water depth and cell resolution.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XModel</code> Model state </li> </ul> <p>Returns:</p> <p>Initial time step value </p>"},{"location":"BGFlood/_mainloop_8h/#function-printstatus","title":"function printstatus","text":"<p>Print the current simulation time and time step to the console. </p><pre><code>template&lt;class T&gt;\nvoid printstatus (\n    T totaltime,\n    T dt\n) \n</code></pre> <p>Displays the total simulation time and current time step in a formatted manner.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>totaltime</code> Current simulation time </li> <li><code>dt</code> Current time step </li> </ul>"},{"location":"BGFlood/_mainloop_8h/#function-storetsout","title":"function storeTSout","text":"<p>CUDA kernel to store time series output for specified nodes. </p><pre><code>template&lt;class T&gt;\n__global__ void storeTSout (\n    Param XParam,\n    int noutnodes,\n    int outnode,\n    int istep,\n    int blknode,\n    int inode,\n    int jnode,\n    int * blkTS,\n    EvolvingP &lt; T &gt; XEv,\n    T * store\n) \n</code></pre> <p>Writes evolving variables for selected nodes and time steps to output storage array.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>noutnodes</code> Number of output nodes </li> <li><code>outnode</code> Output node index </li> <li><code>istep</code> Time step index </li> <li><code>blknode</code> Block index </li> <li><code>inode</code> Node i-index </li> <li><code>jnode</code> Node j-index </li> <li><code>blkTS</code> Block time series mapping </li> <li><code>XEv</code> Evolving state variables </li> <li><code>store</code> Output storage array </li> </ul> <p>The documentation for this class was generated from the following file <code>src/Mainloop.h</code></p>"},{"location":"BGFlood/_mainloop_8h_source/","title":"File Mainloop.h","text":""},{"location":"BGFlood/_mainloop_8h_source/#file-mainlooph","title":"File Mainloop.h","text":"<p>File List &gt; src &gt; Mainloop.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef MAINLOOP_H\n#define MAINLOOP_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"Mesh.h\"\n#include \"Write_netcdf.h\"\n#include \"InitialConditions.h\"\n#include \"MemManagement.h\"\n#include \"Boundary.h\"\n#include \"FlowGPU.h\"\n#include \"FlowCPU.h\"\n#include \"Meanmax.h\"\n#include \"Updateforcing.h\"\n#include \"FlowMLGPU.h\"\n\ntemplate &lt;class T&gt; void MainLoop(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel, Model&lt;T&gt;&amp; XModel_g);\n\ntemplate &lt;class T&gt; void DebugLoop(Param&amp; XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt;&amp; XModel, Model&lt;T&gt;&amp; XModel_g);\n\ntemplate &lt;class T&gt; __host__ double initdt(Param XParam, Loop&lt;T&gt; XLoop, Model&lt;T&gt; XModel);\n\ntemplate &lt;class T&gt; Loop&lt;T&gt; InitLoop(Param&amp; XParam, Model&lt;T&gt;&amp; XModel);\n\ntemplate &lt;class T&gt; void printstatus(T totaltime, T dt);\n\n\ntemplate &lt;class T&gt; __global__ void storeTSout(Param XParam, int noutnodes, int outnode, int istep, int blknode, int inode, int jnode, int* blkTS, EvolvingP&lt;T&gt; XEv, T* store);\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_meanmax_8cu/","title":"File Meanmax.cu","text":""},{"location":"BGFlood/_meanmax_8cu/#file-meanmaxcu","title":"File Meanmax.cu","text":"<p>FileList &gt; src &gt; Meanmax.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Meanmax.h\"</code></li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#public-functions","title":"Public Functions","text":"Type Name void Calcmeanmax (Param XParam, Loop&lt; T &gt; &amp; XLoop, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Calculate mean and/or max of requested variables on GPU/CPU. template void Calcmeanmax&lt; double &gt; (Param XParam, Loop&lt; double &gt; &amp; XLoop, Model&lt; double &gt; XModel, Model&lt; double &gt; XModel_g)  template void Calcmeanmax&lt; float &gt; (Param XParam, Loop&lt; float &gt; &amp; XLoop, Model&lt; float &gt; XModel, Model&lt; float &gt; XModel_g)  void Initmeanmax (Param XParam, Loop&lt; T &gt; XLoop, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Initialize mean and max statistics at the start of the simulation. template void Initmeanmax&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, Model&lt; double &gt; XModel, Model&lt; double &gt; XModel_g)  template void Initmeanmax&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, Model&lt; float &gt; XModel, Model&lt; float &gt; XModel_g)  __host__ void addUandhU_CPU (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * u, T * v, T * U, T * hU) Compute velocity magnitude and hU product on the CPU. __global__ void addUandhU_GPU (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * u, T * v, T * U, T * hU) CUDA kernel to compute velocity magnitude and hU product. __host__ void addavg_varCPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmean, T * Var) Accumulate mean values for a variable on the CPU. __global__ void addavg_varGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmean, T * Var) CUDA kernel to accumulate mean values for a variable. __host__ void addwettime_CPU (Param XParam, BlockP&lt; T &gt; XBlock, T * wett, T * h, T thresold, T time) Accumulate wet duration for each cell on the CPU. __global__ void addwettime_GPU (Param XParam, BlockP&lt; T &gt; XBlock, T * wett, T * h, T thresold, T time) CUDA kernel to accumulate wet duration for each cell. __host__ void divavg_varCPU (Param XParam, BlockP&lt; T &gt; XBlock, T ntdiv, T * Varmean) Divide mean values by the number of steps on the CPU. __global__ void divavg_varGPU (Param XParam, BlockP&lt; T &gt; XBlock, T ntdiv, T * Varmean) CUDA kernel to divide mean values by the number of steps. __host__ void max_Norm_CPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * Var1, T * Var2) Compute max velocity magnitude on the CPU. __global__ void max_Norm_GPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * Var1, T * Var2) CUDA kernel to compute max velocity magnitude. __host__ void max_hU_CPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * h, T * u, T * v) Compute max hU value on the CPU. __global__ void max_hU_GPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * h, T * u, T * v) CUDA kernel to compute max hU value. __host__ void max_varCPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * Var) Compute max value for a variable on the CPU. __global__ void max_varGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * Var) CUDA kernel to compute max value for a variable. void resetmaxCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, EvolvingP_M&lt; T &gt; &amp; XEv) Reset max statistics arrays on the CPU. void resetmaxGPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, EvolvingP_M&lt; T &gt; &amp; XEv) Reset max statistics arrays on the GPU. void resetmeanCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, EvolvingP_M&lt; T &gt; &amp; XEv) Reset mean statistics arrays on the CPU. template void resetmeanCPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, EvolvingP_M&lt; double &gt; &amp; XEv)  template void resetmeanCPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, EvolvingP_M&lt; float &gt; &amp; XEv)  void resetmeanGPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, EvolvingP_M&lt; T &gt; &amp; XEv) Reset mean statistics arrays on the GPU. template void resetmeanGPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, EvolvingP_M&lt; double &gt; &amp; XEv)  template void resetmeanGPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, EvolvingP_M&lt; float &gt; &amp; XEv)  void resetmeanmax (Param XParam, Loop&lt; T &gt; &amp; XLoop, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Reset mean and/or max statistics at output steps. template void resetmeanmax&lt; double &gt; (Param XParam, Loop&lt; double &gt; &amp; XLoop, Model&lt; double &gt; XModel, Model&lt; double &gt; XModel_g)  template void resetmeanmax&lt; float &gt; (Param XParam, Loop&lt; float &gt; &amp; XLoop, Model&lt; float &gt; XModel, Model&lt; float &gt; XModel_g)  void resetvalCPU (Param XParam, BlockP&lt; T &gt; XBlock, T *&amp; var, T val) Reset a variable array to a specified value on the CPU. template void resetvalCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double *&amp; var, double val)  template void resetvalCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float *&amp; var, float val)  void resetvalGPU (Param XParam, BlockP&lt; T &gt; XBlock, T *&amp; var, T val) Reset a variable array to a specified value on the GPU. template void resetvalGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double *&amp; var, double val)  template void resetvalGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float *&amp; var, float val)"},{"location":"BGFlood/_meanmax_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_meanmax_8cu/#function-calcmeanmax","title":"function Calcmeanmax","text":"<p>Calculate mean and/or max of requested variables on GPU/CPU. </p><pre><code>template&lt;class T&gt;\nvoid Calcmeanmax (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Computes mean, max, and wet duration statistics for evolving variables, handling both CPU and GPU execution paths.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XModel</code> Model state (CPU) </li> <li><code>XModel_g</code> Model state (GPU) </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-calcmeanmax-double","title":"function Calcmeanmax&lt; double &gt;","text":"<pre><code>template void Calcmeanmax&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; &amp; XLoop,\n    Model &lt; double &gt; XModel,\n    Model &lt; double &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_meanmax_8cu/#function-calcmeanmax-float","title":"function Calcmeanmax&lt; float &gt;","text":"<pre><code>template void Calcmeanmax&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; &amp; XLoop,\n    Model &lt; float &gt; XModel,\n    Model &lt; float &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_meanmax_8cu/#function-initmeanmax","title":"function Initmeanmax","text":"<p>Initialize mean and max statistics at the start of the simulation. </p><pre><code>template&lt;class T&gt;\nvoid Initmeanmax (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Sets up/reset statistics arrays for the initial simulation step.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XModel</code> Model state (CPU) </li> <li><code>XModel_g</code> Model state (GPU) </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-initmeanmax-double","title":"function Initmeanmax&lt; double &gt;","text":"<pre><code>template void Initmeanmax&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    Model &lt; double &gt; XModel,\n    Model &lt; double &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_meanmax_8cu/#function-initmeanmax-float","title":"function Initmeanmax&lt; float &gt;","text":"<pre><code>template void Initmeanmax&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    Model &lt; float &gt; XModel,\n    Model &lt; float &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_meanmax_8cu/#function-adduandhu_cpu","title":"function addUandhU_CPU","text":"<p>Compute velocity magnitude and hU product on the CPU. </p><pre><code>template&lt;class T&gt;\n__host__ void addUandhU_CPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * u,\n    T * v,\n    T * U,\n    T * hU\n) \n</code></pre> <p>Calculates the velocity magnitude and its product with water depth for each cell on the CPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>h</code> Water depth array </li> <li><code>u</code> U-velocity array </li> <li><code>v</code> V-velocity array </li> <li><code>U</code> Output velocity magnitude array </li> <li><code>hU</code> Output hU product array </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-adduandhu_gpu","title":"function addUandhU_GPU","text":"<p>CUDA kernel to compute velocity magnitude and hU product. </p><pre><code>template&lt;class T&gt;\n__global__ void addUandhU_GPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * u,\n    T * v,\n    T * U,\n    T * hU\n) \n</code></pre> <p>Calculates the velocity magnitude and its product with water depth for each cell on the GPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>h</code> Water depth array </li> <li><code>u</code> U-velocity array </li> <li><code>v</code> V-velocity array </li> <li><code>U</code> Output velocity magnitude array </li> <li><code>hU</code> Output hU product array </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-addavg_varcpu","title":"function addavg_varCPU","text":"<p>Accumulate mean values for a variable on the CPU. </p><pre><code>template&lt;class T&gt;\n__host__ void addavg_varCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmean,\n    T * Var\n) \n</code></pre> <p>Adds the current value to the running mean for each cell on the CPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>Varmean</code> Mean variable array </li> <li><code>Var</code> Source variable array </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-addavg_vargpu","title":"function addavg_varGPU","text":"<p>CUDA kernel to accumulate mean values for a variable. </p><pre><code>template&lt;class T&gt;\n__global__ void addavg_varGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmean,\n    T * Var\n) \n</code></pre> <p>Adds the current value to the running mean for each cell on the GPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>Varmean</code> Mean variable array </li> <li><code>Var</code> Source variable array </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-addwettime_cpu","title":"function addwettime_CPU","text":"<p>Accumulate wet duration for each cell on the CPU. </p><pre><code>template&lt;class T&gt;\n__host__ void addwettime_CPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * wett,\n    T * h,\n    T thresold,\n    T time\n) \n</code></pre> <p>Adds time to the wet duration for cells where water depth exceeds a threshold on the CPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>wett</code> Wet duration array </li> <li><code>h</code> Water depth array </li> <li><code>thresold</code> Wet threshold value </li> <li><code>time</code> Time increment </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-addwettime_gpu","title":"function addwettime_GPU","text":"<p>CUDA kernel to accumulate wet duration for each cell. </p><pre><code>template&lt;class T&gt;\n__global__ void addwettime_GPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * wett,\n    T * h,\n    T thresold,\n    T time\n) \n</code></pre> <p>Adds time to the wet duration for cells where water depth exceeds a threshold on the GPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>wett</code> Wet duration array </li> <li><code>h</code> Water depth array </li> <li><code>thresold</code> Wet threshold value </li> <li><code>time</code> Time increment </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-divavg_varcpu","title":"function divavg_varCPU","text":"<p>Divide mean values by the number of steps on the CPU. </p><pre><code>template&lt;class T&gt;\n__host__ void divavg_varCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T ntdiv,\n    T * Varmean\n) \n</code></pre> <p>Finalizes the mean calculation by dividing accumulated values by the number of time steps on the CPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>ntdiv</code> Number of time steps </li> <li><code>Varmean</code> Mean variable array </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-divavg_vargpu","title":"function divavg_varGPU","text":"<p>CUDA kernel to divide mean values by the number of steps. </p><pre><code>template&lt;class T&gt;\n__global__ void divavg_varGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T ntdiv,\n    T * Varmean\n) \n</code></pre> <p>Finalizes the mean calculation by dividing accumulated values by the number of time steps on the GPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>ntdiv</code> Number of time steps </li> <li><code>Varmean</code> Mean variable array </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-max_norm_cpu","title":"function max_Norm_CPU","text":"<p>Compute max velocity magnitude on the CPU. </p><pre><code>template&lt;class T&gt;\n__host__ void max_Norm_CPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * Var1,\n    T * Var2\n) \n</code></pre> <p>Updates the max velocity magnitude for each cell by comparing with the current value using CPU routines.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>Varmax</code> Max variable array </li> <li><code>Var1</code> U-velocity array </li> <li><code>Var2</code> V-velocity array </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-max_norm_gpu","title":"function max_Norm_GPU","text":"<p>CUDA kernel to compute max velocity magnitude. </p><pre><code>template&lt;class T&gt;\n__global__ void max_Norm_GPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * Var1,\n    T * Var2\n) \n</code></pre> <p>Updates the max velocity magnitude for each cell by comparing with the current value on the GPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>Varmax</code> Max variable array </li> <li><code>Var1</code> U-velocity array </li> <li><code>Var2</code> V-velocity array </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-max_hu_cpu","title":"function max_hU_CPU","text":"<p>Compute max hU value on the CPU. </p><pre><code>template&lt;class T&gt;\n__host__ void max_hU_CPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * h,\n    T * u,\n    T * v\n) \n</code></pre> <p>Updates the max hU value for each cell by comparing with the current value using CPU routines.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>Varmax</code> Max variable array </li> <li><code>h</code> Water depth array </li> <li><code>u</code> U-velocity array </li> <li><code>v</code> V-velocity array </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-max_hu_gpu","title":"function max_hU_GPU","text":"<p>CUDA kernel to compute max hU value. </p><pre><code>template&lt;class T&gt;\n__global__ void max_hU_GPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * h,\n    T * u,\n    T * v\n) \n</code></pre> <p>Updates the max hU value for each cell by comparing with the current value on the GPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>Varmax</code> Max variable array </li> <li><code>h</code> Water depth array </li> <li><code>u</code> U-velocity array </li> <li><code>v</code> V-velocity array </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-max_varcpu","title":"function max_varCPU","text":"<p>Compute max value for a variable on the CPU. </p><pre><code>template&lt;class T&gt;\n__host__ void max_varCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * Var\n) \n</code></pre> <p>Updates the max value for each cell by comparing with the current value using CPU routines.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>Varmax</code> Max variable array </li> <li><code>Var</code> Source variable array </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-max_vargpu","title":"function max_varGPU","text":"<p>CUDA kernel to compute max value for a variable. </p><pre><code>template&lt;class T&gt;\n__global__ void max_varGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * Var\n) \n</code></pre> <p>Updates the max value for each cell by comparing with the current value on the GPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>Varmax</code> Max variable array </li> <li><code>Var</code> Source variable array </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-resetmaxcpu","title":"function resetmaxCPU","text":"<p>Reset max statistics arrays on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid resetmaxCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP_M &lt; T &gt; &amp; XEv\n) \n</code></pre> <p>Sets all max arrays to a large negative value using CPU routines.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XBlock</code> Block data </li> <li><code>XEv</code> Max evolving variables </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-resetmaxgpu","title":"function resetmaxGPU","text":"<p>Reset max statistics arrays on the GPU. </p><pre><code>template&lt;class T&gt;\nvoid resetmaxGPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP_M &lt; T &gt; &amp; XEv\n) \n</code></pre> <p>Sets all max arrays to a large negative value using a CUDA kernel.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XBlock</code> Block data </li> <li><code>XEv</code> Max evolving variables </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-resetmeancpu","title":"function resetmeanCPU","text":"<p>Reset mean statistics arrays on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid resetmeanCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP_M &lt; T &gt; &amp; XEv\n) \n</code></pre> <p>Sets all mean arrays to zero using CPU routines.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XBlock</code> Block data </li> <li><code>XEv</code> Mean evolving variables </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-resetmeancpu-double","title":"function resetmeanCPU&lt; double &gt;","text":"<pre><code>template void resetmeanCPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP_M &lt; double &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/_meanmax_8cu/#function-resetmeancpu-float","title":"function resetmeanCPU&lt; float &gt;","text":"<pre><code>template void resetmeanCPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP_M &lt; float &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/_meanmax_8cu/#function-resetmeangpu","title":"function resetmeanGPU","text":"<p>Reset mean statistics arrays on the GPU. </p><pre><code>template&lt;class T&gt;\nvoid resetmeanGPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP_M &lt; T &gt; &amp; XEv\n) \n</code></pre> <p>Sets all mean arrays to zero using a CUDA kernel.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XBlock</code> Block data </li> <li><code>XEv</code> Mean evolving variables </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-resetmeangpu-double","title":"function resetmeanGPU&lt; double &gt;","text":"<pre><code>template void resetmeanGPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP_M &lt; double &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/_meanmax_8cu/#function-resetmeangpu-float","title":"function resetmeanGPU&lt; float &gt;","text":"<pre><code>template void resetmeanGPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP_M &lt; float &gt; &amp; XEv\n) \n</code></pre>"},{"location":"BGFlood/_meanmax_8cu/#function-resetmeanmax","title":"function resetmeanmax","text":"<p>Reset mean and/or max statistics at output steps. </p><pre><code>template&lt;class T&gt;\nvoid resetmeanmax (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Resets mean, max, and wet duration arrays after output is produced, handling both CPU and GPU paths.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XModel</code> Model state (CPU) </li> <li><code>XModel_g</code> Model state (GPU) </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-resetmeanmax-double","title":"function resetmeanmax&lt; double &gt;","text":"<pre><code>template void resetmeanmax&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; &amp; XLoop,\n    Model &lt; double &gt; XModel,\n    Model &lt; double &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_meanmax_8cu/#function-resetmeanmax-float","title":"function resetmeanmax&lt; float &gt;","text":"<pre><code>template void resetmeanmax&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; &amp; XLoop,\n    Model &lt; float &gt; XModel,\n    Model &lt; float &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_meanmax_8cu/#function-resetvalcpu","title":"function resetvalCPU","text":"<p>Reset a variable array to a specified value on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid resetvalCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; var,\n    T val\n) \n</code></pre> <p>Sets all elements of the array to the given value using CPU routines.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>var</code> Variable array to reset </li> <li><code>val</code> Value to set </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-resetvalcpu-double","title":"function resetvalCPU&lt; double &gt;","text":"<pre><code>template void resetvalCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double *&amp; var,\n    double val\n) \n</code></pre>"},{"location":"BGFlood/_meanmax_8cu/#function-resetvalcpu-float","title":"function resetvalCPU&lt; float &gt;","text":"<pre><code>template void resetvalCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float *&amp; var,\n    float val\n) \n</code></pre>"},{"location":"BGFlood/_meanmax_8cu/#function-resetvalgpu","title":"function resetvalGPU","text":"<p>Reset a variable array to a specified value on the GPU. </p><pre><code>template&lt;class T&gt;\nvoid resetvalGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; var,\n    T val\n) \n</code></pre> <p>Sets all elements of the array to the given value using a CUDA kernel.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>var</code> Variable array to reset </li> <li><code>val</code> Value to set </li> </ul>"},{"location":"BGFlood/_meanmax_8cu/#function-resetvalgpu-double","title":"function resetvalGPU&lt; double &gt;","text":"<pre><code>template void resetvalGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double *&amp; var,\n    double val\n) \n</code></pre>"},{"location":"BGFlood/_meanmax_8cu/#function-resetvalgpu-float","title":"function resetvalGPU&lt; float &gt;","text":"<pre><code>template void resetvalGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float *&amp; var,\n    float val\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Meanmax.cu</code></p>"},{"location":"BGFlood/_meanmax_8cu_source/","title":"File Meanmax.cu","text":""},{"location":"BGFlood/_meanmax_8cu_source/#file-meanmaxcu","title":"File Meanmax.cu","text":"<p>File List &gt; src &gt; Meanmax.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Meanmax.h\"\n\ntemplate &lt;class T&gt; void Calcmeanmax(Param XParam, Loop&lt;T&gt;&amp; XLoop, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n\n    if (XParam.outmean)\n    {\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            addavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmean.h, XModel_g.evolv.h);\n            addavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmean.zs, XModel_g.evolv.zs);\n            addavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmean.u, XModel_g.evolv.u);\n            addavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmean.v, XModel_g.evolv.v);\n            addUandhU_GPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evolv.h, XModel_g.evolv.u, XModel_g.evolv.v, XModel_g.evmean.U, XModel_g.evmean.hU);\n\n            CUDA_CHECK(cudaDeviceSynchronize());\n        }\n        else\n        {\n\n            addavg_varCPU(XParam, XModel.blocks, XModel.evmean.h, XModel.evolv.h);\n            addavg_varCPU(XParam, XModel.blocks, XModel.evmean.zs, XModel.evolv.zs);\n            addavg_varCPU(XParam, XModel.blocks, XModel.evmean.u, XModel.evolv.u);\n            addavg_varCPU(XParam, XModel.blocks, XModel.evmean.v, XModel.evolv.v);\n            addUandhU_CPU(XParam, XModel.blocks, XModel.evolv.h, XModel.evolv.u, XModel.evolv.v, XModel.evmean.U, XModel.evmean.hU);\n\n        }\n\n\n        XLoop.nstep++;\n\n        if (XLoop.nextoutputtime - XLoop.totaltime &lt;= XLoop.dt * T(0.00001))\n        {\n            // devide by number of steps\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                divavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, T(XLoop.nstep), XModel_g.evmean.h);\n                divavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, T(XLoop.nstep), XModel_g.evmean.zs);\n                divavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, T(XLoop.nstep), XModel_g.evmean.u);\n                divavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, T(XLoop.nstep), XModel_g.evmean.v);\n                divavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, T(XLoop.nstep), XModel_g.evmean.U);\n                divavg_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, T(XLoop.nstep), XModel_g.evmean.hU);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n            else\n            {\n                divavg_varCPU(XParam, XModel.blocks, T(XLoop.nstep), XModel.evmean.h);\n                divavg_varCPU(XParam, XModel.blocks, T(XLoop.nstep), XModel.evmean.zs);\n                divavg_varCPU(XParam, XModel.blocks, T(XLoop.nstep), XModel.evmean.u);\n                divavg_varCPU(XParam, XModel.blocks, T(XLoop.nstep), XModel.evmean.v);\n                divavg_varCPU(XParam, XModel.blocks, T(XLoop.nstep), XModel.evmean.U);\n                divavg_varCPU(XParam, XModel.blocks, T(XLoop.nstep), XModel.evmean.hU);\n            }\n\n            //XLoop.nstep will be reset after a save to the disk which occurs in a different function\n        }\n\n    }\n    if (XParam.outmax)\n    {\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            max_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmax.h, XModel_g.evolv.h);\n            max_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmax.zs, XModel_g.evolv.zs);\n            max_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmax.u, XModel_g.evolv.u);\n            max_varGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmax.v, XModel_g.evolv.v);\n            max_Norm_GPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmax.U, XModel_g.evolv.u, XModel_g.evolv.v);\n            max_hU_GPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evmax.hU, XModel_g.evolv.h, XModel_g.evolv.u, XModel_g.evolv.v);\n            CUDA_CHECK(cudaDeviceSynchronize());\n        }\n        else\n        {\n            max_varCPU(XParam, XModel.blocks, XModel.evmax.h, XModel.evolv.h);\n            max_varCPU(XParam, XModel.blocks, XModel.evmax.zs, XModel.evolv.zs);\n            max_varCPU(XParam, XModel.blocks, XModel.evmax.u, XModel.evolv.u);\n            max_varCPU(XParam, XModel.blocks, XModel.evmax.v, XModel.evolv.v);\n            max_Norm_CPU(XParam, XModel.blocks, XModel.evmax.U, XModel.evolv.u, XModel.evolv.v);\n            max_hU_CPU(XParam, XModel.blocks, XModel.evmax.hU, XModel.evolv.h, XModel.evolv.u, XModel.evolv.v);\n        }\n    }\n    if (XParam.outtwet)\n    {\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            // Add value GPU\n            addwettime_GPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.wettime, XModel_g.evolv.h, T(XParam.wet_threshold), T(XLoop.dt));\n        }\n        else\n        {\n            // Add value CPU\n            addwettime_CPU(XParam, XModel.blocks, XModel.wettime, XModel.evolv.h, T(XParam.wet_threshold), T(XLoop.dt));\n        }\n    }\n}\ntemplate void Calcmeanmax&lt;float&gt;(Param XParam, Loop&lt;float&gt;&amp; XLoop, Model&lt;float&gt; XModel, Model&lt;float&gt; XModel_g);\ntemplate void Calcmeanmax&lt;double&gt;(Param XParam, Loop&lt;double&gt;&amp; XLoop, Model&lt;double&gt; XModel, Model&lt;double&gt; XModel_g);\n\n\ntemplate &lt;class T&gt; void resetmeanmax(Param XParam, Loop&lt;T&gt;&amp; XLoop, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    // Reset mean and or max only at output steps\n    //XLoop.nextoutputtime - XLoop.totaltime &lt;= XLoop.dt * T(0.00001)\n    if (XLoop.nstepout == 0) //This implis an output was just produced so need to reset\n    {\n        //Define some useful variables \n        if (XParam.outmean)\n        {\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                resetmeanGPU(XParam, XLoop, XModel_g.blocks, XModel_g.evmean);\n            }\n            else\n            {\n                resetmeanCPU(XParam, XLoop, XModel.blocks, XModel.evmean);\n            }\n            XLoop.nstep = 0;\n        }\n\n        //Reset Max \n        if (XParam.outmax &amp;&amp; XParam.resetmax)\n        {\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                resetmaxGPU(XParam, XLoop, XModel_g.blocks, XModel_g.evmax);\n            }\n            else\n            {\n                resetmaxCPU(XParam, XLoop, XModel.blocks, XModel.evmax);\n\n            }\n        }\n\n        //Reset Wet duration\n        if (XParam.outtwet &amp;&amp; XParam.resetmax)\n        {\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                resetvalGPU(XParam, XModel_g.blocks, XModel_g.wettime, T(0.0));\n            }\n            else\n            {\n                resetvalCPU(XParam, XModel.blocks, XModel.wettime, T(0.0));\n            }\n        }\n    }\n}\ntemplate void resetmeanmax&lt;float&gt;(Param XParam, Loop&lt;float&gt;&amp; XLoop, Model&lt;float&gt; XModel, Model&lt;float&gt; XModel_g);\ntemplate void resetmeanmax&lt;double&gt;(Param XParam, Loop&lt;double&gt;&amp; XLoop, Model&lt;double&gt; XModel, Model&lt;double&gt; XModel_g);\n\ntemplate &lt;class T&gt; void Initmeanmax(Param XParam, Loop&lt;T&gt; XLoop, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    //at the initial step overide the reset max to initialise the max variable (if needed)\n    //this override is not preserved so wont affect the rest of the loop\n    XParam.resetmax = true;\n    XLoop.nextoutputtime = XLoop.totaltime;\n    XLoop.dt = T(1.0);\n    resetmeanmax(XParam, XLoop, XModel, XModel_g);\n}\ntemplate void Initmeanmax&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, Model&lt;float&gt; XModel, Model&lt;float&gt; XModel_g);\ntemplate void Initmeanmax&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, Model&lt;double&gt; XModel, Model&lt;double&gt; XModel_g);\n\ntemplate &lt;class T&gt; void resetmaxGPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, EvolvingP_M&lt;T&gt;&amp; XEv)\n{\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XLoop.hugenegval, XEv.h);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XLoop.hugenegval, XEv.zs);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XLoop.hugenegval, XEv.u);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XLoop.hugenegval, XEv.v);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XLoop.hugenegval, XEv.U);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, XLoop.hugenegval, XEv.hU);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n}\n\n\ntemplate &lt;class T&gt; void resetmaxCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, EvolvingP_M&lt;T&gt;&amp; XEv)\n{\n\n    InitArrayBUQ(XParam, XBlock, XLoop.hugenegval, XEv.h);\n    InitArrayBUQ(XParam, XBlock, XLoop.hugenegval, XEv.zs);\n    InitArrayBUQ(XParam, XBlock, XLoop.hugenegval, XEv.u);\n    InitArrayBUQ(XParam, XBlock, XLoop.hugenegval, XEv.v);\n    InitArrayBUQ(XParam, XBlock, XLoop.hugenegval, XEv.U);\n    InitArrayBUQ(XParam, XBlock, XLoop.hugenegval, XEv.hU);\n\n}\n\n\ntemplate &lt;class T&gt; void resetmeanCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, EvolvingP_M&lt;T&gt;&amp; XEv)\n{\n\n    InitArrayBUQ(XParam, XBlock, T(0.0), XEv.h);\n    InitArrayBUQ(XParam, XBlock, T(0.0), XEv.zs);\n    InitArrayBUQ(XParam, XBlock, T(0.0), XEv.u);\n    InitArrayBUQ(XParam, XBlock, T(0.0), XEv.v);\n    InitArrayBUQ(XParam, XBlock, T(0.0), XEv.U);\n    InitArrayBUQ(XParam, XBlock, T(0.0), XEv.hU);\n\n}\ntemplate void resetmeanCPU&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, EvolvingP_M&lt;float&gt;&amp; XEv);\ntemplate void resetmeanCPU&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, EvolvingP_M&lt;double&gt;&amp; XEv);\n\ntemplate &lt;class T&gt; void resetmeanGPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, EvolvingP_M&lt;T&gt;&amp; XEv)\n{\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n    //\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, T(0.0), XEv.h);\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, T(0.0), XEv.zs);\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, T(0.0), XEv.u);\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, T(0.0), XEv.v);\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, T(0.0), XEv.U);\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, T(0.0), XEv.hU);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n}\ntemplate void resetmeanGPU&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, EvolvingP_M&lt;float&gt;&amp; XEv);\ntemplate void resetmeanGPU&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, EvolvingP_M&lt;double&gt;&amp; XEv);\n\n\ntemplate &lt;class T&gt; void resetvalCPU(Param XParam, BlockP&lt;T&gt; XBlock, T*&amp; var, T val)\n{\n\n    InitArrayBUQ(XParam, XBlock, val, var);\n\n}\ntemplate void resetvalCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float*&amp; var, float val);\ntemplate void resetvalCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double*&amp; var, double val);\n\ntemplate &lt;class T&gt; void resetvalGPU(Param XParam, BlockP&lt;T&gt; XBlock, T*&amp; var, T val)\n{\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XBlock.active, val, var);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n}\ntemplate void resetvalGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float*&amp; var, float val);\ntemplate void resetvalGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double*&amp; var, double val);\n\n\n\ntemplate &lt;class T&gt; __global__ void addavg_varGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmean, T* Var)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n\n    Varmean[i] = Varmean[i] + Var[i];\n\n}\n\n\ntemplate &lt;class T&gt; __host__ void addavg_varCPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmean, T* Var)\n{\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                Varmean[i] = Varmean[i] + Var[i];\n            }\n        }\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void divavg_varGPU(Param XParam, BlockP&lt;T&gt; XBlock, T ntdiv, T* Varmean)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    Varmean[i] = Varmean[i] / ntdiv;\n\n}\n\ntemplate &lt;class T&gt; __host__ void divavg_varCPU(Param XParam, BlockP&lt;T&gt; XBlock, T ntdiv, T* Varmean)\n{\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                Varmean[i] = Varmean[i] / ntdiv;\n            }\n        }\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void addUandhU_GPU(Param XParam, BlockP&lt;T&gt; XBlock, T * h, T * u, T * v, T* U, T* hU)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    U[i] = sqrt((u[i] * u[i]) + (v[i] * v[i]));\n    hU[i] = h[i] * U[i];\n\n}\n\ntemplate &lt;class T&gt; __host__ void addUandhU_CPU(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* u, T* v, T* U, T* hU)\n{\n    int ib, n;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                U[i] = sqrt((u[i] * u[i]) + (v[i] * v[i]));\n                hU[i] = h[i] * U[i];\n            }\n        }\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void max_varGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* Var)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    Varmax[i] = max(Varmax[i], Var[i]);\n\n}\n\ntemplate &lt;class T&gt; __global__ void max_Norm_GPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* Var1, T* Var2)\n{\n    T Var_norm;\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    Var_norm = sqrt((Var1[i] * Var1[i]) + (Var2[i] * Var2[i]));\n    Varmax[i] = max(Varmax[i], Var_norm);\n\n}\n\ntemplate &lt;class T&gt; __global__ void max_hU_GPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* h, T* u, T* v)\n{\n    T Var_hU;\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    Var_hU = h[i] * sqrt((u[i]*u[i])+(v[i]*v[i]));\n    Varmax[i] = max(Varmax[i], Var_hU);\n\n}\n\ntemplate &lt;class T&gt; __host__ void max_varCPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* Var)\n{\n    int ib;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                Varmax[i] = utils::max(Varmax[i], Var[i]);\n            }\n        }\n    }\n\n}\n\ntemplate &lt;class T&gt; __host__ void max_Norm_CPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* Var1, T* Var2)\n{\n    int ib, n;\n    T Var_norm;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n                Var_norm = sqrt((Var1[i] * Var1[i]) + (Var2[i] * Var2[i]));\n                Varmax[i] = utils::max(Varmax[i], Var_norm);\n            }\n        }\n    }\n\n}\n\ntemplate &lt;class T&gt; __host__ void max_hU_CPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* h, T* u, T* v)\n{\n    int ib, n;\n    T Var_hU;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n                Var_hU = h[i] * sqrt((u[i] * u[i]) + (v[i] * v[i]));\n                Varmax[i] = utils::max(Varmax[i], Var_hU);\n            }\n        }\n    }\n\n}\n\ntemplate &lt;class T&gt; __global__ void addwettime_GPU(Param XParam, BlockP&lt;T&gt; XBlock, T* wett, T* h, T thresold, T time)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    if (h[i] &gt; thresold)\n    {\n        wett[i] = wett[i] + time;\n    }\n\n}\n\n\ntemplate &lt;class T&gt; __host__ void addwettime_CPU(Param XParam, BlockP&lt;T&gt; XBlock, T* wett, T* h, T thresold, T time)\n{\n    int ib, n;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                if (h[i] &gt; thresold)\n                {\n                    wett[i] = wett[i] + time;\n                }\n            }\n        }\n    }\n\n}\n</code></pre>"},{"location":"BGFlood/_meanmax_8h/","title":"File Meanmax.h","text":""},{"location":"BGFlood/_meanmax_8h/#file-meanmaxh","title":"File Meanmax.h","text":"<p>FileList &gt; src &gt; Meanmax.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"FlowGPU.h\"</code></li> </ul>"},{"location":"BGFlood/_meanmax_8h/#public-functions","title":"Public Functions","text":"Type Name void Calcmeanmax (Param XParam, Loop&lt; T &gt; &amp; XLoop, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Calculate mean and/or max of requested variables on GPU/CPU. void Initmeanmax (Param XParam, Loop&lt; T &gt; XLoop, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Initialize mean and max statistics at the start of the simulation. __global__ void addUandhU_GPU (Param XParam, BlockP&lt; T &gt; XBlock, T * h, T * u, T * v, T * U, T * hU) CUDA kernel to compute velocity magnitude and hU product. __global__ void addavg_varGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmean, T * Var) CUDA kernel to accumulate mean values for a variable. __global__ void addwettime_GPU (Param XParam, BlockP&lt; T &gt; XBlock, T * wett, T * h, T thresold, T time) CUDA kernel to accumulate wet duration for each cell. __global__ void divavg_varGPU (Param XParam, BlockP&lt; T &gt; XBlock, T ntdiv, T * Varmean) CUDA kernel to divide mean values by the number of steps. __global__ void max_Norm_GPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * Var1, T * Var2) CUDA kernel to compute max velocity magnitude. __global__ void max_hU_GPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * Var1, T * Var2, T * Var3) CUDA kernel to compute max hU value. __global__ void max_varGPU (Param XParam, BlockP&lt; T &gt; XBlock, T * Varmax, T * Var) CUDA kernel to compute max value for a variable. void resetmeanmax (Param XParam, Loop&lt; T &gt; &amp; XLoop, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Reset mean and/or max statistics at output steps. void resetvalGPU (Param XParam, BlockP&lt; T &gt; XBlock, T *&amp; var, T val) Reset a variable array to a specified value on the GPU."},{"location":"BGFlood/_meanmax_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_meanmax_8h/#function-calcmeanmax","title":"function Calcmeanmax","text":"<p>Calculate mean and/or max of requested variables on GPU/CPU. </p><pre><code>template&lt;class T&gt;\nvoid Calcmeanmax (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Computes mean, max, and wet duration statistics for evolving variables, handling both CPU and GPU execution paths.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XModel</code> Model state (CPU) </li> <li><code>XModel_g</code> Model state (GPU) </li> </ul>"},{"location":"BGFlood/_meanmax_8h/#function-initmeanmax","title":"function Initmeanmax","text":"<p>Initialize mean and max statistics at the start of the simulation. </p><pre><code>template&lt;class T&gt;\nvoid Initmeanmax (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Sets up/reset statistics arrays for the initial simulation step.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XModel</code> Model state (CPU) </li> <li><code>XModel_g</code> Model state (GPU) </li> </ul>"},{"location":"BGFlood/_meanmax_8h/#function-adduandhu_gpu","title":"function addUandhU_GPU","text":"<p>CUDA kernel to compute velocity magnitude and hU product. </p><pre><code>template&lt;class T&gt;\n__global__ void addUandhU_GPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * h,\n    T * u,\n    T * v,\n    T * U,\n    T * hU\n) \n</code></pre> <p>Calculates the velocity magnitude and its product with water depth for each cell on the GPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>h</code> Water depth array </li> <li><code>u</code> U-velocity array </li> <li><code>v</code> V-velocity array </li> <li><code>U</code> Output velocity magnitude array </li> <li><code>hU</code> Output hU product array </li> </ul>"},{"location":"BGFlood/_meanmax_8h/#function-addavg_vargpu","title":"function addavg_varGPU","text":"<p>CUDA kernel to accumulate mean values for a variable. </p><pre><code>template&lt;class T&gt;\n__global__ void addavg_varGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmean,\n    T * Var\n) \n</code></pre> <p>Adds the current value to the running mean for each cell on the GPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>Varmean</code> Mean variable array </li> <li><code>Var</code> Source variable array </li> </ul>"},{"location":"BGFlood/_meanmax_8h/#function-addwettime_gpu","title":"function addwettime_GPU","text":"<p>CUDA kernel to accumulate wet duration for each cell. </p><pre><code>template&lt;class T&gt;\n__global__ void addwettime_GPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * wett,\n    T * h,\n    T thresold,\n    T time\n) \n</code></pre> <p>Adds time to the wet duration for cells where water depth exceeds a threshold on the GPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>wett</code> Wet duration array </li> <li><code>h</code> Water depth array </li> <li><code>thresold</code> Wet threshold value </li> <li><code>time</code> Time increment </li> </ul>"},{"location":"BGFlood/_meanmax_8h/#function-divavg_vargpu","title":"function divavg_varGPU","text":"<p>CUDA kernel to divide mean values by the number of steps. </p><pre><code>template&lt;class T&gt;\n__global__ void divavg_varGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T ntdiv,\n    T * Varmean\n) \n</code></pre> <p>Finalizes the mean calculation by dividing accumulated values by the number of time steps on the GPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>ntdiv</code> Number of time steps </li> <li><code>Varmean</code> Mean variable array </li> </ul>"},{"location":"BGFlood/_meanmax_8h/#function-max_norm_gpu","title":"function max_Norm_GPU","text":"<p>CUDA kernel to compute max velocity magnitude. </p><pre><code>template&lt;class T&gt;\n__global__ void max_Norm_GPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * Var1,\n    T * Var2\n) \n</code></pre> <p>Updates the max velocity magnitude for each cell by comparing with the current value on the GPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>Varmax</code> Max variable array </li> <li><code>Var1</code> U-velocity array </li> <li><code>Var2</code> V-velocity array </li> </ul>"},{"location":"BGFlood/_meanmax_8h/#function-max_hu_gpu","title":"function max_hU_GPU","text":"<p>CUDA kernel to compute max hU value. </p><pre><code>template&lt;class T&gt;\n__global__ void max_hU_GPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * Var1,\n    T * Var2,\n    T * Var3\n) \n</code></pre> <p>Updates the max hU value for each cell by comparing with the current value on the GPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>Varmax</code> Max variable array </li> <li><code>h</code> Water depth array </li> <li><code>u</code> U-velocity array </li> <li><code>v</code> V-velocity array </li> </ul>"},{"location":"BGFlood/_meanmax_8h/#function-max_vargpu","title":"function max_varGPU","text":"<p>CUDA kernel to compute max value for a variable. </p><pre><code>template&lt;class T&gt;\n__global__ void max_varGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Varmax,\n    T * Var\n) \n</code></pre> <p>Updates the max value for each cell by comparing with the current value on the GPU.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>Varmax</code> Max variable array </li> <li><code>Var</code> Source variable array </li> </ul>"},{"location":"BGFlood/_meanmax_8h/#function-resetmeanmax","title":"function resetmeanmax","text":"<p>Reset mean and/or max statistics at output steps. </p><pre><code>template&lt;class T&gt;\nvoid resetmeanmax (\n    Param XParam,\n    Loop &lt; T &gt; &amp; XLoop,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Resets mean, max, and wet duration arrays after output is produced, handling both CPU and GPU paths.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop control structure </li> <li><code>XModel</code> Model state (CPU) </li> <li><code>XModel_g</code> Model state (GPU) </li> </ul>"},{"location":"BGFlood/_meanmax_8h/#function-resetvalgpu","title":"function resetvalGPU","text":"<p>Reset a variable array to a specified value on the GPU. </p><pre><code>template&lt;class T&gt;\nvoid resetvalGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T *&amp; var,\n    T val\n) \n</code></pre> <p>Sets all elements of the array to the given value using a CUDA kernel.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data </li> <li><code>var</code> Variable array to reset </li> <li><code>val</code> Value to set </li> </ul> <p>The documentation for this class was generated from the following file <code>src/Meanmax.h</code></p>"},{"location":"BGFlood/_meanmax_8h_source/","title":"File Meanmax.h","text":""},{"location":"BGFlood/_meanmax_8h_source/#file-meanmaxh","title":"File Meanmax.h","text":"<p>File List &gt; src &gt; Meanmax.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef MEANMAX_H\n#define MEANMAX_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"FlowGPU.h\"\n\n\ntemplate &lt;class T&gt; void Calcmeanmax(Param XParam, Loop&lt;T&gt;&amp; XLoop, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g);\ntemplate &lt;class T&gt; void resetmeanmax(Param XParam, Loop&lt;T&gt;&amp; XLoop, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g);\ntemplate &lt;class T&gt; void Initmeanmax(Param XParam, Loop&lt;T&gt; XLoop, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g);\ntemplate &lt;class T&gt; void resetvalGPU(Param XParam, BlockP&lt;T&gt; XBlock, T*&amp; var, T val);\n\n\ntemplate &lt;class T&gt; __global__ void addavg_varGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmean, T* Var);\ntemplate &lt;class T&gt; __global__ void divavg_varGPU(Param XParam, BlockP&lt;T&gt; XBlock, T ntdiv, T* Varmean);\ntemplate &lt;class T&gt; __global__ void addUandhU_GPU(Param XParam, BlockP&lt;T&gt; XBlock, T* h, T* u, T* v, T* U, T* hU);\ntemplate &lt;class T&gt; __global__ void max_varGPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* Var);\ntemplate &lt;class T&gt; __global__ void max_Norm_GPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* Var1, T* Var2);\ntemplate &lt;class T&gt; __global__ void max_hU_GPU(Param XParam, BlockP&lt;T&gt; XBlock, T* Varmax, T* Var1, T* Var2, T* Var3);\ntemplate &lt;class T&gt; __global__ void addwettime_GPU(Param XParam, BlockP&lt;T&gt; XBlock, T* wett, T* h, T thresold, T time);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/","title":"File MemManagement.cu","text":""},{"location":"BGFlood/_mem_management_8cu/#file-memmanagementcu","title":"File MemManagement.cu","text":"<p>FileList &gt; src &gt; MemManagement.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"MemManagement.h\"</code></li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ void AllocateCPU (int nx, int ny, T *&amp; zb) Allocate memory for a single array on the CPU. __host__ void AllocateCPU (int nx, int ny, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v) Allocate memory for multiple arrays (zs, h, u, v) on the CPU. __host__ void AllocateCPU (int nx, int ny, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v, T *&amp; U, T *&amp; hU) Allocate memory for extended arrays (zs, h, u, v, U, hU) on the CPU. __host__ void AllocateCPU (int nx, int ny, GradientsP&lt; T &gt; &amp; Grad) Allocate memory for gradient arrays on the CPU. void AllocateCPU (int nblk, int blksize, EvolvingP&lt; T &gt; &amp; Ev) Allocate memory for evolving variables on the CPU. void AllocateCPU (int nblk, int blksize, EvolvingP_M&lt; T &gt; &amp; Ev) Allocate memory for extended evolving variables on the CPU. void AllocateCPU (int nblk, int blksize, Param XParam, Model&lt; T &gt; &amp; XModel) Allocate all model arrays on the CPU. template void AllocateCPU&lt; double &gt; (int nx, int ny, double *&amp; zs, double *&amp; h, double *&amp; u, double *&amp; v)  template void AllocateCPU&lt; double &gt; (int nx, int ny, double *&amp; zs, double *&amp; h, double *&amp; u, double *&amp; v, double *&amp; U, double *&amp; hU)  template void AllocateCPU&lt; double &gt; (int nx, int ny, GradientsP&lt; double &gt; &amp; Grad)  template void AllocateCPU&lt; double &gt; (int nblk, int blksize, Param XParam, Model&lt; double &gt; &amp; XModel)  template void AllocateCPU&lt; float &gt; (int nx, int ny, float *&amp; zs, float *&amp; h, float *&amp; u, float *&amp; v)  template void AllocateCPU&lt; float &gt; (int nx, int ny, float *&amp; zs, float *&amp; h, float *&amp; u, float *&amp; v, float *&amp; U, float *&amp; hU)  template void AllocateCPU&lt; float &gt; (int nx, int ny, GradientsP&lt; float &gt; &amp; Grad)  template void AllocateCPU&lt; float &gt; (int nblk, int blksize, Param XParam, Model&lt; float &gt; &amp; XModel)  template void AllocateCPU&lt; int &gt; (int nx, int ny, int *&amp; zs, int *&amp; h, int *&amp; u, int *&amp; v)  template void AllocateCPU&lt; int &gt; (int nx, int ny, int *&amp; zs, int *&amp; h, int *&amp; u, int *&amp; v, int *&amp; U, int *&amp; hU)  void AllocateGPU (int nx, int ny, T *&amp; z_g) Allocate memory on the GPU for a single array. void AllocateGPU (int nx, int ny, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v) Allocate memory on the GPU for multiple arrays (zs, h, u, v). void AllocateGPU (int nx, int ny, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v, T *&amp; U, T *&amp; hU) Allocate memory on the GPU for extended arrays (zs, h, u, v, U, hU). void AllocateGPU (int nx, int ny, GradientsP&lt; T &gt; &amp; Grad) Allocate memory on the GPU for gradient arrays. void AllocateGPU (int nblk, int blksize, EvolvingP&lt; T &gt; &amp; Ev) Allocate memory on the GPU for evolving variables structure. void AllocateGPU (int nblk, int blksize, EvolvingP_M&lt; T &gt; &amp; Ev) Allocate memory on the GPU for extended evolving variables structure. void AllocateGPU (int nblk, int blksize, Param XParam, Model&lt; T &gt; &amp; XModel) Allocate all model arrays on the GPU. template void AllocateGPU&lt; double &gt; (int nx, int ny, double *&amp; zs, double *&amp; h, double *&amp; u, double *&amp; v)  template void AllocateGPU&lt; double &gt; (int nx, int ny, double *&amp; zs, double *&amp; h, double *&amp; u, double *&amp; v, double *&amp; U, double *&amp; hU)  template void AllocateGPU&lt; double &gt; (int nx, int ny, GradientsP&lt; double &gt; &amp; Grad)  template void AllocateGPU&lt; double &gt; (int nblk, int blksize, Param XParam, Model&lt; double &gt; &amp; XModel)  template void AllocateGPU&lt; float &gt; (int nx, int ny, float *&amp; zs, float *&amp; h, float *&amp; u, float *&amp; v)  template void AllocateGPU&lt; float &gt; (int nx, int ny, float *&amp; zs, float *&amp; h, float *&amp; u, float *&amp; v, float *&amp; U, float *&amp; hU)  template void AllocateGPU&lt; float &gt; (int nx, int ny, GradientsP&lt; float &gt; &amp; Grad)  template void AllocateGPU&lt; float &gt; (int nblk, int blksize, Param XParam, Model&lt; float &gt; &amp; XModel)  template void AllocateGPU&lt; int &gt; (int nx, int ny, int *&amp; zs, int *&amp; h, int *&amp; u, int *&amp; v)  template void AllocateGPU&lt; int &gt; (int nx, int ny, int *&amp; zs, int *&amp; h, int *&amp; u, int *&amp; v, int *&amp; U, int *&amp; hU)  void AllocateMappedMemCPU (int nx, int ny, int gpudevice, T *&amp; z) Allocate mapped memory on the CPU for CUDA interop. template void AllocateMappedMemCPU&lt; double &gt; (int nx, int ny, int gpudevice, double *&amp; z)  template void AllocateMappedMemCPU&lt; float &gt; (int nx, int ny, int gpudevice, float *&amp; z)  template void AllocateMappedMemCPU&lt; int &gt; (int nx, int ny, int gpudevice, int *&amp; z)  void AllocateMappedMemGPU (int nx, int ny, int gpudevice, T *&amp; z_g, T * z) Get device pointer for mapped host memory. template void AllocateMappedMemGPU&lt; double &gt; (int nx, int ny, int gpudevice, double *&amp; z_g, double * z)  template void AllocateMappedMemGPU&lt; float &gt; (int nx, int ny, int gpudevice, float *&amp; z_g, float * z)  template void AllocateMappedMemGPU&lt; int &gt; (int nx, int ny, int gpudevice, int *&amp; z_g, int * z)  __host__ void FillCPU (int nx, int ny, T fillval, T *&amp; zb) Fill a CPU array with a specified value. template void FillCPU&lt; double &gt; (int nx, int ny, double fillval, double *&amp; zb)  template void FillCPU&lt; float &gt; (int nx, int ny, float fillval, float *&amp; zb)  template void FillCPU&lt; int &gt; (int nx, int ny, int fillval, int *&amp; zb)  void ReallocArray (int nblk, int blksize, T *&amp; zb) Reallocate memory for a single array. void ReallocArray (int nblk, int blksize, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v) Reallocate memory for multiple arrays (zs, h, u, v). void ReallocArray (int nblk, int blksize, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v, T *&amp; U, T *&amp; hU) Reallocate memory for extended arrays (zs, h, u, v, U, hU). void ReallocArray (int nblk, int blksize, EvolvingP&lt; T &gt; &amp; Ev) Reallocate memory for evolving variables structure. void ReallocArray (int nblk, int blksize, EvolvingP_M&lt; T &gt; &amp; Ev) Reallocate memory for extended evolving variables structure. void ReallocArray (int nblk, int blksize, Param XParam, Model&lt; T &gt; &amp; XModel) Reallocate all model arrays. template void ReallocArray&lt; double &gt; (int nblk, int blksize, double *&amp; zs, double *&amp; h, double *&amp; u, double *&amp; v)  template void ReallocArray&lt; double &gt; (int nblk, int blksize, double *&amp; zs, double *&amp; h, double *&amp; u, double *&amp; v, double *&amp; U, double *&amp; hU)  template void ReallocArray&lt; double &gt; (int nblk, int blksize, EvolvingP&lt; double &gt; &amp; Ev)  template void ReallocArray&lt; double &gt; (int nblk, int blksize, EvolvingP_M&lt; double &gt; &amp; Ev)  template void ReallocArray&lt; double &gt; (int nblk, int blksize, Param XParam, Model&lt; double &gt; &amp; XModel)  template void ReallocArray&lt; float &gt; (int nblk, int blksize, float *&amp; zs, float *&amp; h, float *&amp; u, float *&amp; v)  template void ReallocArray&lt; float &gt; (int nblk, int blksize, float *&amp; zs, float *&amp; h, float *&amp; u, float *&amp; v, float *&amp; U, float *&amp; hU)  template void ReallocArray&lt; float &gt; (int nblk, int blksize, EvolvingP&lt; float &gt; &amp; Ev)  template void ReallocArray&lt; float &gt; (int nblk, int blksize, EvolvingP_M&lt; float &gt; &amp; Ev)  template void ReallocArray&lt; float &gt; (int nblk, int blksize, Param XParam, Model&lt; float &gt; &amp; XModel)  template void ReallocArray&lt; int &gt; (int nblk, int blksize, int *&amp; zs, int *&amp; h, int *&amp; u, int *&amp; v)  template void ReallocArray&lt; int &gt; (int nblk, int blksize, int *&amp; zs, int *&amp; h, int *&amp; u, int *&amp; v, int *&amp; U, int *&amp; hU)  __host__ int memloc (Param XParam, int i, int j, int ib) Compute memory index for a cell in a block (using Param ). __host__ __device__ int memloc (int halowidth, int blkmemwidth, int i, int j, int ib) Compute memory index for a cell in a block (using explicit sizes)."},{"location":"BGFlood/_mem_management_8cu/#macros","title":"Macros","text":"Type Name define ALIGN_UP (x, size) <code>( ((size\\_t)x+(size-1))&amp;(~(size-1)) )</code> define MEMORY_ALIGNMENT <code>4096</code>"},{"location":"BGFlood/_mem_management_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_mem_management_8cu/#function-allocatecpu","title":"function AllocateCPU","text":"<p>Allocate memory for a single array on the CPU. </p><pre><code>template&lt;class T&gt;\n__host__ void AllocateCPU (\n    int nx,\n    int ny,\n    T *&amp; zb\n) \n</code></pre> <p>Allocates memory for the given array and checks for allocation failure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or int) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>zb</code> Array to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatecpu_1","title":"function AllocateCPU","text":"<p>Allocate memory for multiple arrays (zs, h, u, v) on the CPU. </p><pre><code>template&lt;class T&gt;\n__host__ void AllocateCPU (\n    int nx,\n    int ny,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v\n) \n</code></pre> <p>Allocates memory for the given arrays.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float, double, int) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>zs</code> Array to allocate </li> <li><code>h</code> Array to allocate </li> <li><code>u</code> Array to allocate </li> <li><code>v</code> Array to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatecpu_2","title":"function AllocateCPU","text":"<p>Allocate memory for extended arrays (zs, h, u, v, U, hU) on the CPU. </p><pre><code>template&lt;class T&gt;\n__host__ void AllocateCPU (\n    int nx,\n    int ny,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v,\n    T *&amp; U,\n    T *&amp; hU\n) \n</code></pre> <p>Allocates memory for the given arrays.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float, double, int) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>zs</code> Array to allocate </li> <li><code>h</code> Array to allocate </li> <li><code>u</code> Array to allocate </li> <li><code>v</code> Array to allocate </li> <li><code>U</code> Array to allocate </li> <li><code>hU</code> Array to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatecpu_3","title":"function AllocateCPU","text":"<p>Allocate memory for gradient arrays on the CPU. </p><pre><code>template&lt;class T&gt;\n__host__ void AllocateCPU (\n    int nx,\n    int ny,\n    GradientsP &lt; T &gt; &amp; Grad\n) \n</code></pre> <p>Allocates memory for all gradient arrays in GradientsP structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>Grad</code> GradientsP structure to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatecpu_4","title":"function AllocateCPU","text":"<p>Allocate memory for evolving variables on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; T &gt; &amp; Ev\n) \n</code></pre> <p>Allocates memory for h, zs, u, v arrays in EvolvingP structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>Ev</code> EvolvingP structure to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatecpu_5","title":"function AllocateCPU","text":"<p>Allocate memory for extended evolving variables on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; T &gt; &amp; Ev\n) \n</code></pre> <p>Allocates memory for h, zs, u, v, U, hU arrays in EvolvingP_M structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>Ev</code> EvolvingP_M structure to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatecpu_6","title":"function AllocateCPU","text":"<p>Allocate all model arrays on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Allocates memory for all arrays in the Model structure, including blocks, gradients, fluxes, and output buffers.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatecpu-double","title":"function AllocateCPU&lt; double &gt;","text":"<pre><code>template void AllocateCPU&lt; double &gt; (\n    int nx,\n    int ny,\n    double *&amp; zs,\n    double *&amp; h,\n    double *&amp; u,\n    double *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatecpu-double_1","title":"function AllocateCPU&lt; double &gt;","text":"<pre><code>template void AllocateCPU&lt; double &gt; (\n    int nx,\n    int ny,\n    double *&amp; zs,\n    double *&amp; h,\n    double *&amp; u,\n    double *&amp; v,\n    double *&amp; U,\n    double *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatecpu-double_2","title":"function AllocateCPU&lt; double &gt;","text":"<pre><code>template void AllocateCPU&lt; double &gt; (\n    int nx,\n    int ny,\n    GradientsP &lt; double &gt; &amp; Grad\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatecpu-double_3","title":"function AllocateCPU&lt; double &gt;","text":"<pre><code>template void AllocateCPU&lt; double &gt; (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatecpu-float","title":"function AllocateCPU&lt; float &gt;","text":"<pre><code>template void AllocateCPU&lt; float &gt; (\n    int nx,\n    int ny,\n    float *&amp; zs,\n    float *&amp; h,\n    float *&amp; u,\n    float *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatecpu-float_1","title":"function AllocateCPU&lt; float &gt;","text":"<pre><code>template void AllocateCPU&lt; float &gt; (\n    int nx,\n    int ny,\n    float *&amp; zs,\n    float *&amp; h,\n    float *&amp; u,\n    float *&amp; v,\n    float *&amp; U,\n    float *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatecpu-float_2","title":"function AllocateCPU&lt; float &gt;","text":"<pre><code>template void AllocateCPU&lt; float &gt; (\n    int nx,\n    int ny,\n    GradientsP &lt; float &gt; &amp; Grad\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatecpu-float_3","title":"function AllocateCPU&lt; float &gt;","text":"<pre><code>template void AllocateCPU&lt; float &gt; (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatecpu-int","title":"function AllocateCPU&lt; int &gt;","text":"<pre><code>template void AllocateCPU&lt; int &gt; (\n    int nx,\n    int ny,\n    int *&amp; zs,\n    int *&amp; h,\n    int *&amp; u,\n    int *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatecpu-int_1","title":"function AllocateCPU&lt; int &gt;","text":"<pre><code>template void AllocateCPU&lt; int &gt; (\n    int nx,\n    int ny,\n    int *&amp; zs,\n    int *&amp; h,\n    int *&amp; u,\n    int *&amp; v,\n    int *&amp; U,\n    int *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocategpu","title":"function AllocateGPU","text":"<p>Allocate memory on the GPU for a single array. </p><pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nx,\n    int ny,\n    T *&amp; z_g\n) \n</code></pre> <p>Allocates device memory for the given array.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>z_g</code> Device pointer output </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-allocategpu_1","title":"function AllocateGPU","text":"<p>Allocate memory on the GPU for multiple arrays (zs, h, u, v). </p><pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nx,\n    int ny,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v\n) \n</code></pre> <p>Allocates device memory for the given arrays.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>zs</code> Device pointer output </li> <li><code>h</code> Device pointer output </li> <li><code>u</code> Device pointer output </li> <li><code>v</code> Device pointer output </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-allocategpu_2","title":"function AllocateGPU","text":"<p>Allocate memory on the GPU for extended arrays (zs, h, u, v, U, hU). </p><pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nx,\n    int ny,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v,\n    T *&amp; U,\n    T *&amp; hU\n) \n</code></pre> <p>Allocates device memory for the given arrays.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>zs</code> Device pointer output </li> <li><code>h</code> Device pointer output </li> <li><code>u</code> Device pointer output </li> <li><code>v</code> Device pointer output </li> <li><code>U</code> Device pointer output </li> <li><code>hU</code> Device pointer output </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-allocategpu_3","title":"function AllocateGPU","text":"<p>Allocate memory on the GPU for gradient arrays. </p><pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nx,\n    int ny,\n    GradientsP &lt; T &gt; &amp; Grad\n) \n</code></pre> <p>Allocates device memory for all gradient arrays in GradientsP structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>Grad</code> GradientsP structure to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-allocategpu_4","title":"function AllocateGPU","text":"<p>Allocate memory on the GPU for evolving variables structure. </p><pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; T &gt; &amp; Ev\n) \n</code></pre> <p>Allocates device memory for all arrays in EvolvingP structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>Ev</code> EvolvingP structure to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-allocategpu_5","title":"function AllocateGPU","text":"<p>Allocate memory on the GPU for extended evolving variables structure. </p><pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; T &gt; &amp; Ev\n) \n</code></pre> <p>Allocates device memory for all arrays in EvolvingP_M structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>Ev</code> EvolvingP_M structure to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-allocategpu_6","title":"function AllocateGPU","text":"<p>Allocate all model arrays on the GPU. </p><pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Allocates device memory for all arrays in the Model structure, including blocks, gradients, fluxes, and output buffers.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-allocategpu-double","title":"function AllocateGPU&lt; double &gt;","text":"<pre><code>template void AllocateGPU&lt; double &gt; (\n    int nx,\n    int ny,\n    double *&amp; zs,\n    double *&amp; h,\n    double *&amp; u,\n    double *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocategpu-double_1","title":"function AllocateGPU&lt; double &gt;","text":"<pre><code>template void AllocateGPU&lt; double &gt; (\n    int nx,\n    int ny,\n    double *&amp; zs,\n    double *&amp; h,\n    double *&amp; u,\n    double *&amp; v,\n    double *&amp; U,\n    double *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocategpu-double_2","title":"function AllocateGPU&lt; double &gt;","text":"<pre><code>template void AllocateGPU&lt; double &gt; (\n    int nx,\n    int ny,\n    GradientsP &lt; double &gt; &amp; Grad\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocategpu-double_3","title":"function AllocateGPU&lt; double &gt;","text":"<pre><code>template void AllocateGPU&lt; double &gt; (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocategpu-float","title":"function AllocateGPU&lt; float &gt;","text":"<pre><code>template void AllocateGPU&lt; float &gt; (\n    int nx,\n    int ny,\n    float *&amp; zs,\n    float *&amp; h,\n    float *&amp; u,\n    float *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocategpu-float_1","title":"function AllocateGPU&lt; float &gt;","text":"<pre><code>template void AllocateGPU&lt; float &gt; (\n    int nx,\n    int ny,\n    float *&amp; zs,\n    float *&amp; h,\n    float *&amp; u,\n    float *&amp; v,\n    float *&amp; U,\n    float *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocategpu-float_2","title":"function AllocateGPU&lt; float &gt;","text":"<pre><code>template void AllocateGPU&lt; float &gt; (\n    int nx,\n    int ny,\n    GradientsP &lt; float &gt; &amp; Grad\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocategpu-float_3","title":"function AllocateGPU&lt; float &gt;","text":"<pre><code>template void AllocateGPU&lt; float &gt; (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocategpu-int","title":"function AllocateGPU&lt; int &gt;","text":"<pre><code>template void AllocateGPU&lt; int &gt; (\n    int nx,\n    int ny,\n    int *&amp; zs,\n    int *&amp; h,\n    int *&amp; u,\n    int *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocategpu-int_1","title":"function AllocateGPU&lt; int &gt;","text":"<pre><code>template void AllocateGPU&lt; int &gt; (\n    int nx,\n    int ny,\n    int *&amp; zs,\n    int *&amp; h,\n    int *&amp; u,\n    int *&amp; v,\n    int *&amp; U,\n    int *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatemappedmemcpu","title":"function AllocateMappedMemCPU","text":"<p>Allocate mapped memory on the CPU for CUDA interop. </p><pre><code>template&lt;class T&gt;\nvoid AllocateMappedMemCPU (\n    int nx,\n    int ny,\n    int gpudevice,\n    T *&amp; z\n) \n</code></pre> <p>Allocates pinned or mapped memory for CUDA host-device interoperation.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>gpudevice</code> GPU device index </li> <li><code>z</code> Pointer to allocated memory </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatemappedmemcpu-double","title":"function AllocateMappedMemCPU&lt; double &gt;","text":"<pre><code>template void AllocateMappedMemCPU&lt; double &gt; (\n    int nx,\n    int ny,\n    int gpudevice,\n    double *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatemappedmemcpu-float","title":"function AllocateMappedMemCPU&lt; float &gt;","text":"<pre><code>template void AllocateMappedMemCPU&lt; float &gt; (\n    int nx,\n    int ny,\n    int gpudevice,\n    float *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatemappedmemcpu-int","title":"function AllocateMappedMemCPU&lt; int &gt;","text":"<pre><code>template void AllocateMappedMemCPU&lt; int &gt; (\n    int nx,\n    int ny,\n    int gpudevice,\n    int *&amp; z\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatemappedmemgpu","title":"function AllocateMappedMemGPU","text":"<p>Get device pointer for mapped host memory. </p><pre><code>template&lt;class T&gt;\nvoid AllocateMappedMemGPU (\n    int nx,\n    int ny,\n    int gpudevice,\n    T *&amp; z_g,\n    T * z\n) \n</code></pre> <p>Retrieves the device pointer for host memory mapped for CUDA interop.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>gpudevice</code> GPU device index </li> <li><code>z_g</code> Device pointer output </li> <li><code>z</code> Host pointer input </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatemappedmemgpu-double","title":"function AllocateMappedMemGPU&lt; double &gt;","text":"<pre><code>template void AllocateMappedMemGPU&lt; double &gt; (\n    int nx,\n    int ny,\n    int gpudevice,\n    double *&amp; z_g,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatemappedmemgpu-float","title":"function AllocateMappedMemGPU&lt; float &gt;","text":"<pre><code>template void AllocateMappedMemGPU&lt; float &gt; (\n    int nx,\n    int ny,\n    int gpudevice,\n    float *&amp; z_g,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-allocatemappedmemgpu-int","title":"function AllocateMappedMemGPU&lt; int &gt;","text":"<pre><code>template void AllocateMappedMemGPU&lt; int &gt; (\n    int nx,\n    int ny,\n    int gpudevice,\n    int *&amp; z_g,\n    int * z\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-fillcpu","title":"function FillCPU","text":"<p>Fill a CPU array with a specified value. </p><pre><code>template&lt;class T&gt;\n__host__ void FillCPU (\n    int nx,\n    int ny,\n    T fillval,\n    T *&amp; zb\n) \n</code></pre> <p>Sets all elements of the array to the given fill value.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float, double, int) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>fillval</code> Value to fill </li> <li><code>zb</code> Array to fill </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-fillcpu-double","title":"function FillCPU&lt; double &gt;","text":"<pre><code>template void FillCPU&lt; double &gt; (\n    int nx,\n    int ny,\n    double fillval,\n    double *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-fillcpu-float","title":"function FillCPU&lt; float &gt;","text":"<pre><code>template void FillCPU&lt; float &gt; (\n    int nx,\n    int ny,\n    float fillval,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-fillcpu-int","title":"function FillCPU&lt; int &gt;","text":"<pre><code>template void FillCPU&lt; int &gt; (\n    int nx,\n    int ny,\n    int fillval,\n    int *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray","title":"function ReallocArray","text":"<p>Reallocate memory for a single array. </p><pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    T *&amp; zb\n) \n</code></pre> <p>Reallocates memory for the given array to match the new block and size.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>zb</code> Array to reallocate </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray_1","title":"function ReallocArray","text":"<p>Reallocate memory for multiple arrays (zs, h, u, v). </p><pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v\n) \n</code></pre> <p>Reallocates memory for the given arrays to match the new block and size.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>zs</code> Array to reallocate </li> <li><code>h</code> Array to reallocate </li> <li><code>u</code> Array to reallocate </li> <li><code>v</code> Array to reallocate </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray_2","title":"function ReallocArray","text":"<p>Reallocate memory for extended arrays (zs, h, u, v, U, hU). </p><pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v,\n    T *&amp; U,\n    T *&amp; hU\n) \n</code></pre> <p>Reallocates memory for the given arrays to match the new block and size.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>zs</code> Array to reallocate </li> <li><code>h</code> Array to reallocate </li> <li><code>u</code> Array to reallocate </li> <li><code>v</code> Array to reallocate </li> <li><code>U</code> Array to reallocate </li> <li><code>hU</code> Array to reallocate </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray_3","title":"function ReallocArray","text":"<p>Reallocate memory for evolving variables structure. </p><pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; T &gt; &amp; Ev\n) \n</code></pre> <p>Reallocates memory for all arrays in EvolvingP structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>Ev</code> EvolvingP structure to reallocate </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray_4","title":"function ReallocArray","text":"<p>Reallocate memory for extended evolving variables structure. </p><pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; T &gt; &amp; Ev\n) \n</code></pre> <p>Reallocates memory for all arrays in EvolvingP_M structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>Ev</code> EvolvingP_M structure to reallocate </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray_5","title":"function ReallocArray","text":"<p>Reallocate all model arrays. </p><pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Reallocates memory for all arrays in the Model structure, including blocks, gradients, fluxes, and output buffers.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure to reallocate </li> </ul>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray-double","title":"function ReallocArray&lt; double &gt;","text":"<pre><code>template void ReallocArray&lt; double &gt; (\n    int nblk,\n    int blksize,\n    double *&amp; zs,\n    double *&amp; h,\n    double *&amp; u,\n    double *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray-double_1","title":"function ReallocArray&lt; double &gt;","text":"<pre><code>template void ReallocArray&lt; double &gt; (\n    int nblk,\n    int blksize,\n    double *&amp; zs,\n    double *&amp; h,\n    double *&amp; u,\n    double *&amp; v,\n    double *&amp; U,\n    double *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray-double_2","title":"function ReallocArray&lt; double &gt;","text":"<pre><code>template void ReallocArray&lt; double &gt; (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; double &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray-double_3","title":"function ReallocArray&lt; double &gt;","text":"<pre><code>template void ReallocArray&lt; double &gt; (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; double &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray-double_4","title":"function ReallocArray&lt; double &gt;","text":"<pre><code>template void ReallocArray&lt; double &gt; (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray-float","title":"function ReallocArray&lt; float &gt;","text":"<pre><code>template void ReallocArray&lt; float &gt; (\n    int nblk,\n    int blksize,\n    float *&amp; zs,\n    float *&amp; h,\n    float *&amp; u,\n    float *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray-float_1","title":"function ReallocArray&lt; float &gt;","text":"<pre><code>template void ReallocArray&lt; float &gt; (\n    int nblk,\n    int blksize,\n    float *&amp; zs,\n    float *&amp; h,\n    float *&amp; u,\n    float *&amp; v,\n    float *&amp; U,\n    float *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray-float_2","title":"function ReallocArray&lt; float &gt;","text":"<pre><code>template void ReallocArray&lt; float &gt; (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; float &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray-float_3","title":"function ReallocArray&lt; float &gt;","text":"<pre><code>template void ReallocArray&lt; float &gt; (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; float &gt; &amp; Ev\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray-float_4","title":"function ReallocArray&lt; float &gt;","text":"<pre><code>template void ReallocArray&lt; float &gt; (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray-int","title":"function ReallocArray&lt; int &gt;","text":"<pre><code>template void ReallocArray&lt; int &gt; (\n    int nblk,\n    int blksize,\n    int *&amp; zs,\n    int *&amp; h,\n    int *&amp; u,\n    int *&amp; v\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-reallocarray-int_1","title":"function ReallocArray&lt; int &gt;","text":"<pre><code>template void ReallocArray&lt; int &gt; (\n    int nblk,\n    int blksize,\n    int *&amp; zs,\n    int *&amp; h,\n    int *&amp; u,\n    int *&amp; v,\n    int *&amp; U,\n    int *&amp; hU\n) \n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#function-memloc","title":"function memloc","text":"<p>Compute memory index for a cell in a block (using Param ). </p><pre><code>__host__ int memloc (\n    Param XParam,\n    int i,\n    int j,\n    int ib\n) \n</code></pre> <p>Calculates the linear memory index for a cell in a block using model parameters.</p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>i</code> Cell x-index </li> <li><code>j</code> Cell y-index </li> <li><code>ib</code> Block index </li> </ul> <p>Returns:</p> <p>Linear memory index </p>"},{"location":"BGFlood/_mem_management_8cu/#function-memloc_1","title":"function memloc","text":"<p>Compute memory index for a cell in a block (using explicit sizes). </p><pre><code>__host__ __device__ int memloc (\n    int halowidth,\n    int blkmemwidth,\n    int i,\n    int j,\n    int ib\n) \n</code></pre> <p>Calculates the linear memory index for a cell in a block using explicit halo and block sizes.</p> <p>Parameters:</p> <ul> <li><code>halowidth</code> Halo width </li> <li><code>blkmemwidth</code> Block memory width </li> <li><code>i</code> Cell x-index </li> <li><code>j</code> Cell y-index </li> <li><code>ib</code> Block index </li> </ul> <p>Returns:</p> <p>Linear memory index </p>"},{"location":"BGFlood/_mem_management_8cu/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"BGFlood/_mem_management_8cu/#define-align_up","title":"define ALIGN_UP","text":"<pre><code>#define ALIGN_UP (\n    x,\n    size\n) `( ((size_t)x+(size-1))&amp;(~(size-1)) )`\n</code></pre>"},{"location":"BGFlood/_mem_management_8cu/#define-memory_alignment","title":"define MEMORY_ALIGNMENT","text":"<pre><code>#define MEMORY_ALIGNMENT `4096`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/MemManagement.cu</code></p>"},{"location":"BGFlood/_mem_management_8cu_source/","title":"File MemManagement.cu","text":""},{"location":"BGFlood/_mem_management_8cu_source/#file-memmanagementcu","title":"File MemManagement.cu","text":"<p>File List &gt; src &gt; MemManagement.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"MemManagement.h\"\n\n\n#define MEMORY_ALIGNMENT  4096\n#define ALIGN_UP(x,size) ( ((size_t)x+(size-1))&amp;(~(size-1)) )\n\n__host__ int memloc(Param XParam, int i, int j, int ib)\n{\n    return (i+XParam.halowidth) + (j + XParam.halowidth) * XParam.blkmemwidth + ib * XParam.blksize;\n}\n\n\n__host__ __device__ int memloc(int halowidth, int blkmemwidth, int i, int j, int ib)\n{\n    return (i + halowidth) + (j + halowidth) * blkmemwidth + ib * (blkmemwidth* blkmemwidth);\n}\n\ntemplate &lt;class T&gt; __host__ void AllocateCPU(int nx, int ny, T *&amp;zb)\n{\n    zb = (T *)malloc(nx*ny * sizeof(T));\n    if (!zb)\n    {\n        fprintf(stderr, \"Memory allocation failure\\n\");\n\n        exit(EXIT_FAILURE);\n    }\n}\n\ntemplate &lt;class T&gt; __host__ void FillCPU(int nx, int ny,T fillval, T*&amp; zb)\n{\n    for (int ix = 0; ix &lt; nx; ix++)\n    {\n        for (int iy = 0; iy &lt; ny; iy++)\n        {\n            zb[iy * nx + ix] = fillval;\n        }\n    }\n}\ntemplate void FillCPU&lt;double&gt;(int nx, int ny, double fillval, double*&amp; zb);\ntemplate void FillCPU&lt;float&gt;(int nx, int ny, float fillval, float*&amp; zb);\ntemplate void FillCPU&lt;int&gt;(int nx, int ny, int fillval, int*&amp; zb);\n\ntemplate &lt;class T&gt; __host__ void AllocateCPU(int nx, int ny, T *&amp;zs, T *&amp;h, T *&amp;u, T *&amp;v)\n{\n\n    AllocateCPU(nx, ny, zs);\n    AllocateCPU(nx, ny, h);\n    AllocateCPU(nx, ny, u);\n    AllocateCPU(nx, ny, v);\n\n}\n\ntemplate void AllocateCPU&lt;double&gt;(int nx, int ny, double *&amp;zs, double *&amp;h, double *&amp;u, double *&amp;v);\ntemplate void AllocateCPU&lt;float&gt;(int nx, int ny, float *&amp;zs, float *&amp;h, float *&amp;u, float *&amp;v);\ntemplate void AllocateCPU&lt;int&gt;(int nx, int ny, int *&amp;zs, int *&amp;h, int *&amp;u, int *&amp;v);\n\ntemplate &lt;class T&gt; __host__ void AllocateCPU(int nx, int ny, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v, T*&amp; U, T*&amp; hU)\n{\n\n    AllocateCPU(nx, ny, zs);\n    AllocateCPU(nx, ny, h);\n    AllocateCPU(nx, ny, u);\n    AllocateCPU(nx, ny, v);\n    AllocateCPU(nx, ny, U);\n    AllocateCPU(nx, ny, hU);\n}\n\ntemplate void AllocateCPU&lt;double&gt;(int nx, int ny, double*&amp; zs, double*&amp; h, double*&amp; u, double*&amp; v, double*&amp; U, double*&amp; hU);\ntemplate void AllocateCPU&lt;float&gt;(int nx, int ny, float*&amp; zs, float*&amp; h, float*&amp; u, float*&amp; v, float*&amp; U, float*&amp; hU);\ntemplate void AllocateCPU&lt;int&gt;(int nx, int ny, int*&amp; zs, int*&amp; h, int*&amp; u, int*&amp; v, int*&amp; U, int*&amp; hU);\n\ntemplate &lt;class T&gt; __host__\nvoid AllocateCPU(int nx, int ny, GradientsP&lt;T&gt;&amp; Grad)\n{\n    AllocateCPU(nx, ny, Grad.dhdx, Grad.dzsdx, Grad.dudx, Grad.dvdx);\n    AllocateCPU(nx, ny, Grad.dhdy, Grad.dzsdy, Grad.dudy, Grad.dvdy);\n\n    AllocateCPU(nx, ny, Grad.dzbdx);\n    AllocateCPU(nx, ny, Grad.dzbdy);\n}\ntemplate void AllocateCPU&lt;float&gt;(int nx, int ny, GradientsP&lt;float&gt;&amp; Grad);\ntemplate void AllocateCPU&lt;double&gt;(int nx, int ny, GradientsP&lt;double&gt;&amp; Grad);\n\ntemplate &lt;class T&gt; void AllocateCPU(int nblk, int blksize, EvolvingP&lt;T&gt; &amp; Ev)\n{\n    AllocateCPU(nblk, blksize, Ev.h, Ev.zs, Ev.u, Ev.v);\n}\n\ntemplate &lt;class T&gt; void AllocateCPU(int nblk, int blksize, EvolvingP_M&lt;T&gt;&amp; Ev)\n{\n    AllocateCPU(nblk, blksize, Ev.h, Ev.zs, Ev.u, Ev.v, Ev.U, Ev.hU);\n\n}\n\ntemplate &lt;class T&gt;\nvoid AllocateCPU(int nblk, int blksize, Param XParam, Model&lt;T&gt;&amp; XModel)\n{\n    // Allocate blocks data \n    AllocateCPU(nblk, blksize, XModel.evolv);\n    AllocateCPU(nblk, blksize, XModel.evolv_o);\n\n    AllocateCPU(nblk, blksize, XModel.grad.dhdy, XModel.grad.dzsdy, XModel.grad.dudy, XModel.grad.dvdy);\n    AllocateCPU(nblk, blksize, XModel.grad.dhdx, XModel.grad.dzsdx, XModel.grad.dudx, XModel.grad.dvdx);\n\n    AllocateCPU(nblk, blksize, XModel.grad.dzbdx);\n    AllocateCPU(nblk, blksize, XModel.grad.dzbdy);\n    if (XParam.engine==5)\n    {\n        AllocateCPU(nblk, blksize, XModel.fluxml.Fux, XModel.fluxml.Fvy, XModel.fluxml.Fuy, XModel.fluxml.Fvx);\n        AllocateCPU(nblk, blksize, XModel.fluxml.hfu, XModel.fluxml.hfv, XModel.fluxml.hu, XModel.fluxml.hv);\n        AllocateCPU(nblk, blksize, XModel.fluxml.hau);\n        AllocateCPU(nblk, blksize, XModel.fluxml.hav);\n    }\n    else\n    {\n        AllocateCPU(nblk, blksize, XModel.flux.Fhu, XModel.flux.Fhv, XModel.flux.Fqux, XModel.flux.Fquy);\n\n        AllocateCPU(nblk, blksize, XModel.flux.Fqvx, XModel.flux.Fqvy, XModel.flux.Su, XModel.flux.Sv);\n    }\n    AllocateCPU(nblk, blksize, XModel.zb, XModel.adv.dh, XModel.adv.dhu, XModel.adv.dhv);\n\n    AllocateCPU(nblk, blksize, XModel.cf, XModel.time.arrmax, XModel.time.arrmin, XModel.time.dtmax);\n\n\n    //Allocate block info\n    AllocateCPU(nblk, 1, XModel.blocks.active);\n    AllocateCPU(nblk, blksize, XModel.blocks.activeCell);\n    AllocateCPU(nblk, 1, XModel.blocks.level);\n\n    AllocateCPU(nblk, 1, XModel.blocks.BotLeft, XModel.blocks.BotRight, XModel.blocks.LeftBot, XModel.blocks.LeftTop);\n    AllocateCPU(nblk, 1, XModel.blocks.RightBot, XModel.blocks.RightTop, XModel.blocks.TopLeft, XModel.blocks.TopRight);\n\n    AllocateCPU(nblk, 1, XModel.blocks.xo);\n    AllocateCPU(nblk, 1, XModel.blocks.yo);\n\n    // do allocate 1 mask block (block with at least 1 empty neighbourhood) \n    // this will be reallocated eventually\n    AllocateCPU(1, 1, XModel.blocks.mask.side);\n    AllocateCPU(1, 1, XModel.blocks.mask.blks);\n\n    // If no adatptation ignore this!\n    if (XParam.maxlevel != XParam.minlevel)\n    {\n        AllocateCPU(nblk, 1, XModel.adapt.availblk, XModel.adapt.csumblk, XModel.adapt.invactive, XModel.adapt.newlevel);\n        AllocateCPU(nblk, 1, XModel.adapt.coarsen);\n        AllocateCPU(nblk, 1, XModel.adapt.refine);\n    }\n\n    // do allocate 1 outzone block, this will be reallocated eventually\n    //AllocateCPU(1, 1, XModel.blocks.outZone[0].blk);\n    //if (XParam.outzone.size() &gt; 0)\n    //{\n    //  //XModel.blocks.outZone.resize(XParam.outzone.size())\n    //  for (int o = 1; o &lt; XParam.outzone.size(); o++)\n    //  {\n    //      AllocateCPU(1, 1, XModel.blocks.outZone[o].blk);\n    //  }\n    //}\n\n\n\n    if (XParam.TSnodesout.size() &gt; 0)\n    {\n        // Timeseries output temporary storage\n        int storage = XParam.maxTSstorage;\n        AllocateCPU(storage, 1, XModel.TSstore);\n    }\n\n    if (XParam.atmpforcing)\n    {\n        AllocateCPU(nblk, blksize, XModel.Patm);\n        AllocateCPU(nblk, blksize, XModel.datmpdx);\n        AllocateCPU(nblk, blksize, XModel.datmpdy);\n    }\n\n    if (XParam.infiltration)\n    {\n        AllocateCPU(nblk, blksize, XModel.il);\n        AllocateCPU(nblk, blksize, XModel.cl);\n        AllocateCPU(nblk, blksize, XModel.hgw);\n    }\n\n    if (XParam.outmax)\n    {\n        AllocateCPU(nblk, blksize, XModel.evmax);\n    }\n    if (XParam.outmean)\n    {\n        AllocateCPU(nblk, blksize, XModel.evmean);\n    }\n    if (XParam.outtwet)\n    {\n        AllocateCPU(nblk, blksize, XModel.wettime);\n    }\n\n    /*if (XParam.outvort)\n    {\n        AllocateCPU(nblk, blksize, XModel.vort);\n    }\n    if (XParam.outU)\n    {\n        AllocateCPU(nblk, blksize, XModel.U);\n    }*/\n\n    if (XParam.TSnodesout.size() &gt; 0)\n    {\n        // Timeseries output temporary storage\n        int storage = XParam.maxTSstorage;\n        AllocateCPU(storage, 1, XModel.TSstore);\n    }\n\n    if (XParam.nrivers &gt; 0)\n    {\n        //this will be eventually reallocated later\n        AllocateCPU(1, 1, XModel.bndblk.river);\n        XModel.bndblk.nblkriver = 1;\n\n        AllocateCPU(1, 1, XModel.bndblk.Riverinfo.Xbidir);\n        AllocateCPU(1, 1, XModel.bndblk.Riverinfo.Xridib);\n    }\n    // preallocate 1 block along all bnds\n    //this will be eventually reallocated later\n    //AllocateCPU(1, 1, XModel.bndblk.left);\n    //AllocateCPU(1, 1, XModel.bndblk.right);\n    //AllocateCPU(1, 1, XModel.bndblk.top);\n    //AllocateCPU(1, 1, XModel.bndblk.bot);\n\n}\n\ntemplate void AllocateCPU&lt;float&gt;(int nblk, int blksize, Param XParam, Model&lt;float&gt;&amp; XModel);\ntemplate void AllocateCPU&lt;double&gt;(int nblk, int blksize, Param XParam, Model&lt;double&gt;&amp; XModel);\n\n\n\n\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, T* &amp; zb)\n{\n    //\n    if (nblk &gt; 0)\n    {\n        zb = (T*)realloc(zb, nblk * blksize * sizeof(T));\n        if (zb == NULL)\n        {\n            fprintf(stderr, \"Memory reallocation failure\\n\");\n\n            exit(EXIT_FAILURE);\n        }\n    }\n    //return nblkmem\n}\n\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v)\n{\n    //\n\n    ReallocArray(nblk, blksize, zs);\n    ReallocArray(nblk, blksize, h);\n    ReallocArray(nblk, blksize, u);\n    ReallocArray(nblk, blksize, v);\n    //return nblkmem\n}\ntemplate void ReallocArray&lt;int&gt;(int nblk, int blksize, int*&amp; zs, int*&amp; h, int*&amp; u, int*&amp; v);\ntemplate void ReallocArray&lt;float&gt;(int nblk, int blksize, float*&amp; zs, float*&amp; h, float*&amp; u, float*&amp; v);\ntemplate void ReallocArray&lt;double&gt;(int nblk, int blksize, double*&amp; zs, double*&amp; h, double*&amp; u, double*&amp; v);\n\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v, T*&amp; U, T*&amp; hU)\n{\n    //\n\n    ReallocArray(nblk, blksize, zs);\n    ReallocArray(nblk, blksize, h);\n    ReallocArray(nblk, blksize, u);\n    ReallocArray(nblk, blksize, v);\n    ReallocArray(nblk, blksize, U);\n    ReallocArray(nblk, blksize, hU);\n    //return nblkmem\n}\n\ntemplate void ReallocArray&lt;int&gt;(int nblk, int blksize, int* &amp; zs, int*&amp; h, int*&amp; u, int*&amp; v, int*&amp; U, int*&amp; hU);\ntemplate void ReallocArray&lt;float&gt;(int nblk, int blksize, float* &amp; zs, float*&amp; h, float*&amp; u, float*&amp; v, float*&amp; U, float*&amp; hU);\ntemplate void ReallocArray&lt;double&gt;(int nblk, int blksize, double* &amp; zs, double*&amp; h, double*&amp; u, double*&amp; v, double*&amp; U, double*&amp; hU);\n\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, EvolvingP&lt;T&gt;&amp; Ev)\n{\n    ReallocArray(nblk, blksize, Ev.zs, Ev.h, Ev.u, Ev.v);\n}\ntemplate void ReallocArray&lt;float&gt;(int nblk, int blksize, EvolvingP&lt;float&gt;&amp; Ev);\ntemplate void ReallocArray&lt;double&gt;(int nblk, int blksize, EvolvingP&lt;double&gt;&amp; Ev);\n\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, EvolvingP_M&lt;T&gt;&amp; Ev)\n{\n    ReallocArray(nblk, blksize, Ev.zs, Ev.h, Ev.u, Ev.v, Ev.U, Ev.hU);\n}\ntemplate void ReallocArray&lt;float&gt;(int nblk, int blksize, EvolvingP_M&lt;float&gt;&amp; Ev);\ntemplate void ReallocArray&lt;double&gt;(int nblk, int blksize, EvolvingP_M&lt;double&gt;&amp; Ev);\n\ntemplate &lt;class T&gt;\nvoid ReallocArray(int nblk, int blksize, Param XParam, Model&lt;T&gt;&amp; XModel)\n{\n    // Allocate blocks data \n    ReallocArray(nblk, blksize, XModel.evolv);\n    ReallocArray(nblk, blksize, XModel.evolv_o);\n\n    ReallocArray(nblk, blksize, XModel.grad.dhdy, XModel.grad.dzsdy, XModel.grad.dudy, XModel.grad.dvdy);\n    ReallocArray(nblk, blksize, XModel.grad.dhdx, XModel.grad.dzsdx, XModel.grad.dudx, XModel.grad.dvdx);\n\n    ReallocArray(nblk, blksize, XModel.grad.dzbdx);\n    ReallocArray(nblk, blksize, XModel.grad.dzbdy);\n    if (XParam.engine == 5)\n    {\n        ReallocArray(nblk, blksize, XModel.fluxml.Fux, XModel.fluxml.Fvy, XModel.fluxml.Fuy, XModel.fluxml.Fvx);\n        ReallocArray(nblk, blksize, XModel.fluxml.hfu, XModel.fluxml.hfv, XModel.fluxml.hu, XModel.fluxml.hv);\n        ReallocArray(nblk, blksize, XModel.fluxml.hau);\n        ReallocArray(nblk, blksize, XModel.fluxml.hav);\n    }\n    else\n    {\n        ReallocArray(nblk, blksize, XModel.flux.Fhu, XModel.flux.Fhv, XModel.flux.Fqux, XModel.flux.Fquy);\n\n        ReallocArray(nblk, blksize, XModel.flux.Fqvx, XModel.flux.Fqvy, XModel.flux.Su, XModel.flux.Sv);\n    }\n\n    ReallocArray(nblk, blksize, XModel.zb, XModel.adv.dh, XModel.adv.dhu, XModel.adv.dhv);\n\n    ReallocArray(nblk, blksize, XModel.cf, XModel.time.arrmax, XModel.time.arrmin, XModel.time.dtmax);\n\n\n    //Allocate block info\n    ReallocArray(nblk, 1, XModel.blocks.active);\n    ReallocArray(nblk, blksize, XModel.blocks.activeCell);\n    ReallocArray(nblk, 1, XModel.blocks.level);\n\n    ReallocArray(nblk, 1, XModel.blocks.BotLeft, XModel.blocks.BotRight, XModel.blocks.LeftBot, XModel.blocks.LeftTop);\n    ReallocArray(nblk, 1, XModel.blocks.RightBot, XModel.blocks.RightTop, XModel.blocks.TopLeft, XModel.blocks.TopRight);\n\n    ReallocArray(nblk, 1, XModel.blocks.xo);\n    ReallocArray(nblk, 1, XModel.blocks.yo);\n\n    // If no adatptation ignore this!\n    if (XParam.maxlevel != XParam.minlevel)\n    {\n        ReallocArray(nblk, 1, XModel.adapt.availblk, XModel.adapt.csumblk, XModel.adapt.invactive, XModel.adapt.newlevel);\n        ReallocArray(nblk, 1, XModel.adapt.coarsen);\n        ReallocArray(nblk, 1, XModel.adapt.refine);\n    }\n\n\n    if (XParam.atmpforcing)\n    {\n        ReallocArray(nblk, blksize, XModel.Patm);\n        ReallocArray(nblk, blksize, XModel.datmpdx);\n        ReallocArray(nblk, blksize, XModel.datmpdy);\n    }\n\n    if (XParam.infiltration)\n    {\n        ReallocArray(nblk, blksize, XModel.il);\n        ReallocArray(nblk, blksize, XModel.cl);\n        ReallocArray(nblk, blksize, XModel.hgw);\n\n    }\n\n    if (XParam.outmax)\n    {\n        ReallocArray(nblk, blksize, XModel.evmax);\n    }\n    if (XParam.outmean)\n    {\n        ReallocArray(nblk, blksize, XModel.evmean);\n    }\n    if (XParam.outtwet)\n    {\n        ReallocArray(nblk, blksize, XModel.wettime);\n    }\n    //ReallocArray(nx, ny, XModel.);\n\n\n\n}\n\ntemplate void ReallocArray&lt;float&gt;(int nblk, int blksize, Param XParam, Model&lt;float&gt;&amp; XModel);\ntemplate void ReallocArray&lt;double&gt;(int nblk, int blksize, Param XParam, Model&lt;double&gt;&amp; XModel);\n\n\n\n\ntemplate &lt;class T&gt; void AllocateMappedMemCPU(int nx, int ny,int gpudevice, T*&amp; z)\n{\n\n    bool bPinGenericMemory;\n    cudaDeviceProp deviceProp;\n#if defined(__APPLE__) || defined(MACOSX)\n    bPinGenericMemory = false;  // Generic Pinning of System Paged memory is not currently supported on Mac OSX\n#else\n    bPinGenericMemory = true;\n#endif\n\n    // Here there should be a limit for cudar version less than 4.000\n\n\n    if (bPinGenericMemory)\n    {\n        //printf(\"&gt; Using Generic System Paged Memory (malloc)\\n\");\n    }\n    else\n    {\n        //printf(\"&gt; Using CUDA Host Allocated (cudaHostAlloc)\\n\");\n    }\n    if (gpudevice &gt;= 0)\n    {\n        cudaGetDeviceProperties(&amp;deviceProp, gpudevice);\n\n        if (!deviceProp.canMapHostMemory)\n        {\n            fprintf(stderr, \"Device %d does not support mapping CPU host memory!\\n\", gpudevice);\n            bPinGenericMemory = false;\n        }\n    }\n    size_t bytes = nx * ny * sizeof(T);\n    if (bPinGenericMemory)\n    {\n\n\n\n        T* a_UA = (T*)malloc(bytes + MEMORY_ALIGNMENT);\n\n\n        // We need to ensure memory is aligned to 4K (so we will need to padd memory accordingly)\n        z = (T*)ALIGN_UP(a_UA, MEMORY_ALIGNMENT);\n\n        if (gpudevice &gt;= 0)\n        {\n            CUDA_CHECK(cudaHostRegister(z, bytes, cudaHostRegisterMapped));\n        }\n\n    }\n    else\n    {\n\n        //flags = cudaHostAllocMapped;\n        CUDA_CHECK(cudaHostAlloc((void**)&amp;z, bytes, cudaHostAllocMapped));\n\n\n    }\n\n\n}\ntemplate void AllocateMappedMemCPU&lt;int&gt;(int nx, int ny, int gpudevice, int*&amp; z);\ntemplate void AllocateMappedMemCPU&lt;float&gt;(int nx, int ny, int gpudevice, float*&amp; z);\ntemplate void AllocateMappedMemCPU&lt;double&gt;(int nx, int ny, int gpudevice, double*&amp; z);\n\ntemplate &lt;class T&gt; void AllocateMappedMemGPU(int nx, int ny, int gpudevice, T*&amp; z_g, T* z)\n{\n    CUDA_CHECK(cudaHostGetDevicePointer((void**)&amp;z_g, (void*)z, 0));\n}\ntemplate void AllocateMappedMemGPU&lt;int&gt;(int nx, int ny, int gpudevice, int*&amp; z_g, int* z);\ntemplate void AllocateMappedMemGPU&lt;float&gt;(int nx, int ny, int gpudevice,float*&amp; z_g, float* z);\ntemplate void AllocateMappedMemGPU&lt;double&gt;(int nx, int ny, int gpudevice, double*&amp; z_g, double* z);\n\n\ntemplate &lt;class T&gt; void AllocateGPU(int nx, int ny, T*&amp; z_g)\n{\n    CUDA_CHECK(cudaMalloc((void**)&amp; z_g, nx * ny * sizeof(T)));\n}\n\ntemplate &lt;class T&gt; void AllocateGPU(int nx, int ny, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v)\n{\n\n    AllocateGPU(nx, ny, zs);\n    AllocateGPU(nx, ny, h);\n    AllocateGPU(nx, ny, u);\n    AllocateGPU(nx, ny, v);\n\n}\ntemplate void AllocateGPU&lt;double&gt;(int nx, int ny, double*&amp; zs, double*&amp; h, double*&amp; u, double*&amp; v);\ntemplate void AllocateGPU&lt;float&gt;(int nx, int ny, float*&amp; zs, float*&amp; h, float*&amp; u, float*&amp; v);\ntemplate void AllocateGPU&lt;int&gt;(int nx, int ny, int*&amp; zs, int*&amp; h, int*&amp; u, int*&amp; v);\n\ntemplate &lt;class T&gt; void AllocateGPU(int nx, int ny, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v, T*&amp; U, T*&amp; hU)\n{\n\n    AllocateGPU(nx, ny, zs);\n    AllocateGPU(nx, ny, h);\n    AllocateGPU(nx, ny, u);\n    AllocateGPU(nx, ny, v);\n    AllocateGPU(nx, ny, U);\n    AllocateGPU(nx, ny, hU);\n\n}\ntemplate void AllocateGPU&lt;double&gt;(int nx, int ny, double*&amp; zs, double*&amp; h, double*&amp; u, double*&amp; v, double*&amp; U, double*&amp; hU);\ntemplate void AllocateGPU&lt;float&gt;(int nx, int ny, float*&amp; zs, float*&amp; h, float*&amp; u, float*&amp; v, float*&amp; U, float*&amp; hU);\ntemplate void AllocateGPU&lt;int&gt;(int nx, int ny, int*&amp; zs, int*&amp; h, int*&amp; u, int*&amp; v, int*&amp; U, int*&amp; hU);\n\ntemplate &lt;class T&gt; \nvoid AllocateGPU(int nx, int ny, GradientsP&lt;T&gt;&amp; Grad)\n{\n    AllocateGPU(nx, ny, Grad.dhdx, Grad.dzsdx, Grad.dudx, Grad.dvdx);\n    AllocateGPU(nx, ny, Grad.dhdy, Grad.dzsdy, Grad.dudy, Grad.dvdy);\n    AllocateGPU(nx, ny, Grad.dzbdy);\n    AllocateGPU(nx, ny, Grad.dzbdx);\n}\ntemplate void AllocateGPU&lt;float&gt;(int nx, int ny, GradientsP&lt;float&gt;&amp; Grad);\ntemplate void AllocateGPU&lt;double&gt;(int nx, int ny, GradientsP&lt;double&gt;&amp; Grad);\n\ntemplate &lt;class T&gt; void AllocateGPU(int nblk, int blksize, EvolvingP&lt;T&gt;&amp; Ev)\n{\n    AllocateGPU(nblk, blksize, Ev.h, Ev.zs, Ev.u, Ev.v);\n}\n\ntemplate &lt;class T&gt; void AllocateGPU(int nblk, int blksize, EvolvingP_M&lt;T&gt;&amp; Ev)\n{\n    AllocateGPU(nblk, blksize, Ev.h, Ev.zs, Ev.u, Ev.v, Ev.U, Ev.hU);\n}\n\ntemplate &lt;class T&gt;\nvoid AllocateGPU(int nblk, int blksize, Param XParam, Model&lt;T&gt;&amp; XModel)\n{\n    // Allocate blocks data \n    AllocateGPU(nblk, blksize, XModel.evolv);\n    AllocateGPU(nblk, blksize, XModel.evolv_o);\n\n    AllocateGPU(nblk, blksize, XModel.grad);\n    if (XParam.engine == 5)\n    {\n        AllocateGPU(nblk, blksize, XModel.fluxml.Fux, XModel.fluxml.Fvy, XModel.fluxml.hau, XModel.fluxml.hav);\n        AllocateGPU(nblk, blksize, XModel.fluxml.hfu, XModel.fluxml.hfv, XModel.fluxml.hu, XModel.fluxml.hv);\n        AllocateGPU(nblk, blksize, XModel.fluxml.Fuy);\n        AllocateGPU(nblk, blksize, XModel.fluxml.Fvx);\n    }\n    else\n    {\n        AllocateGPU(nblk, blksize, XModel.flux.Fhu, XModel.flux.Fhv, XModel.flux.Fqux, XModel.flux.Fquy);\n\n        AllocateGPU(nblk, blksize, XModel.flux.Fqvx, XModel.flux.Fqvy, XModel.flux.Su, XModel.flux.Sv);\n    }\n    AllocateGPU(nblk, blksize, XModel.zb, XModel.adv.dh, XModel.adv.dhu, XModel.adv.dhv);\n\n    AllocateGPU(nblk, blksize, XModel.cf, XModel.time.arrmax, XModel.time.arrmin, XModel.time.dtmax);\n\n\n    //Allocate block info\n    AllocateGPU(nblk, 1, XModel.blocks.active);\n    AllocateGPU(nblk, blksize, XModel.blocks.activeCell);\n    AllocateGPU(nblk, 1, XModel.blocks.level);\n\n    AllocateGPU(nblk, 1, XModel.blocks.BotLeft, XModel.blocks.BotRight, XModel.blocks.LeftBot, XModel.blocks.LeftTop);\n    AllocateGPU(nblk, 1, XModel.blocks.RightBot, XModel.blocks.RightTop, XModel.blocks.TopLeft, XModel.blocks.TopRight);\n\n    AllocateGPU(nblk, 1, XModel.blocks.xo);\n    AllocateGPU(nblk, 1, XModel.blocks.yo);\n\n    // If no adatptation ignore this!\n    /*\n    if (XParam.maxlevel != XParam.minlevel)\n    {\n        AllocateGPU(nblk, 1, XModel.adapt.availblk, XModel.adapt.csumblk, XModel.adapt.invactive, XModel.adapt.newlevel);\n        AllocateGPU(nblk, 1, XModel.adapt.coarsen);\n        AllocateGPU(nblk, 1, XModel.adapt.refine);\n    }\n    */\n\n\n\n    if (XParam.atmpforcing)\n    {\n        AllocateGPU(nblk, blksize, XModel.Patm);\n        AllocateGPU(nblk, blksize, XModel.datmpdx);\n        AllocateGPU(nblk, blksize, XModel.datmpdy);\n    }\n\n    if (XParam.infiltration)\n    {\n        AllocateGPU(nblk, blksize, XModel.il);\n        AllocateGPU(nblk, blksize, XModel.cl);\n        AllocateGPU(nblk, blksize, XModel.hgw);\n    }\n\n    if (XParam.outmax)\n    {\n        AllocateGPU(nblk, blksize, XModel.evmax);\n    }\n    if (XParam.outmean)\n    {\n        AllocateGPU(nblk, blksize, XModel.evmean);\n    }\n    if (XParam.outtwet)\n    {\n        AllocateGPU(nblk, blksize, XModel.wettime);\n    }\n\n\n    /*if (XParam.outvort)\n    {\n        AllocateGPU(nblk, blksize, XModel.vort);\n    }\n    if (XParam.outU)\n    {\n        AllocateGPU(nblk, blksize, XModel.U);\n    }*/\n\n    if (XParam.TSnodesout.size() &gt; 0)\n    {\n        // Timeseries output temporary storage\n        int storage = XParam.maxTSstorage;\n        AllocateGPU(storage, 1, XModel.TSstore);\n    }\n\n    // Allocate textures for boundary and forcing is done in init forcing\n\n\n\n}\n\ntemplate void AllocateGPU&lt;float&gt;(int nblk, int blksize, Param XParam, Model&lt;float&gt;&amp; XModel);\ntemplate void AllocateGPU&lt;double&gt;(int nblk, int blksize, Param XParam, Model&lt;double&gt;&amp; XModel);\n</code></pre>"},{"location":"BGFlood/_mem_management_8h/","title":"File MemManagement.h","text":""},{"location":"BGFlood/_mem_management_8h/#file-memmanagementh","title":"File MemManagement.h","text":"<p>FileList &gt; src &gt; MemManagement.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Setup_GPU.h\"</code></li> </ul>"},{"location":"BGFlood/_mem_management_8h/#public-functions","title":"Public Functions","text":"Type Name void AllocateCPU (int nx, int ny, T *&amp; zb) Allocate memory for a single array on the CPU. void AllocateCPU (int nx, int ny, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v) Allocate memory for multiple arrays (zs, h, u, v) on the CPU. void AllocateCPU (int nx, int ny, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v, T *&amp; U, T *&amp; hU) Allocate memory for extended arrays (zs, h, u, v, U, hU) on the CPU. void AllocateCPU (int nx, int ny, GradientsP&lt; T &gt; &amp; Grad) Allocate memory for gradient arrays on the CPU. void AllocateCPU (int nblk, int blksize, EvolvingP&lt; T &gt; &amp; Ev) Allocate memory for evolving variables on the CPU. void AllocateCPU (int nblk, int blksize, EvolvingP_M&lt; T &gt; &amp; Ev) Allocate memory for extended evolving variables on the CPU. void AllocateCPU (int nblk, int blksize, Param XParam, Model&lt; T &gt; &amp; XModel) Allocate all model arrays on the CPU. void AllocateGPU (int nblk, int blksize, Param XParam, Model&lt; T &gt; &amp; XModel) Allocate all model arrays on the GPU. void AllocateGPU (int nx, int ny, T *&amp; z_g) Allocate memory on the GPU for a single array. void AllocateMappedMemCPU (int nx, int ny, int gpudevice, T *&amp; z) Allocate mapped memory on the CPU for CUDA interop. void AllocateMappedMemGPU (int nx, int ny, int gpudevice, T *&amp; z_g, T * z) Get device pointer for mapped host memory. __host__ void FillCPU (int nx, int ny, T fillval, T *&amp; zb) Fill a CPU array with a specified value. void ReallocArray (int nblk, int blksize, T *&amp; zb) Reallocate memory for a single array. void ReallocArray (int nblk, int blksize, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v) Reallocate memory for multiple arrays (zs, h, u, v). void ReallocArray (int nblk, int blksize, T *&amp; zs, T *&amp; h, T *&amp; u, T *&amp; v, T *&amp; U, T *&amp; hU) Reallocate memory for extended arrays (zs, h, u, v, U, hU). void ReallocArray (int nblk, int blksize, EvolvingP&lt; T &gt; &amp; Ev) Reallocate memory for evolving variables structure. void ReallocArray (int nblk, int blksize, EvolvingP_M&lt; T &gt; &amp; Ev) Reallocate memory for extended evolving variables structure. void ReallocArray (int nblk, int blksize, Param XParam, Model&lt; T &gt; &amp; XModel) Reallocate all model arrays. int memloc (Param XParam, int i, int j, int ib) Compute memory index for a cell in a block (using Param ). __host__ __device__ int memloc (int halowidth, int blkmemwidth, int i, int j, int ib) Compute memory index for a cell in a block (using explicit sizes)."},{"location":"BGFlood/_mem_management_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_mem_management_8h/#function-allocatecpu","title":"function AllocateCPU","text":"<p>Allocate memory for a single array on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nx,\n    int ny,\n    T *&amp; zb\n) \n</code></pre> <p>Allocates memory for the given array and checks for allocation failure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or int) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>zb</code> Array to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-allocatecpu_1","title":"function AllocateCPU","text":"<p>Allocate memory for multiple arrays (zs, h, u, v) on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nx,\n    int ny,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v\n) \n</code></pre> <p>Allocates memory for the given arrays.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float, double, int) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>zs</code> Array to allocate </li> <li><code>h</code> Array to allocate </li> <li><code>u</code> Array to allocate </li> <li><code>v</code> Array to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-allocatecpu_2","title":"function AllocateCPU","text":"<p>Allocate memory for extended arrays (zs, h, u, v, U, hU) on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nx,\n    int ny,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v,\n    T *&amp; U,\n    T *&amp; hU\n) \n</code></pre> <p>Allocates memory for the given arrays.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float, double, int) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>zs</code> Array to allocate </li> <li><code>h</code> Array to allocate </li> <li><code>u</code> Array to allocate </li> <li><code>v</code> Array to allocate </li> <li><code>U</code> Array to allocate </li> <li><code>hU</code> Array to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-allocatecpu_3","title":"function AllocateCPU","text":"<p>Allocate memory for gradient arrays on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nx,\n    int ny,\n    GradientsP &lt; T &gt; &amp; Grad\n) \n</code></pre> <p>Allocates memory for all gradient arrays in GradientsP structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>Grad</code> GradientsP structure to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-allocatecpu_4","title":"function AllocateCPU","text":"<p>Allocate memory for evolving variables on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; T &gt; &amp; Ev\n) \n</code></pre> <p>Allocates memory for h, zs, u, v arrays in EvolvingP structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>Ev</code> EvolvingP structure to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-allocatecpu_5","title":"function AllocateCPU","text":"<p>Allocate memory for extended evolving variables on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; T &gt; &amp; Ev\n) \n</code></pre> <p>Allocates memory for h, zs, u, v, U, hU arrays in EvolvingP_M structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>Ev</code> EvolvingP_M structure to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-allocatecpu_6","title":"function AllocateCPU","text":"<p>Allocate all model arrays on the CPU. </p><pre><code>template&lt;class T&gt;\nvoid AllocateCPU (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Allocates memory for all arrays in the Model structure, including blocks, gradients, fluxes, and output buffers.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-allocategpu","title":"function AllocateGPU","text":"<p>Allocate all model arrays on the GPU. </p><pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Allocates device memory for all arrays in the Model structure, including blocks, gradients, fluxes, and output buffers.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure to allocate </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-allocategpu_1","title":"function AllocateGPU","text":"<p>Allocate memory on the GPU for a single array. </p><pre><code>template&lt;class T&gt;\nvoid AllocateGPU (\n    int nx,\n    int ny,\n    T *&amp; z_g\n) \n</code></pre> <p>Allocates device memory for the given array.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>z_g</code> Device pointer output </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-allocatemappedmemcpu","title":"function AllocateMappedMemCPU","text":"<p>Allocate mapped memory on the CPU for CUDA interop. </p><pre><code>template&lt;class T&gt;\nvoid AllocateMappedMemCPU (\n    int nx,\n    int ny,\n    int gpudevice,\n    T *&amp; z\n) \n</code></pre> <p>Allocates pinned or mapped memory for CUDA host-device interoperation.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>gpudevice</code> GPU device index </li> <li><code>z</code> Pointer to allocated memory </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-allocatemappedmemgpu","title":"function AllocateMappedMemGPU","text":"<p>Get device pointer for mapped host memory. </p><pre><code>template&lt;class T&gt;\nvoid AllocateMappedMemGPU (\n    int nx,\n    int ny,\n    int gpudevice,\n    T *&amp; z_g,\n    T * z\n) \n</code></pre> <p>Retrieves the device pointer for host memory mapped for CUDA interop.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>gpudevice</code> GPU device index </li> <li><code>z_g</code> Device pointer output </li> <li><code>z</code> Host pointer input </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-fillcpu","title":"function FillCPU","text":"<p>Fill a CPU array with a specified value. </p><pre><code>template&lt;class T&gt;\n__host__ void FillCPU (\n    int nx,\n    int ny,\n    T fillval,\n    T *&amp; zb\n) \n</code></pre> <p>Sets all elements of the array to the given fill value.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float, double, int) </li> </ul> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x elements </li> <li><code>ny</code> Number of y elements </li> <li><code>fillval</code> Value to fill </li> <li><code>zb</code> Array to fill </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-reallocarray","title":"function ReallocArray","text":"<p>Reallocate memory for a single array. </p><pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    T *&amp; zb\n) \n</code></pre> <p>Reallocates memory for the given array to match the new block and size.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>zb</code> Array to reallocate </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-reallocarray_1","title":"function ReallocArray","text":"<p>Reallocate memory for multiple arrays (zs, h, u, v). </p><pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v\n) \n</code></pre> <p>Reallocates memory for the given arrays to match the new block and size.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>zs</code> Array to reallocate </li> <li><code>h</code> Array to reallocate </li> <li><code>u</code> Array to reallocate </li> <li><code>v</code> Array to reallocate </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-reallocarray_2","title":"function ReallocArray","text":"<p>Reallocate memory for extended arrays (zs, h, u, v, U, hU). </p><pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    T *&amp; zs,\n    T *&amp; h,\n    T *&amp; u,\n    T *&amp; v,\n    T *&amp; U,\n    T *&amp; hU\n) \n</code></pre> <p>Reallocates memory for the given arrays to match the new block and size.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>zs</code> Array to reallocate </li> <li><code>h</code> Array to reallocate </li> <li><code>u</code> Array to reallocate </li> <li><code>v</code> Array to reallocate </li> <li><code>U</code> Array to reallocate </li> <li><code>hU</code> Array to reallocate </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-reallocarray_3","title":"function ReallocArray","text":"<p>Reallocate memory for evolving variables structure. </p><pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; T &gt; &amp; Ev\n) \n</code></pre> <p>Reallocates memory for all arrays in EvolvingP structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>Ev</code> EvolvingP structure to reallocate </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-reallocarray_4","title":"function ReallocArray","text":"<p>Reallocate memory for extended evolving variables structure. </p><pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; T &gt; &amp; Ev\n) \n</code></pre> <p>Reallocates memory for all arrays in EvolvingP_M structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>Ev</code> EvolvingP_M structure to reallocate </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-reallocarray_5","title":"function ReallocArray","text":"<p>Reallocate all model arrays. </p><pre><code>template&lt;class T&gt;\nvoid ReallocArray (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Reallocates memory for all arrays in the Model structure, including blocks, gradients, fluxes, and output buffers.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure to reallocate </li> </ul>"},{"location":"BGFlood/_mem_management_8h/#function-memloc","title":"function memloc","text":"<p>Compute memory index for a cell in a block (using Param ). </p><pre><code>int memloc (\n    Param XParam,\n    int i,\n    int j,\n    int ib\n) \n</code></pre> <p>Calculates the linear memory index for a cell in a block using model parameters.</p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>i</code> Cell x-index </li> <li><code>j</code> Cell y-index </li> <li><code>ib</code> Block index </li> </ul> <p>Returns:</p> <p>Linear memory index </p>"},{"location":"BGFlood/_mem_management_8h/#function-memloc_1","title":"function memloc","text":"<p>Compute memory index for a cell in a block (using explicit sizes). </p><pre><code>__host__ __device__ int memloc (\n    int halowidth,\n    int blkmemwidth,\n    int i,\n    int j,\n    int ib\n) \n</code></pre> <p>Calculates the linear memory index for a cell in a block using explicit halo and block sizes.</p> <p>Parameters:</p> <ul> <li><code>halowidth</code> Halo width </li> <li><code>blkmemwidth</code> Block memory width </li> <li><code>i</code> Cell x-index </li> <li><code>j</code> Cell y-index </li> <li><code>ib</code> Block index </li> </ul> <p>Returns:</p> <p>Linear memory index </p> <p>The documentation for this class was generated from the following file <code>src/MemManagement.h</code></p>"},{"location":"BGFlood/_mem_management_8h_source/","title":"File MemManagement.h","text":""},{"location":"BGFlood/_mem_management_8h_source/#file-memmanagementh","title":"File MemManagement.h","text":"<p>File List &gt; src &gt; MemManagement.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef MEMMANAGEMENT_H\n#define MEMMANAGEMENT_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Setup_GPU.h\"\n\n\ntemplate &lt;class T&gt; void AllocateCPU(int nx, int ny, T*&amp; zb);\ntemplate &lt;class T&gt; void AllocateCPU(int nx, int ny, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v);\ntemplate &lt;class T&gt; void AllocateCPU(int nx, int ny, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v, T*&amp; U, T*&amp; hU);\n\ntemplate &lt;class T&gt; void AllocateCPU(int nx, int ny, GradientsP&lt;T&gt;&amp; Grad);\ntemplate &lt;class T&gt; void AllocateCPU(int nblk, int blksize, EvolvingP&lt;T&gt; &amp;Ev);\ntemplate &lt;class T&gt; void AllocateCPU(int nblk, int blksize, EvolvingP_M&lt;T&gt;&amp; Ev);\ntemplate &lt;class T&gt; void AllocateCPU(int nblk, int blksize, Param XParam, Model&lt;T&gt;&amp; XModel);\n\n\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, T*&amp; zb);\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v);\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, T*&amp; zs, T*&amp; h, T*&amp; u, T*&amp; v, T*&amp; U, T*&amp; hU);\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, EvolvingP&lt;T&gt;&amp; Ev);\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, EvolvingP_M&lt;T&gt;&amp; Ev);\ntemplate &lt;class T&gt; void ReallocArray(int nblk, int blksize, Param XParam, Model&lt;T&gt;&amp; XModel);\n\ntemplate &lt;class T&gt; void AllocateMappedMemCPU(int nx, int ny, int gpudevice, T*&amp; z);\n\n\ntemplate &lt;class T&gt; __host__ void FillCPU(int nx, int ny, T fillval, T*&amp; zb);\n\nint memloc(Param XParam, int i, int j, int ib);\n//__device__ int memloc(int halowidth, int blkmemwidth, int  blksize, int i, int j, int ib);\n__host__ __device__ int memloc(int halowidth, int blkmemwidth, int i, int j, int ib);\n\ntemplate &lt;class T&gt; void AllocateGPU(int nblk, int blksize, Param XParam, Model&lt;T&gt;&amp; XModel);\ntemplate &lt;class T&gt; void AllocateGPU(int nx, int ny, T*&amp; z_g);\ntemplate &lt;class T&gt; void AllocateMappedMemGPU(int nx, int ny, int gpudevice, T*&amp; z_g, T* z);\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_mesh_8cu/","title":"File Mesh.cu","text":""},{"location":"BGFlood/_mesh_8cu/#file-meshcu","title":"File Mesh.cu","text":"<p>FileList &gt; src &gt; Mesh.cu</p> <p>Go to the source code of this file</p> <p>Mesh initialization and management routines for BG_Flood GPU model. More...</p> <ul> <li><code>#include \"Mesh.h\"</code></li> </ul>"},{"location":"BGFlood/_mesh_8cu/#public-functions","title":"Public Functions","text":"Type Name int CalcInitnblk (Param XParam, Forcing&lt; float &gt; XForcing) Calculates the initial number of blocks for the mesh. int CalcMaskblk (Param XParam, BlockP&lt; T &gt; XBlock) Calculates the number of blocks with masked neighbors (for boundary handling). template int CalcMaskblk&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock)  template int CalcMaskblk&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock)  void FindMaskblk (Param XParam, BlockP&lt; T &gt; &amp; XBlock) Identifies and stores blocks with masked sides for boundary processing. template void FindMaskblk&lt; double &gt; (Param XParam, BlockP&lt; double &gt; &amp; XBlock)  template void FindMaskblk&lt; float &gt; (Param XParam, BlockP&lt; float &gt; &amp; XBlock)  void InitBlockInfo (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; T &gt; &amp; XBlock) Initializes block information (active status, level, coordinates, neighbors). void InitBlockadapt (Param &amp; XParam, BlockP&lt; T &gt; XBlock, AdaptP &amp; XAdap) Initializes block adaptation arrays for mesh refinement/coarsening. template void InitBlockadapt&lt; double &gt; (Param &amp; XParam, BlockP&lt; double &gt; XBlock, AdaptP &amp; XAdap)  template void InitBlockadapt&lt; float &gt; (Param &amp; XParam, BlockP&lt; float &gt; XBlock, AdaptP &amp; XAdap)  void InitBlockneighbours (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; T &gt; &amp; XBlock) Initializes neighbor relationships for each block in a uniform mesh. template void InitBlockneighbours&lt; double &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; double &gt; &amp; XBlock)  template void InitBlockneighbours&lt; float &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; float &gt; &amp; XBlock)  void InitBlockxoyo (Param XParam, Forcing&lt; float &gt; XForcing, BlockP&lt; T &gt; &amp; XBlock) Initializes block coordinates and active status for the mesh. template void InitBlockxoyo&lt; double &gt; (Param XParam, Forcing&lt; float &gt; XForcing, BlockP&lt; double &gt; &amp; XBlockP)  template void InitBlockxoyo&lt; float &gt; (Param XParam, Forcing&lt; float &gt; XForcing, BlockP&lt; float &gt; &amp; XBlock)  void InitMesh (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel) Initializes the mesh and allocates memory for blocks. template void InitMesh&lt; double &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; double &gt; &amp; XModel)  template void InitMesh&lt; float &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; float &gt; &amp; XModel)"},{"location":"BGFlood/_mesh_8cu/#detailed-description","title":"Detailed Description","text":"<p>Contains functions for block-based mesh setup, memory allocation, block adaptation, and block neighbor initialization. </p>"},{"location":"BGFlood/_mesh_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_mesh_8cu/#function-calcinitnblk","title":"function CalcInitnblk","text":"<p>Calculates the initial number of blocks for the mesh. </p><pre><code>int CalcInitnblk (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters (resolution, block size, etc.) </li> <li><code>XForcing</code> Forcing data (bathymetry, AOI polygon, etc.) </li> </ul> <p>Returns:</p> <p>Number of blocks to allocate for the mesh.</p> <p>This function divides the domain into uniform blocks, checks masking and AOI, and counts blocks that are active for computation. </p>"},{"location":"BGFlood/_mesh_8cu/#function-calcmaskblk","title":"function CalcMaskblk","text":"<p>Calculates the number of blocks with masked neighbors (for boundary handling). </p><pre><code>template&lt;class T&gt;\nint CalcMaskblk (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> </ul> <p>Returns:</p> <p>Number of blocks with masked neighbors. </p>"},{"location":"BGFlood/_mesh_8cu/#function-calcmaskblk-double","title":"function CalcMaskblk&lt; double &gt;","text":"<pre><code>template int CalcMaskblk&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock\n) \n</code></pre>"},{"location":"BGFlood/_mesh_8cu/#function-calcmaskblk-float","title":"function CalcMaskblk&lt; float &gt;","text":"<pre><code>template int CalcMaskblk&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock\n) \n</code></pre>"},{"location":"BGFlood/_mesh_8cu/#function-findmaskblk","title":"function FindMaskblk","text":"<p>Identifies and stores blocks with masked sides for boundary processing. </p><pre><code>template&lt;class T&gt;\nvoid FindMaskblk (\n    Param XParam,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure</li> </ul> <p>Populates mask arrays for blocks with masked sides for later boundary condition handling. </p>"},{"location":"BGFlood/_mesh_8cu/#function-findmaskblk-double","title":"function FindMaskblk&lt; double &gt;","text":"<pre><code>template void FindMaskblk&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/_mesh_8cu/#function-findmaskblk-float","title":"function FindMaskblk&lt; float &gt;","text":"<pre><code>template void FindMaskblk&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/_mesh_8cu/#function-initblockinfo","title":"function InitBlockInfo","text":"<p>Initializes block information (active status, level, coordinates, neighbors). </p><pre><code>template&lt;class T&gt;\nvoid InitBlockInfo (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XBlock</code> Block data structure </li> </ul>"},{"location":"BGFlood/_mesh_8cu/#function-initblockadapt","title":"function InitBlockadapt","text":"<p>Initializes block adaptation arrays for mesh refinement/coarsening. </p><pre><code>template&lt;class T&gt;\nvoid InitBlockadapt (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; XBlock,\n    AdaptP &amp; XAdap\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XAdap</code> Adaptation data structure </li> </ul>"},{"location":"BGFlood/_mesh_8cu/#function-initblockadapt-double","title":"function InitBlockadapt&lt; double &gt;","text":"<pre><code>template void InitBlockadapt&lt; double &gt; (\n    Param &amp; XParam,\n    BlockP &lt; double &gt; XBlock,\n    AdaptP &amp; XAdap\n) \n</code></pre>"},{"location":"BGFlood/_mesh_8cu/#function-initblockadapt-float","title":"function InitBlockadapt&lt; float &gt;","text":"<pre><code>template void InitBlockadapt&lt; float &gt; (\n    Param &amp; XParam,\n    BlockP &lt; float &gt; XBlock,\n    AdaptP &amp; XAdap\n) \n</code></pre>"},{"location":"BGFlood/_mesh_8cu/#function-initblockneighbours","title":"function InitBlockneighbours","text":"<p>Initializes neighbor relationships for each block in a uniform mesh. </p><pre><code>template&lt;class T&gt;\nvoid InitBlockneighbours (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XBlock</code> Block data structure</li> </ul> <p>Sets up neighbor indices for each block (left, right, top, bottom, corners). </p>"},{"location":"BGFlood/_mesh_8cu/#function-initblockneighbours-double","title":"function InitBlockneighbours&lt; double &gt;","text":"<pre><code>template void InitBlockneighbours&lt; double &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; double &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/_mesh_8cu/#function-initblockneighbours-float","title":"function InitBlockneighbours&lt; float &gt;","text":"<pre><code>template void InitBlockneighbours&lt; float &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; float &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/_mesh_8cu/#function-initblockxoyo","title":"function InitBlockxoyo","text":"<p>Initializes block coordinates and active status for the mesh. </p><pre><code>template&lt;class T&gt;\nvoid InitBlockxoyo (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XBlock</code> Block data structure</li> </ul> <p>Sets block coordinates and marks active blocks based on mask and AOI polygon. Loops over all blocks, checks if each block is inside the area of interest (AOI), and if the mask threshold is met, sets the block as active and stores its coordinates. </p>"},{"location":"BGFlood/_mesh_8cu/#function-initblockxoyo-double","title":"function InitBlockxoyo&lt; double &gt;","text":"<pre><code>template void InitBlockxoyo&lt; double &gt; (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    BlockP &lt; double &gt; &amp; XBlockP\n) \n</code></pre>"},{"location":"BGFlood/_mesh_8cu/#function-initblockxoyo-float","title":"function InitBlockxoyo&lt; float &gt;","text":"<pre><code>template void InitBlockxoyo&lt; float &gt; (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    BlockP &lt; float &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/_mesh_8cu/#function-initmesh","title":"function InitMesh","text":"<p>Initializes the mesh and allocates memory for blocks. </p><pre><code>template&lt;class T&gt;\nvoid InitMesh (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XModel</code> Model structure to hold mesh and block data</li> </ul> <p>Allocates memory, initializes block info, adaptation info, and boundary masks. </p>"},{"location":"BGFlood/_mesh_8cu/#function-initmesh-double","title":"function InitMesh&lt; double &gt;","text":"<pre><code>template void InitMesh&lt; double &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_mesh_8cu/#function-initmesh-float","title":"function InitMesh&lt; float &gt;","text":"<pre><code>template void InitMesh&lt; float &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Mesh.cu</code></p>"},{"location":"BGFlood/_mesh_8cu_source/","title":"File Mesh.cu","text":""},{"location":"BGFlood/_mesh_8cu_source/#file-meshcu","title":"File Mesh.cu","text":"<p>File List &gt; src &gt; Mesh.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //    \n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n\n#include \"Mesh.h\"\n\nint CalcInitnblk(Param XParam, Forcing&lt;float&gt; XForcing)\n{\n\n    // Rearrange the memory in uniform blocks\n\n\n    //max nb of blocks is ceil(nx/16)*ceil(ny/16)\n    int nblk = 0;\n    int nmask = 0;\n    //int mloc = 0;\n\n    bool insidepoly = false;\n\n    double levdx = calcres(XParam.dx, XParam.initlevel);\n\n    int maxnbx = ftoi(ceil(XParam.nx / (double)XParam.blkwidth));\n    int maxnby = ftoi(ceil(XParam.ny / (double)XParam.blkwidth));\n\n    for (int nblky = 0; nblky &lt; maxnby; nblky++)\n    {\n        for (int nblkx = 0; nblkx &lt; maxnbx; nblkx++)\n        {\n            insidepoly = true;\n            if (XForcing.AOI.active)\n            {\n                insidepoly = blockinpoly(XParam.xo + nblkx * XParam.blkwidth * levdx, XParam.yo + nblky * XParam.blkwidth * levdx, levdx, XParam.blkwidth, XForcing.AOI.poly);\n            }\n            nmask = 0;\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                for (int j = 0; j &lt; XParam.blkwidth; j++)\n                {\n                    double x = XParam.xo + (double(i) + (double)XParam.blkwidth * (double)nblkx) * levdx + 0.5 * levdx;\n                    double y = XParam.yo + (double(j) + (double)XParam.blkwidth * (double)nblky) * levdx + 0.5 * levdx;\n\n                    //if (x &gt;= XForcing.Bathy.xo &amp;&amp; x &lt;= XForcing.Bathy.xmax &amp;&amp; y &gt;= XForcing.Bathy.yo &amp;&amp; y &lt;= XForcing.Bathy.ymax)\n                    {\n                        // cells that falls off this domain are assigned\n                        double x1, x2, y1, y2;\n                        double q11, q12, q21, q22, q;\n                        int cfi, cfip, cfj, cfjp;\n\n                        x = utils::max(utils::min(x, XForcing.Bathy[0].xmax), XForcing.Bathy[0].xo);\n                        y = utils::max(utils::min(y, XForcing.Bathy[0].ymax), XForcing.Bathy[0].yo);\n\n                        cfi = utils::min(utils::max((int)floor((x - XForcing.Bathy[0].xo) / XForcing.Bathy[0].dx), 0), XForcing.Bathy[0].nx - 2);\n                        cfip = cfi + 1;\n\n                        x1 = XForcing.Bathy[0].xo + XForcing.Bathy[0].dx * cfi;\n                        x2 = XForcing.Bathy[0].xo + XForcing.Bathy[0].dx * cfip;\n\n                        cfj = utils::min(utils::max((int)floor((y - XForcing.Bathy[0].yo) / XForcing.Bathy[0].dx), 0), XForcing.Bathy[0].ny - 2);\n                        cfjp = cfj + 1;\n\n                        y1 = XForcing.Bathy[0].yo + XForcing.Bathy[0].dx * cfj;\n                        y2 = XForcing.Bathy[0].yo + XForcing.Bathy[0].dx * cfjp;\n\n                        q11 = XForcing.Bathy[0].val[cfi + cfj * XForcing.Bathy[0].nx];\n                        q12 = XForcing.Bathy[0].val[cfi + cfjp * XForcing.Bathy[0].nx];\n                        q21 = XForcing.Bathy[0].val[cfip + cfj * XForcing.Bathy[0].nx];\n                        q22 = XForcing.Bathy[0].val[cfip + cfjp * XForcing.Bathy[0].nx];\n\n                        q = BilinearInterpolation(q11, q12, q21, q22, x1, x2, y1, y2, x, y);\n                        //printf(\"q = %f\\n\", q);\n                        //printf(\"mloc: %i\\n\", mloc);\n                        if (q &gt;= XParam.mask)\n                            nmask++;\n                    }\n                    //else\n                    //{\n                        //computational domnain is outside of the bathy domain\n                    //}\n\n                }\n            }\n            if ((nmask &lt; (XParam.blkwidth* XParam.blkwidth)) &amp;&amp; insidepoly)\n                nblk++;\n        }\n    }\n\n    return nblk;\n}\n\ntemplate &lt;class T&gt;\nvoid InitMesh(Param &amp;XParam, Forcing&lt;float&gt; &amp; XForcing, Model&lt;T&gt; &amp;XModel)\n{\n    //=============================\n    // Calculate an initial number of block\n\n    log(\"\\nInitializing mesh\");\n    int nblk;\n\n    nblk = CalcInitnblk(XParam, XForcing);\n\n    XParam.nblk = nblk;\n    // allocate a few extra blocks for adaptation\n    XParam.nblkmem = (int)ceil(nblk * XParam.membuffer); //5% buffer on the memory for adaptation \n\n    log(\"\\tInitial number of blocks: \" + std::to_string(nblk) + \"; Will be allocating \" + std::to_string(XParam.nblkmem) + \" in memory.\");\n\n    //==============================\n    // Allocate CPU memory for the whole model\n    AllocateCPU(XParam.nblkmem, XParam.blksize, XParam, XModel);\n\n\n    //==============================\n    // Initialise blockinfo info\n    InitBlockInfo(XParam, XForcing, XModel.blocks);\n\n    //==============================\n    // Init. adaptation info if needed\n    if (XParam.maxlevel != XParam.minlevel)\n    {\n\n        InitBlockadapt(XParam, XModel.blocks, XModel.adapt);\n    }\n\n    //==============================\n    // Reallocate array containing boundary blocks\n\n    //==============================\n    // Add mask block info (flag the block with at least one empty neighbour that is not boundary)\n    FindMaskblk(XParam, XModel.blocks);\n\n\n}\n\ntemplate void InitMesh&lt;float&gt;(Param &amp;XParam, Forcing&lt;float&gt;&amp; XForcing, Model&lt;float&gt; &amp;XModel);\ntemplate void InitMesh&lt;double&gt;(Param &amp;XParam, Forcing&lt;float&gt;&amp; XForcing, Model&lt;double&gt; &amp;XModel);\n\ntemplate &lt;class T&gt; void InitBlockInfo(Param &amp;XParam, Forcing&lt;float&gt; &amp;XForcing, BlockP&lt;T&gt;&amp; XBlock)\n{\n    //============================\n    // Init active and level\n\n    // Initialise activeblk array as all inactive ( = -1 )\n    // Here we cannot yet use the InitBlkBUQ function since none of the blk are active\n    //InitBlkBUQ(XParam, XBlock, XParam.initlevel, XBlock.level)\n    for (int ib = 0; ib &lt; XParam.nblkmem; ib++)\n    {\n        XBlock.active[ib] = -1;\n        XBlock.level[ib] = XParam.initlevel;\n    }\n\n\n\n    //============================\n    // Init xo, yo and active blk\n    InitBlockxoyo(XParam, XForcing, XBlock);\n\n    //============================\n    // Init neighbours\n    InitBlockneighbours(XParam, XForcing, XBlock);\n    //Calcbndblks(XParam, XForcing, XBlock);\n\n}\n\ntemplate &lt;class T&gt; void InitBlockadapt(Param &amp;XParam, BlockP&lt;T&gt; XBlock, AdaptP&amp; XAdap)\n{\n        InitBlkBUQ(XParam, XBlock, XParam.initlevel, XAdap.newlevel);\n        InitBlkBUQ(XParam, XBlock, false, XAdap.coarsen);\n        InitBlkBUQ(XParam, XBlock, false, XAdap.refine);\n        //InitBlkBUQ(XParam, XBlock, XParam.initlevel, XBlock.level);\n        //InitBlkBUQ(XParam, XBlock, XParam.initlevel, XBlock.level);\n        //InitArrayBUQ(XParam.nblkmem, 1, 0, XParam.initlevel, XAdap.newlevel);\n        //InitArrayBUQ(XParam.nblkmem, 1, 0, false, XAdap.coarsen);\n        //InitArrayBUQ(XParam.nblkmem, 1, 0, false, XAdap.refine);\n\n\n        for (int ibl = 0; ibl &lt; (XParam.nblkmem - XParam.nblk); ibl++)\n        {\n\n            XAdap.availblk[ibl] = XParam.nblk + ibl;\n            XParam.navailblk++;\n\n        }\n\n}\ntemplate void InitBlockadapt&lt;float&gt;(Param &amp;XParam, BlockP&lt;float&gt; XBlock, AdaptP&amp; XAdap);\ntemplate void InitBlockadapt&lt;double&gt;(Param &amp;XParam, BlockP&lt;double&gt; XBlock, AdaptP&amp; XAdap);\n\n\n\ntemplate &lt;class T&gt; void InitBlockxoyo(Param XParam, Forcing&lt;float&gt; XForcing, BlockP&lt;T&gt; &amp;XBlock)\n{\n\n    int nmask = 0;\n    //mloc = 0;\n    int blkid = 0;\n    double levdx = calcres(XParam.dx, XParam.initlevel);\n\n    bool insidepoly = true;\n\n    int maxnbx = ftoi(ceil(XParam.nx / (double)XParam.blkwidth));\n    int maxnby = ftoi(ceil(XParam.ny / (double)XParam.blkwidth));\n\n    for (int nblky = 0; nblky &lt; maxnby; nblky++)\n    {\n        for (int nblkx = 0; nblkx &lt; maxnbx; nblkx++)\n        {\n            insidepoly = true;\n            if (XForcing.AOI.active)\n            {\n                insidepoly = blockinpoly(XParam.xo + nblkx * XParam.blkwidth * levdx, XParam.yo + nblky * XParam.blkwidth * levdx, levdx, XParam.blkwidth, XForcing.AOI.poly);\n            }\n            nmask = 0;\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                for (int j = 0; j &lt; XParam.blkwidth; j++)\n                {\n                    double x = XParam.xo + (double(i) + (T)XParam.blkwidth * (T)nblkx)*levdx + 0.5 * levdx;\n                    double y = XParam.yo + (double(j) + (T)XParam.blkwidth * (T)nblky)*levdx + 0.5 * levdx;\n\n                    int n = memloc(XParam, i, j, blkid);\n\n                    //x = max(min(x, XParam.Bathymetry.xmax), XParam.Bathymetry.xo);\n                    //y = max(min(y, XParam.Bathymetry.ymax), XParam.Bathymetry.yo);\n\n                    {\n                        x = utils::max(utils::min(x, XForcing.Bathy[0].xmax), XForcing.Bathy[0].xo);\n                        y = utils::max(utils::min(y, XForcing.Bathy[0].ymax), XForcing.Bathy[0].yo);\n                        // cells that falls off this domain are assigned\n                        double x1, x2, y1, y2;\n                        double q11, q12, q21, q22, q;\n                        int cfi, cfip, cfj, cfjp;\n\n\n\n                        cfi = utils::min(utils::max((int)floor((x - XForcing.Bathy[0].xo) / XForcing.Bathy[0].dx), 0), XForcing.Bathy[0].nx - 2);\n                        cfip = cfi + 1;\n\n                        x1 = XForcing.Bathy[0].xo + XForcing.Bathy[0].dx*cfi;\n                        x2 = XForcing.Bathy[0].xo + XForcing.Bathy[0].dx*cfip;\n\n                        cfj = utils::min(utils::max((int)floor((y - XForcing.Bathy[0].yo) / XForcing.Bathy[0].dx), 0), XForcing.Bathy[0].ny - 2);\n                        cfjp = cfj + 1;\n\n                        y1 = XForcing.Bathy[0].yo + XForcing.Bathy[0].dx*cfj;\n                        y2 = XForcing.Bathy[0].yo + XForcing.Bathy[0].dx*cfjp;\n\n                        q11 = XForcing.Bathy[0].val[cfi + cfj*XForcing.Bathy[0].nx];\n                        q12 = XForcing.Bathy[0].val[cfi + cfjp*XForcing.Bathy[0].nx];\n                        q21 = XForcing.Bathy[0].val[cfip + cfj*XForcing.Bathy[0].nx];\n                        q22 = XForcing.Bathy[0].val[cfip + cfjp*XForcing.Bathy[0].nx];\n\n                        q = BilinearInterpolation(q11, q12, q21, q22, x1, x2, y1, y2, x, y);\n                        //printf(\"q = %f\\t q11=%f\\t, q12=%f\\t, q21=%f\\t, q22=%f\\t, x1=%f\\t, x2=%f\\t, y1=%f\\t, y2=%f\\t, x=%f\\t, y=%f\\t\\n\", q, q11, q12, q21, q22, x1, x2, y1, y2, x, y);\n                        //printf(\"mloc: %i\\n\", mloc);\n                        if (q &gt;= XParam.mask)\n                        {\n                            nmask++;\n\n                        }\n                    }\n\n\n                }\n            }\n            if ((nmask &lt; (XParam.blkwidth * XParam.blkwidth)) &amp;&amp; insidepoly)\n            {\n                //\n                XBlock.xo[blkid] = nblkx * ((T)XParam.blkwidth) * (T)levdx + T(0.5) * (T)levdx;\n                XBlock.yo[blkid] = nblky * ((T)XParam.blkwidth) * (T)levdx + T(0.5) * (T)levdx;\n                XBlock.active[blkid] = blkid;\n                //printf(\"blkxo=%f\\tblkyo=%f\\n\", blockxo_d[blkid], blockyo_d[blkid]);\n                blkid++;\n            }\n        }\n    }\n\n\n\n\n}\ntemplate void InitBlockxoyo&lt;float&gt;(Param XParam, Forcing&lt;float&gt; XForcing, BlockP&lt;float&gt; &amp;XBlock);\ntemplate void InitBlockxoyo&lt;double&gt;(Param XParam, Forcing&lt;float&gt; XForcing, BlockP&lt;double&gt; &amp; XBlockP);\n\ntemplate &lt;class T&gt; void InitBlockneighbours(Param &amp;XParam,Forcing&lt;float&gt; &amp;XForcing,  BlockP&lt;T&gt;&amp; XBlock)\n{\n    // This function will only work if the blocks are uniform\n    // A separate function is used for adaptivity\n    T leftxo, rightxo, topxo, botxo, leftyo, rightyo, topyo, botyo;\n\n    //====================================\n    // First setp up neighbours\n\n    double levdx = calcres(XParam.dx, XParam.initlevel);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n\n        int bl = XBlock.active[ibl];\n        //T espdist = std::numeric_limits&lt;T&gt;::epsilon() * (T)100.0; // i.e. distances are calculated within 100x theoretical machine precision\n        // This too theoretical error definition has been modified to allow more flexibility\n        T espdist = (T)levdx/3;\n\n\n        leftxo = XBlock.xo[bl] - ((T)XParam.blkwidth) * (T)levdx;\n\n        leftyo = XBlock.yo[bl];\n        rightxo = XBlock.xo[bl] + ((T)XParam.blkwidth) * (T)levdx;\n        rightyo = XBlock.yo[bl];\n        topxo = XBlock.xo[bl];\n        topyo = XBlock.yo[bl] + ((T)XParam.blkwidth) * (T)levdx;\n        botxo = XBlock.xo[bl];\n        botyo = XBlock.yo[bl] - ((T)XParam.blkwidth) * (T)levdx;\n\n        // by default neighbour block refer to itself. i.e. if the neighbour block is itself then there are no neighbour\n        XBlock.LeftBot[bl] = bl;\n        XBlock.LeftTop[bl] = bl;\n        XBlock.RightBot[bl] = bl;\n        XBlock.RightTop[bl] = bl;\n        XBlock.TopLeft[bl] = bl;\n        XBlock.TopRight[bl] = bl;\n        XBlock.BotLeft[bl] = bl;\n        XBlock.BotRight[bl] = bl;\n\n\n        for (int iblb = 0; iblb &lt; XParam.nblk; iblb++)\n        {\n            //\n            int blb = XBlock.active[iblb];\n            if (abs(XBlock.xo[blb] - leftxo) &lt; espdist &amp;&amp; abs(XBlock.yo[blb] - leftyo) &lt; espdist)\n            {\n                XBlock.LeftBot[bl] = blb;\n                XBlock.LeftTop[bl] = blb;\n            }\n            if (abs(XBlock.xo[blb] - rightxo) &lt; espdist &amp;&amp; abs(XBlock.yo[blb] - rightyo) &lt; espdist)\n            {\n                XBlock.RightBot[bl] = blb;\n                XBlock.RightTop[bl] = blb;\n            }\n            if (abs(XBlock.xo[blb] - topxo) &lt; espdist &amp;&amp; abs(XBlock.yo[blb] - topyo) &lt; espdist)\n            {\n                XBlock.TopLeft[bl] = blb;\n                XBlock.TopRight[bl] = blb;\n\n            }\n            if (abs(XBlock.xo[blb] - botxo) &lt; espdist &amp;&amp; abs(XBlock.yo[blb] - botyo) &lt; espdist)\n            {\n                XBlock.BotLeft[bl] = blb;\n                XBlock.BotRight[bl] = blb;\n            }\n        }\n    }\n\n\n\n    //\n\n\n}\ntemplate void InitBlockneighbours&lt;float&gt;(Param &amp;XParam,  Forcing&lt;float&gt;&amp; XForcing, BlockP&lt;float&gt;&amp; XBlock);\ntemplate void InitBlockneighbours&lt;double&gt;(Param &amp;XParam, Forcing&lt;float&gt;&amp; XForcing, BlockP&lt;double&gt;&amp; XBlock);\n\n\n\ntemplate &lt;class T&gt; int CalcMaskblk(Param XParam, BlockP&lt;T&gt; XBlock)\n{\n    int nmask = 0;\n    bool neighbourmask = false;\n    T leftxo, rightxo, topyo,  botyo;\n    T initlevdx = calcres((T)XParam.dx, XParam.initlevel);\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        T levdx = calcres((T)XParam.dx, XBlock.level[ib]);\n\n        leftxo = XBlock.xo[ib]; // in adaptive this shoulbe be a range \n\n        //leftyo = XBlock.yo[ib];\n        rightxo = XBlock.xo[ib] + (XParam.blkwidth - 1) * levdx;\n        //rightyo = XBlock.yo[ib];\n        //topxo = XBlock.xo[ib];\n        topyo = XBlock.yo[ib] + (XParam.blkwidth - 1) * levdx;\n        //botxo = XBlock.xo[ib];\n        botyo = XBlock.yo[ib];\n\n        neighbourmask = false;\n\n        if ((XBlock.LeftBot[ib] == ib || XBlock.LeftTop[ib] == ib) &amp;&amp; leftxo &gt; levdx)\n        {\n            neighbourmask = true;\n        }\n        if ((XBlock.BotLeft[ib] == ib || XBlock.BotRight[ib] == ib) &amp;&amp; botyo &gt; levdx)\n        {\n            neighbourmask = true;\n        }\n        if ((XBlock.TopLeft[ib] == ib || XBlock.TopRight[ib] == ib) &amp;&amp; ((topyo - (XParam.ymax - XParam.yo)) &lt; (-1.0 * levdx)))\n        {\n            neighbourmask = true;\n        }\n        if ((XBlock.RightBot[ib] == ib || XBlock.RightBot[ib] == ib) &amp;&amp; ((rightxo - (XParam.xmax - XParam.xo)) &lt; (-1.0 * levdx)))\n        {\n            neighbourmask = true;\n        }\n\n        int nadd = neighbourmask ? 1 : 0;\n\n        nmask = nmask + nadd;\n\n    }\n\n    return nmask;\n}\ntemplate int CalcMaskblk&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock);\ntemplate int CalcMaskblk&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock);\n\n\n\ntemplate &lt;class T&gt; void FindMaskblk(Param XParam, BlockP&lt;T&gt; &amp;XBlock)\n{\n\n    XBlock.mask.nblk = CalcMaskblk(XParam, XBlock);\n    if (XBlock.mask.nblk &gt; 0)\n    {\n        int nmask = 0;\n        bool neighbourmask = false;\n        T leftxo, rightxo,  topyo, botyo;\n\n        // Reallocate array if necessary\n        ReallocArray(XBlock.mask.nblk, 1, XBlock.mask.side);\n        ReallocArray(XBlock.mask.nblk, 1, XBlock.mask.blks);\n\n\n        for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n        {\n            int ib = XBlock.active[ibl];\n            T levdx = calcres((T)XParam.dx, XBlock.level[ib]);\n\n            leftxo = XBlock.xo[ib]; // in adaptive this shoulbe be a range \n\n            //leftyo = XBlock.yo[ib];\n            rightxo = XBlock.xo[ib] + (XParam.blkwidth - 1) * levdx;\n            //rightyo = XBlock.yo[ib];\n            //topxo = XBlock.xo[ib];\n            topyo = XBlock.yo[ib] + (XParam.blkwidth - 1) * levdx;\n            //botxo = XBlock.xo[ib];\n            botyo = XBlock.yo[ib];\n\n            neighbourmask = false;\n\n            if (nmask &lt; XBlock.mask.nblk)\n            {\n                XBlock.mask.side[nmask] = 0b00000000;\n            }\n\n\n            if ((XBlock.LeftBot[ib] == ib || XBlock.LeftTop[ib] == ib) &amp;&amp; leftxo &gt; levdx)\n            {\n                XBlock.mask.blks[nmask] = ib;\n\n                if (XBlock.LeftBot[ib] == ib)\n                {\n                    XBlock.mask.side[nmask] = XBlock.mask.side[nmask] | 0b10000000;\n                }\n                if (XBlock.LeftTop[ib] == ib)\n                {\n                    XBlock.mask.side[nmask] = XBlock.mask.side[nmask] | 0b01000000;\n                }\n                neighbourmask = true;\n            }\n\n            if ((XBlock.TopLeft[ib] == ib || XBlock.TopRight[ib] == ib) &amp;&amp; ((topyo - (XParam.ymax - XParam.yo)) &lt; (-1.0 * levdx)))\n            {\n                XBlock.mask.blks[nmask] = ib;\n                if (XBlock.TopLeft[ib] == ib)\n                {\n                    XBlock.mask.side[nmask] = XBlock.mask.side[nmask] | 0b00100000;\n                }\n                if (XBlock.TopRight[ib] == ib)\n                {\n                    XBlock.mask.side[nmask] = XBlock.mask.side[nmask] | 0b00010000;\n                }\n\n                neighbourmask = true;\n            }\n            if ((XBlock.RightBot[ib] == ib || XBlock.RightBot[ib] == ib) &amp;&amp; ((rightxo - (XParam.xmax - XParam.xo)) &lt; (-1.0 * levdx)))\n            {\n                XBlock.mask.blks[nmask] = ib;\n                if (XBlock.RightTop[ib] == ib)\n                {\n                    XBlock.mask.side[nmask] = XBlock.mask.side[nmask] | 0b00001000;\n                }\n                if (XBlock.RightBot[ib] == ib)\n                {\n                    XBlock.mask.side[nmask] = XBlock.mask.side[nmask] | 0b00000100;\n                }\n                neighbourmask = true;\n            }\n            if ((XBlock.BotLeft[ib] == ib || XBlock.BotRight[ib] == ib) &amp;&amp; botyo &gt; levdx)\n            {\n                XBlock.mask.blks[nmask] = ib;\n                if (XBlock.BotRight[ib] == ib)\n                {\n                    XBlock.mask.side[nmask] = XBlock.mask.side[nmask] | 0b00000010;\n                }\n                if (XBlock.BotLeft[ib] == ib)\n                {\n                    XBlock.mask.side[nmask] = XBlock.mask.side[nmask] | 0b00000001;\n                }\n                neighbourmask = true;\n            }\n\n            int nadd = neighbourmask ? 1 : 0;\n\n            nmask = nmask + nadd;\n\n        }\n    }\n}\ntemplate void FindMaskblk&lt;float&gt;(Param XParam, BlockP&lt;float&gt; &amp;XBlock);\ntemplate void FindMaskblk&lt;double&gt;(Param XParam, BlockP&lt;double&gt; &amp;XBlock);\n</code></pre>"},{"location":"BGFlood/_mesh_8h/","title":"File Mesh.h","text":""},{"location":"BGFlood/_mesh_8h/#file-meshh","title":"File Mesh.h","text":"<p>FileList &gt; src &gt; Mesh.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"GridManip.h\"</code></li> <li><code>#include \"Poly.h\"</code></li> </ul>"},{"location":"BGFlood/_mesh_8h/#public-functions","title":"Public Functions","text":"Type Name int CalcInitnblk (Param XParam, Forcing&lt; float &gt; XForcing) Calculates the initial number of blocks for the mesh. int CalcMaskblk (Param XParam, BlockP&lt; T &gt; XBlock) Calculates the number of blocks with masked neighbors (for boundary handling). void FindMaskblk (Param XParam, BlockP&lt; T &gt; &amp; XBlock) Identifies and stores blocks with masked sides for boundary processing. void InitBlockInfo (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; T &gt; &amp; XBlock) Initializes block information (active status, level, coordinates, neighbors). void InitBlockadapt (Param &amp; XParam, BlockP&lt; T &gt; XBlock, AdaptP &amp; XAdap) Initializes block adaptation arrays for mesh refinement/coarsening. void InitBlockneighbours (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, BlockP&lt; T &gt; &amp; XBlock) Initializes neighbor relationships for each block in a uniform mesh. void InitBlockxoyo (Param XParam, Forcing&lt; float &gt; XForcing, BlockP&lt; T &gt; &amp; XBlock) Initializes block coordinates and active status for the mesh. void InitMesh (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel) Initializes the mesh and allocates memory for blocks."},{"location":"BGFlood/_mesh_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_mesh_8h/#function-calcinitnblk","title":"function CalcInitnblk","text":"<p>Calculates the initial number of blocks for the mesh. </p><pre><code>int CalcInitnblk (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters (resolution, block size, etc.) </li> <li><code>XForcing</code> Forcing data (bathymetry, AOI polygon, etc.) </li> </ul> <p>Returns:</p> <p>Number of blocks to allocate for the mesh.</p> <p>This function divides the domain into uniform blocks, checks masking and AOI, and counts blocks that are active for computation. </p>"},{"location":"BGFlood/_mesh_8h/#function-calcmaskblk","title":"function CalcMaskblk","text":"<p>Calculates the number of blocks with masked neighbors (for boundary handling). </p><pre><code>template&lt;class T&gt;\nint CalcMaskblk (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> </ul> <p>Returns:</p> <p>Number of blocks with masked neighbors. </p>"},{"location":"BGFlood/_mesh_8h/#function-findmaskblk","title":"function FindMaskblk","text":"<p>Identifies and stores blocks with masked sides for boundary processing. </p><pre><code>template&lt;class T&gt;\nvoid FindMaskblk (\n    Param XParam,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure</li> </ul> <p>Populates mask arrays for blocks with masked sides for later boundary condition handling. </p>"},{"location":"BGFlood/_mesh_8h/#function-initblockinfo","title":"function InitBlockInfo","text":"<p>Initializes block information (active status, level, coordinates, neighbors). </p><pre><code>template&lt;class T&gt;\nvoid InitBlockInfo (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XBlock</code> Block data structure </li> </ul>"},{"location":"BGFlood/_mesh_8h/#function-initblockadapt","title":"function InitBlockadapt","text":"<p>Initializes block adaptation arrays for mesh refinement/coarsening. </p><pre><code>template&lt;class T&gt;\nvoid InitBlockadapt (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; XBlock,\n    AdaptP &amp; XAdap\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>XAdap</code> Adaptation data structure </li> </ul>"},{"location":"BGFlood/_mesh_8h/#function-initblockneighbours","title":"function InitBlockneighbours","text":"<p>Initializes neighbor relationships for each block in a uniform mesh. </p><pre><code>template&lt;class T&gt;\nvoid InitBlockneighbours (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XBlock</code> Block data structure</li> </ul> <p>Sets up neighbor indices for each block (left, right, top, bottom, corners). </p>"},{"location":"BGFlood/_mesh_8h/#function-initblockxoyo","title":"function InitBlockxoyo","text":"<p>Initializes block coordinates and active status for the mesh. </p><pre><code>template&lt;class T&gt;\nvoid InitBlockxoyo (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XBlock</code> Block data structure</li> </ul> <p>Sets block coordinates and marks active blocks based on mask and AOI polygon. Loops over all blocks, checks if each block is inside the area of interest (AOI), and if the mask threshold is met, sets the block as active and stores its coordinates. </p>"},{"location":"BGFlood/_mesh_8h/#function-initmesh","title":"function InitMesh","text":"<p>Initializes the mesh and allocates memory for blocks. </p><pre><code>template&lt;class T&gt;\nvoid InitMesh (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data </li> <li><code>XModel</code> Model structure to hold mesh and block data</li> </ul> <p>Allocates memory, initializes block info, adaptation info, and boundary masks. </p> <p>The documentation for this class was generated from the following file <code>src/Mesh.h</code></p>"},{"location":"BGFlood/_mesh_8h_source/","title":"File Mesh.h","text":""},{"location":"BGFlood/_mesh_8h_source/#file-meshh","title":"File Mesh.h","text":"<p>File List &gt; src &gt; Mesh.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef MESH_H\n#define MESH_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"Write_txtlog.h\"\n#include \"GridManip.h\"\n#include \"Poly.h\"\n\n\nint CalcInitnblk(Param XParam, Forcing&lt;float&gt; XForcing);\n\n\ntemplate &lt;class T&gt; void InitMesh(Param&amp; XParam, Forcing&lt;float&gt; &amp;XForcing, Model&lt;T&gt;&amp; XModel);\ntemplate &lt;class T&gt; void InitBlockInfo(Param &amp;XParam, Forcing&lt;float&gt; &amp;XForcing, BlockP&lt;T&gt;&amp; XBlock);\ntemplate &lt;class T&gt; void InitBlockadapt(Param &amp;XParam, BlockP&lt;T&gt; XBlock, AdaptP&amp; XAdap);\ntemplate &lt;class T&gt; void InitBlockxoyo(Param XParam, Forcing&lt;float&gt; XForcing, BlockP&lt;T&gt;&amp; XBlock);\ntemplate &lt;class T&gt; void InitBlockneighbours(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing, BlockP&lt;T&gt;&amp; XBlock);\n\ntemplate &lt;class T&gt; int CalcMaskblk(Param XParam, BlockP&lt;T&gt; XBlock);\ntemplate &lt;class T&gt; void FindMaskblk(Param XParam, BlockP&lt;T&gt; &amp;XBlock);\n\n// End of global definition;\n#endif\n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/","title":"File Multilayer.cu","text":""},{"location":"BGFlood/_multilayer_8cu/#file-multilayercu","title":"File Multilayer.cu","text":"<p>FileList &gt; src &gt; Multilayer.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Multilayer.h\"</code></li> </ul>"},{"location":"BGFlood/_multilayer_8cu/#public-functions","title":"Public Functions","text":"Type Name __global__ void AdvecEv (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  template __global__ void AdvecEv&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxMLP&lt; double &gt; XFlux)  template __global__ void AdvecEv&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxMLP&lt; float &gt; XFlux)  __global__ void AdvecFluxML (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  template __global__ void AdvecFluxML&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxMLP&lt; double &gt; XFlux)  template __global__ void AdvecFluxML&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxMLP&lt; float &gt; XFlux)  __global__ void CalcfaceValX (T pdt, Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux, T * dtmax, T * zb)  template __global__ void CalcfaceValX&lt; double &gt; (double pdt, Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxMLP&lt; double &gt; XFlux, double * dtmax, double * zb)  template __global__ void CalcfaceValX&lt; float &gt; (float pdt, Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxMLP&lt; float &gt; XFlux, float * dtmax, float * zb)  __global__ void CalcfaceValY (T pdt, Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux, T * dtmax, T * zb)  template __global__ void CalcfaceValY&lt; double &gt; (double pdt, Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxMLP&lt; double &gt; XFlux, double * dtmax, double * zb)  template __global__ void CalcfaceValY&lt; float &gt; (float pdt, Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxMLP&lt; float &gt; XFlux, float * dtmax, float * zb)  __global__ void CheckadvecMLX (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  template __global__ void CheckadvecMLX&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxMLP&lt; double &gt; XFlux)  template __global__ void CheckadvecMLX&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxMLP&lt; float &gt; XFlux)  __global__ void CheckadvecMLY (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  template __global__ void CheckadvecMLY&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxMLP&lt; double &gt; XFlux)  template __global__ void CheckadvecMLY&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxMLP&lt; float &gt; XFlux)  __global__ void CleanupML (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  template __global__ void CleanupML&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, double * zb)  template __global__ void CleanupML&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, float * zb)  __global__ void pressureML (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  template __global__ void pressureML&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double dt, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxMLP&lt; double &gt; XFlux)  template __global__ void pressureML&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float dt, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxMLP&lt; float &gt; XFlux)"},{"location":"BGFlood/_multilayer_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_multilayer_8cu/#function-advecev","title":"function AdvecEv","text":"<pre><code>template&lt;class T&gt;\n__global__ void AdvecEv (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-advecev-double","title":"function AdvecEv&lt; double &gt;","text":"<pre><code>template __global__ void AdvecEv&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxMLP &lt; double &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-advecev-float","title":"function AdvecEv&lt; float &gt;","text":"<pre><code>template __global__ void AdvecEv&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxMLP &lt; float &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-advecfluxml","title":"function AdvecFluxML","text":"<pre><code>template&lt;class T&gt;\n__global__ void AdvecFluxML (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-advecfluxml-double","title":"function AdvecFluxML&lt; double &gt;","text":"<pre><code>template __global__ void AdvecFluxML&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxMLP &lt; double &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-advecfluxml-float","title":"function AdvecFluxML&lt; float &gt;","text":"<pre><code>template __global__ void AdvecFluxML&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxMLP &lt; float &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-calcfacevalx","title":"function CalcfaceValX","text":"<pre><code>template&lt;class T&gt;\n__global__ void CalcfaceValX (\n    T pdt,\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-calcfacevalx-double","title":"function CalcfaceValX&lt; double &gt;","text":"<pre><code>template __global__ void CalcfaceValX&lt; double &gt; (\n    double pdt,\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxMLP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-calcfacevalx-float","title":"function CalcfaceValX&lt; float &gt;","text":"<pre><code>template __global__ void CalcfaceValX&lt; float &gt; (\n    float pdt,\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxMLP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-calcfacevaly","title":"function CalcfaceValY","text":"<pre><code>template&lt;class T&gt;\n__global__ void CalcfaceValY (\n    T pdt,\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-calcfacevaly-double","title":"function CalcfaceValY&lt; double &gt;","text":"<pre><code>template __global__ void CalcfaceValY&lt; double &gt; (\n    double pdt,\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxMLP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-calcfacevaly-float","title":"function CalcfaceValY&lt; float &gt;","text":"<pre><code>template __global__ void CalcfaceValY&lt; float &gt; (\n    float pdt,\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxMLP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-checkadvecmlx","title":"function CheckadvecMLX","text":"<pre><code>template&lt;class T&gt;\n__global__ void CheckadvecMLX (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-checkadvecmlx-double","title":"function CheckadvecMLX&lt; double &gt;","text":"<pre><code>template __global__ void CheckadvecMLX&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxMLP &lt; double &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-checkadvecmlx-float","title":"function CheckadvecMLX&lt; float &gt;","text":"<pre><code>template __global__ void CheckadvecMLX&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxMLP &lt; float &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-checkadvecmly","title":"function CheckadvecMLY","text":"<pre><code>template&lt;class T&gt;\n__global__ void CheckadvecMLY (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-checkadvecmly-double","title":"function CheckadvecMLY&lt; double &gt;","text":"<pre><code>template __global__ void CheckadvecMLY&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxMLP &lt; double &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-checkadvecmly-float","title":"function CheckadvecMLY&lt; float &gt;","text":"<pre><code>template __global__ void CheckadvecMLY&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxMLP &lt; float &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-cleanupml","title":"function CleanupML","text":"<pre><code>template&lt;class T&gt;\n__global__ void CleanupML (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-cleanupml-double","title":"function CleanupML&lt; double &gt;","text":"<pre><code>template __global__ void CleanupML&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-cleanupml-float","title":"function CleanupML&lt; float &gt;","text":"<pre><code>template __global__ void CleanupML&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-pressureml","title":"function pressureML","text":"<pre><code>template&lt;class T&gt;\n__global__ void pressureML (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-pressureml-double","title":"function pressureML&lt; double &gt;","text":"<pre><code>template __global__ void pressureML&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double dt,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxMLP &lt; double &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8cu/#function-pressureml-float","title":"function pressureML&lt; float &gt;","text":"<pre><code>template __global__ void pressureML&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float dt,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxMLP &lt; float &gt; XFlux\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Multilayer.cu</code></p>"},{"location":"BGFlood/_multilayer_8cu_source/","title":"File Multilayer.cu","text":""},{"location":"BGFlood/_multilayer_8cu_source/#file-multilayercu","title":"File Multilayer.cu","text":"<p>File List &gt; src &gt; Multilayer.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Multilayer.h\"\n\n//template &lt;class T&gt; void calcAbaro()\n//{\n//\n//  T gmetric = (2. * fm.x[i] / (cm[i] + cm[i - 1]))\n//\n//  a_baro[i] (G*gmetric*(eta[i-1] - eta[i])/Delta)\n//}\n\ntemplate &lt;class T&gt; __global__ void CalcfaceValX(T pdt,Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux, T* dtmax,T* zb)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps);// +epsi;\n    T dry = eps;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T CFL_H = T(0.5);\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n    T zsi = XEv.zs[i];\n\n    T zsn = XEv.zs[ileft];\n\n    T zbi = zb[i];\n    T zbn = zb[ileft];\n\n\n    T fmu = T(1.0);\n    T cm = T(1.0);//T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T gmetric = T(1.0);// (2. * fm.x[i] / (cm[i] + cm[i - 1]));\n\n    T ax = (g * gmetric * (zsn - zsi) / delta);\n\n    T H = 0.;\n    T um = 0.;\n    T Hr = 0.;\n    T Hl = 0.;\n\n\n    //foreach_layer() {\n    {\n        T hi = XEv.h[i];\n        T hn = XEv.h[ileft];\n        Hr += hi;\n        Hl += hn;\n        T hl = hn &gt; dry ? hn : 0.;\n        T hr = hi &gt; dry ? hi : 0.;\n\n\n\n        //XFlux.hu[i] = hl &gt; 0. || hr &gt; 0. ? (hl * XEv.u[ileft] + hr * XEvu[i]) / (hl + hr) : 0.;\n        T hui = hl &gt; 0. || hr &gt; 0. ? (hl * XEv.u[ileft] + hr * XEv.u[i]) / (hl + hr) : 0.;\n\n        T hff;\n\n        if (Hl &lt;= dry)\n            hff = max(min(zbi + Hr - zbn, hi), T(0.0));\n        else if (Hr &lt;= dry)\n            hff = max(min(zbn + Hl - zbi, hn), T(0.0));\n        else\n        {\n            T un = pdt * (hui) / delta; //pdt * (hui + pdt * ax) / delta;\n            T a =  signof(un);\n            int iu = un &gt; 0.0 ? ileft : i;// -(a + 1.) / 2.;\n            //double dhdx = h.gradient ? h.gradient(h[i - 1], h[i], h[i + 1]) / Delta : (h[i + 1] - h[i - 1]) / (2. * Delta);\n\n            hff = XEv.h[iu] + a * (1. - a * un) * XGrad.dhdx[iu] * delta / 2.;\n        }\n        XFlux.hfu[i] = fmu * hff;\n\n        if (fabs(hui) &gt; um)\n            um = fabs(hui);\n\n        XFlux.hu[i] = hui* fmu * hff;\n        XFlux.hau[i] = fmu * hff * ax;\n\n        H += hff;\n    }\n\n    if (H &gt; dry) {\n        T c = um / CFL + sqrt(g*H) / CFL_H;//um / CFL + sqrt(g * (hydrostatic ? H : delta * tanh(H / delta))) / CFL_H;\n        if (c &gt; 0.) {\n            dtmax[i] = min(delta / (c * fmu),dtmax[i]);\n            //if (dt &lt; dtmax)\n            //  dtmax = dt;\n        }\n    }\n    //pdt = dt = dtnext(dtmax);\n}\ntemplate __global__ void CalcfaceValX&lt;float&gt;(float pdt, Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxMLP&lt;float&gt; XFlux, float* dtmax, float* zb);\ntemplate __global__ void CalcfaceValX&lt;double&gt;(double pdt, Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxMLP&lt;double&gt; XFlux, double* dtmax, double* zb);\n\ntemplate &lt;class T&gt; __global__ void CalcfaceValY(T pdt, Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux, T* dtmax, T* zb)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps);// +epsi;\n    T dry = eps;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T CFL_H = T(0.5);\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ibot = memloc(halowidth, blkmemwidth, ix, iy-1, ib);\n\n    T zsi = XEv.zs[i];\n\n    T zsn = XEv.zs[ibot];\n\n    T zbi = zb[i];\n    T zbn = zb[ibot];\n\n\n    T fmu = T(1.0);\n    T cm = T(1.0);//T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T gmetric = T(1.0);// (2. * fm.x[i] / (cm[i] + cm[i - 1]));\n\n    T ax = (g * gmetric * (zsn - zsi) / delta);\n\n    T H = 0.;\n    T um = 0.;\n    T Hr = 0.;\n    T Hl = 0.;\n\n\n    //foreach_layer() {\n    {\n        T hi = XEv.h[i];\n        T hn = XEv.h[ibot];\n        Hr += hi;\n        Hl += hn;\n        T hl = hn &gt; dry ? hn : 0.;\n        T hr = hi &gt; dry ? hi : 0.;\n\n\n\n        //XFlux.hu[i] = hl &gt; 0. || hr &gt; 0. ? (hl * XEv.u[ileft] + hr * XEvu[i]) / (hl + hr) : 0.;\n        T hvi = hl &gt; 0. || hr &gt; 0. ? (hl * XEv.v[ibot] + hr * XEv.v[i]) / (hl + hr) : 0.;\n\n        T hff;\n\n        if (Hl &lt;= dry)\n            hff = max(min(zbi + Hr - zbn, hi), 0.);\n        else if (Hr &lt;= dry)\n            hff = max(min(zbn + Hl - zbi, hn), 0.);\n        else\n        {\n            T vn = pdt * (hvi) / delta;//pdt * (hvi + pdt * ax) / delta;\n            T a = signof(vn);\n            int iu = vn &gt; 0.0 ? ibot : i;// -(a + 1.) / 2.;\n            //double dhdx = h.gradient ? h.gradient(h[i - 1], h[i], h[i + 1]) / Delta : (h[i + 1] - h[i - 1]) / (2. * Delta);\n\n            hff = XEv.h[iu] + a * (1. - a * vn) * XGrad.dhdy[iu] * delta / 2.;\n        }\n        XFlux.hfv[i] = fmu * hff;\n\n        if (fabs(hvi) &gt; um)\n            um = fabs(hvi);\n\n        XFlux.hv[i] = hvi* fmu * hff;\n        XFlux.hav[i] = fmu * hff * ax;\n\n        H += hff;\n    }\n\n    if (H &gt; dry) {\n        T c = um / CFL + sqrt(g * H) / CFL_H;//um / CFL + sqrt(g * (hydrostatic ? H : delta * tanh(H / delta))) / CFL_H;\n        if (c &gt; 0.) {\n            dtmax[i] = min(delta / (c * fmu), dtmax[i]);\n            //if (dt &lt; dtmax)\n            //  dtmax = dt;\n        }\n    }\n    //pdt = dt = dtnext(dtmax);\n}\ntemplate __global__ void CalcfaceValY&lt;float&gt;(float pdt, Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxMLP&lt;float&gt; XFlux, float* dtmax, float* zb);\ntemplate __global__ void CalcfaceValY&lt;double&gt;(double pdt, Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxMLP&lt;double&gt; XFlux, double* dtmax, double* zb);\n\n\n\ntemplate &lt;class T&gt; __global__ void CheckadvecMLX(Param XParam, BlockP&lt;T&gt; XBlock,T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps);// +epsi;\n    T dry = eps;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T CFL_H = T(0.5);\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n    //For each layer\n    {\n        T hul = XFlux.hu[i];\n        T hi = XEv.h[i];\n        T hn = XEv.h[ileft];\n\n        T cmn = T(1.0);//cm[-1]\n        T cmi = T(1.0);//cm[]\n\n        if (hul * dt / (delta * cmn) &gt; CFL * hn)\n        {\n            hul = CFL * hn * delta * cmn / dt;\n        }\n        else if (-hul * dt / (delta * cmi) &gt; CFL * hi)\n        {\n            hul = -CFL * hi * delta * cmi / dt;\n        }\n\n        if (hul != XFlux.hu[i])\n        {\n            /*if (l &lt; nl - 1)\n            {\n                hu.x[0, 0, 1] += hu.x[] - hul;\n            }*/\n            XFlux.hu[i] = hul;\n        }\n    }\n\n\n}\ntemplate __global__ void CheckadvecMLX&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float dt, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxMLP&lt;float&gt; XFlux);\ntemplate __global__ void CheckadvecMLX&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double dt, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxMLP&lt;double&gt; XFlux);\n\ntemplate &lt;class T&gt; __global__ void CheckadvecMLY(Param XParam, BlockP&lt;T&gt; XBlock,T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps);// +epsi;\n    T dry = eps;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T CFL_H = T(0.5);\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ibot = memloc(halowidth, blkmemwidth, ix, iy-1, ib);\n\n    //For each layer\n    {\n        T hvl = XFlux.hv[i];\n        T hi = XEv.h[i];\n        T hn = XEv.h[ibot];\n\n        T cmn = T(1.0);//cm[-1]\n        T cmi = T(1.0);//cm[]\n\n        if (hvl * dt / (delta * cmn) &gt; CFL * hn)\n        {\n            hvl = CFL * hn * delta * cmn / dt;\n        }\n        else if (-hvl * dt / (delta * cmi) &gt; CFL * hi)\n        {\n            hvl = -CFL * hi * delta * cmi / dt;\n        }\n\n        if (hvl != XFlux.hv[i])\n        {\n            /*if (l &lt; nl - 1)\n            {\n                hu.x[0, 0, 1] += hu.x[] - hul;\n            }*/\n            XFlux.hv[i] = hvl;\n        }\n    }\n\n\n}\ntemplate __global__ void CheckadvecMLY&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float dt, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxMLP&lt;float&gt; XFlux);\ntemplate __global__ void CheckadvecMLY&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double dt, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxMLP&lt;double&gt; XFlux);\n\n\n\ntemplate &lt;class T&gt; __global__ void AdvecFluxML(Param XParam, BlockP&lt;T&gt; XBlock,T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps);// +epsi;\n    T dry = eps;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n\n    //For each layer\n    {\n        T un = dt * XFlux.hu[i] / ((XFlux.hfu[i] + dry) * delta);\n        //T vn = dt * XFlux.hu[i] / ((XFlux.hfu[i] + dry) * delta);\n        T vn = dt * XFlux.hv[i] / ((XFlux.hfv[i] + dry) * delta);\n\n        T au = signof(un);\n        T av = signof(vn);\n\n        int ixshft = un &gt; 0.0 ? -1: 0;\n        int iyshft = vn &gt; 0.0 ? -1 : 0;\n        //int iu = un &gt;= 0.0 ? ileft : i;//-(a + 1.) / 2.;\n        int iu = memloc(halowidth, blkmemwidth, ix + ixshft, iy, ib);\n\n        int iut, iub;\n\n\n        /*\n        if (ix == 0 &amp;&amp; iy == 15)\n        {\n            iut = memloc(halowidth, blkmemwidth, ix, iy + 1, ib);\n        }\n        else\n        {\n            iut = memloc(halowidth, blkmemwidth, ix + ixshft, iy + 1, ib);\n        }\n        if (ix == 0 &amp;&amp; iy == 0)\n        {\n            iub = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n        }\n        else\n        {\n            iub = memloc(halowidth, blkmemwidth, ix + ixshft, iy - 1, ib);\n        }\n        */\n        iub = memloc(halowidth, blkmemwidth, ix + ixshft, iy - 1, ib);\n        iut = memloc(halowidth, blkmemwidth, ix + ixshft, iy + 1, ib);\n\n\n        int iv = memloc(halowidth, blkmemwidth, ix, iy + iyshft, ib);\n\n        int ivr, ivl;\n        /*\n        if (iy == 0 &amp;&amp; ix == 15)\n        {\n            ivr = memloc(halowidth, blkmemwidth, ix + 1, iy, ib);\n        }\n        else\n        {\n            ivr = memloc(halowidth, blkmemwidth, ix + 1, iy + iyshft, ib);\n        }\n\n        if (iy == 0 &amp;&amp; ix == 0)\n        {\n            ivl = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n        }\n        else\n        {\n            ivl = memloc(halowidth, blkmemwidth, ix - 1, iy+iyshft, ib);\n        }\n        */\n        ivr = memloc(halowidth, blkmemwidth, ix + 1, iy + iyshft, ib);\n        ivl = memloc(halowidth, blkmemwidth, ix - 1, iy + iyshft, ib);\n\n\n        T sux2 = XEv.u[iu] + au * (1. - au * un) * XGrad.dudx[iu] * delta / 2.0;\n        T suy2 = XEv.u[iv] + av * (1. - av * vn) * XGrad.dudy[iv] * delta / 2.0;\n\n        T svy2 = XEv.v[iv] + av * (1. - av * vn) * XGrad.dvdy[iv] * delta / 2.0;\n        T svx2 = XEv.v[iu] + au * (1. - au * un) * XGrad.dvdx[iu] * delta / 2.0;\n        if (XFlux.hfv[iu] + XFlux.hfv[iut] &gt; dry)\n        {\n            T vvn = (XFlux.hv[iu] + XFlux.hv[iut]) / (XFlux.hfv[iu] + XFlux.hfv[iut]);\n            T syy = XGrad.dudy[iu] * delta;// != 0.0 ? XGrad.dudy[iu] :*/ vvn &lt; 0.0 ? XEv.u[iut] - XEv.u[iu] : XEv.u[iu] - XEv.u[iub];\n            T sxx = XGrad.dvdy[iu] * delta;\n            sux2 -= dt * vvn * syy / (2. * delta);\n            svx2 -= dt * vvn * sxx / (2. * delta);\n\n        }\n        if (XFlux.hfu[iv] + XFlux.hfu[ivr] &gt; dry)\n        {\n            T uun = (XFlux.hu[iv] + XFlux.hu[ivr]) / (XFlux.hfu[iv] + XFlux.hfu[ivr]);\n            T syy = XGrad.dvdx[iv] * delta;// != 0.0 ? XGrad.dvdx[iv] : uun &lt; 0.0 ? XEv.v[ivr] - XEv.v[iv] : XEv.v[iv] - XEv.v[ivl];\n            T sxx = XGrad.dudx[iv] * delta;\n            svy2 -= dt * uun * syy / (2. * delta);\n            suy2 -= dt * uun * sxx / (2. * delta);\n            //svx2 -= dt * vvn * syy / (2. * delta);\n            //su2 -= dt * uun * syy / (2. * delta);\n        }\n\n\n\n        XFlux.Fux[i] = sux2 * XFlux.hu[i];\n        XFlux.Fuy[i] = suy2 * XFlux.hv[i];// suy2* XFlux.hv[i];// su2*XFlux.hu[i];\n\n        //XFlux.Fvx[i] = svy2 * XFlux.hv[i];// sv2*XFlux.hv[i];\n        XFlux.Fvx[i] = svx2 * XFlux.hu[i];;// svx2* XFlux.hu[i];// sv2*XFlux.hv[i];\n        XFlux.Fvy[i] = svy2 * XFlux.hv[i];\n        // Confirmed equations\n        //XFlux.Fux[i] = sux2 * XFlux.hu[i];\n\n        //XFlux.Fvy[i] = svy2 * XFlux.hv[i];\n\n\n\n    }\n}\ntemplate __global__ void AdvecFluxML&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float dt, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxMLP&lt;float&gt; XFlux);\ntemplate __global__ void AdvecFluxML&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double dt, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxMLP&lt;double&gt; XFlux);\n\n\ntemplate &lt;class T&gt; __global__ void AdvecEv(Param XParam, BlockP&lt;T&gt; XBlock,T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps);// +epsi;\n    T dry = eps;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    T cmu = T(1.0);\n    T cmv = T(1.0);\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n    int iright = memloc(halowidth, blkmemwidth, ix + 1, iy, ib);\n    int itop = memloc(halowidth, blkmemwidth, ix, iy + 1, ib);\n    //For each layer\n    {\n        T uui = XEv.u[i];\n        T vvi = XEv.v[i];\n        T hi = XEv.h[i];\n\n\n\n        uui *= hi;\n        vvi *= hi;\n\n\n        //for debugging\n        //uui += XFlux.Fux[i];\n        //vvi += XFlux.Fvx[i];\n\n\n        //Below is correct\n\n        uui += dt * (XFlux.Fux[i] - XFlux.Fux[iright]) / (delta * cmu);\n        uui += dt * (XFlux.Fuy[i] - XFlux.Fuy[itop]) / (delta * cmv);\n\n        vvi += dt * (XFlux.Fvx[i] - XFlux.Fvx[iright]) / (delta * cmu);\n        vvi += dt * (XFlux.Fvy[i] - XFlux.Fvy[itop]) / (delta * cmv);\n\n\n\n\n\n\n        T h1 = hi;\n        h1 += dt * (XFlux.hu[i] - XFlux.hu[iright]) / (delta * cmu);\n        h1 += dt * (XFlux.hv[i] - XFlux.hv[itop]) / (delta * cmv);\n\n        XEv.h[i] = max(h1, T(0.0));\n\n        if (h1 &lt; dry)\n        {\n            uui = T(0.0);\n            vvi = T(0.0);\n        }\n        else\n        {\n            uui /=  h1;\n            vvi /=  h1;\n        }\n        XEv.u[i] = uui;\n        XEv.v[i] = vvi;\n    }\n\n}\ntemplate __global__ void AdvecEv&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float dt, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxMLP&lt;float&gt; XFlux);\ntemplate __global__ void AdvecEv&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double dt, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxMLP&lt;double&gt; XFlux);\n\n\n\ntemplate &lt;class T&gt; __global__ void pressureML(Param XParam, BlockP&lt;T&gt; XBlock,T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps);// +epsi;\n    T dry = eps;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n    int iright = memloc(halowidth, blkmemwidth, ix + 1, iy, ib);\n    int itop = memloc(halowidth, blkmemwidth, ix, iy + 1, ib);\n\n    T cm = T(1.0);// XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T fmu = T(1.0);\n    T fmv = T(1.0);// XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, ydwn) : T(1.0);\n    T fmup = T(1.0);\n    T fmvp = T(1.0);// XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, yup) : T(1.0);\n\n    T cmdinv, ga;\n\n    cmdinv = T(1.0) / (cm * delta);\n    ga = T(0.5) * g;\n\n    //For each layer\n    {\n\n        T uui = XEv.u[i];\n        T vvi = XEv.v[i];\n        //\n        XFlux.hu[i] += dt * XFlux.hau[i];\n        XFlux.hv[i] += dt * XFlux.hav[i];\n\n        uui += dt * (XFlux.hau[i] + XFlux.hau[iright]) / (XFlux.hfu[i] + XFlux.hfu[iright] + dry);\n        vvi += dt * (XFlux.hav[i] + XFlux.hav[itop]) / (XFlux.hfv[i] + XFlux.hfv[itop] + dry);\n\n        T dmdl = (fmup - fmu) * cmdinv;// absurd if not spherical!\n        T dmdt = (fmvp - fmv) * cmdinv;\n        T fG = vvi * dmdl - uui * dmdt;\n\n        uui += dt * fG * vvi;\n        vvi -= dt * fG * uui;\n\n        XEv.u[i] = uui;\n        XEv.v[i] = vvi;\n    }\n\n\n\n}\ntemplate __global__ void pressureML&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float dt, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxMLP&lt;float&gt; XFlux);\ntemplate __global__ void pressureML&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double dt, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxMLP&lt;double&gt; XFlux);\n\n\n\ntemplate &lt;class T&gt; __global__ void CleanupML(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv,T* zb)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n    int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n\n    XEv.zs[i] = zb[i] + max(XEv.h[i], 0.0);\n}\ntemplate __global__ void CleanupML&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, float* zb);\ntemplate __global__ void CleanupML&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, double* zb);\n</code></pre>"},{"location":"BGFlood/_multilayer_8h/","title":"File Multilayer.h","text":""},{"location":"BGFlood/_multilayer_8h/#file-multilayerh","title":"File Multilayer.h","text":"<p>FileList &gt; src &gt; Multilayer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Spherical.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> </ul>"},{"location":"BGFlood/_multilayer_8h/#public-functions","title":"Public Functions","text":"Type Name __global__ void AdvecEv (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  __global__ void AdvecFluxML (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  __global__ void CalcfaceValX (T pdt, Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux, T * dtmax, T * zb)  __global__ void CalcfaceValY (T pdt, Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux, T * dtmax, T * zb)  __global__ void CheckadvecMLX (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  __global__ void CheckadvecMLY (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)  __global__ void CleanupML (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, T * zb)  __global__ void pressureML (Param XParam, BlockP&lt; T &gt; XBlock, T dt, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxMLP&lt; T &gt; XFlux)"},{"location":"BGFlood/_multilayer_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_multilayer_8h/#function-advecev","title":"function AdvecEv","text":"<pre><code>template&lt;class T&gt;\n__global__ void AdvecEv (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8h/#function-advecfluxml","title":"function AdvecFluxML","text":"<pre><code>template&lt;class T&gt;\n__global__ void AdvecFluxML (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8h/#function-calcfacevalx","title":"function CalcfaceValX","text":"<pre><code>template&lt;class T&gt;\n__global__ void CalcfaceValX (\n    T pdt,\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8h/#function-calcfacevaly","title":"function CalcfaceValY","text":"<pre><code>template&lt;class T&gt;\n__global__ void CalcfaceValY (\n    T pdt,\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8h/#function-checkadvecmlx","title":"function CheckadvecMLX","text":"<pre><code>template&lt;class T&gt;\n__global__ void CheckadvecMLX (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8h/#function-checkadvecmly","title":"function CheckadvecMLY","text":"<pre><code>template&lt;class T&gt;\n__global__ void CheckadvecMLY (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8h/#function-cleanupml","title":"function CleanupML","text":"<pre><code>template&lt;class T&gt;\n__global__ void CleanupML (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_multilayer_8h/#function-pressureml","title":"function pressureML","text":"<pre><code>template&lt;class T&gt;\n__global__ void pressureML (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T dt,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxMLP &lt; T &gt; XFlux\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Multilayer.h</code></p>"},{"location":"BGFlood/_multilayer_8h_source/","title":"File Multilayer.h","text":""},{"location":"BGFlood/_multilayer_8h_source/#file-multilayerh","title":"File Multilayer.h","text":"<p>File List &gt; src &gt; Multilayer.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef MULTILAYER_H\n#define MULTILAYER_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"Spherical.h\"\n#include \"Util_CPU.h\"\n\ntemplate &lt;class T&gt; __global__ void CalcfaceValX(T pdt, Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __global__ void CalcfaceValY(T pdt, Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux, T* dtmax, T* zb);\n\ntemplate &lt;class T&gt; __global__ void CheckadvecMLX(Param XParam, BlockP&lt;T&gt; XBlock, T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux);\ntemplate &lt;class T&gt; __global__ void CheckadvecMLY(Param XParam, BlockP&lt;T&gt; XBlock, T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux);\ntemplate &lt;class T&gt; __global__ void AdvecFluxML(Param XParam, BlockP&lt;T&gt; XBlock, T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux);\ntemplate &lt;class T&gt; __global__ void AdvecEv(Param XParam, BlockP&lt;T&gt; XBlock, T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux);\ntemplate &lt;class T&gt; __global__ void pressureML(Param XParam, BlockP&lt;T&gt; XBlock, T dt, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxMLP&lt;T&gt; XFlux);\n\ntemplate &lt;class T&gt; __global__ void CleanupML(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, T* zb);\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_param_8h/","title":"File Param.h","text":""},{"location":"BGFlood/_param_8h/#file-paramh","title":"File Param.h","text":"<p>FileList &gt; src &gt; Param.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Input.h\"</code></li> </ul>"},{"location":"BGFlood/_param_8h/#classes","title":"Classes","text":"Type Name class Param <p>The documentation for this class was generated from the following file <code>src/Param.h</code></p>"},{"location":"BGFlood/_param_8h_source/","title":"File Param.h","text":""},{"location":"BGFlood/_param_8h_source/#file-paramh","title":"File Param.h","text":"<p>File List &gt; src &gt; Param.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef PARAM_H\n#define PARAM_H\n\n#include \"General.h\"\n#include \"Input.h\"\n\nclass Param {\npublic:\n\n    //*General parameters\n    int test = -1; //-1: no test, 99: run all independent tests, X: run test X\n    double g = 9.81; // Acceleration of gravity in m.s-2\n    double rho = 1025.0; // Fluid density in kg.m-3\n    double eps = 0.0001; // Drying height in m (if h&lt;eps, the surface is concidered dry)\n    double dt = 0.0; // Model time step in s.\n    double CFL = 0.5; // Current Freidrich Limiter criterium (between 0 and 1. Higher values may make the model unstable)\n    double theta = 1.3; // Minmod limiter parameter, theta in [1,2]. &lt;br&gt;Can be used to tune the momentum dissipation (theta=1 gives minmod the most dissipative limiter and theta = 2 gives    superbee, the least dissipative).\n    double VelThreshold = -1.0; // Using Velocity threshold if the the velocuity exceeds that threshold. Advice value of 16.0 to use or negative value (-1) to turn off\n    int frictionmodel = 0; // Bottom friction model flag (-1: Manning model, 0: quadratic, 1: Smart roughtness length model)\n    double cf = 0.0001; // Bottom friction coefficient for the model (if constant)\n    double Cd = 0.002; // Wind drag coefficient\n    double il = 0.0; //Initial Loss value (if constant)\n    double cl = 0.0; //Continuous Loss value (if constant)\n    bool windforcing = false; //not working yet\n    bool atmpforcing = false;\n    bool rainforcing = false;\n    bool infiltration = false;\n\n    bool conserveElevation = false; //Switch to force the conservation of zs instead of h at the interface between coarse and fine blocks\n    bool wetdryfix = true; // Switch to remove wet/dry instability (i.e. true reoves instability and false leaves the model as is)\n    bool ForceMassConserve = false; // Switch to enforce mass conservation only useful on steep slope\n\n    double Pa2m = 0.00009916; // Conversion between atmospheric pressure changes to water level changes in Pa (if unit is hPa then user should use 0.009916)\n    double Paref = 101300.0; // Reference pressure in Pa (if unit is hPa then user should use 1013.0)\n    double lat = 0.0; // Model latitude. This is ignored in spherical case\n    int GPUDEVICE = 0; // 0: first available GPU, -1: CPU single core, 2+: other GPU\n\n    int doubleprecision = 0; // 0: float precision, 1: double precision (for the solver and math)\n    bool savebyblk = true;\n\n    int engine = 1; // 1: Buttinger-Kreuzhuber et al. 2019, 2: Kurganov (Popinet 2011), 3: KurganovATMP same as Kurganov but with atmospheric forcing terms \n\n    //*Grid parameters\n    double dx = nan(\"\"); // Grid resolution, in m for a metric grid or in decimal degree for a sperical grid.\n    double delta; // Grid resolution for the model. in Spherical coordinates this is dx * Radius*pi / 180.0\n    int nx = 0; // Initial/input grid size (number of nodes) in x direction\n    int ny = 0; //Initial/input grid size (number of nodes) in y direction\n    int nblk = 0; // Number of compute blocks\n    int blkwidth = 16; //Block width in number of cells\n    int blkmemwidth = 0; // Calculated in sanity check as blkwidth+2*halowidth\n    int blksize = 0; // Calculated in sanity check as blkmemwidth*blkmemwidth\n    int halowidth = 1; // Use a halo around the blocks default is 1 cell: the memory for each blk is 18x18 when blkwidth is 16\n\n\n    double xo = nan(\"\"); // Grid x origin (if not alter by the user, will be defined based on the topography/bathymetry input map)\n    double yo = nan(\"\"); // Grid y origin (if not alter by the user, will be defined based on the topography/bathymetry input map)\n    double ymax = nan(\"\"); // Grid ymax (if not alter by the user, will be defined based on the topography/bathymetry input map)\n    double xmax = nan(\"\"); // Grid xmax (if not alter by the user, will be defined based on the topography/bathymetry input map)\n    double grdalpha = nan(\"\"); // Grid rotation on Y axis from the North input in degrees but later converted to rad\n    int posdown = 0; // Flag for bathy input. Model requirement is positive up  so if posdown ==1 then zb=zb*-1.0f\n    bool spherical = 0; // Flag for sperical coordinate (still in development)\n    double Radius = 6371220.; //Earth radius [m]\n    double mask = 9999.0; //Mask any zb above this value. If the entire Block is masked then it is not allocated in the memory\n\n    //*Adaptation\n    int initlevel = 0; //Initial level of grid adaptation (based on dx if defined by the user or on the resolution of the topography/bathymetry input)\n    int maxlevel = -99999; //Maximum level for grid adaptation (overwrite the adaptation map if use) \n    int minlevel = -99999; //Minumim level for grid adaptation (overwrite the adaptation map if use) \n    int nblkmem = 0;\n    int navailblk = 0;\n    double membuffer = 1.05; //Needs to allocate more memory than initially needed so adaptation can happen without memory reallocation\n\n\n\n    //*Timekeeping\n    //double outputtimeinit = -99999; //Initial time for the output, initialised to initial running time\n    double outputtimestep = 0.0; //Number of seconds between netCDF outputs, 0.0 for none\n    double endtime = std::numeric_limits&lt;double&gt;::max(); // Total runtime in s, will be calculated based on bnd input as min(length of the shortest time series, user defined) and should be shorter than any time-varying forcing\n    double totaltime = 0.0; // Total simulation time in s\n    double inittime = 0.0; // Initital model time. At start of simulation inittime==totaltime\n    double dtinit = -1; // Maximum initial time steps in s (should be positive, advice 0.1 if dry domain initialement) \n    double dtmin = 0.0005; //Minimum accepted time steps in s (a lower value will be concidered a crash of the code, and stop the run)\n    std::string reftime = \"\"; // Reference time string as yyyy-mm-ddTHH:MM:SS\n    std::string crs_ref = \"no_crs\"; //\"PROJCS[\\\"NZGD2000 / New Zealand Transverse Mercator 2000\\\",GEOGCS[\\\"NZGD2000\\\",DATUM[\\\"New_Zealand_Geodetic_Datum_2000\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101]],PRIMEM[\\\"Greenwich\\\",0],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4167\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",173],PARAMETER[\\\"scale_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",1600000],PARAMETER[\\\"false_northing\\\",10000000],UNIT[\\\"metre\\\",1],AXIS[\\\"Northing\\\",NORTH],AXIS[\\\"Easting\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"2193\\\"]]\";\n\n\n    //*Boundaries\n    bool leftbnd = false; // bnd is forced (i.e. not a wall or neuman)\n    bool rightbnd = false; // bnd is forced (i.e. not a wall or neuman)\n    bool topbnd = false; // bnd is forced (i.e. not a wall or neuman)\n    bool botbnd = false; // bnd is forced (i.e. not a wall or neuman)\n\n    int aoibnd = 0; // Boundary type for AOI: 0=wall; 1 neumann; 3 absorbing\n    double bndrelaxtime = 3600.0; // Realxation time for absorbing boundary\n    double bndfiltertime = 60.0; // Filtering time for absorbing boundary\n\n\n    //* Initialisation\n    double zsinit = nan(\"\"); //Init zs for cold start in m. If not specified by user and no bnd file = 1 then sanity check will set it to 0.0\n\n    double zsoffset = nan(\"\"); //Add a water level offset in m to initial conditions and boundaries (0.0 by default)\n\n    std::string hotstartfile;\n    /*Allow to hotstart (or restart) the computation providing a netcdf file containing at least zb, h or zs, u and v\n    Default: None\n    */\n    //std::string deformfile;\n    int hotstep = 0; //Step to read if hotstart file has multiple steps (step and not (computation) time)\n\n\n    double bndtaper = 0.0; // number of second to taper boundary values to smooth transition with initial conditions default is no tapering but 600s is good practice\n    //other\n    clock_t startcputime, endcputime, setupcputime;\n    size_t GPU_initmem_byte, GPU_totalmem_byte;\n\n\n    //*Outputs\n    //std::string Bathymetryfile;// bathymetry file name\n    //inputmap Bathymetry;\n\n    T_output Toutput;\n    /* Flexible time definition for outputs (nc files)\n    Example: \"Toutput = 0.0:3600:7200,7000,7100; which mean every 3600s from 0 to 7200s, and the two times 7000 and 7100\"\n    Default = First and last timne steps*/\n\n    //Timeseries output (save as a vector containing information for each Time Serie output)\n    std::vector&lt;TSoutnode&gt; TSnodesout;\n    /*Time serie output, giving a file name and a (x,y) position\n    (which will be converted to nearest grid position).\n    This keyword can be used multiple times to extract time series at different locations.\n    The data is stocked for each timestep and written by flocs.\n    The resulting file contains (t,zs,h,u,v)\n    Example: \"TSnodesout = Offshore.txt,3101.00,4982.57\" (*filename,x,y*)\n    Default: None\n    */\n\n    std::string outfile = \"Output.nc\"; // Netcdf output file name (if it exists, a number will be happened to the file name to not overwrite it)\n    std::vector&lt;std::string&gt; outvars; \n    /*List of names of the variables to output (for 2D maps)\n    Supported variables = \"zb\", \"zs\", \"u\", \"v\", \"h\", \"hmean\", \"zsmean\", \"umean\", \"vmean\", \"hUmean\", \"Umean\", \"hmax\", \"zsmax\", \"umax\", \"vmax\", \"hUmax\", \"Umax\", \"twet\", \"dhdx\",\"dhdy\",\"dzsdx\",\"dzsdy\",\"dudx\",\"dudy\",\"dvdx\",\"dvdy\",\"Fhu\",\"Fhv\",\"Fqux\",\"Fqvy\",\"Fquy\",\"Fqvx\",\"Su\",\"Sv\",\"dh\",\"dhu\",\"dhv\",\"cf\",\"Patm\", \"datmpdx\",\"datmpdy\",\"il\",\"cl\",\"hgw\";\n    Example: \"outvars = zs,h,u,v,zb,hmax,Umax;\"\n    Default: \"zb\", \"zs\", \"u\", \"v\", \"h\"\n    */\n    double wet_threshold = 0.1; //in m. Limit to consider a cell wet for the twet output (duration of inundation (s))\n\n    std::vector&lt;outzoneP&gt; outzone;\n    /*Zoned output (netcdf file), giving a file name and the position of two corner points\n    (which will be converted to a rectagle containing full blocks).\n    Time vector or values can also be added to specified special outputs for this one in particular.\n    This keyword can be used multiple times to output maps of different areas.\n    Example: \"outzone=zoomed.nc,5.3,5.4,0.5,0.8;\" (*filename,x1,x2,y1,y2*) or \"outzone=zoomed.nc,5.3,5.4,0.5,0.8, 3600:360:7200;\" (*filename,x1,x2,y1,y2, t_init:t_step:t_end*)\n    Default: Full domain\n    */\n\n    int maxTSstorage = 16384; //maximum strorage (nTSnodes*4*nTSsteps) before time series output are flushed to disk [2^14]\n\n\n\n\n    // Output switch controls\n    bool resetmax = false; //Switch to reset the \"max\" outputs after each output (reset if 1, no reset if 0)\n    bool outmax = false;\n    bool outmean = false;\n    //bool outvort = false;\n    bool outtwet = false;\n    //bool outU = false;\n\n    // WARNING FOR DEBUGGING PURPOSE ONLY\n// For debugging one can shift the output by 1 or -1 in the i and j direction.\n// this will save the value in the halo to the output file allowing debugging of values there.\n    int outishift = 0; //DEBUGGING ONLY: allow cell shift (1 or -1) in x direction to visualise the halo around blocks in the output \n    int outjshift = 0; //DEBUGGING ONLY: allow cell shift (1 or -1) in y direction to visualise the halo around blocks in the output \n\n\n    //Rivers\n    //std::vector&lt;River&gt; Rivers; // empty vector to hold river location and discharge time series\n    int nrivers = 0;\n    int nblkriver = 0;\n\n    // length of bnd blk, redundant from XForcing but useful\n    int nbndblkleft = 0;\n    int nbndblkright = 0;\n    int nbndblktop = 0;\n    int nbndblkbot = 0;\n\n    int nmaskblk = 0;\n\n\n\n    //*Netcdf parameters\n    int smallnc = 1; //Short integer conversion for netcdf outputs. 1: save as short integer for the netcdf file, if 0 then save all variables as float\n    float scalefactor = 0.01f; //Scale factor used for the short integer conversion for netcdf outputs. This follow the COARDS convention.\n    float addoffset = 0.0f; //Offset add during the short integer conversion for netcdf outputs (follow the COARDS convention)\n\n#ifdef USE_CATALYST\n        //* ParaView Catalyst parameters (special use with ParaView)\n    int use_catalyst = 0; // Switch to use ParaView Catalyst\n    int catalyst_python_pipeline = 0; //Pipeline to use ParaView Catalyst\n    int vtk_output_frequency = 0; // Output frequency for ParaView Catalyst\n    double vtk_output_time_interval = 1.0; // Output time step for ParaView Catalyst\n    std::string vtk_outputfile_root = \"bg_out\"; //output file name for ParaView Catalyst\n    std::string python_pipeline = \"coproc.py\"; //python pipeline for ParaView Catalyst\n#endif\n\n\n\n\n    // info of the mapped cf\n    //inputmap roughnessmap;\n\n    //forcingmap windU;\n    //forcingmap windV;\n    //forcingmap atmP;\n    //forcingmap Rainongrid;\n\n    // deformation forcing for tsunami generation\n    //std::vector&lt;deformmap&gt; deform;\n    double deformmaxtime = 0.0; // time (s) after which no deformation occurs (internal parameter to cut some of the loops)\n    bool rainbnd = false; // when false it force the rain forcing on the bnd cells to be null.\n\n    // This here should be stored in a structure at a later stage\n\n    std::string AdaptCrit;\n    int* AdaptCrit_funct_pointer;\n\n    std::string Adapt_arg1, Adapt_arg2, Adapt_arg3, Adapt_arg4, Adapt_arg5;\n    int adaptmaxiteration = 20; // Maximum number of iteration for adaptation. default 20\n\n\n\n\n};\n\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_poly_8cu/","title":"File Poly.cu","text":""},{"location":"BGFlood/_poly_8cu/#file-polycu","title":"File Poly.cu","text":"<p>FileList &gt; src &gt; Poly.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Poly.h\"</code></li> </ul>"},{"location":"BGFlood/_poly_8cu/#public-functions","title":"Public Functions","text":"Type Name Polygon CounterCWPoly (Polygon Poly) check polygon handedness and reverse if necessary. bool PolygonIntersect (Polygon P, Polygon Q) Intersection between two polygons. bool SegmentIntersect (Polygon P, Polygon Q) Intersection between segments. Vertex VertAdd (Vertex A, Vertex B) Add two vertices. Vertex VertSub (Vertex A, Vertex B) Subtract two vertices. bool blockinpoly (T xo, T yo, T dx, int blkwidth, Polygon Poly) Check whether a block is inside or intersects a polygon. template bool blockinpoly&lt; double &gt; (double xo, double yo, double dx, int blkwidth, Polygon Poly)  template bool blockinpoly&lt; float &gt; (float xo, float yo, float dx, int blkwidth, Polygon Poly)  int cn_PnPoly (T Px, T Py, F * Vx, F * Vy, int n) Crossing number test for a point in a polygon. double dotprod (Vertex A, Vertex B) Compute dot product of two vertices. T isLeft (T P0x, T P0y, T P1x, T P1y, T P2x, T P2y) Tests if a point is Left|On|Right of an infinite line. bool test_SegmentIntersect () Test segment intersection function. bool test_intersectpoly () Test polygon intersection function. bool test_wninpoly () Test winding number inpoly function. int wn_PnPoly (T Px, T Py, T * Vx, T * Vy, unsigned int n) winding number test for a point in a polygon int wn_PnPoly (T Px, T Py, Polygon Poly) winding number test for a point in a polygon template int wn_PnPoly&lt; double &gt; (double Px, double Py, Polygon Poly)  template int wn_PnPoly&lt; float &gt; (float Px, float Py, Polygon Poly)  double xprod (Vertex A, Vertex B) Compute cross product of two vertices."},{"location":"BGFlood/_poly_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_poly_8cu/#function-countercwpoly","title":"function CounterCWPoly","text":"<p>check polygon handedness and reverse if necessary. </p><pre><code>Polygon CounterCWPoly (\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/_poly_8cu/#description","title":"Description","text":"<p>check polygon handedness and enforce left-handesness (Counter-clockwise). This function is used to ensure the right polygon handedness for the winding number inpoly (using the isleft()) </p>"},{"location":"BGFlood/_poly_8cu/#function-polygonintersect","title":"function PolygonIntersect","text":"<p>Intersection between two polygons. </p><pre><code>bool PolygonIntersect (\n    Polygon P,\n    Polygon Q\n) \n</code></pre> <p>Checks whether two polygons intersect by testing all segment pairs. The function checks whether each segment of Polygon P intersect any segment of Poly Q. If an intersection is detected, returns true immediately.</p> <p>Parameters:</p> <ul> <li><code>P</code> First polygon </li> <li><code>Q</code> Second polygon </li> </ul> <p>Returns:</p> <p>True if polygons intersect, false otherwise </p>"},{"location":"BGFlood/_poly_8cu/#function-segmentintersect","title":"function SegmentIntersect","text":"<p>Intersection between segments. </p><pre><code>bool SegmentIntersect (\n    Polygon P,\n    Polygon Q\n) \n</code></pre> <p>Checks whether two polygon segments intersect. Polygon P and Q are only 2 vertex long each. i.e. they represent a segment each.</p>"},{"location":"BGFlood/_poly_8cu/#where-does-this-come-from","title":"Where does this come from:","text":"<p>https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect Best answer from Gareth Rees</p> <p>Parameters:</p> <ul> <li><code>P</code> First segment as Polygon </li> <li><code>Q</code> Second segment as Polygon </li> </ul> <p>Returns:</p> <p>True if segments intersect, false otherwise </p>"},{"location":"BGFlood/_poly_8cu/#function-vertadd","title":"function VertAdd","text":"<p>Add two vertices. </p><pre><code>Vertex VertAdd (\n    Vertex A,\n    Vertex B\n) \n</code></pre> <p>Returns the sum of two Vertex objects.</p> <p>Parameters:</p> <ul> <li><code>A</code> First vertex </li> <li><code>B</code> Second vertex </li> </ul> <p>Returns:</p> <p>Sum vertex </p>"},{"location":"BGFlood/_poly_8cu/#function-vertsub","title":"function VertSub","text":"<p>Subtract two vertices. </p><pre><code>Vertex VertSub (\n    Vertex A,\n    Vertex B\n) \n</code></pre> <p>Returns the difference of two Vertex objects.</p> <p>Parameters:</p> <ul> <li><code>A</code> First vertex </li> <li><code>B</code> Second vertex </li> </ul> <p>Returns:</p> <p>Difference vertex </p>"},{"location":"BGFlood/_poly_8cu/#function-blockinpoly","title":"function blockinpoly","text":"<p>Check whether a block is inside or intersects a polygon. </p><pre><code>template&lt;class T&gt;\nbool blockinpoly (\n    T xo,\n    T yo,\n    T dx,\n    int blkwidth,\n    Polygon Poly\n) \n</code></pre> <p>Determines if any corner of the block is inside the polygon or if the block intersects the polygon.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Coordinate type </li> </ul> <p>Parameters:</p> <ul> <li><code>xo</code> Block origin x </li> <li><code>yo</code> Block origin y </li> <li><code>dx</code> Block cell size </li> <li><code>blkwidth</code> Block width </li> <li><code>Poly</code> Polygon to test </li> </ul> <p>Returns:</p> <p>True if block is inside or intersects polygon, false otherwise </p>"},{"location":"BGFlood/_poly_8cu/#function-blockinpoly-double","title":"function blockinpoly&lt; double &gt;","text":"<pre><code>template bool blockinpoly&lt; double &gt; (\n    double xo,\n    double yo,\n    double dx,\n    int blkwidth,\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/_poly_8cu/#function-blockinpoly-float","title":"function blockinpoly&lt; float &gt;","text":"<pre><code>template bool blockinpoly&lt; float &gt; (\n    float xo,\n    float yo,\n    float dx,\n    int blkwidth,\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/_poly_8cu/#function-cn_pnpoly","title":"function cn_PnPoly","text":"<p>Crossing number test for a point in a polygon. </p><pre><code>template&lt;class T, class F&gt;\nint cn_PnPoly (\n    T Px,\n    T Py,\n    F * Vx,\n    F * Vy,\n    int n\n) \n</code></pre> <p>Determines if a point is inside a polygon using the crossing number algorithm. cn_PnPoly(): crossing number test for a point in a polygon Input: P = a point, V[] = vertex points of a polygon V[n+1] with V[n]=V[0] Return: 0 = outside, 1 = inside </p>"},{"location":"BGFlood/_poly_8cu/#where-does-this-come-from_1","title":"Where does this come from:","text":"<p>Copyright 2000 softSurfer, 2012 Dan Sunday </p>"},{"location":"BGFlood/_poly_8cu/#original-licence","title":"Original Licence","text":"<p>This code may be freely used and modified for any purpose providing that this copyright notice is included with it. SoftSurfer makes no warranty for this code, and cannot be held liable for any real or imagined damage resulting from its use. Users of this code must verify correctness for their application. Code modified to fit the use in DisperGPU</p> <p>This code is patterned after [Franklin, 2000]</p> <p>Template parameters:</p> <ul> <li><code>T</code> Point coordinate type </li> <li><code>F</code> Vertex coordinate type </li> </ul> <p>Parameters:</p> <ul> <li><code>Px</code> X coordinate of point </li> <li><code>Py</code> Y coordinate of point </li> <li><code>Vx</code> Array of polygon vertex X coordinates </li> <li><code>Vy</code> Array of polygon vertex Y coordinates </li> <li><code>n</code> Number of vertices </li> </ul> <p>Returns:</p> <p>1 if inside, 0 if outside </p>"},{"location":"BGFlood/_poly_8cu/#function-dotprod","title":"function dotprod","text":"<p>Compute dot product of two vertices. </p><pre><code>double dotprod (\n    Vertex A,\n    Vertex B\n) \n</code></pre> <p>Calculates the dot product of two Vertex objects.</p> <p>Parameters:</p> <ul> <li><code>A</code> First vertex </li> <li><code>B</code> Second vertex </li> </ul> <p>Returns:</p> <p>Dot product value </p>"},{"location":"BGFlood/_poly_8cu/#function-isleft","title":"function isLeft","text":"<p>Tests if a point is Left|On|Right of an infinite line. </p><pre><code>template&lt;class T&gt;\nT isLeft (\n    T P0x,\n    T P0y,\n    T P1x,\n    T P1y,\n    T P2x,\n    T P2y\n) \n</code></pre> <p>Returns &gt;0 for P2 left of the line through P0 and P1, =0 for P2 on the line, &lt;0 for P2 right of the line. See: Algorithm 1 \"Area of Triangles and Polygons\"</p>"},{"location":"BGFlood/_poly_8cu/#where-does-this-come-from_2","title":"Where does this come from:","text":"<p>Copyright 2000 softSurfer, 2012 Dan Sunday </p>"},{"location":"BGFlood/_poly_8cu/#original-licence_1","title":"Original Licence","text":"<p>This code may be freely used and modified for any purpose providing that this copyright notice is included with it. SoftSurfer makes no warranty for this code, and cannot be held liable for any real or imagined damage resulting from its use. Users of this code must verify correctness for their application. Code modified to fit the use in DisperGPU</p> <p>Template parameters:</p> <ul> <li><code>T</code> Coordinate type </li> </ul> <p>Parameters:</p> <ul> <li><code>P0x</code> X of first point </li> <li><code>P0y</code> Y of first point </li> <li><code>P1x</code> X of second point </li> <li><code>P1y</code> Y of second point </li> <li><code>P2x</code> X of test point </li> <li><code>P2y</code> Y of test point </li> </ul> <p>Returns:</p> <p>Relative position value </p>"},{"location":"BGFlood/_poly_8cu/#function-test_segmentintersect","title":"function test_SegmentIntersect","text":"<p>Test segment intersection function. </p><pre><code>bool test_SegmentIntersect () \n</code></pre> <p>Tests the segment intersection function for known cases. </p> <p>Returns:</p> <p>True if test passes, false otherwise </p>"},{"location":"BGFlood/_poly_8cu/#function-test_intersectpoly","title":"function test_intersectpoly","text":"<p>Test polygon intersection function. </p><pre><code>bool test_intersectpoly () \n</code></pre> <p>Tests the polygon intersection function for known cases. </p> <p>Returns:</p> <p>True if test passes, false otherwise </p>"},{"location":"BGFlood/_poly_8cu/#function-test_wninpoly","title":"function test_wninpoly","text":"<p>Test winding number inpoly function. </p><pre><code>bool test_wninpoly () \n</code></pre> <p>Tests the winding number function for a block polygon. </p> <p>Returns:</p> <p>True if test passes, false otherwise </p>"},{"location":"BGFlood/_poly_8cu/#function-wn_pnpoly","title":"function wn_PnPoly","text":"<p>winding number test for a point in a polygon </p><pre><code>template&lt;class T&gt;\nint wn_PnPoly (\n    T Px,\n    T Py,\n    T * Vx,\n    T * Vy,\n    unsigned int n\n) \n</code></pre>"},{"location":"BGFlood/_poly_8cu/#description_1","title":"Description","text":"<p>wn_PnPoly(): winding number test for a point in a polygon Input: P = a point, V[] = vertex points of a polygon V[n+1] with V[n]=V[0] Return: wn = the winding number (=0 only when P is outside)</p>"},{"location":"BGFlood/_poly_8cu/#where-does-this-come-from_3","title":"Where does this come from:","text":"<p>Copyright 2000 softSurfer, 2012 Dan Sunday </p>"},{"location":"BGFlood/_poly_8cu/#original-licence_2","title":"Original Licence","text":"<p>This code may be freely used and modified for any purpose providing that this copyright notice is included with it. SoftSurfer makes no warranty for this code, and cannot be held liable for any real or imagined damage resulting from its use. Users of this code must verify correctness for their application. Code modified to fit the use in DisperGPU </p>"},{"location":"BGFlood/_poly_8cu/#function-wn_pnpoly_1","title":"function wn_PnPoly","text":"<p>winding number test for a point in a polygon </p><pre><code>template&lt;class T&gt;\nint wn_PnPoly (\n    T Px,\n    T Py,\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/_poly_8cu/#description_2","title":"Description","text":"<p>wn_PnPoly(): winding number test for a point in a polygon Input: P = a point, V[] = vertex points of a polygon V[n+1] with V[n]=V[0] Return: wn = the winding number (=0 only when P is outside)</p>"},{"location":"BGFlood/_poly_8cu/#where-does-this-come-from_4","title":"Where does this come from:","text":"<p>Copyright 2000 softSurfer, 2012 Dan Sunday </p>"},{"location":"BGFlood/_poly_8cu/#original-licence_3","title":"Original Licence","text":"<p>This code may be freely used and modified for any purpose providing that this copyright notice is included with it. SoftSurfer makes no warranty for this code, and cannot be held liable for any real or imagined damage resulting from its use. Users of this code must verify correctness for their application. Code modified to fit the use in DisperGPU </p>"},{"location":"BGFlood/_poly_8cu/#function-wn_pnpoly-double","title":"function wn_PnPoly&lt; double &gt;","text":"<pre><code>template int wn_PnPoly&lt; double &gt; (\n    double Px,\n    double Py,\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/_poly_8cu/#function-wn_pnpoly-float","title":"function wn_PnPoly&lt; float &gt;","text":"<pre><code>template int wn_PnPoly&lt; float &gt; (\n    float Px,\n    float Py,\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/_poly_8cu/#function-xprod","title":"function xprod","text":"<p>Compute cross product of two vertices. </p><pre><code>double xprod (\n    Vertex A,\n    Vertex B\n) \n</code></pre> <p>Calculates the cross product of two Vertex objects.</p> <p>Parameters:</p> <ul> <li><code>A</code> First vertex </li> <li><code>B</code> Second vertex </li> </ul> <p>Returns:</p> <p>Cross product value </p> <p>The documentation for this class was generated from the following file <code>src/Poly.cu</code></p>"},{"location":"BGFlood/_poly_8cu_source/","title":"File Poly.cu","text":""},{"location":"BGFlood/_poly_8cu_source/#file-polycu","title":"File Poly.cu","text":"<p>File List &gt; src &gt; Poly.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n// This code contains an adaptation of the St Venant equation from Basilisk     //\n// See                                                                          //\n// http://basilisk.fr/src/saint-venant.h and                                    //\n// S. Popinet. Quadtree-adaptive tsunami modelling. Ocean Dynamics,             //\n// doi: 61(9) : 1261 - 1285, 2011                                               //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //\n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n\n#include \"Poly.h\"\n\n\ntemplate &lt;class T&gt; T isLeft(T P0x, T P0y, T P1x, T P1y, T P2x, T P2y)\n{\n    return ((P1x - P0x) * (P2y - P0y)\n        - (P2x - P0x) * (P1y - P0y));\n}\n//===================================================================\n\ntemplate &lt;class T, class F&gt; int cn_PnPoly(T Px, T Py, F* Vx, F* Vy, int n)\n{\n    int    cn = 0;    // the  crossing number counter\n\n    // loop through all edges of the polygon\n    for (int i = 0; i &lt; n; i++) {    // edge from V[i]  to V[i+1]\n        if (((Vy[i] &lt;= Py) &amp;&amp; (Vy[i + 1] &gt; Py))     // an upward crossing\n            || ((Vy[i] &gt; Py) &amp;&amp; (Vy[i + 1] &lt;= Py))) { // a downward crossing\n            // compute  the actual edge-ray intersect x-coordinate\n            T vt = (T)(Py - Vy[i]) / (Vy[i + 1] - Vy[i]);\n            if (Px &lt; Vx[i] + vt * (Vx[i + 1] - Vx[i])) // P.x &lt; intersect\n                ++cn;   // a valid crossing of y=P.y right of P.x\n        }\n    }\n    return (cn &amp; 1);    // 0 if even (out), and 1 if  odd (in)\n\n}\n//===================================================================\n\ntemplate &lt;class T&gt; int wn_PnPoly(T Px, T Py, T* Vx, T* Vy, unsigned int n)\n{\n    int    wn = 0;    // the  winding number counter\n\n    // loop through all edges of the polygon\n    for (int i = 0; i &lt; n; i++) {   // edge from V[i] to  V[i+1]\n        if (Vy[i] &lt;= Py) {          // start y &lt;= P.y\n            if (Vy[i + 1] &gt; Py)      // an upward crossing\n                if (isLeft(Vx[i], Vy[i], Vx[i + 1], Vy[i + 1], Px, Py) &gt; 0)  // P left of  edge\n                    ++wn;            // have  a valid up intersect\n        }\n        else {                        // start y &gt; P.y (no test needed)\n            if (Vy[i + 1] &lt;= Py)     // a downward crossing\n                if (isLeft(Vx[i], Vy[i], Vx[i + 1], Vy[i + 1], Px, Py) &lt; 0)  // P right of  edge\n                    --wn;            // have  a valid down intersect\n        }\n    }\n    return wn;\n}\n\ntemplate &lt;class T&gt; int wn_PnPoly(T Px, T Py, Polygon Poly)\n{\n    int    wn = 0;    // the  winding number counter\n\n    // loop through all edges of the polygon\n    for (int i = 0; i &lt; (Poly.vertices.size() - 1); i++) {   // edge from V[i] to  V[i+1]\n        if (Poly.vertices[i].y &lt;= Py) {          // start y &lt;= P.y\n            if (Poly.vertices[i + 1].y &gt; Py)      // an upward crossing\n                if (isLeft(T(Poly.vertices[i].x), T(Poly.vertices[i].y), T(Poly.vertices[i + 1].x), T(Poly.vertices[i + 1].y), Px, Py) &gt; 0)  // P left of  edge\n                    ++wn;            // have  a valid up intersect\n        }\n        else {                        // start y &gt; P.y (no test needed)\n            if (Poly.vertices[i + 1].y &lt;= Py)     // a downward crossing\n                if (isLeft(T(Poly.vertices[i].x), T(Poly.vertices[i].y), T(Poly.vertices[i + 1].x), T(Poly.vertices[i + 1].y), Px, Py) &lt; 0)  // P right of  edge\n                    --wn;            // have  a valid down intersect\n        }\n    }\n    return wn;\n}\ntemplate int wn_PnPoly&lt;float&gt;(float Px, float Py, Polygon Poly);\ntemplate int wn_PnPoly&lt;double&gt;(double Px, double Py, Polygon Poly);\n//===================================================================\n\n\nPolygon CounterCWPoly(Polygon Poly)\n{\n    double sum = 0.0;\n    Polygon Rev;\n\n\n    for (int i = 0; i &lt; (Poly.vertices.size() - 1); i++)\n    {\n        //\n        sum = sum + (Poly.vertices[i + 1].x - Poly.vertices[i].x) * (Poly.vertices[i + 1].y - Poly.vertices[i].y);\n    }\n\n    std::string res = sum &gt; 0.0 ? \"ClockWise\" : \"CCW\";\n\n    log(\" Polygon is \" + res );\n\n\n    // sum&lt;0.0 -&gt; counterclockwise Polygon; sum&gt;0.0 -&gt; clockwise\n    if (sum &gt; 0.0)\n    {\n        log(\" Reversing Polygon handedness\");\n        for (int i = Poly.vertices.size()-1; i &gt; 0; i--)\n        {\n            //\n\n\n            Rev.vertices.push_back(Poly.vertices[i]);\n        }\n        Rev.vertices.push_back(Rev.vertices[0]);\n\n    }\n    return sum &gt; 0.0 ? Rev : Poly;\n\n}\n\nVertex VertAdd(Vertex A, Vertex B)\n{\n    Vertex v;\n    v.x = A.x + B.x; \n    v.y = A.y + B.y;\n\n    return v;\n}\n\nVertex VertSub(Vertex A, Vertex B)\n{\n    Vertex v;\n    v.x = A.x - B.x;\n    v.y = A.y - B.y;\n\n    return v;\n}\n\ndouble dotprod(Vertex A, Vertex B)\n{\n    double a = 0.0;\n    a = A.x * B.x + A.x + B.y + A.y * B.x + A.y * B.y;\n    return a;\n}\n\ndouble xprod(Vertex A, Vertex B)\n{\n    double a = 0.0;\n    a = A.x*B.y-A.y*B.x;\n    return a;\n}\n\nbool SegmentIntersect(Polygon P, Polygon Q)\n{\n    //\n    Vertex r, s, p, q, qmp;\n    double rxs, qmpxr, eps, t, u;\n    bool intersect = false;\n\n    eps = 1e-9;\n\n    p = P.vertices[0];\n    q = Q.vertices[0];\n    r = VertSub(P.vertices[1], P.vertices[0]);\n    s = VertSub(Q.vertices[1], Q.vertices[0]);\n\n    qmp= VertSub(q, p);\n\n    rxs = xprod(r, s);\n\n    qmpxr = xprod(qmp, r);\n\n\n\n\n    if (abs(rxs) &lt;= eps &amp;&amp; abs(qmpxr) &lt;= eps)\n    {\n        // colinear\n        double t0, t1, rdr, sdr;\n        sdr= dotprod(s, r);\n        rdr = dotprod(r, r);\n\n        t0 = dotprod(qmp, r) / rdr;\n        t1 = t0 + dotprod(s, r) / rdr;\n\n        if (sdr &lt; 0.0)\n        {\n            intersect = (t0 &gt;= 0.0 &amp;&amp; t1 &lt;= 1);\n        }\n        else\n        {\n            intersect = (t1 &gt;= 0.0 &amp;&amp; t0 &lt;= 1);\n        }\n\n\n    }\n    else if (abs(rxs) &lt;= eps &amp;&amp; abs(qmpxr) &gt; eps)\n    {\n        // parallele lines and non intersecting\n        intersect = false;\n    }\n    else if (abs(rxs) &gt; eps)\n    {\n        t = xprod(qmp, s) / rxs;\n        u = qmpxr / rxs;\n\n        if (t &gt;= 0.0 &amp;&amp; t &lt;= 1.0 &amp;&amp; u &lt;= 1.0 &amp;&amp; u &gt;= 0.0)\n        {\n            intersect = true;\n        }\n\n    }\n    else\n    {\n        intersect = false;\n    }\n\n\n    return intersect;\n}\n\nbool PolygonIntersect(Polygon P, Polygon Q)\n{\n    bool intersect=false;\n    for (int i = 0; i &lt; (P.vertices.size() - 1); i++)\n    {\n        for (int j = 0; j &lt; (Q.vertices.size() - 1); j++)\n        {\n            // build segments\n            Polygon Pseg, Qseg;\n            Pseg.vertices = { P.vertices[i], P.vertices[i + 1] };\n            Qseg.vertices = { Q.vertices[j], Q.vertices[j + 1] };\n\n            intersect = SegmentIntersect(Pseg, Qseg);\n\n            if (intersect)\n            {\n                i = (int)P.vertices.size();\n                j = (int)Q.vertices.size();\n                break;\n            }\n\n        }\n\n\n    }\n\n    return intersect;\n\n}\n\ntemplate &lt;class T&gt; bool blockinpoly(T xo, T yo, T dx, int blkwidth, Polygon Poly)\n{\n    bool insidepoly = false;\n\n\n\n\n\n    //bool test = test_wninpoly();\n\n\n\n    //printf(\"wn_inpolytest=%s\\n\", test ? \"true\" : \"false\");\n\n    //test = test_intersectpoly();\n    //printf(\"test_intersectpoly=%s\\n\", test ? \"true\" : \"false\");\n\n    //test = test_SegmentIntersect();\n    //printf(\"test_SegmentIntersect=%s\\n\", test ? \"true\" : \"false\");\n\n    // First check if it isinmside the bounding box\n    insidepoly = OBBdetect(xo, xo + dx * blkwidth, yo, yo + dx * blkwidth, T(Poly.xmin), T(Poly.xmax), T(Poly.ymin), T(Poly.ymax));\n\n    if (insidepoly)\n    {\n        //printf(\"xo=%f, yo=%f, dx=%f, blkwidth=%d\\n\", xo, yo, dx, blkwidth);\n        // being in the bounding box doesn't say much\n\n        // Is there any corner of the block inside the polygon?\n        int wnBL,wnBR,wnTL,wnTR;\n        insidepoly = false;\n\n        wnBL = wn_PnPoly(xo, yo, Poly);\n        wnBR = wn_PnPoly(xo + blkwidth*dx, yo, Poly);\n        wnTL = wn_PnPoly(xo, yo + blkwidth * dx, Poly);\n        wnTR = wn_PnPoly(xo + blkwidth * dx, yo + blkwidth * dx, Poly);\n\n        insidepoly = (wnBL != 0 || wnBR != 0 || wnTL != 0 || wnTR != 0);\n\n        if (!insidepoly)\n        {\n            // maybe a thin arn of the polygon intersect the block\n            Polygon Polyblock;\n            Vertex vxBL, vxBR, vxTL, vxTR;\n            vxBL.x = xo; vxBL.y = yo;\n            vxBR.x = xo + blkwidth * dx; vxBR.y = yo;\n            vxTL.x = xo; vxTL.y = yo + blkwidth * dx;\n            vxTR.x = xo + blkwidth * dx; vxTR.y = yo + blkwidth * dx;\n\n            Polyblock.vertices.push_back(vxBL);\n            Polyblock.vertices.push_back(vxBR);\n            Polyblock.vertices.push_back(vxTR);\n            Polyblock.vertices.push_back(vxTL);\n            Polyblock.vertices.push_back(vxBL);\n\n            insidepoly = PolygonIntersect(Polyblock, Poly);\n        }\n\n    }\n\n    return insidepoly;\n}\ntemplate bool blockinpoly&lt;float&gt;(float xo, float yo, float dx, int blkwidth, Polygon Poly);\ntemplate bool blockinpoly&lt;double&gt;(double xo, double yo, double dx, int blkwidth, Polygon Poly);\n//template &lt;class T&gt; Poly&lt;T&gt; ReadPoly();\n\nbool test_wninpoly()\n{\n    int in, out;\n    bool success = false;\n    Polygon Polyblock;\n    Vertex vxBL, vxBR, vxTL, vxTR;\n    vxBL.x = 0.0; vxBL.y = 0.0;\n    vxBR.x = 1.0; vxBR.y = 0.0;\n    vxTL.x = 0.0; vxTL.y = 1.0;\n    vxTR.x = 1.0; vxTR.y = 1.0;\n\n    Polyblock.vertices.push_back(vxBL);\n    Polyblock.vertices.push_back(vxBR);\n    Polyblock.vertices.push_back(vxTR);\n    Polyblock.vertices.push_back(vxTL);\n    Polyblock.vertices.push_back(vxBL);\n\n    in = wn_PnPoly(0.2, 0.3, Polyblock);\n    out = wn_PnPoly(1.2, 0.3, Polyblock);\n\n    success = (out == 0 &amp;&amp; in != 0);\n    return success;\n}\n\nbool test_SegmentIntersect()\n{\n    bool in, out, success;\n    Vertex a, b, c, d, e, f;\n    Polygon P, Q, R;\n\n    a.x = -1.0; a.y = -1.0;\n    b.x = 1.0; b.y = 1.0;\n\n    c.x = -1.0; c.y = 1.0;\n    d.x = 1.0; d.y = -1.0;\n\n    double eps = 0.0001;\n\n    e.x = a.x + eps; e.y = a.y ;\n    f.x = b.x + eps; f.y = b.y;\n\n    P.vertices.push_back(a);\n    P.vertices.push_back(b);\n\n    Q.vertices.push_back(c);\n    Q.vertices.push_back(d);\n\n    R.vertices.push_back(e);\n    R.vertices.push_back(f);\n\n    in = SegmentIntersect(P, Q);\n    out = SegmentIntersect(P, R);\n    success = (in &amp;&amp; !out);\n    return success;\n}\n\nbool test_intersectpoly()\n{\n    bool success = false;\n    bool in = false;\n    bool out = false;\n    Polygon Polyblock;\n\n    Polygon PolyTriA, PolyTriB;\n    Vertex vxBL, vxBR, vxTL, vxTR, TriA, TriB, TriC;\n    vxBL.x = 0.0; vxBL.y = 0.0;\n    vxBR.x = 1.0; vxBR.y = 0.0;\n    vxTL.x = 0.0; vxTL.y = 1.0;\n    vxTR.x = 1.0; vxTR.y = 1.0;\n\n    Polyblock.vertices.push_back(vxBL);\n    Polyblock.vertices.push_back(vxBR);\n    Polyblock.vertices.push_back(vxTR);\n    Polyblock.vertices.push_back(vxTL);\n    Polyblock.vertices.push_back(vxBL);\n\n    TriA.x = -1.0; TriA.y = 1.0;\n\n    TriB.x = -1.0; TriB.y = -1.0;\n\n    TriC.x = 0.8; TriC.y = -0.8;\n\n    PolyTriA.vertices.push_back(TriA);\n    PolyTriA.vertices.push_back(TriB);\n    PolyTriA.vertices.push_back(TriC);\n    PolyTriA.vertices.push_back(TriA);\n\n    in = PolygonIntersect(Polyblock, PolyTriA);\n\n    TriA.x = -2.0; TriA.y = 1.0;\n\n    TriB.x = -2.0; TriB.y = -1.0;\n\n    TriC.x = -1.8; TriC.y = -0.8;\n\n    PolyTriB.vertices.push_back(TriA);\n    PolyTriB.vertices.push_back(TriB);\n    PolyTriB.vertices.push_back(TriC);\n    PolyTriB.vertices.push_back(TriA);\n\n    out = PolygonIntersect(Polyblock, PolyTriB);\n\n    success = (in &amp;&amp; !out);\n    return success;\n\n}\n</code></pre>"},{"location":"BGFlood/_poly_8h/","title":"File Poly.h","text":""},{"location":"BGFlood/_poly_8h/#file-polyh","title":"File Poly.h","text":"<p>FileList &gt; src &gt; Poly.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Input.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> </ul>"},{"location":"BGFlood/_poly_8h/#public-functions","title":"Public Functions","text":"Type Name Polygon CounterCWPoly (Polygon Poly) check polygon handedness and reverse if necessary. bool blockinpoly (T xo, T yo, T dx, int blkwidth, Polygon Poly) Check whether a block is inside or intersects a polygon. int wn_PnPoly (T Px, T Py, Polygon Poly) winding number test for a point in a polygon"},{"location":"BGFlood/_poly_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_poly_8h/#function-countercwpoly","title":"function CounterCWPoly","text":"<p>check polygon handedness and reverse if necessary. </p><pre><code>Polygon CounterCWPoly (\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/_poly_8h/#description","title":"Description","text":"<p>check polygon handedness and enforce left-handesness (Counter-clockwise). This function is used to ensure the right polygon handedness for the winding number inpoly (using the isleft()) </p>"},{"location":"BGFlood/_poly_8h/#function-blockinpoly","title":"function blockinpoly","text":"<p>Check whether a block is inside or intersects a polygon. </p><pre><code>template&lt;class T&gt;\nbool blockinpoly (\n    T xo,\n    T yo,\n    T dx,\n    int blkwidth,\n    Polygon Poly\n) \n</code></pre> <p>Determines if any corner of the block is inside the polygon or if the block intersects the polygon.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Coordinate type </li> </ul> <p>Parameters:</p> <ul> <li><code>xo</code> Block origin x </li> <li><code>yo</code> Block origin y </li> <li><code>dx</code> Block cell size </li> <li><code>blkwidth</code> Block width </li> <li><code>Poly</code> Polygon to test </li> </ul> <p>Returns:</p> <p>True if block is inside or intersects polygon, false otherwise </p>"},{"location":"BGFlood/_poly_8h/#function-wn_pnpoly","title":"function wn_PnPoly","text":"<p>winding number test for a point in a polygon </p><pre><code>template&lt;class T&gt;\nint wn_PnPoly (\n    T Px,\n    T Py,\n    Polygon Poly\n) \n</code></pre>"},{"location":"BGFlood/_poly_8h/#description_1","title":"Description","text":"<p>wn_PnPoly(): winding number test for a point in a polygon Input: P = a point, V[] = vertex points of a polygon V[n+1] with V[n]=V[0] Return: wn = the winding number (=0 only when P is outside)</p>"},{"location":"BGFlood/_poly_8h/#where-does-this-come-from","title":"Where does this come from:","text":"<p>Copyright 2000 softSurfer, 2012 Dan Sunday </p>"},{"location":"BGFlood/_poly_8h/#original-licence","title":"Original Licence","text":"<p>This code may be freely used and modified for any purpose providing that this copyright notice is included with it. SoftSurfer makes no warranty for this code, and cannot be held liable for any real or imagined damage resulting from its use. Users of this code must verify correctness for their application. Code modified to fit the use in DisperGPU </p> <p>The documentation for this class was generated from the following file <code>src/Poly.h</code></p>"},{"location":"BGFlood/_poly_8h_source/","title":"File Poly.h","text":""},{"location":"BGFlood/_poly_8h_source/#file-polyh","title":"File Poly.h","text":"<p>File List &gt; src &gt; Poly.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef POLY_H\n#define POLY_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Input.h\"\n#include \"Write_txtlog.h\"\n#include \"Util_CPU.h\"\n#include \"Forcing.h\"\n#include \"Arrays.h\"\n#include \"MemManagement.h\"\n\ntemplate &lt;class T&gt; bool blockinpoly(T xo, T yo, T dx, int blkwidth, Polygon Poly);\ntemplate &lt;class T&gt; int wn_PnPoly(T Px, T Py, Polygon Poly);\nPolygon CounterCWPoly(Polygon Poly);\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/","title":"File ReadForcing.cu","text":""},{"location":"BGFlood/_read_forcing_8cu/#file-readforcingcu","title":"File ReadForcing.cu","text":"<p>FileList &gt; src &gt; ReadForcing.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ReadForcing.h\"</code></li> </ul>"},{"location":"BGFlood/_read_forcing_8cu/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; std::string &gt; DelimLine (std::string line, int n, char delim) Split a string into a vector of substrings based on a specified delimiter. std::vector&lt; std::string &gt; DelimLine (std::string line, int n) Split a string into a vector of substrings based on common delimiters (tab, space, comma). Tries tab, space, and comma as delimiters and returns the first successful split with the expected number of elements. void InitDynforcing (bool gpgpu, Param &amp; XParam, DynForcingP&lt; float &gt; &amp; Dforcing) Initialize dynamic forcing data (Rain, wind, Atm pressure). void clampedges (int nx, int ny, T clamp, T * z) Clamp the edges of a 2D array to a specified value. Sets the values at the edges of a 2D array to a specified clamp value. void denan (int nx, int ny, float denanval, T * z) Replace NaN values in a 2D array with a specified value. Iterates through a 2D array and replaces any NaN values with the specified denanval. void denan (int nx, int ny, float denanval, int * z)  template void denan&lt; double &gt; (int nx, int ny, float denanval, double * z)  template void denan&lt; float &gt; (int nx, int ny, float denanval, float * z)  std::string readCRSfrombathy (std::string crs_ref, StaticForcingP&lt; float &gt; &amp; Sforcing) Read CRS information from bathymetry file metadata (last one read). Reads CRS information from the metadata of the specified bathymetry file. void readDynforcing (bool gpgpu, double totaltime, DynForcingP&lt; float &gt; &amp; Dforcing) Deprecated function (!!!) to read dynamic forcing data for a given time. std::vector&lt; Flowin &gt; readFlowfile (std::string Flowfilename, std::string &amp; refdate) Read flow data from a specified file, for river forcing for example. Reads flow data from a specified file and extracts time and flow rate information. Applies reference date adjustment if provided. std::vector&lt; Windin &gt; readINfileUNI (std::string filename, std::string &amp; refdate) Read rain/atmospheric pressure data from a specified file for spatially uniform forcing. Reads rain/atmospheric pressure data from a specified file and extracts time and wind speed information. Applies reference date adjustment if provided. std::vector&lt; SLTS &gt; readNestfile (std::string ncfile, std::string varname, int hor, double eps, double bndxo, double bndxmax, double bndy) Read boundary nesting data from a NetCDF file. Reads boundary nesting data from a specified NetCDF file and variable name. Supports both horizontal and vertical boundaries. Polygon readPolygon (std::string filename) Read polygon from a specified file. Reads polygon vertices from a specified file and ensures the polygon is closed. Calculates bounding box of the polygon. std::vector&lt; SLTS &gt; readWLfile (std::string WLfilename, std::string &amp; refdate) Read water level boundary file. Reads water level boundary file and extracts time and water level data. Applies reference date adjustment if provided. std::vector&lt; Windin &gt; readWNDfileUNI (std::string filename, std::string &amp; refdate, double grdalpha) Read wind data from a specified file for spatially uniform forcing. Reads wind data from a specified file and extracts time, wind speed, wind direction, and calculates u and v wind components. Applies reference date adjustment if provided.  __ void readXBbathy (std::string filename, int nx, int ny, T *&amp; zb) Read bathymetry data from an XBeach-style .bot/.dep file into a provided array. Parses the file format and fills the provided array with bathymetry values. template void readXBbathy&lt; float &gt; (std::string filename, int nx, int ny, float *&amp; zb)  template void readXBbathy&lt; int &gt; (std::string filename, int nx, int ny, int *&amp; zb)  void readbathyASCHead (std::string filename, int &amp; nx, int &amp; ny, double &amp; dx, double &amp; xo, double &amp; yo, double &amp; grdalpha) Read header information from an ASC (bathymetry) file. Extracts grid size (nx, ny), grid spacing (dx), origin (xo, yo), and grid rotation angle (grdalpha). Adjusts origin if the file uses corner registration. void readbathyASCzb (std::string filename, int nx, int ny, T *&amp; zb) Read (bathymetry) data from an ASC file into a provided array. Parses the ASC file format and fills the provided array with bathymetry values. template void readbathyASCzb&lt; float &gt; (std::string filename, int nx, int ny, float *&amp; zb)  template void readbathyASCzb&lt; int &gt; (std::string filename, int nx, int ny, int *&amp; zb)  void readbathyHeadMD (std::string filename, int &amp; nx, int &amp; ny, double &amp; dx, double &amp; grdalpha) Read header information from an MD bathymetry file (or other MD input map). Extracts grid size (nx, ny), grid spacing (dx), and grid rotation angle (grdalpha). void readbathyMD (std::string filename, T *&amp; zb) Read bathymetry data from an MD file into a provided array. Parses the MD file format and fills the provided array with bathymetry values.  __ template void readbathyMD&lt; float &gt; (std::string filename, float *&amp; zb)  template void readbathyMD&lt; int &gt; (std::string filename, int *&amp; zb)  void readbathydata (int posdown, StaticForcingP&lt; float &gt; &amp; Sforcing) Read bathymetry data and apply corrections if needed. std::vector&lt; SLTS &gt; readbndfile (std::string filename, Param &amp; XParam) Read boundary forcing files (water levels or nest files). Polygon readbndpolysegment (bndsegment bnd, Param XParam) Read boundary polygon segment and create polygon structure. void readforcing (Param &amp; XParam, Forcing&lt; T &gt; &amp; XForcing) Wrapping function for reading all the forcing data. template void readforcing&lt; float &gt; (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing)  void readforcingdata (int step, T forcing) Read static forcing data from various file formats based on the file extension. Supports reading from .md, .nc, .bot/.dep, and .asc files. void readforcingdata (double totaltime, DynForcingP&lt; float &gt; &amp; forcing) Read dynamic forcing data from a NetCDF file based on the current simulation time. Interpolates between time steps to obtain the current forcing values. Handles NaN values and clamps edges if specified. template void readforcingdata&lt; StaticForcingP&lt; float &gt; &gt; (int step, StaticForcingP&lt; float &gt; forcing)  template void readforcingdata&lt; StaticForcingP&lt; int &gt; &gt; (int step, StaticForcingP&lt; int &gt; forcing)  template void readforcingdata&lt; deformmap&lt; float &gt; &gt; (int step, deformmap&lt; float &gt; forcing)  DynForcingP&lt; float &gt; readforcinghead (DynForcingP&lt; float &gt; Fmap, Param XParam) Read dynamic forcing metadata/header from a NetCDF file. Extracts grid size, spacing, origin, and time information. T readforcinghead (T ForcingParam) Read static forcing metadata/header from various file formats based on the file extension. Supports reading from .md, .nc, .bot/.dep, and .asc files. Extracts grid size, spacing, origin, and other relevant information.  __ template StaticForcingP&lt; float &gt; readforcinghead&lt; StaticForcingP&lt; float &gt; &gt; (StaticForcingP&lt; float &gt; ForcingParam)  template forcingmap readforcinghead&lt; forcingmap &gt; (forcingmap BathyParam)  template inputmap readforcinghead&lt; inputmap &gt; (inputmap BathyParam)  void readstaticforcing (T &amp; Sforcing) Single parameter version of readstaticforcing(int step, T&amp; Sforcing). void readstaticforcing (int step, T &amp; Sforcing) Allocate and read static (i.e. not varying in time) forcing data. Used for Bathymetry, roughness, deformation, etc. template void readstaticforcing&lt; StaticForcingP&lt; float &gt; &gt; (StaticForcingP&lt; float &gt; &amp; Sforcing)  template void readstaticforcing&lt; StaticForcingP&lt; float &gt; &gt; (int step, StaticForcingP&lt; float &gt; &amp; Sforcing)  template void readstaticforcing&lt; StaticForcingP&lt; int &gt; &gt; (StaticForcingP&lt; int &gt; &amp; Sforcing)  template void readstaticforcing&lt; StaticForcingP&lt; int &gt; &gt; (int step, StaticForcingP&lt; int &gt; &amp; Sforcing)  template void readstaticforcing&lt; deformmap&lt; float &gt; &gt; (deformmap&lt; float &gt; &amp; Sforcing)  template void readstaticforcing&lt; deformmap&lt; float &gt; &gt; (int step, deformmap&lt; float &gt; &amp; Sforcing)"},{"location":"BGFlood/_read_forcing_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_read_forcing_8cu/#function-delimline","title":"function DelimLine","text":"<p>Split a string into a vector of substrings based on a specified delimiter. </p><pre><code>std::vector&lt; std::string &gt; DelimLine (\n    std::string line,\n    int n,\n    char delim\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s</code> The input string to be split </li> <li><code>delim</code> The delimiter character used for splitting </li> </ul> <p>Returns:</p> <p>Vector of substrings </p>"},{"location":"BGFlood/_read_forcing_8cu/#function-delimline_1","title":"function DelimLine","text":"<p>Split a string into a vector of substrings based on common delimiters (tab, space, comma). Tries tab, space, and comma as delimiters and returns the first successful split with the expected number of elements. </p><pre><code>std::vector&lt; std::string &gt; DelimLine (\n    std::string line,\n    int n\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>line</code> The input string to be split </li> <li><code>n</code> The expected number of elements after splitting </li> </ul> <p>Returns:</p> <p>Vector of substrings if successful; empty vector otherwise </p>"},{"location":"BGFlood/_read_forcing_8cu/#function-initdynforcing","title":"function InitDynforcing","text":"<p>Initialize dynamic forcing data (Rain, wind, Atm pressure). </p><pre><code>void InitDynforcing (\n    bool gpgpu,\n    Param &amp; XParam,\n    DynForcingP &lt; float &gt; &amp; Dforcing\n) \n</code></pre> <p>Reads dynamic forcing header and allocates memory for dynamic forcing arrays.</p> <p>Parameters:</p> <ul> <li><code>gpgpu</code> Use GPU acceleration </li> <li><code>XParam</code> Model parameters </li> <li><code>Dforcing</code> Dynamic forcing structure </li> </ul>"},{"location":"BGFlood/_read_forcing_8cu/#function-clampedges","title":"function clampedges","text":"<p>Clamp the edges of a 2D array to a specified value. Sets the values at the edges of a 2D array to a specified clamp value. </p><pre><code>template&lt;class T&gt;\nvoid clampedges (\n    int nx,\n    int ny,\n    T clamp,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>nx</code> Number of grid points in the x-direction </li> <li><code>ny</code> Number of grid points in the y-direction </li> <li><code>clamp</code> Value to set at the edges </li> <li><code>z</code> Pointer to the 2D array (flattened as 1D) to be modified </li> </ul>"},{"location":"BGFlood/_read_forcing_8cu/#function-denan","title":"function denan","text":"<p>Replace NaN values in a 2D array with a specified value. Iterates through a 2D array and replaces any NaN values with the specified denanval. </p><pre><code>template&lt;class T&gt;\nvoid denan (\n    int nx,\n    int ny,\n    float denanval,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>nx</code> Number of grid points in the x-direction </li> <li><code>ny</code> Number of grid points in the y-direction </li> <li><code>denanval</code> Value to replace NaN values with </li> <li><code>z</code> Pointer to the 2D array (flattened as 1D) to be modified </li> </ul>"},{"location":"BGFlood/_read_forcing_8cu/#function-denan_1","title":"function denan","text":"<pre><code>void denan (\n    int nx,\n    int ny,\n    float denanval,\n    int * z\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-denan-double","title":"function denan&lt; double &gt;","text":"<pre><code>template void denan&lt; double &gt; (\n    int nx,\n    int ny,\n    float denanval,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-denan-float","title":"function denan&lt; float &gt;","text":"<pre><code>template void denan&lt; float &gt; (\n    int nx,\n    int ny,\n    float denanval,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readcrsfrombathy","title":"function readCRSfrombathy","text":"<p>Read CRS information from bathymetry file metadata (last one read). Reads CRS information from the metadata of the specified bathymetry file. </p><pre><code>std::string readCRSfrombathy (\n    std::string crs_ref,\n    StaticForcingP &lt; float &gt; &amp; Sforcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>crs_ref</code> Reference to the CRS string </li> <li><code>Sforcing</code> Static forcing structure </li> </ul> <p>Returns:</p> <p>CRS WKT string </p>"},{"location":"BGFlood/_read_forcing_8cu/#function-readdynforcing","title":"function readDynforcing","text":"<p>Deprecated function (!!!) to read dynamic forcing data for a given time. </p><pre><code>void readDynforcing (\n    bool gpgpu,\n    double totaltime,\n    DynForcingP &lt; float &gt; &amp; Dforcing\n) \n</code></pre> <p>Reads and allocates dynamic forcing arrays for the specified time.</p> <p>Parameters:</p> <ul> <li><code>gpgpu</code> Use GPU acceleration </li> <li><code>totaltime</code> Current simulation time </li> <li><code>Dforcing</code> Dynamic forcing structure</li> </ul> <p>This is a deprecated function! See InitDynforcing() instead </p>"},{"location":"BGFlood/_read_forcing_8cu/#function-readflowfile","title":"function readFlowfile","text":"<p>Read flow data from a specified file, for river forcing for example. Reads flow data from a specified file and extracts time and flow rate information. Applies reference date adjustment if provided. </p><pre><code>std::vector&lt; Flowin &gt; readFlowfile (\n    std::string Flowfilename,\n    std::string &amp; refdate\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>Flowfilename</code> Name of the flow data file </li> <li><code>refdate</code> Reference date for time adjustment </li> </ul> <p>Returns:</p> <p>Vector of Flowin structures containing time and flow rate data </p>"},{"location":"BGFlood/_read_forcing_8cu/#function-readinfileuni","title":"function readINfileUNI","text":"<p>Read rain/atmospheric pressure data from a specified file for spatially uniform forcing. Reads rain/atmospheric pressure data from a specified file and extracts time and wind speed information. Applies reference date adjustment if provided. </p><pre><code>std::vector&lt; Windin &gt; readINfileUNI (\n    std::string filename,\n    std::string &amp; refdate\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the rain/atmospheric pressure data file </li> <li><code>refdate</code> Reference date for time adjustment </li> </ul> <p>Returns:</p> <p>Vector of Windin structures containing time and wind speed data </p>"},{"location":"BGFlood/_read_forcing_8cu/#function-readnestfile","title":"function readNestfile","text":"<p>Read boundary nesting data from a NetCDF file. Reads boundary nesting data from a specified NetCDF file and variable name. Supports both horizontal and vertical boundaries. </p><pre><code>std::vector&lt; SLTS &gt; readNestfile (\n    std::string ncfile,\n    std::string varname,\n    int hor,\n    double eps,\n    double bndxo,\n    double bndxmax,\n    double bndy\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>ncfile</code> Name of the NetCDF file </li> <li><code>varname</code> Name of the variable to read </li> <li><code>hor</code> If 1, read horizontal boundary (top/bottom); if 0 read vertical boundary (left/right) </li> <li><code>eps</code> Small value to avoid numerical issues </li> <li><code>bndxo</code> Starting coordinate of the boundary </li> <li><code>bndxmax</code> Ending coordinate of the boundary </li> <li><code>bndy</code> Fixed coordinate of the boundary </li> </ul> <p>Returns:</p> <p>Vector of SLTS structures containing time and water level data </p>"},{"location":"BGFlood/_read_forcing_8cu/#function-readpolygon","title":"function readPolygon","text":"<p>Read polygon from a specified file. Reads polygon vertices from a specified file and ensures the polygon is closed. Calculates bounding box of the polygon. </p><pre><code>Polygon readPolygon (\n    std::string filename\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the polygon file </li> </ul> <p>Returns:</p> <p>Polygon structure containing vertices and bounding box information </p>"},{"location":"BGFlood/_read_forcing_8cu/#function-readwlfile","title":"function readWLfile","text":"<p>Read water level boundary file. Reads water level boundary file and extracts time and water level data. Applies reference date adjustment if provided. </p><pre><code>std::vector&lt; SLTS &gt; readWLfile (\n    std::string WLfilename,\n    std::string &amp; refdate\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>WLfilename</code> Name of the water level boundary file </li> <li><code>refdate</code> Reference date for time adjustment </li> </ul> <p>Returns:</p> <p>Vector of SLTS structures containing time and water level data </p>"},{"location":"BGFlood/_read_forcing_8cu/#function-readwndfileuni","title":"function readWNDfileUNI","text":"<p>Read wind data from a specified file for spatially uniform forcing. Reads wind data from a specified file and extracts time, wind speed, wind direction, and calculates u and v wind components. Applies reference date adjustment if provided.  __ </p><pre><code>std::vector&lt; Windin &gt; readWNDfileUNI (\n    std::string filename,\n    std::string &amp; refdate,\n    double grdalpha\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the wind data file </li> <li><code>refdate</code> Reference date for time adjustment </li> <li><code>grdalpha</code> Grid rotation angle in radians </li> </ul> <p>Returns:</p> <p>Vector of Windin structures containing time, wind speed, wind direction, and u/v components </p>"},{"location":"BGFlood/_read_forcing_8cu/#function-readxbbathy","title":"function readXBbathy","text":"<p>Read bathymetry data from an XBeach-style .bot/.dep file into a provided array. Parses the file format and fills the provided array with bathymetry values. </p><pre><code>template&lt;class T&gt;\nvoid readXBbathy (\n    std::string filename,\n    int nx,\n    int ny,\n    T *&amp; zb\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the XBeach-style bathymetry file </li> <li><code>nx</code> Number of grid points in the x-direction </li> <li><code>ny</code> Number of grid points in the y-direction </li> <li><code>zb</code> Reference to the array to store bathymetry values </li> </ul>"},{"location":"BGFlood/_read_forcing_8cu/#function-readxbbathy-float","title":"function readXBbathy&lt; float &gt;","text":"<pre><code>template void readXBbathy&lt; float &gt; (\n    std::string filename,\n    int nx,\n    int ny,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readxbbathy-int","title":"function readXBbathy&lt; int &gt;","text":"<pre><code>template void readXBbathy&lt; int &gt; (\n    std::string filename,\n    int nx,\n    int ny,\n    int *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readbathyaschead","title":"function readbathyASCHead","text":"<p>Read header information from an ASC (bathymetry) file. Extracts grid size (nx, ny), grid spacing (dx), origin (xo, yo), and grid rotation angle (grdalpha). Adjusts origin if the file uses corner registration. </p><pre><code>void readbathyASCHead (\n    std::string filename,\n    int &amp; nx,\n    int &amp; ny,\n    double &amp; dx,\n    double &amp; xo,\n    double &amp; yo,\n    double &amp; grdalpha\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the ASC bathymetry file </li> <li><code>nx</code> Reference to store the number of grid points in the x-direction </li> <li><code>ny</code> Reference to store the number of grid points in the y-direction </li> <li><code>dx</code> Reference to store the grid spacing in the x-direction </li> <li><code>xo</code> Reference to store the x-coordinate of the grid origin </li> <li><code>yo</code> Reference to store the y-coordinate of the grid origin </li> <li><code>grdalpha</code> Reference to store the grid rotation angle in radians </li> </ul>"},{"location":"BGFlood/_read_forcing_8cu/#function-readbathyasczb","title":"function readbathyASCzb","text":"<p>Read (bathymetry) data from an ASC file into a provided array. Parses the ASC file format and fills the provided array with bathymetry values. </p><pre><code>template&lt;class T&gt;\nvoid readbathyASCzb (\n    std::string filename,\n    int nx,\n    int ny,\n    T *&amp; zb\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the ASC bathymetry file </li> <li><code>nx</code> Number of grid points in the x-direction </li> <li><code>ny</code> Number of grid points in the y-direction </li> <li><code>zb</code> Reference to the array to store bathymetry values </li> </ul>"},{"location":"BGFlood/_read_forcing_8cu/#function-readbathyasczb-float","title":"function readbathyASCzb&lt; float &gt;","text":"<pre><code>template void readbathyASCzb&lt; float &gt; (\n    std::string filename,\n    int nx,\n    int ny,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readbathyasczb-int","title":"function readbathyASCzb&lt; int &gt;","text":"<pre><code>template void readbathyASCzb&lt; int &gt; (\n    std::string filename,\n    int nx,\n    int ny,\n    int *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readbathyheadmd","title":"function readbathyHeadMD","text":"<p>Read header information from an MD bathymetry file (or other MD input map). Extracts grid size (nx, ny), grid spacing (dx), and grid rotation angle (grdalpha). </p><pre><code>void readbathyHeadMD (\n    std::string filename,\n    int &amp; nx,\n    int &amp; ny,\n    double &amp; dx,\n    double &amp; grdalpha\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the MD bathymetry file </li> <li><code>nx</code> Reference to store the number of grid points in the x-direction </li> <li><code>ny</code> Reference to store the number of grid points in the y-direction </li> <li><code>dx</code> Reference to store the grid spacing </li> <li><code>grdalpha</code> Reference to store the grid rotation angle in radians </li> </ul>"},{"location":"BGFlood/_read_forcing_8cu/#function-readbathymd","title":"function readbathyMD","text":"<p>Read bathymetry data from an MD file into a provided array. Parses the MD file format and fills the provided array with bathymetry values.  __ </p><pre><code>template&lt;class T&gt;\nvoid readbathyMD (\n    std::string filename,\n    T *&amp; zb\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the MD bathymetry file </li> <li><code>zb</code> Reference to the array to store bathymetry values </li> </ul>"},{"location":"BGFlood/_read_forcing_8cu/#function-readbathymd-float","title":"function readbathyMD&lt; float &gt;","text":"<pre><code>template void readbathyMD&lt; float &gt; (\n    std::string filename,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readbathymd-int","title":"function readbathyMD&lt; int &gt;","text":"<pre><code>template void readbathyMD&lt; int &gt; (\n    std::string filename,\n    int *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readbathydata","title":"function readbathydata","text":"<p>Read bathymetry data and apply corrections if needed. </p><pre><code>void readbathydata (\n    int posdown,\n    StaticForcingP &lt; float &gt; &amp; Sforcing\n) \n</code></pre> <p>Reads static bathymetry data and applies correction for positive-down convention (special case of readstaticforcing(Sforcing)).</p> <p>Parameters:</p> <ul> <li><code>posdown</code> If 1, apply positive-down correction </li> <li><code>Sforcing</code> Static forcing structure </li> </ul>"},{"location":"BGFlood/_read_forcing_8cu/#function-readbndfile","title":"function readbndfile","text":"<p>Read boundary forcing files (water levels or nest files). </p><pre><code>std::vector&lt; SLTS &gt; readbndfile (\n    std::string filename,\n    Param &amp; XParam\n) \n</code></pre> <p>Reads boundary forcing files based on their extension (.nc for nest files, others for water level files). Applies zsoffset correction if specified in model parameters. </p> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the boundary forcing file </li> <li><code>XParam</code> Model parameters </li> </ul> <p>Returns:</p> <p>Vector of SLTS structures containing boundary information </p>"},{"location":"BGFlood/_read_forcing_8cu/#function-readbndpolysegment","title":"function readbndpolysegment","text":"<p>Read boundary polygon segment and create polygon structure. </p><pre><code>Polygon readbndpolysegment (\n    bndsegment bnd,\n    Param XParam\n) \n</code></pre> <p>Reads boundary polygon segment based on specified keywords or file input.</p> <p>Parameters:</p> <ul> <li><code>bnd</code> Boundary segment structure </li> <li><code>XParam</code> Model parameters </li> </ul> <p>Returns:</p> <p>Polygon structure representing the boundary segment </p>"},{"location":"BGFlood/_read_forcing_8cu/#function-readforcing","title":"function readforcing","text":"<p>Wrapping function for reading all the forcing data. </p><pre><code>template&lt;class T&gt;\nvoid readforcing (\n    Param &amp; XParam,\n    Forcing &lt; T &gt; &amp; XForcing\n) \n</code></pre> <p>Reads bathymetry and other forcing data into the provided Forcing structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data structure</li> </ul> <p>wrapping function for reading all the forcing data </p>"},{"location":"BGFlood/_read_forcing_8cu/#function-readforcing-float","title":"function readforcing&lt; float &gt;","text":"<pre><code>template void readforcing&lt; float &gt; (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readforcingdata","title":"function readforcingdata","text":"<p>Read static forcing data from various file formats based on the file extension. Supports reading from .md, .nc, .bot/.dep, and .asc files. </p><pre><code>template&lt;class T&gt;\nvoid readforcingdata (\n    int step,\n    T forcing\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Type of the forcing parameter structure (e.g., StaticForcingP&lt;float&gt;, deformmap&lt;float&gt;, etc.) </li> </ul> <p>Parameters:</p> <ul> <li><code>step</code> Current time step for reading time-dependent data (if applicable) </li> <li><code>forcing</code> Forcing parameter structure containing file information and data storage </li> </ul>"},{"location":"BGFlood/_read_forcing_8cu/#function-readforcingdata_1","title":"function readforcingdata","text":"<p>Read dynamic forcing data from a NetCDF file based on the current simulation time. Interpolates between time steps to obtain the current forcing values. Handles NaN values and clamps edges if specified. </p><pre><code>void readforcingdata (\n    double totaltime,\n    DynForcingP &lt; float &gt; &amp; forcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>totaltime</code> Current simulation time </li> <li><code>forcing</code> Dynamic forcing parameter structure containing file information and data storage </li> </ul>"},{"location":"BGFlood/_read_forcing_8cu/#function-readforcingdata-staticforcingp-float","title":"function readforcingdata&lt; StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template void readforcingdata&lt; StaticForcingP&lt; float &gt; &gt; (\n    int step,\n    StaticForcingP &lt; float &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readforcingdata-staticforcingp-int","title":"function readforcingdata&lt; StaticForcingP&lt; int &gt; &gt;","text":"<pre><code>template void readforcingdata&lt; StaticForcingP&lt; int &gt; &gt; (\n    int step,\n    StaticForcingP &lt; int &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readforcingdata-deformmap-float","title":"function readforcingdata&lt; deformmap&lt; float &gt; &gt;","text":"<pre><code>template void readforcingdata&lt; deformmap&lt; float &gt; &gt; (\n    int step,\n    deformmap &lt; float &gt; forcing\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readforcinghead","title":"function readforcinghead","text":"<p>Read dynamic forcing metadata/header from a NetCDF file. Extracts grid size, spacing, origin, and time information. </p><pre><code>DynForcingP &lt; float &gt; readforcinghead (\n    DynForcingP &lt; float &gt; Fmap,\n    Param XParam\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>Fmap</code> Dynamic forcing parameter structure containing file information </li> <li><code>XParam</code> Simulation parameters (used for reference date) </li> </ul> <p>Returns:</p> <p>Updated dynamic forcing parameter structure with metadata </p>"},{"location":"BGFlood/_read_forcing_8cu/#function-readforcinghead_1","title":"function readforcinghead","text":"<p>Read static forcing metadata/header from various file formats based on the file extension. Supports reading from .md, .nc, .bot/.dep, and .asc files. Extracts grid size, spacing, origin, and other relevant information.  __ </p><pre><code>template&lt;class T&gt;\nT readforcinghead (\n    T ForcingParam\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Type of the forcing parameter structure (e.g., StaticForcingP&lt;float&gt;, deformmap&lt;float&gt;, etc.) </li> </ul> <p>Parameters:</p> <ul> <li><code>ForcingParam</code> Forcing parameter structure containing file information </li> </ul> <p>Returns:</p> <p>Updated forcing parameter structure with metadata </p>"},{"location":"BGFlood/_read_forcing_8cu/#function-readforcinghead-staticforcingp-float","title":"function readforcinghead&lt; StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template StaticForcingP &lt; float &gt; readforcinghead&lt; StaticForcingP&lt; float &gt; &gt; (\n    StaticForcingP &lt; float &gt; ForcingParam\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readforcinghead-forcingmap","title":"function readforcinghead&lt; forcingmap &gt;","text":"<pre><code>template forcingmap readforcinghead&lt; forcingmap &gt; (\n    forcingmap BathyParam\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readforcinghead-inputmap","title":"function readforcinghead&lt; inputmap &gt;","text":"<pre><code>template inputmap readforcinghead&lt; inputmap &gt; (\n    inputmap BathyParam\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readstaticforcing","title":"function readstaticforcing","text":"<p>Single parameter version of readstaticforcing(int step, T&amp; Sforcing). </p><pre><code>template&lt;class T&gt;\nvoid readstaticforcing (\n    T &amp; Sforcing\n) \n</code></pre> <p>Calls readstaticforcing with step set to 0.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>Sforcing</code> Static forcing structure to be read and allocated</li> </ul> <p>single parameter version of readstaticforcing(int step,T&amp; Sforcing) readstaticforcing(0, Sforcing); </p>"},{"location":"BGFlood/_read_forcing_8cu/#function-readstaticforcing_1","title":"function readstaticforcing","text":"<p>Allocate and read static (i.e. not varying in time) forcing data. Used for Bathymetry, roughness, deformation, etc. </p><pre><code>template&lt;class T&gt;\nvoid readstaticforcing (\n    int step,\n    T &amp; Sforcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>step</code> Time step (usually 0 for static data) </li> <li><code>Sforcing</code> Static forcing structure to be read and allocated</li> </ul> <p>Allocate and read static (i.e. not varying in time) forcing Used for Bathy, roughness, deformation </p>"},{"location":"BGFlood/_read_forcing_8cu/#function-readstaticforcing-staticforcingp-float","title":"function readstaticforcing&lt; StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template void readstaticforcing&lt; StaticForcingP&lt; float &gt; &gt; (\n    StaticForcingP &lt; float &gt; &amp; Sforcing\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readstaticforcing-staticforcingp-float_1","title":"function readstaticforcing&lt; StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template void readstaticforcing&lt; StaticForcingP&lt; float &gt; &gt; (\n    int step,\n    StaticForcingP &lt; float &gt; &amp; Sforcing\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readstaticforcing-staticforcingp-int","title":"function readstaticforcing&lt; StaticForcingP&lt; int &gt; &gt;","text":"<pre><code>template void readstaticforcing&lt; StaticForcingP&lt; int &gt; &gt; (\n    StaticForcingP &lt; int &gt; &amp; Sforcing\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readstaticforcing-staticforcingp-int_1","title":"function readstaticforcing&lt; StaticForcingP&lt; int &gt; &gt;","text":"<pre><code>template void readstaticforcing&lt; StaticForcingP&lt; int &gt; &gt; (\n    int step,\n    StaticForcingP &lt; int &gt; &amp; Sforcing\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readstaticforcing-deformmap-float","title":"function readstaticforcing&lt; deformmap&lt; float &gt; &gt;","text":"<pre><code>template void readstaticforcing&lt; deformmap&lt; float &gt; &gt; (\n    deformmap &lt; float &gt; &amp; Sforcing\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8cu/#function-readstaticforcing-deformmap-float_1","title":"function readstaticforcing&lt; deformmap&lt; float &gt; &gt;","text":"<pre><code>template void readstaticforcing&lt; deformmap&lt; float &gt; &gt; (\n    int step,\n    deformmap &lt; float &gt; &amp; Sforcing\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/ReadForcing.cu</code></p>"},{"location":"BGFlood/_read_forcing_8cu_source/","title":"File ReadForcing.cu","text":""},{"location":"BGFlood/_read_forcing_8cu_source/#file-readforcingcu","title":"File ReadForcing.cu","text":"<p>File List &gt; src &gt; ReadForcing.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //    \n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n\n\n\n#include \"ReadForcing.h\"\n\n\ntemplate &lt;class T&gt;\nvoid readforcing(Param &amp; XParam, Forcing&lt;T&gt; &amp; XForcing)\n{\n    int nt;\n\n    //=================\n    // Read Bathymetry\n    log(\"\\nReading bathymetry grid data...\");\n    for (int ib = 0; ib &lt; XForcing.Bathy.size(); ib++)\n    {\n        readbathydata(XParam.posdown, XForcing.Bathy[ib]);\n\n        if (ib == 0) // Fill Nan for only the first bathy listed, the others will use values from original bathy topo.\n        {\n            denan(XForcing.Bathy[ib].nx, XForcing.Bathy[ib].ny, T(0.0), XForcing.Bathy[ib].val);\n        }\n    }\n\n    if (XForcing.Bathy[0].extension.compare(\"nc\") == 0)\n    {\n        std::string nccrs;\n        //Get_CRS information from last bathymetry file\n        nccrs = readCRSfrombathy(XParam.crs_ref, XForcing.Bathy[XForcing.Bathy.size() - 1]);\n\n        if (!nccrs.empty())\n        {\n            XParam.crs_ref = nccrs;\n        }\n        //XParam.crs_ref = \"test2\";\n    }\n\n    if (isnan(XParam.grdalpha))\n    {\n        XParam.grdalpha=0.0;\n    }\n\n    bool gpgpu = XParam.GPUDEVICE &gt;= 0;\n\n    //=================\n    // Read bnd files\n    log(\"\\nReading boundary data...\");\n\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n        if (XForcing.bndseg[iseg].on)\n        {\n            //XForcing.bndseg[iseg].data = readbndfile(XForcing.bndseg[iseg].inputfile, XParam);\n\n            if (XForcing.bndseg[iseg].uniform == 1)\n            {\n                // grid uniform time varying rain input\n                XForcing.bndseg[iseg].data = readINfileUNI(XForcing.bndseg[iseg].inputfile, XParam.reftime);\n            }\n            else\n            {\n                XForcing.bndseg[iseg].WLmap.denanval = 0.0;\n                InitDynforcing(gpgpu, XParam, XForcing.bndseg[iseg].WLmap);\n                //readDynforcing(gpgpu, XParam.totaltime, XForcing.Rain);\n            }\n        }\n    }\n\n    /*\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n\n    if (!XForcing.left.inputfile.empty())\n    {\n        //XParam.leftbnd.data = readWLfile(XParam.leftbnd.inputfile);\n        XForcing.left.data = readbndfile(XForcing.left.inputfile, XParam, 0);\n\n        XForcing.left.on = true; \n        XForcing.left.nbnd = int(XForcing.left.data[0].wlevs.size());\n\n        if (gpgpu)\n        {\n            AllocateBndTEX(XForcing.left);\n        }\n\n\n    }\n    if (!XForcing.right.inputfile.empty())\n    {\n        XForcing.right.data = readbndfile(XForcing.right.inputfile, XParam, 2);\n        XForcing.right.on = true;\n        XForcing.right.nbnd = int(XForcing.right.data[0].wlevs.size());\n        if (gpgpu)\n        {\n            AllocateBndTEX(XForcing.right);\n        }\n    }\n    if (!XForcing.top.inputfile.empty())\n    {\n        XForcing.top.data = readbndfile(XForcing.top.inputfile, XParam, 3);\n        XForcing.top.on = true;\n        XForcing.top.nbnd = int(XForcing.top.data[0].wlevs.size());\n        if (gpgpu)\n        {\n            AllocateBndTEX(XForcing.top);\n        }\n    }\n    if (!XForcing.bot.inputfile.empty())\n    {\n        XForcing.bot.data = readbndfile(XForcing.bot.inputfile, XParam, 1);\n        XForcing.bot.on = true;\n        XForcing.bot.nbnd = int(XForcing.bot.data[0].wlevs.size());\n        if (gpgpu)\n        {\n            AllocateBndTEX(XForcing.bot);\n        }\n    }\n    */\n\n\n\n    //Check that endtime is no longer than boundaries (if specified to other than wall or neumann)\n    // Removed. This is better done in the sanity check!\n\n    //log(\"...done\");\n\n    //==================\n    // Friction maps \n\n    if (!XForcing.cf.empty())\n    {\n        //denanval = 0.0000001;\n        log(\"\\nRead Roughness map (cf) data...\");\n        // roughness map was specified!\n        //readstaticforcing(XForcing.cf);\n        //log(\"...done\");\n        // Here we are not using the automated denaning because we want to preserve the Nan in all but the \"main/first\" listed roughness map. \n        // This mean that subsequently listed roughness map can have large NAN holes in them.\n        for (int ib = 0; ib &lt; XForcing.cf.size(); ib++)\n        {\n\n            readstaticforcing(XForcing.cf[ib]);\n            if (ib == 0) // Fill Nan for only the first map listed, the others will use values from original bathy topo.\n            {\n                denan(XForcing.cf[ib].nx, XForcing.cf[ib].ny, T(0.0000001), XForcing.cf[ib].val);\n            }\n        }\n    }\n\n\n\n\n\n    //==================\n    // Rain losses maps\n\n    if (!XForcing.il.inputfile.empty())\n    {\n        log(\"\\nRead initial losses map (il) data...\");\n        XForcing.il.denanval = 0.0;\n\n        readstaticforcing(XForcing.il);\n        XParam.infiltration = true;\n    }\n    if (!XForcing.cl.inputfile.empty())\n    {\n        log(\"\\nRead initial losses map (cl) data...\");\n        XForcing.cl.denanval = 0.0;\n        readstaticforcing(XForcing.cl);\n        XParam.infiltration = true;\n    }\n\n    //=====================\n    // Deformation (tsunami generation)\n    if (XForcing.deform.size() &gt; 0)\n    {\n        log(\"\\nRead deform data...\");\n        // Deformation files was specified!\n\n        for (int nd = 0; nd &lt; XForcing.deform.size(); nd++)\n        {\n            XForcing.deform[nd].denanval = 0.0;\n            // read the roughness map header\n            readstaticforcing(XForcing.deform[nd]);\n            //XForcing.deform[nd].grid = readcfmaphead(XForcing.deform[nd].grid);\n\n            //Clamp edges to 0.0\n            clampedges(XForcing.deform[nd].nx, XForcing.deform[nd].ny, 0.0f, XForcing.deform[nd].val);\n\n\n\n            XParam.deformmaxtime = utils::max(XParam.deformmaxtime, XForcing.deform[nd].startime + XForcing.deform[nd].duration);\n\n            AllocateTEX(XForcing.deform[nd].nx, XForcing.deform[nd].ny, XForcing.deform[nd].GPU, XForcing.deform[nd].val);\n\n            // below might seem redundant but it simplifies the \n            // template &lt;class T&gt; __device__ T interpDyn2BUQ(T x, T y, TexSetP Forcing)\n            // function\n            XForcing.deform[nd].GPU.xo = float(XForcing.deform[nd].xo);\n            XForcing.deform[nd].GPU.yo = float(XForcing.deform[nd].yo);\n            XForcing.deform[nd].GPU.uniform = false;\n            XForcing.deform[nd].GPU.dx = float(XForcing.deform[nd].dx);\n            XForcing.deform[nd].GPU.dy = float(XForcing.deform[nd].dy);\n        }\n        //log(\"...done\");\n\n    }\n\n    //=====================\n    // Target level\n    if (XParam.AdaptCrit.compare(\"Targetlevel\") == 0)\n    {\n        log(\"\\nRead Target level data...\");\n        for (int nd = 0; nd &lt; XForcing.targetadapt.size(); nd++)\n        {\n            //\n            readstaticforcing(XForcing.targetadapt[nd]);\n        }\n    }\n\n\n    //======================\n    // Rivers\n    if (XForcing.rivers.size() &gt; 0)\n    {\n        // This part of the code only reads the meta data and data \n        // the full initialisation and detection of river blocks is done in model initialisation\n        log(\"\\nPreparing rivers (\" + std::to_string(XForcing.rivers.size()) + \" rivers)\");\n        for (int Rin = 0; Rin &lt; XForcing.rivers.size(); Rin++)\n        {\n            // Now read the discharge input and store to  \n            XForcing.rivers[Rin].flowinput = readFlowfile(XForcing.rivers[Rin].Riverflowfile, XParam.reftime);\n\n            //Check the time range of the river forcing\n            nt = (int)XForcing.rivers[Rin].flowinput.size();\n            XForcing.rivers[Rin].to = XForcing.rivers[Rin].flowinput[0].time;\n            XForcing.rivers[Rin].tmax = XForcing.rivers[Rin].flowinput[nt-1].time;\n            if ( XForcing.rivers[Rin].tmax &lt; XParam.endtime)\n            {\n                XParam.endtime = XForcing.rivers[Rin].tmax;\n                log(\"\\nWARNING: simulation endtime reduced to \" + std::to_string(XParam.endtime) + \" to fit the time range of the River number \" + std::to_string(Rin));\n            }\n            if (XForcing.rivers[Rin].to &gt; XParam.totaltime)\n            {\n                XParam.totaltime = XForcing.rivers[Rin].to;\n                log(\"\\nWARNING: simulation initial time increased to \" + std::to_string(XParam.totaltime) + \" to fit the time range of the River number \" + std::to_string(Rin));\n            }\n        }\n    }\n\n\n    //======================\n    // Wind file(s)\n    if (!XForcing.UWind.inputfile.empty())\n    {   \n        log(\"\\nPreparing Wind forcing\");\n        // This part of the code only reads the meta data and data for initial step\n        // the full initialisation of the cuda array and texture is done in model initialisation\n        if (XForcing.UWind.uniform == 1)\n        {\n            XForcing.VWind.uniform = true;\n\n            // grid uniform time varying wind input: wlevs[0] is wind speed and wlev[1] is direction\n            XForcing.VWind.inputfile = XForcing.UWind.inputfile;\n            XForcing.UWind.unidata = readWNDfileUNI(XForcing.UWind.inputfile, XParam.reftime, XParam.grdalpha);\n            XForcing.VWind.unidata = readWNDfileUNI(XForcing.VWind.inputfile, XParam.reftime, XParam.grdalpha);\n\n            // this below is a bit ugly but it simplifies the other functions\n            for (int n = 0; n &lt; XForcing.VWind.unidata.size(); n++)\n            {\n                XForcing.VWind.unidata[n].wspeed = XForcing.VWind.unidata[n].vwind;\n            }\n            for (int n = 0; n &lt; XForcing.UWind.unidata.size(); n++)\n            {\n                XForcing.UWind.unidata[n].wspeed = XForcing.UWind.unidata[n].uwind;\n            }\n\n            //Sanity check on the time range of the forcing\n            nt = (int)XForcing.UWind.unidata.size();\n            if (XForcing.UWind.unidata[nt - 1].time &lt; XParam.endtime || XForcing.VWind.unidata[nt - 1].time &lt; XParam.endtime)\n            {\n                XParam.endtime = min(XForcing.UWind.unidata[nt - 1].time, XForcing.VWind.unidata[nt - 1].time);\n                log(\"\\nWARNING: simulation endtime reduced to \" + std::to_string(XParam.endtime) + \" to fit the time range of the wind forcing. \");\n            }\n            if (XForcing.UWind.unidata[0].time &gt; XParam.totaltime || XForcing.VWind.unidata[0].time &gt; XParam.totaltime)\n            {\n                XParam.totaltime = max(XForcing.UWind.unidata[0].time, XForcing.VWind.unidata[0].time);\n                log(\"\\nWARNING: simulation initial time increased to \" + std::to_string(XParam.totaltime) + \" to fit the time range of the wind forcing. \");\n            }\n\n        }\n        else\n        {\n            //\n            //readDynforcing(gpgpu, XParam.totaltime, XForcing.UWind);\n            //readDynforcing(gpgpu, XParam.totaltime, XForcing.VWind);\n\n            XForcing.UWind.denanval = 0.0;\n            XForcing.VWind.denanval = 0.0;\n            InitDynforcing(gpgpu, XParam, XForcing.UWind);\n            InitDynforcing(gpgpu, XParam, XForcing.VWind);\n\n\n\n        }\n\n    }\n\n    //======================\n    // ATM file\n    if (!XForcing.Atmp.inputfile.empty())\n    {\n        log(\"\\nPreparing Atmospheric pressure forcing\");\n        // This part of the code only reads the meta data and data for initial step\n        // the full initialisation of the cuda array and texture is done in model initialisation\n        XForcing.Atmp.uniform = (XForcing.Atmp.extension.compare(\"nc\") == 0) ? 0 : 1;\n        if (XForcing.Atmp.uniform == 1)\n        {\n            // grid uniform time varying atm pressure input is pretty useless...\n            XForcing.Atmp.unidata = readINfileUNI(XForcing.Atmp.inputfile, XParam.reftime);\n        }\n        else\n        {\n            XForcing.Atmp.denanval = XParam.Paref;\n            InitDynforcing(gpgpu, XParam, XForcing.Atmp);\n            // Deflault is zero wich is terrible so change to Paref so limitwaves generated at the edge of forcing\n            // Users should insure there forcing extend well beyond the intended model extent.\n            XForcing.Atmp.clampedge = T(XParam.Paref);\n            //readDynforcing(gpgpu, XParam.totaltime, XForcing.Atmp);\n        }\n    }\n\n    //======================\n    // Rain file\n    if (!XForcing.Rain.inputfile.empty())\n    {\n        log(\"\\nPreparing Rain forcing\");\n        // This part of the code only reads the meta data and data for initial step\n        // the full initialisation of the cuda array and texture is done in model initialisation\n        if (XForcing.Rain.uniform == 1)\n        {\n            // grid uniform time varying rain input\n            XForcing.Rain.unidata = readINfileUNI(XForcing.Rain.inputfile, XParam.reftime);\n        }\n        else\n        {\n            XForcing.Rain.denanval = 0.0;\n            InitDynforcing(gpgpu, XParam, XForcing.Rain);\n            //readDynforcing(gpgpu, XParam.totaltime, XForcing.Rain);\n        }\n    }\n\n    //======================\n    // Polygon data\n    if (!XForcing.AOI.file.empty())\n    {\n        log(\"\\nRead AOI polygon\");\n\n        //Polygon Poly;\n        XForcing.AOI.poly = readPolygon(XForcing.AOI.file);\n\n        // = CounterCWPoly(Poly);\n        //\n\n    }\n\n    //======================\n    // Done\n    //======================\n}\n\ntemplate void readforcing&lt;float&gt;(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing);\n//template void readforcing&lt;double&gt;(Param&amp; XParam, Forcing&lt;double&gt;&amp; XForcing);\n\ntemplate &lt;class T&gt; void readstaticforcing(T&amp; Sforcing)\n{\n    readstaticforcing(0, Sforcing);\n}\n\ntemplate void readstaticforcing&lt;deformmap&lt;float&gt;&gt;(deformmap&lt;float&gt;&amp; Sforcing);\ntemplate void readstaticforcing&lt;StaticForcingP&lt;float&gt;&gt;(StaticForcingP&lt;float&gt;&amp; Sforcing);\ntemplate void readstaticforcing&lt;StaticForcingP&lt;int&gt;&gt;(StaticForcingP&lt;int&gt;&amp; Sforcing);\n\ntemplate &lt;class T&gt; void readstaticforcing(int step,T&amp; Sforcing)\n{\n    Sforcing=readforcinghead(Sforcing);\n\n\n    if (Sforcing.nx &gt; 0 &amp;&amp; Sforcing.ny &gt; 0)\n    {\n        AllocateCPU(Sforcing.nx, Sforcing.ny, Sforcing.val);\n\n        //readvarinfo(Sforcing.inputfile, Sforcing.varname, ddimU)\n        // read the roughness map header\n        //readvardata(0, Sforcing, Sforcing.val);\n        readforcingdata(step,Sforcing);\n        //readvardata(forcing.inputfile, forcing.varname, step, forcing.val);\n\n        denan(Sforcing.nx, Sforcing.ny, float(Sforcing.denanval), Sforcing.val);\n\n    }\n    else\n    {\n        //Error message\n        log(\"Error while reading forcing map file: \" + Sforcing.inputfile);\n    }\n}\ntemplate void readstaticforcing&lt;deformmap&lt;float&gt;&gt;(int step, deformmap&lt;float&gt;&amp; Sforcing);\ntemplate void readstaticforcing&lt;StaticForcingP&lt;float&gt;&gt;(int step, StaticForcingP&lt;float&gt;&amp; Sforcing);\ntemplate void readstaticforcing&lt;StaticForcingP&lt;int&gt;&gt;(int step, StaticForcingP&lt;int&gt;&amp; Sforcing);\n\n\nvoid InitDynforcing(bool gpgpu, Param&amp; XParam, DynForcingP&lt;float&gt;&amp; Dforcing)\n{\n    Dforcing = readforcinghead(Dforcing, XParam);\n\n    //Sanity check on the time range of the forcing\n    if (Dforcing.tmax &lt; XParam.endtime)\n    {\n        XParam.endtime = Dforcing.tmax;\n        log(\"\\nWARNING: simulation endtime reduced to \" + std::to_string(XParam.endtime) + \" to fit the time range provided in \" + Dforcing.inputfile);\n    }\n    if (Dforcing.to &gt; XParam.totaltime)\n    {\n        XParam.totaltime = Dforcing.to;\n        log(\"\\nWARNING: simulation initial time increased to \" + std::to_string(XParam.totaltime) + \" to fit the time provided in \" + Dforcing.inputfile);\n    }\n\n\n    if (Dforcing.nx &gt; 0 &amp;&amp; Dforcing.ny &gt; 0)\n    {\n        AllocateCPU(Dforcing.nx, Dforcing.ny, Dforcing.now, Dforcing.before, Dforcing.after, Dforcing.val);\n        readforcingdata(XParam.totaltime, Dforcing);\n\n        if (gpgpu)\n        { \n            AllocateGPU(Dforcing.nx, Dforcing.ny, Dforcing.now_g);\n            AllocateGPU(Dforcing.nx, Dforcing.ny, Dforcing.before_g);\n            AllocateGPU(Dforcing.nx, Dforcing.ny, Dforcing.after_g);\n            CopytoGPU(Dforcing.nx, Dforcing.ny, Dforcing.now, Dforcing.now_g);\n            CopytoGPU(Dforcing.nx, Dforcing.ny, Dforcing.before, Dforcing.before_g);\n            CopytoGPU(Dforcing.nx, Dforcing.ny, Dforcing.after, Dforcing.after_g);\n\n            // Allocate and bind textures\n            AllocateTEX(Dforcing.nx, Dforcing.ny, Dforcing.GPU, Dforcing.now);\n\n            // below might seem redundant but it simplifies the \n            // template &lt;class T&gt; __device__ T interpDyn2BUQ(T x, T y, TexSetP Forcing)\n            // function\n            Dforcing.GPU.xo = float(Dforcing.xo);\n            Dforcing.GPU.yo = float(Dforcing.yo);\n            Dforcing.GPU.uniform = Dforcing.uniform;\n            Dforcing.GPU.dx = float(Dforcing.dx);\n            Dforcing.GPU.dy = float(Dforcing.dy);\n        }\n\n    }\n    else\n    {\n        //Error message\n        log(\"Error while reading forcing map file: \" + Dforcing.inputfile);\n    }\n}\n\n\nvoid readDynforcing(bool gpgpu, double totaltime, DynForcingP&lt;float&gt;&amp; Dforcing)\n{\n    Dforcing = readforcinghead(Dforcing);\n\n\n    if (Dforcing.nx &gt; 0 &amp;&amp; Dforcing.ny &gt; 0)\n    {\n        AllocateCPU(Dforcing.nx, Dforcing.ny, Dforcing.now, Dforcing.before, Dforcing.after, Dforcing.val);\n        //\n        readforcingdata(totaltime, Dforcing);\n        if (gpgpu)\n        {\n            // Allocate and bind textures\n            AllocateTEX(Dforcing.nx, Dforcing.ny, Dforcing.GPU, Dforcing.now);\n        }\n\n    }\n    else\n    {\n        //Error message\n        log(\"Error while reading forcing map file: \" + Dforcing.inputfile);\n    }\n}\n\n\n\nvoid readbathydata(int posdown, StaticForcingP&lt;float&gt; &amp;Sforcing)\n{\n    readstaticforcing(Sforcing);\n\n    if (posdown == 1)\n    {\n\n        log(\"Bathy data is positive down...correcting\");\n        for (int j = 0; j &lt; Sforcing.ny; j++)\n        {\n            for (int i = 0; i &lt; Sforcing.nx; i++)\n            {\n                Sforcing.val[i + j * Sforcing.nx] = Sforcing.val[i + j * Sforcing.nx] * -1.0f;\n                //printf(\"%f\\n\", zb[i + (j)*nx]);\n\n            }\n        }\n    }\n}\n\n\nstd::string readCRSfrombathy(std::string crs_ref, StaticForcingP&lt;float&gt;&amp; Sforcing)\n{\n    int ncid, ncvarid, ncAttid, status;\n    size_t t_len;\n    char* crs;\n    char* crs_wkt;\n    std::string crs_ref2;\n\n    crs_wkt = \"\";\n\n    if (!Sforcing.inputfile.empty())\n    {\n\n        log(\"Reading CRS information from forcing metadata (file: \" + Sforcing.inputfile + \")\");\n\n\n        /* Open the netCDF file */\n        status = nc_open(Sforcing.inputfile.c_str(), NC_NOWRITE, &amp;ncid);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        /* Get variable ID */\n        status = nc_inq_varid(ncid, Sforcing.varname.c_str(), &amp;ncvarid);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        /* Get the attribute ID */\n        status = nc_inq_attid(ncid, ncvarid, \"grid_mapping\", &amp;ncAttid);\n        if (status == NC_NOERR)\n        {\n\n\n\n\n            /* Read CRS attribute from the variable */\n            status = nc_inq_attlen(ncid, ncvarid, \"grid_mapping\", &amp;t_len);\n            if (status != NC_NOERR) handle_ncerror(status);\n\n            crs = (char*)malloc(t_len + 1);\n\n            crs[t_len] = '\\0';\n\n            /* Read CRS attribute from the variable */\n            status = nc_get_att_text(ncid, ncvarid, \"grid_mapping\", crs);\n            if (status != NC_NOERR) handle_ncerror(status);\n\n            printf(\"grid info detected: %s\\n\", crs);\n\n\n            /*Get associated CRS variable ID*/\n            status = nc_inq_varid(ncid, crs, &amp;ncvarid);\n            if (status != NC_NOERR) handle_ncerror(status);\n\n            std::vector&lt;std::string&gt; attnamevec = { \"crs_wkt\",\"spatial_ref\" };\n\n            int idatt = -1;\n\n            for (int id = 0; id &lt; attnamevec.size(); id++)\n            {\n                /* Get the attribute ID */\n                status = nc_inq_attid(ncid, ncvarid, attnamevec[id].c_str(), &amp;ncAttid);\n                if (status == NC_NOERR)\n                {\n                    idatt = id;\n                    break;\n                }\n            }\n\n            if (idatt &gt; -1)\n            {\n\n                /* Get the attribute ID */\n                status = nc_inq_attid(ncid, ncvarid, attnamevec[idatt].c_str(), &amp;ncAttid);\n                if (status != NC_NOERR) handle_ncerror(status);\n\n\n                /* Read CRS attribute from the variable */\n                status = nc_inq_attlen(ncid, ncvarid, attnamevec[idatt].c_str(), &amp;t_len);\n                if (status != NC_NOERR) handle_ncerror(status);\n\n                crs_wkt = (char*)malloc(t_len + 1);\n                crs_wkt[t_len] = '\\0';\n\n                /* Read CRS attribute from the variable */\n                status = nc_get_att_text(ncid, ncvarid, attnamevec[idatt].c_str(), crs_wkt);\n                if (status != NC_NOERR) handle_ncerror(status);\n\n                printf(\"CRS_info: %s\\n\", crs_wkt);\n\n                //crs_ref = crs_wkt;\n                //crs_ref2 = crs_wkt;\n\n                //printf(\"CRS_info: %s\\n\", crs_ref2.c_str());\n            }\n            else\n            {\n                printf(\"CRS_info detected but not understood reverting to default CRS\\n Rename attribute in grid-mapping variable\\n\");\n\n                //crs_wkt = \"\"; //Move to the top of the file for initialisation\n            }\n\n        }\n        status = nc_close(ncid);\n        /* Close the netCDF file */\n        if ( status != NC_NOERR) {\n            fprintf(stderr, \"Error: Failed to close file.\\n\");\n        }\n    }\n    return crs_wkt;\n}\n\nPolygon readbndpolysegment(bndsegment bnd, Param XParam)\n{\n    Polygon bndpoly;\n    Vertex va,vb,vc,vd;\n    double epsbnd = calcres(XParam.dx,XParam.initlevel);\n    double xo = XParam.xo;\n    double xmax = XParam.xmax;\n    double yo = XParam.yo;\n    double ymax = XParam.ymax;\n\n\n    if (case_insensitive_compare(bnd.polyfile, \"all\") == 0)\n    {\n        va.x = xo - epsbnd; va.y = yo - epsbnd;\n        vb.x = xmax + epsbnd; vb.y = yo - epsbnd;\n        vc.x = xmax + epsbnd; vc.y = ymax + epsbnd;\n        vd.x = xo - epsbnd; vd.y = ymax + epsbnd;\n\n        bndpoly.vertices.push_back(va);\n        bndpoly.vertices.push_back(vb);\n        bndpoly.vertices.push_back(vc);\n        bndpoly.vertices.push_back(vd);\n        bndpoly.vertices.push_back(va);\n        bndpoly.xmin = va.x;\n        bndpoly.xmax = vb.x;\n        bndpoly.ymin = va.y;\n        bndpoly.ymax = vd.y;\n    }\n    else if (case_insensitive_compare(bnd.polyfile, \"file\") == 0)\n    {\n        if (bnd.WLmap.uniform == 1)\n        {\n\n            log(\"Warning: 'file' keyword used for uniform boundary, using 'all' instead\");\n\n            va.x = xo - epsbnd; va.y = yo - epsbnd;\n            vb.x = xmax + epsbnd; vb.y = yo - epsbnd;\n            vc.x = xmax + epsbnd; vc.y = ymax + epsbnd;\n            vd.x = xo - epsbnd; vd.y = ymax + epsbnd;\n\n            bndpoly.vertices.push_back(va);\n            bndpoly.vertices.push_back(vb);\n            bndpoly.vertices.push_back(vc);\n            bndpoly.vertices.push_back(vd);\n            bndpoly.vertices.push_back(va);\n            bndpoly.xmin = va.x;\n            bndpoly.xmax = vb.x;\n            bndpoly.ymin = va.y;\n            bndpoly.ymax = vd.y;\n        }\n        else\n        {\n            DynForcingP&lt;float&gt; Df = readforcinghead(bnd.WLmap, XParam);\n\n\n\n\n            va.x = Df.xo - epsbnd; va.y = Df.yo - epsbnd;\n            vb.x = Df.xmax + epsbnd; vb.y = Df.yo - epsbnd;\n            vc.x = Df.xmax + epsbnd; vc.y = Df.ymax + epsbnd;\n            vd.x = Df.xo - epsbnd; vd.y = Df.ymax + epsbnd;\n\n            bndpoly.vertices.push_back(va);\n            bndpoly.vertices.push_back(vb);\n            bndpoly.vertices.push_back(vc);\n            bndpoly.vertices.push_back(vd);\n            bndpoly.vertices.push_back(va);\n            bndpoly.xmin = va.x;\n            bndpoly.xmax = vb.x;\n            bndpoly.ymin = va.y;\n            bndpoly.ymax = vd.y;\n\n        }\n\n    }\n    else if (case_insensitive_compare(bnd.polyfile,\"left\")==0)\n    {\n        va.x = xo - epsbnd; va.y = yo;\n        vb.x = xo + epsbnd; vb.y = yo;\n        vc.x = xo + epsbnd; vc.y = ymax;\n        vd.x = xo - epsbnd; vd.y = ymax;\n\n        bndpoly.vertices.push_back(va);\n        bndpoly.vertices.push_back(vb);\n        bndpoly.vertices.push_back(vc);\n        bndpoly.vertices.push_back(vd);\n        bndpoly.vertices.push_back(va);\n        bndpoly.xmin = xo - epsbnd;\n        bndpoly.xmax = xo + epsbnd;\n        bndpoly.ymin = yo;\n        bndpoly.ymax = ymax;\n\n    }\n    else if (case_insensitive_compare(bnd.polyfile, \"bot\") == 0)\n    {\n        va.x = xo ; va.y = yo - epsbnd;\n        vb.x = xmax; vb.y = yo - epsbnd;\n        vc.x = xmax; vc.y = yo + epsbnd;\n        vd.x = xo; vd.y = yo + epsbnd;\n\n        bndpoly.vertices.push_back(va);\n        bndpoly.vertices.push_back(vb);\n        bndpoly.vertices.push_back(vc);\n        bndpoly.vertices.push_back(vd);\n        bndpoly.vertices.push_back(va);\n        bndpoly.xmin = xo ;\n        bndpoly.xmax = xmax;\n        bndpoly.ymin = yo - epsbnd;\n        bndpoly.ymax = yo + epsbnd;\n    }\n    else if (case_insensitive_compare(bnd.polyfile, \"right\") == 0)\n    {\n        va.x = xmax - epsbnd; va.y = yo;\n        vb.x = xmax + epsbnd; vb.y = yo;\n        vc.x = xmax + epsbnd; vc.y = ymax;\n        vd.x = xmax - epsbnd; vd.y = ymax;\n\n        bndpoly.vertices.push_back(va);\n        bndpoly.vertices.push_back(vb);\n        bndpoly.vertices.push_back(vc);\n        bndpoly.vertices.push_back(vd);\n        bndpoly.vertices.push_back(va);\n        bndpoly.xmin = xmax - epsbnd;\n        bndpoly.xmax = xmax + epsbnd;\n        bndpoly.ymin = yo;\n        bndpoly.ymax = ymax;\n\n    }\n    else if (case_insensitive_compare(bnd.polyfile, \"top\") == 0)\n    {\n\n        va.x = xo; va.y = ymax - epsbnd;\n        vb.x = xmax; vb.y = ymax - epsbnd;\n        vc.x = xmax; vc.y = ymax + epsbnd;\n        vd.x = xo; vd.y = ymax + epsbnd;\n\n        bndpoly.vertices.push_back(va);\n        bndpoly.vertices.push_back(vb);\n        bndpoly.vertices.push_back(vc);\n        bndpoly.vertices.push_back(vd);\n        bndpoly.vertices.push_back(va);\n        bndpoly.xmin = xo;\n        bndpoly.xmax = xmax;\n        bndpoly.ymin = ymax - epsbnd;\n        bndpoly.ymax = ymax + epsbnd;\n    }\n    else\n    {\n        bndpoly = readPolygon(bnd.polyfile);\n    }\n\n    return bndpoly;\n}\n\n\nstd::vector&lt;SLTS&gt; readbndfile(std::string filename,Param &amp; XParam)\n{\n    // read bnd or nest file\n    // side is for deciding whether we are talking about a left(side=0) bot (side =1) right (side=2) or top (side=3)\n    // Warning just made this up and need to have some sort of convention in the model\n    std::string fileext;\n    std::vector&lt;std::string&gt; extvec = split(filename, '.');\n\n    std::vector&lt;std::string&gt; nameelements;\n\n    std::vector&lt;SLTS&gt; Bndinfo;\n\n    //\n    //printf(\"%d\\n\", side);\n    /*\n    double xxmax;\n    int hor;\n    switch (side)\n    {\n        case 0://Left bnd\n        {\n            //xxo = XParam.yo;\n            xxmax = XParam.ymax;\n            //yy = XParam.xo;\n            hor = 0;\n            break;\n        }\n        case 1://Bot bnd\n        {\n            //xxo = XParam.xo;\n            xxmax = XParam.xmax;\n            //yy = XParam.yo;\n            hor = 1;\n            break;\n        }\n        case 2://Right bnd\n        {\n            //xxo = XParam.yo;\n            xxmax = XParam.ymax;\n            //yy = XParam.xmax;\n            hor = 0;\n            break;\n        }\n        case 3://Top bnd\n        {\n            //xxo = XParam.xo;\n            xxmax = XParam.xmax;\n            //yy = XParam.ymax;\n            hor = 1;\n            break;\n        }\n    }\n    */\n\n    //printf(\"%f\\t%f\\t%f\\n\", xxo, xxmax, yy);\n\n    nameelements = split(extvec.back(), '?');\n    if (nameelements.size() &gt; 1)\n    {\n\n        fileext = nameelements[0];\n    }\n    else\n    {\n        fileext = extvec.back();\n    }\n\n    if (fileext.compare(\"nc\") == 0)\n    {\n        //Bndinfo = readNestfile(filename);\n        //Bndinfo = readNestfile(filename, hor, XParam.eps, xxo, xxmax, yy);\n    }\n    else\n    {\n        Bndinfo = readWLfile(filename,XParam.reftime);\n    }\n\n    // Add zsoffset\n    for (int i = 0; i &lt; Bndinfo.size(); i++)\n    {\n        for (int n = 0; n &lt; Bndinfo[i].wlevs.size(); n++)\n        {\n            double addoffset = std::isnan(XParam.zsoffset) ? 0.0 : XParam.zsoffset;\n            Bndinfo[i].wlevs[n] = Bndinfo[i].wlevs[n] + addoffset;\n        }\n    }\n\n\n    return Bndinfo;\n}\n\n\n\nstd::vector&lt;SLTS&gt; readWLfile(std::string WLfilename, std::string &amp; refdate)\n{\n    std::vector&lt;SLTS&gt; slbnd;\n\n    std::ifstream fs(WLfilename);\n\n    if (fs.fail()) {\n        //std::cerr &lt;&lt; WLfilename &lt;&lt; \" Water level bnd file could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: Water level bnd file could not be opened : \" + WLfilename);\n        exit(1);\n    }\n\n    std::string line;\n    std::vector&lt;std::string&gt; lineelements;\n    std::vector&lt;double&gt; WLS;\n    SLTS slbndline;\n    while (std::getline(fs, line))\n    {\n        //std::cout &lt;&lt; line &lt;&lt; std::endl;\n\n        // skip empty lines and lines starting with #\n        if (!line.empty() &amp;&amp; line.substr(0, 1).compare(\"#\") != 0)\n        {\n            //Data should be in the format : time,Water level 1,Water level 2,...Water level n\n            //Location where the water level is 0:ny/(nwl-1):ny where nwl i the number of wlevnodes\n\n            //by default we expect tab delimitation\n            lineelements = split(line, '\\t');\n            if (lineelements.size() &lt; 2)\n            {\n                // Is it space delimited?\n                lineelements.clear();\n                lineelements = split(line, ' ');\n            }\n\n            if (lineelements.size() &lt; 2)\n            {\n                //Well it has to be comma delimited then\n                lineelements.clear();\n                lineelements = split(line, ',');\n            }\n            if (lineelements.size() &lt; 2)\n            {\n                // Giving up now! Could not read the files\n                //issue a warning and exit\n                //std::cerr &lt;&lt; WLfilename &lt;&lt; \"ERROR Water level bnd file format error. only \" &lt;&lt; lineelements.size() &lt;&lt; \" where at least 2 were expected. Exiting.\" &lt;&lt; std::endl;\n                log(\"ERROR:  Water level bnd file (\" + WLfilename + \") format error. only \" + std::to_string(lineelements.size()) + \" where at least 2 were expected. Exiting.\");\n                log(line);\n                exit(1);\n            }\n\n\n            //slbndline.time = std::stod(lineelements[0]);\n            slbndline.time = readinputtimetxt(lineelements[0], refdate);\n\n            for (int n = 1; n &lt; lineelements.size(); n++)\n            {\n                WLS.push_back(std::stod(lineelements[n]));\n            }\n\n\n\n            slbndline.wlevs = WLS;\n\n\n\n            //slbndline = readBSHline(line);\n            slbnd.push_back(slbndline);\n            //std::cout &lt;&lt; line &lt;&lt; std::endl;\n            WLS.clear();\n        }\n\n    }\n    fs.close();\n\n    //std::cout &lt;&lt; slbnd[0].wlev &lt;&lt; std::endl;\n\n\n    return slbnd;\n}\n\n\nstd::vector&lt;SLTS&gt; readNestfile(std::string ncfile,std::string varname, int hor ,double eps, double bndxo, double bndxmax, double bndy)\n{\n    // Prep boundary input vector from anorthe model output file\n    //this function works for botom top bnd as written but flips x and y for left and right bnds\n    // hor controls wheter the boundary is a top/botom bnd hor=1 or left/right hor=0 \n    std::vector&lt;SLTS&gt; slbnd;\n    SLTS slbndline;\n\n    std::vector&lt;double&gt; WLS,Unest,Vnest;\n    //Define NC file variables\n    int nnx, nny, nt, nbndpts, indxx, indyy, indx, indy,nx, ny;\n    double dx, dy, xxo, yyo, tmax,xo,yo;\n    double * ttt, *zsa;\n    bool checkhh = false;\n    int iswet;\n    bool flipx = false;\n    bool flipy = false;\n\n\n    // Read NC info // \n    //readgridncsize(ncfile,varname, nnx, nny, nt, dx, xxo, yyo, to, xmax, ymax, tmax, flipx, flipy);\n\n\n    if (hor == 0)\n    {\n        nx = nny;\n        ny = nnx;\n        xo = yyo;\n        yo = xxo;\n\n    }\n    else\n    {\n        nx = nnx;\n        ny = nny;\n        xo = xxo;\n        yo = yyo;\n    }\n\n    // Read time vector\n    ttt=(double *)malloc(nt*sizeof(double));\n    zsa = (double *)malloc(1*sizeof(double));\n    readnctime(ncfile, ttt);\n\n\n\n\n    nbndpts = (int)((bndxmax - bndxo) / dx)+1;\n\n    //printf(\"%f\\t%f\\t%f\\t%f\\n\", bndxmax, bndxo, xo, yo);\n    //printf(\"%f\\t%f\\t%f\\t%f\\n\", bndxmax, bndxo, xxo, yyo);\n    //printf(\"%f\\t%d\\t%d\\t%f\\n\", bndy, nx, ny, dx);\n\n    //printf(\"%d\\n\", nbndpts);\n    std::string ncfilestr;\n    std::string varstr,varstruu,varstrvv;\n\n\n    //char ncfile[]=\"ocean_ausnwsrstwq2.nc\";\n    std::vector&lt;std::string&gt; nameelements;\n    nameelements = split(ncfile, '?');\n    if (nameelements.size() &gt; 1)\n    {\n\n        ncfilestr = nameelements[0];\n        varstr = nameelements[1];\n    }\n    else\n    {\n\n        ncfilestr = ncfile;\n        varstr = \"zs\";\n        checkhh = true;\n    }\n\n\n    for (int it = 0; it &lt; nt; it++)\n    {\n        slbndline.time = ttt[it];\n        for (int ibnd = 0; ibnd &lt; nbndpts; ibnd++)\n        {\n            //\n            // Read// interpolate data for each bnds\n            indxx = utils::max(utils::min((int)((bndxo+(dx*ibnd) - xo) / dx), nx - 1), 0);\n            indyy = utils::max(utils::min((int)((bndy - yo) / dx), ny - 1), 0);\n\n            if (hor == 0)\n            {\n                indy = indxx;\n                indx = indyy;\n            }\n            else\n            {\n                indx = indxx;\n                indy = indyy;\n            }\n\n            iswet=readncslev1(ncfile, varstr, indx, indy, it, checkhh,eps, zsa);\n            //varstr\n            //printf(\"%d\\t%d\\t%d\\tzs=%f\\t%d\\n\", it,indx, indy, zsa[0],iswet);\n\n            if (iswet == 0)\n            {\n                if (WLS.size() &gt;= 1)\n                {\n                    zsa[0] = WLS.back();\n                }\n                else\n                {\n                    zsa[0] = 0.0;\n                }\n            }\n\n            WLS.push_back(zsa[0]);\n\n            printf(\"zs=%f\\\\n\", zsa[0]);\n\n            // If true nesting then uu and vv are expected to be present in the netcdf file \n\n            if (checkhh)\n            {\n                varstruu = \"uu\";\n                iswet = readncslev1(ncfilestr, varstruu, indx, indy, it, checkhh, eps, zsa);\n                //printf(\"%d\\t%d\\t%d\\tuu=%f\\t%d\\n\", it, indx, indy, zsa[0], iswet);\n                //printf(\"%d\\t%d\\t%f\\n\", indx, indy, zsa[0]);\n\n                if (iswet == 0)\n                {\n\n                    if (Unest.size() &gt;= 1)\n                    {\n                        zsa[0] = Unest.back();\n                    }\n                    else\n                    {\n                        zsa[0] = 0.0;\n                    }\n                }\n\n                Unest.push_back(zsa[0]);\n\n                varstrvv = \"vv\";\n                iswet = readncslev1(ncfile, varstrvv, indx, indy, it, checkhh, eps, zsa);\n                //printf(\"%d\\t%d\\t%d\\tvv=%f\\t%d\\n\", it, indx, indy, zsa[0], iswet);\n                //printf(\"%d\\t%d\\t%f\\n\", indx, indy, zsa[0]);\n\n                if (iswet == 0)\n                {\n                    if (Vnest.size() &gt;= 1)\n                    {\n                        zsa[0] = Vnest.back();\n                    }\n                    else\n                    {\n                        zsa[0] = 0.0;\n                    }\n                }\n\n                Vnest.push_back(zsa[0]);\n            }\n\n\n\n\n        }\n        slbndline.wlevs = WLS;\n        WLS.clear();\n        if (checkhh)\n        {\n            slbndline.uuvel = Unest;\n            slbndline.vvvel = Vnest;\n            Unest.clear();\n            Vnest.clear();\n        }\n\n        slbnd.push_back(slbndline);\n        //std::cout &lt;&lt; line &lt;&lt; std::endl;\n\n    }\n\n    free(ttt);\n    free(zsa);\n    return slbnd;\n}\n\n\nstd::vector&lt;Flowin&gt; readFlowfile(std::string Flowfilename, std::string &amp;refdate)\n{\n    std::vector&lt;Flowin&gt; slbnd;\n\n    std::ifstream fs(Flowfilename);\n\n    if (fs.fail()) {\n        std::cerr &lt;&lt; Flowfilename &lt;&lt; \" Flow file could not be opened\" &lt;&lt; std::endl;\n        write_text_to_log_file(\"ERROR: Flow/River file could not be opened \");\n        exit(1);\n    }\n\n    std::string line;\n    std::vector&lt;std::string&gt; lineelements;\n    //std::vector&lt;double&gt; WLS;\n    Flowin slbndline;\n    while (std::getline(fs, line))\n    {\n        //std::cout &lt;&lt; line &lt;&lt; std::endl;\n\n        // skip empty lines and lines starting with #\n        if (!line.empty() &amp;&amp; line.substr(0, 1).compare(\"#\") != 0)\n        {\n            //Data should be in the format : time,Water level 1,Water level 2,...Water level n\n            //Location where the water level is 0:ny/(nwl-1):ny where nwl i the number of wlevnodes\n\n            //by default we expect tab delimitation\n            lineelements = split(line, '\\t');\n            if (lineelements.size() != 2)\n            {\n                // Is it space delimited?\n                lineelements.clear();\n                lineelements = split(line, ' ');\n            }\n\n            if (lineelements.size() != 2)\n            {\n                //Well it has to be comma delimited then\n                lineelements.clear();\n                lineelements = split(line, ',');\n            }\n            if (lineelements.size() != 2)\n            {\n                // Giving up now! Could not read the files\n                //issue a warning and exit\n                //std::cerr &lt;&lt; Flowfilename &lt;&lt; \"ERROR flow file format error. only \" &lt;&lt; lineelements.size() &lt;&lt; \" where at least 2 were expected. Exiting.\" &lt;&lt; std::endl;\n                log(\"ERROR:  flow file (\" + Flowfilename + \") format error. only \" + std::to_string(lineelements.size()) + \" where at least 2 were expected. Exiting.\");\n                log(line);\n                exit(1);\n            }\n\n            slbndline.time = readinputtimetxt(lineelements[0], refdate);\n            //slbndline.time = std::stod(lineelements[0]);\n\n\n\n\n\n            slbndline.q = std::stod(lineelements[1]);;\n\n\n\n            //slbndline = readBSHline(line);\n            slbnd.push_back(slbndline);\n            //std::cout &lt;&lt; line &lt;&lt; std::endl;\n            //WLS.clear();\n        }\n\n    }\n    fs.close();\n\n    //std::cout &lt;&lt; slbnd[0].wlev &lt;&lt; std::endl;\n\n\n    return slbnd;\n}\n\n\nstd::vector&lt;Windin&gt; readINfileUNI(std::string filename, std::string &amp;refdate)\n{\n    std::vector&lt;Windin&gt; wndinput;\n\n    std::ifstream fs(filename);\n\n    if (fs.fail()) {\n        //std::cerr &lt;&lt; filename &lt;&lt; \"ERROR: Atm presssure / Rainfall file could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: Bnd file / Atm presssure / Rainfall file could not be opened : \" + filename);\n        exit(1);\n    }\n\n    std::string line;\n    std::vector&lt;std::string&gt; lineelements;\n    std::vector&lt;double&gt; WLS;\n    Windin wndline;\n    while (std::getline(fs, line))\n    {\n        // skip empty lines and lines starting with #\n        if (!line.empty() &amp;&amp; line.substr(0, 1).compare(\"#\") != 0)\n        {\n            //Data should be in the format : time,wind speed, wind dir, uwind vwind\n            //Location where the water level is 0:ny/(nwl-1):ny where nwl i the number of wlevnodes\n\n            //by default we expect tab delimitation\n            lineelements = split(line, '\\t');\n            if (lineelements.size() &lt; 2)\n            {\n                // Is it space delimited?\n                lineelements.clear();\n                lineelements = split(line, ' ');\n            }\n\n            if (lineelements.size() &lt; 2)\n            {\n                //Well it has to be comma delimited then\n                lineelements.clear();\n                lineelements = split(line, ',');\n            }\n            if (lineelements.size() &lt; 2)\n            {\n                // Giving up now! Could not read the files\n                //issue a warning and exit\n                //std::cerr &lt;&lt; filename &lt;&lt; \"ERROR Atm presssure / Rainfall  file format error. only \" &lt;&lt; lineelements.size() &lt;&lt; \" where at least 2 were expected. Exiting.\" &lt;&lt; std::endl;\n                log(\"ERROR:  Atm presssure / Rainfall file (\" + filename + \") format error. only \" + std::to_string(lineelements.size()) + \" where at least 2 were expected. Exiting.\");\n                log(line);\n                exit(1);\n            }\n\n            wndline.time = readinputtimetxt(lineelements[0], refdate);\n            //wndline.time = std::stod(lineelements[0]);\n            wndline.wspeed = std::stod(lineelements[1]);\n\n            wndinput.push_back(wndline);\n\n\n        }\n\n    }\n    fs.close();\n\n    return wndinput;\n}\n\n\nstd::vector&lt;Windin&gt; readWNDfileUNI(std::string filename, std::string &amp; refdate, double grdalpha)\n{\n    // Warning grdapha is expected in radian here\n    std::vector&lt;Windin&gt; wndinput;\n\n    std::ifstream fs(filename);\n\n    if (fs.fail()) {\n        //std::cerr &lt;&lt; filename &lt;&lt; \"ERROR: Wind file could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: Wind file could not be opened : \"+ filename);\n        exit(1);\n    }\n\n    std::string line;\n    std::vector&lt;std::string&gt; lineelements;\n    std::vector&lt;double&gt; WLS;\n    Windin wndline;\n    while (std::getline(fs, line))\n    {\n        //std::cout &lt;&lt; line &lt;&lt; std::endl;\n\n        // skip empty lines and lines starting with #\n        if (!line.empty() &amp;&amp; line.substr(0, 1).compare(\"#\") != 0)\n        {\n            //Data should be in the format : time,wind speed, wind dir, uwind vwind\n            //Location where the water level is 0:ny/(nwl-1):ny where nwl i the number of wlevnodes\n\n            //by default we expect tab delimitation\n            lineelements = split(line, '\\t');\n            if (lineelements.size() &lt; 3)\n            {\n                // Is it space delimited?\n                lineelements.clear();\n                lineelements = split(line, ' ');\n            }\n\n            if (lineelements.size() &lt; 3)\n            {\n                //Well it has to be comma delimited then\n                lineelements.clear();\n                lineelements = split(line, ',');\n            }\n            if (lineelements.size() &lt; 3)\n            {\n                // Giving up now! Could not read the files\n                //issue a warning and exit\n                //std::cerr &lt;&lt; filename &lt;&lt; \"ERROR Wind  file format error. only \" &lt;&lt; lineelements.size() &lt;&lt; \" where at least 3 were expected. Exiting.\" &lt;&lt; std::endl;\n                log(\"ERROR:  Wind file (\" + filename + \") format error. only \" + std::to_string(lineelements.size()) + \" where at least 3 were expected. Exiting.\");\n                log(line);\n                exit(1);\n            }\n\n            wndline.time = readinputtimetxt(lineelements[0], refdate);\n            //wndline.time = std::stod(lineelements[0]);\n            if (lineelements.size() == 5)\n            {\n                // U and v are explicitelly stated\n                wndline.wspeed = std::stod(lineelements[1]); // Actually his is a dummy \n                wndline.wdirection= std::stod(lineelements[2]); // Actually his is a dummy\n                wndline.uwind = std::stod(lineelements[3]);\n                wndline.vwind = std::stod(lineelements[4]);\n            }\n            else\n            {\n                // read speed and direction and directly convert to u and v\n                wndline.wspeed = std::stod(lineelements[1]); // Actually his is a dummy \n                wndline.wdirection = std::stod(lineelements[2]);\n                double theta = (1.5*pi - grdalpha) - wndline.wdirection*pi / 180;\n\n                wndline.uwind = wndline.wspeed*cos(theta);\n                wndline.vwind = wndline.wspeed*sin(theta);\n            }\n            //slbndline.wlevs = WLS;\n\n\n\n            //slbndline = readBSHline(line);\n            wndinput.push_back(wndline);\n            //std::cout &lt;&lt; line &lt;&lt; std::endl;\n\n        }\n\n    }\n    fs.close();\n\n    //std::cout &lt;&lt; slbnd[0].wlev &lt;&lt; std::endl;\n\n\n    return wndinput;\n}\n\n\nPolygon readPolygon(std::string filename)\n{\n    Polygon poly, polyB;\n    Vertex v;\n\n    std::string line;\n    std::vector&lt;std::string&gt; lineelements;\n\n    std::ifstream fs(filename);\n\n    if (fs.fail()) {\n        //std::cerr &lt;&lt; filename &lt;&lt; \"ERROR: Wind file could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: Polygon file could not be opened : \" + filename);\n        return poly;\n    }\n\n    while (std::getline(fs, line))\n    {\n        // skip empty lines and lines starting with #\n        if (!line.empty() &amp;&amp; line.substr(0, 1).compare(\"#\") != 0)\n        {\n            //\n            //line.substr(0, 1).compare(\"&gt;\") != 0\n            //by default we expect tab delimitation\n            lineelements = DelimLine(line, 2);\n            v.x = std::stod(lineelements[0]);\n            v.y = std::stod(lineelements[1]);\n\n            poly.vertices.push_back(v);\n\n        }\n    }\n\n\n    size_t nv = poly.vertices.size();\n\n    // Make sure ploygon is closed\n    double epsilon = std::numeric_limits&lt;double&gt;::epsilon() * 1000.0;\n\n    if ( !(abs(poly.vertices[0].x - poly.vertices[nv - 1].x) &lt; epsilon &amp;&amp; abs(poly.vertices[0].y - poly.vertices[nv - 1].y) &lt; epsilon) )\n    {\n        v.x = poly.vertices[0].x;\n        v.y = poly.vertices[0].y;\n\n        poly.vertices.push_back(v);\n    }\n\n    polyB = CounterCWPoly(poly);\n\n    polyB.xmin = polyB.vertices[0].x;\n    polyB.xmax = polyB.vertices[0].x;\n\n    polyB.ymin = polyB.vertices[0].y;\n    polyB.ymax = polyB.vertices[0].y;\n\n    for (int i = 0; i &lt; polyB.vertices.size(); i++)\n    {\n        polyB.xmin = utils::min(polyB.vertices[i].x, polyB.xmin);\n        polyB.xmax = utils::max(polyB.vertices[i].x, polyB.xmax);\n        polyB.ymin = utils::min(polyB.vertices[i].y, polyB.ymin);\n        polyB.ymax = utils::max(polyB.vertices[i].y, polyB.ymax);\n    }\n\n\n    return polyB;\n}\n\nstd::vector&lt;std::string&gt; DelimLine(std::string line, int n, char delim)\n{\n    std::vector&lt;std::string&gt; lineelements;\n    lineelements = split(line, delim);\n    if (lineelements.size() != n)\n    {\n        lineelements.clear();\n\n\n    }\n    return lineelements;\n}\n\nstd::vector&lt;std::string&gt; DelimLine(std::string line, int n)\n{\n    std::vector&lt;std::string&gt; LeTab;\n    std::vector&lt;std::string&gt; LeSpace;\n    std::vector&lt;std::string&gt; LeComma;\n\n    //std::vector&lt;std::string&gt; lineelements;\n\n    LeTab = DelimLine(line, n, '\\t');\n    LeSpace = DelimLine(line, n, ' ');\n    LeComma = DelimLine(line, n, ',');\n\n    if (LeTab.size() == n)\n    {\n        return LeTab;\n    }\n    if (LeSpace.size() == n)\n    {\n        return LeSpace;\n    }\n    if (LeComma.size() == n)\n    {\n        return LeComma;\n    }\n\n    LeTab.clear();\n\n    return LeTab;\n\n}\n\n\ntemplate &lt;class T&gt;\nvoid readforcingdata(int step,T forcing)\n{\n    // Check extension \n    std::string fileext;\n\n    fileext = forcing.extension;\n    //Now choose the right function to read the data\n\n    if (fileext.compare(\"md\") == 0)\n    {\n        readbathyMD(forcing.inputfile, forcing.val);\n    }\n    if (fileext.compare(\"nc\") == 0)\n    {\n        readvardata(forcing.inputfile, forcing.varname,step, forcing.val, forcing.flipxx, forcing.flipyy);\n    }\n    if (fileext.compare(\"bot\") == 0 || fileext.compare(\"dep\") == 0)\n    {\n        readXBbathy(forcing.inputfile, forcing.nx, forcing.ny, forcing.val);\n    }\n    if (fileext.compare(\"asc\") == 0)\n    {\n        //\n        readbathyASCzb(forcing.inputfile, forcing.nx, forcing.ny, forcing.val);\n    }\n\n    //return 1;\n}\ntemplate void readforcingdata&lt;StaticForcingP&lt;float&gt;&gt;(int step, StaticForcingP&lt;float&gt; forcing);\ntemplate void readforcingdata&lt;deformmap&lt;float&gt;&gt;(int step, deformmap&lt;float&gt; forcing);\ntemplate void readforcingdata&lt;StaticForcingP&lt;int&gt;&gt;(int step, StaticForcingP&lt;int&gt; forcing);\n//template void readforcingdata&lt;DynForcingP&lt;float&gt;&gt;(int step, DynForcingP&lt;float&gt; forcing);\n\n\nvoid readforcingdata(double totaltime, DynForcingP&lt;float&gt;&amp; forcing)\n{\n    int step = utils::min(utils::max((int)floor((totaltime - forcing.to) / forcing.dt), 0), forcing.nt - 2);\n    readvardata(forcing.inputfile, forcing.varname, step, forcing.before, forcing.flipxx, forcing.flipyy);\n    readvardata(forcing.inputfile, forcing.varname, step+1, forcing.after, forcing.flipxx, forcing.flipyy);\n\n    denan(forcing.nx, forcing.ny, float(forcing.denanval), forcing.before);\n    denan(forcing.nx, forcing.ny, float(forcing.denanval), forcing.after);\n\n    clampedges(forcing.nx, forcing.ny, forcing.clampedge, forcing.before);\n    clampedges(forcing.nx, forcing.ny, forcing.clampedge, forcing.after);\n\n    InterpstepCPU(forcing.nx, forcing.ny, step, totaltime, forcing.dt, forcing.now, forcing.before, forcing.after);\n    forcing.val = forcing.now;\n}\n\n\nDynForcingP&lt;float&gt; readforcinghead(DynForcingP&lt;float&gt; Fmap, Param XParam)\n{\n    // Read critical parameter for the forcing map\n    log(\"Forcing map was specified. Checking file... \");\n    std::string fileext = Fmap.extension;\n    //double dummy;\n\n\n    if (fileext.compare(\"nc\") == 0)\n    {\n        log(\"Reading Forcing file as netcdf file\");\n\n        //readgridncsize(Fmap.inputfile,Fmap.varname, Fmap.nx, Fmap.ny, Fmap.nt, Fmap.dx, Fmap.xo, Fmap.yo, Fmap.to, Fmap.xmax, Fmap.ymax, Fmap.tmax, Fmap.flipxx, Fmap.flipyy);\n        readgridncsize(Fmap, XParam);\n\n\n    }\n    else\n    {\n        log(\"Forcing file needs to be a .nc file you also need to specify the netcdf variable name like this ncfile.nc?myvar\");\n    }\n\n\n    return Fmap;\n}\n\n\ntemplate&lt;class T&gt; T readforcinghead(T ForcingParam)\n{\n    //std::string fileext;\n\n    //read bathy and perform sanity check\n\n    if (!ForcingParam.inputfile.empty())\n    {\n        //printf(\"bathy: %s\\n\", BathyParam.inputfile.c_str());\n\n        log(\"Reading forcing metadata. file: \" + ForcingParam.inputfile + \" extension: \" + ForcingParam.extension);\n\n\n\n\n        if (ForcingParam.extension.compare(\"md\") == 0)\n        {\n            //log(\"'md' file\");\n            readbathyHeadMD(ForcingParam.inputfile, ForcingParam.nx, ForcingParam.ny, ForcingParam.dx, ForcingParam.grdalpha);\n            ForcingParam.dy = ForcingParam.dx;\n            ForcingParam.xo = 0.0;\n            ForcingParam.yo = 0.0;\n            ForcingParam.xmax = ForcingParam.xo + (double(ForcingParam.nx) - 1.0) * ForcingParam.dx;\n            ForcingParam.ymax = ForcingParam.yo + (double(ForcingParam.ny) - 1.0) * ForcingParam.dx;\n\n        }\n        if (ForcingParam.extension.compare(\"nc\") == 0)\n        {\n            //int dummy;\n            //double dummyb, dummyc;\n            //log(\"netcdf file\");\n\n            //readgridncsize(ForcingParam.inputfile, ForcingParam.varname, ForcingParam.nx, ForcingParam.ny, dummy, ForcingParam.dx, ForcingParam.xo, ForcingParam.yo, dummyb, ForcingParam.xmax, ForcingParam.ymax, dummyc, ForcingParam.flipxx, ForcingParam.flipyy);\n            readgridncsize(ForcingParam);\n\n            //log(\"For nc of bathy file please specify grdalpha in the BG_param.txt (default 0)\");\n\n            //Check that the x and y variable are in crescent order:\n            if (ForcingParam.xmax &lt; ForcingParam.xo)\n            {\n                log(\"FATAL ERROR:  x coordinate isn't in crescent order in file: \" + ForcingParam.inputfile);\n                exit(1);\n            }\n            if (ForcingParam.ymax &lt; ForcingParam.yo)\n            {\n                log(\"FATAL ERROR:  y coordinate isn't in crescent order in file: \" + ForcingParam.inputfile);\n                exit(1);\n            }\n\n        }\n        if (ForcingParam.extension.compare(\"dep\") == 0 || ForcingParam.extension.compare(\"bot\") == 0)\n        {\n            //XBeach style file\n            log(ForcingParam.extension + \" file\");\n            log(\"For this type of bathy file please specify nx, ny, dx, xo, yo and grdalpha in the XBG_param.txt\");\n        }\n        if (ForcingParam.extension.compare(\"asc\") == 0)\n        {\n            //\n            //log(\"asc file\");\n            readbathyASCHead(ForcingParam.inputfile, ForcingParam.nx, ForcingParam.ny, ForcingParam.dx, ForcingParam.xo, ForcingParam.yo, ForcingParam.grdalpha);\n            ForcingParam.xmax = ForcingParam.xo + (ForcingParam.nx-1)* ForcingParam.dx;\n            ForcingParam.ymax = ForcingParam.yo + (ForcingParam.ny-1)* ForcingParam.dx;\n\n            log(\"For asc of bathy file please specify grdalpha in the BG_param.txt (default 0)\");\n        }\n\n\n\n        //XParam.nx = ceil(XParam.nx / 16) * 16;\n        //XParam.ny = ceil(XParam.ny / 16) * 16;\n\n\n\n        //printf(\"Bathymetry grid info: nx=%d\\tny=%d\\tdx=%lf\\talpha=%f\\txo=%lf\\tyo=%lf\\txmax=%lf\\tymax=%lf\\n\", BathyParam.nx, BathyParam.ny, BathyParam.dx, BathyParam.grdalpha * 180.0 / pi, BathyParam.xo, BathyParam.yo, BathyParam.xmax, BathyParam.ymax);\n        log(\"Forcing grid info: nx=\" + std::to_string(ForcingParam.nx) + \" ny=\" + std::to_string(ForcingParam.ny) + \" dx=\" + std::to_string(ForcingParam.dx) + \" dy=\" + std::to_string(ForcingParam.dy) + \" grdalpha=\" + std::to_string(ForcingParam.grdalpha*180.0 / pi) + \" xo=\" + std::to_string(ForcingParam.xo) + \" xmax=\" + std::to_string(ForcingParam.xmax) + \" yo=\" + std::to_string(ForcingParam.yo) + \" ymax=\" + std::to_string(ForcingParam.ymax));\n\n\n\n\n\n\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Fatal error: No bathymetry file specified. Please specify using 'bathy = Filename.bot'\" &lt;&lt; std::endl;\n        log(\"Fatal error : No bathymetry file specified. Please specify using 'bathy = Filename.md'\");\n        exit(1);\n    }\n    return ForcingParam;\n}\ntemplate inputmap readforcinghead&lt;inputmap&gt;(inputmap BathyParam);\ntemplate forcingmap readforcinghead&lt;forcingmap&gt;(forcingmap BathyParam);\n//template StaticForcingP&lt;float&gt; readBathyhead&lt;StaticForcingP&lt;float&gt;&gt;(StaticForcingP&lt;float&gt; BathyParam);\ntemplate StaticForcingP&lt;float&gt; readforcinghead&lt;StaticForcingP&lt;float&gt;&gt;(StaticForcingP&lt;float&gt; ForcingParam);\n\n\nvoid readbathyHeadMD(std::string filename, int &amp;nx, int &amp;ny, double &amp;dx, double &amp;grdalpha)\n{\n\n\n    std::ifstream fs(filename);\n\n    if (fs.fail()) {\n        std::cerr &lt;&lt; filename &lt;&lt; \" bathy file (md file) could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: bathy file could not be opened \"+ filename);\n        exit(1);\n    }\n\n    std::string line;\n    std::vector&lt;std::string&gt; lineelements;\n\n    std::getline(fs, line);\n    // skip empty lines\n    if (!line.empty())\n    {\n\n        //by default we expect tab delimitation\n        lineelements = split(line, '\\t');\n        if (lineelements.size() &lt; 5)\n        {\n            // Is it space delimited?\n            lineelements.clear();\n            lineelements = split(line, ' ');\n        }\n\n        if (lineelements.size() &lt; 5)\n        {\n            //Well it has to be comma delimited then\n            lineelements.clear();\n            lineelements = split(line, ',');\n        }\n        if (lineelements.size() &lt; 5)\n        {\n            // Giving up now! Could not read the files\n            //issue a warning and exit\n            std::cerr &lt;&lt; filename &lt;&lt; \"ERROR Wind bnd file format error. only \" &lt;&lt; lineelements.size() &lt;&lt; \" where 5 were expected. Exiting.\" &lt;&lt; std::endl;\n            log(\"ERROR:  Wind bnd file (\" + filename + \") format error. only \" + std::to_string(lineelements.size()) + \" where 3 were expected. Exiting.\");\n            log(line);\n            exit(1);\n        }\n\n        nx = std::stoi(lineelements[0]);\n        ny = std::stoi(lineelements[1]);\n        dx = std::stod(lineelements[2]);\n        grdalpha = std::stod(lineelements[4]);\n    }\n\n    fs.close();\n}\n\n\ntemplate &lt;class T&gt; void readbathyMD(std::string filename, T*&amp; zb)\n{\n    // Shit that doesn'y wor... Needs fixing \n    int nx;\n    //int ny;\n    //float dx;\n    std::ifstream fs(filename);\n\n    if (fs.fail()) {\n        std::cerr &lt;&lt; filename &lt;&lt; \" bathy file (md file) could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: bathy file could not be opened \" + filename);\n        exit(1);\n    }\n\n    std::string line;\n\n    std::vector&lt;std::string&gt; lineelements;\n\n    std::getline(fs, line);\n    if (!line.empty() &amp;&amp; line.substr(0, 1).compare(\"#\") != 0)\n    {\n        //by default we expect tab delimitation\n        lineelements = split(line, '\\t');\n        if (lineelements.size() &lt; 5)\n        {\n            // Is it space delimited?\n            lineelements.clear();\n            lineelements = split(line, ' ');\n        }\n\n        if (lineelements.size() &lt; 5)\n        {\n            //Well it has to be comma delimited then\n            lineelements.clear();\n            lineelements = split(line, ',');\n        }\n        if (lineelements.size() &lt; 5)\n        {\n            // Giving up now! Could not read the files\n            //issue a warning and exit\n            std::cerr &lt;&lt; filename &lt;&lt; \"ERROR Wind bnd file format error. only \" &lt;&lt; lineelements.size() &lt;&lt; \" where 5 were expected. Exiting.\" &lt;&lt; std::endl;\n            log(\"ERROR:  Wind bnd file (\" + filename + \") format error. only \" + std::to_string(lineelements.size()) + \" where 3 were expected. Exiting.\");\n            log(line);\n            exit(1);\n        }\n\n        nx = std::stoi(lineelements[0]);\n        //ny = std::stoi(lineelements[1]);\n        //dx = std::stof(lineelements[2]);\n        //grdalpha = std::stof(lineelements[4]);\n    }\n\n    int j = 0;\n    while (std::getline(fs, line))\n    {\n        //std::cout &lt;&lt; line &lt;&lt; std::endl;\n\n        // skip empty lines and lines starting with #\n        if (!line.empty() &amp;&amp; line.substr(0, 1).compare(\"#\") != 0)\n        {\n            lineelements = split(line, '\\t');\n            for (int i = 0; i &lt; nx; i++)\n            {\n                zb[i + j * nx] = T(std::stof(lineelements[0]));\n            }\n            j++;\n        }\n    }\n\n    fs.close();\n\n}\ntemplate void readbathyMD&lt;int&gt;(std::string filename, int*&amp; zb);\ntemplate void readbathyMD&lt;float&gt;(std::string filename, float*&amp; zb);\n\n\ntemplate &lt;class T&gt; void readXBbathy(std::string filename, int nx,int ny, T *&amp;zb)\n{\n    //read input data:\n    //printf(\"bathy: %s\\n\", filename);\n\n\n    //read md file\n     std::ifstream fs(filename);\n     std::string line;\n     std::vector&lt;std::string&gt; lineelements;\n\n\n\n\n\n    //int jreadzs;\n    for (int jnod = 0; jnod &lt; ny; jnod++)\n    {\n\n        std::getline(fs, line);\n\n        for (int inod = 0; inod &lt; nx; inod++)\n        {\n            //fscanf(fid, \"%f\", &amp;zb[inod + (jnod)*nx]);\n            zb[inod + jnod * nx] = T(std::stod(lineelements[0]));\n\n        }\n    }\n    fs.close();\n    //fclose(fid);\n}\ntemplate void readXBbathy&lt;int&gt;(std::string filename, int nx, int ny, int*&amp; zb);\ntemplate void readXBbathy&lt;float&gt;(std::string filename, int nx, int ny, float*&amp; zb);\n\n\nvoid readbathyASCHead(std::string filename, int &amp;nx, int &amp;ny, double &amp;dx, double &amp;xo, double &amp;yo, double &amp;grdalpha)\n{\n    std::ifstream fs(filename);\n\n    if (fs.fail()) {\n        std::cerr &lt;&lt; filename &lt;&lt; \" bathy file (md file) could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: bathy file could not be opened \" + filename);\n        exit(1);\n    }\n\n    std::string line,left,right;\n    std::vector&lt;std::string&gt; lineelements;\n    //std::size_t found;\n    //std::getline(fs, line);\n    int linehead = 0;\n\n    bool pixelreg = true;\n\n    while (linehead &lt; 6)\n    {\n        std::getline(fs, line);\n        // skip empty lines\n        if (!line.empty())\n        {\n\n            //by default we expect tab delimitation\n            lineelements = split(line, ' ');\n            if (lineelements.size() &lt; 2)\n            {\n                lineelements = split(line, '\\t');\n\n            }\n\n\n\n\n            left = trim(lineelements[0], \" \");\n            right = lineelements[1]; \n            //printf(\"left: %s ;right: %s\\n\", left.c_str(), right.c_str());\n            //found = left.compare(\"ncols\");// it needs to strictly compare\n            if (left.compare(\"ncols\") == 0) // found the parameter\n            {\n\n                //\n                nx = std::stoi(right);\n\n            }\n\n            if (left.compare(\"nrows\") == 0) // found the parameter\n            {\n\n                //\n                ny = std::stoi(right);\n\n            }\n            if (left.compare(\"cellsize\") == 0) // found the parameter\n            {\n\n                //\n                dx = std::stod(right);\n\n            }\n            if (left.compare(\"xllcenter\") == 0) // found the parameter\n            {\n\n                //\n                xo = std::stod(right);\n\n            }\n            if (left.compare(\"yllcenter\") == 0) // found the parameter\n            {\n                pixelreg = false;\n                //\n                yo = std::stod(right);\n\n            }\n            //if gridnode registration this should happen\n            if (left.compare(\"xllcorner\") == 0) // found the parameter\n            {\n                pixelreg = false;\n                //\n                xo = std::stod(right);\n\n            }\n            if (left.compare(\"yllcorner\") == 0) // found the parameter\n            {\n\n                //\n                yo = std::stod(right);\n                //This should be:\n                //yo = std::stod(right) + dx / 2.0;\n                //but by the time xo and yo are found dx has not been setup... awkward...\n\n            }\n            linehead++;\n        }\n    }\n\n    if (!pixelreg)\n    {\n        xo = xo + 0.5 * dx;\n        yo = yo + 0.5 * dx;\n    }\n\n    grdalpha = 0.0;\n    fs.close();\n\n}\n\n\n\ntemplate &lt;class T&gt; void readbathyASCzb(std::string filename,int nx, int ny, T* &amp;zb)\n{\n    //\n    std::ifstream fs(filename);\n    int linehead = 0;\n    std::string line;\n    if (fs.fail()) {\n        std::cerr &lt;&lt; filename &lt;&lt; \" bathy file (md file) could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: bathy file could not be opened \" + filename);\n        exit(1);\n    }\n    while (linehead &lt; 6)\n    {\n        //Skip header\n        std::getline(fs, line);\n        linehead++;\n    }\n    //int jreadzs;\n    for (int jnod = ny-1; jnod &gt;= 0; jnod--)\n    {\n\n\n\n        for (int inod = 0; inod &lt; nx; inod++)\n        {\n            //fscanf(fid, \"%f\", &amp;zb[inod + (jnod)*nx]);\n\n            fs &gt;&gt; zb[inod + (jnod)*nx];\n            //printf(\"%f\\n\", zb[inod + (jnod)*nx]);\n\n        }\n    }\n\n    fs.close();\n}\ntemplate void readbathyASCzb&lt;int&gt;(std::string filename, int nx, int ny, int*&amp; zb);\ntemplate void readbathyASCzb&lt;float&gt;(std::string filename, int nx, int ny, float*&amp; zb);\n\ntemplate &lt;class T&gt; void clampedges(int nx, int ny, T clamp, T* z)\n{\n    //\n    int ii;\n    for (int ix = 0; ix &lt;nx; ix++)\n    {\n        ii = ix + 0 * nx;\n        z[ii] = clamp;\n        ii = ix + (ny - 1) * nx;\n        z[ii] = clamp;\n    }\n\n    for (int iy = 0; iy &lt; ny; iy++)\n    {\n        ii = 0 + iy * nx;\n        z[ii] = clamp;\n        ii = (nx - 1) + (iy)* nx;\n        z[ii] = clamp;\n    }\n}\n\ntemplate &lt;class T&gt; void denan(int nx, int ny, float denanval, T* z)\n{\n    for (int j = 0; j &lt; ny; j++)\n    {\n        for (int i = 0; i &lt; nx; i++)\n        {\n            if (isnan(z[i + j * nx]))\n            {\n                z[i + j * nx] = denanval;\n            }\n        }\n    }\n}\ntemplate void denan&lt;float&gt;(int nx, int ny, float denanval, float* z);\ntemplate void denan&lt;double&gt;(int nx, int ny, float denanval, double* z);\n\nvoid denan(int nx, int ny, float denanval, int* z)\n{\n    //don't do nothing\n    // This function exist for cleaner compiling requirement that NaN do not exist in int form\n}\n\n//template &lt;class T&gt; void InterpstepCPU(int nx, int ny, int hdstep, float totaltime, float hddt, T*&amp; Ux, T* Uo, T* Un)\n//{\n//  //float fac = 1.0;\n//  T Uxo, Uxn;\n//\n//  /*Ums[tx]=Umask[ix];*/\n//\n//\n//\n//\n//  for (int i = 0; i &lt; nx; i++)\n//  {\n//      for (int j = 0; j &lt; ny; j++)\n//      {\n//          Uxo = Uo[i + nx * j];\n//          Uxn = Un[i + nx * j];\n//\n//          Ux[i + nx * j] = Uxo + (totaltime - hddt * hdstep) * (Uxn - Uxo) / hddt;\n//      }\n//  }\n//}\n//template void InterpstepCPU&lt;int&gt;(int nx, int ny, int hdstep, float totaltime, float hddt, int*&amp; Ux, int* Uo, int* Un);\n//template void InterpstepCPU&lt;float&gt;(int nx, int ny, int hdstep, float totaltime, float hddt, float*&amp; Ux, float* Uo, float* Un);\n</code></pre>"},{"location":"BGFlood/_read_forcing_8h/","title":"File ReadForcing.h","text":""},{"location":"BGFlood/_read_forcing_8h/#file-readforcingh","title":"File ReadForcing.h","text":"<p>FileList &gt; src &gt; ReadForcing.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Input.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"Read_netcdf.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Setup_GPU.h\"</code></li> <li><code>#include \"Poly.h\"</code></li> </ul>"},{"location":"BGFlood/_read_forcing_8h/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; std::string &gt; DelimLine (std::string line, int n, char delim) Split a string into a vector of substrings based on a specified delimiter. std::vector&lt; std::string &gt; DelimLine (std::string line, int n) Split a string into a vector of substrings based on common delimiters (tab, space, comma). Tries tab, space, and comma as delimiters and returns the first successful split with the expected number of elements. void InitDynforcing (bool gpgpu, Param &amp; XParam, DynForcingP&lt; float &gt; &amp; Dforcing) Initialize dynamic forcing data (Rain, wind, Atm pressure). void InterpstepCPU (int nx, int ny, int hdstep, float totaltime, float hddt, T *&amp; Ux, T * Uo, T * Un)  void clampedges (int nx, int ny, T clamp, T * z) Clamp the edges of a 2D array to a specified value. Sets the values at the edges of a 2D array to a specified clamp value. void denan (int nx, int ny, float denanval, int * z)  void denan (int nx, int ny, float denanval, T * z) Replace NaN values in a 2D array with a specified value. Iterates through a 2D array and replaces any NaN values with the specified denanval. void readDynforcing (bool gpgpu, double totaltime, DynForcingP&lt; float &gt; &amp; Dforcing) Deprecated function (!!!) to read dynamic forcing data for a given time. std::vector&lt; Flowin &gt; readFlowfile (std::string Flowfilename, std::string &amp; refdate) Read flow data from a specified file, for river forcing for example. Reads flow data from a specified file and extracts time and flow rate information. Applies reference date adjustment if provided. std::vector&lt; Windin &gt; readINfileUNI (std::string filename, std::string &amp; refdate) Read rain/atmospheric pressure data from a specified file for spatially uniform forcing. Reads rain/atmospheric pressure data from a specified file and extracts time and wind speed information. Applies reference date adjustment if provided. std::vector&lt; SLTS &gt; readNestfile (std::string ncfile, std::string varname, int hor, double eps, double bndxo, double bndxmax, double bndy) Read boundary nesting data from a NetCDF file. Reads boundary nesting data from a specified NetCDF file and variable name. Supports both horizontal and vertical boundaries. Polygon readPolygon (std::string filename) Read polygon from a specified file. Reads polygon vertices from a specified file and ensures the polygon is closed. Calculates bounding box of the polygon. std::vector&lt; SLTS &gt; readWLfile (std::string WLfilename, std::string &amp; refdate) Read water level boundary file. Reads water level boundary file and extracts time and water level data. Applies reference date adjustment if provided. std::vector&lt; Windin &gt; readWNDfileUNI (std::string filename, std::string &amp; refdate, double grdalpha) Read wind data from a specified file for spatially uniform forcing. Reads wind data from a specified file and extracts time, wind speed, wind direction, and calculates u and v wind components. Applies reference date adjustment if provided.  __ void readXBbathy (std::string filename, int nx, int ny, T *&amp; zb) Read bathymetry data from an XBeach-style .bot/.dep file into a provided array. Parses the file format and fills the provided array with bathymetry values. void readbathyASCHead (std::string filename, int &amp; nx, int &amp; ny, double &amp; dx, double &amp; xo, double &amp; yo, double &amp; grdalpha) Read header information from an ASC (bathymetry) file. Extracts grid size (nx, ny), grid spacing (dx), origin (xo, yo), and grid rotation angle (grdalpha). Adjusts origin if the file uses corner registration. void readbathyASCzb (std::string filename, int nx, int ny, T *&amp; zb) Read (bathymetry) data from an ASC file into a provided array. Parses the ASC file format and fills the provided array with bathymetry values. void readbathyHeadMD (std::string filename, int &amp; nx, int &amp; ny, double &amp; dx, double &amp; grdalpha) Read header information from an MD bathymetry file (or other MD input map). Extracts grid size (nx, ny), grid spacing (dx), and grid rotation angle (grdalpha). void readbathyMD (std::string filename, T *&amp; zb) Read bathymetry data from an MD file into a provided array. Parses the MD file format and fills the provided array with bathymetry values.  __ std::vector&lt; SLTS &gt; readbndfile (std::string filename, Param &amp; XParam) Read boundary forcing files (water levels or nest files). Polygon readbndpolysegment (bndsegment bnd, Param XParam) Read boundary polygon segment and create polygon structure. void readforcing (Param &amp; XParam, Forcing&lt; T &gt; &amp; XForcing) Wrapping function for reading all the forcing data. void readforcingdata (int step, T forcing) Read static forcing data from various file formats based on the file extension. Supports reading from .md, .nc, .bot/.dep, and .asc files. void readforcingdata (double totaltime, DynForcingP&lt; float &gt; &amp; forcing) Read dynamic forcing data from a NetCDF file based on the current simulation time. Interpolates between time steps to obtain the current forcing values. Handles NaN values and clamps edges if specified. DynForcingP&lt; float &gt; readforcinghead (DynForcingP&lt; float &gt; Fmap, Param XParam) Read dynamic forcing metadata/header from a NetCDF file. Extracts grid size, spacing, origin, and time information. T readforcinghead (T Fmap) Read static forcing metadata/header from various file formats based on the file extension. Supports reading from .md, .nc, .bot/.dep, and .asc files. Extracts grid size, spacing, origin, and other relevant information.  __ void readstaticforcing (T &amp; Sforcing) Single parameter version of readstaticforcing(int step, T&amp; Sforcing). void readstaticforcing (int step, T &amp; Sforcing) Allocate and read static (i.e. not varying in time) forcing data. Used for Bathymetry, roughness, deformation, etc."},{"location":"BGFlood/_read_forcing_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_read_forcing_8h/#function-delimline","title":"function DelimLine","text":"<p>Split a string into a vector of substrings based on a specified delimiter. </p><pre><code>std::vector&lt; std::string &gt; DelimLine (\n    std::string line,\n    int n,\n    char delim\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s</code> The input string to be split </li> <li><code>delim</code> The delimiter character used for splitting </li> </ul> <p>Returns:</p> <p>Vector of substrings </p>"},{"location":"BGFlood/_read_forcing_8h/#function-delimline_1","title":"function DelimLine","text":"<p>Split a string into a vector of substrings based on common delimiters (tab, space, comma). Tries tab, space, and comma as delimiters and returns the first successful split with the expected number of elements. </p><pre><code>std::vector&lt; std::string &gt; DelimLine (\n    std::string line,\n    int n\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>line</code> The input string to be split </li> <li><code>n</code> The expected number of elements after splitting </li> </ul> <p>Returns:</p> <p>Vector of substrings if successful; empty vector otherwise </p>"},{"location":"BGFlood/_read_forcing_8h/#function-initdynforcing","title":"function InitDynforcing","text":"<p>Initialize dynamic forcing data (Rain, wind, Atm pressure). </p><pre><code>void InitDynforcing (\n    bool gpgpu,\n    Param &amp; XParam,\n    DynForcingP &lt; float &gt; &amp; Dforcing\n) \n</code></pre> <p>Reads dynamic forcing header and allocates memory for dynamic forcing arrays.</p> <p>Parameters:</p> <ul> <li><code>gpgpu</code> Use GPU acceleration </li> <li><code>XParam</code> Model parameters </li> <li><code>Dforcing</code> Dynamic forcing structure </li> </ul>"},{"location":"BGFlood/_read_forcing_8h/#function-interpstepcpu","title":"function InterpstepCPU","text":"<pre><code>template&lt;class T&gt;\nvoid InterpstepCPU (\n    int nx,\n    int ny,\n    int hdstep,\n    float totaltime,\n    float hddt,\n    T *&amp; Ux,\n    T * Uo,\n    T * Un\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8h/#function-clampedges","title":"function clampedges","text":"<p>Clamp the edges of a 2D array to a specified value. Sets the values at the edges of a 2D array to a specified clamp value. </p><pre><code>template&lt;class T&gt;\nvoid clampedges (\n    int nx,\n    int ny,\n    T clamp,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>nx</code> Number of grid points in the x-direction </li> <li><code>ny</code> Number of grid points in the y-direction </li> <li><code>clamp</code> Value to set at the edges </li> <li><code>z</code> Pointer to the 2D array (flattened as 1D) to be modified </li> </ul>"},{"location":"BGFlood/_read_forcing_8h/#function-denan","title":"function denan","text":"<pre><code>void denan (\n    int nx,\n    int ny,\n    float denanval,\n    int * z\n) \n</code></pre>"},{"location":"BGFlood/_read_forcing_8h/#function-denan_1","title":"function denan","text":"<p>Replace NaN values in a 2D array with a specified value. Iterates through a 2D array and replaces any NaN values with the specified denanval. </p><pre><code>template&lt;class T&gt;\nvoid denan (\n    int nx,\n    int ny,\n    float denanval,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>nx</code> Number of grid points in the x-direction </li> <li><code>ny</code> Number of grid points in the y-direction </li> <li><code>denanval</code> Value to replace NaN values with </li> <li><code>z</code> Pointer to the 2D array (flattened as 1D) to be modified </li> </ul>"},{"location":"BGFlood/_read_forcing_8h/#function-readdynforcing","title":"function readDynforcing","text":"<p>Deprecated function (!!!) to read dynamic forcing data for a given time. </p><pre><code>void readDynforcing (\n    bool gpgpu,\n    double totaltime,\n    DynForcingP &lt; float &gt; &amp; Dforcing\n) \n</code></pre> <p>Reads and allocates dynamic forcing arrays for the specified time.</p> <p>Parameters:</p> <ul> <li><code>gpgpu</code> Use GPU acceleration </li> <li><code>totaltime</code> Current simulation time </li> <li><code>Dforcing</code> Dynamic forcing structure</li> </ul> <p>This is a deprecated function! See InitDynforcing() instead </p>"},{"location":"BGFlood/_read_forcing_8h/#function-readflowfile","title":"function readFlowfile","text":"<p>Read flow data from a specified file, for river forcing for example. Reads flow data from a specified file and extracts time and flow rate information. Applies reference date adjustment if provided. </p><pre><code>std::vector&lt; Flowin &gt; readFlowfile (\n    std::string Flowfilename,\n    std::string &amp; refdate\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>Flowfilename</code> Name of the flow data file </li> <li><code>refdate</code> Reference date for time adjustment </li> </ul> <p>Returns:</p> <p>Vector of Flowin structures containing time and flow rate data </p>"},{"location":"BGFlood/_read_forcing_8h/#function-readinfileuni","title":"function readINfileUNI","text":"<p>Read rain/atmospheric pressure data from a specified file for spatially uniform forcing. Reads rain/atmospheric pressure data from a specified file and extracts time and wind speed information. Applies reference date adjustment if provided. </p><pre><code>std::vector&lt; Windin &gt; readINfileUNI (\n    std::string filename,\n    std::string &amp; refdate\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the rain/atmospheric pressure data file </li> <li><code>refdate</code> Reference date for time adjustment </li> </ul> <p>Returns:</p> <p>Vector of Windin structures containing time and wind speed data </p>"},{"location":"BGFlood/_read_forcing_8h/#function-readnestfile","title":"function readNestfile","text":"<p>Read boundary nesting data from a NetCDF file. Reads boundary nesting data from a specified NetCDF file and variable name. Supports both horizontal and vertical boundaries. </p><pre><code>std::vector&lt; SLTS &gt; readNestfile (\n    std::string ncfile,\n    std::string varname,\n    int hor,\n    double eps,\n    double bndxo,\n    double bndxmax,\n    double bndy\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>ncfile</code> Name of the NetCDF file </li> <li><code>varname</code> Name of the variable to read </li> <li><code>hor</code> If 1, read horizontal boundary (top/bottom); if 0 read vertical boundary (left/right) </li> <li><code>eps</code> Small value to avoid numerical issues </li> <li><code>bndxo</code> Starting coordinate of the boundary </li> <li><code>bndxmax</code> Ending coordinate of the boundary </li> <li><code>bndy</code> Fixed coordinate of the boundary </li> </ul> <p>Returns:</p> <p>Vector of SLTS structures containing time and water level data </p>"},{"location":"BGFlood/_read_forcing_8h/#function-readpolygon","title":"function readPolygon","text":"<p>Read polygon from a specified file. Reads polygon vertices from a specified file and ensures the polygon is closed. Calculates bounding box of the polygon. </p><pre><code>Polygon readPolygon (\n    std::string filename\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the polygon file </li> </ul> <p>Returns:</p> <p>Polygon structure containing vertices and bounding box information </p>"},{"location":"BGFlood/_read_forcing_8h/#function-readwlfile","title":"function readWLfile","text":"<p>Read water level boundary file. Reads water level boundary file and extracts time and water level data. Applies reference date adjustment if provided. </p><pre><code>std::vector&lt; SLTS &gt; readWLfile (\n    std::string WLfilename,\n    std::string &amp; refdate\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>WLfilename</code> Name of the water level boundary file </li> <li><code>refdate</code> Reference date for time adjustment </li> </ul> <p>Returns:</p> <p>Vector of SLTS structures containing time and water level data </p>"},{"location":"BGFlood/_read_forcing_8h/#function-readwndfileuni","title":"function readWNDfileUNI","text":"<p>Read wind data from a specified file for spatially uniform forcing. Reads wind data from a specified file and extracts time, wind speed, wind direction, and calculates u and v wind components. Applies reference date adjustment if provided.  __ </p><pre><code>std::vector&lt; Windin &gt; readWNDfileUNI (\n    std::string filename,\n    std::string &amp; refdate,\n    double grdalpha\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the wind data file </li> <li><code>refdate</code> Reference date for time adjustment </li> <li><code>grdalpha</code> Grid rotation angle in radians </li> </ul> <p>Returns:</p> <p>Vector of Windin structures containing time, wind speed, wind direction, and u/v components </p>"},{"location":"BGFlood/_read_forcing_8h/#function-readxbbathy","title":"function readXBbathy","text":"<p>Read bathymetry data from an XBeach-style .bot/.dep file into a provided array. Parses the file format and fills the provided array with bathymetry values. </p><pre><code>template&lt;class T&gt;\nvoid readXBbathy (\n    std::string filename,\n    int nx,\n    int ny,\n    T *&amp; zb\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the XBeach-style bathymetry file </li> <li><code>nx</code> Number of grid points in the x-direction </li> <li><code>ny</code> Number of grid points in the y-direction </li> <li><code>zb</code> Reference to the array to store bathymetry values </li> </ul>"},{"location":"BGFlood/_read_forcing_8h/#function-readbathyaschead","title":"function readbathyASCHead","text":"<p>Read header information from an ASC (bathymetry) file. Extracts grid size (nx, ny), grid spacing (dx), origin (xo, yo), and grid rotation angle (grdalpha). Adjusts origin if the file uses corner registration. </p><pre><code>void readbathyASCHead (\n    std::string filename,\n    int &amp; nx,\n    int &amp; ny,\n    double &amp; dx,\n    double &amp; xo,\n    double &amp; yo,\n    double &amp; grdalpha\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the ASC bathymetry file </li> <li><code>nx</code> Reference to store the number of grid points in the x-direction </li> <li><code>ny</code> Reference to store the number of grid points in the y-direction </li> <li><code>dx</code> Reference to store the grid spacing in the x-direction </li> <li><code>xo</code> Reference to store the x-coordinate of the grid origin </li> <li><code>yo</code> Reference to store the y-coordinate of the grid origin </li> <li><code>grdalpha</code> Reference to store the grid rotation angle in radians </li> </ul>"},{"location":"BGFlood/_read_forcing_8h/#function-readbathyasczb","title":"function readbathyASCzb","text":"<p>Read (bathymetry) data from an ASC file into a provided array. Parses the ASC file format and fills the provided array with bathymetry values. </p><pre><code>template&lt;class T&gt;\nvoid readbathyASCzb (\n    std::string filename,\n    int nx,\n    int ny,\n    T *&amp; zb\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the ASC bathymetry file </li> <li><code>nx</code> Number of grid points in the x-direction </li> <li><code>ny</code> Number of grid points in the y-direction </li> <li><code>zb</code> Reference to the array to store bathymetry values </li> </ul>"},{"location":"BGFlood/_read_forcing_8h/#function-readbathyheadmd","title":"function readbathyHeadMD","text":"<p>Read header information from an MD bathymetry file (or other MD input map). Extracts grid size (nx, ny), grid spacing (dx), and grid rotation angle (grdalpha). </p><pre><code>void readbathyHeadMD (\n    std::string filename,\n    int &amp; nx,\n    int &amp; ny,\n    double &amp; dx,\n    double &amp; grdalpha\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the MD bathymetry file </li> <li><code>nx</code> Reference to store the number of grid points in the x-direction </li> <li><code>ny</code> Reference to store the number of grid points in the y-direction </li> <li><code>dx</code> Reference to store the grid spacing </li> <li><code>grdalpha</code> Reference to store the grid rotation angle in radians </li> </ul>"},{"location":"BGFlood/_read_forcing_8h/#function-readbathymd","title":"function readbathyMD","text":"<p>Read bathymetry data from an MD file into a provided array. Parses the MD file format and fills the provided array with bathymetry values.  __ </p><pre><code>template&lt;class T&gt;\nvoid readbathyMD (\n    std::string filename,\n    T *&amp; zb\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the MD bathymetry file </li> <li><code>zb</code> Reference to the array to store bathymetry values </li> </ul>"},{"location":"BGFlood/_read_forcing_8h/#function-readbndfile","title":"function readbndfile","text":"<p>Read boundary forcing files (water levels or nest files). </p><pre><code>std::vector&lt; SLTS &gt; readbndfile (\n    std::string filename,\n    Param &amp; XParam\n) \n</code></pre> <p>Reads boundary forcing files based on their extension (.nc for nest files, others for water level files). Applies zsoffset correction if specified in model parameters. </p> <p>Parameters:</p> <ul> <li><code>filename</code> Name of the boundary forcing file </li> <li><code>XParam</code> Model parameters </li> </ul> <p>Returns:</p> <p>Vector of SLTS structures containing boundary information </p>"},{"location":"BGFlood/_read_forcing_8h/#function-readbndpolysegment","title":"function readbndpolysegment","text":"<p>Read boundary polygon segment and create polygon structure. </p><pre><code>Polygon readbndpolysegment (\n    bndsegment bnd,\n    Param XParam\n) \n</code></pre> <p>Reads boundary polygon segment based on specified keywords or file input.</p> <p>Parameters:</p> <ul> <li><code>bnd</code> Boundary segment structure </li> <li><code>XParam</code> Model parameters </li> </ul> <p>Returns:</p> <p>Polygon structure representing the boundary segment </p>"},{"location":"BGFlood/_read_forcing_8h/#function-readforcing","title":"function readforcing","text":"<p>Wrapping function for reading all the forcing data. </p><pre><code>template&lt;class T&gt;\nvoid readforcing (\n    Param &amp; XParam,\n    Forcing &lt; T &gt; &amp; XForcing\n) \n</code></pre> <p>Reads bathymetry and other forcing data into the provided Forcing structure.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XForcing</code> Forcing data structure</li> </ul> <p>wrapping function for reading all the forcing data </p>"},{"location":"BGFlood/_read_forcing_8h/#function-readforcingdata","title":"function readforcingdata","text":"<p>Read static forcing data from various file formats based on the file extension. Supports reading from .md, .nc, .bot/.dep, and .asc files. </p><pre><code>template&lt;class T&gt;\nvoid readforcingdata (\n    int step,\n    T forcing\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Type of the forcing parameter structure (e.g., StaticForcingP&lt;float&gt;, deformmap&lt;float&gt;, etc.) </li> </ul> <p>Parameters:</p> <ul> <li><code>step</code> Current time step for reading time-dependent data (if applicable) </li> <li><code>forcing</code> Forcing parameter structure containing file information and data storage </li> </ul>"},{"location":"BGFlood/_read_forcing_8h/#function-readforcingdata_1","title":"function readforcingdata","text":"<p>Read dynamic forcing data from a NetCDF file based on the current simulation time. Interpolates between time steps to obtain the current forcing values. Handles NaN values and clamps edges if specified. </p><pre><code>void readforcingdata (\n    double totaltime,\n    DynForcingP &lt; float &gt; &amp; forcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>totaltime</code> Current simulation time </li> <li><code>forcing</code> Dynamic forcing parameter structure containing file information and data storage </li> </ul>"},{"location":"BGFlood/_read_forcing_8h/#function-readforcinghead","title":"function readforcinghead","text":"<p>Read dynamic forcing metadata/header from a NetCDF file. Extracts grid size, spacing, origin, and time information. </p><pre><code>DynForcingP &lt; float &gt; readforcinghead (\n    DynForcingP &lt; float &gt; Fmap,\n    Param XParam\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>Fmap</code> Dynamic forcing parameter structure containing file information </li> <li><code>XParam</code> Simulation parameters (used for reference date) </li> </ul> <p>Returns:</p> <p>Updated dynamic forcing parameter structure with metadata </p>"},{"location":"BGFlood/_read_forcing_8h/#function-readforcinghead_1","title":"function readforcinghead","text":"<p>Read static forcing metadata/header from various file formats based on the file extension. Supports reading from .md, .nc, .bot/.dep, and .asc files. Extracts grid size, spacing, origin, and other relevant information.  __ </p><pre><code>template&lt;class T&gt;\nT readforcinghead (\n    T Fmap\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Type of the forcing parameter structure (e.g., StaticForcingP&lt;float&gt;, deformmap&lt;float&gt;, etc.) </li> </ul> <p>Parameters:</p> <ul> <li><code>ForcingParam</code> Forcing parameter structure containing file information </li> </ul> <p>Returns:</p> <p>Updated forcing parameter structure with metadata </p>"},{"location":"BGFlood/_read_forcing_8h/#function-readstaticforcing","title":"function readstaticforcing","text":"<p>Single parameter version of readstaticforcing(int step, T&amp; Sforcing). </p><pre><code>template&lt;class T&gt;\nvoid readstaticforcing (\n    T &amp; Sforcing\n) \n</code></pre> <p>Calls readstaticforcing with step set to 0.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>Sforcing</code> Static forcing structure to be read and allocated</li> </ul> <p>single parameter version of readstaticforcing(int step,T&amp; Sforcing) readstaticforcing(0, Sforcing); </p>"},{"location":"BGFlood/_read_forcing_8h/#function-readstaticforcing_1","title":"function readstaticforcing","text":"<p>Allocate and read static (i.e. not varying in time) forcing data. Used for Bathymetry, roughness, deformation, etc. </p><pre><code>template&lt;class T&gt;\nvoid readstaticforcing (\n    int step,\n    T &amp; Sforcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>step</code> Time step (usually 0 for static data) </li> <li><code>Sforcing</code> Static forcing structure to be read and allocated</li> </ul> <p>Allocate and read static (i.e. not varying in time) forcing Used for Bathy, roughness, deformation </p> <p>The documentation for this class was generated from the following file <code>src/ReadForcing.h</code></p>"},{"location":"BGFlood/_read_forcing_8h_source/","title":"File ReadForcing.h","text":""},{"location":"BGFlood/_read_forcing_8h_source/#file-readforcingh","title":"File ReadForcing.h","text":"<p>File List &gt; src &gt; ReadForcing.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef READFORCING_H\n#define READFORCING_H\n\n#include \"General.h\"\n#include \"Input.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"Read_netcdf.h\"\n#include \"Forcing.h\"\n#include \"Util_CPU.h\"\n#include \"Setup_GPU.h\"\n#include \"Poly.h\"\n\ntemplate&lt;class T&gt; void readforcing(Param&amp; XParam, Forcing&lt;T&gt; &amp; XForcing);\n\nstd::vector&lt;SLTS&gt; readbndfile(std::string filename, Param &amp; XParam);\nstd::vector&lt;SLTS&gt; readWLfile(std::string WLfilename,  std::string&amp; refdate);\n\nstd::vector&lt;SLTS&gt; readNestfile(std::string ncfile, std::string varname, int hor, double eps, double bndxo, double bndxmax, double bndy);\n\nstd::vector&lt;Flowin&gt; readFlowfile(std::string Flowfilename, std::string &amp;refdate);\nstd::vector&lt;Windin&gt; readINfileUNI(std::string filename, std::string &amp;refdate);\nstd::vector&lt;Windin&gt; readWNDfileUNI(std::string filename, std::string &amp; refdate, double grdalpha);\n\nvoid denan(int nx, int ny, float denanval, int* z);\ntemplate &lt;class T&gt; void denan(int nx, int ny, float denanval, T* z);\n\n\nvoid readDynforcing(bool gpgpu,double totaltime, DynForcingP&lt;float&gt;&amp; Dforcing);\n\n//DynForcingP&lt;float&gt; readforcinghead(DynForcingP&lt;float&gt; Fmap);\nDynForcingP&lt;float&gt; readforcinghead(DynForcingP&lt;float&gt; Fmap, Param XParam);\n\n\ntemplate&lt;class T&gt; T readforcinghead(T Fmap);\n//template&lt;class T&gt; T readBathyhead(T BathyParam);\ntemplate&lt;class T&gt; void readstaticforcing(T&amp; Sforcing);\ntemplate &lt;class T&gt; void readstaticforcing(int step, T&amp; Sforcing);\n\ntemplate &lt;class T&gt; void readforcingdata(int step, T forcing);\nvoid readforcingdata(double totaltime, DynForcingP&lt;float&gt;&amp; forcing);\nvoid readbathyHeadMD(std::string filename, int &amp;nx, int &amp;ny, double &amp;dx, double &amp;grdalpha);\ntemplate &lt;class T&gt; void readbathyMD(std::string filename, T*&amp; zb);\ntemplate &lt;class T&gt; void readXBbathy(std::string filename, int nx, int ny, T*&amp; zb);\n\nvoid InitDynforcing(bool gpgpu, Param&amp; XParam, DynForcingP&lt;float&gt;&amp; Dforcing);\n\nvoid readbathyASCHead(std::string filename, int &amp;nx, int &amp;ny, double &amp;dx, double &amp;xo, double &amp;yo, double &amp;grdalpha);\ntemplate &lt;class T&gt; void readbathyASCzb(std::string filename, int nx, int ny, T*&amp; zb);\n\ntemplate &lt;class T&gt; void InterpstepCPU(int nx, int ny, int hdstep, float totaltime, float hddt, T*&amp; Ux, T* Uo, T* Un);\n\ntemplate &lt;class T&gt; void clampedges(int nx, int ny, T clamp, T* z);\n\nstd::vector&lt;std::string&gt; DelimLine(std::string line, int n, char delim);\nstd::vector&lt;std::string&gt; DelimLine(std::string line, int n);\nPolygon readPolygon(std::string filename);\nPolygon readbndpolysegment(bndsegment bnd, Param XParam);\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_read_input_8cu/","title":"File ReadInput.cu","text":""},{"location":"BGFlood/_read_input_8cu/#file-readinputcu","title":"File ReadInput.cu","text":"<p>FileList &gt; src &gt; ReadInput.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ReadInput.h\"</code></li> </ul>"},{"location":"BGFlood/_read_input_8cu/#public-functions","title":"Public Functions","text":"Type Name void InitialiseToutput (T_output &amp; Toutput_loc, Param XParam) Initialise the Toutput structure with output times. This function reads the output times from a specified input string and ensures that the times are within the simulation time range. If no valid times are provided, it defaults to using the total time and end time. std::vector&lt; double &gt; ReadTRangestr (std::vector&lt; std::string &gt; timestr, double start, double end, std::string reftime) Read and interpret a time range string, converting it to a vector of doubles within specified bounds. This function interprets a time range string formatted as \"t_init:t_step:t_end\", where each component can be a specific time value or a keyword representing the start or end of the overall time range. It converts the range into a vector of double values representing discrete time steps, ensuring all values fall within the provided start and end bounds. std::vector&lt; std::string &gt; ReadToutSTR (std::string paramstr) Split a comma-separated parameter string into a vector of strings. std::vector&lt; double &gt; ReadToutput (std::vector&lt; std::string &gt; paramstr, Param XParam) Read and interpret output time specifications from a vector of parameter strings. This function processes a vector of parameter strings that specify output times, which can include individual time values or ranges defined by a start, step, and end. It converts these specifications into a vector of double values representing the output times, ensuring all times fall within the simulation's total time and end time. double ReadTvalstr (std::string timestr, double start, double end, std::string reftime) Read and interpret a time value string, converting it to a double within specified bounds. This function interprets a time value string, which can represent specific keywords (\"start\", \"end\"), relative times, or absolute date-time strings. It converts the string to a double value representing time, ensuring it falls within the provided start and end bounds. void Readparamfile (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, std::string Paramfile) Read and parse the parameter file. Opens the specified parameter file (default: BG_param.txt file), reads its contents, and updates the provided parameter structures: Param class (XParam) andForcing class (XForcing). std::size_t case_insensitive_compare (std::string s1, std::string s2) Perform a non case-insensitive comparison between two strings or a string and a vector of strings. This function converts both strings to lowercase and compares them. If a vector of strings is provided, it compares the first string against each string in the vector. std::size_t case_insensitive_compare (std::string s1, std::vector&lt; std::string &gt; vecstr) Perform a non case-insensitive comparison between a string and a vector of strings. This function converts the first string to lowercase and compares it against each string in the vector. void checkparamsanity (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing) Check and adjust the sanity of model parameters and forcing data. This function checks the sanity of the model parameters and forcing data. It adjusts parameters as needed, ensuring they are within acceptable ranges and consistent with each other. std::string findparameter (std::vector&lt; std::string &gt; parameterstr, std::string line) Find and extract the value of a specified parameter from a configuration line. This function searches for a specified parameter in a given line of text, and extracts its associated value if found. It handles comments and whitespace appropriately. std::string findparameter (std::string parameterstr, std::string line) Find and extract the value of a specified parameter from a configuration line. This function searches for a specified parameter in a given line of text, and extracts its associated value if found. It handles comments and whitespace appropriately. double readApproxtimestr (std::string input) Convert an approximate time string to a double value in seconds. This function interprets a time string that may include a numeric value followed by a time unit (e.g., \"seconds\", \"minutes\", \"hours\", \"days\", \"months\", \"years\") and converts it to a double value representing the equivalent time in seconds. If the unit is not recognized, it defaults to seconds. bndsegment readbndline (std::string parametervalue) Read boundary segment information from a parameter value string. This function parses a parameter value string to extract boundary segment information, including type, input file, and polygon file. It also reads file information and sets the expected type of input based on the file extension. bndsegment readbndlineside (std::string parametervalue, std::string side) Read boundary segment information from a parameter value string for a specific side. This function parses a parameter value string to extract boundary segment information, including type, input file, and polygon file for a specified side. It also reads file information and sets the expected type of input based on the file extension. T readfileinfo (std::string input, T outinfo) Parse a parameter string and update the parameter structure. Parses a line from the parameter file and updates the given parameter structure. Convert file name into name and extension. This is used for various input classes template inputmap readfileinfo&lt;inputmap&gt;(std::string input, inputmap outinfo); template forcingmap readfileinfo&lt;forcingmap&gt;(std::string input, forcingmap outinfo); template StaticForcingP&lt;float&gt; readfileinfo&lt;StaticForcingP&lt;float&gt;&gt;(std::string input, StaticForcingP&lt;float&gt; outinfo); template DynForcingP&lt;float&gt; readfileinfo&lt;DynForcingP&lt;float&gt; &gt;(std::string input,DynForcingP&lt;float&gt; outinfo); template deformmap&lt;float&gt; readfileinfo&lt;deformmap&lt;float&gt;&gt;(std::string input, deformmap&lt;float&gt; outinfo);. template DynForcingP&lt; float &gt; readfileinfo&lt; DynForcingP&lt; float &gt; &gt; (std::string input, DynForcingP&lt; float &gt; outinfo)  template StaticForcingP&lt; float &gt; readfileinfo&lt; StaticForcingP&lt; float &gt; &gt; (std::string input, StaticForcingP&lt; float &gt; outinfo)  template deformmap&lt; float &gt; readfileinfo&lt; deformmap&lt; float &gt; &gt; (std::string input, deformmap&lt; float &gt; outinfo)  template forcingmap readfileinfo&lt; forcingmap &gt; (std::string input, forcingmap outinfo)  template inputmap readfileinfo&lt; inputmap &gt; (std::string input, inputmap outinfo)  bool readparambool (std::string paramstr, bool defaultval) Convert a parameter string to a boolean value, with a default fallback. This function interprets a parameter string as a boolean value, returning true for recognized true values and false for recognized false values. If the string does not match any known values, it returns a specified default value.  __ Param readparamstr (std::string line, Param param) Parse a parameter string and update the parameter structure. Forcing&lt; T &gt; readparamstr (std::string line, Forcing&lt; T &gt; forcing) Parse a parameter string and update the forcing structure. Parses a line from the parameter file and updates the given forcing structure. Read BG_param.txt line and convert parameter to the right parameter in the class Return an updatedForcing class. double setendtime (Param XParam, Forcing&lt; float &gt; XForcing) Adjust the simulation \"endtime\" based on maximum time in forcings. This function checks the end times of boundary forcing data and adjusts the simulation end time if any boundary forcing ends before the specified end time. A warning is logged if the end time is reduced. void split (const std::string &amp; s, char delim, std::vector&lt; std::string &gt; &amp; elems) Split a string into tokens based on a specified delimiter, skipping empty tokens. This function takes a string and splits it into a vector of substrings using the specified delimiter. Empty tokens resulting from consecutive delimiters are skipped. std::vector&lt; std::string &gt; split (const std::string &amp; s, char delim) Split a string into tokens based on a specified character delimiter, skipping empty tokens. This function takes a string and splits it into a vector of substrings using the specified delimiter. Empty tokens resulting from consecutive delimiters are skipped. std::vector&lt; std::string &gt; split (const std::string s, const std::string delim) Split a string into tokens based on a specified substring delimiter. This function takes a string and splits it into a vector of substrings using the specified substring delimiter. void split_full (const std::string &amp; s, char delim, std::vector&lt; std::string &gt; &amp; elems) Split a string into tokens based on a specified delimiter, preserving empty tokens. This function takes a string and splits it into a vector of substrings using the specified delimiter. Unlike the standard split function, this version preserves empty tokens that result from consecutive delimiters.  __ std::vector&lt; std::string &gt; split_full (const std::string &amp; s, char delim) Split a string into tokens based on a specified character delimiter, preserving empty tokens. This function takes a string and splits it into a vector of substrings using the specified delimiter. Unlike the standard split function, this version preserves empty tokens that result from consecutive delimiters.  __ std::string trim (const std::string &amp; str, const std::string &amp; whitespace) Trim leading and trailing whitespace from a string. This function removes all leading and trailing characters from the input string that are present in the specified whitespace string."},{"location":"BGFlood/_read_input_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_read_input_8cu/#function-initialisetoutput","title":"function InitialiseToutput","text":"<p>Initialise the Toutput structure with output times. This function reads the output times from a specified input string and ensures that the times are within the simulation time range. If no valid times are provided, it defaults to using the total time and end time. </p><pre><code>void InitialiseToutput (\n    T_output &amp; Toutput_loc,\n    Param XParam\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>Toutput_loc</code> Reference to the T_output structure to be initialised. </li> <li><code>XParam</code> The Param structure containing simulation parameters. </li> </ul>"},{"location":"BGFlood/_read_input_8cu/#function-readtrangestr","title":"function ReadTRangestr","text":"<p>Read and interpret a time range string, converting it to a vector of doubles within specified bounds. This function interprets a time range string formatted as \"t_init:t_step:t_end\", where each component can be a specific time value or a keyword representing the start or end of the overall time range. It converts the range into a vector of double values representing discrete time steps, ensuring all values fall within the provided start and end bounds. </p><pre><code>std::vector&lt; double &gt; ReadTRangestr (\n    std::vector&lt; std::string &gt; timestr,\n    double start,\n    double end,\n    std::string reftime\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>timestr</code> A vector of strings representing the time range components: [t_init, t_step, t_end]. </li> <li><code>start</code> The start time bound. </li> <li><code>end</code> The end time bound. </li> <li><code>reftime</code> The reference time for interpreting absolute date-time strings. </li> </ul> <p>Returns:</p> <p>A vector of double values representing the interpreted time steps within the specified range. </p>"},{"location":"BGFlood/_read_input_8cu/#function-readtoutstr","title":"function ReadToutSTR","text":"<p>Split a comma-separated parameter string into a vector of strings. </p><pre><code>std::vector&lt; std::string &gt; ReadToutSTR (\n    std::string paramstr\n) \n</code></pre> <p>This function takes a parameter string containing values separated by commas and splits it into a vector of individual strings. </p> <p>Parameters:</p> <ul> <li><code>paramstr</code> The parameter string to be split. </li> </ul> <p>Returns:</p> <p>A vector of strings obtained by splitting the input string at commas. </p>"},{"location":"BGFlood/_read_input_8cu/#function-readtoutput","title":"function ReadToutput","text":"<p>Read and interpret output time specifications from a vector of parameter strings. This function processes a vector of parameter strings that specify output times, which can include individual time values or ranges defined by a start, step, and end. It converts these specifications into a vector of double values representing the output times, ensuring all times fall within the simulation's total time and end time. </p><pre><code>std::vector&lt; double &gt; ReadToutput (\n    std::vector&lt; std::string &gt; paramstr,\n    Param XParam\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>paramstr</code> A vector of strings specifying output times or ranges. </li> <li><code>XParam</code> The Param structure containing simulation parameters, including total time and end time. </li> </ul> <p>Returns:</p> <p>A vector of double values representing the interpreted output times. </p>"},{"location":"BGFlood/_read_input_8cu/#function-readtvalstr","title":"function ReadTvalstr","text":"<p>Read and interpret a time value string, converting it to a double within specified bounds. This function interprets a time value string, which can represent specific keywords (\"start\", \"end\"), relative times, or absolute date-time strings. It converts the string to a double value representing time, ensuring it falls within the provided start and end bounds. </p><pre><code>double ReadTvalstr (\n    std::string timestr,\n    double start,\n    double end,\n    std::string reftime\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>timestr</code> The time value string to be interpreted. </li> <li><code>start</code> The start time bound. </li> <li><code>end</code> The end time bound. </li> <li><code>reftime</code> The reference time for interpreting absolute date-time strings. </li> </ul> <p>Returns:</p> <p>A double value representing the interpreted time, constrained within the start and end bounds. </p>"},{"location":"BGFlood/_read_input_8cu/#function-readparamfile","title":"function Readparamfile","text":"<p>Read and parse the parameter file. Opens the specified parameter file (default: BG_param.txt file), reads its contents, and updates the provided parameter structures: Param class (XParam) andForcing class (XForcing). </p><pre><code>void Readparamfile (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    std::string Paramfile\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Reference to the parameter structure to be updated </li> <li><code>XForcing</code> Reference to the forcing structure to be updated </li> <li><code>Paramfile</code> Name of the parameter file to read </li> </ul>"},{"location":"BGFlood/_read_input_8cu/#function-case_insensitive_compare","title":"function case_insensitive_compare","text":"<p>Perform a non case-insensitive comparison between two strings or a string and a vector of strings. This function converts both strings to lowercase and compares them. If a vector of strings is provided, it compares the first string against each string in the vector. </p><pre><code>std::size_t case_insensitive_compare (\n    std::string s1,\n    std::string s2\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s1</code> The first string to compare. </li> <li><code>s2</code> The second string to compare, or a vector of strings to compare against </li> </ul>"},{"location":"BGFlood/_read_input_8cu/#function-case_insensitive_compare_1","title":"function case_insensitive_compare","text":"<p>Perform a non case-insensitive comparison between a string and a vector of strings. This function converts the first string to lowercase and compares it against each string in the vector. </p><pre><code>std::size_t case_insensitive_compare (\n    std::string s1,\n    std::vector&lt; std::string &gt; vecstr\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s1</code> The first string to compare. </li> <li><code>vecstr</code> The vector of strings to compare against. </li> </ul>"},{"location":"BGFlood/_read_input_8cu/#function-checkparamsanity","title":"function checkparamsanity","text":"<p>Check and adjust the sanity of model parameters and forcing data. This function checks the sanity of the model parameters and forcing data. It adjusts parameters as needed, ensuring they are within acceptable ranges and consistent with each other. </p><pre><code>void checkparamsanity (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Reference to the model parameters structure to be checked and adjusted. </li> <li><code>XForcing</code> Reference to the forcing data structure to be checked and adjusted. </li> </ul>"},{"location":"BGFlood/_read_input_8cu/#function-findparameter","title":"function findparameter","text":"<p>Find and extract the value of a specified parameter from a configuration line. This function searches for a specified parameter in a given line of text, and extracts its associated value if found. It handles comments and whitespace appropriately. </p><pre><code>std::string findparameter (\n    std::vector&lt; std::string &gt; parameterstr,\n    std::string line\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>parameterstr</code> The parameter name to search for. </li> <li><code>line</code> The line of text to search within. </li> </ul> <p>Returns:</p> <p>The extracted parameter value as a string, or an empty string if the parameter is not found. </p>"},{"location":"BGFlood/_read_input_8cu/#function-findparameter_1","title":"function findparameter","text":"<p>Find and extract the value of a specified parameter from a configuration line. This function searches for a specified parameter in a given line of text, and extracts its associated value if found. It handles comments and whitespace appropriately. </p><pre><code>std::string findparameter (\n    std::string parameterstr,\n    std::string line\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>parameterstr</code> The parameter name to search for. </li> <li><code>line</code> The line of text to search within. </li> </ul> <p>Returns:</p> <p>The extracted parameter value as a string, or an empty string if the parameter is not found. </p>"},{"location":"BGFlood/_read_input_8cu/#function-readapproxtimestr","title":"function readApproxtimestr","text":"<p>Convert an approximate time string to a double value in seconds. This function interprets a time string that may include a numeric value followed by a time unit (e.g., \"seconds\", \"minutes\", \"hours\", \"days\", \"months\", \"years\") and converts it to a double value representing the equivalent time in seconds. If the unit is not recognized, it defaults to seconds. </p><pre><code>double readApproxtimestr (\n    std::string input\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>input</code> The approximate time string to be converted (e.g., \"10 minutes\", \"2.5 hours\"). </li> </ul> <p>Returns:</p> <p>A double value representing the time in seconds. </p>"},{"location":"BGFlood/_read_input_8cu/#function-readbndline","title":"function readbndline","text":"<p>Read boundary segment information from a parameter value string. This function parses a parameter value string to extract boundary segment information, including type, input file, and polygon file. It also reads file information and sets the expected type of input based on the file extension. </p><pre><code>bndsegment readbndline (\n    std::string parametervalue\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>parametervalue</code> The parameter value string containing boundary segment information. </li> </ul>"},{"location":"BGFlood/_read_input_8cu/#function-readbndlineside","title":"function readbndlineside","text":"<p>Read boundary segment information from a parameter value string for a specific side. This function parses a parameter value string to extract boundary segment information, including type, input file, and polygon file for a specified side. It also reads file information and sets the expected type of input based on the file extension. </p><pre><code>bndsegment readbndlineside (\n    std::string parametervalue,\n    std::string side\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>parametervalue</code> The parameter value string containing boundary segment information. </li> <li><code>side</code> The side (e.g., \"left\", \"right\", \"top\", \"bot\") for which the boundary segment is defined. </li> </ul>"},{"location":"BGFlood/_read_input_8cu/#function-readfileinfo","title":"function readfileinfo","text":"<p>Parse a parameter string and update the parameter structure. Parses a line from the parameter file and updates the given parameter structure. Convert file name into name and extension. This is used for various input classes template inputmap readfileinfo&lt;inputmap&gt;(std::string input, inputmap outinfo); template forcingmap readfileinfo&lt;forcingmap&gt;(std::string input, forcingmap outinfo); template StaticForcingP&lt;float&gt; readfileinfo&lt;StaticForcingP&lt;float&gt;&gt;(std::string input, StaticForcingP&lt;float&gt; outinfo); template DynForcingP&lt;float&gt; readfileinfo&lt;DynForcingP&lt;float&gt; &gt;(std::string input,DynForcingP&lt;float&gt; outinfo); template deformmap&lt;float&gt; readfileinfo&lt;deformmap&lt;float&gt;&gt;(std::string input, deformmap&lt;float&gt; outinfo);. </p><pre><code>template&lt;class T&gt;\nT readfileinfo (\n    std::string input,\n    T outinfo\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>line</code> Input line from parameter file </li> <li><code>param</code> Parameter structure to update </li> </ul> <p>Returns:</p> <p>Updated parameter structure</p> <p>convert file name into name and extension This is used for various input classes</p> <p>template inputmap readfileinfo&lt;inputmap&gt;(std::string input, inputmap outinfo); template forcingmap readfileinfo&lt;forcingmap&gt;(std::string input, forcingmap outinfo); template StaticForcingP&lt;float&gt; readfileinfo&lt;StaticForcingP&lt;float&gt;&gt;(std::string input, StaticForcingP&lt;float&gt; outinfo); template DynForcingP&lt;float&gt; readfileinfo&lt;DynForcingP&lt;float&gt;&gt;(std::string input, DynForcingP&lt;float&gt; outinfo); template deformmap&lt;float&gt; readfileinfo&lt;deformmap&lt;float&gt;&gt;(std::string input, deformmap&lt;float&gt; outinfo); </p>"},{"location":"BGFlood/_read_input_8cu/#function-readfileinfo-dynforcingp-float","title":"function readfileinfo&lt; DynForcingP&lt; float &gt; &gt;","text":"<pre><code>template DynForcingP &lt; float &gt; readfileinfo&lt; DynForcingP&lt; float &gt; &gt; (\n    std::string input,\n    DynForcingP &lt; float &gt; outinfo\n) \n</code></pre>"},{"location":"BGFlood/_read_input_8cu/#function-readfileinfo-staticforcingp-float","title":"function readfileinfo&lt; StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template StaticForcingP &lt; float &gt; readfileinfo&lt; StaticForcingP&lt; float &gt; &gt; (\n    std::string input,\n    StaticForcingP &lt; float &gt; outinfo\n) \n</code></pre>"},{"location":"BGFlood/_read_input_8cu/#function-readfileinfo-deformmap-float","title":"function readfileinfo&lt; deformmap&lt; float &gt; &gt;","text":"<pre><code>template deformmap &lt; float &gt; readfileinfo&lt; deformmap&lt; float &gt; &gt; (\n    std::string input,\n    deformmap &lt; float &gt; outinfo\n) \n</code></pre>"},{"location":"BGFlood/_read_input_8cu/#function-readfileinfo-forcingmap","title":"function readfileinfo&lt; forcingmap &gt;","text":"<pre><code>template forcingmap readfileinfo&lt; forcingmap &gt; (\n    std::string input,\n    forcingmap outinfo\n) \n</code></pre>"},{"location":"BGFlood/_read_input_8cu/#function-readfileinfo-inputmap","title":"function readfileinfo&lt; inputmap &gt;","text":"<pre><code>template inputmap readfileinfo&lt; inputmap &gt; (\n    std::string input,\n    inputmap outinfo\n) \n</code></pre>"},{"location":"BGFlood/_read_input_8cu/#function-readparambool","title":"function readparambool","text":"<p>Convert a parameter string to a boolean value, with a default fallback. This function interprets a parameter string as a boolean value, returning true for recognized true values and false for recognized false values. If the string does not match any known values, it returns a specified default value.  __ </p><pre><code>bool readparambool (\n    std::string paramstr,\n    bool defaultval\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>paramstr</code> The parameter string to be interpreted. </li> <li><code>defaultval</code> The default boolean value to return if the string does not match known values </li> </ul>"},{"location":"BGFlood/_read_input_8cu/#function-readparamstr","title":"function readparamstr","text":"<p>Parse a parameter string and update the parameter structure. </p><pre><code>Param readparamstr (\n    std::string line,\n    Param param\n) \n</code></pre> <p>Parses a line from the parameter file and updates the given parameter structure. Read BG_param.txt line and convert parameter to the right parameter in the class Return an updated Param class</p> <p>Parameters:</p> <ul> <li><code>line</code> Input line from parameter file </li> <li><code>param</code> Parameter structure to update </li> </ul> <p>Returns:</p> <p>Updated parameter structure</p> <p>Read BG_param.txt line and convert parameter to the righ parameter in the class return an updated Param class </p>"},{"location":"BGFlood/_read_input_8cu/#function-readparamstr_1","title":"function readparamstr","text":"<p>Parse a parameter string and update the forcing structure. Parses a line from the parameter file and updates the given forcing structure. Read BG_param.txt line and convert parameter to the right parameter in the class Return an updatedForcing class. </p><pre><code>template&lt;class T&gt;\nForcing &lt; T &gt; readparamstr (\n    std::string line,\n    Forcing &lt; T &gt; forcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>line</code> Input line from parameter file </li> <li><code>forcing</code> Forcing structure to update </li> </ul> <p>Returns:</p> <p>Updated forcing structure</p> <p>Read BG_param.txt line and convert parameter to the righ parameter in the class return an updated Param class </p>"},{"location":"BGFlood/_read_input_8cu/#function-setendtime","title":"function setendtime","text":"<p>Adjust the simulation \"endtime\" based on maximum time in forcings. This function checks the end times of boundary forcing data and adjusts the simulation end time if any boundary forcing ends before the specified end time. A warning is logged if the end time is reduced. </p><pre><code>double setendtime (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The Param structure containing simulation parameters, including the initial end time. </li> <li><code>XForcing</code> The Forcing structure containing boundary forcing data. </li> </ul>"},{"location":"BGFlood/_read_input_8cu/#function-split","title":"function split","text":"<p>Split a string into tokens based on a specified delimiter, skipping empty tokens. This function takes a string and splits it into a vector of substrings using the specified delimiter. Empty tokens resulting from consecutive delimiters are skipped. </p><pre><code>void split (\n    const std::string &amp; s,\n    char delim,\n    std::vector&lt; std::string &gt; &amp; elems\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s</code> The input string to be split. </li> <li><code>delim</code> The character used as the delimiter for splitting the string. </li> <li><code>elems</code> A reference to a vector where the resulting substrings will be stored. </li> </ul>"},{"location":"BGFlood/_read_input_8cu/#function-split_1","title":"function split","text":"<p>Split a string into tokens based on a specified character delimiter, skipping empty tokens. This function takes a string and splits it into a vector of substrings using the specified delimiter. Empty tokens resulting from consecutive delimiters are skipped. </p><pre><code>std::vector&lt; std::string &gt; split (\n    const std::string &amp; s,\n    char delim\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s</code> The input string to be split. </li> <li><code>delim</code> The character used as the delimiter for splitting the string. </li> </ul> <p>Returns:</p> <p>A vector containing the resulting substrings. </p>"},{"location":"BGFlood/_read_input_8cu/#function-split_2","title":"function split","text":"<p>Split a string into tokens based on a specified substring delimiter. This function takes a string and splits it into a vector of substrings using the specified substring delimiter. </p><pre><code>std::vector&lt; std::string &gt; split (\n    const std::string s,\n    const std::string delim\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s</code> The input string to be split. </li> <li><code>delim</code> The substring used as the delimiter for splitting the string. </li> </ul> <p>Returns:</p> <p>A vector containing the resulting substrings. </p>"},{"location":"BGFlood/_read_input_8cu/#function-split_full","title":"function split_full","text":"<p>Split a string into tokens based on a specified delimiter, preserving empty tokens. This function takes a string and splits it into a vector of substrings using the specified delimiter. Unlike the standard split function, this version preserves empty tokens that result from consecutive delimiters.  __ </p><pre><code>void split_full (\n    const std::string &amp; s,\n    char delim,\n    std::vector&lt; std::string &gt; &amp; elems\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s</code> The input string to be split. </li> <li><code>delim</code> The character used as the delimiter for splitting the string. </li> <li><code>elems</code> A reference to a vector where the resulting substrings will be stored.</li> </ul> <p>split string based in character, conserving empty item </p>"},{"location":"BGFlood/_read_input_8cu/#function-split_full_1","title":"function split_full","text":"<p>Split a string into tokens based on a specified character delimiter, preserving empty tokens. This function takes a string and splits it into a vector of substrings using the specified delimiter. Unlike the standard split function, this version preserves empty tokens that result from consecutive delimiters.  __ </p><pre><code>std::vector&lt; std::string &gt; split_full (\n    const std::string &amp; s,\n    char delim\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s</code> The input string to be split. </li> <li><code>delim</code> The character used as the delimiter for splitting the string.</li> </ul> <p>split string based in character, conserving empty items </p>"},{"location":"BGFlood/_read_input_8cu/#function-trim","title":"function trim","text":"<p>Trim leading and trailing whitespace from a string. This function removes all leading and trailing characters from the input string that are present in the specified whitespace string. </p><pre><code>std::string trim (\n    const std::string &amp; str,\n    const std::string &amp; whitespace\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>str</code> The input string to be trimmed. </li> <li><code>whitespace</code> A string containing all characters considered as whitespace.</li> </ul> <p>remove leading and trailing space in a string </p> <p>The documentation for this class was generated from the following file <code>src/ReadInput.cu</code></p>"},{"location":"BGFlood/_read_input_8cu_source/","title":"File ReadInput.cu","text":""},{"location":"BGFlood/_read_input_8cu_source/#file-readinputcu","title":"File ReadInput.cu","text":"<p>File List &gt; src &gt; ReadInput.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //    \n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n#include \"ReadInput.h\"\n\n// Collection of functions to read input to the model\n\n\ntemplate &lt;class T&gt; T readfileinfo(std::string input, T outinfo)\n{\n    // Outinfo is based on an inputmap (or it's sub classes)\n\n    //filename include the file extension\n\n    std::vector&lt;std::string&gt; extvec = split(input, '.');\n\n    //outinfo.inputfile = extvec.front();\n\n    std::vector&lt;std::string&gt; nameelements, filename;\n    //\n    nameelements = split(extvec.back(), '?');\n\n    filename = split(input, '?');\n    if (nameelements.size() &gt; 1)\n    {\n        //variable name for bathy is not given so it is assumed to be zb\n        outinfo.extension = nameelements[0];\n        outinfo.varname = nameelements.back();\n\n    }\n    else\n    {\n        outinfo.extension = extvec.back();\n        outinfo.varname = \"z\";\n    }\n\n    //Reconstruct filename with extension but without varname\n    //outinfo.inputfile = extvec.front() + \".\" + outinfo.extension;\n    outinfo.inputfile = filename.front();\n\n    return outinfo;\n}\n\ntemplate inputmap readfileinfo&lt;inputmap&gt;(std::string input, inputmap outinfo);\ntemplate forcingmap readfileinfo&lt;forcingmap&gt;(std::string input, forcingmap outinfo);\ntemplate StaticForcingP&lt;float&gt; readfileinfo&lt;StaticForcingP&lt;float&gt;&gt;(std::string input, StaticForcingP&lt;float&gt; outinfo);\ntemplate DynForcingP&lt;float&gt; readfileinfo&lt;DynForcingP&lt;float&gt;&gt;(std::string input, DynForcingP&lt;float&gt; outinfo);\ntemplate deformmap&lt;float&gt; readfileinfo&lt;deformmap&lt;float&gt;&gt;(std::string input, deformmap&lt;float&gt; outinfo);\n\n\n\n\nvoid Readparamfile(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing, std::string Paramfile)\n{\n    //\n    log(\"\\nReading parameter file: \" + Paramfile + \" ...\");\n    //std::ifstream fs(\"BG_param.txt\");\n    std::ifstream fs(Paramfile);\n\n    if (fs.fail()) {\n        //std::cerr &lt;&lt; \"BG_param.txt file could not be opened\" &lt;&lt; std::endl;\n        log(\"ERROR: BG_param.txt file could not be opened...use this log file to create a file named BG_param.txt\");\n        SaveParamtolog(XParam);\n\n        exit(1);\n\n    }\n    else\n    {\n        // Read and interpret each line of the BG_param.txt\n        std::string line;\n        while (std::getline(fs, line))\n        {\n\n            //Get param or skip empty lines\n            if (!line.empty() &amp;&amp; line.substr(0, 1).compare(\"#\") != 0)\n            {\n                XParam = readparamstr(line, XParam);\n                XForcing = readparamstr(line, XForcing);\n\n                //std::cout &lt;&lt; line &lt;&lt; std::endl;\n            }\n\n        }\n        fs.close();\n\n\n    }\n\n}\n\n\n\n\n\nParam readparamstr(std::string line, Param param)\n{\n\n\n    std::string parameterstr, parametervalue;\n    std::vector&lt;std::string&gt; paramvec;\n    // General parameters\n    //\n\n    parameterstr = \"test\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.test = std::stoi(parametervalue);\n    }\n\n    paramvec = { \"GPUDEVICE\",\"gpu\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.GPUDEVICE = std::stoi(parametervalue);\n    }\n\n    parameterstr = \"doubleprecision\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.doubleprecision = std::stoi(parametervalue);\n    }\n\n    parameterstr = \"engine\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        std::vector&lt;std::string&gt; buttingerstr = { \"b\",\"butt\",\"buttinger\",\"1\" };\n        std::size_t found;\n        bool foo = false;\n        for (int ii = 0; ii &lt; buttingerstr.size(); ii++)\n        {\n            found = case_insensitive_compare(parametervalue, buttingerstr[ii]);// it needs to strictly compare\n            if (found == 0)\n            {\n                param.engine = 1;\n                foo = true;\n            }\n\n        }\n        if (!foo)\n        {\n            param.engine = 5;\n        }\n    }\n    // Adaptation\n    //\n    parameterstr = \"maxlevel\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.maxlevel = std::stoi(parametervalue);\n    }\n\n    parameterstr = \"minlevel\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.minlevel = std::stoi(parametervalue);\n    }\n\n    parameterstr = \"initlevel\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.initlevel = std::stoi(parametervalue);\n    }\n\n    paramvec = { \"adaptmaxiteration\",\"maxiterationadapt\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.adaptmaxiteration = std::stoi(parametervalue);\n    }\n\n    parameterstr = \"conserveElevation\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.conserveElevation = readparambool(parametervalue, param.conserveElevation);\n    }\n\n    paramvec = { \"wetdryfix\",\"reminstab\",\"fixinstab\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n\n        param.wetdryfix = readparambool(parametervalue, param.wetdryfix);\n\n    }\n\n\n    parameterstr = \"membuffer\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.membuffer = std::stod(parametervalue);\n    }\n\n    // Flow parameters\n    //\n    parameterstr = \"eps\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.eps = std::stod(parametervalue);\n    }\n\n    paramvec = { \"cf\",\"roughness\",\"cfmap\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        if (std::any_of(parametervalue.begin(), parametervalue.end(), ::isalpha) == false) //(std::isdigit(parametervalue[0]) == true)\n        {\n            param.cf = std::stod(parametervalue);\n        }\n    }\n\n    paramvec = { \"il\",\"Rain_il\",\"initialloss\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        if (std::any_of(parametervalue.begin(), parametervalue.end(), ::isalpha) == false) //(std::isdigit(parametervalue[0]) == true)\n        {\n            param.il = std::stod(parametervalue);\n            param.infiltration = true;\n        }\n    }\n\n    paramvec = { \"cl\",\"Rain_cl\",\"continuousloss\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        if (std::any_of(parametervalue.begin(), parametervalue.end(), ::isalpha) == false) //(std::isdigit(parametervalue[0]) == true)\n        {\n            param.cl = std::stod(parametervalue);\n            param.infiltration = true;\n        }\n    }\n\n    paramvec = { \"VelThreshold\",\"vthresh\",\"vmax\",\"velmax\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.VelThreshold = std::stod(parametervalue);\n    }\n\n    parameterstr = \"Cd\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.Cd = std::stod(parametervalue);\n    }\n\n    parameterstr = \"Pa2m\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.Pa2m = std::stod(parametervalue);\n    }\n\n    parameterstr = \"Paref\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.Paref = std::stod(parametervalue);\n    }\n\n    parameterstr = \"mask\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.mask = std::stod(parametervalue);\n    }\n\n    // Timekeeping parameters\n    //\n    parameterstr = \"dt\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.dt = std::stod(parametervalue);\n\n    }\n\n    parameterstr = \"dtmin\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.dtmin = std::stod(parametervalue);\n\n    }\n    parameterstr = \"bndtaper\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.bndtaper = std::stod(parametervalue);\n\n    }\n\n    parameterstr = \"bndrelaxtime\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.bndrelaxtime = std::stod(parametervalue);\n\n    }\n    parameterstr = \"bndfiltertime\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.bndfiltertime = std::stod(parametervalue);\n\n    }\n\n\n    paramvec = { \"aoibnd\",\"remainderbnd\",\"remainbndtype\",\"aoibndtype\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.aoibnd = std::stoi(parametervalue);\n    }\n\n\n    parameterstr = \"CFL\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.CFL = std::stod(parametervalue);\n\n    }\n    parameterstr = \"theta\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.theta = std::stod(parametervalue);\n\n    }\n\n    paramvec = { \"outputtimestep\",\"outtimestep\",\"outputstep\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.outputtimestep = std::stod(parametervalue);\n\n    }\n\n    paramvec = { \"endtime\", \"stoptime\", \"end\", \"stop\",\"end_time\",\"stop_time\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.endtime = readinputtimetxt(parametervalue, param.reftime);\n\n    }\n\n    paramvec = { \"totaltime\",\"inittime\",\"starttime\", \"start_time\", \"init_time\", \"start\", \"init\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        //param.totaltime = std::stod(parametervalue);\n        param.totaltime = readinputtimetxt(parametervalue, param.reftime);\n\n    }\n\n    paramvec = { \"MassConservation\", \"MassCon\",\"forcemassconservation\",\"forcevolumeconservation\",\"Volumeconservation\",\"VolumeCon\", \"ForceMassConserve\", \"ForceVolConserve\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        //param.totaltime = std::stod(parametervalue);\n        param.totaltime = readinputtimetxt(parametervalue, param.reftime);\n        param.ForceMassConserve = readparambool(parametervalue, param.ForceMassConserve);\n\n    }\n\n\n    parameterstr = \"dtinit\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.dtinit = std::stod(parametervalue);\n\n    }\n\n    paramvec = { \"reftime\",\"referencetime\",\"timeref\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        if (param.reftime.empty())\n        {\n            param.reftime = parametervalue;\n        }\n\n    }\n\n    // Input and output files\n    //\n\n    parameterstr = \"outfile\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.outfile = parametervalue;\n\n    }\n\n\n    // Below is a bit more complex than usual because more than 1 node can be outputed as a timeseries\n    paramvec = { \"TSnodesout\",\"TSOutput\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        TSoutnode node;\n        std::vector&lt;std::string&gt; nodeitems = split(parametervalue, ',');\n        if (nodeitems.size() &gt;= 3)\n        {\n            node.outname = nodeitems[0];\n            node.x = std::stod(nodeitems[1]);\n            node.y = std::stod(nodeitems[2]);\n\n            param.TSnodesout.push_back(node);\n        }\n        else\n        {\n            std::cerr &lt;&lt; \"Node input failed there should be 3 arguments (comma separated) when inputing a outout node: TSOutput = filename, xvalue, yvalue; see log file for details\" &lt;&lt; std::endl;\n\n            log(\"Node input failed there should be 3 arguments (comma separated) when inputing a outout node: TSOutput = filename, xvalue, yvalue; see log file for details. Input was: \" + parametervalue);\n\n        }\n\n    }\n\n\n\n    //outvars\n    parameterstr = \"outvars\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        std::vector&lt;std::string&gt; vars = split(parametervalue, ',');\n        for (int nv = 0; nv &lt; vars.size(); nv++)\n        {\n            //Verify that the variable name makes sense?\n            //Need to add more here\n\n\n            std::vector&lt;std::string&gt; SupportedVarNames = { \"zb\",\"zs\",\"u\",\"v\",\"h\",\"hmean\",\"zsmean\",\"umean\",\"vmean\",\"hUmean\",\"Umean\",\"hmax\",\"zsmax\",\"umax\",\"vmax\",\"hUmax\",\"Umax\",\"twet\",\"dhdx\",\"dhdy\",\"dzsdx\",\"dzsdy\",\"dzbdx\",\"dzbdy\",\"dudx\",\"dudy\",\"dvdx\",\"dvdy\",\"Fhu\",\"Fhv\",\"Fqux\",\"Fqvy\",\"Fquy\",\"Fqvx\",\"Su\",\"Sv\",\"dh\",\"dhu\",\"dhv\",\"cf\",\"Patm\",\"datmpdx\",\"datmpdy\",\"il\",\"cl\",\"hgw\",\"hu\",\"hv\",\"hfu\" ,\"hfv\",\"hau\",\"hav\",\"Fux\",\"Fvx\",\"Fuy\",\"Fvy\" };\n\n\n            std::string vvar = trim(vars[nv], \" \");\n            for (int isup = 0; isup &lt; SupportedVarNames.size(); isup++)\n            {\n\n                //std::cout &lt;&lt; \"...\" &lt;&lt; vvar &lt;&lt; \"...\" &lt;&lt; std::endl;\n                if (vvar.compare(SupportedVarNames[isup]) == 0)\n                {\n                    param.outvars.push_back(vvar);\n                    break;\n                }\n\n            }\n\n            param.outmean = (vvar.compare(\"hmean\") == 0) ? true : param.outmean;\n            param.outmean = (vvar.compare(\"zsmean\") == 0) ? true : param.outmean;\n            param.outmean = (vvar.compare(\"umean\") == 0) ? true : param.outmean;\n            param.outmean = (vvar.compare(\"vmean\") == 0) ? true : param.outmean;\n            param.outmean = (vvar.compare(\"Umean\") == 0) ? true : param.outmean;\n            param.outmean = (vvar.compare(\"hUmean\") == 0) ? true : param.outmean;\n\n            param.outmax = (vvar.compare(\"hmax\") == 0) ? true : param.outmax;\n            param.outmax = (vvar.compare(\"zsmax\") == 0) ? true : param.outmax;\n            param.outmax = (vvar.compare(\"umax\") == 0) ? true : param.outmax;\n            param.outmax = (vvar.compare(\"vmax\") == 0) ? true : param.outmax;\n            param.outmax = (vvar.compare(\"Umax\") == 0) ? true : param.outmax;\n            param.outmax = (vvar.compare(\"hUmax\") == 0) ? true : param.outmax;\n\n            param.outtwet = (vvar.compare(\"twet\") == 0) ? true : param.outtwet;\n\n            //param.outvort = (vvar.compare(\"vort\") == 0) ? true : param.outvort;\n            //param.outU = (vvar.compare(\"U\") == 0) ? true : param.outU;\n        }\n\n\n\n    }\n\n\n    // Same as for TSnodesout, the same key word can be used for different zones Output\n    parameterstr = \"outzone\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        outzoneP zone;\n        std::vector&lt;std::string&gt; zoneitems = split(parametervalue, ',');\n        if (zoneitems.size() &gt;= 5)\n        {\n            zone.outname = zoneitems[0];\n            zone.xstart = std::stod(zoneitems[1]);\n            zone.xend = std::stod(zoneitems[2]);\n            zone.ystart = std::stod(zoneitems[3]);\n            zone.yend = std::stod(zoneitems[4]);\n        }\n        if (zoneitems.size() &gt; 5)\n        {\n            // concatenate 5,6,.... together\n            std::string constr;\n\n            for (int ist = 5; ist &lt; zoneitems.size(); ist++)\n            {\n                constr = constr + zoneitems[ist];\n                if (ist &lt; (zoneitems.size() - 1))\n                {\n                    constr = constr + \",\";\n                }\n\n            }\n            zone.Toutput.inputstr = ReadToutSTR(constr);\n\n\n        }\n        else if (zoneitems.size() == 5)//No time input in the zone area\n        {\n            zone.Toutput.inputstr = ReadToutSTR(\"\"); // Thats needs to move to sanity check\n        }\n        else\n        {\n            std::cerr &lt;&lt; \"Zone input failed there should be at least 5 arguments (comma separated) when inputing a outout zone: outzone = filename, xstart, xend, ystart, yend; see log file for details\" &lt;&lt; std::endl;\n            log(\"Node input failed there should be at least 5 arguments (comma separated) when inputing a outout zone: outzone = filename, xstart, xend, ystart, yend; see log file for details (with possibly some time inputs after). Input was: \" + parametervalue);\n        }\n        param.outzone.push_back(zone);\n    }\n\n    parameterstr = \"resetmax\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        if (std::stoi(parametervalue) == 1)\n        {\n            param.resetmax = true;\n        }\n    }\n\n    // WARNING FOR DEBUGGING PURPOSE ONLY\n    // For debugging one can shift the output by 1 or -1 in the i and j direction.\n    // this will save the value in the halo to the output file allowing debugging of values there.\n    parameterstr = \"outishift\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.outishift = std::stoi(parametervalue);\n    }\n    parameterstr = \"outjshift\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.outjshift = std::stoi(parametervalue);\n    }\n\n\n\n    parameterstr = \"nx\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.nx = std::stoi(parametervalue);\n    }\n\n    parameterstr = \"ny\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.ny = std::stoi(parametervalue);\n    }\n\n    parameterstr = \"dx\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.dx = std::stod(parametervalue);\n    }\n\n    parameterstr = \"grdalpha\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.grdalpha = std::stod(parametervalue);\n    }\n\n    paramvec = { \"xo\",\"xmin\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.xo = std::stod(parametervalue);\n    }\n\n    paramvec = { \"yo\",\"ymin\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.yo = std::stod(parametervalue);\n    }\n\n    parameterstr = \"xmax\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.xmax = std::stod(parametervalue);\n    }\n\n    parameterstr = \"ymax\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.ymax = std::stod(parametervalue);\n    }\n\n    parameterstr = \"g\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.g = std::stod(parametervalue);\n\n    }\n\n    parameterstr = \"rho\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.rho = std::stod(parametervalue);\n    }\n\n    parameterstr = \"smallnc\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.smallnc = std::stoi(parametervalue);\n    }\n    parameterstr = \"scalefactor\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.scalefactor = std::stof(parametervalue);\n    }\n    parameterstr = \"addoffset\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.addoffset = std::stof(parametervalue);\n    }\n    parameterstr = \"posdown\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.posdown = std::stoi(parametervalue);\n    }\n\n#ifdef USE_CATALYST\n    parameterstr = \"use_catalyst\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.use_catalyst = std::stoi(parametervalue);\n    }\n    parameterstr = \"catalyst_python_pipeline\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.catalyst_python_pipeline = std::stoi(parametervalue);\n    }\n    parameterstr = \"vtk_output_frequency\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.vtk_output_frequency = std::stoi(parametervalue);\n    }\n    parameterstr = \"vtk_output_time_interval\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.vtk_output_time_interval = std::stod(parametervalue);\n    }\n    parameterstr = \"vtk_outputfile_root\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.vtk_outputfile_root = parametervalue;\n    }\n    parameterstr = \"python_pipeline\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.python_pipeline = parametervalue;\n    }\n#endif\n\n    paramvec = { \"zsinit\", \"initzs\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.zsinit = std::stod(parametervalue);\n    }\n\n    parameterstr = \"zsoffset\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.zsoffset = std::stod(parametervalue);\n    }\n    paramvec = { \"rainbnd\", \"rainonbnd\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.rainbnd = readparambool(parametervalue, param.rainbnd);\n\n    }\n\n\n    parameterstr = \"hotstartfile\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.hotstartfile = parametervalue;\n\n    }\n\n    parameterstr = \"hotstep\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.hotstep = std::stoi(parametervalue);\n    }\n\n\n    paramvec = { \"spherical\", \"geo\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.spherical = readparambool(parametervalue, param.spherical);\n    }\n\n    parameterstr = \"Radius\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.Radius = std::stod(parametervalue);\n    }\n\n    parameterstr = \"frictionmodel\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.frictionmodel = std::stoi(parametervalue);\n    }\n\n    parameterstr = \"Adaptation\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        std::vector&lt;std::string&gt; adaptpar = split(parametervalue, ',');\n\n        if (!adaptpar.empty())\n        {\n            param.AdaptCrit = adaptpar[0];\n            if (adaptpar.size() &gt; 1)\n                param.Adapt_arg1 = adaptpar[1];\n            if (adaptpar.size() &gt; 2)\n                param.Adapt_arg2 = adaptpar[2];\n            if (adaptpar.size() &gt; 3)\n                param.Adapt_arg3 = adaptpar[3];\n            if (adaptpar.size() &gt; 4)\n                param.Adapt_arg4 = adaptpar[4];\n            if (adaptpar.size() &gt; 5)\n                param.Adapt_arg5 = adaptpar[5];\n        }\n    }\n\n    paramvec = { \"crs\", \"spatialref\", \"spatial_ref\", \"wtk\", \"crsinfo\",\"crs_info\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.crs_ref = parametervalue;\n    }\n\n    //Read Flexible Toutput variable\n    parameterstr = \"Toutput\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        param.Toutput.inputstr = ReadToutSTR(parametervalue);\n    }\n\n    paramvec = { \"savebyblk\", \"writebyblk\",\"saveperblk\", \"writeperblk\",\"savebyblock\", \"writebyblock\",\"saveperblock\", \"writeperblock\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        param.savebyblk = readparambool(parametervalue, param.savebyblk);\n    }\n\n    return param;\n}\n\n\n\ntemplate &lt;class T&gt;\nForcing&lt;T&gt; readparamstr(std::string line, Forcing&lt;T&gt; forcing)\n{\n    std::string parameterstr, parametervalue;\n    std::vector&lt;std::string&gt; paramvec;\n\n    paramvec = { \"Bathy\",\"bathyfile\",\"bathymetry\",\"depfile\",\"depthfile\",\"topofile\",\"topo\",\"DEM\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        StaticForcingP&lt;float&gt; infobathy;\n        forcing.Bathy.push_back(readfileinfo(parametervalue, infobathy));\n        //std::cerr &lt;&lt; \"Bathymetry file found!\" &lt;&lt; std::endl;\n    }\n\n\n\n    paramvec = { \"AOI\",\"aoipoly\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        forcing.AOI.file = parametervalue;\n        forcing.AOI.active = true;\n    }\n\n    /*parameterstr = \"bathyfile\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        StaticForcingP&lt;float&gt; infobathy;\n        forcing.Bathy.push_back(readfileinfo(parametervalue, infobathy));\n        //forcing.Bathy = readfileinfo(parametervalue, forcing.Bathy);\n        //std::cerr &lt;&lt; \"Bathymetry file found!\" &lt;&lt; std::endl;\n    }\n\n    parameterstr = \"bathymetry\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        StaticForcingP&lt;float&gt; infobathy;\n        forcing.Bathy.push_back(readfileinfo(parametervalue, infobathy));\n        //forcing.Bathy = readfileinfo(parametervalue, forcing.Bathy);\n        //std::cerr &lt;&lt; \"Bathymetry file found!\" &lt;&lt; std::endl;\n    }\n\n    //\n    parameterstr = \"depfile\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        StaticForcingP&lt;float&gt; infobathy;\n        forcing.Bathy.push_back(readfileinfo(parametervalue, infobathy));\n        //forcing.Bathy = readfileinfo(parametervalue, forcing.Bathy);\n    }*/\n\n\n    // Boundaries\n\n    paramvec = { \"left\",\"leftbndfile\",\"leftbnd\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        //forcing.left = readbndline(parametervalue);\n        forcing.bndseg.push_back(readbndlineside(parametervalue, \"left\"));\n\n\n\n    }\n\n    paramvec = { \"right\",\"rightbndfile\",\"rightbnd\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        //forcing.right = readbndline(parametervalue);\n        forcing.bndseg.push_back(readbndlineside(parametervalue, \"right\"));\n\n    }\n\n    paramvec = { \"top\",\"topbndfile\",\"topbnd\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        //forcing.top = readbndline(parametervalue);\n        forcing.bndseg.push_back(readbndlineside(parametervalue, \"top\"));\n    }\n\n    paramvec = { \"bot\",\"botbndfile\",\"botbnd\",\"bottom\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        //forcing.bot = readbndline(parametervalue);\n        forcing.bndseg.push_back(readbndlineside(parametervalue, \"bot\"));\n    }\n\n    paramvec = { \"bnd\",\"bndseg\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        //forcing.bot = readbndline(parametervalue);\n        forcing.bndseg.push_back(readbndline(parametervalue));\n    }\n\n\n    //Tsunami deformation input files\n    parameterstr = \"deform\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n\n        deformmap&lt;float&gt; thisdeform;\n        std::vector&lt;std::string&gt; items = split(parametervalue, ',');\n        //Need sanity check here\n        thisdeform = readfileinfo(items[0], thisdeform);\n        //thisdeform.inputfile = items[0];\n        if (items.size() &gt; 1)\n        {\n            thisdeform.startime = std::stod(items[1]);\n\n        }\n        if (items.size() &gt; 2)\n        {\n            thisdeform.duration = std::stod(items[2]);\n\n        }\n\n        forcing.deform.push_back(thisdeform);\n\n    }\n\n    //Tsunami deformation input files\n    parameterstr = \"cavity\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n\n        deformmap&lt;float&gt; thisdeform;\n\n        thisdeform.iscavity = true;\n        std::vector&lt;std::string&gt; items = split(parametervalue, ',');\n        //Need sanity check here\n        thisdeform = readfileinfo(items[0], thisdeform);\n        //thisdeform.inputfile = items[0];\n        if (items.size() &gt; 1)\n        {\n            thisdeform.startime = std::stod(items[1]);\n\n        }\n        if (items.size() &gt; 2)\n        {\n            thisdeform.duration = std::stod(items[2]);\n\n        }\n\n        forcing.deform.push_back(thisdeform);\n\n    }\n\n    //River\n    paramvec = { \"rivers\",\"river\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        std::vector&lt;std::string&gt; vars = split(parametervalue, ',');\n        if (vars.size() == 5)\n        {\n            River thisriver;\n            thisriver.Riverflowfile = trim(vars[0], \" \");\n            thisriver.xstart = std::stod(vars[1]);\n            thisriver.xend = std::stod(vars[2]);\n            thisriver.ystart = std::stod(vars[3]);\n            thisriver.yend = std::stod(vars[4]);\n\n            forcing.rivers.push_back(thisriver);\n        }\n        else\n        {\n            //Failed there should be 5 arguments (comma separated) when inputing a river: filename, xstart,xend,ystart,yend;\n            std::cerr &lt;&lt; \"River input failed there should be 5 arguments (comma separated) when inputing a river: river = filename, xstart,xend,ystart,yend; see log file for details\" &lt;&lt; std::endl;\n\n            log(\"River input below failed there should be 5 arguments (comma separated) when inputing a river: river = filename, xstart,xend,ystart,yend;\");\n            log(parametervalue);\n        }\n    }\n\n    // friction coefficient (mapped or constant)\n    // if it is a constant no-need to do anything below but if it is a file it overwrites any other value\n    paramvec = { \"cf\",\"roughness\",\"cfmap\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        if (std::any_of(parametervalue.begin(), parametervalue.end(), ::isalpha)) //(std::isdigit(parametervalue[0]) == false)\n        {\n            //forcing.cf = readfileinfo(parametervalue, forcing.cf);\n            StaticForcingP&lt;float&gt; infoRoughness;\n            forcing.cf.push_back(readfileinfo(parametervalue, infoRoughness));\n        }\n    }\n\n\n    //if (!parametervalue.empty())\n    //{\n    //\n        //std::cerr &lt;&lt; \"Bathymetry file found!\" &lt;&lt; std::endl;\n    //}\n\n    // Rain losses, initial and continuous loss\n    paramvec = { \"il\",\"Rain_il\",\"initialloss\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        if (std::any_of(parametervalue.begin(), parametervalue.end(), ::isalpha)) //(std::isdigit(parametervalue[0]) == false)\n        {\n            forcing.il = readfileinfo(parametervalue, forcing.il);\n        }\n    }\n    paramvec = { \"cl\",\"Rain_cl\",\"continuousloss\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        if (std::any_of(parametervalue.begin(), parametervalue.end(), ::isalpha)) //(std::isdigit(parametervalue[0]) == false)\n        {\n            forcing.cl = readfileinfo(parametervalue, forcing.cl);\n        }\n    }\n\n    // wind forcing\n    paramvec = { \"Wind\",\"windfiles\" }; //## forcing.Wind\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n\n        std::vector&lt;std::string&gt; vars = split(parametervalue, ',');\n        if (vars.size() == 2)\n        {\n            // If 2 parameters (files) are given then 1st file is U wind and second is V wind.\n            // This is for variable winds no rotation of the data is performed\n\n            forcing.UWind = readfileinfo(trim(vars[0], \" \"), forcing.UWind);\n            forcing.VWind = readfileinfo(trim(vars[1], \" \"), forcing.VWind);\n        }\n        else if (vars.size() == 1)\n        {\n            // if 1 parameter(file) is given then a 3 column file is expected showing time windspeed and direction\n            // wind direction is rotated (later) to the grid direction (via grdalpha)\n            forcing.UWind = readfileinfo(parametervalue, forcing.UWind);\n            forcing.UWind.uniform = 1;\n\n            //apply the same for Vwind? seem unecessary but need to be careful later in the code\n        }\n        else\n        {\n            //Failed there should be 5 arguments (comma separated) when inputing a river: filename, xstart,xend,ystart,yend;\n            //std::cerr &lt;&lt; \"Wind input failed there should be 2 arguments (comma separated) when inputing a wind: windfiles = windfile.nc?uwind, windfile.nc?vwind; see log file for details\" &lt;&lt; std::endl;\n\n            log(\"Wind input failed there should be 2 arguments(comma separated) when inputing a wind : windfiles = windfile.nc ? uwind, windfile.nc ? vwind; see log file for details\");\n            log(parametervalue);\n        }\n\n    }\n\n    // atmospheric pressure forcing\n    paramvec = { \"Atmp\",\"atmpfile\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        // needs to be a netcdf file \n        forcing.Atmp = readfileinfo(parametervalue, forcing.Atmp);\n\n    }\n\n    // rain forcing\n    paramvec = { \"Rain\",\"rainfile\" };\n    parametervalue = findparameter(paramvec, line);\n    if (!parametervalue.empty())\n    {\n        // netcdf file == Variable spatially\n        // txt file (other than .nc) == spatially cst (txt file with 2 col time and mmm/h )\n        forcing.Rain = readfileinfo(parametervalue, forcing.Rain);\n\n        //set the expected type of input\n\n        if (forcing.Rain.extension.compare(\"nc\") == 0)\n        {\n            forcing.Rain.uniform = 0;\n        }\n        else\n        {\n            forcing.Rain.uniform = 1;\n        }\n\n    }\n\n    parameterstr = \"Adaptation\";\n    parametervalue = findparameter(parameterstr, line);\n    if (!parametervalue.empty())\n    {\n        std::vector&lt;std::string&gt; adaptpar = split(parametervalue, ',');\n        // special case for 'Targetlevel' adaptation\n        if (!adaptpar.empty())\n        {\n            //if (adaptpar[0].compare(\"Targetlevel\") == 0)\n            if (case_insensitive_compare(adaptpar[0], std::string(\"Targetlevel\")) == 0)\n            {\n                for (int ng = 1; ng &lt; adaptpar.size(); ng++)\n                {\n                    StaticForcingP&lt;int&gt; infogrid;\n                    forcing.targetadapt.push_back(readfileinfo(adaptpar[ng], infogrid));\n                }\n            }\n        }\n\n    }\n\n    return forcing;\n}\n\n\n\nvoid checkparamsanity(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing)\n{\n    Param DefaultParams;\n\n    double tiny = 0.0000001;\n\n    // Sanity check for model levels\n    int minlev = XParam.minlevel;\n    int maxlev = XParam.maxlevel;\n\n    if (minlev == -99999)\n    {\n        minlev = XParam.initlevel;\n    }\n    if (maxlev == -99999)\n    {\n        maxlev = XParam.initlevel;\n    }\n\n    XParam.maxlevel = utils::max(maxlev, minlev);\n    XParam.minlevel = utils::min(maxlev, minlev);\n\n    XParam.initlevel = utils::min(utils::max(XParam.minlevel, XParam.initlevel), XParam.maxlevel);\n\n    //force double for Rain on grid cases\n    if (!XForcing.Rain.inputfile.empty())\n    {\n        XParam.doubleprecision = 1;\n    }\n\n    XParam.blkmemwidth = XParam.blkwidth + 2 * XParam.halowidth;\n    XParam.blksize = utils::sq(XParam.blkmemwidth);\n\n    // zsoffset\n\n    XParam.zsoffset = std::isnan(XParam.zsoffset) ? 0.0 : XParam.zsoffset;\n\n    //  Read Bathy Information\n\n    //this sets xo yo  etc...\n\n    // Any of xo,yo,xmax,ymax or dx not defined is assigned the value from bathy file\n    //default value is nan in default param file\n\n    //inputmap Bathymetry;\n    //Bathymetry.inputfile = XForcing.Bathy.inputfile;\n    //XForcing.Bathy = readforcinghead(XForcing.Bathy);\n\n\n\n    if (std::isnan(XParam.xo))\n        XParam.xo = XForcing.Bathy[0].xo - (0.5 * XForcing.Bathy[0].dx);\n    if (std::isnan(XParam.xmax))\n        XParam.xmax = XForcing.Bathy[0].xmax + (0.5 * XForcing.Bathy[0].dx);\n    if (std::isnan(XParam.yo))\n        XParam.yo = XForcing.Bathy[0].yo - (0.5 * XForcing.Bathy[0].dx);\n    if (std::isnan(XParam.ymax))\n        XParam.ymax = XForcing.Bathy[0].ymax + (0.5 * XForcing.Bathy[0].dx);\n\n    if (std::isnan(XParam.dx))\n        XParam.dx = XForcing.Bathy[0].dx;\n\n    if (std::isnan(XParam.grdalpha))\n        XParam.grdalpha = XForcing.Bathy[0].grdalpha; // here the default bathy grdalpha is 0.0 as defined by inputmap/Bathymetry class\n\n\n    //Check Bathy input type\n    if (XForcing.Bathy[0].extension.compare(\"dep\") == 0 || XForcing.Bathy[0].extension.compare(\"bot\") == 0)\n    {\n        if (std::isnan(XParam.dx))\n        {\n            //std::cerr &lt;&lt; \"FATAL ERROR: nx or ny or dx were not specified. These parameters are required when using .\" &lt;&lt; bathyext &lt;&lt; \" file\" &lt;&lt; std::endl;\n            log(\"FATAL ERROR: nx or ny or dx were not specified. These parameters are required when using .\" + XForcing.Bathy[0].extension + \" file\");\n            exit(1);\n        }\n    }\n\n    double levdx = calcres(XParam.dx, XParam.initlevel);// true grid resolution as in dx/2^(initlevel)\n    //printf(\"levdx=%f;1 &lt;&lt; XParam.initlevel=%f\\n\", levdx, calcres(1.0, XParam.initlevel));\n\n    // First estimate nx and ny\n    XParam.nx = ftoi((XParam.xmax - XParam.xo) / (levdx));\n    XParam.ny = ftoi((XParam.ymax - XParam.yo) / (levdx)); //+1?\n    //if desire size in one direction is under the bathy resolution or dx requested\n    if (XParam.nx == 0) { XParam.nx = 1; }\n    if (XParam.ny == 0) { XParam.ny = 1; }\n\n\n    // Adjust xmax and ymax so that nx and ny are a factor of XParam.blkwidth [16]\n    XParam.xmax = XParam.xo + (ceil(XParam.nx / ((double)XParam.blkwidth)) * ((double)XParam.blkwidth)) * levdx;\n    XParam.ymax = XParam.yo + (ceil(XParam.ny / ((double)XParam.blkwidth)) * ((double)XParam.blkwidth)) * levdx;\n\n    // Update nx and ny \n    XParam.nx = ftoi((XParam.xmax - XParam.xo) / (levdx));\n    XParam.ny = ftoi((XParam.ymax - XParam.yo) / (levdx)); //+1?\n\n    log(\"\\nAdjusted model domain (xo/xmax/yo/ymax): \");\n    log(\"\\t\" + std::to_string(XParam.xo) + \"/\" + std::to_string(XParam.xmax) + \"/\" + std::to_string(XParam.yo) + \"/\" + std::to_string(XParam.ymax));\n    log(\"\\t Initial resolution (level \" + std::to_string(XParam.initlevel) + \") = \" + std::to_string(levdx));\n\n    if (XParam.spherical == false)\n    {\n        XParam.delta = XParam.dx;\n        XParam.grdalpha = XParam.grdalpha * pi / 180.0; // grid rotation\n\n    }\n    else\n    {\n        //Geo grid\n\n        XParam.delta = XParam.dx * XParam.Radius * pi / 180.0;\n        //XParam.engine = 2;\n\n        //printf(\"Using spherical coordinate; delta=%f rad\\n\", XParam.delta);\n        log(\"Using spherical coordinate; delta=\" + std::to_string(XParam.delta));\n        if (XParam.grdalpha != 0.0)\n        {\n            //printf(\"grid rotation in spherical coordinate is not supported yet. grdalpha=%f rad\\n\", XParam.grdalpha);\n            log(\"grid rotation in spherical coordinate is not supported yet. grdalpha=\" + std::to_string(XParam.grdalpha * 180.0 / pi));\n        }\n    }\n\n    // Read/setup bdn segment polygon. Note this can't be part of the \"readforcing\" step because xmin, xmax ymin ymax are not known then\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n\n        XForcing.bndseg[iseg].poly= readbndpolysegment(XForcing.bndseg[iseg], XParam);\n        //if (XForcing.bndseg[iseg].type == 2)\n        //{\n        //  XForcing.bndseg[iseg].type = 3;\n        //}\n\n\n        XForcing.bndseg[iseg].left.isright = -1;\n        XForcing.bndseg[iseg].left.istop = 0;\n\n        XForcing.bndseg[iseg].right.isright = 1;\n        XForcing.bndseg[iseg].right.istop = 0;\n\n        XForcing.bndseg[iseg].top.isright = 0;\n        XForcing.bndseg[iseg].top.istop = 1;\n\n        XForcing.bndseg[iseg].bot.isright = 0;\n        XForcing.bndseg[iseg].bot.istop = -1;\n    }\n\n    bndsegment remainderblk;\n\n    remainderblk.left.isright = -1;\n    remainderblk.left.istop = 0;\n\n    remainderblk.right.isright = 1;\n    remainderblk.right.istop = 0;\n\n    remainderblk.top.isright = 0;\n    remainderblk.top.istop = 1;\n\n    remainderblk.bot.isright = 0;\n    remainderblk.bot.istop = -1;\n    remainderblk.type = XParam.aoibnd;\n\n    XForcing.bndseg.push_back(remainderblk);\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n\n        AllocateCPU(1, 1, XForcing.bndseg[iseg].left.blk);\n        AllocateCPU(1, 1, XForcing.bndseg[iseg].right.blk);\n        AllocateCPU(1, 1, XForcing.bndseg[iseg].top.blk);\n        AllocateCPU(1, 1, XForcing.bndseg[iseg].bot.blk);\n\n        AllocateCPU(1, 1, XForcing.bndseg[iseg].left.qmean);\n        AllocateCPU(1, 1, XForcing.bndseg[iseg].right.qmean);\n        AllocateCPU(1, 1, XForcing.bndseg[iseg].top.qmean);\n        AllocateCPU(1, 1, XForcing.bndseg[iseg].bot.qmean);\n    }\n\n\n\n\n\n    //setup extra infor about boundaries\n    // This is not needed anymore\n    XForcing.left.side = 3;\n    XForcing.left.isright = -1;\n    XForcing.left.istop = 0;\n\n    XForcing.right.side = 1;\n    XForcing.right.isright = 1;\n    XForcing.right.istop = 0;\n\n    XForcing.top.side = 0;\n    XForcing.top.isright = 0;\n    XForcing.top.istop = 1;\n\n    XForcing.bot.side = 2;\n    XForcing.bot.isright = 0;\n    XForcing.bot.istop = -1;\n\n\n    //\n\n    XForcing.Atmp.clampedge = float(XParam.Paref);\n\n    if (!XForcing.Atmp.inputfile.empty())\n    {\n        XParam.atmpforcing = true;\n        XParam.engine = 3;\n    }\n\n\n    // Make sure the nriver in param (used for preallocation of memory) and number of rivers in XForcing are consistent\n    XParam.nrivers = int(XForcing.rivers.size());\n\n    // Engine checks\n    if (XParam.engine == 5)\n    {\n        XParam.CFL = utils::max(XParam.CFL, 0.25);\n        //XParam.eps = 0.0000000001;\n    }\n\n    // Check whether endtime was specified by the user\n    //No; i.e. endtimne =0.0\n    //so the following conditions are useless\n\n\n\n    if (abs(XParam.endtime - DefaultParams.endtime) &lt;= tiny)\n    {\n        //No; i.e. endtimne =0.0\n        XParam.endtime = 1.0 / tiny; //==huge\n    }\n\n    XParam.endtime = setendtime(XParam, XForcing);\n\n\n    // Assign a value for reftime if not yet set. \n    //It is needed in the Netcdf file generation\n    if (XParam.reftime.empty())\n    {\n        XParam.reftime = \"2000-01-01T00:00:00\";\n    }\n\n    XParam.inittime = XParam.totaltime;\n\n    log(\"Reference time: \" + XParam.reftime);\n    log(\"Model Initial time: \" + std::to_string(XParam.totaltime) + \" ; \" );\n\n    log(\"Model end time: \" + std::to_string(XParam.endtime));\n\n    // Check that outputtimestep is not zero, so at least the first and final time step are saved\n    // If only the model stepup is needed than just run with endtime=0.0\n    /*\n    // No longer needed\n    if (abs(XParam.outputtimestep - DefaultParams.outputtimestep) &lt;= tiny)\n    {\n        XParam.outputtimestep = XParam.endtime;\n        //otherwise there is really no point running the model\n    }\n    if (XParam.outputtimestep &gt; XParam.endtime)\n    {\n        XParam.outputtimestep = XParam.endtime;\n        //otherwise, no final output\n    }\n    */\n    //Initialisation of the main time output vector\n    //Initialise default values for Toutput (output times for map outputs)\n    InitialiseToutput(XParam.Toutput, XParam);\n    if (XParam.Toutput.val.empty())\n    {\n        if (abs(XParam.outputtimestep - DefaultParams.outputtimestep) &lt;= tiny)\n        {\n            XParam.Toutput.val.push_back(XParam.totaltime);\n            XParam.Toutput.val.push_back(XParam.endtime);\n        }\n        else\n        {\n            int nstep = (XParam.endtime - XParam.totaltime) / XParam.outputtimestep + 1;\n\n            for (int k = 0; k &lt; nstep; k++)\n            {\n                XParam.Toutput.val.push_back(std::min(XParam.totaltime + XParam.outputtimestep * k, XParam.endtime));\n            }\n\n        }\n    }\n    else\n    {\n\n        XParam.Toutput.val.push_back(XParam.totaltime);\n        XParam.Toutput.val.push_back(XParam.endtime);\n    }\n\n\n    // Initialisation of the time output vector for the zones outputs\n    if (XParam.outzone.size() &gt; 0)\n    {\n        for (int ii = 0; ii &lt; XParam.outzone.size(); ii++)\n        {\n            {\n                InitialiseToutput(XParam.outzone[ii].Toutput, XParam);\n            }\n        }\n    }\n\n\n\n    if (XParam.outvars.empty() &amp;&amp; XParam.outputtimestep &gt; 0.0)\n    {\n        //a nc file was specified but no output variable were specified\n        std::vector&lt;std::string&gt; SupportedVarNames = { \"zb\", \"zs\", \"u\", \"v\", \"h\" };\n        for (int isup = 0; isup &lt; SupportedVarNames.size(); isup++)\n        {\n            XParam.outvars.push_back(SupportedVarNames[isup]);\n\n        }\n\n    }\n\n\n    // Check whether a cuda compatible GPU is present\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        // Init GPU\n        int nDevices;\n        cudaGetDeviceCount(&amp;nDevices);\n        cudaDeviceProp prop;\n\n        if (XParam.GPUDEVICE &gt; (nDevices - 1))\n        {\n            //  if no GPU device are present then use the CPU (GPUDEVICE = -1)\n            XParam.GPUDEVICE = (nDevices - 1);\n        }\n        cudaGetDeviceProperties(&amp;prop, XParam.GPUDEVICE);\n        //printf(\"There are %d GPU devices on this machine\\n\", nDevices);\n        log(\"There are \" + std::to_string(nDevices) + \" GPU devices on this machine\");\n\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n\n            log(\"Using Device: \" + std::string(prop.name));\n        }\n        else\n        {\n            log(\"No GPU device were detected on this machine... Using CPU instead\");\n        }\n\n    }\n\n\n    if (XParam.minlevel != XParam.maxlevel)\n    {\n        if (XParam.AdaptCrit.empty())\n        {\n            XParam.AdaptCrit = \"Threshold\";\n            XParam.Adapt_arg1 = \"0.0\";\n            XParam.Adapt_arg2 = \"h\";\n        }\n    }\n\n    //Check that we have both initial loss and continuous loss if one is given\n    if (!XForcing.il.inputfile.empty())\n    {\n        if (XForcing.cl.inputfile.empty())\n        {\n            log(\"Error: File identified for initial loss but no data entered for continuous loss.\\n Please, enter a \");\n        }\n    }\n    if (!XForcing.cl.inputfile.empty())\n    {\n        if (XForcing.il.inputfile.empty())\n        {\n            log(\"Error: File identified for continuous loss but no data entered for initial loss\");\n        }\n    }\n\n    //Check that the Initial Loss/ Continuing Loss model is used if il, cl or hgw output are asked by user.\n    if (!XParam.infiltration) // (XForcing.il.inputfile.empty() &amp;&amp; XForcing.cl.inputfile.empty() &amp;&amp; (XParam.il == 0.0) &amp;&amp; (XParam.cl == 0.0))\n    {\n        std::vector&lt;std::string&gt; namestr = { \"il\",\"cl\",\"hgw\" };\n        for (int ii = 0; ii &lt; namestr.size(); ii++)\n        {\n            std::vector&lt;std::string&gt;::iterator itr = std::find(XParam.outvars.begin(), XParam.outvars.end(), namestr[ii]);\n            if (itr != XParam.outvars.end())\n            {\n                log(\"The output variable associated to the ILCL model \\\"\" + namestr[ii] + \"\\\" is requested but the model is not used. The variable is removed from the outputs.\");\n                XParam.outvars.erase(itr);\n            }\n        }\n    }\n\n    //Check that the atmospheric forcing is used if datmpdx, datmpdy output are asked by user.\n    if (XForcing.Atmp.inputfile.empty())\n    {\n        std::vector&lt;std::string&gt; namestr = { \"datmpdx\", \"datmpdy\" };\n        for (int ii = 0; ii &lt; namestr.size(); ii++)\n        {\n            std::vector&lt;std::string&gt;::iterator itr = std::find(XParam.outvars.begin(), XParam.outvars.end(), namestr[ii]);\n            if (itr != XParam.outvars.end())\n            {\n                log(\"The output variable associated to the atmosheric forcing \\\"\" + namestr[ii] + \"\\\" is requested but the model is not used. The variable is removed from the outputs.\");\n                XParam.outvars.erase(itr);\n            }\n        }\n\n    }\n\n}\n\n//Initialise default values for Toutput (output times for map outputs)\nvoid InitialiseToutput(T_output&amp; Toutput_loc, Param XParam)\n{\n\n    Toutput_loc.val = ReadToutput(Toutput_loc.inputstr, XParam);\n    // Make sure Toutput is not empty and that all values are &gt;= totaltime and &lt;= endtime\n    if (Toutput_loc.val.empty())\n    {\n        for (int i = 0; i &lt; XParam.Toutput.val.size(); i++)\n        {\n            Toutput_loc.val.push_back(std::min(std::max(XParam.totaltime, XParam.Toutput.val[i]), XParam.endtime));\n        }\n    }\n\n    // This may seem redundant but the uniq function used in the initial condition should clean out duplicate\n\n\n\n}\n\n\ndouble setendtime(Param XParam, Forcing&lt;float&gt; XForcing)\n{\n    //endtime cannot be bigger than the smallest time set in a boundary\n    SLTS tempSLTS;\n    double endtime = XParam.endtime;\n    if (XForcing.left.on)\n    {\n        tempSLTS = XForcing.left.data.back();\n        endtime = utils::min(endtime, tempSLTS.time);\n\n    }\n    if (XForcing.right.on)\n    {\n        tempSLTS = XForcing.right.data.back();\n        endtime = utils::min(endtime, tempSLTS.time);\n    }\n    if (XForcing.top.on)\n    {\n        tempSLTS = XForcing.top.data.back();\n        endtime = utils::min(endtime, tempSLTS.time);\n    }\n    if (XForcing.bot.on)\n    {\n        tempSLTS = XForcing.bot.data.back();\n        endtime = utils::min(endtime, tempSLTS.time);\n    }\n\n    if (endtime &lt; XParam.endtime)\n    {\n        log(\"\\nWARNING: Boundary definition too short, endtime of the simulation reduced to : \" + std::to_string(endtime));\n    }\n\n    return endtime;\n}\n\n\nstd::string findparameter(std::vector&lt;std::string&gt; parameterstr, std::string line)\n{\n    std::size_t found;\n\n    std::string parameternumber,left,right;\n    std::vector&lt;std::string&gt; splittedstr, splittedstrnohash;\n\n\n    // first look for an equal sign\n    // No equal sign mean not a valid line so skip\n    splittedstr = split(line, '=');\n    if (splittedstr.size() &gt; 1)\n    {\n        left = trim(splittedstr[0], \" \");\n        right = splittedstr[1]; // if there are more than one equal sign in the line the second one is ignored\n        for (int ieq = 2; ieq &lt; splittedstr.size(); ieq++)\n        {\n            right = right + \"=\" + splittedstr[ieq];\n        }\n        for (int ii = 0; ii &lt; parameterstr.size(); ii++)\n        {\n            found = case_insensitive_compare(left, parameterstr[ii]);// it needs to strictly compare\n            if (found == 0)\n                break;\n        }\n        if (found == 0) // found the parameter\n        {\n            //std::cout &lt;&lt;\"found LonMin at : \"&lt;&lt; found &lt;&lt; std::endl;\n            //Numberstart = found + parameterstr.length();\n\n\n            splittedstrnohash = split(right, '#');\n\n            splittedstr = split(splittedstrnohash[0], ';');\n\n            if (splittedstr.size() &gt;= 1)\n            {\n                parameternumber = splittedstr[0];\n            }\n            //std::cout &lt;&lt; parameternumber &lt;&lt; std::endl;\n\n        }\n    }\n    return trim(parameternumber, \" \");\n    //return parameternumber;\n}\n\nstd::string findparameter(std::string parameterstr, std::string line)\n{\n    std::vector&lt;std::string&gt; parametervec;\n\n    parametervec.push_back(parameterstr);\n    return findparameter(parametervec, line);\n}\n\n\n\nvoid split(const std::string&amp; s, char delim, std::vector&lt;std::string&gt;&amp; elems) {\n    std::stringstream ss;\n    ss.str(s);\n    std::string item;\n    while (std::getline(ss, item, delim)) {\n        if (!item.empty())//skip empty tokens\n        {\n            elems.push_back(item);\n        }\n\n    }\n}\n\n\nstd::vector&lt;std::string&gt; split(const std::string&amp; s, char delim) {\n    std::vector&lt;std::string&gt; elems;\n    split(s, delim, elems);\n    return elems;\n}\n\n\n\nvoid split_full(const std::string&amp; s, char delim, std::vector&lt;std::string&gt;&amp; elems) {\n    std::stringstream ss;\n    ss.str(s);\n    std::string item;\n    while (std::getline(ss, item, delim)) {\n        std::string::iterator end_pos = std::remove(item.begin(), item.end(), ' ');\n        item.erase(end_pos, item.end());\n        elems.push_back(item);\n    }\n    if (s[s.length() - 1] == delim)\n    {\n        std::string item;\n        elems.push_back(item);\n    }\n}\n\nstd::vector&lt;std::string&gt; split_full(const std::string&amp; s, char delim) {\n    std::vector&lt;std::string&gt; elems;\n    split_full(s, delim, elems);\n    return elems;\n}\n\nstd::vector&lt;std::string&gt; split(const std::string s, const std::string delim)\n{\n    size_t ide = 0;\n    int loc = 0;\n    std::vector&lt;std::string&gt; output;\n    std::string rem = s;\n\n\n    while (ide &lt; std::string::npos || output.size() == 0)\n    {\n\n        ide = rem.find(delim);\n        if (ide == 0 || ide == std::string::npos)\n        {\n            output.push_back(rem);\n            ide = std::string::npos;\n        }\n        else\n        {\n            output.push_back(rem.substr(loc, ide));\n        }\n\n        if (ide &lt; (rem.length() - delim.length()))\n        {\n            loc = int(ide + delim.length());\n            rem = rem.substr(loc);\n        }\n    }\n\n    return output;\n\n\n\n}\n\n\nstd::string trim(const std::string&amp; str, const std::string&amp; whitespace)\n{\n    const auto strBegin = str.find_first_not_of(whitespace);\n    if (strBegin == std::string::npos)\n        return \"\"; // no content\n\n    const auto strEnd = str.find_last_not_of(whitespace);\n    const auto strRange = strEnd - strBegin + 1;\n\n    return str.substr(strBegin, strRange);\n}\n\nstd::size_t case_insensitive_compare(std::string s1, std::string s2)\n{\n    //Convert s1 and s2 to lower case strings\n    std::transform(s1.begin(), s1.end(), s1.begin(), ::tolower);\n    std::transform(s2.begin(), s2.end(), s2.begin(), ::tolower);\n    //if (s1.compare(s2) == 0)\n    return s1.compare(s2);\n}\n\nstd::size_t case_insensitive_compare(std::string s1, std::vector&lt;std::string&gt; vecstr)\n{\n    std::size_t found;\n    //Convert s1 and s2 to lower case strings\n    for (int ii = 0; ii &lt; vecstr.size(); ii++)\n    {\n        found = case_insensitive_compare(s1, vecstr[ii]);// it needs to strictly compare\n        if (found == 0)\n        {\n            break;\n        }\n    }\n    return found;\n}\n\nbndsegment readbndlineside(std::string parametervalue, std::string side)\n{\n    bndsegment bnd;\n\n\n    std::vector&lt;std::string&gt; items = split(parametervalue, ',');\n\n    if (items.size() == 1)\n    {\n        bnd.type = std::stoi(items[0]);\n\n    }\n    else if (items.size() &gt;= 2)\n    {\n        const char* cstr = items[1].c_str();\n\n        if (isdigit(cstr[0]))\n        {\n            //?\n            bnd.type = std::stoi(items[1]);\n            bnd.inputfile = items[0];\n            bnd.on = true;\n\n\n\n        }\n        else\n        {\n            bnd.type = std::stoi(items[0]);\n            bnd.inputfile = items[1];\n            bnd.on = true;\n        }\n\n    }\n    bnd.polyfile = side;\n    if (bnd.on)\n    {\n        bnd.WLmap = readfileinfo(bnd.inputfile, bnd.WLmap);\n\n        //set the expected type of input\n\n        if (bnd.WLmap.extension.compare(\"nc\") == 0)\n        {\n            bnd.WLmap.uniform = 0;\n            bnd.uniform = 0;\n        }\n        else\n        {\n            bnd.WLmap.uniform = 1;\n            bnd.uniform = 1;\n        }\n    }\n    return bnd;\n}\n\nbndsegment readbndline(std::string parametervalue)\n{\n    //bndseg = area.txt, waterlevelforcing, 1;\n    bndsegment bnd;\n    std::vector&lt;std::string&gt; items = split(parametervalue, ',');\n    if (items.size() == 1)\n    {\n        bnd.type = std::stoi(items[0]);\n\n    }\n    else if (items.size() &gt;= 2)\n    {\n        const char* cstr = items[1].c_str();\n        if (items[1].length() &gt; 2)\n        {\n            bnd.polyfile = items[0];\n            bnd.type = std::stoi(items[2]);\n            bnd.inputfile = items[1];\n            bnd.on = true;\n\n        }\n        else\n        {\n            bnd.polyfile = items[0];\n            bnd.type = std::max(std::stoi(items[1]), 1); // only 2 param implies that it is either a wall or Neumann bnd\n\n        }\n    }\n\n\n    //set the expected type of input\n\n    if (bnd.on)\n    {\n        bnd.WLmap = readfileinfo(bnd.inputfile, bnd.WLmap);\n\n        //set the expected type of input\n\n        if (bnd.WLmap.extension.compare(\"nc\") == 0)\n        {\n            bnd.WLmap.uniform = 0;\n            bnd.uniform = 0;\n        }\n        else\n        {\n            bnd.WLmap.uniform = 1;\n            bnd.uniform = 1;\n        }\n    }\n    return bnd;\n}\n\n\nbool readparambool(std::string paramstr, bool defaultval)\n{\n    bool out = defaultval;\n    std::vector&lt;std::string&gt; truestr = { \"1\",\"true\",\"yes\", \"on\" };\n    std::vector&lt;std::string&gt; falsestr = { \"-1\",\"false\",\"no\",\"off\" };\n\n    if (case_insensitive_compare(paramstr, truestr) == 0)\n    {\n        out = true;\n    }\n    if (case_insensitive_compare(paramstr, falsestr) == 0)\n    {\n        out = false;\n    }\n\n    return out;\n}\n\n\n\n\n//inline bool fileexists(const std::string&amp; name) {\n//  struct stat buffer;\n//  return (stat(name.c_str(), &amp;buffer) == 0);\n//}\n\nstd::vector&lt;std::string&gt; ReadToutSTR(std::string paramstr)\n{\n    std::vector&lt;std::string&gt; Toutputpar = split(paramstr, ',');\n    return Toutputpar;\n\n}\n\ndouble ReadTvalstr(std::string timestr,double start, double end,std::string reftime)\n{\n    double time = 0.0;\n    std::vector&lt;std::string&gt; STstr = { \"start\",\"begin\" };\n    std::vector&lt;std::string&gt; ENstr = { \"end\",\"finish\" };\n\n    bool isdatest = timestr.find('T') != std::string::npos;\n\n    if (case_insensitive_compare(timestr, STstr) == 0)\n    {\n        time = start;\n    }\n    else if (case_insensitive_compare(timestr, ENstr) == 0)\n    {\n        time = end;\n    }\n    else if (!isdatest)\n    {\n        time = start + readApproxtimestr(timestr);\n    }\n    else\n    {\n        time = date_string_to_s(timestr, reftime);\n    }\n\n    return time = std::min(std::max(start, time), end);\n\n}\n\nstd::vector&lt;double&gt; ReadTRangestr(std::vector&lt;std::string&gt; timestr, double start, double end, std::string reftime)\n{\n    double init = 0.0;\n    double step = 0.0;\n    double last = 0.0;\n\n    std::vector&lt;std::string&gt; STstr = { \"start\",\"begin\" };\n\n    std::vector&lt;std::string&gt; ENstr = { \"end\",\"finish\" };\n\n    std::string initstr = timestr[0];\n    std::string stepstr = timestr[1];\n    std::string laststr = timestr[2];\n\n    bool isdateinit = initstr.find('T') != std::string::npos;\n\n    bool isdatelast = laststr.find('T') != std::string::npos;\n\n\n    if (case_insensitive_compare(initstr, STstr) == 0 || initstr.empty())\n    {\n        init = start;\n    }\n    else if (!isdateinit)\n    {\n        init = start + readApproxtimestr(initstr);\n    }\n    else\n    {\n        init = date_string_to_s(initstr, reftime);\n    }\n\n    if (case_insensitive_compare(laststr, ENstr) == 0 || laststr.empty())\n    {\n        last = end;\n    }\n    else if (!isdatelast)\n    {\n        last = start + readApproxtimestr(laststr);\n    }\n    else\n    {\n        last = date_string_to_s(laststr, reftime);\n    }\n\n    if (stepstr.empty())\n    {\n        step = (last - init);\n    }\n    else\n    {\n        step = readApproxtimestr(stepstr);\n    }\n\n    std::vector&lt;double&gt; tout;\n    int nstep = (last - init) / step + 1;\n\n    for (int k = 0; k &lt; nstep; k++)\n    {\n        tout.push_back(std::min(init + step * k, last));\n    }\n\n\n    return tout;\n\n}\n\ndouble readApproxtimestr(std::string input)\n{\n    double time = 0.0;\n\n    double fac = 1.0;\n\n    std::string numberst;\n    std::string unit;\n\n    // first split the digit from the string\n    for (auto e : input)\n    {\n        if (isalpha(e) &amp;&amp; e!='.')\n            unit.push_back(e);\n        else if (isdigit(e) || e == '.')\n            numberst.push_back(e);\n    }\n\n    double number = std::stod(numberst);\n\n    std::vector&lt;std::string&gt; secondvec = { \"seconds\",\"second\",\"sec\",\"s\" };\n    std::vector&lt;std::string&gt; minutevec = { \"minutes\",\"minute\",\"min\",\"m\" };\n    std::vector&lt;std::string&gt; hourvec = { \"hours\",\"hour\",\"hrs\",\"hr\",\"h\" };\n    std::vector&lt;std::string&gt; dayvec = { \"days\",\"day\",\"d\" };\n    std::vector&lt;std::string&gt; monthvec = { \"months\",\"month\",\"mths\", \"mth\", \"mon\" };\n    std::vector&lt;std::string&gt; yearvec = { \"years\",\"year\",\"yrs\", \"yr\", \"y\" };\n\n\n    std::size_t found;\n    found = case_insensitive_compare(unit, secondvec);\n    if (found == 0)\n        fac = 1.0;\n\n    found = case_insensitive_compare(unit, minutevec);\n    if (found == 0)\n        fac = 60.0;\n\n    found = case_insensitive_compare(unit, hourvec);\n    if (found == 0)\n        fac = 3600.0;\n\n    found = case_insensitive_compare(unit, dayvec);\n    if (found == 0)\n        fac = 3600.0 * 24.0;\n\n    found = case_insensitive_compare(unit, monthvec);\n    if (found == 0)\n        fac = 3600.0 * 24.0 * 30.4375;\n\n    found = case_insensitive_compare(unit, yearvec);\n    if (found == 0)\n        fac = 3600.0 * 24.0 * 365.25;\n\n    // If unit is not understood it will return number\n    time = fac * number;\n\n    return time;\n}\n\nstd::vector&lt;double&gt; ReadToutput(std::vector&lt;std::string&gt; paramstr,Param XParam)\n{\n    //\n\n    T_output tout;\n    double Xstart = XParam.totaltime;\n    double Xend = XParam.endtime;\n    std::string reftime = XParam.reftime;\n\n\n    for (int ipa = 0; ipa &lt; paramstr.size(); ipa++)\n    {\n\n        //Check if it is a range or a single value\n\n\n        std::vector&lt;std::string&gt; Toutputpar_vect = split_full(paramstr[ipa], '|');\n\n        if (Toutputpar_vect.size() == 3)\n        {\n\n            // It is range\n            std::vector&lt;double&gt; rgvals = ReadTRangestr(Toutputpar_vect, Xstart, Xend, reftime);\n            //a.insert(a.end(), b.begin(), b.end());\n            tout.val.insert(tout.val.end(), rgvals.begin(), rgvals.end());\n\n\n        }\n        else if (Toutputpar_vect.size() &gt; 1)\n        {\n            //Failed: Toutput must be exactly 3 values, separated by \":\" for a vector shape, in virst position. \"t_init:t_step:t_end\" (with possible empty values as \"t_init:t_setps: \" to use the last time steps as t_end;\n            std::cerr &lt;&lt; \"Failed: Toutput must be exactly 3 values, separated by ':' for a vector shape, in virst position. 't_init : t_step : t_end' (with possible empty values as 't_init : t_setps : ' to use the last time steps as t_end; see log file for details\" &lt;&lt; std::endl;\n\n            log(\"Failed: Toutput must be exactly 3 values, separated by ':' for a vector shape, in virst position. 't_init : t_step : t_end' (with possible empty values as 't_init : t_setps : ' to use the last time steps as t_end;\");\n            log(paramstr[ipa]);\n        }\n        else {\n            tout.val.push_back(ReadTvalstr(paramstr[ipa],Xstart, Xend, reftime));\n        }\n    }\n\n    return tout.val;\n}\n</code></pre>"},{"location":"BGFlood/_read_input_8h/","title":"File ReadInput.h","text":""},{"location":"BGFlood/_read_input_8h/#file-readinputh","title":"File ReadInput.h","text":"<p>FileList &gt; src &gt; ReadInput.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"utctime.h\"</code></li> <li><code>#include \"Input.h\"</code></li> <li><code>#include \"ReadForcing.h\"</code></li> </ul>"},{"location":"BGFlood/_read_input_8h/#public-functions","title":"Public Functions","text":"Type Name void InitialiseToutput (T_output &amp; Toutput, Param XParam) Initialise the Toutput structure with output times. This function reads the output times from a specified input string and ensures that the times are within the simulation time range. If no valid times are provided, it defaults to using the total time and end time. std::vector&lt; double &gt; ReadTRangestr (std::vector&lt; std::string &gt; timestr, double start, double end, std::string reftime) Read and interpret a time range string, converting it to a vector of doubles within specified bounds. This function interprets a time range string formatted as \"t_init:t_step:t_end\", where each component can be a specific time value or a keyword representing the start or end of the overall time range. It converts the range into a vector of double values representing discrete time steps, ensuring all values fall within the provided start and end bounds. std::vector&lt; std::string &gt; ReadToutSTR (std::string paramstr) Split a comma-separated parameter string into a vector of strings. std::vector&lt; double &gt; ReadToutput (std::vector&lt; std::string &gt; paramstr, Param XParam) Read and interpret output time specifications from a vector of parameter strings. This function processes a vector of parameter strings that specify output times, which can include individual time values or ranges defined by a start, step, and end. It converts these specifications into a vector of double values representing the output times, ensuring all times fall within the simulation's total time and end time. double ReadTvalstr (std::string timestr, double start, double end, std::string reftime) Read and interpret a time value string, converting it to a double within specified bounds. This function interprets a time value string, which can represent specific keywords (\"start\", \"end\"), relative times, or absolute date-time strings. It converts the string to a double value representing time, ensuring it falls within the provided start and end bounds. void Readparamfile (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing, std::string Paramfile) Read and parse the parameter file. Opens the specified parameter file (default: BG_param.txt file), reads its contents, and updates the provided parameter structures: Param class (XParam) andForcing class (XForcing). std::size_t case_insensitive_compare (std::string s1, std::string s2) Perform a non case-insensitive comparison between two strings or a string and a vector of strings. This function converts both strings to lowercase and compares them. If a vector of strings is provided, it compares the first string against each string in the vector. std::size_t case_insensitive_compare (std::string s1, std::vector&lt; std::string &gt; vecstr) Perform a non case-insensitive comparison between a string and a vector of strings. This function converts the first string to lowercase and compares it against each string in the vector. void checkparamsanity (Param &amp; XParam, Forcing&lt; float &gt; &amp; XForcing) Check and adjust the sanity of model parameters and forcing data. This function checks the sanity of the model parameters and forcing data. It adjusts parameters as needed, ensuring they are within acceptable ranges and consistent with each other. std::string findparameter (std::vector&lt; std::string &gt; parameterstr, std::string line) Find and extract the value of a specified parameter from a configuration line. This function searches for a specified parameter in a given line of text, and extracts its associated value if found. It handles comments and whitespace appropriately. std::string findparameter (std::string parameterstr, std::string line) Find and extract the value of a specified parameter from a configuration line. This function searches for a specified parameter in a given line of text, and extracts its associated value if found. It handles comments and whitespace appropriately. double readApproxtimestr (std::string input) Convert an approximate time string to a double value in seconds. This function interprets a time string that may include a numeric value followed by a time unit (e.g., \"seconds\", \"minutes\", \"hours\", \"days\", \"months\", \"years\") and converts it to a double value representing the equivalent time in seconds. If the unit is not recognized, it defaults to seconds. bndsegment readbndline (std::string parametervalue) Read boundary segment information from a parameter value string. This function parses a parameter value string to extract boundary segment information, including type, input file, and polygon file. It also reads file information and sets the expected type of input based on the file extension. bndsegment readbndlineside (std::string parametervalue, std::string side) Read boundary segment information from a parameter value string for a specific side. This function parses a parameter value string to extract boundary segment information, including type, input file, and polygon file for a specified side. It also reads file information and sets the expected type of input based on the file extension. T readfileinfo (std::string input, T outinfo) Parse a parameter string and update the parameter structure. Parses a line from the parameter file and updates the given parameter structure. Convert file name into name and extension. This is used for various input classes template inputmap readfileinfo&lt;inputmap&gt;(std::string input, inputmap outinfo); template forcingmap readfileinfo&lt;forcingmap&gt;(std::string input, forcingmap outinfo); template StaticForcingP&lt;float&gt; readfileinfo&lt;StaticForcingP&lt;float&gt;&gt;(std::string input, StaticForcingP&lt;float&gt; outinfo); template DynForcingP&lt;float&gt; readfileinfo&lt;DynForcingP&lt;float&gt; &gt;(std::string input,DynForcingP&lt;float&gt; outinfo); template deformmap&lt;float&gt; readfileinfo&lt;deformmap&lt;float&gt;&gt;(std::string input, deformmap&lt;float&gt; outinfo);. bool readparambool (std::string paramstr, bool defaultval) Convert a parameter string to a boolean value, with a default fallback. This function interprets a parameter string as a boolean value, returning true for recognized true values and false for recognized false values. If the string does not match any known values, it returns a specified default value.  __ Forcing&lt; T &gt; readparamstr (std::string line, Forcing&lt; T &gt; forcing) Parse a parameter string and update the forcing structure. Parses a line from the parameter file and updates the given forcing structure. Read BG_param.txt line and convert parameter to the right parameter in the class Return an updatedForcing class. Param readparamstr (std::string line, Param param) Parse a parameter string and update the parameter structure. double setendtime (Param XParam, Forcing&lt; float &gt; XForcing) Adjust the simulation \"endtime\" based on maximum time in forcings. This function checks the end times of boundary forcing data and adjusts the simulation end time if any boundary forcing ends before the specified end time. A warning is logged if the end time is reduced. void split (const std::string &amp; s, char delim, std::vector&lt; std::string &gt; &amp; elems) Split a string into tokens based on a specified delimiter, skipping empty tokens. This function takes a string and splits it into a vector of substrings using the specified delimiter. Empty tokens resulting from consecutive delimiters are skipped. std::vector&lt; std::string &gt; split (const std::string &amp; s, char delim) Split a string into tokens based on a specified character delimiter, skipping empty tokens. This function takes a string and splits it into a vector of substrings using the specified delimiter. Empty tokens resulting from consecutive delimiters are skipped. std::vector&lt; std::string &gt; split (const std::string s, const std::string delim) Split a string into tokens based on a specified substring delimiter. This function takes a string and splits it into a vector of substrings using the specified substring delimiter. void split_full (const std::string &amp; s, char delim, std::vector&lt; std::string &gt; &amp; elems) Split a string into tokens based on a specified delimiter, preserving empty tokens. This function takes a string and splits it into a vector of substrings using the specified delimiter. Unlike the standard split function, this version preserves empty tokens that result from consecutive delimiters.  __ std::vector&lt; std::string &gt; split_full (const std::string &amp; s, char delim) Split a string into tokens based on a specified character delimiter, preserving empty tokens. This function takes a string and splits it into a vector of substrings using the specified delimiter. Unlike the standard split function, this version preserves empty tokens that result from consecutive delimiters.  __ std::string trim (const std::string &amp; str, const std::string &amp; whitespace) Trim leading and trailing whitespace from a string. This function removes all leading and trailing characters from the input string that are present in the specified whitespace string."},{"location":"BGFlood/_read_input_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_read_input_8h/#function-initialisetoutput","title":"function InitialiseToutput","text":"<p>Initialise the Toutput structure with output times. This function reads the output times from a specified input string and ensures that the times are within the simulation time range. If no valid times are provided, it defaults to using the total time and end time. </p><pre><code>void InitialiseToutput (\n    T_output &amp; Toutput,\n    Param XParam\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>Toutput_loc</code> Reference to the T_output structure to be initialised. </li> <li><code>XParam</code> The Param structure containing simulation parameters. </li> </ul>"},{"location":"BGFlood/_read_input_8h/#function-readtrangestr","title":"function ReadTRangestr","text":"<p>Read and interpret a time range string, converting it to a vector of doubles within specified bounds. This function interprets a time range string formatted as \"t_init:t_step:t_end\", where each component can be a specific time value or a keyword representing the start or end of the overall time range. It converts the range into a vector of double values representing discrete time steps, ensuring all values fall within the provided start and end bounds. </p><pre><code>std::vector&lt; double &gt; ReadTRangestr (\n    std::vector&lt; std::string &gt; timestr,\n    double start,\n    double end,\n    std::string reftime\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>timestr</code> A vector of strings representing the time range components: [t_init, t_step, t_end]. </li> <li><code>start</code> The start time bound. </li> <li><code>end</code> The end time bound. </li> <li><code>reftime</code> The reference time for interpreting absolute date-time strings. </li> </ul> <p>Returns:</p> <p>A vector of double values representing the interpreted time steps within the specified range. </p>"},{"location":"BGFlood/_read_input_8h/#function-readtoutstr","title":"function ReadToutSTR","text":"<p>Split a comma-separated parameter string into a vector of strings. </p><pre><code>std::vector&lt; std::string &gt; ReadToutSTR (\n    std::string paramstr\n) \n</code></pre> <p>This function takes a parameter string containing values separated by commas and splits it into a vector of individual strings. </p> <p>Parameters:</p> <ul> <li><code>paramstr</code> The parameter string to be split. </li> </ul> <p>Returns:</p> <p>A vector of strings obtained by splitting the input string at commas. </p>"},{"location":"BGFlood/_read_input_8h/#function-readtoutput","title":"function ReadToutput","text":"<p>Read and interpret output time specifications from a vector of parameter strings. This function processes a vector of parameter strings that specify output times, which can include individual time values or ranges defined by a start, step, and end. It converts these specifications into a vector of double values representing the output times, ensuring all times fall within the simulation's total time and end time. </p><pre><code>std::vector&lt; double &gt; ReadToutput (\n    std::vector&lt; std::string &gt; paramstr,\n    Param XParam\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>paramstr</code> A vector of strings specifying output times or ranges. </li> <li><code>XParam</code> The Param structure containing simulation parameters, including total time and end time. </li> </ul> <p>Returns:</p> <p>A vector of double values representing the interpreted output times. </p>"},{"location":"BGFlood/_read_input_8h/#function-readtvalstr","title":"function ReadTvalstr","text":"<p>Read and interpret a time value string, converting it to a double within specified bounds. This function interprets a time value string, which can represent specific keywords (\"start\", \"end\"), relative times, or absolute date-time strings. It converts the string to a double value representing time, ensuring it falls within the provided start and end bounds. </p><pre><code>double ReadTvalstr (\n    std::string timestr,\n    double start,\n    double end,\n    std::string reftime\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>timestr</code> The time value string to be interpreted. </li> <li><code>start</code> The start time bound. </li> <li><code>end</code> The end time bound. </li> <li><code>reftime</code> The reference time for interpreting absolute date-time strings. </li> </ul> <p>Returns:</p> <p>A double value representing the interpreted time, constrained within the start and end bounds. </p>"},{"location":"BGFlood/_read_input_8h/#function-readparamfile","title":"function Readparamfile","text":"<p>Read and parse the parameter file. Opens the specified parameter file (default: BG_param.txt file), reads its contents, and updates the provided parameter structures: Param class (XParam) andForcing class (XForcing). </p><pre><code>void Readparamfile (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing,\n    std::string Paramfile\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Reference to the parameter structure to be updated </li> <li><code>XForcing</code> Reference to the forcing structure to be updated </li> <li><code>Paramfile</code> Name of the parameter file to read </li> </ul>"},{"location":"BGFlood/_read_input_8h/#function-case_insensitive_compare","title":"function case_insensitive_compare","text":"<p>Perform a non case-insensitive comparison between two strings or a string and a vector of strings. This function converts both strings to lowercase and compares them. If a vector of strings is provided, it compares the first string against each string in the vector. </p><pre><code>std::size_t case_insensitive_compare (\n    std::string s1,\n    std::string s2\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s1</code> The first string to compare. </li> <li><code>s2</code> The second string to compare, or a vector of strings to compare against </li> </ul>"},{"location":"BGFlood/_read_input_8h/#function-case_insensitive_compare_1","title":"function case_insensitive_compare","text":"<p>Perform a non case-insensitive comparison between a string and a vector of strings. This function converts the first string to lowercase and compares it against each string in the vector. </p><pre><code>std::size_t case_insensitive_compare (\n    std::string s1,\n    std::vector&lt; std::string &gt; vecstr\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s1</code> The first string to compare. </li> <li><code>vecstr</code> The vector of strings to compare against. </li> </ul>"},{"location":"BGFlood/_read_input_8h/#function-checkparamsanity","title":"function checkparamsanity","text":"<p>Check and adjust the sanity of model parameters and forcing data. This function checks the sanity of the model parameters and forcing data. It adjusts parameters as needed, ensuring they are within acceptable ranges and consistent with each other. </p><pre><code>void checkparamsanity (\n    Param &amp; XParam,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Reference to the model parameters structure to be checked and adjusted. </li> <li><code>XForcing</code> Reference to the forcing data structure to be checked and adjusted. </li> </ul>"},{"location":"BGFlood/_read_input_8h/#function-findparameter","title":"function findparameter","text":"<p>Find and extract the value of a specified parameter from a configuration line. This function searches for a specified parameter in a given line of text, and extracts its associated value if found. It handles comments and whitespace appropriately. </p><pre><code>std::string findparameter (\n    std::vector&lt; std::string &gt; parameterstr,\n    std::string line\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>parameterstr</code> The parameter name to search for. </li> <li><code>line</code> The line of text to search within. </li> </ul> <p>Returns:</p> <p>The extracted parameter value as a string, or an empty string if the parameter is not found. </p>"},{"location":"BGFlood/_read_input_8h/#function-findparameter_1","title":"function findparameter","text":"<p>Find and extract the value of a specified parameter from a configuration line. This function searches for a specified parameter in a given line of text, and extracts its associated value if found. It handles comments and whitespace appropriately. </p><pre><code>std::string findparameter (\n    std::string parameterstr,\n    std::string line\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>parameterstr</code> The parameter name to search for. </li> <li><code>line</code> The line of text to search within. </li> </ul> <p>Returns:</p> <p>The extracted parameter value as a string, or an empty string if the parameter is not found. </p>"},{"location":"BGFlood/_read_input_8h/#function-readapproxtimestr","title":"function readApproxtimestr","text":"<p>Convert an approximate time string to a double value in seconds. This function interprets a time string that may include a numeric value followed by a time unit (e.g., \"seconds\", \"minutes\", \"hours\", \"days\", \"months\", \"years\") and converts it to a double value representing the equivalent time in seconds. If the unit is not recognized, it defaults to seconds. </p><pre><code>double readApproxtimestr (\n    std::string input\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>input</code> The approximate time string to be converted (e.g., \"10 minutes\", \"2.5 hours\"). </li> </ul> <p>Returns:</p> <p>A double value representing the time in seconds. </p>"},{"location":"BGFlood/_read_input_8h/#function-readbndline","title":"function readbndline","text":"<p>Read boundary segment information from a parameter value string. This function parses a parameter value string to extract boundary segment information, including type, input file, and polygon file. It also reads file information and sets the expected type of input based on the file extension. </p><pre><code>bndsegment readbndline (\n    std::string parametervalue\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>parametervalue</code> The parameter value string containing boundary segment information. </li> </ul>"},{"location":"BGFlood/_read_input_8h/#function-readbndlineside","title":"function readbndlineside","text":"<p>Read boundary segment information from a parameter value string for a specific side. This function parses a parameter value string to extract boundary segment information, including type, input file, and polygon file for a specified side. It also reads file information and sets the expected type of input based on the file extension. </p><pre><code>bndsegment readbndlineside (\n    std::string parametervalue,\n    std::string side\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>parametervalue</code> The parameter value string containing boundary segment information. </li> <li><code>side</code> The side (e.g., \"left\", \"right\", \"top\", \"bot\") for which the boundary segment is defined. </li> </ul>"},{"location":"BGFlood/_read_input_8h/#function-readfileinfo","title":"function readfileinfo","text":"<p>Parse a parameter string and update the parameter structure. Parses a line from the parameter file and updates the given parameter structure. Convert file name into name and extension. This is used for various input classes template inputmap readfileinfo&lt;inputmap&gt;(std::string input, inputmap outinfo); template forcingmap readfileinfo&lt;forcingmap&gt;(std::string input, forcingmap outinfo); template StaticForcingP&lt;float&gt; readfileinfo&lt;StaticForcingP&lt;float&gt;&gt;(std::string input, StaticForcingP&lt;float&gt; outinfo); template DynForcingP&lt;float&gt; readfileinfo&lt;DynForcingP&lt;float&gt; &gt;(std::string input,DynForcingP&lt;float&gt; outinfo); template deformmap&lt;float&gt; readfileinfo&lt;deformmap&lt;float&gt;&gt;(std::string input, deformmap&lt;float&gt; outinfo);. </p><pre><code>template&lt;class T&gt;\nT readfileinfo (\n    std::string input,\n    T outinfo\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>line</code> Input line from parameter file </li> <li><code>param</code> Parameter structure to update </li> </ul> <p>Returns:</p> <p>Updated parameter structure</p> <p>convert file name into name and extension This is used for various input classes</p> <p>template inputmap readfileinfo&lt;inputmap&gt;(std::string input, inputmap outinfo); template forcingmap readfileinfo&lt;forcingmap&gt;(std::string input, forcingmap outinfo); template StaticForcingP&lt;float&gt; readfileinfo&lt;StaticForcingP&lt;float&gt;&gt;(std::string input, StaticForcingP&lt;float&gt; outinfo); template DynForcingP&lt;float&gt; readfileinfo&lt;DynForcingP&lt;float&gt;&gt;(std::string input, DynForcingP&lt;float&gt; outinfo); template deformmap&lt;float&gt; readfileinfo&lt;deformmap&lt;float&gt;&gt;(std::string input, deformmap&lt;float&gt; outinfo); </p>"},{"location":"BGFlood/_read_input_8h/#function-readparambool","title":"function readparambool","text":"<p>Convert a parameter string to a boolean value, with a default fallback. This function interprets a parameter string as a boolean value, returning true for recognized true values and false for recognized false values. If the string does not match any known values, it returns a specified default value.  __ </p><pre><code>bool readparambool (\n    std::string paramstr,\n    bool defaultval\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>paramstr</code> The parameter string to be interpreted. </li> <li><code>defaultval</code> The default boolean value to return if the string does not match known values </li> </ul>"},{"location":"BGFlood/_read_input_8h/#function-readparamstr","title":"function readparamstr","text":"<p>Parse a parameter string and update the forcing structure. Parses a line from the parameter file and updates the given forcing structure. Read BG_param.txt line and convert parameter to the right parameter in the class Return an updatedForcing class. </p><pre><code>template&lt;class T&gt;\nForcing &lt; T &gt; readparamstr (\n    std::string line,\n    Forcing &lt; T &gt; forcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>line</code> Input line from parameter file </li> <li><code>forcing</code> Forcing structure to update </li> </ul> <p>Returns:</p> <p>Updated forcing structure</p> <p>Read BG_param.txt line and convert parameter to the righ parameter in the class return an updated Param class </p>"},{"location":"BGFlood/_read_input_8h/#function-readparamstr_1","title":"function readparamstr","text":"<p>Parse a parameter string and update the parameter structure. </p><pre><code>Param readparamstr (\n    std::string line,\n    Param param\n) \n</code></pre> <p>Parses a line from the parameter file and updates the given parameter structure. Read BG_param.txt line and convert parameter to the right parameter in the class Return an updated Param class</p> <p>Parameters:</p> <ul> <li><code>line</code> Input line from parameter file </li> <li><code>param</code> Parameter structure to update </li> </ul> <p>Returns:</p> <p>Updated parameter structure</p> <p>Read BG_param.txt line and convert parameter to the righ parameter in the class return an updated Param class </p>"},{"location":"BGFlood/_read_input_8h/#function-setendtime","title":"function setendtime","text":"<p>Adjust the simulation \"endtime\" based on maximum time in forcings. This function checks the end times of boundary forcing data and adjusts the simulation end time if any boundary forcing ends before the specified end time. A warning is logged if the end time is reduced. </p><pre><code>double setendtime (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The Param structure containing simulation parameters, including the initial end time. </li> <li><code>XForcing</code> The Forcing structure containing boundary forcing data. </li> </ul>"},{"location":"BGFlood/_read_input_8h/#function-split","title":"function split","text":"<p>Split a string into tokens based on a specified delimiter, skipping empty tokens. This function takes a string and splits it into a vector of substrings using the specified delimiter. Empty tokens resulting from consecutive delimiters are skipped. </p><pre><code>void split (\n    const std::string &amp; s,\n    char delim,\n    std::vector&lt; std::string &gt; &amp; elems\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s</code> The input string to be split. </li> <li><code>delim</code> The character used as the delimiter for splitting the string. </li> <li><code>elems</code> A reference to a vector where the resulting substrings will be stored. </li> </ul>"},{"location":"BGFlood/_read_input_8h/#function-split_1","title":"function split","text":"<p>Split a string into tokens based on a specified character delimiter, skipping empty tokens. This function takes a string and splits it into a vector of substrings using the specified delimiter. Empty tokens resulting from consecutive delimiters are skipped. </p><pre><code>std::vector&lt; std::string &gt; split (\n    const std::string &amp; s,\n    char delim\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s</code> The input string to be split. </li> <li><code>delim</code> The character used as the delimiter for splitting the string. </li> </ul> <p>Returns:</p> <p>A vector containing the resulting substrings. </p>"},{"location":"BGFlood/_read_input_8h/#function-split_2","title":"function split","text":"<p>Split a string into tokens based on a specified substring delimiter. This function takes a string and splits it into a vector of substrings using the specified substring delimiter. </p><pre><code>std::vector&lt; std::string &gt; split (\n    const std::string s,\n    const std::string delim\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s</code> The input string to be split. </li> <li><code>delim</code> The substring used as the delimiter for splitting the string. </li> </ul> <p>Returns:</p> <p>A vector containing the resulting substrings. </p>"},{"location":"BGFlood/_read_input_8h/#function-split_full","title":"function split_full","text":"<p>Split a string into tokens based on a specified delimiter, preserving empty tokens. This function takes a string and splits it into a vector of substrings using the specified delimiter. Unlike the standard split function, this version preserves empty tokens that result from consecutive delimiters.  __ </p><pre><code>void split_full (\n    const std::string &amp; s,\n    char delim,\n    std::vector&lt; std::string &gt; &amp; elems\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s</code> The input string to be split. </li> <li><code>delim</code> The character used as the delimiter for splitting the string. </li> <li><code>elems</code> A reference to a vector where the resulting substrings will be stored.</li> </ul> <p>split string based in character, conserving empty item </p>"},{"location":"BGFlood/_read_input_8h/#function-split_full_1","title":"function split_full","text":"<p>Split a string into tokens based on a specified character delimiter, preserving empty tokens. This function takes a string and splits it into a vector of substrings using the specified delimiter. Unlike the standard split function, this version preserves empty tokens that result from consecutive delimiters.  __ </p><pre><code>std::vector&lt; std::string &gt; split_full (\n    const std::string &amp; s,\n    char delim\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s</code> The input string to be split. </li> <li><code>delim</code> The character used as the delimiter for splitting the string.</li> </ul> <p>split string based in character, conserving empty items </p>"},{"location":"BGFlood/_read_input_8h/#function-trim","title":"function trim","text":"<p>Trim leading and trailing whitespace from a string. This function removes all leading and trailing characters from the input string that are present in the specified whitespace string. </p><pre><code>std::string trim (\n    const std::string &amp; str,\n    const std::string &amp; whitespace\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>str</code> The input string to be trimmed. </li> <li><code>whitespace</code> A string containing all characters considered as whitespace.</li> </ul> <p>remove leading and trailing space in a string </p> <p>The documentation for this class was generated from the following file <code>src/ReadInput.h</code></p>"},{"location":"BGFlood/_read_input_8h_source/","title":"File ReadInput.h","text":""},{"location":"BGFlood/_read_input_8h_source/#file-readinputh","title":"File ReadInput.h","text":"<p>File List &gt; src &gt; ReadInput.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef READINPUT_H\n#define READINPUT_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"Forcing.h\"\n#include \"Util_CPU.h\"\n#include \"utctime.h\"\n#include \"Input.h\"\n#include \"ReadForcing.h\"\n\n\ntemplate &lt;class T&gt; T readfileinfo(std::string input, T outinfo);\n\nvoid Readparamfile(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing, std::string Paramfile);\n\ntemplate &lt;class T&gt; Forcing&lt;T&gt; readparamstr(std::string line, Forcing&lt;T&gt; forcing);\n\nParam readparamstr(std::string line, Param param);\n\ntemplate &lt;class T&gt;Forcing&lt;T&gt; readparamstr(std::string line, Forcing&lt;T&gt; forcing);\nvoid checkparamsanity(Param&amp; XParam, Forcing&lt;float&gt;&amp; XForcing);\ndouble setendtime(Param XParam, Forcing&lt;float&gt; XForcing);\nstd::string findparameter(std::vector&lt;std::string&gt; parameterstr, std::string line);\nstd::string findparameter(std::string parameterstr, std::string line);\nvoid split(const std::string&amp; s, char delim, std::vector&lt;std::string&gt;&amp; elems);\nstd::vector&lt;std::string&gt; split(const std::string&amp; s, char delim);\nvoid split_full(const std::string&amp; s, char delim, std::vector&lt;std::string&gt;&amp; elems);\nstd::vector&lt;std::string&gt; split_full(const std::string&amp; s, char delim);\nstd::vector&lt;std::string&gt; split(const std::string s, const std::string delim);\nstd::string trim(const std::string&amp; str, const std::string&amp; whitespace);\nstd::size_t case_insensitive_compare(std::string s1, std::string s2);\nstd::size_t case_insensitive_compare(std::string s1, std::vector&lt;std::string&gt; vecstr);\nbool readparambool(std::string paramstr, bool defaultval);\nvoid InitialiseToutput(T_output&amp; Toutput, Param XParam);\nbndsegment readbndline(std::string parametervalue);\nbndsegment readbndlineside(std::string parametervalue, std::string side);\n\n//T_output ReadToutput(std::vector&lt;std::string&gt; paramstr, Param XParam);\nstd::vector&lt;double&gt; ReadToutput(std::vector&lt;std::string&gt; paramstr, Param XParam);\n\nstd::vector&lt;std::string&gt; ReadToutSTR(std::string paramstr);\ndouble ReadTvalstr(std::string timestr, double start, double end, std::string reftime);\nstd::vector&lt;double&gt; ReadTRangestr(std::vector&lt;std::string&gt; timestr, double start, double end, std::string reftime);\ndouble readApproxtimestr(std::string input);\n\n//inline bool fileexists(const std::string&amp; name);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/","title":"File Read_netcdf.cu","text":""},{"location":"BGFlood/_read__netcdf_8cu/#file-read_netcdfcu","title":"File Read_netcdf.cu","text":"<p>FileList &gt; src &gt; Read_netcdf.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Read_netcdf.h\"</code></li> </ul>"},{"location":"BGFlood/_read__netcdf_8cu/#public-functions","title":"Public Functions","text":"Type Name std::string checkncvarname (int ncid, std::string stringA, std::string stringB, std::string stringC, std::string stringD, std::string stringE) Check for the existence of NetCDF variable names and return the first found. int nc_get_var1_T (int ncid, int varid, const size_t * startp, float * zsa)  int nc_get_var1_T (int ncid, int varid, const size_t * startp, double * zsa)  int nc_get_var_T (int ncid, int varid, float *&amp; zb)  int nc_get_var_T (int ncid, int varid, double *&amp; zb)  int nc_get_var_T (int ncid, int varid, int *&amp; zb)  int nc_get_vara_T (int ncid, int varid, const size_t * startp, const size_t * countp, int *&amp; zb)  int nc_get_vara_T (int ncid, int varid, const size_t * startp, const size_t * countp, float *&amp; zb)  int nc_get_vara_T (int ncid, int varid, const size_t * startp, const size_t * countp, double *&amp; zb)  void read2Dnc (int nx, int ny, char ncfile, float *&amp; hh)  void read3Dnc (int nx, int ny, int ntheta, char ncfile, float *&amp; ee)  void readATMstep (forcingmap ATMPmap, int steptoread, float *&amp; Po) Read atmospheric pressure data from NetCDF file for a specific time step. void readWNDstep (forcingmap WNDUmap, forcingmap WNDVmap, int steptoread, float *&amp; Uo, float *&amp; Vo) Read wind data from NetCDF files for a specific time step. void readgridncsize (const std::string ncfilestr, const std::string varstr, std::string reftime, int &amp; nx, int &amp; ny, int &amp; nt, double &amp; dx, double &amp; dy, double &amp; dt, double &amp; xo, double &amp; yo, double &amp; to, double &amp; xmax, double &amp; ymax, double &amp; tmax, bool &amp; flipx, bool &amp; flipy) Read grid size and metadata from a NetCDF file. void readgridncsize (forcingmap &amp; Fmap, Param XParam) Read grid size and metadata for a forcing map. void readgridncsize (T &amp; Imap) Read grid size and metadata for a generic map type. template void readgridncsize&lt; DynForcingP&lt; float &gt; &gt; (DynForcingP&lt; float &gt; &amp; Imap)  template void readgridncsize&lt; StaticForcingP&lt; float &gt; &gt; (StaticForcingP&lt; float &gt; &amp; Imap)  template void readgridncsize&lt; StaticForcingP&lt; int &gt; &gt; (StaticForcingP&lt; int &gt; &amp; Imap)  template void readgridncsize&lt; deformmap&lt; float &gt; &gt; (deformmap&lt; float &gt; &amp; Imap)  template void readgridncsize&lt; forcingmap &gt; (forcingmap &amp; Imap)  template void readgridncsize&lt; inputmap &gt; (inputmap &amp; Imap)  int readncslev1 (std::string filename, std::string varstr, size_t indx, size_t indy, size_t indt, bool checkhh, double eps, T *&amp; zsa) Read a single level of data from a NetCDF file. template int readncslev1&lt; double &gt; (std::string filename, std::string varstr, size_t indx, size_t indy, size_t indt, bool checkhh, double eps, double *&amp; zsa)  template int readncslev1&lt; float &gt; (std::string filename, std::string varstr, size_t indx, size_t indy, size_t indt, bool checkhh, double eps, float *&amp; zsa)  int readnctime (std::string filename, double *&amp; time) Read time variable from a NetCDF file. int readnctime2 (int ncid, char * timecoordname, std::string refdate, size_t nt, double *&amp; time) Read time variable from a NetCDF file with reference date. void readnczb (int nx, int ny, std::string ncfile, float *&amp; zb)  int readvardata (std::string filename, std::string Varname, int step, T *&amp; vardata, bool flipx, bool flipy) Read variable data from a NetCDF file for a specific time step. template int readvardata&lt; double &gt; (std::string filename, std::string Varname, int step, double *&amp; vardata, bool flipx, bool flipy)  template int readvardata&lt; float &gt; (std::string filename, std::string Varname, int step, float *&amp; vardata, bool flipx, bool flipy)  template int readvardata&lt; int &gt; (std::string filename, std::string Varname, int step, int *&amp; vardata, bool flipx, bool flipy)  int readvarinfo (std::string filename, std::string Varname, size_t *&amp; ddimU) Read variable dimension info from a NetCDF file."},{"location":"BGFlood/_read__netcdf_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_read__netcdf_8cu/#function-checkncvarname","title":"function checkncvarname","text":"<p>Check for the existence of NetCDF variable names and return the first found. </p><pre><code>std::string checkncvarname (\n    int ncid,\n    std::string stringA,\n    std::string stringB,\n    std::string stringC,\n    std::string stringD,\n    std::string stringE\n) \n</code></pre> <p>Checks up to five possible variable names in a NetCDF file and returns the first one that exists.</p> <p>Parameters:</p> <ul> <li><code>ncid</code> NetCDF file ID </li> <li><code>stringA</code> First variable name to check </li> <li><code>stringB</code> Second variable name to check </li> <li><code>stringC</code> Third variable name to check </li> <li><code>stringD</code> Fourth variable name to check </li> <li><code>stringE</code> Fifth variable name to check </li> </ul> <p>Returns:</p> <p>The first variable name found in the NetCDF file, or an empty string if none are found. </p>"},{"location":"BGFlood/_read__netcdf_8cu/#function-nc_get_var1_t","title":"function nc_get_var1_T","text":"<pre><code>inline int nc_get_var1_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    float * zsa\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-nc_get_var1_t_1","title":"function nc_get_var1_T","text":"<pre><code>inline int nc_get_var1_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    double * zsa\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-nc_get_var_t","title":"function nc_get_var_T","text":"<pre><code>inline int nc_get_var_T (\n    int ncid,\n    int varid,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-nc_get_var_t_1","title":"function nc_get_var_T","text":"<pre><code>inline int nc_get_var_T (\n    int ncid,\n    int varid,\n    double *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-nc_get_var_t_2","title":"function nc_get_var_T","text":"<pre><code>inline int nc_get_var_T (\n    int ncid,\n    int varid,\n    int *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-nc_get_vara_t","title":"function nc_get_vara_T","text":"<pre><code>inline int nc_get_vara_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    const size_t * countp,\n    int *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-nc_get_vara_t_1","title":"function nc_get_vara_T","text":"<pre><code>inline int nc_get_vara_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    const size_t * countp,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-nc_get_vara_t_2","title":"function nc_get_vara_T","text":"<pre><code>inline int nc_get_vara_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    const size_t * countp,\n    double *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-read2dnc","title":"function read2Dnc","text":"<pre><code>void read2Dnc (\n    int nx,\n    int ny,\n    char ncfile,\n    float *&amp; hh\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-read3dnc","title":"function read3Dnc","text":"<pre><code>void read3Dnc (\n    int nx,\n    int ny,\n    int ntheta,\n    char ncfile,\n    float *&amp; ee\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readatmstep","title":"function readATMstep","text":"<p>Read atmospheric pressure data from NetCDF file for a specific time step. </p><pre><code>void readATMstep (\n    forcingmap ATMPmap,\n    int steptoread,\n    float *&amp; Po\n) \n</code></pre> <p>Reads atmospheric pressure data from a NetCDF file for a given time step. Atm pressure is same as wind we only read floats and that is plenty for real world application.</p> <p>Parameters:</p> <ul> <li><code>ATMPmap</code> Forcing map for atmospheric pressure </li> <li><code>steptoread</code> Time step to read </li> <li><code>Po</code> Output array for pressure data </li> </ul>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readwndstep","title":"function readWNDstep","text":"<p>Read wind data from NetCDF files for a specific time step. </p><pre><code>void readWNDstep (\n    forcingmap WNDUmap,\n    forcingmap WNDVmap,\n    int steptoread,\n    float *&amp; Uo,\n    float *&amp; Vo\n) \n</code></pre> <p>Reads U and V wind components from NetCDF files for a given time step. By default we want to read wind info as float because it will reside in a texture. the value is converted to the apropriate type only when it is used. so there is no need to template this function</p> <p>Parameters:</p> <ul> <li><code>WNDUmap</code> Forcing map for U wind </li> <li><code>WNDVmap</code> Forcing map for V wind </li> <li><code>steptoread</code> Time step to read </li> <li><code>Uo</code> Output array for U wind </li> <li><code>Vo</code> Output array for V wind </li> </ul>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readgridncsize","title":"function readgridncsize","text":"<p>Read grid size and metadata from a NetCDF file. </p><pre><code>void readgridncsize (\n    const std::string ncfilestr,\n    const std::string varstr,\n    std::string reftime,\n    int &amp; nx,\n    int &amp; ny,\n    int &amp; nt,\n    double &amp; dx,\n    double &amp; dy,\n    double &amp; dt,\n    double &amp; xo,\n    double &amp; yo,\n    double &amp; to,\n    double &amp; xmax,\n    double &amp; ymax,\n    double &amp; tmax,\n    bool &amp; flipx,\n    bool &amp; flipy\n) \n</code></pre> <p>Reads dimensions, coordinates, and time information for a variable in a NetCDF file.</p> <p>Parameters:</p> <ul> <li><code>ncfilestr</code> NetCDF filename </li> <li><code>varstr</code> Variable name </li> <li><code>reftime</code> Reference time string </li> <li><code>nx</code> Number of x grid points </li> <li><code>ny</code> Number of y grid points </li> <li><code>nt</code> Number of time steps </li> <li><code>dx</code> Grid spacing in x </li> <li><code>dy</code> Grid spacing in y </li> <li><code>dt</code> Time step size </li> <li><code>xo</code> Origin x </li> <li><code>yo</code> Origin y </li> <li><code>to</code> Origin time </li> <li><code>xmax</code> Maximum x </li> <li><code>ymax</code> Maximum y </li> <li><code>tmax</code> Maximum time </li> <li><code>flipx</code> Flip x axis </li> <li><code>flipy</code> Flip y axis </li> </ul>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readgridncsize_1","title":"function readgridncsize","text":"<p>Read grid size and metadata for a forcing map. </p><pre><code>void readgridncsize (\n    forcingmap &amp; Fmap,\n    Param XParam\n) \n</code></pre> <p>Reads grid size and metadata for a forcing map using model parameters.</p> <p>Parameters:</p> <ul> <li><code>Fmap</code> Forcing map structure </li> <li><code>XParam</code> Model parameters </li> </ul>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readgridncsize_2","title":"function readgridncsize","text":"<p>Read grid size and metadata for a generic map type. </p><pre><code>template&lt;class T&gt;\nvoid readgridncsize (\n    T &amp; Imap\n) \n</code></pre> <p>Reads grid size and metadata for a generic map type (inputmap, forcingmap, etc.).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Map type </li> </ul> <p>Parameters:</p> <ul> <li><code>Imap</code> Map structure </li> </ul>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readgridncsize-dynforcingp-float","title":"function readgridncsize&lt; DynForcingP&lt; float &gt; &gt;","text":"<pre><code>template void readgridncsize&lt; DynForcingP&lt; float &gt; &gt; (\n    DynForcingP &lt; float &gt; &amp; Imap\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readgridncsize-staticforcingp-float","title":"function readgridncsize&lt; StaticForcingP&lt; float &gt; &gt;","text":"<pre><code>template void readgridncsize&lt; StaticForcingP&lt; float &gt; &gt; (\n    StaticForcingP &lt; float &gt; &amp; Imap\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readgridncsize-staticforcingp-int","title":"function readgridncsize&lt; StaticForcingP&lt; int &gt; &gt;","text":"<pre><code>template void readgridncsize&lt; StaticForcingP&lt; int &gt; &gt; (\n    StaticForcingP &lt; int &gt; &amp; Imap\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readgridncsize-deformmap-float","title":"function readgridncsize&lt; deformmap&lt; float &gt; &gt;","text":"<pre><code>template void readgridncsize&lt; deformmap&lt; float &gt; &gt; (\n    deformmap &lt; float &gt; &amp; Imap\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readgridncsize-forcingmap","title":"function readgridncsize&lt; forcingmap &gt;","text":"<pre><code>template void readgridncsize&lt; forcingmap &gt; (\n    forcingmap &amp; Imap\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readgridncsize-inputmap","title":"function readgridncsize&lt; inputmap &gt;","text":"<pre><code>template void readgridncsize&lt; inputmap &gt; (\n    inputmap &amp; Imap\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readncslev1","title":"function readncslev1","text":"<p>Read a single level of data from a NetCDF file. </p><pre><code>template&lt;class T&gt;\nint readncslev1 (\n    std::string filename,\n    std::string varstr,\n    size_t indx,\n    size_t indy,\n    size_t indt,\n    bool checkhh,\n    double eps,\n    T *&amp; zsa\n) \n</code></pre> <p>Reads a single level of data for a variable from a NetCDF file.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>filename</code> NetCDF filename </li> <li><code>varstr</code> Variable name </li> <li><code>indx</code> X index </li> <li><code>indy</code> Y index </li> <li><code>indt</code> Time index </li> <li><code>checkhh</code> Check for missing values </li> <li><code>eps</code> Epsilon for missing value detection </li> <li><code>zsa</code> Output array for data </li> </ul> <p>Returns:</p> <p>Status code </p>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readncslev1-double","title":"function readncslev1&lt; double &gt;","text":"<pre><code>template int readncslev1&lt; double &gt; (\n    std::string filename,\n    std::string varstr,\n    size_t indx,\n    size_t indy,\n    size_t indt,\n    bool checkhh,\n    double eps,\n    double *&amp; zsa\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readncslev1-float","title":"function readncslev1&lt; float &gt;","text":"<pre><code>template int readncslev1&lt; float &gt; (\n    std::string filename,\n    std::string varstr,\n    size_t indx,\n    size_t indy,\n    size_t indt,\n    bool checkhh,\n    double eps,\n    float *&amp; zsa\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readnctime","title":"function readnctime","text":"<p>Read time variable from a NetCDF file. </p><pre><code>int readnctime (\n    std::string filename,\n    double *&amp; time\n) \n</code></pre> <p>Reads the time variable from a NetCDF file into a double array.</p> <p>Parameters:</p> <ul> <li><code>filename</code> NetCDF filename </li> <li><code>time</code> Output array for time values </li> </ul> <p>Returns:</p> <p>Status code </p>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readnctime2","title":"function readnctime2","text":"<p>Read time variable from a NetCDF file with reference date. </p><pre><code>int readnctime2 (\n    int ncid,\n    char * timecoordname,\n    std::string refdate,\n    size_t nt,\n    double *&amp; time\n) \n</code></pre> <p>Reads the time variable from a NetCDF file using a reference date and time coordinate name.</p> <p>Parameters:</p> <ul> <li><code>ncid</code> NetCDF file ID </li> <li><code>timecoordname</code> Time coordinate variable name </li> <li><code>refdate</code> Reference date string </li> <li><code>nt</code> Number of time steps </li> <li><code>time</code> Output array for time values </li> </ul> <p>Returns:</p> <p>Status code </p>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readnczb","title":"function readnczb","text":"<pre><code>void readnczb (\n    int nx,\n    int ny,\n    std::string ncfile,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readvardata","title":"function readvardata","text":"<p>Read variable data from a NetCDF file for a specific time step. </p><pre><code>template&lt;class T&gt;\nint readvardata (\n    std::string filename,\n    std::string Varname,\n    int step,\n    T *&amp; vardata,\n    bool flipx,\n    bool flipy\n) \n</code></pre> <p>Reads data for a variable from a NetCDF file for a given time step, with optional axis flipping.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>filename</code> NetCDF filename </li> <li><code>Varname</code> Variable name </li> <li><code>step</code> Time step to read </li> <li><code>vardata</code> Output array for data </li> <li><code>flipx</code> Flip x axis </li> <li><code>flipy</code> Flip y axis </li> </ul> <p>Returns:</p> <p>Status code </p>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readvardata-double","title":"function readvardata&lt; double &gt;","text":"<pre><code>template int readvardata&lt; double &gt; (\n    std::string filename,\n    std::string Varname,\n    int step,\n    double *&amp; vardata,\n    bool flipx,\n    bool flipy\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readvardata-float","title":"function readvardata&lt; float &gt;","text":"<pre><code>template int readvardata&lt; float &gt; (\n    std::string filename,\n    std::string Varname,\n    int step,\n    float *&amp; vardata,\n    bool flipx,\n    bool flipy\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readvardata-int","title":"function readvardata&lt; int &gt;","text":"<pre><code>template int readvardata&lt; int &gt; (\n    std::string filename,\n    std::string Varname,\n    int step,\n    int *&amp; vardata,\n    bool flipx,\n    bool flipy\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8cu/#function-readvarinfo","title":"function readvarinfo","text":"<p>Read variable dimension info from a NetCDF file. </p><pre><code>int readvarinfo (\n    std::string filename,\n    std::string Varname,\n    size_t *&amp; ddimU\n) \n</code></pre> <p>Reads the dimensions for a variable in a NetCDF file.</p> <p>Parameters:</p> <ul> <li><code>filename</code> NetCDF filename </li> <li><code>Varname</code> Variable name </li> <li><code>ddimU</code> Output array for dimension sizes </li> </ul> <p>Returns:</p> <p>Number of dimensions </p> <p>The documentation for this class was generated from the following file <code>src/Read_netcdf.cu</code></p>"},{"location":"BGFlood/_read__netcdf_8cu_source/","title":"File Read_netcdf.cu","text":""},{"location":"BGFlood/_read__netcdf_8cu_source/#file-read_netcdfcu","title":"File Read_netcdf.cu","text":"<p>File List &gt; src &gt; Read_netcdf.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //\n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n#include \"Read_netcdf.h\"\n\n\n\n\n\ninline int nc_get_var_T(int ncid, int varid, float * &amp;zb)\n{\n    int status;\n    status = nc_get_var_float(ncid, varid, zb);\n    return status;\n}\ninline int nc_get_var_T(int ncid, int varid, double * &amp;zb)\n{\n    int status;\n    status = nc_get_var_double(ncid, varid, zb);\n    return status;\n}\ninline int nc_get_var_T(int ncid, int varid, int*&amp; zb)\n{\n    int status;\n    status = nc_get_var_int(ncid, varid, zb);\n    return status;\n}\n\ninline int nc_get_vara_T(int ncid, int varid, const size_t* startp, const size_t* countp, int*&amp; zb)\n{\n    int status;\n    status = nc_get_vara_int(ncid, varid, startp, countp, zb);\n    return status;\n\n}\ninline int nc_get_vara_T(int ncid, int varid, const size_t* startp, const size_t* countp, float * &amp;zb)\n{\n    int status;\n    status = nc_get_vara_float(ncid, varid, startp, countp, zb);\n    return status;\n\n}\ninline int nc_get_vara_T(int ncid, int varid, const size_t* startp, const size_t* countp, double * &amp;zb)\n{\n    int status;\n    status = nc_get_vara_double(ncid, varid, startp, countp, zb);\n    return status;\n\n}\n\ninline int nc_get_var1_T(int ncid, int varid, const size_t* startp, float * zsa)\n{\n    int status;\n    status = nc_get_var1_float(ncid, varid, startp, zsa);\n    return status;\n}\ninline int nc_get_var1_T(int ncid, int varid, const size_t* startp, double * zsa)\n{\n    int status;\n    status = nc_get_var1_double(ncid, varid, startp, zsa);\n    return status;\n}\n\n\n\n\n//void readgridncsize(const std::string ncfilestr, const std::string varstr, int &amp;nx, int &amp;ny, int &amp;nt, double &amp;dx, double &amp;xo, double &amp;yo, double &amp;to, double &amp;xmax, double &amp;ymax, double &amp;tmax, bool &amp; flipx, bool &amp; flipy)\n//void readgridncsize(forcingmap &amp;Fmap, Param XParam)\nvoid readgridncsize(const std::string ncfilestr, const std::string varstr, std::string reftime, int&amp; nx, int&amp; ny, int&amp; nt, double&amp; dx, double&amp; dy, double&amp; dt, double&amp; xo, double&amp; yo, double&amp; to, double&amp; xmax, double&amp; ymax, double&amp; tmax, bool&amp; flipx, bool&amp; flipy)\n{\n    //std::string ncfilestr = Fmap.inputfile;\n    //std::string varstr = Fmap.varname;\n\n    //int nx, ny, nt;\n    //double dx, dt, xo, xmax, yo, ymax, to, tmax;\n    //bool flipx, flipy;\n\n    //read the dimentions of grid, levels and time\n    int status;\n    int ncid, ndimshh, ndims;\n    double *xcoord, *ycoord;\n    int varid;\n\n    //int ndimsp, nvarsp, nattsp, unlimdimidp;\n\n    int dimids[NC_MAX_VAR_DIMS];   /* dimension IDs */\n    char coordname[NC_MAX_NAME + 1];\n    //char varname[NC_MAX_NAME + 1];\n    size_t  *ddimhh;\n\n\n    //Open NC file\n    //printf(\"Open file\\n\");\n    status = nc_open(ncfilestr.c_str(), NC_NOWRITE, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n    //printf(\" %s...\\n\", hhvar);\n    status = nc_inq_varid(ncid, varstr.c_str(), &amp;varid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n\n    status = nc_inq_varndims(ncid, varid, &amp;ndimshh);\n    if (status != NC_NOERR) handle_ncerror(status);\n    //printf(\"hhVar:%d dims\\n\", ndimshh);\n\n    status = nc_inq_vardimid(ncid, varid, dimids);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    ddimhh = (size_t *)malloc(ndimshh*sizeof(size_t));\n\n    //Read dimensions nx_u ny_u\n    for (int iddim = 0; iddim &lt; ndimshh; iddim++)\n    {\n        status = nc_inq_dimlen(ncid, dimids[iddim], &amp;ddimhh[iddim]);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        //printf(\"dim:%d=%d\\n\", iddim, ddimhh[iddim]);\n    }\n\n    if (ndimshh &gt; 2)\n    {\n        nt = (int) ddimhh[0];\n        ny = (int) ddimhh[1];\n        nx = (int) ddimhh[2];\n\n    }\n    else\n    {\n        nt = 0;\n        ny = (int) ddimhh[0];\n        nx = (int) ddimhh[1];\n    }\n\n    //allocate\n    xcoord = (double *)malloc(nx*ny*sizeof(double));\n    ycoord = (double *)malloc(nx*ny*sizeof(double));\n\n    //inquire variable name for x dimension\n    //aka x dim of hh\n    int ycovar, xcovar, tcovar;\n\n    if (ndimshh &gt; 2)\n    {\n        tcovar = dimids[0];\n        ycovar = dimids[1];\n        xcovar = dimids[2];\n    }\n    else\n    {\n        ycovar = dimids[0];\n        xcovar = dimids[1];\n    }\n\n    //ycoord\n    status = nc_inq_dimname(ncid, ycovar, coordname);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_inq_varid(ncid, coordname, &amp;varid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_inq_varndims(ncid, varid, &amp;ndims);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    if (ndims &lt; 2)\n    {\n        double * ytempvar;\n        ytempvar = (double *)malloc(ny*sizeof(double));\n        size_t start[] = { 0 };\n        size_t count[] = { (size_t)ny };\n        status = nc_get_vara_double(ncid, varid, start, count, ytempvar);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        for (int i = 0; i&lt;nx; i++)\n        {\n            for (int j = 0; j&lt;ny; j++)\n            {\n\n                ycoord[i + j*nx] = ytempvar[j];\n\n            }\n        }\n        free(ytempvar);\n    }\n    else\n    {\n        size_t start[] = { 0, 0 };\n        size_t count[] = { (size_t)ny, (size_t)nx };\n        status = nc_get_vara_double(ncid, varid, start, count, ycoord);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n    }\n    //xcoord\n    status = nc_inq_dimname(ncid, xcovar, coordname);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_inq_varid(ncid, coordname, &amp;varid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_inq_varndims(ncid, varid, &amp;ndims);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    if (ndims &lt; 2)\n    {\n        double * xtempvar;\n        xtempvar = (double *)malloc(nx*sizeof(double));\n        size_t start[] = { 0 };\n        size_t count[] = { (size_t)nx };\n        status = nc_get_vara_double(ncid, varid, start, count, xtempvar);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        for (int i = 0; i&lt;nx; i++)\n        {\n            for (int j = 0; j&lt;ny; j++)\n            {\n\n                xcoord[i + j*nx] = xtempvar[i];\n\n            }\n        }\n        free(xtempvar);\n    }\n    else\n    {\n        size_t start[] = { 0, 0 };\n        size_t count[] = { (size_t)ny, (size_t)nx };\n        status = nc_get_vara_double(ncid, varid, start, count, xcoord);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n    }\n\n    double dxx,ddy;\n    //check dx\n    dxx = abs(xcoord[nx - 1] - xcoord[0]) / (nx - 1.0);\n    ddy = abs(ycoord[(ny - 1) * nx]- ycoord[0]) / (ny - 1.0);\n    //log(\"xo=\" + std::to_string(xcoord[0])+\"; xmax=\"+ std::to_string(xcoord[nx - 1]) +\"; nx=\"+ std::to_string(nx) +\"; dxx=\" +std::to_string(dxx));\n    //dyy = (float) abs(ycoord[0] - ycoord[(ny - 1)*nx]) / (ny - 1);\n\n\n    //Read time dimension if any\n    if (nt &gt; 0)\n    {\n        //read dimension name\n        status = nc_inq_dimname(ncid, tcovar, coordname);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n\n\n\n        //inquire variable id\n        status = nc_inq_varid(ncid, coordname, &amp;varid);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n\n\n\n        // read the dimension of time variable // yes it should be == 1\n        status = nc_inq_varndims(ncid, varid, &amp;ndims);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        //allocate temporary array and read time vector\n        double * ttempvar;\n        ttempvar = (double *)malloc(nt * sizeof(double));\n        //size_t start[] = { 0 };\n        //size_t count[] = { (size_t)nt };\n        //status = nc_get_vara_double(ncid, varid, start, count, ttempvar);\n\n        status = readnctime2(ncid, coordname, reftime, nt, ttempvar);\n\n        to = ttempvar[0];\n        tmax= ttempvar[nt-1];\n        dt = ttempvar[1] - ttempvar[0];\n\n        free(ttempvar);\n    }\n    else\n    {\n        //this is a 2d file so assign dummy values\n        to = 0.0;\n        tmax = 0.0;\n    }\n\n    dx = dxx;\n    dy = ddy;\n\n    xo = utils::min(xcoord[0], xcoord[nx - 1]);\n    xmax = utils::max(xcoord[0], xcoord[nx - 1]);\n    yo = utils::min(ycoord[0], ycoord[(ny - 1) * nx]);\n    ymax = utils::max(ycoord[(ny - 1)*nx], ycoord[0]);\n\n\n    if (xcoord[0] &gt; xcoord[nx - 1])\n        flipx = true;\n\n    if (ycoord[0] &gt; ycoord[(ny - 1) * nx])\n        flipy = true;\n\n\n    status = nc_close(ncid);\n\n\n\n    free(ddimhh);\n    free(xcoord);\n    free(ycoord);\n\n\n}\n\n\nvoid readgridncsize(forcingmap&amp; Fmap, Param XParam)\n{\n\n    readgridncsize(Fmap.inputfile, Fmap.varname, XParam.reftime, Fmap.nx, Fmap.ny, Fmap.nt, Fmap.dx, Fmap.dy, Fmap.dt, Fmap.xo, Fmap.yo, Fmap.to, Fmap.xmax, Fmap.ymax, Fmap.tmax, Fmap.flipxx, Fmap.flipyy);\n}\n\n\ntemplate&lt;class T&gt; void readgridncsize(T&amp; Imap)\n{\n    double a, b, c;\n    int duma;\n    readgridncsize(Imap.inputfile, Imap.varname, \"2000-01-01T00:00:00\", Imap.nx, Imap.ny, duma, Imap.dx, Imap.dy, a, Imap.xo, Imap.yo, b, Imap.xmax, Imap.ymax, c, Imap.flipxx, Imap.flipyy);\n}\ntemplate void readgridncsize&lt;inputmap&gt;(inputmap &amp;Imap);\ntemplate void readgridncsize&lt;forcingmap&gt;(forcingmap &amp;Imap);\ntemplate void readgridncsize&lt;StaticForcingP&lt;int &gt;&gt;(StaticForcingP&lt;int&gt;&amp; Imap);\ntemplate void readgridncsize&lt;StaticForcingP&lt;float &gt;&gt;(StaticForcingP&lt;float&gt; &amp;Imap);\ntemplate void readgridncsize&lt;deformmap&lt;float &gt;&gt;(deformmap&lt;float &gt;&amp; Imap);\ntemplate void readgridncsize&lt;DynForcingP&lt;float &gt;&gt;(DynForcingP&lt;float &gt;&amp; Imap);\n\n\nint readvarinfo(std::string filename, std::string Varname, size_t *&amp;ddimU)\n{\n    // This function reads the dimensions for each variables\n    int status, varid;\n    int ncid, ndims;\n    int dimids[NC_MAX_VAR_DIMS];\n    //Open NC file\n    //printf(\"Open file\\n\");\n\n    status = nc_open(filename.c_str(), 0, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //inquire variable by name\n    //printf(\"Reading information about %s...\", Varname.c_str());\n    status = nc_inq_varid(ncid, Varname.c_str(), &amp;varid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_inq_varndims(ncid, varid, &amp;ndims);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n    status = nc_inq_vardimid(ncid, varid, dimids);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    ddimU = (size_t *)malloc(ndims*sizeof(size_t));\n\n    //Read dimensions nx_u ny_u\n    for (int iddim = 0; iddim &lt; ndims; iddim++)\n    {\n        status = nc_inq_dimlen(ncid, dimids[iddim], &amp;ddimU[iddim]);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        //printf(\"dim:%d=%d\\n\", iddim, ddimU[iddim]);\n    }\n\n\n    status = nc_close(ncid);\n\n    return ndims;\n}\n\n\nint readnctime(std::string filename, double * &amp;time)\n{\n    int status, ncid, varid;\n\n    std::string ncfilestr;\n    std::string varstr;\n\n\n    //char ncfile[]=\"ocean_ausnwsrstwq2.nc\";\n    std::vector&lt;std::string&gt; nameelements;\n\n    nameelements = split(filename, '?');\n    if (nameelements.size() &gt; 1)\n    {\n        //variable name for bathy is not given so it is assumed to be zb\n        ncfilestr = nameelements[0];\n        //varstr = nameelements[1];\n    }\n    else\n    {\n        ncfilestr = filename;\n        //varstr = \"time\";\n    }\n\n    // Warning this could be more robust by taking the unlimited dimention if time does not exist!\n    std::string Varname = \"time\";\n\n    status = nc_open(ncfilestr.c_str(), 0, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_inq_varid(ncid, Varname.c_str(), &amp;varid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_get_var_double(ncid, varid, time);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_close(ncid);\n\n    return status;\n}\n\nint readnctime2(int ncid,char * timecoordname,std::string refdate,size_t nt, double*&amp; time)\n{\n\n    int status, varid;\n\n    std::string ncfilestr;\n    std::string varstr;\n\n    double fac = 1.0;\n    double offset = 0.0;\n\n    //char ncfile[]=\"ocean_ausnwsrstwq2.nc\";\n\n\n    // Warning this could be more robust by taking the unlimited dimension if time does not exist!\n    //std::string Varname = \"time\";\n\n\n    status = nc_inq_varid(ncid, timecoordname, &amp;varid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    // inquire unit of time\n    int ncAttid;\n    size_t t_len;\n\n    char* tunit;\n\n    std::string tunitstr;\n\n    /* Get the attribute ID */\n    status = nc_inq_attid(ncid, varid, \"units\", &amp;ncAttid);\n    if (status == NC_NOERR)\n    {\n        /* Read units attribute length from the variable */\n        status = nc_inq_attlen(ncid, varid, \"units\", &amp;t_len);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        tunit = (char*)malloc(t_len + 1); // +1 to automatically have a null character at the end. Is this cross platform portable?\n\n        /* Read units attribute from the variable */\n        status = nc_get_att_text(ncid, varid, \"units\", tunit);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        // convert to string\n        tunitstr = std::string(tunit);\n\n        std::string ncstepunit= tunitstr;\n\n        if (tunitstr.find(\"since\") != std::string::npos)\n        {\n\n            // Try to make sense of the unit\n            // The word \"since\" should be in the center\n            // e.g. hour since 2000-01-01 00:00:00 \n            std::vector&lt;std::string&gt; nodeitems = split(tunitstr, \"since\");\n            ncstepunit = trim(nodeitems[0], \" \");\n            std::string ncrefdatestr = trim(nodeitems[1], \" \");\n\n            //time_t ncrefdate = date_string_to_time(ncrefdatestr);\n            offset = date_string_to_s(ncrefdatestr, refdate);\n        }\n\n        std::vector&lt;std::string&gt; secondvec = { \"seconds\",\"second\",\"sec\",\"s\" };\n        std::vector&lt;std::string&gt; minutevec = { \"minutes\",\"minute\",\"min\",\"m\" };\n        std::vector&lt;std::string&gt; hourvec = { \"hours\",\"hour\",\"hrs\",\"hr\",\"h\" };\n        std::vector&lt;std::string&gt; dayvec = { \"days\",\"day\",\"d\" };\n        std::vector&lt;std::string&gt; monthvec = { \"months\",\"month\",\"mths\", \"mth\", \"mon\" };\n        std::vector&lt;std::string&gt; yearvec = { \"years\",\"year\",\"yrs\", \"yr\", \"y\" };\n\n\n        std::size_t found;\n        found = case_insensitive_compare(ncstepunit, secondvec);\n        if (found == 0)\n            fac = 1.0;\n\n        found = case_insensitive_compare(ncstepunit, minutevec);\n        if (found == 0)\n            fac = 60.0;\n\n        found = case_insensitive_compare(ncstepunit, hourvec);\n        if (found == 0)\n            fac = 3600.0;\n\n        found = case_insensitive_compare(ncstepunit, dayvec);\n        if (found == 0)\n            fac = 3600.0*24.0;\n\n        found = case_insensitive_compare(ncstepunit, monthvec);\n        if (found == 0)\n            fac = 3600.0 * 24.0 * 30.4375;\n\n        found = case_insensitive_compare(ncstepunit, yearvec);\n        if (found == 0)\n            fac = 3600.0 * 24.0 * 365.25;\n\n\n    }\n\n    status = nc_get_var_double(ncid, varid, time);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    for (int it = 0; it &lt; nt; it++)\n    {\n        time[it] = time[it] * fac + offset;\n        //printf(\"%f\\n\", time[it]);\n    }\n\n\n    return status;\n\n}\n\ntemplate &lt;class T&gt; int readncslev1(std::string filename, std::string varstr, size_t indx, size_t indy, size_t indt, bool checkhh, double eps, T * &amp;zsa)\n{\n    int status, ncid, varid,ndims,sferr,oferr,misserr,fillerr, iderr;\n    double scalefac, offset, missing, fillval;\n\n    double hha,zza;\n\n    //bool checkhh = false;\n\n    int wet = 1;\n\n    size_t *start;\n    //std::string Varname = \"time\";\n    ndims = 3;\n\n    start = (size_t *)malloc(ndims*sizeof(size_t));\n    //count = (size_t *)malloc(ndims*sizeof(size_t));\n\n    start[0] = indt;\n    start[1] = indy;\n    start[2] = indx;\n\n    //std::string ncfilestr;\n    //std::string varstr;\n\n\n    //char ncfile[]=\"ocean_ausnwsrstwq2.nc\";\n    //std::vector&lt;std::string&gt; nameelements;\n\n    /*nameelements = split(filename, '?');\n    if (nameelements.size() &gt; 1)\n    {\n\n        ncfilestr = nameelements[0];\n        varstr = nameelements[1];\n    }\n    else\n    {\n\n        ncfilestr = filename;\n        varstr = \"zs\";\n        checkhh = true;\n    }*/\n\n    status = nc_open(filename.c_str(), 0, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_inq_varid(ncid, varstr.c_str(), &amp;varid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_get_var1_T(ncid, varid, start, zsa);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n\n    sferr = nc_get_att_double(ncid, varid, \"scale_factor\", &amp;scalefac);\n    oferr = nc_get_att_double(ncid, varid, \"add_offset\", &amp;offset);\n\n    // Check if variable is a missing value\n\n    misserr = nc_get_att_double(ncid, varid, \"_FillValue\", &amp;missing);\n\n    fillerr = nc_get_att_double(ncid, varid, \"missingvalue\", &amp;fillval);\n\n    if (misserr == NC_NOERR)\n    {\n        if (zsa[0] == missing)\n        {\n            zsa[0] = 0.0;\n            wet = 0;\n        }\n    }\n    if (fillerr == NC_NOERR)\n    {\n        if (zsa[0] == fillval)\n        {\n            zsa[0] = 0.0;\n            wet = 0;\n        }\n    }\n\n\n\n\n    if (sferr == NC_NOERR || oferr == NC_NOERR) // data must be packed\n    {\n        zsa[0] = zsa[0] * (T)scalefac + (T)offset;\n    }\n\n    if (checkhh)\n    {\n        zza = zsa[0];\n        iderr = nc_inq_varid(ncid, \"hh\", &amp;varid);\n        if (iderr == NC_NOERR)\n        {\n            if (typeid(T) == typeid(float))\n                status = nc_get_var1_T(ncid, varid, start, zsa);\n            if (typeid(T) == typeid(double))\n                status = nc_get_var1_T(ncid, varid, start, zsa);\n            //status = nc_get_var1_double(ncid, varid, start, zsa);\n            sferr = nc_get_att_double(ncid, varid, \"scale_factor\", &amp;scalefac);\n            oferr = nc_get_att_double(ncid, varid, \"add_offset\", &amp;offset);\n\n            // Check if variable is a missing value\n\n            misserr = nc_get_att_double(ncid, varid, \"_FillValue\", &amp;missing);\n\n            fillerr = nc_get_att_double(ncid, varid, \"missingvalue\", &amp;fillval);\n\n            if (misserr == NC_NOERR)\n            {\n                if (zsa[0] == missing)\n                {\n                    zsa[0] = 0.0;\n                    wet = 0;\n                }\n            }\n            if (fillerr == NC_NOERR)\n            {\n                if (zsa[0] == fillval)\n                {\n                    zsa[0] = 0.0;\n                    wet = 0;\n                }\n            }\n\n\n\n\n            if (sferr == NC_NOERR || oferr == NC_NOERR) // data must be packed\n            {\n                zsa[0] = zsa[0] * (T)scalefac + (T)offset;\n            }\n\n            hha = zsa[0];\n            if (hha &gt; eps)\n            {\n                zsa[0] = T(zza);\n            }\n            else\n            {\n                zsa[0] = T(0.0);\n                wet = 0;\n            }\n\n        }\n\n\n    }\n\n\n\n    status = nc_close(ncid);\n\n    free(start);\n    //free(count);\n\n\n    return wet;\n}\n\ntemplate int readncslev1&lt;float&gt;(std::string filename, std::string varstr, size_t indx, size_t indy, size_t indt, bool checkhh, double eps, float * &amp;zsa);\ntemplate int readncslev1&lt;double&gt;(std::string filename, std::string varstr, size_t indx, size_t indy, size_t indt, bool checkhh, double eps, double * &amp;zsa);\n\n\ntemplate &lt;class T&gt; int readvardata(std::string filename, std::string Varname, int step, T * &amp;vardata, bool flipx, bool flipy)\n{\n    // function to standardise the way to read netCDF data off a file\n    // The role of this function is to offload and simplify the rest of the code\n\n\n    int nx, ny, nt, status, ncid, varid, sferr, oferr, merr,ndims;\n    size_t * start, * count, *ddim;\n    double scalefac, offset, missing;\n\n\n\n\n\n    ndims = readvarinfo(filename, Varname, ddim);\n\n    start = (size_t *)malloc(ndims*sizeof(size_t));\n    count = (size_t *)malloc(ndims*sizeof(size_t));\n\n\n\n    //\n    status = nc_open(filename.c_str(), 0, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_inq_varid(ncid, Varname.c_str(), &amp;varid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    if (ndims == 1)\n    {\n        nx = (int)ddim[0];\n        start[0] = 0;\n        count[0] =  nx ;\n\n\n\n    }\n    else if (ndims == 2)\n    {\n        ny = (int)ddim[0];\n        nx = (int)ddim[1];\n        start[0] = 0;\n        start[1] = 0;\n\n        count[0] = ny;\n        count[1] = nx;\n\n\n\n\n    }\n    else //(ndim&gt;2)\n    {\n        nt = (int)ddim[0];\n        ny = (int)ddim[1];\n        nx = (int)ddim[2];\n        start[0] = size_t(utils::min(step, nt - 1));\n        start[1] = size_t(0);\n        start[2] = size_t(0);\n\n        count[0] = size_t(1);\n        count[1] = size_t(ny);\n        count[2] = size_t(nx);\n\n\n\n    }\n\n    //double* xo,xnd;\n\n\n    status = nc_get_vara_T(ncid, varid, start, count, vardata);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    if (ndims &gt; 1)\n    {\n\n        sferr = nc_get_att_double(ncid, varid, \"scale_factor\", &amp;scalefac);\n        oferr = nc_get_att_double(ncid, varid, \"add_offset\", &amp;offset);\n\n        merr = nc_get_att_double(ncid, varid, \"missingvalue\", &amp;missing);\n        if (merr != NC_NOERR)\n        {\n            merr = nc_get_att_double(ncid, varid, \"_FillValue\", &amp;missing);\n        }\n        if (merr != NC_NOERR)\n        {\n            merr = nc_get_att_double(ncid, varid, \"missing_value\", &amp;missing);\n        }\n\n        // remove fill value\n        if (merr == NC_NOERR)\n        {\n            //T maxval = T(-99999.0);\n            for (int j = 0; j &lt; ny; j++)\n            {\n                for (int i = 0; i &lt; nx; i++)\n                {\n                    bool test = missing != missing ? vardata[i + j * nx] != vardata[i + j * nx] : (abs(vardata[i + j * nx]) &gt; abs(T(0.9 * missing)));\n                    if (test) // i.e. if vardata is anywhere near missing\n                    {\n\n                        vardata[i + j * nx] = T(NAN);\n                    }\n                    //maxval = utils::max(maxval, vardata[i + j * nx]);\n                }\n            }\n            //printf(\"maxval = %f\\n\", float(maxval));\n        }\n\n        if (flipx)\n        {\n            T* xdata;\n            xdata=(T*)malloc(nx * sizeof(T));\n            for (int j = 0; j &lt; ny; j++)\n            {\n                for (int i = 0; i &lt; nx; i++)\n                {\n                    xdata[i] = vardata[i + j * nx];\n                    //unpacked_value = packed_value * scale_factor + add_offset\n\n                }\n                for (int i = 0; i &lt; nx; i++)\n                {\n                    vardata[i + j * nx] = xdata[nx - 1 - i];\n                    //unpacked_value = packed_value * scale_factor + add_offset\n\n                }\n            }\n            free(xdata);\n        }\n\n        if (flipy)\n        {\n            T* ydata;\n            ydata = (T*)malloc(ny * sizeof(T));\n            for (int i = 0; i &lt; nx; i++)\n            {\n                for (int j = 0; j &lt; ny; j++)\n                {\n                    ydata[j] = vardata[i + j * nx];\n                    //unpacked_value = packed_value * scale_factor + add_offset\n\n                }\n                for (int j = 0; j &lt; ny; j++)\n                {\n                    vardata[i + j * nx] = ydata[ny - 1 - j];\n                    //unpacked_value = packed_value * scale_factor + add_offset\n\n                }\n            }\n            free(ydata);\n        }\n\n\n\n        // apply scale and offset\n        if (sferr == NC_NOERR || oferr == NC_NOERR) // data must be packed\n        {\n            for (int j = 0; j &lt; ny; j++)\n            {\n                for (int i = 0; i &lt; nx; i++)\n                {\n                    vardata[i + j * nx] = vardata[i + j * nx] * (T)scalefac + (T)offset;\n                    //unpacked_value = packed_value * scale_factor + add_offset\n\n                }\n            }\n        }\n    }\n\n\n\n    //clean up\n    free(start);\n    free(count);\n\n    status = nc_close(ncid);\n\n    return status;\n\n}\ntemplate int readvardata&lt;int&gt;(std::string filename, std::string Varname, int step, int*&amp; vardata, bool flipx, bool flipy);\ntemplate int readvardata&lt;float&gt;(std::string filename, std::string Varname, int step, float * &amp;vardata, bool flipx, bool flipy);\ntemplate int readvardata&lt;double&gt;(std::string filename, std::string Varname, int step, double * &amp;vardata, bool flipx, bool flipy);\n\n\n\nstd::string checkncvarname(int ncid, std::string stringA, std::string stringB, std::string stringC, std::string stringD, std::string stringE)\n{\n    int varid;\n    int errorA, errorB,errorC,errorD,errorE;\n    std::string outstring;\n\n    //std::vector&lt;std::string&gt; teststr;\n\n    //teststr.push_back((stringA))\n\n\n    errorA = nc_inq_varid(ncid, stringA.c_str(), &amp;varid);\n    errorB = nc_inq_varid(ncid, stringB.c_str(), &amp;varid);\n    errorC = nc_inq_varid(ncid, stringC.c_str(), &amp;varid);\n    errorD = nc_inq_varid(ncid, stringD.c_str(), &amp;varid);\n    errorE = nc_inq_varid(ncid, stringE.c_str(), &amp;varid);\n\n\n    if (errorA == NC_NOERR)\n    {\n        outstring = stringA;\n    }\n    else if (errorB == NC_NOERR)\n    {\n        outstring = stringB;\n    }\n    else if (errorC == NC_NOERR)\n    {\n        outstring = stringC;\n    }\n    else if (errorD == NC_NOERR)\n    {\n        outstring = stringD;\n    }\n    else if (errorE == NC_NOERR)\n    {\n        outstring = stringE;\n    }\n\n    return outstring;\n\n\n}\n\n//By default we want to read wind info as float because it will reside in a texture. the value is converted to the apropriate type only when it is used. so there is no need to template this function \nvoid readWNDstep(forcingmap WNDUmap, forcingmap WNDVmap, int steptoread, float *&amp;Uo, float *&amp;Vo)\n{\n    //\n    int status;\n    int ncid;\n    //float NanValU = -9999, NanValV = -9999, NanValH = -9999;\n    int uu_id, vv_id;\n    // step to read should be adjusted in each variables so that it keeps using the last output and teh model keeps on going\n    // right now the model will catch anexception\n    printf(\"Reading Wind data step: %d ...\", steptoread);\n    //size_t startl[]={hdstep-1,lev,0,0};\n    //size_t countlu[]={1,1,netau,nxiu};\n    //size_t countlv[]={1,1,netav,nxiv};\n    size_t startl[] = { (size_t)steptoread, 0, 0 };\n    size_t countlu[] = { 1, (size_t)WNDUmap.ny, (size_t)WNDUmap.nx };\n    size_t countlv[] = { 1, (size_t)WNDVmap.ny, (size_t)WNDVmap.nx };\n\n    //static ptrdiff_t stridel[]={1,1,1,1};\n    //static ptrdiff_t stridel[] = { 1, 1, 1 };\n\n    std::string ncfilestrU, ncfilestrV;\n    std::string Uvarstr, Vvarstr;\n\n\n    //char ncfile[]=\"ocean_ausnwsrstwq2.nc\";\n    std::vector&lt;std::string&gt; nameelements;\n    //by default we expect tab delimitation\n    nameelements = split(WNDUmap.inputfile, '?');\n    if (nameelements.size() &gt; 1)\n    {\n        //variable name for bathy is not given so it is assumed to be zb\n        ncfilestrU = nameelements[0];\n        Uvarstr = nameelements[1];\n    }\n    else\n    {\n        ncfilestrU = WNDUmap.inputfile;\n        Uvarstr = \"uwnd\";\n    }\n\n    nameelements = split(WNDVmap.inputfile, '?');\n    if (nameelements.size() &gt; 1)\n    {\n        //variable name for bathy is not given so it is assumed to be zb\n        ncfilestrV = nameelements[0];\n        Vvarstr = nameelements[1];\n    }\n    else\n    {\n        ncfilestrV = WNDVmap.inputfile;\n        Vvarstr = \"vwnd\";\n    }\n\n\n    //Open NC file\n\n    status = nc_open(ncfilestrU.c_str(), 0, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //status = nc_inq_varid (ncid, \"u\", &amp;uu_id);\n    status = nc_inq_varid(ncid, Uvarstr.c_str(), &amp;uu_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_get_vara_float(ncid, uu_id, startl, countlu, Uo);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //status = nc_get_att_float(ncid, uu_id, \"_FillValue\", &amp;NanValU);\n    //if (status != NC_NOERR) handle_error(status);\n\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_open(ncfilestrV.c_str(), 0, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    //status = nc_inq_varid (ncid, \"v\", &amp;vv_id);\n    status = nc_inq_varid(ncid, Vvarstr.c_str(), &amp;vv_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_get_vara_float(ncid, vv_id, startl, countlv, Vo);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //status = nc_get_att_float(ncid, vv_id, \"_FillValue\", &amp;NanValV);\n    //if (status != NC_NOERR) handle_error(status);\n\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    printf(\"Done!\\n\");\n\n}\n\n//Atm pressure is same as wind we only read floats and that is plenty for real world application\nvoid readATMstep(forcingmap ATMPmap, int steptoread, float *&amp;Po)\n{\n    //\n    int status;\n    int ncid;\n    //float NanValU = -9999, NanValV = -9999, NanValH = -9999;\n    int uu_id;\n    // step to read should be adjusted in each variables so that it keeps using the last output and teh model keeps on going\n    // right now the model will catch anexception\n    printf(\"Reading atm pressure data. step: %d ...\", steptoread);\n    //size_t startl[]={hdstep-1,lev,0,0};\n    //size_t countlu[]={1,1,netau,nxiu};\n    //size_t countlv[]={1,1,netav,nxiv};\n    size_t startl[] = { (size_t)steptoread, 0, 0 };\n    size_t countlu[] = { 1, (size_t)ATMPmap.ny, (size_t)ATMPmap.nx };\n    //size_t countlv[] = { 1, WNDVmap.ny, WNDVmap.nx };\n\n    //static ptrdiff_t stridel[]={1,1,1,1};\n    //static ptrdiff_t stridel[] = { 1, 1, 1 };\n\n    std::string ncfilestr;\n    std::string atmpvarstr;\n\n\n    //char ncfile[]=\"ocean_ausnwsrstwq2.nc\";\n    std::vector&lt;std::string&gt; nameelements;\n    //by default we expect tab delimitation\n    nameelements = split(ATMPmap.inputfile, '?');\n    if (nameelements.size() &gt; 1)\n    {\n        //variable name for bathy is not given so it is assumed to be zb\n        ncfilestr = nameelements[0];\n        atmpvarstr = nameelements[1];\n    }\n    else\n    {\n        ncfilestr = ATMPmap.inputfile;\n        atmpvarstr = \"atmP\";\n    }\n\n\n    //Open NC file\n\n    status = nc_open(ncfilestr.c_str(), 0, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //status = nc_inq_varid (ncid, \"u\", &amp;uu_id);\n    status = nc_inq_varid(ncid, atmpvarstr.c_str(), &amp;uu_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_get_vara_float(ncid, uu_id, startl, countlu, Po);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //status = nc_get_att_float(ncid, uu_id, \"_FillValue\", &amp;NanValU);\n    //if (status != NC_NOERR) handle_error(status);\n\n    status = nc_close(ncid);\n\n    printf(\"Done!\\n\");\n\n}\n\n// The following functions are simple tools to create 2D or 3D netcdf files (for testing for example)\n\nextern \"C\" void read3Dnc(int nx, int ny, int ntheta, char ncfile[], float * &amp;ee)\n{\n    int status;\n    int ncid, ee_id;\n    //static size_t count[] = { nx, ny,ntheta };\n    status = nc_open(ncfile, NC_NOWRITE, &amp;ncid);\n    status = nc_inq_varid(ncid, \"z\", &amp;ee_id);\n    status = nc_get_var_float(ncid, ee_id, ee);\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n}\n\nextern \"C\" void read2Dnc(int nx, int ny, char ncfile[], float * &amp;hh)\n{\n    int status;\n    int ncid, hh_id;\n    //static size_t count[] = { nx, ny };\n    status = nc_open(ncfile, NC_NOWRITE, &amp;ncid);\n    status = nc_inq_varid(ncid, \"hh\", &amp;hh_id);\n    status = nc_get_var_float(ncid, hh_id, hh);\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n}\n\nextern \"C\" void readnczb(int nx, int ny, std::string ncfile, float * &amp;zb)\n{\n    int status;\n    int ncid, hh_id;\n    //static size_t count[] = { nx, ny };\n\n    status = nc_open(ncfile.c_str(), NC_NOWRITE, &amp;ncid);\n    status = nc_inq_varid(ncid, \"zb\", &amp;hh_id);\n    status = nc_get_var_float(ncid, hh_id, zb);\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n}\n</code></pre>"},{"location":"BGFlood/_read__netcdf_8h/","title":"File Read_netcdf.h","text":""},{"location":"BGFlood/_read__netcdf_8h/#file-read_netcdfh","title":"File Read_netcdf.h","text":"<p>FileList &gt; src &gt; Read_netcdf.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Input.h\"</code></li> <li><code>#include \"ReadInput.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"Write_netcdf.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"GridManip.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"utctime.h\"</code></li> </ul>"},{"location":"BGFlood/_read__netcdf_8h/#public-functions","title":"Public Functions","text":"Type Name std::string checkncvarname (int ncid, std::string stringA, std::string stringB, std::string stringC, std::string stringD, std::string stringE) Check for the existence of NetCDF variable names and return the first found. int nc_get_var1_T (int ncid, int varid, const size_t * startp, float * zsa)  int nc_get_var1_T (int ncid, int varid, const size_t * startp, double * zsa)  int nc_get_var_T (int ncid, int varid, float *&amp; zb)  int nc_get_var_T (int ncid, int varid, double *&amp; zb)  int nc_get_vara_T (int ncid, int varid, const size_t * startp, const size_t * countp, float *&amp; zb)  int nc_get_vara_T (int ncid, int varid, const size_t * startp, const size_t * countp, double *&amp; zb)  void read2Dnc (int nx, int ny, char ncfile, float *&amp; hh)  void read3Dnc (int nx, int ny, int ntheta, char ncfile, float *&amp; ee)  void readATMstep (forcingmap ATMPmap, int steptoread, float *&amp; Po) Read atmospheric pressure data from NetCDF file for a specific time step. void readWNDstep (forcingmap WNDUmap, forcingmap WNDVmap, int steptoread, float *&amp; Uo, float *&amp; Vo) Read wind data from NetCDF files for a specific time step. void readgridncsize (const std::string ncfilestr, const std::string varstr, std::string reftime, int &amp; nx, int &amp; ny, int &amp; nt, double &amp; dx, double &amp; dy, double &amp; dt, double &amp; xo, double &amp; yo, double &amp; to, double &amp; xmax, double &amp; ymax, double &amp; tmax, bool &amp; flipx, bool &amp; flipy) Read grid size and metadata from a NetCDF file. void readgridncsize (forcingmap &amp; Fmap, Param XParam) Read grid size and metadata for a forcing map. void readgridncsize (T &amp; Imap) Read grid size and metadata for a generic map type. int readncslev1 (std::string filename, std::string varstr, size_t indx, size_t indy, size_t indt, bool checkhh, double eps, T *&amp; zsa) Read a single level of data from a NetCDF file. int readnctime (std::string filename, double *&amp; time) Read time variable from a NetCDF file. int readnctime2 (int ncid, char * timecoordname, std::string refdate, size_t nt, double *&amp; time) Read time variable from a NetCDF file with reference date. void readnczb (int nx, int ny, std::string ncfile, float *&amp; zb)  int readvardata (std::string filename, std::string Varname, int step, T *&amp; vardata, bool flipx, bool flipy) Read variable data from a NetCDF file for a specific time step. int readvarinfo (std::string filename, std::string Varname, size_t *&amp; ddimU) Read variable dimension info from a NetCDF file."},{"location":"BGFlood/_read__netcdf_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_read__netcdf_8h/#function-checkncvarname","title":"function checkncvarname","text":"<p>Check for the existence of NetCDF variable names and return the first found. </p><pre><code>std::string checkncvarname (\n    int ncid,\n    std::string stringA,\n    std::string stringB,\n    std::string stringC,\n    std::string stringD,\n    std::string stringE\n) \n</code></pre> <p>Checks up to five possible variable names in a NetCDF file and returns the first one that exists.</p> <p>Parameters:</p> <ul> <li><code>ncid</code> NetCDF file ID </li> <li><code>stringA</code> First variable name to check </li> <li><code>stringB</code> Second variable name to check </li> <li><code>stringC</code> Third variable name to check </li> <li><code>stringD</code> Fourth variable name to check </li> <li><code>stringE</code> Fifth variable name to check </li> </ul> <p>Returns:</p> <p>The first variable name found in the NetCDF file, or an empty string if none are found. </p>"},{"location":"BGFlood/_read__netcdf_8h/#function-nc_get_var1_t","title":"function nc_get_var1_T","text":"<pre><code>inline int nc_get_var1_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    float * zsa\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8h/#function-nc_get_var1_t_1","title":"function nc_get_var1_T","text":"<pre><code>inline int nc_get_var1_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    double * zsa\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8h/#function-nc_get_var_t","title":"function nc_get_var_T","text":"<pre><code>inline int nc_get_var_T (\n    int ncid,\n    int varid,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8h/#function-nc_get_var_t_1","title":"function nc_get_var_T","text":"<pre><code>inline int nc_get_var_T (\n    int ncid,\n    int varid,\n    double *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8h/#function-nc_get_vara_t","title":"function nc_get_vara_T","text":"<pre><code>inline int nc_get_vara_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    const size_t * countp,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8h/#function-nc_get_vara_t_1","title":"function nc_get_vara_T","text":"<pre><code>inline int nc_get_vara_T (\n    int ncid,\n    int varid,\n    const size_t * startp,\n    const size_t * countp,\n    double *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8h/#function-read2dnc","title":"function read2Dnc","text":"<pre><code>void read2Dnc (\n    int nx,\n    int ny,\n    char ncfile,\n    float *&amp; hh\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8h/#function-read3dnc","title":"function read3Dnc","text":"<pre><code>void read3Dnc (\n    int nx,\n    int ny,\n    int ntheta,\n    char ncfile,\n    float *&amp; ee\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8h/#function-readatmstep","title":"function readATMstep","text":"<p>Read atmospheric pressure data from NetCDF file for a specific time step. </p><pre><code>void readATMstep (\n    forcingmap ATMPmap,\n    int steptoread,\n    float *&amp; Po\n) \n</code></pre> <p>Reads atmospheric pressure data from a NetCDF file for a given time step. Atm pressure is same as wind we only read floats and that is plenty for real world application.</p> <p>Parameters:</p> <ul> <li><code>ATMPmap</code> Forcing map for atmospheric pressure </li> <li><code>steptoread</code> Time step to read </li> <li><code>Po</code> Output array for pressure data </li> </ul>"},{"location":"BGFlood/_read__netcdf_8h/#function-readwndstep","title":"function readWNDstep","text":"<p>Read wind data from NetCDF files for a specific time step. </p><pre><code>void readWNDstep (\n    forcingmap WNDUmap,\n    forcingmap WNDVmap,\n    int steptoread,\n    float *&amp; Uo,\n    float *&amp; Vo\n) \n</code></pre> <p>Reads U and V wind components from NetCDF files for a given time step. By default we want to read wind info as float because it will reside in a texture. the value is converted to the apropriate type only when it is used. so there is no need to template this function</p> <p>Parameters:</p> <ul> <li><code>WNDUmap</code> Forcing map for U wind </li> <li><code>WNDVmap</code> Forcing map for V wind </li> <li><code>steptoread</code> Time step to read </li> <li><code>Uo</code> Output array for U wind </li> <li><code>Vo</code> Output array for V wind </li> </ul>"},{"location":"BGFlood/_read__netcdf_8h/#function-readgridncsize","title":"function readgridncsize","text":"<p>Read grid size and metadata from a NetCDF file. </p><pre><code>void readgridncsize (\n    const std::string ncfilestr,\n    const std::string varstr,\n    std::string reftime,\n    int &amp; nx,\n    int &amp; ny,\n    int &amp; nt,\n    double &amp; dx,\n    double &amp; dy,\n    double &amp; dt,\n    double &amp; xo,\n    double &amp; yo,\n    double &amp; to,\n    double &amp; xmax,\n    double &amp; ymax,\n    double &amp; tmax,\n    bool &amp; flipx,\n    bool &amp; flipy\n) \n</code></pre> <p>Reads dimensions, coordinates, and time information for a variable in a NetCDF file.</p> <p>Parameters:</p> <ul> <li><code>ncfilestr</code> NetCDF filename </li> <li><code>varstr</code> Variable name </li> <li><code>reftime</code> Reference time string </li> <li><code>nx</code> Number of x grid points </li> <li><code>ny</code> Number of y grid points </li> <li><code>nt</code> Number of time steps </li> <li><code>dx</code> Grid spacing in x </li> <li><code>dy</code> Grid spacing in y </li> <li><code>dt</code> Time step size </li> <li><code>xo</code> Origin x </li> <li><code>yo</code> Origin y </li> <li><code>to</code> Origin time </li> <li><code>xmax</code> Maximum x </li> <li><code>ymax</code> Maximum y </li> <li><code>tmax</code> Maximum time </li> <li><code>flipx</code> Flip x axis </li> <li><code>flipy</code> Flip y axis </li> </ul>"},{"location":"BGFlood/_read__netcdf_8h/#function-readgridncsize_1","title":"function readgridncsize","text":"<p>Read grid size and metadata for a forcing map. </p><pre><code>void readgridncsize (\n    forcingmap &amp; Fmap,\n    Param XParam\n) \n</code></pre> <p>Reads grid size and metadata for a forcing map using model parameters.</p> <p>Parameters:</p> <ul> <li><code>Fmap</code> Forcing map structure </li> <li><code>XParam</code> Model parameters </li> </ul>"},{"location":"BGFlood/_read__netcdf_8h/#function-readgridncsize_2","title":"function readgridncsize","text":"<p>Read grid size and metadata for a generic map type. </p><pre><code>template&lt;class T&gt;\nvoid readgridncsize (\n    T &amp; Imap\n) \n</code></pre> <p>Reads grid size and metadata for a generic map type (inputmap, forcingmap, etc.).</p> <p>Template parameters:</p> <ul> <li><code>T</code> Map type </li> </ul> <p>Parameters:</p> <ul> <li><code>Imap</code> Map structure </li> </ul>"},{"location":"BGFlood/_read__netcdf_8h/#function-readncslev1","title":"function readncslev1","text":"<p>Read a single level of data from a NetCDF file. </p><pre><code>template&lt;class T&gt;\nint readncslev1 (\n    std::string filename,\n    std::string varstr,\n    size_t indx,\n    size_t indy,\n    size_t indt,\n    bool checkhh,\n    double eps,\n    T *&amp; zsa\n) \n</code></pre> <p>Reads a single level of data for a variable from a NetCDF file.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>filename</code> NetCDF filename </li> <li><code>varstr</code> Variable name </li> <li><code>indx</code> X index </li> <li><code>indy</code> Y index </li> <li><code>indt</code> Time index </li> <li><code>checkhh</code> Check for missing values </li> <li><code>eps</code> Epsilon for missing value detection </li> <li><code>zsa</code> Output array for data </li> </ul> <p>Returns:</p> <p>Status code </p>"},{"location":"BGFlood/_read__netcdf_8h/#function-readnctime","title":"function readnctime","text":"<p>Read time variable from a NetCDF file. </p><pre><code>int readnctime (\n    std::string filename,\n    double *&amp; time\n) \n</code></pre> <p>Reads the time variable from a NetCDF file into a double array.</p> <p>Parameters:</p> <ul> <li><code>filename</code> NetCDF filename </li> <li><code>time</code> Output array for time values </li> </ul> <p>Returns:</p> <p>Status code </p>"},{"location":"BGFlood/_read__netcdf_8h/#function-readnctime2","title":"function readnctime2","text":"<p>Read time variable from a NetCDF file with reference date. </p><pre><code>int readnctime2 (\n    int ncid,\n    char * timecoordname,\n    std::string refdate,\n    size_t nt,\n    double *&amp; time\n) \n</code></pre> <p>Reads the time variable from a NetCDF file using a reference date and time coordinate name.</p> <p>Parameters:</p> <ul> <li><code>ncid</code> NetCDF file ID </li> <li><code>timecoordname</code> Time coordinate variable name </li> <li><code>refdate</code> Reference date string </li> <li><code>nt</code> Number of time steps </li> <li><code>time</code> Output array for time values </li> </ul> <p>Returns:</p> <p>Status code </p>"},{"location":"BGFlood/_read__netcdf_8h/#function-readnczb","title":"function readnczb","text":"<pre><code>void readnczb (\n    int nx,\n    int ny,\n    std::string ncfile,\n    float *&amp; zb\n) \n</code></pre>"},{"location":"BGFlood/_read__netcdf_8h/#function-readvardata","title":"function readvardata","text":"<p>Read variable data from a NetCDF file for a specific time step. </p><pre><code>template&lt;class T&gt;\nint readvardata (\n    std::string filename,\n    std::string Varname,\n    int step,\n    T *&amp; vardata,\n    bool flipx,\n    bool flipy\n) \n</code></pre> <p>Reads data for a variable from a NetCDF file for a given time step, with optional axis flipping.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>filename</code> NetCDF filename </li> <li><code>Varname</code> Variable name </li> <li><code>step</code> Time step to read </li> <li><code>vardata</code> Output array for data </li> <li><code>flipx</code> Flip x axis </li> <li><code>flipy</code> Flip y axis </li> </ul> <p>Returns:</p> <p>Status code </p>"},{"location":"BGFlood/_read__netcdf_8h/#function-readvarinfo","title":"function readvarinfo","text":"<p>Read variable dimension info from a NetCDF file. </p><pre><code>int readvarinfo (\n    std::string filename,\n    std::string Varname,\n    size_t *&amp; ddimU\n) \n</code></pre> <p>Reads the dimensions for a variable in a NetCDF file.</p> <p>Parameters:</p> <ul> <li><code>filename</code> NetCDF filename </li> <li><code>Varname</code> Variable name </li> <li><code>ddimU</code> Output array for dimension sizes </li> </ul> <p>Returns:</p> <p>Number of dimensions </p> <p>The documentation for this class was generated from the following file <code>src/Read_netcdf.h</code></p>"},{"location":"BGFlood/_read__netcdf_8h_source/","title":"File Read_netcdf.h","text":""},{"location":"BGFlood/_read__netcdf_8h_source/#file-read_netcdfh","title":"File Read_netcdf.h","text":"<p>File List &gt; src &gt; Read_netcdf.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef READNETCDF_H\n#define READNETCDF_H\n\n#include \"General.h\"\n#include \"Input.h\"\n#include \"ReadInput.h\"\n#include \"Write_txtlog.h\"\n#include \"Write_netcdf.h\"\n#include \"Util_CPU.h\"\n#include \"GridManip.h\"\n#include \"Forcing.h\"\n#include \"utctime.h\"\n\n\n\ninline int nc_get_var_T(int ncid, int varid, float * &amp;zb);\ninline int nc_get_var_T(int ncid, int varid, double * &amp;zb);\n\ninline int nc_get_vara_T(int ncid, int varid, const size_t* startp, const size_t* countp, float * &amp;zb);\ninline int nc_get_vara_T(int ncid, int varid, const size_t* startp, const size_t* countp, double * &amp;zb);\n\ninline int nc_get_var1_T(int ncid, int varid, const size_t* startp, float * zsa);\ninline int nc_get_var1_T(int ncid, int varid, const size_t* startp, double * zsa);\n\n//template &lt;class T&gt; int readnczb(int nx, int ny, const std::string ncfile, T * &amp;zb);\n//int readnczb(int nx, int ny, const std::string ncfile, float*&amp; zb);\n//int readnczb(int nx, int ny, const std::string ncfile, double*&amp; zb);\nstd::string checkncvarname(int ncid, std::string stringA, std::string stringB, std::string stringC, std::string stringD, std::string stringE);\n\n\nvoid readgridncsize(const std::string ncfilestr, const std::string varstr, std::string reftime, int&amp; nx, int&amp; ny, int&amp; nt, double&amp; dx, double&amp; dy, double&amp; dt, double&amp; xo, double&amp; yo, double&amp; to, double&amp; xmax, double&amp; ymax, double&amp; tmax, bool&amp; flipx, bool&amp; flipy);\nvoid readgridncsize(forcingmap&amp; Fmap, Param XParam);\n\ntemplate&lt;class T&gt; void readgridncsize(T&amp; Imap);\n\n\nint readvarinfo(std::string filename, std::string Varname, size_t *&amp;ddimU);\nint readnctime(std::string filename, double * &amp;time);\nint readnctime2(int ncid,char* timecoordname, std::string refdate, size_t nt, double*&amp; time);\ntemplate &lt;class T&gt; int readncslev1(std::string filename, std::string varstr, size_t indx, size_t indy, size_t indt, bool checkhh, double eps, T * &amp;zsa);\ntemplate &lt;class T&gt; int readvardata(std::string filename, std::string Varname, int step, T*&amp; vardata, bool flipx, bool flipy);\n//template &lt;class T&gt; int readhotstartfile(Param XParam, int * leftblk, int *rightblk, int * topblk, int* botblk, double * blockxo, double * blockyo, T * &amp;zs, T * &amp;zb, T * &amp;hh, T *&amp;uu, T * &amp;vv);\n\nvoid readWNDstep(forcingmap WNDUmap, forcingmap WNDVmap, int steptoread, float *&amp;Uo, float *&amp;Vo);\nvoid readATMstep(forcingmap ATMPmap, int steptoread, float *&amp;Po);\n\nextern \"C\" void read3Dnc(int nx, int ny, int ntheta, char ncfile[], float*&amp; ee);\nextern \"C\" void read2Dnc(int nx, int ny, char ncfile[], float*&amp; hh);\nextern \"C\" void readnczb(int nx, int ny, std::string ncfile, float*&amp; zb);\n\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_reimann_8cu/","title":"File Reimann.cu","text":""},{"location":"BGFlood/_reimann_8cu/#file-reimanncu","title":"File Reimann.cu","text":"<p>FileList &gt; src &gt; Reimann.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Reimann.h\"</code></li> </ul>"},{"location":"BGFlood/_reimann_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ void UpdateButtingerXCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) \"Adaptive\" second-order hydrostatic reconstruction. CPU version for the X-axis template __host__ void UpdateButtingerXCPU (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb)  template __host__ void UpdateButtingerXCPU (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb)  __global__ void UpdateButtingerXGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) \"Adaptive\" second-order hydrostatic reconstruction. GPU version for the X-axis template __global__ void UpdateButtingerXGPU (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb)  template __global__ void UpdateButtingerXGPU (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb)  __host__ void UpdateButtingerYCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) \"Adaptive\" second-order hydrostatic reconstruction. CPU version for the Y-axis template __host__ void UpdateButtingerYCPU (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb)  template __host__ void UpdateButtingerYCPU (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb)  __global__ void UpdateButtingerYGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) \"Adaptive\" second-order hydrostatic reconstruction. GPU version for the Y-axis template __global__ void UpdateButtingerYGPU (Param XParam, BlockP&lt; float &gt; XBlock, EvolvingP&lt; float &gt; XEv, GradientsP&lt; float &gt; XGrad, FluxP&lt; float &gt; XFlux, float * dtmax, float * zb)  template __global__ void UpdateButtingerYGPU (Param XParam, BlockP&lt; double &gt; XBlock, EvolvingP&lt; double &gt; XEv, GradientsP&lt; double &gt; XGrad, FluxP&lt; double &gt; XFlux, double * dtmax, double * zb)  __host__ __device__ T hllc (T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T &amp; fh, T &amp; fq) Calculate the Harten-Lax-van Leer-contact (HLLC) flux."},{"location":"BGFlood/_reimann_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_reimann_8cu/#function-updatebuttingerxcpu","title":"function UpdateButtingerXCPU","text":"<p>\"Adaptive\" second-order hydrostatic reconstruction. CPU version for the X-axis </p><pre><code>template&lt;class T&gt;\n__host__ void UpdateButtingerXCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8cu/#description","title":"Description","text":"<p>This function computes the flux term at the cell interface using the hydrostatic reconstruction from Buttinger et al (2019). This reconstruction is safe for steep slopes with thin water depth and is well-balanced, conserving \"lake-at-rest\" states.</p> <p>For optimizing the code on CPU and GPU, there are 4 versions of this function: X or Y and CPU or GPU. </p>"},{"location":"BGFlood/_reimann_8cu/#where-does-this-come-from","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk / B-Flood source code. I (CypB) changed the zr and zl term back to the Audusse type reconstruction http://basilisk.fr/sandbox/b-flood/saint-venant-topo.h</p> <p>Reference: * Buttinger-Kreuzhuber, A., Horvath, Z., Noelle, S., Bloschl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89-108, 2019. * Kirstetter, G., Delestre, O., Lagree, P.-Y., Popinet, S., and Josserand, C.: B-flood 1.0: an open-source Saint-Venant model for flash flood simulation using adaptive refinement, Geosci. Model Dev. Discuss. [preprint], https://doi.org/10.5194/gmd-2021-15, in review, 2021. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Structure containing the simulation parameters </li> <li><code>XBlock</code> Structure containing the block information </li> <li><code>XEv</code> Structure containing the evolving variables </li> <li><code>XGrad</code> Structure containing the gradients of the evolving variables </li> <li><code>XFlux</code> Structure containing the fluxes to be updated </li> <li><code>dtmax</code> Array to store the maximum allowable time step for each cell </li> <li><code>zb</code> Array containing the bed elevation </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> Data type, either float or double </li> </ul> <p>Note:</p> <p>This function is designed to be run on the CPU and should be called within a loop over all blocks. </p>"},{"location":"BGFlood/_reimann_8cu/#function-updatebuttingerxcpu_1","title":"function UpdateButtingerXCPU","text":"<pre><code>template __host__ void UpdateButtingerXCPU (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8cu/#function-updatebuttingerxcpu_2","title":"function UpdateButtingerXCPU","text":"<pre><code>template __host__ void UpdateButtingerXCPU (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8cu/#function-updatebuttingerxgpu","title":"function UpdateButtingerXGPU","text":"<p>\"Adaptive\" second-order hydrostatic reconstruction. GPU version for the X-axis </p><pre><code>template&lt;class T&gt;\n__global__ void UpdateButtingerXGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8cu/#description_1","title":"Description","text":"<p>This function computes the flux term at the cell interface using the hydrostatic reconstruction from Buttinger et al (2019). This reconstruction is safe for steep slopes with thin water depth and is well-balanced, conserving \"lake-at-rest\" states.</p> <p>For optimising the code on CPU and GPU there are 4 versions of this function: X or Y and CPU or GPU</p>"},{"location":"BGFlood/_reimann_8cu/#where-does-this-come-from_1","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk / B-Flood source code. I (CypB) changed the zr and zl term back to the Audusse type reconstruction http://basilisk.fr/sandbox/b-flood/saint-venant-topo.h</p>"},{"location":"BGFlood/_reimann_8cu/#reference","title":"Reference:","text":"<p>Kirstetter, G., Delestre, O., Lagree, P.-Y., Popinet, S., and Josserand, C.: B-flood 1.0: an open-source Saint-Venant model for flash flood simulation using adaptive refinement, Geosci. Model Dev. Discuss. [preprint], https://doi.org/10.5194/gmd-2021-15, in review, 2021.* Buttinger-Kreuzhuber, A., Horvath, Z., Noelle, S., Bloschl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89-108, 2019.</p> <p>Parameters:</p> <ul> <li><code>XParam</code> Structure containing the simulation parameters </li> <li><code>XBlock</code> Structure containing the block information </li> <li><code>XEv</code> Structure containing the evolving variables </li> <li><code>XGrad</code> Structure containing the gradients of the evolving variables </li> <li><code>XFlux</code> Structure containing the fluxes to be updated </li> <li><code>dtmax</code> Array to store the maximum allowable time step for each cell </li> <li><code>zb</code> Array containing the bed elevation </li> <li><code>T</code> Data type, either float or double </li> </ul> <p>Note:</p> <p>This function is designed to be run on the GPU and should be launched with a grid and block configuration that matches the number of blocks and block size. </p>"},{"location":"BGFlood/_reimann_8cu/#function-updatebuttingerxgpu_1","title":"function UpdateButtingerXGPU","text":"<pre><code>template __global__ void UpdateButtingerXGPU (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8cu/#function-updatebuttingerxgpu_2","title":"function UpdateButtingerXGPU","text":"<pre><code>template __global__ void UpdateButtingerXGPU (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8cu/#function-updatebuttingerycpu","title":"function UpdateButtingerYCPU","text":"<p>\"Adaptive\" second-order hydrostatic reconstruction. CPU version for the Y-axis </p><pre><code>template&lt;class T&gt;\n__host__ void UpdateButtingerYCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8cu/#description_2","title":"Description","text":"<p>This function computes the flux term at the cell interface using the hydrostatic reconstruction from Buttinger et al (2019). This reconstruction is safe for steep slope with thin water depth and is well-balanced meaning that it conserve the \"lake-at-rest\" states.</p> <p>For optimising the code on CPU and GPU there are 4 versions of this function: X or Y and CPU or GPU</p>"},{"location":"BGFlood/_reimann_8cu/#where-does-this-come-from_2","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk / B-Flood source code. I (CypB) changed the zr and zl term back to the Audusse type reconstruction http://basilisk.fr/sandbox/b-flood/saint-venant-topo.h</p> <p>Reference: Kirstetter, G., Delestre, O., Lagree, P.-Y., Popinet, S., and Josserand, C.: B-flood 1.0: an open-source Saint-Venant model for flash flood simulation using adaptive refinement, Geosci. Model Dev. Discuss. [preprint], https://doi.org/10.5194/gmd-2021-15, in review, 2021.* Buttinger-Kreuzhuber, A., Horvath, Z., Noelle, S., Bloschl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89-108, 2019. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Structure containing the simulation parameters </li> <li><code>XBlock</code> Structure containing the block information </li> <li><code>XEv</code> Structure containing the evolving variables </li> <li><code>XGrad</code> Structure containing the gradients of the evolving variables </li> <li><code>XFlux</code> Structure containing the fluxes to be updated </li> <li><code>dtmax</code> Array to store the maximum allowable time step for each cell </li> <li><code>zb</code> Array containing the bed elevation </li> <li><code>T</code> Data type, either float or double </li> </ul> <p>Note:</p> <p>This function is designed to be run on the CPU and should be called within a loop over all blocks. </p>"},{"location":"BGFlood/_reimann_8cu/#function-updatebuttingerycpu_1","title":"function UpdateButtingerYCPU","text":"<pre><code>template __host__ void UpdateButtingerYCPU (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8cu/#function-updatebuttingerycpu_2","title":"function UpdateButtingerYCPU","text":"<pre><code>template __host__ void UpdateButtingerYCPU (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8cu/#function-updatebuttingerygpu","title":"function UpdateButtingerYGPU","text":"<p>\"Adaptive\" second-order hydrostatic reconstruction. GPU version for the Y-axis </p><pre><code>template&lt;class T&gt;\n__global__ void UpdateButtingerYGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8cu/#description_3","title":"Description","text":"<p>This function computes the flux term at the cell interface using the hydrostatic reconstruction from Buttinger et al (2019). This reconstruction is safe for steep slope with thin water depth and is well-balanced meaning that it conserve the \"lake-at-rest\" states.</p> <p>For optimising the code on CPU and GPU there are 4 versions of this function: X or Y and CPU or GPU</p>"},{"location":"BGFlood/_reimann_8cu/#where-does-this-come-from_3","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk / B-Flood source code. I (CypB) changed the zr and zl term back to the Audusse type reconstruction http://basilisk.fr/sandbox/b-flood/saint-venant-topo.h</p> <p>Reference: Kirstetter, G., Delestre, O., Lagree, P.-Y., Popinet, S., and Josserand, C.: B-flood 1.0: an open-source Saint-Venant model for flash flood simulation using adaptive refinement, Geosci. Model Dev. Discuss. [preprint], https://doi.org/10.5194/gmd-2021-15, in review, 2021.* Buttinger-Kreuzhuber, A., Horvath, Z., Noelle, S., Bloschl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89-108, 2019. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Structure containing the simulation parameters </li> <li><code>XBlock</code> Structure containing the block information </li> <li><code>XEv</code> Structure containing the evolving variables </li> <li><code>XGrad</code> Structure containing the gradients of the evolving variables </li> <li><code>XFlux</code> Structure containing the fluxes to be updated </li> <li><code>dtmax</code> Array to store the maximum allowable time step for each cell </li> <li><code>zb</code> Array containing the bed elevation </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> Data type, either float or double </li> </ul> <p>Note:</p> <p>This function is designed to be run on the GPU and should be launched with a grid and block configuration that matches the number of blocks and block size. </p>"},{"location":"BGFlood/_reimann_8cu/#function-updatebuttingerygpu_1","title":"function UpdateButtingerYGPU","text":"<pre><code>template __global__ void UpdateButtingerYGPU (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    EvolvingP &lt; float &gt; XEv,\n    GradientsP &lt; float &gt; XGrad,\n    FluxP &lt; float &gt; XFlux,\n    float * dtmax,\n    float * zb\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8cu/#function-updatebuttingerygpu_2","title":"function UpdateButtingerYGPU","text":"<pre><code>template __global__ void UpdateButtingerYGPU (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    EvolvingP &lt; double &gt; XEv,\n    GradientsP &lt; double &gt; XGrad,\n    FluxP &lt; double &gt; XFlux,\n    double * dtmax,\n    double * zb\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8cu/#function-hllc","title":"function hllc","text":"<p>Calculate the Harten-Lax-van Leer-contact (HLLC) flux. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T hllc (\n    T g,\n    T delta,\n    T epsi,\n    T CFL,\n    T cm,\n    T fm,\n    T hm,\n    T hp,\n    T um,\n    T up,\n    T &amp; fh,\n    T &amp; fq\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8cu/#description_4","title":"Description","text":"<p>This an implementation of the HLLC solver.</p>"},{"location":"BGFlood/_reimann_8cu/#where-does-this-come-from_4","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk source code. http://basilisk.fr/src/riemann.h</p> <p>Reference: (Basilisk reference the scheme from Kurganov reference below) Kurganov, A., &amp; Levy, D. (2002). Central-upwind schemes for the Saint-Venant system. Mathematical Modelling and Numerical Analysis, 36(3), 397-425.</p> <p>Parameters:</p> <ul> <li><code>g</code> Gravitational acceleration </li> <li><code>delta</code> Grid resolution at the current level </li> <li><code>epsi</code> Small number to prevent division by zero </li> <li><code>CFL</code> Courant-Friedrichs-Lewy number for stability condition </li> <li><code>cm</code> Metric term for spherical coordinates (1.0 for Cartesian) </li> <li><code>fm</code> Metric term for spherical coordinates (1.0 for Cartesian) </li> <li><code>hm</code> Water depth on the left side of the interface </li> <li><code>hp</code> Water depth on the right side of the interface </li> <li><code>um</code> Velocity in the x-direction on the left side of the interface </li> <li><code>up</code> Velocity in the x-direction on the right side of the interface </li> <li><code>fh</code> Reference to store the computed flux for water depth </li> <li><code>fq</code> Reference to store the computed flux for momentum </li> </ul> <p>Returns:</p> <p>The maximum allowable time step based on the wave speeds and CFL condition </p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type, either float or double </li> </ul> <p>Note:</p> <p>This function is designed to be run on both CPU and GPU. </p> <p>The documentation for this class was generated from the following file <code>src/Reimann.cu</code></p>"},{"location":"BGFlood/_reimann_8cu_source/","title":"File Reimann.cu","text":""},{"location":"BGFlood/_reimann_8cu_source/#file-reimanncu","title":"File Reimann.cu","text":"<p>File List &gt; src &gt; Reimann.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Reimann.h\"\n\n\ntemplate &lt;class T&gt; __global__ void UpdateButtingerXGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.y + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int RB, LBRB, LB, RBLB, levRB, levLB;\n    RB = XBlock.RightBot[ib];\n    levRB = XBlock.level[RB];\n    LBRB = XBlock.LeftBot[RB];\n\n    LB = XBlock.LeftBot[ib];\n    levLB = XBlock.level[LB];\n    RBLB = XBlock.RightBot[LB];\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n    T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n\n    //T dhdxi = XGrad.dhdx[i];\n    //T dhdxmin = XGrad.dhdx[ileft];\n    T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T fmu = T(1.0);\n\n    T hi = XEv.h[i];\n\n    T hn = XEv.h[ileft];\n\n\n    if (hi &gt; eps || hn &gt; eps)\n    {\n        T dx, zi, zn, hr, hl, etar, etal, zr, zl, zA, zCN, hCNr, hCNl;\n        T ui, vi, uli, vli, dhdxi, dhdxil, dudxi, dudxil, dvdxi,dvdxil;\n\n        T ga = g * T(0.5);\n        // along X\n        dx = delta * T(0.5);\n        zi = zb[i];\n        zn = zb[ileft];\n\n        ui = XEv.u[i];\n        vi = XEv.v[i];\n        uli = XEv.u[ileft];\n        vli = XEv.v[ileft];\n\n        dhdxi = XGrad.dhdx[i];\n        dhdxil = XGrad.dhdx[ileft];\n        dudxi = XGrad.dudx[i];\n        dudxil = XGrad.dudx[ileft];\n        dvdxi = XGrad.dvdx[i];\n        dvdxil = XGrad.dvdx[ileft];\n\n\n        hr = hi - dx * dhdxi;\n        hl = hn + dx * dhdxil;\n        etar = XEv.zs[i] - dx * XGrad.dzsdx[i];\n        etal = XEv.zs[ileft] + dx * XGrad.dzsdx[ileft];\n\n        //define the topography term at the interfaces\n        zr = etar - hr;// zi - dx * XGrad.dzbdx[i];\n        zl = etal - hl;// zn + dx * XGrad.dzbdx[ileft];\n\n        //define the Audusse terms\n        zA = max(zr, zl);\n\n        // Now the CN terms\n        zCN = min(zA, min(etal, etar));\n        hCNr = max(T(0.0), min(etar - zCN, hr));\n        hCNl = max(T(0.0), min(etal - zCN, hl));\n\n        //Velocity reconstruction\n        //To avoid high velocities near dry cells, we reconstruct velocities according to Bouchut.\n        T ul, ur, vl, vr,sl,sr;\n        if (hi &gt; eps) {\n            ur = ui - (1. + dx * dhdxi / hi) * dx * dudxi;\n            vr = vi - (1. + dx * dhdxi / hi) * dx * dvdxi;\n        }\n        else {\n            ur = ui - dx * dudxi;\n            vr = vi - dx * dvdxi;\n        }\n        if (hn &gt; eps) {\n            ul = uli + (T(1.0) - dx * dhdxil / hn) * dx * dudxil;\n            vl = vli + (T(1.0) - dx * dhdxil / hn) * dx * dvdxil;\n        }\n        else {\n            ul = uli + dx * dudxil;\n            vl = vli + dx * dvdxil;\n        }\n\n\n\n\n        T fh, fu, fv, dt;\n\n\n        //solver below also modifies fh and fu\n        dt = hllc(g, delta, epsi, CFL, cm, fmu, hCNl, hCNr, ul, ur, fh, fu);\n        //hllc(T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T &amp; fh, T &amp; fq)\n\n        if (dt &lt; dtmax[i])\n        {\n            dtmax[i] = dt;\n        }\n\n\n        fv = (fh &gt; 0. ? vl : vr) * fh;\n\n\n        // Topographic source term\n\n        // In the case of adaptive refinement, care must be taken to ensure\n        // well-balancing at coarse/fine faces (see [notes/balanced.tm]()). \n        if ((ix == blockDim.y) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = LBRB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n            int iright = memloc(halowidth, blkmemwidth, 0, jj, RB);;\n            hi = XEv.h[iright];\n            zi = zb[iright];\n        }\n        if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = RBLB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + blockDim.y / 2;\n            int ilc = memloc(halowidth, blkmemwidth, blockDim.y - 1, jj, LB);\n            hn = XEv.h[ilc];\n            zn = zb[ilc];\n        }\n\n        sl = ga * (hi + hCNr) * (zi - zCN);\n        sr = ga * (hCNl + hn) * (zn - zCN);\n\n\n        XFlux.Fhu[i] = fmu * fh;\n        XFlux.Fqux[i] = fmu * (fu - sl);\n        XFlux.Su[i] = fmu * (fu - sr);\n        XFlux.Fqvx[i] = fmu * fv;\n    }\n    else\n    {\n        dtmax[i] = T(1.0) / epsi;\n        XFlux.Fhu[i] = T(0.0);\n        XFlux.Fqux[i] = T(0.0);\n        XFlux.Su[i] = T(0.0);\n        XFlux.Fqvx[i] = T(0.0);\n    }\n\n}\ntemplate __global__ void UpdateButtingerXGPU(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb);\ntemplate __global__ void UpdateButtingerXGPU(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double* zb);\n\n\ntemplate &lt;class T&gt; __host__ void UpdateButtingerXCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb)\n{\n\n\n    T delta;\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    int RB, LBRB, LB, RBLB, levRB, levLB;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n        int lev = XBlock.level[ib];\n        delta = calcres(T(XParam.delta), lev);\n\n        // neighbours for source term\n\n        RB = XBlock.RightBot[ib];\n        levRB = XBlock.level[RB];\n        LBRB = XBlock.LeftBot[RB];\n\n        LB = XBlock.LeftBot[ib];\n        levLB = XBlock.level[LB];\n        RBLB = XBlock.RightBot[LB];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth + XParam.halowidth); ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int ileft = memloc(halowidth, blkmemwidth, ix - 1, iy, ib);\n\n                T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n\n                //T dhdxi = XGrad.dhdx[i];\n                //T dhdxmin = XGrad.dhdx[ileft];\n                T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n                T fmu = T(1.0);\n\n                T hi = XEv.h[i];\n\n                T hn = XEv.h[ileft];\n\n\n                if (hi &gt; eps || hn &gt; eps)\n                {\n                    T dx, zi, zn, hr, hl, etar, etal, zr, zl, zA, zCN, hCNr, hCNl;\n                    T ui, vi, uli, vli, dhdxi, dhdxil, dudxi, dudxil, dvdxi, dvdxil;\n\n                    T ga = g * T(0.5);\n                    // along X\n                    dx = delta * T(0.5);\n                    zi = zb[i];\n                    zn = zb[ileft];\n\n                    ui = XEv.u[i];\n                    vi = XEv.v[i];\n                    uli = XEv.u[ileft];\n                    vli = XEv.v[ileft];\n\n                    dhdxi = XGrad.dhdx[i];\n                    dhdxil = XGrad.dhdx[ileft];\n                    dudxi = XGrad.dudx[i];\n                    dudxil = XGrad.dudx[ileft];\n                    dvdxi = XGrad.dvdx[i];\n                    dvdxil = XGrad.dvdx[ileft];\n\n\n                    hr = hi - dx * dhdxi;\n                    hl = hn + dx * dhdxil;\n                    etar = XEv.zs[i] - dx * XGrad.dzsdx[i];\n                    etal = XEv.zs[ileft] + dx * XGrad.dzsdx[ileft];\n\n                    //define the topography term at the interfaces\n                    zr = etar - hr;// zi - dx * XGrad.dzbdx[i];\n                    zl = etal - hl;// zn + dx * XGrad.dzbdx[ileft];\n\n                    //define the Audusse terms\n                    zA = max(zr, zl);\n\n                    // Now the CN terms\n                    zCN = min(zA, min(etal, etar));\n                    hCNr = max(T(0.0), min(etar - zCN, hr));\n                    hCNl = max(T(0.0), min(etal - zCN, hl));\n\n                    //Velocity reconstruction\n                    //To avoid high velocities near dry cells, we reconstruct velocities according to Bouchut.\n                    T ul, ur, vl, vr, sl, sr;\n                    if (hi &gt; eps) {\n                        ur = ui - (T(1.0) + dx * dhdxi / hi) * dx * dudxi;\n                        vr = vi - (T(1.0) + dx * dhdxi / hi) * dx * dvdxi;\n                    }\n                    else {\n                        ur = ui - dx * dudxi;\n                        vr = vi - dx * dvdxi;\n                    }\n                    if (hn &gt; eps) {\n                        ul = uli + (T(1.0) - dx * dhdxil / hn) * dx * dudxil;\n                        vl = vli + (T(1.0) - dx * dhdxil / hn) * dx * dvdxil;\n                    }\n                    else {\n                        ul = uli + dx * dudxil;\n                        vl = vli + dx * dvdxil;\n                    }\n\n\n\n\n                    T fh, fu, fv, dt;\n\n\n                    //solver below also modifies fh and fu\n                    dt = hllc(g, delta, epsi, CFL, cm, fmu, hCNl, hCNr, ul, ur, fh, fu);\n                    //hllc(T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T &amp; fh, T &amp; fq)\n\n                    if (dt &lt; dtmax[i])\n                    {\n                        dtmax[i] = dt;\n                    }\n\n\n                    fv = (fh &gt; 0. ? vl : vr) * fh;\n\n\n                    // Topographic source term\n\n                    // In the case of adaptive refinement, care must be taken to ensure\n                    // well-balancing at coarse/fine faces (see [notes/balanced.tm]()). \n                    if ((ix == XParam.blkwidth) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n                    {\n                        int jj = LBRB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n                        int iright = memloc(halowidth, blkmemwidth, 0, jj, RB);;\n                        hi = XEv.h[iright];\n                        zi = zb[iright];\n                    }\n                    if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo if you \n                    {\n                        int jj = RBLB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n                        int ilc = memloc(halowidth, blkmemwidth, XParam.blkwidth- 1, jj, LB);\n\n                        hn = XEv.h[ilc];\n                        zn = zb[ilc];\n                    }\n\n                    sl = ga * (hi + hCNr) * (zi - zCN);\n                    sr = ga * (hCNl + hn) * (zn - zCN);\n\n\n                    XFlux.Fhu[i] = fmu * fh;\n                    XFlux.Fqux[i] = fmu * (fu - sl);\n                    XFlux.Su[i] = fmu * (fu - sr);\n                    XFlux.Fqvx[i] = fmu * fv;\n                }\n                else\n                {\n                    dtmax[i] = T(1.0) / epsi;\n                    XFlux.Fhu[i] = T(0.0);\n                    XFlux.Fqux[i] = T(0.0);\n                    XFlux.Su[i] = T(0.0);\n                    XFlux.Fqvx[i] = T(0.0);\n                }\n            }\n        }\n    }\n}\ntemplate __host__ void UpdateButtingerXCPU(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb);\ntemplate __host__ void UpdateButtingerXCPU(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double* zb);\n\n\ntemplate &lt;class T&gt; __global__ void UpdateButtingerYGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int lev = XBlock.level[ib];\n    int TL, BLTL, BL, TLBL, levTL, levBL;\n    TL = XBlock.TopLeft[ib];\n    levTL = XBlock.level[TL];\n    BLTL = XBlock.BotLeft[TL];\n\n    BL = XBlock.BotLeft[ib];\n    levBL = XBlock.level[BL];\n    TLBL = XBlock.TopLeft[BL];\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n    T delta = calcres(T(XParam.delta), lev);\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    int ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n\n\n    T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n    //T dhdyi = XGrad.dhdy[i];\n    //T dhdymin = XGrad.dhdy[ibot];\n    T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n    T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, T(iy)) : T(1.0);\n\n    T hi = XEv.h[i];\n\n    T hn = XEv.h[ibot];\n\n\n    if (hi &gt; eps || hn &gt; eps)\n    {\n        T dx, zi, zn, hr, hl, etar, etal, zr, zl, zA, zCN, hCNr, hCNl;\n        T ui, vi, uli, vli, dhdyi, dhdyil, dudyi, dudyil, dvdyi, dvdyil;\n\n        T ga = g * T(0.5);\n        // along X\n        dx = delta * T(0.5);\n        zi = zb[i];\n        zn = zb[ibot];\n\n        ui = XEv.u[i];\n        vi = XEv.v[i];\n        uli = XEv.u[ibot];\n        vli = XEv.v[ibot];\n\n        dhdyi = XGrad.dhdy[i];\n        dhdyil = XGrad.dhdy[ibot];\n        dudyi = XGrad.dudy[i];\n        dudyil = XGrad.dudy[ibot];\n        dvdyi = XGrad.dvdy[i];\n        dvdyil = XGrad.dvdy[ibot];\n\n\n        hr = hi - dx * dhdyi;\n        hl = hn + dx * dhdyil;\n        etar = XEv.zs[i] - dx * XGrad.dzsdy[i];\n        etal = XEv.zs[ibot] + dx * XGrad.dzsdy[ibot];\n\n        //define the topography term at the interfaces\n        zr = etar - hr;// zi - dx * XGrad.dzbdy[i];\n        zl = etal - hl;// zn + dx * XGrad.dzbdy[ibot];\n\n        //define the Audusse terms\n        zA = max(zr, zl);\n\n        // Now the CN terms\n        zCN = min(zA, min(etal, etar));\n        hCNr = max(T(0.0), min(etar - zCN, hr));\n        hCNl = max(T(0.0), min(etal - zCN, hl));\n\n        //Velocity reconstruction\n        //To avoid high velocities near dry cells, we reconstruct velocities according to Bouchut.\n        T ul, ur, vl, vr, sl, sr;\n        if (hi &gt; eps) {\n            ur = ui - (1. + dx * dhdyi / hi) * dx * dudyi;\n            vr = vi - (1. + dx * dhdyi / hi) * dx * dvdyi;\n        }\n        else {\n            ur = ui - dx * dudyi;\n            vr = vi - dx * dvdyi;\n        }\n        if (hn &gt; eps) {\n            ul = uli + (1. - dx * dhdyil / hn) * dx * dudyil;\n            vl = vli + (1. - dx * dhdyil / hn) * dx * dvdyil;\n        }\n        else {\n            ul = uli + dx * dudyil;\n            vl = vli + dx * dvdyil;\n        }\n\n\n\n\n        T fh, fu, fv, dt;\n\n\n        //solver below also modifies fh and fu\n        dt = hllc(g, delta, epsi, CFL, cm, fmv, hCNl, hCNr, vl, vr, fh, fu);\n        //hllc(T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T &amp; fh, T &amp; fq)\n\n        if (dt &lt; dtmax[i])\n        {\n            dtmax[i] = dt;\n        }\n\n\n        fv = (fh &gt; 0. ? ul : ur) * fh;\n\n\n        // Topographic source term\n\n        // In the case of adaptive refinement, care must be taken to ensure\n        // well-balancing at coarse/fine faces (see [notes/balanced.tm]()). \n        if ((iy == blockDim.x) &amp;&amp; levTL &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = BLTL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n            int itop = memloc(halowidth, blkmemwidth, jj, 0, TL);;\n            hi = XEv.h[itop];\n            zi = zb[itop];\n        }\n        if ((iy == 0) &amp;&amp; levBL &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = TLBL == ib ? floor(ix * (T)0.5) : floor(ix * (T)0.5) + blockDim.x / 2;\n            int ibc = memloc(halowidth, blkmemwidth, jj, blockDim.x - 1, BL);\n            hn = XEv.h[ibc];\n            zn = zb[ibc];\n        }\n\n        sl = ga * (hi + hCNr) * (zi - zCN);\n        sr = ga * (hCNl + hn) * (zn - zCN);\n\n\n        XFlux.Fhv[i] = fmv * fh;\n        XFlux.Fqvy[i] = fmv * (fu - sl);\n        XFlux.Sv[i] = fmv * (fu - sr);\n        XFlux.Fquy[i] = fmv * fv;\n    }\n    else\n    {\n        dtmax[i] = T(1.0) / epsi;\n        XFlux.Fhv[i] = T(0.0);\n        XFlux.Fqvy[i] = T(0.0);\n        XFlux.Sv[i] = T(0.0);\n        XFlux.Fquy[i] = T(0.0);\n    }\n\n}\ntemplate __global__ void UpdateButtingerYGPU(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb);\ntemplate __global__ void UpdateButtingerYGPU(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double* zb);\n\ntemplate &lt;class T&gt; __host__ void UpdateButtingerYCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb)\n{\n\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n    T delta;\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n\n\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    int TL, BLTL, BL, TLBL, levTL, levBL, lev;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n\n\n\n        TL = XBlock.TopLeft[ib];\n        levTL = XBlock.level[TL];\n        BLTL = XBlock.BotLeft[TL];\n\n        BL = XBlock.BotLeft[ib];\n        levBL = XBlock.level[BL];\n        TLBL = XBlock.TopLeft[BL];\n\n        lev = XBlock.level[ib];\n\n        delta = calcres(T(XParam.delta), lev);\n\n        for (int iy = 0; iy &lt; (XParam.blkwidth + XParam.halowidth); iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n                int ibot = memloc(halowidth, blkmemwidth, ix, iy - 1, ib);\n\n                T ybo = T(XParam.yo + XBlock.yo[ib]);\n\n\n                //T dhdyi = XGrad.dhdy[i];\n                //T dhdymin = XGrad.dhdy[ibot];\n                T cm = XParam.spherical ? calcCM(T(XParam.Radius), delta, ybo, iy) : T(1.0);\n                T fmv = XParam.spherical ? calcFM(T(XParam.Radius), delta, ybo, T(iy)) : T(1.0);\n\n                T hi = XEv.h[i];\n\n                T hn = XEv.h[ibot];\n\n\n                if (hi &gt; eps || hn &gt; eps)\n                {\n                    T dx, zi, zn, hr, hl, etar, etal, zr, zl, zA, zCN, hCNr, hCNl;\n                    T ui, vi, uli, vli, dhdyi, dhdyil, dudyi, dudyil, dvdyi, dvdyil;\n\n                    T ga = g * T(0.5);\n                    // along X\n                    dx = delta * T(0.5);\n                    zi = zb[i];\n                    zn = zb[ibot];\n\n                    ui = XEv.u[i];\n                    vi = XEv.v[i];\n                    uli = XEv.u[ibot];\n                    vli = XEv.v[ibot];\n\n                    dhdyi = XGrad.dhdy[i];\n                    dhdyil = XGrad.dhdy[ibot];\n                    dudyi = XGrad.dudy[i];\n                    dudyil = XGrad.dudy[ibot];\n                    dvdyi = XGrad.dvdy[i];\n                    dvdyil = XGrad.dvdy[ibot];\n\n\n                    hr = hi - dx * dhdyi;\n                    hl = hn + dx * dhdyil;\n                    etar = XEv.zs[i] - dx * XGrad.dzsdy[i];\n                    etal = XEv.zs[ibot] + dx * XGrad.dzsdy[ibot];\n\n                    //define the topography term at the interfaces\n                    zr = etar - hr;// zi - dx * XGrad.dzbdy[i];\n                    zl = etal - hl;// zn + dx * XGrad.dzbdy[ibot];\n\n                    //define the Audusse terms\n                    zA = max(zr, zl);\n\n                    // Now the CN terms\n                    zCN = min(zA, min(etal, etar));\n                    hCNr = max(T(0.0), min(etar - zCN, hr));\n                    hCNl = max(T(0.0), min(etal - zCN, hl));\n\n                    //Velocity reconstruction\n                    //To avoid high velocities near dry cells, we reconstruct velocities according to Bouchut.\n                    T ul, ur, vl, vr, sl, sr;\n                    if (hi &gt; eps) {\n                        ur = ui - (T(1.0) + dx * dhdyi / hi) * dx * dudyi;\n                        vr = vi - (T(1.0) + dx * dhdyi / hi) * dx * dvdyi;\n                    }\n                    else {\n                        ur = ui - dx * dudyi;\n                        vr = vi - dx * dvdyi;\n                    }\n                    if (hn &gt; eps) {\n                        ul = uli + (T(1.0) - dx * dhdyil / hn) * dx * dudyil;\n                        vl = vli + (T(1.0) - dx * dhdyil / hn) * dx * dvdyil;\n                    }\n                    else {\n                        ul = uli + dx * dudyil;\n                        vl = vli + dx * dvdyil;\n                    }\n\n\n\n\n                    T fh, fu, fv, dt;\n\n\n                    //solver below also modifies fh and fu\n                    dt = hllc(g, delta, epsi, CFL, cm, fmv, hCNl, hCNr, vl, vr, fh, fu);\n                    //hllc(T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T &amp; fh, T &amp; fq)\n\n                    if (dt &lt; dtmax[i])\n                    {\n                        dtmax[i] = dt;\n                    }\n\n\n                    fv = (fh &gt; T(0.0) ? ul : ur) * fh;\n\n\n                    // Topographic source term\n\n                    // In the case of adaptive refinement, care must be taken to ensure\n                    // well-balancing at coarse/fine faces (see [notes/balanced.tm]()). \n                    if ((iy == XParam.blkwidth) &amp;&amp; levTL &lt; lev)//(ix==16) i.e. in the top halo\n                    {\n                        int jj = BLTL == ib ? ftoi(floor(ix * (T)0.5)) : ftoi(floor(ix * (T)0.5) + XParam.blkwidth / 2);\n                        int itop = memloc(halowidth, blkmemwidth, jj, 0, TL);\n                        hi = XEv.h[itop];\n                        zi = zb[itop];\n                    }\n                    if ((iy == 0) &amp;&amp; levBL &lt; lev)//(ix==16) i.e. in the bot halo\n                    {\n                        int jj = TLBL == ib ? ftoi(floor(ix * (T)0.5)) : ftoi(floor(ix * (T)0.5) + XParam.blkwidth / 2);\n                        int ibc = memloc(halowidth, blkmemwidth, jj, XParam.blkwidth - 1, BL);\n                        // Warning I think the above is wrong and should be as below to be consistent with halo flux scheme:\n                        //int ibc = memloc(halowidth, blkmemwidth, jj, XParam.blkwidth, BL);\n                        hn = XEv.h[ibc];\n                        zn = zb[ibc];\n                    }\n\n                    sl = ga * (hi + hCNr) * (zi - zCN);\n                    sr = ga * (hCNl + hn) * (zn - zCN);\n\n\n                    XFlux.Fhv[i] = fmv * fh;\n                    XFlux.Fqvy[i] = fmv * (fu - sl);\n                    XFlux.Sv[i] = fmv * (fu - sr);\n                    XFlux.Fquy[i] = fmv * fv;\n                }\n                else\n                {\n                    dtmax[i] = T(1.0) / epsi;\n                    XFlux.Fhv[i] = T(0.0);\n                    XFlux.Fqvy[i] = T(0.0);\n                    XFlux.Sv[i] = T(0.0);\n                    XFlux.Fquy[i] = T(0.0);\n                }\n            }\n        }\n    }\n}\ntemplate __host__ void UpdateButtingerYCPU(Param XParam, BlockP&lt;float&gt; XBlock, EvolvingP&lt;float&gt; XEv, GradientsP&lt;float&gt; XGrad, FluxP&lt;float&gt; XFlux, float* dtmax, float* zb);\ntemplate __host__ void UpdateButtingerYCPU(Param XParam, BlockP&lt;double&gt; XBlock, EvolvingP&lt;double&gt; XEv, GradientsP&lt;double&gt; XGrad, FluxP&lt;double&gt; XFlux, double* dtmax, double* zb);\n\n\n\n\ntemplate &lt;class T&gt; __host__ __device__ T hllc(T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T &amp;fh, T &amp;fq)\n{\n    T cp, cmo , dt, ustar, cstar, SL, SR, fhm, fum,fhp, fup,dlt;\n    cmo = sqrt(g * hm);\n    cp = sqrt(g * hp);\n    ustar = (um + up) / T(2.) + cmo - cp;\n    cstar = (cmo + cp) / T(2.) + (um - up) / T(4.);\n    SL = hm == T(0.) ? up - T(2.) * cp : min(um - cmo, ustar - cstar);\n    SR = hp == T(0.) ? um + T(2.) * cmo : max(up + cp, ustar + cstar);\n\n    if (T(0.) &lt;= SL) {\n        fh = um * hm;\n        fq = hm * (um * um + g * hm / T(2.));\n    }\n    else if (T(0.) &gt;= SR) {\n        fh = up * hp;\n        fq = hp * (up * up + g * hp / T(2.));\n    }\n    else {\n        fhm = um * hm;\n        fum = hm * (um * um + g * hm / T(2.));\n        fhp = up * hp;\n        fup = hp * (up * up + g * hp / T(2.));\n        fh = (SR * fhm - SL * fhp + SL * SR * (hp - hm)) / (SR - SL);\n        fq = (SR * fum - SL * fup + SL * SR * (hp * up - hm * um)) / (SR - SL);\n    }\n\n    double a = max(fabs(SL), fabs(SR));\n    if (a &gt; epsi) {\n        dlt = delta * cm / fm;\n        dt = CFL * dlt / T(a);\n\n    }\n    else\n    {\n        dt = T(1.0) / epsi;\n    }\n    return dt;\n}\n</code></pre>"},{"location":"BGFlood/_reimann_8h/","title":"File Reimann.h","text":""},{"location":"BGFlood/_reimann_8h/#file-reimannh","title":"File Reimann.h","text":"<p>FileList &gt; src &gt; Reimann.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> </ul>"},{"location":"BGFlood/_reimann_8h/#public-functions","title":"Public Functions","text":"Type Name __host__ void UpdateButtingerXCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) \"Adaptive\" second-order hydrostatic reconstruction. CPU version for the X-axis __global__ void UpdateButtingerXGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) \"Adaptive\" second-order hydrostatic reconstruction. GPU version for the X-axis __host__ void UpdateButtingerYCPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) \"Adaptive\" second-order hydrostatic reconstruction. CPU version for the Y-axis __global__ void UpdateButtingerYGPU (Param XParam, BlockP&lt; T &gt; XBlock, EvolvingP&lt; T &gt; XEv, GradientsP&lt; T &gt; XGrad, FluxP&lt; T &gt; XFlux, T * dtmax, T * zb) \"Adaptive\" second-order hydrostatic reconstruction. GPU version for the Y-axis __host__ __device__ T hllc (T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T &amp; fh, T &amp; fq) Calculate the Harten-Lax-van Leer-contact (HLLC) flux."},{"location":"BGFlood/_reimann_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_reimann_8h/#function-updatebuttingerxcpu","title":"function UpdateButtingerXCPU","text":"<p>\"Adaptive\" second-order hydrostatic reconstruction. CPU version for the X-axis </p><pre><code>template&lt;class T&gt;\n__host__ void UpdateButtingerXCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8h/#description","title":"Description","text":"<p>This function computes the flux term at the cell interface using the hydrostatic reconstruction from Buttinger et al (2019). This reconstruction is safe for steep slopes with thin water depth and is well-balanced, conserving \"lake-at-rest\" states.</p> <p>For optimizing the code on CPU and GPU, there are 4 versions of this function: X or Y and CPU or GPU. </p>"},{"location":"BGFlood/_reimann_8h/#where-does-this-come-from","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk / B-Flood source code. I (CypB) changed the zr and zl term back to the Audusse type reconstruction http://basilisk.fr/sandbox/b-flood/saint-venant-topo.h</p> <p>Reference: * Buttinger-Kreuzhuber, A., Horvath, Z., Noelle, S., Bloschl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89-108, 2019. * Kirstetter, G., Delestre, O., Lagree, P.-Y., Popinet, S., and Josserand, C.: B-flood 1.0: an open-source Saint-Venant model for flash flood simulation using adaptive refinement, Geosci. Model Dev. Discuss. [preprint], https://doi.org/10.5194/gmd-2021-15, in review, 2021. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Structure containing the simulation parameters </li> <li><code>XBlock</code> Structure containing the block information </li> <li><code>XEv</code> Structure containing the evolving variables </li> <li><code>XGrad</code> Structure containing the gradients of the evolving variables </li> <li><code>XFlux</code> Structure containing the fluxes to be updated </li> <li><code>dtmax</code> Array to store the maximum allowable time step for each cell </li> <li><code>zb</code> Array containing the bed elevation </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> Data type, either float or double </li> </ul> <p>Note:</p> <p>This function is designed to be run on the CPU and should be called within a loop over all blocks. </p>"},{"location":"BGFlood/_reimann_8h/#function-updatebuttingerxgpu","title":"function UpdateButtingerXGPU","text":"<p>\"Adaptive\" second-order hydrostatic reconstruction. GPU version for the X-axis </p><pre><code>template&lt;class T&gt;\n__global__ void UpdateButtingerXGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8h/#description_1","title":"Description","text":"<p>This function computes the flux term at the cell interface using the hydrostatic reconstruction from Buttinger et al (2019). This reconstruction is safe for steep slopes with thin water depth and is well-balanced, conserving \"lake-at-rest\" states.</p> <p>For optimising the code on CPU and GPU there are 4 versions of this function: X or Y and CPU or GPU</p>"},{"location":"BGFlood/_reimann_8h/#where-does-this-come-from_1","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk / B-Flood source code. I (CypB) changed the zr and zl term back to the Audusse type reconstruction http://basilisk.fr/sandbox/b-flood/saint-venant-topo.h</p>"},{"location":"BGFlood/_reimann_8h/#reference","title":"Reference:","text":"<p>Kirstetter, G., Delestre, O., Lagree, P.-Y., Popinet, S., and Josserand, C.: B-flood 1.0: an open-source Saint-Venant model for flash flood simulation using adaptive refinement, Geosci. Model Dev. Discuss. [preprint], https://doi.org/10.5194/gmd-2021-15, in review, 2021.* Buttinger-Kreuzhuber, A., Horvath, Z., Noelle, S., Bloschl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89-108, 2019.</p> <p>Parameters:</p> <ul> <li><code>XParam</code> Structure containing the simulation parameters </li> <li><code>XBlock</code> Structure containing the block information </li> <li><code>XEv</code> Structure containing the evolving variables </li> <li><code>XGrad</code> Structure containing the gradients of the evolving variables </li> <li><code>XFlux</code> Structure containing the fluxes to be updated </li> <li><code>dtmax</code> Array to store the maximum allowable time step for each cell </li> <li><code>zb</code> Array containing the bed elevation </li> <li><code>T</code> Data type, either float or double </li> </ul> <p>Note:</p> <p>This function is designed to be run on the GPU and should be launched with a grid and block configuration that matches the number of blocks and block size. </p>"},{"location":"BGFlood/_reimann_8h/#function-updatebuttingerycpu","title":"function UpdateButtingerYCPU","text":"<p>\"Adaptive\" second-order hydrostatic reconstruction. CPU version for the Y-axis </p><pre><code>template&lt;class T&gt;\n__host__ void UpdateButtingerYCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8h/#description_2","title":"Description","text":"<p>This function computes the flux term at the cell interface using the hydrostatic reconstruction from Buttinger et al (2019). This reconstruction is safe for steep slope with thin water depth and is well-balanced meaning that it conserve the \"lake-at-rest\" states.</p> <p>For optimising the code on CPU and GPU there are 4 versions of this function: X or Y and CPU or GPU</p>"},{"location":"BGFlood/_reimann_8h/#where-does-this-come-from_2","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk / B-Flood source code. I (CypB) changed the zr and zl term back to the Audusse type reconstruction http://basilisk.fr/sandbox/b-flood/saint-venant-topo.h</p> <p>Reference: Kirstetter, G., Delestre, O., Lagree, P.-Y., Popinet, S., and Josserand, C.: B-flood 1.0: an open-source Saint-Venant model for flash flood simulation using adaptive refinement, Geosci. Model Dev. Discuss. [preprint], https://doi.org/10.5194/gmd-2021-15, in review, 2021.* Buttinger-Kreuzhuber, A., Horvath, Z., Noelle, S., Bloschl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89-108, 2019. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Structure containing the simulation parameters </li> <li><code>XBlock</code> Structure containing the block information </li> <li><code>XEv</code> Structure containing the evolving variables </li> <li><code>XGrad</code> Structure containing the gradients of the evolving variables </li> <li><code>XFlux</code> Structure containing the fluxes to be updated </li> <li><code>dtmax</code> Array to store the maximum allowable time step for each cell </li> <li><code>zb</code> Array containing the bed elevation </li> <li><code>T</code> Data type, either float or double </li> </ul> <p>Note:</p> <p>This function is designed to be run on the CPU and should be called within a loop over all blocks. </p>"},{"location":"BGFlood/_reimann_8h/#function-updatebuttingerygpu","title":"function UpdateButtingerYGPU","text":"<p>\"Adaptive\" second-order hydrostatic reconstruction. GPU version for the Y-axis </p><pre><code>template&lt;class T&gt;\n__global__ void UpdateButtingerYGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    EvolvingP &lt; T &gt; XEv,\n    GradientsP &lt; T &gt; XGrad,\n    FluxP &lt; T &gt; XFlux,\n    T * dtmax,\n    T * zb\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8h/#description_3","title":"Description","text":"<p>This function computes the flux term at the cell interface using the hydrostatic reconstruction from Buttinger et al (2019). This reconstruction is safe for steep slope with thin water depth and is well-balanced meaning that it conserve the \"lake-at-rest\" states.</p> <p>For optimising the code on CPU and GPU there are 4 versions of this function: X or Y and CPU or GPU</p>"},{"location":"BGFlood/_reimann_8h/#where-does-this-come-from_3","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk / B-Flood source code. I (CypB) changed the zr and zl term back to the Audusse type reconstruction http://basilisk.fr/sandbox/b-flood/saint-venant-topo.h</p> <p>Reference: Kirstetter, G., Delestre, O., Lagree, P.-Y., Popinet, S., and Josserand, C.: B-flood 1.0: an open-source Saint-Venant model for flash flood simulation using adaptive refinement, Geosci. Model Dev. Discuss. [preprint], https://doi.org/10.5194/gmd-2021-15, in review, 2021.* Buttinger-Kreuzhuber, A., Horvath, Z., Noelle, S., Bloschl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89-108, 2019. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Structure containing the simulation parameters </li> <li><code>XBlock</code> Structure containing the block information </li> <li><code>XEv</code> Structure containing the evolving variables </li> <li><code>XGrad</code> Structure containing the gradients of the evolving variables </li> <li><code>XFlux</code> Structure containing the fluxes to be updated </li> <li><code>dtmax</code> Array to store the maximum allowable time step for each cell </li> <li><code>zb</code> Array containing the bed elevation </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> Data type, either float or double </li> </ul> <p>Note:</p> <p>This function is designed to be run on the GPU and should be launched with a grid and block configuration that matches the number of blocks and block size. </p>"},{"location":"BGFlood/_reimann_8h/#function-hllc","title":"function hllc","text":"<p>Calculate the Harten-Lax-van Leer-contact (HLLC) flux. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T hllc (\n    T g,\n    T delta,\n    T epsi,\n    T CFL,\n    T cm,\n    T fm,\n    T hm,\n    T hp,\n    T um,\n    T up,\n    T &amp; fh,\n    T &amp; fq\n) \n</code></pre>"},{"location":"BGFlood/_reimann_8h/#description_4","title":"Description","text":"<p>This an implementation of the HLLC solver.</p>"},{"location":"BGFlood/_reimann_8h/#where-does-this-come-from_4","title":"Where does this come from:","text":"<p>This scheme was adapted/modified from the Basilisk source code. http://basilisk.fr/src/riemann.h</p> <p>Reference: (Basilisk reference the scheme from Kurganov reference below) Kurganov, A., &amp; Levy, D. (2002). Central-upwind schemes for the Saint-Venant system. Mathematical Modelling and Numerical Analysis, 36(3), 397-425.</p> <p>Parameters:</p> <ul> <li><code>g</code> Gravitational acceleration </li> <li><code>delta</code> Grid resolution at the current level </li> <li><code>epsi</code> Small number to prevent division by zero </li> <li><code>CFL</code> Courant-Friedrichs-Lewy number for stability condition </li> <li><code>cm</code> Metric term for spherical coordinates (1.0 for Cartesian) </li> <li><code>fm</code> Metric term for spherical coordinates (1.0 for Cartesian) </li> <li><code>hm</code> Water depth on the left side of the interface </li> <li><code>hp</code> Water depth on the right side of the interface </li> <li><code>um</code> Velocity in the x-direction on the left side of the interface </li> <li><code>up</code> Velocity in the x-direction on the right side of the interface </li> <li><code>fh</code> Reference to store the computed flux for water depth </li> <li><code>fq</code> Reference to store the computed flux for momentum </li> </ul> <p>Returns:</p> <p>The maximum allowable time step based on the wave speeds and CFL condition </p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type, either float or double </li> </ul> <p>Note:</p> <p>This function is designed to be run on both CPU and GPU. </p> <p>The documentation for this class was generated from the following file <code>src/Reimann.h</code></p>"},{"location":"BGFlood/_reimann_8h_source/","title":"File Reimann.h","text":""},{"location":"BGFlood/_reimann_8h_source/#file-reimannh","title":"File Reimann.h","text":"<p>File List &gt; src &gt; Reimann.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef REIMANN_H\n#define REIMANN_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"Util_CPU.h\"\n\ntemplate &lt;class T&gt; __global__ void UpdateButtingerXGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __host__ void UpdateButtingerXCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __global__ void UpdateButtingerYGPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __host__ void UpdateButtingerYCPU(Param XParam, BlockP&lt;T&gt; XBlock, EvolvingP&lt;T&gt; XEv, GradientsP&lt;T&gt; XGrad, FluxP&lt;T&gt; XFlux, T* dtmax, T* zb);\ntemplate &lt;class T&gt; __host__ __device__ T hllc(T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T&amp; fh, T&amp; fq);\n#endif\n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/","title":"File Setup_GPU.cu","text":""},{"location":"BGFlood/_setup___g_p_u_8cu/#file-setup_gpucu","title":"File Setup_GPU.cu","text":"<p>FileList &gt; src &gt; Setup_GPU.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Setup_GPU.h\"</code></li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8cu/#public-functions","title":"Public Functions","text":"Type Name void AllocateBndTEX (bndparam &amp; side) Allocate boundary texture for GPU. void AllocateTEX (int nx, int ny, TexSetP &amp; Tex, float * input) Allocate and bind a CUDA texture object. void CUDA_CHECK (cudaError CUDerr) Check CUDA error status and print message if error occurs. void CopyGPUtoCPU (int nblk, int blksize, T * z_cpu, T * z_gpu) Copy data from GPU to CPU memory. template void CopyGPUtoCPU&lt; bool &gt; (int nblk, int blksize, bool * z_cpu, bool * z_gpu)  template void CopyGPUtoCPU&lt; double &gt; (int nblk, int blksize, double * z_cpu, double * z_gpu)  template void CopyGPUtoCPU&lt; float &gt; (int nblk, int blksize, float * z_cpu, float * z_gpu)  template void CopyGPUtoCPU&lt; int &gt; (int nblk, int blksize, int * z_cpu, int * z_gpu)  void CopytoGPU (int nblk, int blksize, T * z_cpu, T * z_gpu) Copy data from CPU to GPU memory. void CopytoGPU (int nblk, int blksize, EvolvingP&lt; T &gt; XEv_cpu, EvolvingP&lt; T &gt; XEv_gpu) Copy complex data structures from CPU to GPU. void CopytoGPU (int nblk, int blksize, EvolvingP_M&lt; T &gt; XEv_cpu, EvolvingP_M&lt; T &gt; XEv_gpu) Copy complex data structures from CPU to GPU. void CopytoGPU (int nblk, int blksize, GradientsP&lt; T &gt; XGrad_cpu, GradientsP&lt; T &gt; XGrad_gpu) Copy complex data structures from CPU to GPU. template void CopytoGPU (int nblk, int blksize, GradientsP&lt; float &gt; XGrad_cpu, GradientsP&lt; float &gt; XGrad_gpu)  template void CopytoGPU (int nblk, int blksize, GradientsP&lt; double &gt; XGrad_cpu, GradientsP&lt; double &gt; XGrad_gpu)  void CopytoGPU (int nblk, int blksize, Param XParam, Model&lt; T &gt; XModel_cpu, Model&lt; T &gt; XModel_gpu) Copy complex data structures from CPU to GPU. template void CopytoGPU&lt; bool &gt; (int nblk, int blksize, bool * z_cpu, bool * z_gpu)  template void CopytoGPU&lt; double &gt; (int nblk, int blksize, double * z_cpu, double * z_gpu)  template void CopytoGPU&lt; double &gt; (int nblk, int blksize, EvolvingP&lt; double &gt; XEv_cpu, EvolvingP&lt; double &gt; XEv_gpu)  template void CopytoGPU&lt; double &gt; (int nblk, int blksize, EvolvingP_M&lt; double &gt; XEv_cpu, EvolvingP_M&lt; double &gt; XEv_gpu)  template void CopytoGPU&lt; double &gt; (int nblk, int blksize, Param XParam, Model&lt; double &gt; XModel_cpu, Model&lt; double &gt; XModel_gpu)  template void CopytoGPU&lt; float &gt; (int nblk, int blksize, float * z_cpu, float * z_gpu)  template void CopytoGPU&lt; float &gt; (int nblk, int blksize, EvolvingP&lt; float &gt; XEv_cpu, EvolvingP&lt; float &gt; XEv_gpu)  template void CopytoGPU&lt; float &gt; (int nblk, int blksize, EvolvingP_M&lt; float &gt; XEv_cpu, EvolvingP_M&lt; float &gt; XEv_gpu)  template void CopytoGPU&lt; float &gt; (int nblk, int blksize, Param XParam, Model&lt; float &gt; XModel_cpu, Model&lt; float &gt; XModel_gpu)  template void CopytoGPU&lt; int &gt; (int nblk, int blksize, int * z_cpu, int * z_gpu)  void SetupGPU (Param &amp; XParam, Model&lt; T &gt; XModel, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel_g) Setup and initialize GPU for simulation. template void SetupGPU&lt; double &gt; (Param &amp; XParam, Model&lt; double &gt; XModel, Forcing&lt; float &gt; &amp; XForcing, Model&lt; double &gt; &amp; XModel_g)  template void SetupGPU&lt; float &gt; (Param &amp; XParam, Model&lt; float &gt; XModel, Forcing&lt; float &gt; &amp; XForcing, Model&lt; float &gt; &amp; XModel_g)"},{"location":"BGFlood/_setup___g_p_u_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_setup___g_p_u_8cu/#function-allocatebndtex","title":"function AllocateBndTEX","text":"<p>Allocate boundary texture for GPU. </p><pre><code>void AllocateBndTEX (\n    bndparam &amp; side\n) \n</code></pre> <p>Allocates and binds boundary water level data as a CUDA texture for GPU use.</p> <p>Parameters:</p> <ul> <li><code>side</code> Boundary parameter structure </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-allocatetex","title":"function AllocateTEX","text":"<p>Allocate and bind a CUDA texture object. </p><pre><code>void AllocateTEX (\n    int nx,\n    int ny,\n    TexSetP &amp; Tex,\n    float * input\n) \n</code></pre> <p>Allocates a CUDA array and creates a texture object for use in GPU kernels.</p> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x grid points </li> <li><code>ny</code> Number of y grid points </li> <li><code>Tex</code> Texture set structure </li> <li><code>input</code> Input data array </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-cuda_check","title":"function CUDA_CHECK","text":"<p>Check CUDA error status and print message if error occurs. </p><pre><code>void CUDA_CHECK (\n    cudaError CUDerr\n) \n</code></pre> <p>Checks the CUDA error code and prints an error message if the code indicates failure.</p> <p>Parameters:</p> <ul> <li><code>CUDerr</code> CUDA error code </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copygputocpu","title":"function CopyGPUtoCPU","text":"<p>Copy data from GPU to CPU memory. </p><pre><code>template&lt;class T&gt;\nvoid CopyGPUtoCPU (\n    int nblk,\n    int blksize,\n    T * z_cpu,\n    T * z_gpu\n) \n</code></pre> <p>Copies an array from device (GPU) memory to host (CPU) memory using CUDA.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>z_cpu</code> Destination array (CPU) </li> <li><code>z_gpu</code> Source array (GPU) </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copygputocpu-bool","title":"function CopyGPUtoCPU&lt; bool &gt;","text":"<pre><code>template void CopyGPUtoCPU&lt; bool &gt; (\n    int nblk,\n    int blksize,\n    bool * z_cpu,\n    bool * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copygputocpu-double","title":"function CopyGPUtoCPU&lt; double &gt;","text":"<pre><code>template void CopyGPUtoCPU&lt; double &gt; (\n    int nblk,\n    int blksize,\n    double * z_cpu,\n    double * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copygputocpu-float","title":"function CopyGPUtoCPU&lt; float &gt;","text":"<pre><code>template void CopyGPUtoCPU&lt; float &gt; (\n    int nblk,\n    int blksize,\n    float * z_cpu,\n    float * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copygputocpu-int","title":"function CopyGPUtoCPU&lt; int &gt;","text":"<pre><code>template void CopyGPUtoCPU&lt; int &gt; (\n    int nblk,\n    int blksize,\n    int * z_cpu,\n    int * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copytogpu","title":"function CopytoGPU","text":"<p>Copy data from CPU to GPU memory. </p><pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    T * z_cpu,\n    T * z_gpu\n) \n</code></pre> <p>Copies an array from host (CPU) memory to device (GPU) memory using CUDA.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>z_cpu</code> Source array (CPU) </li> <li><code>z_gpu</code> Destination array (GPU) </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copytogpu_1","title":"function CopytoGPU","text":"<p>Copy complex data structures from CPU to GPU. </p><pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; T &gt; XEv_cpu,\n    EvolvingP &lt; T &gt; XEv_gpu\n) \n</code></pre> <p>This function copies the evolving variables structure from the host (CPU) to the device (GPU) memory.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>XEv_cpu</code> Source evolving variables structure (CPU) </li> <li><code>XEv_gpu</code> Destination evolving variables structure (GPU) </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copytogpu_2","title":"function CopytoGPU","text":"<p>Copy complex data structures from CPU to GPU. </p><pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; T &gt; XEv_cpu,\n    EvolvingP_M &lt; T &gt; XEv_gpu\n) \n</code></pre> <p>This function copies the evolving variables with momentum structure from the host (CPU) to the device (GPU) memory.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>XEv_cpu</code> Source evolving variables with momentum structure (CPU) </li> <li><code>XEv_gpu</code> Destination evolving variables with momentum structure (GPU) </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copytogpu_3","title":"function CopytoGPU","text":"<p>Copy complex data structures from CPU to GPU. </p><pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    GradientsP &lt; T &gt; XGrad_cpu,\n    GradientsP &lt; T &gt; XGrad_gpu\n) \n</code></pre> <p>This function copies the gradients structure from the host (CPU) to the device (GPU) memory.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>XGrad_cpu</code> Source gradients structure (CPU) </li> <li><code>XGrad_gpu</code> Destination gradients structure (GPU) </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copytogpu_4","title":"function CopytoGPU","text":"<pre><code>template void CopytoGPU (\n    int nblk,\n    int blksize,\n    GradientsP &lt; float &gt; XGrad_cpu,\n    GradientsP &lt; float &gt; XGrad_gpu\n) \n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copytogpu_5","title":"function CopytoGPU","text":"<pre><code>template void CopytoGPU (\n    int nblk,\n    int blksize,\n    GradientsP &lt; double &gt; XGrad_cpu,\n    GradientsP &lt; double &gt; XGrad_gpu\n) \n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copytogpu_6","title":"function CopytoGPU","text":"<p>Copy complex data structures from CPU to GPU. </p><pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; T &gt; XModel_cpu,\n    Model &lt; T &gt; XModel_gpu\n) \n</code></pre> <p>This function copies the entire model structure from the host (CPU) to the device (GPU) memory.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>XParam</code> Simulation parameters </li> <li><code>XModel_cpu</code> Source model structure (CPU) </li> <li><code>XModel_gpu</code> Destination model structure (GPU) </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copytogpu-bool","title":"function CopytoGPU&lt; bool &gt;","text":"<pre><code>template void CopytoGPU&lt; bool &gt; (\n    int nblk,\n    int blksize,\n    bool * z_cpu,\n    bool * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copytogpu-double","title":"function CopytoGPU&lt; double &gt;","text":"<pre><code>template void CopytoGPU&lt; double &gt; (\n    int nblk,\n    int blksize,\n    double * z_cpu,\n    double * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copytogpu-double_1","title":"function CopytoGPU&lt; double &gt;","text":"<pre><code>template void CopytoGPU&lt; double &gt; (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; double &gt; XEv_cpu,\n    EvolvingP &lt; double &gt; XEv_gpu\n) \n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copytogpu-double_2","title":"function CopytoGPU&lt; double &gt;","text":"<pre><code>template void CopytoGPU&lt; double &gt; (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; double &gt; XEv_cpu,\n    EvolvingP_M &lt; double &gt; XEv_gpu\n) \n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copytogpu-double_3","title":"function CopytoGPU&lt; double &gt;","text":"<pre><code>template void CopytoGPU&lt; double &gt; (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; double &gt; XModel_cpu,\n    Model &lt; double &gt; XModel_gpu\n) \n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copytogpu-float","title":"function CopytoGPU&lt; float &gt;","text":"<pre><code>template void CopytoGPU&lt; float &gt; (\n    int nblk,\n    int blksize,\n    float * z_cpu,\n    float * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copytogpu-float_1","title":"function CopytoGPU&lt; float &gt;","text":"<pre><code>template void CopytoGPU&lt; float &gt; (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; float &gt; XEv_cpu,\n    EvolvingP &lt; float &gt; XEv_gpu\n) \n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copytogpu-float_2","title":"function CopytoGPU&lt; float &gt;","text":"<pre><code>template void CopytoGPU&lt; float &gt; (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; float &gt; XEv_cpu,\n    EvolvingP_M &lt; float &gt; XEv_gpu\n) \n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copytogpu-float_3","title":"function CopytoGPU&lt; float &gt;","text":"<pre><code>template void CopytoGPU&lt; float &gt; (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; float &gt; XModel_cpu,\n    Model &lt; float &gt; XModel_gpu\n) \n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-copytogpu-int","title":"function CopytoGPU&lt; int &gt;","text":"<pre><code>template void CopytoGPU&lt; int &gt; (\n    int nblk,\n    int blksize,\n    int * z_cpu,\n    int * z_gpu\n) \n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-setupgpu","title":"function SetupGPU","text":"<p>Setup and initialize GPU for simulation. </p><pre><code>template&lt;class T&gt;\nvoid SetupGPU (\n    Param &amp; XParam,\n    Model &lt; T &gt; XModel,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel_g\n) \n</code></pre> <p>This function sets up the GPU device, allocates memory, and copies data from the host to the device. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XModel</code> Host model data structure </li> <li><code>XForcing</code> Forcing data structure </li> <li><code>XModel_g</code> Device model data structure </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-setupgpu-double","title":"function SetupGPU&lt; double &gt;","text":"<pre><code>template void SetupGPU&lt; double &gt; (\n    Param &amp; XParam,\n    Model &lt; double &gt; XModel,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; double &gt; &amp; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8cu/#function-setupgpu-float","title":"function SetupGPU&lt; float &gt;","text":"<pre><code>template void SetupGPU&lt; float &gt; (\n    Param &amp; XParam,\n    Model &lt; float &gt; XModel,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; float &gt; &amp; XModel_g\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Setup_GPU.cu</code></p>"},{"location":"BGFlood/_setup___g_p_u_8cu_source/","title":"File Setup_GPU.cu","text":""},{"location":"BGFlood/_setup___g_p_u_8cu_source/#file-setup_gpucu","title":"File Setup_GPU.cu","text":"<p>File List &gt; src &gt; Setup_GPU.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Setup_GPU.h\"\n\n\ntemplate &lt;class T&gt; void SetupGPU(Param &amp;XParam, Model&lt;T&gt; XModel,Forcing&lt;float&gt; &amp;XForcing, Model&lt;T&gt;&amp; XModel_g)\n{\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        log(\"Setting up GPU\");\n\n        size_t free_byte;\n\n        size_t total_byte;\n\n        cudaSetDevice(XParam.GPUDEVICE);\n\n        CUDA_CHECK(cudaMemGetInfo(&amp;free_byte, &amp;total_byte));\n\n        XParam.GPU_initmem_byte = total_byte - free_byte;\n\n\n        //Allocate memory for the model on the GPU\n        AllocateGPU(XParam.nblkmem, XParam.blksize, XParam, XModel_g);\n\n        // Copy arrays from CPU to GPU\n        CopytoGPU(XParam.nblkmem, XParam.blksize,XParam, XModel, XModel_g);\n\n        //\n        fillHaloGPU(XParam, XModel_g.blocks, XModel_g.evolv);\n\n        //=============================\n        // Same for Bnds\n\n\n        // Allocate memory for the boundary blk\n        AllocateGPU(XForcing.left.nblk, 1, XForcing.left.blks_g);\n        //copy bnd blk info on GPU\n        CopytoGPU(XForcing.left.nblk, 1, XForcing.left.blks, XForcing.left.blks_g);\n\n        AllocateGPU(XForcing.right.nblk, 1, XForcing.right.blks_g);\n        CopytoGPU(XForcing.right.nblk, 1, XForcing.right.blks, XForcing.right.blks_g);\n\n        AllocateGPU(XForcing.top.nblk, 1, XForcing.top.blks_g);\n        CopytoGPU(XForcing.top.nblk, 1, XForcing.top.blks, XForcing.top.blks_g);\n\n        AllocateGPU(XForcing.bot.nblk, 1, XForcing.bot.blks_g);\n        CopytoGPU(XForcing.bot.nblk, 1, XForcing.bot.blks, XForcing.bot.blks_g);\n\n\n        for (int s = 0; s &lt; XForcing.bndseg.size(); s++)\n        {\n            AllocateGPU(XForcing.bndseg[s].left.nblk, 1, XForcing.bndseg[s].left.blk_g);\n            CopytoGPU(XForcing.bndseg[s].left.nblk, 1, XForcing.bndseg[s].left.blk, XForcing.bndseg[s].left.blk_g);\n\n            AllocateGPU(XForcing.bndseg[s].right.nblk, 1, XForcing.bndseg[s].right.blk_g);\n            CopytoGPU(XForcing.bndseg[s].right.nblk, 1, XForcing.bndseg[s].right.blk, XForcing.bndseg[s].right.blk_g);\n\n            AllocateGPU(XForcing.bndseg[s].top.nblk, 1, XForcing.bndseg[s].top.blk_g);\n            CopytoGPU(XForcing.bndseg[s].top.nblk, 1, XForcing.bndseg[s].top.blk, XForcing.bndseg[s].top.blk_g);\n\n            AllocateGPU(XForcing.bndseg[s].bot.nblk, 1, XForcing.bndseg[s].bot.blk_g);\n            CopytoGPU(XForcing.bndseg[s].bot.nblk, 1, XForcing.bndseg[s].bot.blk, XForcing.bndseg[s].bot.blk_g);\n\n            AllocateGPU(XForcing.bndseg[s].left.nblk, XParam.blkwidth, XForcing.bndseg[s].left.qmean_g);\n            CopytoGPU(XForcing.bndseg[s].left.nblk, XParam.blkwidth, XForcing.bndseg[s].left.qmean, XForcing.bndseg[s].left.qmean_g);\n\n            AllocateGPU(XForcing.bndseg[s].right.nblk, XParam.blkwidth, XForcing.bndseg[s].right.qmean_g);\n            CopytoGPU(XForcing.bndseg[s].right.nblk, XParam.blkwidth, XForcing.bndseg[s].right.qmean, XForcing.bndseg[s].right.qmean_g);\n\n            AllocateGPU(XForcing.bndseg[s].top.nblk, XParam.blkwidth, XForcing.bndseg[s].top.qmean_g);\n            CopytoGPU(XForcing.bndseg[s].top.nblk, XParam.blkwidth, XForcing.bndseg[s].top.qmean, XForcing.bndseg[s].top.qmean_g);\n\n            AllocateGPU(XForcing.bndseg[s].bot.nblk, XParam.blkwidth, XForcing.bndseg[s].bot.qmean_g);\n            CopytoGPU(XForcing.bndseg[s].bot.nblk, XParam.blkwidth, XForcing.bndseg[s].bot.qmean, XForcing.bndseg[s].bot.qmean_g);\n        }\n\n\n        // Also for mask\n        XModel_g.blocks.mask.nblk = XModel.blocks.mask.nblk;\n        AllocateGPU(XModel_g.blocks.mask.nblk, 1, XModel_g.blocks.mask.side);\n        AllocateGPU(XModel_g.blocks.mask.nblk, 1, XModel_g.blocks.mask.blks);\n        CopytoGPU(XModel_g.blocks.mask.nblk, 1, XModel.blocks.mask.side, XModel_g.blocks.mask.side);\n        CopytoGPU(XModel_g.blocks.mask.nblk, 1, XModel.blocks.mask.blks, XModel_g.blocks.mask.blks);\n\n\n        // things are quite different for Time Series output. Why is that?.\n        if (XParam.TSnodesout.size() &gt; 0)\n        {\n\n            AllocateGPU(XModel.bndblk.nblkTs, 1, XModel_g.bndblk.Tsout);\n            CopytoGPU(XModel.bndblk.nblkTs, 1, XModel.bndblk.Tsout, XModel_g.bndblk.Tsout);\n\n        }\n\n        // River are a bit of a special case too\n        if (XForcing.rivers.size() &gt; 0)\n        {\n            //\n            XModel_g.bndblk.nblkriver = XModel.bndblk.nblkriver;\n            AllocateGPU(XModel.bndblk.nblkriver, 1, XModel_g.bndblk.river);\n            CopytoGPU(XModel.bndblk.nblkriver, 1, XModel.bndblk.river, XModel_g.bndblk.river);\n\n            int nribmax = XModel.bndblk.Riverinfo.nribmax;\n            int nburmax = XModel.bndblk.Riverinfo.nburmax;\n\n            XModel_g.bndblk.Riverinfo.nribmax = nribmax;\n            XModel_g.bndblk.Riverinfo.nburmax = nburmax;\n\n\n            AllocateMappedMemGPU(XForcing.rivers.size(), 1,XParam.GPUDEVICE, XModel_g.bndblk.Riverinfo.qnow_g,XModel.bndblk.Riverinfo.qnow);\n            XModel_g.bndblk.Riverinfo.qnow = XModel.bndblk.Riverinfo.qnow;\n\n\n            AllocateGPU(nribmax, nburmax, XModel_g.bndblk.Riverinfo.Xbidir);\n            AllocateGPU(nribmax, nburmax, XModel_g.bndblk.Riverinfo.Xridib);\n            CopytoGPU(nribmax, nburmax, XModel.bndblk.Riverinfo.Xbidir, XModel_g.bndblk.Riverinfo.Xbidir);\n            CopytoGPU(nribmax, nburmax, XModel.bndblk.Riverinfo.Xridib, XModel_g.bndblk.Riverinfo.Xridib);\n\n            AllocateGPU(nribmax, nburmax, XModel_g.bndblk.Riverinfo.xstart);\n            AllocateGPU(nribmax, nburmax, XModel_g.bndblk.Riverinfo.xend);\n            AllocateGPU(nribmax, nburmax, XModel_g.bndblk.Riverinfo.ystart);\n            AllocateGPU(nribmax, nburmax, XModel_g.bndblk.Riverinfo.yend);\n\n            CopytoGPU(nribmax, nburmax, XModel.bndblk.Riverinfo.xstart, XModel_g.bndblk.Riverinfo.xstart);\n            CopytoGPU(nribmax, nburmax, XModel.bndblk.Riverinfo.xend, XModel_g.bndblk.Riverinfo.xend);\n            CopytoGPU(nribmax, nburmax, XModel.bndblk.Riverinfo.ystart, XModel_g.bndblk.Riverinfo.ystart);\n            CopytoGPU(nribmax, nburmax, XModel.bndblk.Riverinfo.yend, XModel_g.bndblk.Riverinfo.yend);\n\n        }\n\n        // Reset GPU mean and max arrays\n        if (XParam.outmax)\n        {\n            //ResetmaxvarGPU(XParam);\n        }\n        if (XParam.outmean)\n        {\n            //ResetmeanvarGPU(XParam);\n        }\n\n        Initmaparray(XModel_g);\n\n        //InitzbgradientGPU(XParam, XModel_g);\n\n\n    }\n}\ntemplate void SetupGPU&lt;float&gt;(Param &amp;XParam, Model&lt;float&gt; XModel, Forcing&lt;float&gt;&amp; XForcing, Model&lt;float&gt;&amp; XModel_g);\ntemplate void SetupGPU&lt;double&gt;(Param &amp;XParam, Model&lt;double&gt; XModel, Forcing&lt;float&gt;&amp; XForcing, Model&lt;double&gt;&amp; XModel_g);\n\n\nvoid CUDA_CHECK(cudaError CUDerr)\n{\n\n\n    if (cudaSuccess != CUDerr) {\n\n        fprintf(stderr, \"Cuda error in file '%s' in line %i : %s.\\n\", \\\n\n            __FILE__, __LINE__, cudaGetErrorString(CUDerr));\n\n        exit(EXIT_FAILURE);\n\n    }\n}\n\n\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, T * z_cpu, T* z_gpu)\n{\n    CUDA_CHECK(cudaMemcpy(z_gpu, z_cpu, nblk * blksize * sizeof(T), cudaMemcpyHostToDevice));\n}\ntemplate void CopytoGPU&lt;bool&gt;(int nblk, int blksize, bool* z_cpu, bool* z_gpu);\ntemplate void CopytoGPU&lt;int&gt;(int nblk, int blksize, int* z_cpu, int* z_gpu);\ntemplate void CopytoGPU&lt;float&gt;(int nblk, int blksize, float* z_cpu, float* z_gpu);\ntemplate void CopytoGPU&lt;double&gt;(int nblk, int blksize, double* z_cpu, double* z_gpu);\n\ntemplate &lt;class T&gt; void CopyGPUtoCPU(int nblk, int blksize, T* z_cpu, T* z_gpu)\n{\n    CUDA_CHECK(cudaMemcpy(z_cpu, z_gpu, nblk * blksize * sizeof(T), cudaMemcpyDeviceToHost));\n}\ntemplate void CopyGPUtoCPU&lt;bool&gt;(int nblk, int blksize, bool* z_cpu, bool* z_gpu);\ntemplate void CopyGPUtoCPU&lt;int&gt;(int nblk, int blksize, int* z_cpu, int* z_gpu);\ntemplate void CopyGPUtoCPU&lt;float&gt;(int nblk, int blksize, float* z_cpu, float* z_gpu);\ntemplate void CopyGPUtoCPU&lt;double&gt;(int nblk, int blksize, double* z_cpu, double* z_gpu);\n\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, EvolvingP&lt;T&gt; XEv_cpu, EvolvingP&lt;T&gt; XEv_gpu)\n{\n    CopytoGPU(nblk, blksize, XEv_cpu.h, XEv_gpu.h);\n    CopytoGPU(nblk, blksize, XEv_cpu.zs, XEv_gpu.zs);\n    CopytoGPU(nblk, blksize, XEv_cpu.u, XEv_gpu.u);\n    CopytoGPU(nblk, blksize, XEv_cpu.v, XEv_gpu.v);\n}\ntemplate void CopytoGPU&lt;float&gt;(int nblk, int blksize, EvolvingP&lt;float&gt; XEv_cpu, EvolvingP&lt;float&gt; XEv_gpu);\ntemplate void CopytoGPU &lt; double &gt;(int nblk, int blksize, EvolvingP&lt;double&gt; XEv_cpu, EvolvingP&lt;double&gt; XEv_gpu);\n\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, EvolvingP_M&lt;T&gt; XEv_cpu, EvolvingP_M&lt;T&gt; XEv_gpu)\n{\n    CopytoGPU(nblk, blksize, XEv_cpu.h, XEv_gpu.h);\n    CopytoGPU(nblk, blksize, XEv_cpu.zs, XEv_gpu.zs);\n    CopytoGPU(nblk, blksize, XEv_cpu.u, XEv_gpu.u);\n    CopytoGPU(nblk, blksize, XEv_cpu.v, XEv_gpu.v);\n    CopytoGPU(nblk, blksize, XEv_cpu.U, XEv_gpu.U);\n    CopytoGPU(nblk, blksize, XEv_cpu.hU, XEv_gpu.hU);\n}\ntemplate void CopytoGPU&lt;float&gt;(int nblk, int blksize, EvolvingP_M&lt;float&gt; XEv_cpu, EvolvingP_M&lt;float&gt; XEv_gpu);\ntemplate void CopytoGPU &lt; double &gt;(int nblk, int blksize, EvolvingP_M&lt;double&gt; XEv_cpu, EvolvingP_M &lt; double &gt;  XEv_gpu);\n\n\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, GradientsP&lt;T&gt; XGrad_cpu, GradientsP&lt;T&gt; XGrad_gpu)\n{\n    CopytoGPU(nblk, blksize, XGrad_cpu.dhdx, XGrad_gpu.dhdx);\n    CopytoGPU(nblk, blksize, XGrad_cpu.dhdy, XGrad_gpu.dhdy);\n    CopytoGPU(nblk, blksize, XGrad_cpu.dudx, XGrad_gpu.dudx);\n    CopytoGPU(nblk, blksize, XGrad_cpu.dudy, XGrad_gpu.dudy);\n    CopytoGPU(nblk, blksize, XGrad_cpu.dvdx, XGrad_gpu.dvdx);\n    CopytoGPU(nblk, blksize, XGrad_cpu.dvdy, XGrad_gpu.dvdy);\n    CopytoGPU(nblk, blksize, XGrad_cpu.dzsdx, XGrad_gpu.dzsdx);\n    CopytoGPU(nblk, blksize, XGrad_cpu.dzsdy, XGrad_gpu.dzsdy);\n}\ntemplate void CopytoGPU(int nblk, int blksize, GradientsP&lt;float&gt; XGrad_cpu, GradientsP&lt;float&gt; XGrad_gpu);\ntemplate void CopytoGPU(int nblk, int blksize, GradientsP&lt;double&gt; XGrad_cpu, GradientsP&lt;double&gt; XGrad_gpu);\n\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, Param XParam, Model&lt;T&gt; XModel_cpu, Model&lt;T&gt; XModel_gpu)\n{\n    CopytoGPU(nblk, blksize, XModel_cpu.zb, XModel_gpu.zb);\n\n    CopytoGPU(nblk, blksize, XModel_cpu.evolv, XModel_gpu.evolv);\n    //CopytoGPU(nblk, blksize, XModel_cpu.evolv_o, XModel_gpu.evolv_o);\n\n    CopytoGPU(nblk, blksize, XModel_cpu.evolv_o, XModel_gpu.evolv_o);\n\n    CopytoGPU(nblk, blksize, XModel_cpu.cf, XModel_gpu.cf);\n\n    CopytoGPU(nblk, blksize, XModel_cpu.grad.dzbdx, XModel_gpu.grad.dzbdx);\n    CopytoGPU(nblk, blksize, XModel_cpu.grad.dzbdy, XModel_gpu.grad.dzbdy);\n\n\n    //Block info\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.active, XModel_gpu.blocks.active);\n    CopytoGPU(nblk, blksize, XModel_cpu.blocks.activeCell, XModel_gpu.blocks.activeCell);\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.level, XModel_gpu.blocks.level);\n\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.xo, XModel_gpu.blocks.xo);\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.yo, XModel_gpu.blocks.yo);\n\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.BotLeft, XModel_gpu.blocks.BotLeft);\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.BotRight, XModel_gpu.blocks.BotRight);\n\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.TopLeft, XModel_gpu.blocks.TopLeft);\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.TopRight, XModel_gpu.blocks.TopRight);\n\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.LeftBot, XModel_gpu.blocks.LeftBot);\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.LeftTop, XModel_gpu.blocks.LeftTop);\n\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.RightBot, XModel_gpu.blocks.RightBot);\n    CopytoGPU(nblk, 1, XModel_cpu.blocks.RightTop, XModel_gpu.blocks.RightTop);\n\n\n    if (XParam.infiltration)\n    {\n        CopytoGPU(nblk, blksize, XModel_cpu.il, XModel_gpu.il);\n        CopytoGPU(nblk, blksize, XModel_cpu.cl, XModel_gpu.cl);\n        CopytoGPU(nblk, blksize, XModel_cpu.hgw, XModel_gpu.hgw);\n    }\n\n    if (XParam.outmax)\n    {\n        CopytoGPU(nblk, blksize, XModel_cpu.evmax, XModel_gpu.evmax);\n    }\n    if (XParam.outmean)\n    {\n        CopytoGPU(nblk, blksize, XModel_cpu.evmean, XModel_gpu.evmean);\n    }\n    if (XParam.outtwet)\n    {\n        CopytoGPU(nblk, blksize, XModel_cpu.wettime, XModel_gpu.wettime);\n    }\n}\ntemplate void CopytoGPU&lt;float&gt;(int nblk, int blksize, Param XParam, Model&lt;float&gt; XModel_cpu, Model&lt;float&gt; XModel_gpu);\ntemplate void CopytoGPU&lt;double&gt;(int nblk, int blksize, Param XParam, Model&lt;double&gt; XModel_cpu, Model&lt;double&gt; XModel_gpu);\n\n\nvoid AllocateTEX(int nx, int ny, TexSetP&amp; Tex, float* input)\n{\n\n\n    CUDA_CHECK(cudaMallocArray(&amp;Tex.CudArr, &amp;Tex.channelDesc, nx, ny));\n    CUDA_CHECK(cudaMemcpyToArray(Tex.CudArr, 0, 0, input, nx * ny * sizeof(float), cudaMemcpyHostToDevice));\n\n\n    memset(&amp;Tex.texDesc, 0, sizeof(cudaTextureDesc));\n    Tex.texDesc.addressMode[0] = cudaAddressModeClamp;\n    Tex.texDesc.addressMode[1] = cudaAddressModeClamp;\n    Tex.texDesc.filterMode = cudaFilterModeLinear;\n    //Tex.texDesc.filterMode = cudaFilterModePoint;\n    Tex.texDesc.normalizedCoords = false;\n\n    memset(&amp;Tex.resDesc, 0, sizeof(cudaResourceDesc));\n\n    Tex.resDesc.resType = cudaResourceTypeArray;\n    Tex.resDesc.res.array.array = Tex.CudArr;\n\n    CUDA_CHECK(cudaCreateTextureObject(&amp;Tex.tex, &amp;Tex.resDesc, &amp;Tex.texDesc, NULL));\n    //CUDA_CHECK(cudaBindTextureToArray(Tex, zca, cCFD));\n\n\n}\n\n\nvoid AllocateBndTEX(bndparam &amp; side)\n{\n    int nbndtimes = (int)side.data.size();\n    int nbndvec = (int)side.data[0].wlevs.size();\n\n    float* lWLS;\n    lWLS = (float*)malloc(nbndtimes * nbndvec * sizeof(float));\n\n    for (int ibndv = 0; ibndv &lt; nbndvec; ibndv++)\n    {\n        for (int ibndt = 0; ibndt &lt; nbndtimes; ibndt++)\n        {\n            //\n            lWLS[ibndt + ibndv * nbndtimes] = (float)side.data[ibndt].wlevs[ibndv];\n        }\n    }\n    AllocateTEX(nbndtimes, nbndvec, side.GPU.WLS, lWLS);\n\n    // In case of Nesting U and V are also prescribed\n\n    // If uu information is available in the boundary we can assume it is a nesting type of bnd\n    int nbndvecuu = (int)side.data[0].uuvel.size();\n    if (nbndvecuu == nbndvec)\n    {\n        //\n        for (int ibndv = 0; ibndv &lt; nbndvec; ibndv++)\n        {\n            for (int ibndt = 0; ibndt &lt; nbndtimes; ibndt++)\n            {\n                //\n                lWLS[ibndt + ibndv * nbndtimes] = (float)side.data[ibndt].uuvel[ibndv];\n            }\n        }\n        AllocateTEX(nbndtimes, nbndvec, side.GPU.Uvel, lWLS);\n\n    }\n    //V velocity side\n    int nbndvecvv = (int)side.data[0].vvvel.size();\n\n    if (nbndvecvv == nbndvec)\n    {\n        for (int ibndv = 0; ibndv &lt; nbndvec; ibndv++)\n        {\n            for (int ibndt = 0; ibndt &lt; nbndtimes; ibndt++)\n            {\n                //\n                lWLS[ibndt + ibndv * nbndtimes] = (float)side.data[ibndt].vvvel[ibndv];\n            }\n        }\n        AllocateTEX(nbndtimes, nbndvec, side.GPU.Vvel, lWLS);\n    }\n\n    free(lWLS);\n\n\n}\n</code></pre>"},{"location":"BGFlood/_setup___g_p_u_8h/","title":"File Setup_GPU.h","text":""},{"location":"BGFlood/_setup___g_p_u_8h/#file-setup_gpuh","title":"File Setup_GPU.h","text":"<p>FileList &gt; src &gt; Setup_GPU.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Halo.h\"</code></li> <li><code>#include \"InitialConditions.h\"</code></li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8h/#public-functions","title":"Public Functions","text":"Type Name void AllocateBndTEX (bndparam &amp; side) Allocate boundary texture for GPU. void AllocateTEX (int nx, int ny, TexSetP &amp; Tex, float * input) Allocate and bind a CUDA texture object. void CUDA_CHECK (cudaError CUDerr) Check CUDA error status and print message if error occurs. void CopyGPUtoCPU (int nblk, int blksize, T * z_cpu, T * z_gpu) Copy data from GPU to CPU memory. void CopytoGPU (int nblk, int blksize, Param XParam, Model&lt; T &gt; XModel_cpu, Model&lt; T &gt; XModel_gpu) Copy complex data structures from CPU to GPU. void CopytoGPU (int nblk, int blksize, T * z_cpu, T * z_gpu) Copy data from CPU to GPU memory. void CopytoGPU (int nblk, int blksize, EvolvingP&lt; T &gt; XEv_cpu, EvolvingP&lt; T &gt; XEv_gpu) Copy complex data structures from CPU to GPU. void CopytoGPU (int nblk, int blksize, EvolvingP_M&lt; T &gt; XEv_cpu, EvolvingP_M&lt; T &gt; XEv_gpu) Copy complex data structures from CPU to GPU. void CopytoGPU (int nblk, int blksize, GradientsP&lt; T &gt; XGrad_cpu, GradientsP&lt; T &gt; XGrad_gpu) Copy complex data structures from CPU to GPU. void SetupGPU (Param &amp; XParam, Model&lt; T &gt; XModel, Forcing&lt; float &gt; &amp; XForcing, Model&lt; T &gt; &amp; XModel_g) Setup and initialize GPU for simulation."},{"location":"BGFlood/_setup___g_p_u_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_setup___g_p_u_8h/#function-allocatebndtex","title":"function AllocateBndTEX","text":"<p>Allocate boundary texture for GPU. </p><pre><code>void AllocateBndTEX (\n    bndparam &amp; side\n) \n</code></pre> <p>Allocates and binds boundary water level data as a CUDA texture for GPU use.</p> <p>Parameters:</p> <ul> <li><code>side</code> Boundary parameter structure </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8h/#function-allocatetex","title":"function AllocateTEX","text":"<p>Allocate and bind a CUDA texture object. </p><pre><code>void AllocateTEX (\n    int nx,\n    int ny,\n    TexSetP &amp; Tex,\n    float * input\n) \n</code></pre> <p>Allocates a CUDA array and creates a texture object for use in GPU kernels.</p> <p>Parameters:</p> <ul> <li><code>nx</code> Number of x grid points </li> <li><code>ny</code> Number of y grid points </li> <li><code>Tex</code> Texture set structure </li> <li><code>input</code> Input data array </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8h/#function-cuda_check","title":"function CUDA_CHECK","text":"<p>Check CUDA error status and print message if error occurs. </p><pre><code>void CUDA_CHECK (\n    cudaError CUDerr\n) \n</code></pre> <p>Checks the CUDA error code and prints an error message if the code indicates failure.</p> <p>Parameters:</p> <ul> <li><code>CUDerr</code> CUDA error code </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8h/#function-copygputocpu","title":"function CopyGPUtoCPU","text":"<p>Copy data from GPU to CPU memory. </p><pre><code>template&lt;class T&gt;\nvoid CopyGPUtoCPU (\n    int nblk,\n    int blksize,\n    T * z_cpu,\n    T * z_gpu\n) \n</code></pre> <p>Copies an array from device (GPU) memory to host (CPU) memory using CUDA.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>z_cpu</code> Destination array (CPU) </li> <li><code>z_gpu</code> Source array (GPU) </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8h/#function-copytogpu","title":"function CopytoGPU","text":"<p>Copy complex data structures from CPU to GPU. </p><pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    Param XParam,\n    Model &lt; T &gt; XModel_cpu,\n    Model &lt; T &gt; XModel_gpu\n) \n</code></pre> <p>This function copies the entire model structure from the host (CPU) to the device (GPU) memory.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>XParam</code> Simulation parameters </li> <li><code>XModel_cpu</code> Source model structure (CPU) </li> <li><code>XModel_gpu</code> Destination model structure (GPU) </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8h/#function-copytogpu_1","title":"function CopytoGPU","text":"<p>Copy data from CPU to GPU memory. </p><pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    T * z_cpu,\n    T * z_gpu\n) \n</code></pre> <p>Copies an array from host (CPU) memory to device (GPU) memory using CUDA.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>z_cpu</code> Source array (CPU) </li> <li><code>z_gpu</code> Destination array (GPU) </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8h/#function-copytogpu_2","title":"function CopytoGPU","text":"<p>Copy complex data structures from CPU to GPU. </p><pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    EvolvingP &lt; T &gt; XEv_cpu,\n    EvolvingP &lt; T &gt; XEv_gpu\n) \n</code></pre> <p>This function copies the evolving variables structure from the host (CPU) to the device (GPU) memory.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>XEv_cpu</code> Source evolving variables structure (CPU) </li> <li><code>XEv_gpu</code> Destination evolving variables structure (GPU) </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8h/#function-copytogpu_3","title":"function CopytoGPU","text":"<p>Copy complex data structures from CPU to GPU. </p><pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    EvolvingP_M &lt; T &gt; XEv_cpu,\n    EvolvingP_M &lt; T &gt; XEv_gpu\n) \n</code></pre> <p>This function copies the evolving variables with momentum structure from the host (CPU) to the device (GPU) memory.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>XEv_cpu</code> Source evolving variables with momentum structure (CPU) </li> <li><code>XEv_gpu</code> Destination evolving variables with momentum structure (GPU) </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8h/#function-copytogpu_4","title":"function CopytoGPU","text":"<p>Copy complex data structures from CPU to GPU. </p><pre><code>template&lt;class T&gt;\nvoid CopytoGPU (\n    int nblk,\n    int blksize,\n    GradientsP &lt; T &gt; XGrad_cpu,\n    GradientsP &lt; T &gt; XGrad_gpu\n) \n</code></pre> <p>This function copies the gradients structure from the host (CPU) to the device (GPU) memory.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Data type </li> </ul> <p>Parameters:</p> <ul> <li><code>nblk</code> Number of blocks </li> <li><code>blksize</code> Block size </li> <li><code>XGrad_cpu</code> Source gradients structure (CPU) </li> <li><code>XGrad_gpu</code> Destination gradients structure (GPU) </li> </ul>"},{"location":"BGFlood/_setup___g_p_u_8h/#function-setupgpu","title":"function SetupGPU","text":"<p>Setup and initialize GPU for simulation. </p><pre><code>template&lt;class T&gt;\nvoid SetupGPU (\n    Param &amp; XParam,\n    Model &lt; T &gt; XModel,\n    Forcing &lt; float &gt; &amp; XForcing,\n    Model &lt; T &gt; &amp; XModel_g\n) \n</code></pre> <p>This function sets up the GPU device, allocates memory, and copies data from the host to the device. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XModel</code> Host model data structure </li> <li><code>XForcing</code> Forcing data structure </li> <li><code>XModel_g</code> Device model data structure </li> </ul> <p>The documentation for this class was generated from the following file <code>src/Setup_GPU.h</code></p>"},{"location":"BGFlood/_setup___g_p_u_8h_source/","title":"File Setup_GPU.h","text":""},{"location":"BGFlood/_setup___g_p_u_8h_source/#file-setup_gpuh","title":"File Setup_GPU.h","text":"<p>File List &gt; src &gt; Setup_GPU.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef SETUPGPU_H\n#define SETUPGPU_H\n\n#include \"General.h\"\n#include \"Forcing.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"MemManagement.h\"\n#include \"Halo.h\"\n#include \"InitialConditions.h\"\n\nvoid CUDA_CHECK(cudaError CUDerr);\n\ntemplate &lt;class T&gt; void SetupGPU(Param &amp;XParam, Model&lt;T&gt; XModel, Forcing&lt;float&gt;&amp; XForcing, Model&lt;T&gt;&amp; XModel_g);\nvoid AllocateTEX(int nx, int ny, TexSetP&amp; Tex, float* input);\nvoid AllocateBndTEX(bndparam&amp; side);\n\ntemplate &lt;class T&gt; void CopyGPUtoCPU(int nblk, int blksize, T* z_cpu, T* z_gpu);\n\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, Param XParam, Model&lt;T&gt; XModel_cpu, Model&lt;T&gt; XModel_gpu);\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, T* z_cpu, T* z_gpu);\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, EvolvingP&lt;T&gt; XEv_cpu, EvolvingP&lt;T&gt; XEv_gpu);\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, EvolvingP_M&lt;T&gt; XEv_cpu, EvolvingP_M&lt;T&gt; XEv_gpu);\ntemplate &lt;class T&gt; void CopytoGPU(int nblk, int blksize, GradientsP&lt;T&gt; XGrad_cpu, GradientsP&lt;T&gt; XGrad_gpu);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_spherical_8cu/","title":"File Spherical.cu","text":""},{"location":"BGFlood/_spherical_8cu/#file-sphericalcu","title":"File Spherical.cu","text":"<p>FileList &gt; src &gt; Spherical.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Spherical.h\"</code></li> </ul>"},{"location":"BGFlood/_spherical_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ __device__ T calcCM (T Radius, T delta, T yo, int iy) Calculate the scale factor for the y face length in a spherical model. This function computes the scale factor based on the sphere's radius, grid spacing, origin offset, and index in the y direction. Scale factor for y face length (x face lengh scale is always 1 in spherical model assuming that lat long are entered) template __host__ __device__ double calcCM (double Radius, double delta, double yo, int iy)  template __host__ __device__ float calcCM (float Radius, float delta, float yo, int iy)  __host__ __device__ T calcFM (T Radius, T delta, T yo, T iy) Calculate the scale factor for the y face length in a spherical model. This function computes the scale factor based on the sphere's radius, grid spacing, origin offset and index in the y direction. Scale factor for y face length (x face lengh scale is always 1 in spherical model assuming that lat long are entered) template __host__ __device__ double calcFM (double Radius, double delta, double yo, double iy)  template __host__ __device__ float calcFM (float Radius, float delta, float yo, float iy)  __host__ __device__ T haversin (T Radius, T lon1, T lat1, T lon2, T lat2) Classic Haversine formula to calculate great-circle distance between two points on a sphere. The function is too slow to use directly in BG_flood engine but is more usable (i.e. naive) for model setup. __host__ __device__ T spharea (T Radius, T lon, T lat, T dx) Calculate the surface area of a spherical cap. template __host__ __device__ double spharea (double Radius, double lon, double lat, double dx)  template __host__ __device__ float spharea (float Radius, float lon, float lat, float dx)"},{"location":"BGFlood/_spherical_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_spherical_8cu/#function-calccm","title":"function calcCM","text":"<p>Calculate the scale factor for the y face length in a spherical model. This function computes the scale factor based on the sphere's radius, grid spacing, origin offset, and index in the y direction. Scale factor for y face length (x face lengh scale is always 1 in spherical model assuming that lat long are entered) </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T calcCM (\n    T Radius,\n    T delta,\n    T yo,\n    int iy\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>Radius</code> Radius of the sphere </li> <li><code>delta</code> Grid spacing </li> <li><code>yo</code> Origin offset in the y direction </li> <li><code>iy</code> Index in the y direction </li> </ul>"},{"location":"BGFlood/_spherical_8cu/#function-calccm_1","title":"function calcCM","text":"<pre><code>template __host__ __device__ double calcCM (\n    double Radius,\n    double delta,\n    double yo,\n    int iy\n) \n</code></pre>"},{"location":"BGFlood/_spherical_8cu/#function-calccm_2","title":"function calcCM","text":"<pre><code>template __host__ __device__ float calcCM (\n    float Radius,\n    float delta,\n    float yo,\n    int iy\n) \n</code></pre>"},{"location":"BGFlood/_spherical_8cu/#function-calcfm","title":"function calcFM","text":"<p>Calculate the scale factor for the y face length in a spherical model. This function computes the scale factor based on the sphere's radius, grid spacing, origin offset and index in the y direction. Scale factor for y face length (x face lengh scale is always 1 in spherical model assuming that lat long are entered) </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T calcFM (\n    T Radius,\n    T delta,\n    T yo,\n    T iy\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>Radius</code> Radius of the sphere </li> <li><code>delta</code> Grid spacing </li> <li><code>yo</code> Origin offset in the y direction </li> <li><code>iy</code> Index in the y direction </li> </ul>"},{"location":"BGFlood/_spherical_8cu/#function-calcfm_1","title":"function calcFM","text":"<pre><code>template __host__ __device__ double calcFM (\n    double Radius,\n    double delta,\n    double yo,\n    double iy\n) \n</code></pre>"},{"location":"BGFlood/_spherical_8cu/#function-calcfm_2","title":"function calcFM","text":"<pre><code>template __host__ __device__ float calcFM (\n    float Radius,\n    float delta,\n    float yo,\n    float iy\n) \n</code></pre>"},{"location":"BGFlood/_spherical_8cu/#function-haversin","title":"function haversin","text":"<p>Classic Haversine formula to calculate great-circle distance between two points on a sphere. The function is too slow to use directly in BG_flood engine but is more usable (i.e. naive) for model setup. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T haversin (\n    T Radius,\n    T lon1,\n    T lat1,\n    T lon2,\n    T lat2\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>Radius</code> Radius of the sphere </li> <li><code>lon1</code> Longitude of the first point (in degrees) </li> <li><code>lat1</code> Latitude of the first point (in degrees) </li> <li><code>lon2</code> Longitude of the second point (in degrees) </li> <li><code>lat2</code> Latitude of the second point (in degrees) </li> </ul> <p>Returns:</p> <p>Great-circle distance between the two points </p>"},{"location":"BGFlood/_spherical_8cu/#function-spharea","title":"function spharea","text":"<p>Calculate the surface area of a spherical cap. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T spharea (\n    T Radius,\n    T lon,\n    T lat,\n    T dx\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>Radius</code> Radius of the sphere </li> <li><code>lon</code> Longitude of the center of the cap (in degrees) </li> <li><code>lat</code> Latitude of the center of the cap (in degrees) </li> <li><code>dx</code> Grid spacing (in degrees) </li> </ul> <p>Returns:</p> <p>Surface area of the spherical cap </p>"},{"location":"BGFlood/_spherical_8cu/#function-spharea_1","title":"function spharea","text":"<pre><code>template __host__ __device__ double spharea (\n    double Radius,\n    double lon,\n    double lat,\n    double dx\n) \n</code></pre>"},{"location":"BGFlood/_spherical_8cu/#function-spharea_2","title":"function spharea","text":"<pre><code>template __host__ __device__ float spharea (\n    float Radius,\n    float lon,\n    float lat,\n    float dx\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Spherical.cu</code></p>"},{"location":"BGFlood/_spherical_8cu_source/","title":"File Spherical.cu","text":""},{"location":"BGFlood/_spherical_8cu_source/#file-sphericalcu","title":"File Spherical.cu","text":"<p>File List &gt; src &gt; Spherical.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Spherical.h\"\n\n\n\ntemplate &lt;class T&gt; \n__host__ __device__ T calcCM(T Radius, T delta, T yo, int iy)\n{\n    T y = yo + (iy+0.5) * delta / Radius * T(180.0 / pi);\n    // THis should be the y of the face so fo the v face you need to remove 0.5*delta\n\n    T phi = y * T(pi / 180.0);\n\n    T dphi = delta / (T(2.0 * Radius));// dy*0.5f*pi/180.0f;\n\n    T cm = (sin(phi + dphi) - sin(phi - dphi)) / (2.0 * dphi);\n\n    return cm;\n}\ntemplate __host__ __device__ double calcCM(double Radius, double delta, double yo, int iy);\ntemplate __host__ __device__ float calcCM(float Radius, float delta, float yo, int iy);\n\n\ntemplate &lt;class T&gt; \n__host__ __device__  T calcFM(T Radius, T delta, T yo, T iy)\n{\n    T dy = delta / Radius * T(180.0 / pi);\n    T y = yo + iy * dy;\n    // THis should be the y of the face so fo the v face you need to remove 0.5*delta\n\n    T phi = y * T(pi / 180.0);\n\n    //T dphi = delta / (T(2.0 * Radius));// dy*0.5f*pi/180.0f;\n\n    T fmu = cos(phi);\n\n    return fmu;\n}\ntemplate __host__ __device__ double calcFM(double Radius, double delta, double yo, double iy);\ntemplate __host__ __device__ float calcFM(float Radius, float delta, float yo, float iy);\n\n\ntemplate &lt;class T&gt;\n__host__ __device__  T haversin(T Radius, T lon1, T lat1, T lon2, T lat2)\n{\n    T phi1, phi2, dphi, dlbda, a, c;\n    dphi = (lat2 - lat1) * T(pi / 180.0);\n    dlbda = (lon2 -lon1) * T(pi / 180.0);\n\n    phi1 = lat1 * T(pi / 180.0);\n    phi2 = lat2 * T(pi / 180.0);\n\n    T sindphid2 = sin(dphi / T(2.0));\n    T sindlbdad2 = sin(dlbda / T(2.0));\n\n    a = sindphid2 * sindphid2 + cos(phi1) * cos(phi2) * sindlbdad2 * sindlbdad2;\n\n    c = T(2.0) * atan2(sqrt(a), sqrt(T(1.0) - a));\n\n    return Radius * c;\n\n}\n\ntemplate &lt;class T&gt;\n__host__ __device__  T spharea(T Radius, T lon, T lat, T dx)\n{\n    T lon1, lon2, lat1, lat2;\n    lon1 = lon - T(0.5) * dx;\n    lon2 = lon + T(0.5) * dx;\n\n    lat1 = lat - T(0.5) * dx;\n    lat2 = lat + T(0.5) * dx;\n\n    T a, b, c;\n\n    a = haversin(Radius, lon1, lat1, lon2, lat1);\n    c = haversin(Radius, lon1, lat2, lon2, lat2);\n    b = haversin(Radius, lon1, lat1, lon1, lat2);\n\n    T Area = T(0.5) * (a * b + c * b);\n\n    return Area;\n\n}\ntemplate __host__ __device__  double spharea(double Radius, double lon, double lat, double dx);\ntemplate __host__ __device__  float spharea(float Radius, float lon, float lat, float dx);\n</code></pre>"},{"location":"BGFlood/_spherical_8h/","title":"File Spherical.h","text":""},{"location":"BGFlood/_spherical_8h/#file-sphericalh","title":"File Spherical.h","text":"<p>FileList &gt; src &gt; Spherical.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Kurganov.h\"</code></li> </ul>"},{"location":"BGFlood/_spherical_8h/#public-functions","title":"Public Functions","text":"Type Name __host__ __device__ T calcCM (T Radius, T delta, T yo, int iy) Calculate the scale factor for the y face length in a spherical model. This function computes the scale factor based on the sphere's radius, grid spacing, origin offset, and index in the y direction. Scale factor for y face length (x face lengh scale is always 1 in spherical model assuming that lat long are entered) __host__ __device__ T calcFM (T Radius, T delta, T yo, T iy) Calculate the scale factor for the y face length in a spherical model. This function computes the scale factor based on the sphere's radius, grid spacing, origin offset and index in the y direction. Scale factor for y face length (x face lengh scale is always 1 in spherical model assuming that lat long are entered) __host__ __device__ T spharea (T Radius, T lon, T lat, T dx) Calculate the surface area of a spherical cap."},{"location":"BGFlood/_spherical_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_spherical_8h/#function-calccm","title":"function calcCM","text":"<p>Calculate the scale factor for the y face length in a spherical model. This function computes the scale factor based on the sphere's radius, grid spacing, origin offset, and index in the y direction. Scale factor for y face length (x face lengh scale is always 1 in spherical model assuming that lat long are entered) </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T calcCM (\n    T Radius,\n    T delta,\n    T yo,\n    int iy\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>Radius</code> Radius of the sphere </li> <li><code>delta</code> Grid spacing </li> <li><code>yo</code> Origin offset in the y direction </li> <li><code>iy</code> Index in the y direction </li> </ul>"},{"location":"BGFlood/_spherical_8h/#function-calcfm","title":"function calcFM","text":"<p>Calculate the scale factor for the y face length in a spherical model. This function computes the scale factor based on the sphere's radius, grid spacing, origin offset and index in the y direction. Scale factor for y face length (x face lengh scale is always 1 in spherical model assuming that lat long are entered) </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T calcFM (\n    T Radius,\n    T delta,\n    T yo,\n    T iy\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>Radius</code> Radius of the sphere </li> <li><code>delta</code> Grid spacing </li> <li><code>yo</code> Origin offset in the y direction </li> <li><code>iy</code> Index in the y direction </li> </ul>"},{"location":"BGFlood/_spherical_8h/#function-spharea","title":"function spharea","text":"<p>Calculate the surface area of a spherical cap. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T spharea (\n    T Radius,\n    T lon,\n    T lat,\n    T dx\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>T</code> Data type (float or double) </li> </ul> <p>Parameters:</p> <ul> <li><code>Radius</code> Radius of the sphere </li> <li><code>lon</code> Longitude of the center of the cap (in degrees) </li> <li><code>lat</code> Latitude of the center of the cap (in degrees) </li> <li><code>dx</code> Grid spacing (in degrees) </li> </ul> <p>Returns:</p> <p>Surface area of the spherical cap </p> <p>The documentation for this class was generated from the following file <code>src/Spherical.h</code></p>"},{"location":"BGFlood/_spherical_8h_source/","title":"File Spherical.h","text":""},{"location":"BGFlood/_spherical_8h_source/#file-sphericalh","title":"File Spherical.h","text":"<p>File List &gt; src &gt; Spherical.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef SPHERICAL_H\n#define SPHERICAL_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"MemManagement.h\"\n#include \"Util_CPU.h\"\n#include \"Kurganov.h\"\n\ntemplate &lt;class T&gt; __host__ __device__ T calcCM(T Radius, T delta, T yo, int iy);\ntemplate &lt;class T&gt; __host__ __device__  T calcFM(T Radius, T delta, T yo, T iy);\ntemplate &lt;class T&gt; __host__ __device__  T spharea(T Radius, T lon, T lat, T dx);\n\n\n#endif\n</code></pre>"},{"location":"BGFlood/_testing_8cu/","title":"File Testing.cu","text":""},{"location":"BGFlood/_testing_8cu/#file-testingcu","title":"File Testing.cu","text":"<p>FileList &gt; src &gt; Testing.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Testing.h\"</code></li> </ul>"},{"location":"BGFlood/_testing_8cu/#public-functions","title":"Public Functions","text":"Type Name bool CPUGPUtest (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g)  void CompareCPUvsGPU (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g, std::vector&lt; std::string &gt; varlist, bool checkhalo) Compares the Variables in a CPU model and a GPU models This function is quite useful when checking both are identical enough one needs to provide a list (vector&lt;string&gt;) of variable to check. template void CompareCPUvsGPU&lt; double &gt; (Param XParam, Model&lt; double &gt; XModel, Model&lt; double &gt; XModel_g, std::vector&lt; std::string &gt; varlist, bool checkhalo)  template void CompareCPUvsGPU&lt; float &gt; (Param XParam, Model&lt; float &gt; XModel, Model&lt; float &gt; XModel_g, std::vector&lt; std::string &gt; varlist, bool checkhalo)  bool GaussianHumptest (T zsnit, int gpu, bool compare) Gaussian hump propagation test. template bool GaussianHumptest&lt; double &gt; (double zsnit, int gpu, bool compare)  template bool GaussianHumptest&lt; float &gt; (float zsnit, int gpu, bool compare)  bool LakeAtRest (Param XParam, Model&lt; T &gt; XModel) Test the lake at rest condition This function simulates the first predictive step and check whether the lake at rest is preserved otherwise it prints out to screen the cells (and neighbour) where the test fails. Forcing&lt; float &gt; MakValleyBathy (Param XParam, T slope, bool bottop, bool flip) Creates a valley bathymetry This function creates a valley bathymetry with a given slope and center It also adds a wall around the domain to avoid boundary effects. bool MassConserveSteepSlope (T zsnit, int gpu) River inflow mass conservation test on steep slope. template bool MassConserveSteepSlope&lt; double &gt; (double zsnit, int gpu)  template bool MassConserveSteepSlope&lt; float &gt; (float zsnit, int gpu)  bool Rainlossestest (T zsinit, int gpu, float alpha) Test the Initial and Continuous losses implementation This function tests the Initial Losses and Continuous Losses implementation a plain domain, under constant rain. The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsinit=0.0 is dry) and runs for 1s comparing results every 0.1s (that is approx 20 steps) bool Raintest (T zsnit, int gpu, float alpha, int engine) Test the rain input and mass conservation This function tests the mass conservation of the spacial injection (used to model rain on grid) The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsnit=0.0 is dry) and runs for 0.1s before comparing results with zsnit=0.1 that is approx 20 steps. bool Raintestinput (int gpu) Test the rain input options This function tests the different inputs for rain forcing. This test is based on the paper Aureli2020, the 3 slopes test with regional rain. The experiment has been presented in Iwagaki1955. The first test compares a time varying rain input using a uniform time serie forcing and a time varying 2D field (with same value). The second test check the 3D rain forcing (comparing it to expected values). std::vector&lt; float &gt; Raintestmap (int gpu, int dimf, T zinit) Test the rain input options and return the flux at the bottom of the slope This function return the flux at the bottom of the 3 part slope for different types of rain forcings using the test case based on Iwagaki1955. template std::vector&lt; float &gt; Raintestmap&lt; double &gt; (int gpu, int dimf, double Zsinit)  template std::vector&lt; float &gt; Raintestmap&lt; float &gt; (int gpu, int dimf, float Zsinit)  bool RiverOnBoundary (Param XParam, T slope, int Dir, int Bound_type)  bool RiverVolumeAdapt (Param XParam, T maxslope)  bool RiverVolumeAdapt (Param XParam, T slope, bool bottop, bool flip) Simulate a river flowing in a steep valley and heck the Volume conservation. bool Rivertest (T zsnit, int gpu) River inflow mass conservation test. template bool Rivertest&lt; double &gt; (double zsnit, int gpu)  template bool Rivertest&lt; float &gt; (float zsnit, int gpu)  int TestAIObnd (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g, bool bottop, bool flip, bool withaoi) Test the aoibnd option of the model This function tests the aoibnd option of the model on a valley domain with a small amount of water The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsinit=0.0 is dry) and runs for 20s. void TestFirsthalfstep (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Test the first half step of the model This function tests the first half step of the model on a sloping domain with a small amount of water The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsinit=0.0 is dry) and runs for 1s comparing results every 0.1s. bool TestFlexibleOutputTimes (int gpu, T ref, int scenario) Test the reading of flexible output times. int TestGradientSpeed (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Test the speed of different gradient functions This function fill an array with random values (0 - 1) bool TestHaloSpeed (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Test the speed of different halo filling functions This function test the speed and accuracy of a new gradient function gradient are only calculated for zb but assigned to different gradient variable for storage. int TestInstability (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Test the stability of the model This function tests the stability of the model on a sloping domain with a small amount of water The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsinit=0.0 is dry) and runs for 1s comparing results every 0.1s. bool TestMultiBathyRough (int gpu, T ref, int scenario) Test the reading of multiple bathymetry and roughness files. int TestPinMem (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Test the pin memory allocation and transfer between CPU and GPU This function allocates a pinned memory array on the CPU, fills it with values, transfers it to the GPU, modifies it there, and transfers it back to the CPU. It then checks that the values have been correctly modified. template int TestPinMem&lt; double &gt; (Param XParam, Model&lt; double &gt; XModel, Model&lt; double &gt; XModel_g)  template int TestPinMem&lt; float &gt; (Param XParam, Model&lt; float &gt; XModel, Model&lt; float &gt; XModel_g)  bool Testing (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Wrapping function for all the inbuilt test This function is the entry point to other function below. template bool Testing&lt; double &gt; (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; double &gt; XModel, Model&lt; double &gt; XModel_g)  template bool Testing&lt; float &gt; (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; float &gt; XModel, Model&lt; float &gt; XModel_g)  void TestingOutput (Param XParam, Model&lt; T &gt; XModel) OUTDATED ?Test the output functions of the model OUTDATED? This function tests the output functions of the model by running a simple simulation and writing the output to a netcdf file. template void TestingOutput&lt; double &gt; (Param XParam, Model&lt; double &gt; XModel)  template void TestingOutput&lt; float &gt; (Param XParam, Model&lt; float &gt; XModel)  void Testzbinit (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Test the zbinit option of the model This function tests the zbinit option of the model on a sloping domain with a small amount of water The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsinit=0.0 is dry) and runs for 1s comparing results every 0.1s. T ThackerBathy (T x, T y, T L, T D) create a parabolic bassin bool ThackerLakeAtRest (Param XParam, T zsinit) Simulate the Lake-at-rest in a parabolic bassin. template bool ThackerLakeAtRest&lt; double &gt; (Param XParam, double zsinit)  template bool ThackerLakeAtRest&lt; float &gt; (Param XParam, float zsinit)  T ValleyBathy (T x, T y, T slope, T center) create V shape Valley basin bool ZoneOutputTest (int nzones, T zsinit) Test the zoned output This function test the zoned output for a basic configuration. template bool ZoneOutputTest&lt; double &gt; (int nzones, double zsinit)  template bool ZoneOutputTest&lt; float &gt; (int nzones, float zsinit)  void alloc_init2Darray (float ** arr, int NX, int NY) Allocates and initializes a 2D array This function allocates and fills a 2D array with zero values. void copyBlockinfo2var (Param XParam, BlockP&lt; T &gt; XBlock, int * blkinfo, T * z) Copies block info to an output variable This function copies block info to an output variable This function is somewhat useful when checking bugs in the mesh refinement or coarsening one needs to provide a pointer(z) allocated on the CPU to store the clockinfo This fonction only works on CPU. template void copyBlockinfo2var&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, int * blkinfo, double * z)  template void copyBlockinfo2var&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, int * blkinfo, float * z)  void copyID2var (Param XParam, BlockP&lt; T &gt; XBlock, T * z) Copies block ID to an output variable This function copies block info to an output variable This function is somewhat useful when checking bugs in the mesh refinement or coarsening one needs to provide a pointer(z) allocated on the CPU to store the clockinfo This fonction only works on CPU. template void copyID2var&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z)  template void copyID2var&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z)  void diffArray (Param XParam, BlockP&lt; T &gt; XBlock, std::string varname, bool checkhalo, T * cpu, T * gpu, T * dummy, T * out)  void diffSource (Param XParam, BlockP&lt; T &gt; XBlock, T * Fqux, T * Su, T * output) Calculate The source term of the equation This function Calculate The source term of the equation. This function is quite useful when checking for Lake-at-Rest states This function requires an outputCPU pointers to save the result of the calculation. void diffdh (Param XParam, BlockP&lt; T &gt; XBlock, T * input, T * output, T * shuffle) Calculate The difference between adjacent cells in an array This function Calculates The difference in left and right flux terms. This function is quite useful when checking for Lake-at-Rest states This function requires a preallocated output and a shuffle (right side term) CPU pointers to save the result of teh calculation. void fillgauss (Param XParam, BlockP&lt; T &gt; XBlock, T amp, T * z) Fill an array with a gaussian bump This function fill an array with a gaussian bump. template void fillgauss&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double amp, double * z)  template void fillgauss&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float amp, float * z)  void fillrandom (Param XParam, BlockP&lt; T &gt; XBlock, T * z) Fill an array with random values This function fill an array with random values (0 - 1) template void fillrandom&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, double * z)  template void fillrandom&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, float * z)  void init3Darray (float *** arr, int rows, int cols, int depths) Initializes a 3D array This function fill a 3D array with zero values. bool reductiontest (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Reduction test Test the algorithm for reducing the global time step on the user grid layout. template bool reductiontest&lt; double &gt; (Param XParam, Model&lt; double &gt; XModel, Model&lt; double &gt; XModel_g)  template bool reductiontest&lt; float &gt; (Param XParam, Model&lt; float &gt; XModel, Model&lt; float &gt; XModel_g)  void testButtingerX (Param XParam, int ib, int ix, int iy, Model&lt; T &gt; XModel) Test the Buttinger scheme in X direction This function goes through the Buttinger scheme but instead of the normal output just prints all teh usefull values This function is/was used in the lake-at-rest verification. bool testboundaries (Param XParam, T maxslope)  void testkurganovX (Param XParam, int ib, int ix, int iy, Model&lt; T &gt; XModel) Test the Kurganov scheme in X direction This function goes through the Kurganov scheme but instead of the normal output just prints all teh usefull values This function is/was used in the lake-at-rest verification See also: void testButtingerX(Param XParam, int ib, int ix, int iy, Model&lt;T&gt; XModel) __global__ void vectoroffsetGPU (int nx, T offset, T * z) A simple kernel to add an offset to a vector This is used to test the pin memory allocation and transfer between CPU and GPU."},{"location":"BGFlood/_testing_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_testing_8cu/#function-cpugputest","title":"function CPUGPUtest","text":"<pre><code>template&lt;class T&gt;\nbool CPUGPUtest (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-comparecpuvsgpu","title":"function CompareCPUvsGPU","text":"<p>Compares the Variables in a CPU model and a GPU models This function is quite useful when checking both are identical enough one needs to provide a list (vector&lt;string&gt;) of variable to check. </p><pre><code>template&lt;class T&gt;\nvoid CompareCPUvsGPU (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g,\n    std::vector&lt; std::string &gt; varlist,\n    bool checkhalo\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure (CPU) </li> <li><code>XModel_g</code> Model structure (GPU) </li> <li><code>varlist</code> List of variable names to check (as in OutputVarMap) </li> <li><code>checkhalo</code> true if halo cells should be checked, false otherwise </li> </ul>"},{"location":"BGFlood/_testing_8cu/#function-comparecpuvsgpu-double","title":"function CompareCPUvsGPU&lt; double &gt;","text":"<pre><code>template void CompareCPUvsGPU&lt; double &gt; (\n    Param XParam,\n    Model &lt; double &gt; XModel,\n    Model &lt; double &gt; XModel_g,\n    std::vector&lt; std::string &gt; varlist,\n    bool checkhalo\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-comparecpuvsgpu-float","title":"function CompareCPUvsGPU&lt; float &gt;","text":"<pre><code>template void CompareCPUvsGPU&lt; float &gt; (\n    Param XParam,\n    Model &lt; float &gt; XModel,\n    Model &lt; float &gt; XModel_g,\n    std::vector&lt; std::string &gt; varlist,\n    bool checkhalo\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-gaussianhumptest","title":"function GaussianHumptest","text":"<p>Gaussian hump propagation test. </p><pre><code>template&lt;class T&gt;\nbool GaussianHumptest (\n    T zsnit,\n    int gpu,\n    bool compare\n) \n</code></pre> <p>!</p> <p>This function tests the full hydrodynamics model and compares the results with pre-conmputed (Hard wired) values The function creates it own model setup and mesh independantly to what the user might want to do The setup consist of a centrally located gaussian hump radiating away The test stops at an arbitrary time to compare with 8 values extracted from a identical run in basilisk This function also compares the result of the GPU and CPU code (until they diverge) </p> <p>Parameters:</p> <ul> <li><code>zsnit</code> Initial water surface elevation at the centre of the domain </li> <li><code>gpu</code> GPU device number to use (-1 for CPU only) </li> <li><code>compare</code> If true, compare GPU and CPU results (GPU required) </li> </ul> <p>Returns:</p> <p>true if the test passed (results within 1e-6 of reference values) </p>"},{"location":"BGFlood/_testing_8cu/#function-gaussianhumptest-double","title":"function GaussianHumptest&lt; double &gt;","text":"<pre><code>template bool GaussianHumptest&lt; double &gt; (\n    double zsnit,\n    int gpu,\n    bool compare\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-gaussianhumptest-float","title":"function GaussianHumptest&lt; float &gt;","text":"<pre><code>template bool GaussianHumptest&lt; float &gt; (\n    float zsnit,\n    int gpu,\n    bool compare\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-lakeatrest","title":"function LakeAtRest","text":"<p>Test the lake at rest condition This function simulates the first predictive step and check whether the lake at rest is preserved otherwise it prints out to screen the cells (and neighbour) where the test fails. </p><pre><code>template&lt;class T&gt;\nbool LakeAtRest (\n    Param XParam,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>!</p> <p>The function inherits the adaptation set in XParam so needs to be rerun to accnout for the different scenarios: * uniform level * flow from coasrse to fine * flow from fine to coarse This is done in the higher level wrapping function </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model variables </li> </ul> <p>Returns:</p> <p>true if test passed </p>"},{"location":"BGFlood/_testing_8cu/#function-makvalleybathy","title":"function MakValleyBathy","text":"<p>Creates a valley bathymetry This function creates a valley bathymetry with a given slope and center It also adds a wall around the domain to avoid boundary effects. </p><pre><code>template&lt;class T&gt;\nForcing &lt; float &gt; MakValleyBathy (\n    Param XParam,\n    T slope,\n    bool bottop,\n    bool flip\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters (only used to set the mesh size) </li> <li><code>slope</code> Slope of the valley </li> <li><code>bottop</code> true if the valley is oriented in the y direction (i.e. bottom/top boundaries), false if in the x direction (i.e. left/right boundaries) </li> <li><code>flip</code> true if the valley is oriented towards top or right, false if towards bottom or left </li> </ul> <p>Returns:</p> <p>A Forcing structure containing the bathymetry </p>"},{"location":"BGFlood/_testing_8cu/#function-massconservesteepslope","title":"function MassConserveSteepSlope","text":"<p>River inflow mass conservation test on steep slope. </p><pre><code>template&lt;class T&gt;\nbool MassConserveSteepSlope (\n    T zsnit,\n    int gpu\n) \n</code></pre> <p>!</p> <p>This function tests the mass conservation of the vertical injection (used for rivers) The function creates it own model setup and mesh independantly to what the user might want to do This starts with a initial water level (zsnit=0 is dry) and runs for 0.1s before comparing results with zsnit=0.1 that is approx 20 steps </p> <p>Parameters:</p> <ul> <li><code>zsnit</code> Initial water surface elevation at the centre of the domain </li> <li><code>gpu</code> GPU device number to use (-1 for CPU only) </li> </ul> <p>Returns:</p> <p>true if the test passed (mass conservation within 5%) </p>"},{"location":"BGFlood/_testing_8cu/#function-massconservesteepslope-double","title":"function MassConserveSteepSlope&lt; double &gt;","text":"<pre><code>template bool MassConserveSteepSlope&lt; double &gt; (\n    double zsnit,\n    int gpu\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-massconservesteepslope-float","title":"function MassConserveSteepSlope&lt; float &gt;","text":"<pre><code>template bool MassConserveSteepSlope&lt; float &gt; (\n    float zsnit,\n    int gpu\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-rainlossestest","title":"function Rainlossestest","text":"<p>Test the Initial and Continuous losses implementation This function tests the Initial Losses and Continuous Losses implementation a plain domain, under constant rain. The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsinit=0.0 is dry) and runs for 1s comparing results every 0.1s (that is approx 20 steps) </p><pre><code>template&lt;class T&gt;\nbool Rainlossestest (\n    T zsinit,\n    int gpu,\n    float alpha\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>zsinit</code> Initial water level </li> <li><code>gpu</code> GPU device to use (or -1 for CPU) </li> <li><code>alpha</code> Tolerance for the test (relative error) </li> </ul> <p>Returns:</p> <p>true if test passed </p>"},{"location":"BGFlood/_testing_8cu/#function-raintest","title":"function Raintest","text":"<p>Test the rain input and mass conservation This function tests the mass conservation of the spacial injection (used to model rain on grid) The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsnit=0.0 is dry) and runs for 0.1s before comparing results with zsnit=0.1 that is approx 20 steps. </p><pre><code>template&lt;class T&gt;\nbool Raintest (\n    T zsnit,\n    int gpu,\n    float alpha,\n    int engine\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>zsnit</code> Initial water level </li> <li><code>gpu</code> GPU device to use (or -1 for CPU) </li> <li><code>alpha</code> Slope of the bathymetry in % </li> <li><code>engine</code> Engine to use (0=non-hydrostatic, 1=hydrostatic) </li> </ul> <p>Returns:</p> <p>true if test passed </p>"},{"location":"BGFlood/_testing_8cu/#function-raintestinput","title":"function Raintestinput","text":"<p>Test the rain input options This function tests the different inputs for rain forcing. This test is based on the paper Aureli2020, the 3 slopes test with regional rain. The experiment has been presented in Iwagaki1955. The first test compares a time varying rain input using a uniform time serie forcing and a time varying 2D field (with same value). The second test check the 3D rain forcing (comparing it to expected values). </p><pre><code>bool Raintestinput (\n    int gpu\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>gpu</code> GPU device to use (or -1 for CPU) </li> </ul> <p>Returns:</p> <p>true if test passed </p>"},{"location":"BGFlood/_testing_8cu/#function-raintestmap","title":"function Raintestmap","text":"<p>Test the rain input options and return the flux at the bottom of the slope This function return the flux at the bottom of the 3 part slope for different types of rain forcings using the test case based on Iwagaki1955. </p><pre><code>template&lt;class T&gt;\nstd::vector&lt; float &gt; Raintestmap (\n    int gpu,\n    int dimf,\n    T zinit\n) \n</code></pre> <p>! \\fnstd::vector&lt;float&gt; Raintestmap(int gpu, int dimf, T zinit) </p> <p>Parameters:</p> <ul> <li><code>gpu</code> GPU device to use (or -1 for CPU) </li> <li><code>dimf</code> Dimension of the rain forcing (1=uniform, 3=2 </li> <li><code>zinit</code> Initial water level </li> </ul> <p>Returns:</p> <p>vector of flux at the bottom of the slope </p>"},{"location":"BGFlood/_testing_8cu/#function-raintestmap-double","title":"function Raintestmap&lt; double &gt;","text":"<pre><code>template std::vector&lt; float &gt; Raintestmap&lt; double &gt; (\n    int gpu,\n    int dimf,\n    double Zsinit\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-raintestmap-float","title":"function Raintestmap&lt; float &gt;","text":"<pre><code>template std::vector&lt; float &gt; Raintestmap&lt; float &gt; (\n    int gpu,\n    int dimf,\n    float Zsinit\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-riveronboundary","title":"function RiverOnBoundary","text":"<pre><code>template&lt;class T&gt;\nbool RiverOnBoundary (\n    Param XParam,\n    T slope,\n    int Dir,\n    int Bound_type\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-rivervolumeadapt","title":"function RiverVolumeAdapt","text":"<pre><code>template&lt;class T&gt;\nbool RiverVolumeAdapt (\n    Param XParam,\n    T maxslope\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-rivervolumeadapt_1","title":"function RiverVolumeAdapt","text":"<p>Simulate a river flowing in a steep valley and heck the Volume conservation. </p><pre><code>template&lt;class T&gt;\nbool RiverVolumeAdapt (\n    Param XParam,\n    T slope,\n    bool bottop,\n    bool flip\n) \n</code></pre> <p>!</p> <p>This function creates a dry steep valley topography to a given level and run the model for a while and checks that the Volume matches the theory.</p> <p>The function can test the water volume for 4 scenario each time: * left to right: bottop=false &amp; flip=true; * right to left: bottop=false &amp; flip=false; * bottom to top: bottop=true &amp; flip=true; * top to bottom: bottop=true &amp; flip=false;</p> <p>The function inherits the adaptation set in XParam so needs to be rerun to account for the different scenarios: * uniform level * flow from coarse to fine * flow from fine to coarse This is done in the higher level wrapping function </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>slope</code> slope of the valley sides </li> <li><code>bottop</code> if true the river flows bottom to top, if false left to right </li> <li><code>flip</code> if true the river flows right to left or top to bottom, if false left to right or bottom to top </li> </ul> <p>Returns:</p> <p>true if test passed </p>"},{"location":"BGFlood/_testing_8cu/#function-rivertest","title":"function Rivertest","text":"<p>River inflow mass conservation test. </p><pre><code>template&lt;class T&gt;\nbool Rivertest (\n    T zsnit,\n    int gpu\n) \n</code></pre> <p>!</p> <p>This function tests the mass conservation of the vertical injection (used for rivers) The function creates it own model setup and mesh independantly to what the user might want to do This starts with a initial water level (zsnit=0 is dry) and runs for 0.1s before comparing results with zsnit=0.1 that is approx 20 steps </p> <p>Parameters:</p> <ul> <li><code>zsnit</code> Initial water surface elevation at the centre of the domain </li> <li><code>gpu</code> GPU device number to use (-1 for CPU only) </li> </ul> <p>Returns:</p> <p>true if the test is successful (mass is conserved within 0.1% of the theoretical value) </p>"},{"location":"BGFlood/_testing_8cu/#function-rivertest-double","title":"function Rivertest&lt; double &gt;","text":"<pre><code>template bool Rivertest&lt; double &gt; (\n    double zsnit,\n    int gpu\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-rivertest-float","title":"function Rivertest&lt; float &gt;","text":"<pre><code>template bool Rivertest&lt; float &gt; (\n    float zsnit,\n    int gpu\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-testaiobnd","title":"function TestAIObnd","text":"<p>Test the aoibnd option of the model This function tests the aoibnd option of the model on a valley domain with a small amount of water The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsinit=0.0 is dry) and runs for 20s. </p><pre><code>template&lt;class T&gt;\nint TestAIObnd (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g,\n    bool bottop,\n    bool flip,\n    bool withaoi\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure (CPU) </li> <li><code>XModel_g</code> Model structure (GPU) </li> <li><code>bottop</code> true if the boundary condition to test is bottom/top, false for left/right </li> <li><code>flip</code> true if the boundary condition to test is top or right, false for bottom or left </li> <li><code>withaoi</code> true if the AOI is to be used, false otherwise </li> </ul> <p>Returns:</p> <p>1 if the test passed (i.e. the model runs without crashing and gives a reasonable result), 0 otherwise </p>"},{"location":"BGFlood/_testing_8cu/#function-testfirsthalfstep","title":"function TestFirsthalfstep","text":"<p>Test the first half step of the model This function tests the first half step of the model on a sloping domain with a small amount of water The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsinit=0.0 is dry) and runs for 1s comparing results every 0.1s. </p><pre><code>template&lt;class T&gt;\nvoid TestFirsthalfstep (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure (CPU) </li> <li><code>XModel_g</code> Model structure (GPU) </li> </ul>"},{"location":"BGFlood/_testing_8cu/#function-testflexibleoutputtimes","title":"function TestFlexibleOutputTimes","text":"<p>Test the reading of flexible output times. </p><pre><code>template&lt;class T&gt;\nbool TestFlexibleOutputTimes (\n    int gpu,\n    T ref,\n    int scenario\n) \n</code></pre> <p>This function creates a case set-up with a param file, read it. It tests the reading and default values used for times outputs. It checks the vectors for time outputs. </p> <p>Parameters:</p> <ul> <li><code>gpu</code> GPU to use (-1 for CPU only) </li> <li><code>ref</code> Reference elevation for the bathymetry files </li> <li><code>scenario</code> Scenario to test (not used here but could be used to test different input cases) </li> </ul> <p>Returns:</p> <p>true if test passed (i.e. the model runs without crashing and gives a reasonable result) </p>"},{"location":"BGFlood/_testing_8cu/#function-testgradientspeed","title":"function TestGradientSpeed","text":"<p>Test the speed of different gradient functions This function fill an array with random values (0 - 1) </p><pre><code>template&lt;class T&gt;\nint TestGradientSpeed (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>!</p> <p>This function test the spped and accuracy of a new gradient function gradient are only calculated for zb but assigned to different gradient variable for storage </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure (CPU) </li> <li><code>XModel_g</code> Model structure (GPU) </li> </ul> <p>Returns:</p> <p>1 if test passed </p>"},{"location":"BGFlood/_testing_8cu/#function-testhalospeed","title":"function TestHaloSpeed","text":"<p>Test the speed of different halo filling functions This function test the speed and accuracy of a new gradient function gradient are only calculated for zb but assigned to different gradient variable for storage. </p><pre><code>template&lt;class T&gt;\nbool TestHaloSpeed (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure (CPU) </li> <li><code>XModel_g</code> Model structure (GPU) </li> </ul> <p>Returns:</p> <p>true if test passed </p>"},{"location":"BGFlood/_testing_8cu/#function-testinstability","title":"function TestInstability","text":"<p>Test the stability of the model This function tests the stability of the model on a sloping domain with a small amount of water The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsinit=0.0 is dry) and runs for 1s comparing results every 0.1s. </p><pre><code>template&lt;class T&gt;\nint TestInstability (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure (CPU) </li> <li><code>XModel_g</code> Model structure (GPU) </li> </ul> <p>Returns:</p> <p>0 if test failed (i.e. unstable), 1 if test passed </p>"},{"location":"BGFlood/_testing_8cu/#function-testmultibathyrough","title":"function TestMultiBathyRough","text":"<p>Test the reading of multiple bathymetry and roughness files. </p><pre><code>template&lt;class T&gt;\nbool TestMultiBathyRough (\n    int gpu,\n    T ref,\n    int scenario\n) \n</code></pre> <p>!</p> <p>This function creates bathy and roughtness files and tests their reading (and interpolation) The objectif is particularly to test multi bathy/roughness inputs and value/file input.</p> <p>Parameters:</p> <ul> <li><code>gpu</code> GPU to use (-1 for CPU only) </li> <li><code>ref</code> Reference elevation for the bathymetry files </li> <li><code>scenario</code> Scenario to test (0: R1 in the middle of the domain, 1: R1 covering the whole domain) </li> </ul> <p>Returns:</p> <p>true if test passed (i.e. the model runs without crashing and gives a reasonable result) </p>"},{"location":"BGFlood/_testing_8cu/#function-testpinmem","title":"function TestPinMem","text":"<p>Test the pin memory allocation and transfer between CPU and GPU This function allocates a pinned memory array on the CPU, fills it with values, transfers it to the GPU, modifies it there, and transfers it back to the CPU. It then checks that the values have been correctly modified. </p><pre><code>template&lt;class T&gt;\nint TestPinMem (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters (only GPUDEVICE is used) </li> <li><code>XModel</code> Model structure (CPU) </li> <li><code>XModel_g</code> Model structure (GPU) </li> </ul> <p>Returns:</p> <p>1 if the test passed (i.e. the values are as expected), 0 otherwise </p>"},{"location":"BGFlood/_testing_8cu/#function-testpinmem-double","title":"function TestPinMem&lt; double &gt;","text":"<pre><code>template int TestPinMem&lt; double &gt; (\n    Param XParam,\n    Model &lt; double &gt; XModel,\n    Model &lt; double &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-testpinmem-float","title":"function TestPinMem&lt; float &gt;","text":"<pre><code>template int TestPinMem&lt; float &gt; (\n    Param XParam,\n    Model &lt; float &gt; XModel,\n    Model &lt; float &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-testing","title":"function Testing","text":"<p>Wrapping function for all the inbuilt test This function is the entry point to other function below. </p><pre><code>template&lt;class T&gt;\nbool Testing (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Test 0 is a gausian hump propagating on a flat uniorm cartesian mesh (both GPU and CPU version tested) Test 1 is vertical discharge on a flat uniorm cartesian mesh (GPU or CPU version) Test 2 Gaussian wave on Cartesian grid (same as test 0): CPU vs GPU (GPU required) Test 3 Test Reduction algorithm Test 4 Boundary condition test Test 5 Lake at rest test for Ardusse/kurganov reconstruction/scheme Test 6 Mass conservation on a slope Test 7 Mass conservation with rain fall on grid Test 8 Rain Map forcing (comparison map and Time Serie and test case with slope and non-uniform rain map) Test 9 Zoned output (test zoned outputs with adaptative grid) Test 10 Initial Loss / Continuous Loss on a slope, under uniform rain Test 11 Wet/dry Instability test with Conserve Elevation Test 12 Calendar time to second conversion Test 13 Multi bathy and roughness map input Test 14 Test AOI bnds aswall to start with Test 15 Flexible times reading</p> <p>Test 99 Run all the test with test number &lt; 99.</p> <p>The following test are not independant, they are tools to check or debug a personnal case Test 998 Compare resuts between the CPU and GPU Flow functions (GPU required) Test 999 Run the main loop and engine in debug mode</p> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XForcing</code> Forcing data structure </li> <li><code>XModel</code> Host model data structure </li> <li><code>XModel_g</code> Device model data structure </li> </ul> <p>Returns:</p> <p>true if all the tests passed </p>"},{"location":"BGFlood/_testing_8cu/#function-testing-double","title":"function Testing&lt; double &gt;","text":"<pre><code>template bool Testing&lt; double &gt; (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; double &gt; XModel,\n    Model &lt; double &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-testing-float","title":"function Testing&lt; float &gt;","text":"<pre><code>template bool Testing&lt; float &gt; (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; float &gt; XModel,\n    Model &lt; float &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-testingoutput","title":"function TestingOutput","text":"<p>OUTDATED ?Test the output functions of the model OUTDATED? This function tests the output functions of the model by running a simple simulation and writing the output to a netcdf file. </p><pre><code>template&lt;class T&gt;\nvoid TestingOutput (\n    Param XParam,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure (CPU) </li> </ul>"},{"location":"BGFlood/_testing_8cu/#function-testingoutput-double","title":"function TestingOutput&lt; double &gt;","text":"<pre><code>template void TestingOutput&lt; double &gt; (\n    Param XParam,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-testingoutput-float","title":"function TestingOutput&lt; float &gt;","text":"<pre><code>template void TestingOutput&lt; float &gt; (\n    Param XParam,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-testzbinit","title":"function Testzbinit","text":"<p>Test the zbinit option of the model This function tests the zbinit option of the model on a sloping domain with a small amount of water The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsinit=0.0 is dry) and runs for 1s comparing results every 0.1s. </p><pre><code>template&lt;class T&gt;\nvoid Testzbinit (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure (CPU) </li> <li><code>XModel_g</code> Model structure (GPU) </li> </ul>"},{"location":"BGFlood/_testing_8cu/#function-thackerbathy","title":"function ThackerBathy","text":"<p>create a parabolic bassin </p><pre><code>template&lt;class T&gt;\nT ThackerBathy (\n    T x,\n    T y,\n    T L,\n    T D\n) \n</code></pre> <p>!</p> <p>This function creates a parabolic bassin. The function returns a single value of the bassin</p> <p>Borrowed from Buttinger et al. 2019.</p>"},{"location":"BGFlood/_testing_8cu/#reference","title":"Reference","text":"<p>Buttinger-Kreuzhuber, A., Horv\u00e1th, Z., Noelle, S., Bl\u00f6schl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89\u2013108, 2019. </p> <p>Parameters:</p> <ul> <li><code>x</code> x coordinate </li> <li><code>y</code> y coordinate </li> <li><code>L</code> characteristic length scale of the bassin </li> <li><code>D</code> characteristic depth of the bassin </li> </ul> <p>Returns:</p> <p>the depth of the basin at point (x,y) </p>"},{"location":"BGFlood/_testing_8cu/#function-thackerlakeatrest","title":"function ThackerLakeAtRest","text":"<p>Simulate the Lake-at-rest in a parabolic bassin. </p><pre><code>template&lt;class T&gt;\nbool ThackerLakeAtRest (\n    Param XParam,\n    T zsinit\n) \n</code></pre> <p>This function creates a parabolic bassin filled to a given level and run the modle for a while and checks that the velocities in the lake remain very small thus verifying the well-balancedness of teh engine and the Lake-at-rest condition.</p> <p>Borrowed from Buttinger et al. 2019.</p>"},{"location":"BGFlood/_testing_8cu/#reference_1","title":"Reference","text":"<p>Buttinger-Kreuzhuber, A., Horv\u00e1th, Z., Noelle, S., Bl\u00f6schl, G., and Waser, J.: A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography, Advances in water resources, 127, 89\u2013108, 2019. </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>zsinit</code> initial water surface elevation </li> </ul> <p>Returns:</p> <p>true if test passed </p>"},{"location":"BGFlood/_testing_8cu/#function-thackerlakeatrest-double","title":"function ThackerLakeAtRest&lt; double &gt;","text":"<pre><code>template bool ThackerLakeAtRest&lt; double &gt; (\n    Param XParam,\n    double zsinit\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-thackerlakeatrest-float","title":"function ThackerLakeAtRest&lt; float &gt;","text":"<pre><code>template bool ThackerLakeAtRest&lt; float &gt; (\n    Param XParam,\n    float zsinit\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-valleybathy","title":"function ValleyBathy","text":"<p>create V shape Valley basin </p><pre><code>template&lt;class T&gt;\nT ValleyBathy (\n    T x,\n    T y,\n    T slope,\n    T center\n) \n</code></pre> <p>!</p> <p>This function creates a simple V shape Valley basin</p> <p>Parameters:</p> <ul> <li><code>x</code> x coordinate </li> <li><code>y</code> y coordinate </li> <li><code>slope</code> slope of the valley sides </li> <li><code>center</code> x coordinate of the valley center </li> </ul> <p>Returns:</p> <p>the depth of the basin at point (x,y) </p>"},{"location":"BGFlood/_testing_8cu/#function-zoneoutputtest","title":"function ZoneOutputTest","text":"<p>Test the zoned output This function test the zoned output for a basic configuration. </p><pre><code>template&lt;class T&gt;\nbool ZoneOutputTest (\n    int nzones,\n    T zsinit\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>nzones</code> Number of zones to test (1 or 3) </li> <li><code>zsinit</code> Initial water level </li> </ul> <p>Returns:</p> <p>true if test passed </p>"},{"location":"BGFlood/_testing_8cu/#function-zoneoutputtest-double","title":"function ZoneOutputTest&lt; double &gt;","text":"<pre><code>template bool ZoneOutputTest&lt; double &gt; (\n    int nzones,\n    double zsinit\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-zoneoutputtest-float","title":"function ZoneOutputTest&lt; float &gt;","text":"<pre><code>template bool ZoneOutputTest&lt; float &gt; (\n    int nzones,\n    float zsinit\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-alloc_init2darray","title":"function alloc_init2Darray","text":"<p>Allocates and initializes a 2D array This function allocates and fills a 2D array with zero values. </p><pre><code>void alloc_init2Darray (\n    float ** arr,\n    int NX,\n    int NY\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>arr</code> Pointer to the 2D array </li> <li><code>NX</code> Number of rows </li> <li><code>NY</code> Number of columns </li> </ul>"},{"location":"BGFlood/_testing_8cu/#function-copyblockinfo2var","title":"function copyBlockinfo2var","text":"<p>Copies block info to an output variable This function copies block info to an output variable This function is somewhat useful when checking bugs in the mesh refinement or coarsening one needs to provide a pointer(z) allocated on the CPU to store the clockinfo This fonction only works on CPU. </p><pre><code>template&lt;class T&gt;\nvoid copyBlockinfo2var (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    int * blkinfo,\n    T * z\n) \n</code></pre> <p>!</p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters (only nblk, blkwidth, xo, yo, xmax, ymax and dx are used) </li> <li><code>XBlock</code> Block parameters (only active is used) </li> <li><code>blkinfo</code> Block information array (CPU) </li> <li><code>z</code> Array to fill </li> </ul>"},{"location":"BGFlood/_testing_8cu/#function-copyblockinfo2var-double","title":"function copyBlockinfo2var&lt; double &gt;","text":"<pre><code>template void copyBlockinfo2var&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    int * blkinfo,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-copyblockinfo2var-float","title":"function copyBlockinfo2var&lt; float &gt;","text":"<pre><code>template void copyBlockinfo2var&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    int * blkinfo,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-copyid2var","title":"function copyID2var","text":"<p>Copies block ID to an output variable This function copies block info to an output variable This function is somewhat useful when checking bugs in the mesh refinement or coarsening one needs to provide a pointer(z) allocated on the CPU to store the clockinfo This fonction only works on CPU. </p><pre><code>template&lt;class T&gt;\nvoid copyID2var (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>!</p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters (only nblk, blkwidth, xo, yo, xmax, ymax and dx are used) </li> <li><code>XBlock</code> Block parameters (only active is used) </li> <li><code>z</code> Array to fill </li> </ul>"},{"location":"BGFlood/_testing_8cu/#function-copyid2var-double","title":"function copyID2var&lt; double &gt;","text":"<pre><code>template void copyID2var&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-copyid2var-float","title":"function copyID2var&lt; float &gt;","text":"<pre><code>template void copyID2var&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-diffarray","title":"function diffArray","text":"<pre><code>template&lt;class T&gt;\nvoid diffArray (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    std::string varname,\n    bool checkhalo,\n    T * cpu,\n    T * gpu,\n    T * dummy,\n    T * out\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-diffsource","title":"function diffSource","text":"<p>Calculate The source term of the equation This function Calculate The source term of the equation. This function is quite useful when checking for Lake-at-Rest states This function requires an outputCPU pointers to save the result of the calculation. </p><pre><code>template&lt;class T&gt;\nvoid diffSource (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * Fqux,\n    T * Su,\n    T * output\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters (only nblk and blkwidth are used) </li> <li><code>XBlock</code> Block parameters (only active are used) </li> <li><code>Fqux</code> Input array </li> <li><code>Su</code> Input array </li> <li><code>output</code> Output array (source term) </li> </ul>"},{"location":"BGFlood/_testing_8cu/#function-diffdh","title":"function diffdh","text":"<p>Calculate The difference between adjacent cells in an array This function Calculates The difference in left and right flux terms. This function is quite useful when checking for Lake-at-Rest states This function requires a preallocated output and a shuffle (right side term) CPU pointers to save the result of teh calculation. </p><pre><code>template&lt;class T&gt;\nvoid diffdh (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * input,\n    T * output,\n    T * shuffle\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters (only nblk and blkwidth are used) </li> <li><code>XBlock</code> Block parameters (only active are used) </li> <li><code>input</code> Input array </li> <li><code>output</code> Output array (difference) </li> <li><code>shuffle</code> Output array (right side term) </li> </ul>"},{"location":"BGFlood/_testing_8cu/#function-fillgauss","title":"function fillgauss","text":"<p>Fill an array with a gaussian bump This function fill an array with a gaussian bump. </p><pre><code>template&lt;class T&gt;\nvoid fillgauss (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T amp,\n    T * z\n) \n</code></pre> <p>!</p> <p>borrowed/adapted from Basilisk test (?) </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters (only nblk, blkwidth, xo, yo, xmax, ymax and dx are used) </li> <li><code>XBlock</code> Block parameters (only active, level, xo and yo are used) </li> <li><code>amp</code> Amplitude of the gaussian bump </li> <li><code>z</code> Array to fill </li> </ul>"},{"location":"BGFlood/_testing_8cu/#function-fillgauss-double","title":"function fillgauss&lt; double &gt;","text":"<pre><code>template void fillgauss&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double amp,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-fillgauss-float","title":"function fillgauss&lt; float &gt;","text":"<pre><code>template void fillgauss&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float amp,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-fillrandom","title":"function fillrandom","text":"<p>Fill an array with random values This function fill an array with random values (0 - 1) </p><pre><code>template&lt;class T&gt;\nvoid fillrandom (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters (only nblk and blkwidth are used) </li> <li><code>XBlock</code> Block parameters (only active are used) </li> <li><code>z</code> Array to fill </li> </ul>"},{"location":"BGFlood/_testing_8cu/#function-fillrandom-double","title":"function fillrandom&lt; double &gt;","text":"<pre><code>template void fillrandom&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    double * z\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-fillrandom-float","title":"function fillrandom&lt; float &gt;","text":"<pre><code>template void fillrandom&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    float * z\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-init3darray","title":"function init3Darray","text":"<p>Initializes a 3D array This function fill a 3D array with zero values. </p><pre><code>void init3Darray (\n    float *** arr,\n    int rows,\n    int cols,\n    int depths\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>arr</code> Pointer to the 3D array </li> <li><code>rows</code> Number of rows </li> <li><code>cols</code> Number of columns </li> <li><code>depths</code> Number of depths </li> </ul>"},{"location":"BGFlood/_testing_8cu/#function-reductiontest","title":"function reductiontest","text":"<p>Reduction test Test the algorithm for reducing the global time step on the user grid layout. </p><pre><code>template&lt;class T&gt;\nbool reductiontest (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> CPU model </li> <li><code>XModel_g</code> GPU model </li> </ul> <p>Returns:</p> <p>true if test passed </p>"},{"location":"BGFlood/_testing_8cu/#function-reductiontest-double","title":"function reductiontest&lt; double &gt;","text":"<pre><code>template bool reductiontest&lt; double &gt; (\n    Param XParam,\n    Model &lt; double &gt; XModel,\n    Model &lt; double &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-reductiontest-float","title":"function reductiontest&lt; float &gt;","text":"<pre><code>template bool reductiontest&lt; float &gt; (\n    Param XParam,\n    Model &lt; float &gt; XModel,\n    Model &lt; float &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-testbuttingerx","title":"function testButtingerX","text":"<p>Test the Buttinger scheme in X direction This function goes through the Buttinger scheme but instead of the normal output just prints all teh usefull values This function is/was used in the lake-at-rest verification. </p><pre><code>template&lt;class T&gt;\nvoid testButtingerX (\n    Param XParam,\n    int ib,\n    int ix,\n    int iy,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>!</p> <p>See also: void testkurganovX(Param XParam, int ib, int ix, int iy, Model&lt;T&gt; XModel) </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>ib</code> Block index </li> <li><code>ix</code> X index in the block </li> <li><code>iy</code> Y index in the block </li> <li><code>XModel</code> Model variables </li> </ul>"},{"location":"BGFlood/_testing_8cu/#function-testboundaries","title":"function testboundaries","text":"<pre><code>template&lt;class T&gt;\nbool testboundaries (\n    Param XParam,\n    T maxslope\n) \n</code></pre>"},{"location":"BGFlood/_testing_8cu/#function-testkurganovx","title":"function testkurganovX","text":"<p>Test the Kurganov scheme in X direction This function goes through the Kurganov scheme but instead of the normal output just prints all teh usefull values This function is/was used in the lake-at-rest verification See also: void testButtingerX(Param XParam, int ib, int ix, int iy, Model&lt;T&gt; XModel) </p><pre><code>template&lt;class T&gt;\nvoid testkurganovX (\n    Param XParam,\n    int ib,\n    int ix,\n    int iy,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>ib</code> Block index </li> <li><code>ix</code> X index in the block </li> <li><code>iy</code> Y index in the block </li> <li><code>XModel</code> Model variables </li> </ul>"},{"location":"BGFlood/_testing_8cu/#function-vectoroffsetgpu","title":"function vectoroffsetGPU","text":"<p>A simple kernel to add an offset to a vector This is used to test the pin memory allocation and transfer between CPU and GPU. </p><pre><code>template&lt;class T&gt;\n__global__ void vectoroffsetGPU (\n    int nx,\n    T offset,\n    T * z\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>nx</code> Number of elements in the vector </li> <li><code>offset</code> Offset to add </li> <li><code>z</code> Vector to modify (input and output) </li> </ul> <p>Template parameters:</p> <ul> <li><code>T</code> Data type of the vector (float or double) </li> </ul> <p>The documentation for this class was generated from the following file <code>src/Testing.cu</code></p>"},{"location":"BGFlood/_testing_8cu_source/","title":"File Testing.cu","text":""},{"location":"BGFlood/_testing_8cu_source/#file-testingcu","title":"File Testing.cu","text":"<p>File List &gt; src &gt; Testing.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Testing.h\"\n\n\n\n\ntemplate &lt;class T&gt; bool Testing(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n\n    bool isfailed = false;\n    std::string result;\n\n    log(\"\\nRunning internal test(s):\");\n\n    int mytest;\n    mytest = XParam.test;\n    if (XParam.test == 99)\n    {\n        mytest = 0;\n    }\n\n    while (mytest &lt;= XParam.test)\n    {\n        if (mytest == 0)\n        {\n            bool bumptest, bumptestComp;\n            bool bumptestGPU = true;\n            // Test 0 is pure bump test\n            log(\"\\t ### Gaussian wave on Cartesian grid ###\");\n            //set gpu is -1 for cpu test\n\n            bumptest = GaussianHumptest(0.1, -1, false);\n            result = bumptest ? \"successful\" : \"failed\";\n            log(\"\\t\\tCPU test: \" + result);\n\n            // If original XParam tried to use GPU we try also\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                bumptestGPU = GaussianHumptest(0.1, XParam.GPUDEVICE, false);\n                result = bumptestGPU ? \"successful\" : \"failed\";\n                log(\"\\t\\tGPU test: \" + result);\n\n                if (!bumptestGPU)\n                {\n                    bumptestComp = GaussianHumptest(0.1, XParam.GPUDEVICE, true);\n                }\n            }\n            isfailed = ((bumptest == true) &amp;&amp; (bumptestGPU == true)) ? false : true;\n        }\n        if (mytest == 1)\n        {\n            bool rivertest;\n            // Test 1 is vertical discharge on a flat uniorm cartesian mesh (GPU and CU version)\n            log(\"\\t ### River Mass conservation grid ###\");\n            rivertest = Rivertest(0.1, -1);\n            result = rivertest ? \"successful\" : \"failed\";\n            log(\"\\t\\tCPU test: \" + result);\n            isfailed = (!rivertest || isfailed) ? true : false;\n\n            log(\" \\t\\t\\t GPU device= \" + std::to_string(XParam.GPUDEVICE));\n\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                rivertest = Rivertest(0.1, XParam.GPUDEVICE);\n                result = rivertest ? \"successful\" : \"failed\";\n                log(\"\\t\\tGPU test: \" + result);\n                isfailed = (!rivertest || isfailed) ? true : false;\n            }\n\n            rivertest = RiverVolumeAdapt(XParam, T(0.4));\n            result = rivertest ? \"successful\" : \"failed\";\n            log(\"\\t\\tRiver Volume Adapt: \" + result);\n            isfailed = (!rivertest || isfailed) ? true : false;\n\n        }\n        if (mytest == 2)\n        {\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                bool GPUvsCPUtest;\n                log(\"\\t### Gaussian wave on Cartesian grid: CPU vs GPU ###\");\n                GPUvsCPUtest = GaussianHumptest(0.1, XParam.GPUDEVICE, true);\n                result = GPUvsCPUtest ? \"successful\" : \"failed\";\n                log(\"\\t\\tCPU vs GPU test: \" + result);\n                isfailed = (!GPUvsCPUtest || isfailed) ? true : false;\n            }\n            else\n            {\n                log(\"Specify GPU device to run test 2 (CPU vs GPU comparison)\");\n            }\n        }\n        if (mytest == 3)\n        {\n\n            bool testresults;\n            bool testreduction = true;\n\n            // Iterate this test niter times:\n            int niter = 1000;\n            srand(time(0));\n            log(\"\\t### Reduction Test ###\");\n            for (int iter = 0; iter &lt; niter; iter++)\n            {\n                testresults = reductiontest(XParam, XModel, XModel_g);\n                testreduction = testreduction &amp;&amp; testresults;\n            }\n\n            result = testreduction ? \"successful\" : \"failed\";\n            log(\"\\t\\tReduction test: \" + result);\n            isfailed = (!testreduction || isfailed) ? true : false;\n\n        }\n        if (mytest == 4)\n        {\n            log(\"\\t### Boundary Test ###\");\n            bool testBound = testboundaries(XParam, T(0.1));\n            result = testBound ? \"successful\" : \"failed\";\n            isfailed = (!testBound || isfailed) ? true : false;\n            log(\"\\t\\tboundaries test: \" + result);\n        }\n        if (mytest == 5)\n        {\n            log(\"\\t### Lake-at-rest Test ###\");\n            bool testTLAR = ThackerLakeAtRest(XParam, T(0.0));\n            result = testTLAR ? \"successful\" : \"failed\";\n            isfailed = (!testTLAR || isfailed) ? true : false;\n            log(\"\\t\\tThaker lake-at-rest test: \" + result);\n            testTLAR = LakeAtRest(XParam, XModel);\n            isfailed = (!testTLAR || isfailed) ? true : false;\n            log(\"\\t\\tLake-at-rest test: \" + result);\n        }\n        if (mytest == 6)\n        {\n            log(\"\\t### Mass conservation Test ###\");\n            bool testSteepSlope = MassConserveSteepSlope(XParam.zsinit, XParam.GPUDEVICE);\n            result = testSteepSlope ? \"successful\" : \"failed\";\n            isfailed = (!testSteepSlope || isfailed) ? true : false;\n            log(\"\\t\\tMass conservation test: \" + result);\n        }\n        if (mytest == 7)\n        {\n            bool testrainGPU, testrainCPU;\n            /* Test 7 is homogeneous rain on a uniform slope for cartesian mesh (GPU and CPU version)\n             The input parameters are :\n                    - the initial water level (zs)\n                    - GPU option\n                    - the slope (%)\n            */\n            log(\"\\t### Homogeneous rain on grid Mass conservation test ###\");\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                testrainGPU = Raintest(0.0, 0, 10, XParam.engine);\n                result = testrainGPU ? \"successful\" : \"failed\";\n                log(\"\\t\\tHomogeneous rain on grid test GPU: \" + result);\n            }\n            testrainCPU = Raintest(0.0, -1, 10, XParam.engine);\n            result = testrainCPU ? \"successful\" : \"failed\";\n            log(\"\\t\\tHomogeneous rain on grid test CPU: \" + result);\n            isfailed = (!testrainCPU || !testrainGPU || isfailed) ? true : false;\n        }\n        if (XParam.test == 8)\n        {\n            bool raintest2;\n            /* Test 8 is non-homogeneous rain on a non-uniform slope for cartesian mesh (GPU and CPU version)\n             It is based on a teste case from litterature (Iwagaki1955) and tests the different\n             rain inputs (time serie for 1D input or netCDF file).\n            */\n\n            log(\"\\t non-uniform rain forcing on slope based on Aureli2020\");\n            int gpu = 0;\n            raintest2 = Raintestinput(gpu);\n            result = raintest2 ? \"successful\" : \"failed\";\n            log(\"\\t\\tNon-uniform rain forcing : \" + result);\n        }\n        if (mytest == 9)\n        {\n            bool testzoneOutDef, testzoneOutUser;\n            /* Test 9 is basic configuration to test the zoned outputs, with different resolutions.\n             The default (without zoned defined by user) configuration is tested.\n             Then, the creation of 3 zones is then tested(whole, zoned complexe, zoned with part of the levels).\n             The size of the created nc files is used to verified this fonctionnality.\n             Parameter: nbzones: number of zones for output defined by the user\n                        zsinit: initial water elevation\n            */\n\n            log(\"\\t### Test zoned output ###\");\n            int nbzones = 0;\n            T zsinit = 0.01;\n            testzoneOutDef = ZoneOutputTest(nbzones, zsinit);\n            result = testzoneOutDef ? \"successful\" : \"failed\";\n            log(\"\\n\\nDefault zoned Outputs: \" + result);\n            nbzones = 3; // 3 only\n            testzoneOutUser = ZoneOutputTest(nbzones, zsinit);\n            result = testzoneOutUser ? \"successful\" : \"failed\";\n            log(\"\\n\\nUser defined zones Outputs: \" + result);\n            isfailed = (!testzoneOutDef || !testzoneOutUser || isfailed) ? true : false;\n        }\n        if (mytest == 10)\n        {\n\n            bool testrainlossesGPU, testrainlossesCPU;\n            /* Test 10 is to test the Initial / Continuous Losses of rain, on a uniform slope, under uniform rain\n            for cartesian mesh (GPU and CPU version)\n             The input parameters are :\n                    - the initial water level (zs)\n                    - GPU option\n                    - the slope (%)\n            */\n            log(\"\\t### IL-CL Rain losses test on GPU ###\");\n            testrainlossesGPU = Rainlossestest(0.0, 0, 10);\n            result = testrainlossesGPU ? \"successful\" : \"failed\";\n            log(\"\\n\\n\\t IL-CL Rain losses test GPU: \" + result);\n            testrainlossesCPU = Rainlossestest(0.0, -1, 10);\n            result = testrainlossesCPU ? \"successful\" : \"failed\";\n            log(\"\\n\\n\\t IL-CL Rain losses test CPU: \" + result);\n            isfailed = (!testrainlossesCPU || !testrainlossesGPU || isfailed) ? true : false;\n        }\n        if (mytest == 11)\n        {\n            bool instab;\n            log(\"\\t### Wet/dry Instability test with Conserve Elevation ###\");\n            instab = TestInstability(XParam, XModel, XModel_g);\n            result = instab ? \"successful\" : \"failed\";\n            log(\"\\t\\tWet/dry Instability test : \" + result);\n        }\n\n        if (mytest == 12)\n        {\n            /* Test 12 is to test the calendar time to second conversion\n                This test will fail if the system or compiler does not suport long long\n\n            */\n            bool timetest;\n            timetest = testime1(1) &amp;&amp; testime2(2);\n            result = timetest ? \"successful\" : \"failed\";\n            log(\"\\t\\tCalendar time test : \" + result);\n        }\n\n        if (mytest == 13)\n        {\n            /* Test 13 is to test the input of different roughness maps (and different bathymetry at the same time)\n                Test1: 2 DEM and 2 roughness netcdf files are created and saved; then read.\n                    The max / min values are check to see if the z/z0 maps are created as expected\n                Test2: A roughness file name is changed to have a number in first position. We check that the\n                    file is read and not the number taken as z0 value.\n                Test3: A roughness is entered as a value, test that it is implemented for the whole domain.\n                Test4 :  Test value input for initial loss / continuous loss\n            */\n            bool RoughBathyresult, RoughInput, RoughtInputnumber, ILCLInputnumber;\n            log(\"\\t### Different bathy and different roughness file inputs ###\");\n            RoughBathyresult = TestMultiBathyRough(0, 0.0, 0);//&amp;&amp; TestRoughness(XParam, XModel, XModel_g);\n            result = RoughBathyresult ? \"successful\" : \"failed\";\n            log(\"\\t\\t ##### \\n\");\n            log(\"\\t\\t ##### Different Bathy and Roughness test : \" + result + \"\\n\");\n            RoughInput = TestMultiBathyRough(0, 0.0, 1);//&amp;&amp; TestRoughness(XParam, XModel, XModel_g);\n            result = RoughInput ? \"successful\" : \"failed\";\n            log(\"\\t\\t ##### \\n\");\n            log(\"\\t\\t ##### Roughness file name test : \" + result + \"\\n\");\n            RoughtInputnumber = TestMultiBathyRough(0, 0.0, 2);//&amp;&amp; TestRoughness(XParam, XModel, XModel_g);\n            result = RoughtInputnumber ? \"successful\" : \"failed\";\n            log(\"\\t\\t ##### \\n\");\n            log(\"\\t\\t ##### Roughness value input test : \" + result + \"\\n\");\n            log(\"\\t\\t ##### \\n\");\n            ILCLInputnumber = TestMultiBathyRough(0, 0.0, 3);//&amp;&amp; TestRoughness(XParam, XModel, XModel_g);\n            result = ILCLInputnumber ? \"successful\" : \"failed\";\n            log(\"\\t\\t ##### \\n\");\n            log(\"\\t\\t ##### Initial Loss / Continuous Loss value input test : \" + result + \"\\n\");\n            log(\"\\t\\t ##### \\n\");\n            isfailed = (!RoughBathyresult || !RoughInput || !RoughtInputnumber || !ILCLInputnumber || isfailed) ? true : false;\n        }\n\n        if (mytest == 14)\n        {\n            /* Test 14  This test AOI bnds aswall to start with\n\n            */\n            bool wallbndleft, wallbndright, wallbndbot, wallbndtop;\n            log(\"\\t###AOI bnd wall test ###\");\n            wallbndleft = TestAIObnd(XParam, XModel, XModel_g, false, false, false);\n            wallbndright = TestAIObnd(XParam, XModel, XModel_g, false, true, false);\n            wallbndbot = TestAIObnd(XParam, XModel, XModel_g, true, false, false);\n            wallbndtop = TestAIObnd(XParam, XModel, XModel_g, true, true, false);\n            result = (wallbndleft &amp; wallbndright &amp; wallbndbot &amp; wallbndtop) ? \"successful\" : \"failed\";\n            log(\"\\t\\tBBox bnd wall test : \" + result);\n            wallbndleft = TestAIObnd(XParam, XModel, XModel_g, false, false, true);\n            wallbndright = TestAIObnd(XParam, XModel, XModel_g, false, true, true);\n            wallbndbot = TestAIObnd(XParam, XModel, XModel_g, true, false, true);\n            wallbndtop = TestAIObnd(XParam, XModel, XModel_g, true, true, true);\n            result = (wallbndleft &amp; wallbndright &amp; wallbndbot &amp; wallbndtop) ? \"successful\" : \"failed\";\n            log(\"\\t\\tAOI bnd wall test : \" + result);\n        }\n\n        if (mytest == 15)\n            /* Test 15 is to test the input of flexible times outputs (general and in zone_outputs)\n                Test1: Test of times in second/durations (for general and zone_outputs)\n                    The data is read from paramfile and we test the reading and nc files created.\n            */\n        {\n            bool FlexibleOutTime;\n            log(\"\\t### Tests for flexible time outputs (general and zones outputs) ###\");\n            FlexibleOutTime = TestFlexibleOutputTimes(0, 0.0, 0);\n            result = FlexibleOutTime ? \"successful\" : \"failed\";\n            log(\"\\t\\t ##### \\n\");\n            log(\"\\t\\t ##### Flexible output times reading test : \" + result + \"\\n\");\n            log(\"\\t\\t ##### \\n\");\n            isfailed = (!FlexibleOutTime || isfailed) ? true : false;\n\n        }\n\n\n\n    if (mytest == 993)\n    {\n        //pinned pageable Memory test\n        TestPinMem(XParam, XModel, XModel_g);\n    }\n\n    if (mytest == 900)\n    {\n        GaussianHumptest(0.1, XParam.GPUDEVICE, false);\n    }\n\n        if (mytest == 994)\n        {\n            Testzbinit(XParam, XForcing, XModel, XModel_g);\n        }\n\n        if (mytest == 995)\n        {\n            TestFirsthalfstep(XParam, XForcing, XModel, XModel_g);\n        }\n        if (mytest == 996)\n        {\n            TestHaloSpeed(XParam, XModel, XModel_g);\n        }\n        if (mytest == 997)\n        {\n            TestGradientSpeed(XParam, XModel, XModel_g);\n        }\n\n        if (mytest == 998)\n        {\n            //\n            bool testresults;\n            log(\"\\t### CPU vs GPU Test ###\");\n            testresults = CPUGPUtest(XParam, XModel, XModel_g);\n            isfailed = (!testresults || isfailed) ? true : false;\n            if (testresults)\n            {\n                exit(0);\n            }\n            else\n            {\n                exit(1);\n            }\n        }\n        if (XParam.test == 999)\n        {\n            //\n            DebugLoop(XParam, XForcing, XModel, XModel_g);\n        }\n        mytest++;\n    }\n    return(isfailed);\n}\ntemplate bool Testing&lt;float&gt;(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;float&gt; XModel, Model&lt;float&gt; XModel_g);\ntemplate bool Testing&lt;double&gt;(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;double&gt; XModel, Model&lt;double&gt; XModel_g);\n\n\ntemplate &lt;class T&gt; bool GaussianHumptest(T zsnit, int gpu, bool compare)\n{\n    log(\"#####\");\n    // this is a preplica of the tutorial case for Basilisk\n    Param XParam;\n\n    T x, y, delta;\n    T cc = T(0.05);// Match the 200 in chracteristic radius used in Basilisk  1/(2*cc^2)=200\n\n    //XParam.engine = 2;\n\n    T a = T(1.0); //Gaussian wave amplitude\n\n    // Verification data\n    // This is a transect across iy=15:16:127 at ix=127 (or vice versa because the solution is symetrical)\n    // These values are based on single precision output from Netcdf file so are only accurate to 10-7 \n    //double ZsVerifKurganov[8] = { 0.100000000023, 0.100000063119, 0.100110376004, 0.195039970749, 0.136739044168, 0.0848024805994, 0.066275833049, 0.0637058445888 };\n    //double ZsVerification[8] = { 0.100000008904, 0.187920326216, 0.152329657390, 0.117710230042, 0.0828616638138, 0.0483274739972, 0.0321501737555, 0.0307609731288 };\n    double ZsVerifButtinger[8] = { 0.100000000023, 0.100000063119, 0.100093580546, 0.195088199869, 0.136767978925, 0.0850706353898, 0.0663028448129, 0.063727949607 };\n\n\n\n\n    // initialise domain and required resolution\n    XParam.dx = 1.0 / ((1 &lt;&lt; 8));\n    XParam.xo = -0.5;\n    XParam.yo = -0.5;\n\n    XParam.xmax = 0.5;\n    XParam.ymax = 0.5;\n    //level 8 is \n\n\n    XParam.initlevel = 0;\n    XParam.minlevel = 0;\n    XParam.maxlevel = 0;\n\n    XParam.zsinit = zsnit;\n    XParam.zsoffset = 0.0;\n\n    XParam.aoibnd = 3;\n\n    //Output times for comparisons\n    XParam.endtime = 1.0;\n    XParam.outputtimestep = 0.1;\n\n    XParam.smallnc = 0;\n\n    XParam.cf = 0.0;\n    XParam.frictionmodel = 0;\n\n    // Enforece GPU/CPU\n    XParam.GPUDEVICE = gpu;\n\n    std::string outvi[18] = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"ho\", \"vo\", \"uo\", \"cf\" };\n\n    std::vector&lt;std::string&gt; outv;\n\n    for (int nv = 0; nv &lt; 18; nv++)\n    {\n        outv.push_back(outvi[nv]);\n    }\n\n    XParam.outvars = outv;\n\n    // create Model setup\n    Model&lt;T&gt; XModel;\n    Model&lt;T&gt; XModel_g;\n\n    Forcing&lt;float&gt; XForcing;\n    StaticForcingP&lt;float&gt; bathy;\n\n    XForcing.Bathy.push_back(bathy);\n    // initialise forcing bathymetry to 0\n    XForcing.Bathy[0].xo = -1.0;\n    XForcing.Bathy[0].yo = -1.0;\n\n    XForcing.Bathy[0].xmax = 1.0;\n    XForcing.Bathy[0].ymax = 1.0;\n    XForcing.Bathy[0].nx = 3;\n    XForcing.Bathy[0].ny = 3;\n\n    XForcing.Bathy[0].dx = 1.0;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n\n    //AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = 0.0f;\n        }\n    }\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    // Recreate the initia;l conditions\n    //InitArrayBUQ(XParam, XModel.blocks, T(0.0), XModel.zb);\n    //InitArrayBUQ(XParam, XModel.blocks, zsnit, XModel.evolv.zs);\n    //zs is initialised here:\n    InitialConditions(XParam, XForcing, XModel);\n\n    T xorigin = T(0.0);\n    T yorigin = T(0.0);\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XModel.blocks.active[ibl];\n        delta = T(calcres(XParam.dx, XModel.blocks.level[ib]));\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int n = memloc(XParam, ix, iy, ib);\n                x = T(XParam.xo) + XModel.blocks.xo[ib] + ix * delta;\n                y = T(XParam.yo) + XModel.blocks.yo[ib] + iy * delta;\n                XModel.evolv.zs[n] = XModel.evolv.zs[n] + a * exp(T(-1.0) * ((x - xorigin) * (x - xorigin) + (y - yorigin) * (y - yorigin)) / (T(2.0) * cc * cc));\n                XModel.evolv.h[n] = utils::max(XModel.evolv.zs[n] - XModel.zb[n], T(0.0));\n\n            }\n        }\n    }\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    Loop&lt;T&gt; XLoop;\n    Loop&lt;T&gt; XLoop_g;\n\n\n    XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n    XLoop.totaltime = 0.0;\n\n    //InitSave2Netcdf(XParam, XModel);\n    XLoop.nextoutputtime = XParam.outputtimestep;\n    XLoop.dtmax = initdt(XParam, XLoop, XModel);\n\n    //XLoop_g = XLoop;\n    XLoop_g.hugenegval = std::numeric_limits&lt;T&gt;::min();\n    XLoop_g.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop_g.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n    XLoop_g.totaltime = 0.0;\n\n    //InitSave2Netcdf(XParam, XModel);\n    XLoop_g.nextoutputtime = XParam.outputtimestep;\n    XLoop_g.dtmax = XLoop.dtmax;\n\n\n    if (XParam.GPUDEVICE &gt;= 0 &amp;&amp; compare)\n    {\n        CompareCPUvsGPU(XParam, XModel, XModel_g, outv, false);\n    }\n    bool modelgood = true;\n\n    fillHaloC(XParam, XModel.blocks, XModel.zb);\n    gradientC(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    gradientHalo(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n\n    refine_linear(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    gradientHalo(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n\n    while (XLoop.totaltime &lt; XLoop.nextoutputtime)\n    {\n\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            if (XParam.engine == 5)\n            {\n                FlowMLGPU(XParam, XLoop, XForcing, XModel_g);\n            }\n            else\n            {\n                FlowGPU(XParam, XLoop_g, XForcing, XModel_g);\n            }\n            XLoop.dt = XLoop_g.dt;\n        }\n        else\n        {\n            FlowCPU(XParam, XLoop, XForcing, XModel);\n        }\n        if (XParam.GPUDEVICE &gt;= 0 &amp;&amp; compare)\n        {\n            int GPUdev = XParam.GPUDEVICE;\n            XParam.GPUDEVICE = -1;\n            FlowCPU(XParam, XLoop, XForcing, XModel);\n            XParam.GPUDEVICE = GPUdev;\n\n            T diffdt = T(XLoop_g.dt - XLoop.dt);\n            if (abs(diffdt) &gt; T(100.0) * (XLoop.epsilon))\n            {\n                printf(\"Timestep Difference=%f\\n\", diffdt);\n\n                compare = false;\n            }\n            CompareCPUvsGPU(XParam, XModel, XModel_g, outv, false);\n        }\n\n        //diffdh(XParam, XModel.blocks, XModel.flux.Su, diff, shuffle);\n        //diffSource(XParam, XModel.blocks, XModel.flux.Fqux, XModel.flux.Su, diff);\n        XLoop.totaltime = XLoop.totaltime + XLoop.dt;\n        XLoop_g.totaltime = XLoop_g.totaltime + XLoop_g.dt;\n        if (XLoop.nextoutputtime - XLoop.totaltime &lt;= XLoop.dt * T(0.00001) &amp;&amp; XParam.outputtimestep &gt; 0.0)\n        {\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n                {\n                    CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[XParam.outvars[ivar]], XModel_g.OutputVarMap[XParam.outvars[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n                }\n            }\n\n            //Save2Netcdf(XParam, XModel);\n            // Verify the Validity of results\n\n\n            double diff;\n            for (int iv = 0; iv &lt; 8; iv++)\n            {\n\n                int ix, iy, ib, ii, jj, ibx, iby, nbx;\n                jj = 127;\n                ii = (iv + 1) * 16 - 1;\n\n                // Theoretical size is 255x255\n                nbx = 256 / 16;\n\n\n                ibx = ftoi(floor(ii / XParam.blkwidth));\n                iby = ftoi(floor(jj / XParam.blkwidth));\n\n                ib = (iby)*nbx + ibx;\n\n                ix = ii - ibx * XParam.blkwidth;\n                iy = jj - iby * XParam.blkwidth;\n\n                int n = memloc(XParam, ix, iy, ib);\n\n                diff = abs(T(XModel.evolv.zs[n]) - ZsVerifButtinger[iv]);\n\n\n\n                if (diff &gt; 1e-6)//Tolerance is 1e-6 or 1e-7/1e-8??\n                {\n\n                    printf(\"ib=%d, ix=%d, iy=%d; simulated=%f; expected=%f; diff=%e\\n\", ib, ix, iy, XModel.evolv.zs[n], ZsVerifButtinger[iv], diff);\n                    modelgood = false;\n                    creatncfileBUQ(XParam, XModel.blocks);\n                    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"zs\", 3, XModel.evolv.zs, XModel.blocks.outZone[0]);\n                }\n\n\n\n            }\n\n\n\n            //XLoop.nextoutputtime = min(XLoop.nextoutputtime + XParam.outputtimestep, XParam.endtime);\n\n        }\n    }\n    log(\"#####\");\n    return modelgood;\n}\ntemplate bool GaussianHumptest&lt;float&gt;(float zsnit, int gpu, bool compare);\ntemplate bool GaussianHumptest&lt;double&gt;(double zsnit, int gpu, bool compare);\n\ntemplate &lt;class T&gt; bool Rivertest(T zsnit, int gpu)\n{\n    log(\"#####\");\n    Param XParam;\n    T delta = 0;\n    T initVol = 0;\n    T finalVol = 0;\n    T TheoryInput = 0;\n\n    // initialise domain and required resolution\n    XParam.dx = 1.0 / ((1 &lt;&lt; 4));\n    XParam.xo = -0.5;\n    XParam.yo = -0.5;\n\n    XParam.xmax = 0.5;\n    XParam.ymax = 0.5;\n    //level 8 is \n\n\n    XParam.initlevel = 0;\n    XParam.minlevel = 0;\n    XParam.maxlevel = 0;\n\n    XParam.zsinit = zsnit;\n    XParam.zsoffset = 0.0;\n\n    //Output times for comparisons\n    XParam.endtime = 1.0;\n    XParam.outputtimestep = 0.1;\n\n    XParam.smallnc = 0;\n\n    XParam.cf = 0.0;\n    XParam.frictionmodel = 0;\n\n    // Enforece GPU/CPU\n    XParam.GPUDEVICE = gpu;\n\n    std::vector&lt;std::string&gt; outv = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"Su\", \"Sv\",\"dhdx\", \"dhdy\", \"dudx\", \"dvdx\", \"dzsdx\", \"twet\", \"hUmax\", \"Umean\" };\n    XParam.outvars = outv;\n\n    XParam.outmax = true;\n    XParam.outmean = true;\n    XParam.outtwet = true;\n\n    XParam.ForceMassConserve = true;\n\n    // create Model setup\n    Model&lt;T&gt; XModel;\n    Model&lt;T&gt; XModel_g;\n\n    Forcing&lt;float&gt; XForcing;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    XForcing.Bathy.push_back(bathy);\n\n    // initialise forcing bathymetry to 0\n    XForcing.Bathy[0].xo = -1.0;\n    XForcing.Bathy[0].yo = -1.0;\n\n    XForcing.Bathy[0].xmax = 1.0;\n    XForcing.Bathy[0].ymax = 1.0;\n    XForcing.Bathy[0].nx = 3;\n    XForcing.Bathy[0].ny = 3;\n\n    XForcing.Bathy[0].dx = 1.0;\n    XForcing.Bathy[0].dy = 1.0;\n\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = 0.0f;\n        }\n    }\n    //\n    //\n    // \n    T Q = T(0.001);\n    TheoryInput = Q * T(XParam.outputtimestep);\n\n\n    //Create a temporary file with river fluxes\n    std::ofstream river_file(\n        \"testriver.tmp\", std::ios_base::out | std::ios_base::trunc);\n    river_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file &lt;&lt; \"3600.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file.close(); //destructor implicitly does it\n\n    River thisriver;\n    thisriver.Riverflowfile = \"testriver.tmp\";\n    thisriver.xstart = -1.0 * XParam.dx * 3.0;\n    thisriver.xend = XParam.dx * 3.0;\n    thisriver.ystart = -1.0 * XParam.dx * 3.0;\n    thisriver.yend = XParam.dx * 3.0;\n\n    XForcing.rivers.push_back(thisriver);\n\n\n    XForcing.rivers[0].flowinput = readFlowfile(XForcing.rivers[0].Riverflowfile, XParam.reftime);\n\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    Loop&lt;T&gt; XLoop;\n\n    XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    XLoop.totaltime = 0.0;\n\n    //InitSave2Netcdf(XParam, XModel);\n    XLoop.nextoutputtime = XParam.outputtimestep;\n    XLoop.dtmax = initdt(XParam, XLoop, XModel);\n    initVol = T(0.0);\n\n    fillHaloC(XParam, XModel.blocks, XModel.zb);\n\n    // Calculate initial water volume\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XModel.blocks.active[ibl];\n        delta = calcres(T(XParam.delta), XModel.blocks.level[ib]);\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int n = memloc(XParam, ix, iy, ib);\n                //printf(\"h[%d] = %f\\n\", n, XModel.evolv.h[n]);\n                initVol = initVol + XModel.evolv.h[n] * delta * delta;\n            }\n        }\n    }\n\n\n    //InitSave2Netcdf(XParam, XModel);\n    bool modelgood = true;\n\n    while (XLoop.totaltime &lt; XLoop.nextoutputtime)\n    {\n\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            FlowGPU(XParam, XLoop, XForcing, XModel_g);\n        }\n        else\n        {\n            printf(\"h[1] = %f\\n\", XModel.evolv.h[1]);\n            FlowCPU(XParam, XLoop, XForcing, XModel);\n        }\n        XLoop.totaltime = XLoop.totaltime + XLoop.dt;\n        //Save2Netcdf(XParam, XLoop, XModel);\n\n        if (XLoop.nextoutputtime - XLoop.totaltime &lt;= XLoop.dt * T(0.00001))\n        {\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n                {\n                    CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[XParam.outvars[ivar]], XModel_g.OutputVarMap[XParam.outvars[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n                }\n            }\n\n            //Save2Netcdf(XParam, XLoop, XModel);\n            // Verify the Validity of results\n            finalVol = T(0.0);\n            for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n            {\n                //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n                int ib = XModel.blocks.active[ibl];\n                delta = calcres(T(XParam.delta), XModel.blocks.level[ib]);\n\n\n                for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n                {\n                    for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n                    {\n                        //\n                        int n = memloc(XParam, ix, iy, ib);\n                        //printf(\"h[%d] = %f\\n\", n, XModel.evolv.h[n]);\n                        finalVol = finalVol + XModel.evolv.h[n] * delta * delta;\n                    }\n                }\n            }\n            T error = ((finalVol - initVol) - TheoryInput) / TheoryInput;\n            printf(\"error = %g %%, initial volume=%4.4f; final Volume=%4.4f; abs. difference=%4.4f, Theoretical  input=%4.4f \\n\", error, initVol, finalVol, abs(finalVol - initVol), TheoryInput);\n\n\n            modelgood = abs(error) &lt; 0.05;\n        }\n\n\n\n    }\n\n    if (!modelgood)\n    {\n        InitSave2Netcdf(XParam, XModel);\n\n    }\n\n\n    log(\"#####\");\n    return modelgood;\n}\ntemplate bool Rivertest&lt;float&gt;(float zsnit, int gpu);\ntemplate bool Rivertest&lt;double&gt;(double zsnit, int gpu);\n\n\n\ntemplate &lt;class T&gt; bool MassConserveSteepSlope(T zsnit, int gpu)\n{\n    log(\"#####\");\n    Param XParam;\n    T delta, initVol, finalVol, TheoryInput;\n    // initialise domain and required resolution\n    XParam.dx = 1.0 / ((1 &lt;&lt; 8));\n    XParam.xo = -0.5;\n    XParam.yo = -0.5;\n\n    XParam.xmax = 0.5;\n    XParam.ymax = 0.5;\n    //level 8 is \n\n\n    XParam.initlevel = 0;\n    XParam.minlevel = -1;\n    XParam.maxlevel = 1;\n\n    XParam.AdaptCrit = \"Threshold\";\n    XParam.Adapt_arg1 = \"3.5\";\n    XParam.Adapt_arg2 = \"zb\";\n\n    XParam.zsinit = zsnit;\n    XParam.zsoffset = 0.0;\n\n    //Output times for comparisons\n    XParam.endtime = 1.0;\n    XParam.outputtimestep = 0.04;//0.035;\n\n    XParam.smallnc = 0;\n\n    XParam.cf = 0.001;\n    XParam.frictionmodel = 1;\n\n    XParam.conserveElevation = false;\n    XParam.ForceMassConserve = true;\n\n    // Enforce GPU/CPU\n    XParam.GPUDEVICE = gpu;\n    std::vector&lt;std::string&gt; outv = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"Su\", \"Sv\",\"dhdx\", \"dhdy\" };\n\n\n    XParam.outvars = outv;\n    // create Model setup\n    Model&lt;T&gt; XModel;\n    Model&lt;T&gt; XModel_g;\n\n    Forcing&lt;float&gt; XForcing;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    XForcing.Bathy.push_back(bathy);\n\n    // initialise forcing bathymetry to 0\n    XForcing.Bathy[0].xo = -1.0;\n    XForcing.Bathy[0].yo = -1.0;\n\n    XForcing.Bathy[0].xmax = 1.0;\n    XForcing.Bathy[0].ymax = 1.0;\n    XForcing.Bathy[0].nx = 3;\n    XForcing.Bathy[0].ny = 3;\n\n    XForcing.Bathy[0].dx = 1.0;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = T(i * 4);\n        }\n    }\n    //\n    //\n    // \n    T Q = T(0.10);\n    TheoryInput = Q * T(XParam.outputtimestep);\n\n\n    //Create a temporary file with river fluxes\n    std::ofstream river_file(\n        \"testriver.tmp\", std::ios_base::out | std::ios_base::trunc);\n    river_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file &lt;&lt; \"3600.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file.close(); //destructor implicitly does it\n\n    River thisriver;\n    thisriver.Riverflowfile = \"testriver.tmp\";\n    thisriver.xstart = -1.0 * XParam.dx * 3.0;\n    thisriver.xend = XParam.dx * 3.0;\n    thisriver.ystart = -1.0 * XParam.dx * 3.0;\n    thisriver.yend = XParam.dx * 3.0;\n\n    XForcing.rivers.push_back(thisriver);\n\n\n    XForcing.rivers[0].flowinput = readFlowfile(XForcing.rivers[0].Riverflowfile, XParam.reftime);\n\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    Loop&lt;T&gt; XLoop;\n\n    XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    XLoop.totaltime = 0.0;\n\n\n\n    InitSave2Netcdf(XParam, XModel);\n    XLoop.nextoutputtime = XParam.outputtimestep;\n    XLoop.dtmax = 0.025;// initdt(XParam, XLoop, XModel);\n\n\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XModel.blocks.active[ibl];\n        //delta = calcres(XParam.dx, XModel.blocks.level[ib]);\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int n = memloc(XParam, ix, iy, ib);\n                if (XModel.zb[n] &lt; XParam.eps)\n                {\n                    printf(\"ix=%d, iy=%d, ib=%d, n=%d; zb=%f \\n\", ix, iy, ib, n, XModel.zb[n]);\n                }\n            }\n        }\n    }\n\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        cudaStream_t stream;\n        CUDA_CHECK(cudaStreamCreate(&amp;stream));\n\n        fillHaloGPU(XParam, XModel_g.blocks, stream, XModel_g.zb);\n\n        cudaStreamDestroy(stream);\n    }\n    else\n    {\n        fillHaloC(XParam, XModel.blocks, XModel.zb);\n    }\n\n    initVol = T(0.0);\n    // Calculate initial water volume\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XModel.blocks.active[ibl];\n        delta = calcres(T(XParam.delta), XModel.blocks.level[ib]);\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int n = memloc(XParam, ix, iy, ib);\n                initVol = initVol + XModel.evolv.h[n] * delta * delta;\n            }\n        }\n    }\n\n\n    //InitSave2Netcdf(XParam, XModel);+\n\n\n\n    bool modelgood = true;\n\n    while (XLoop.totaltime &lt; XLoop.nextoutputtime)\n    {\n\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            FlowGPU(XParam, XLoop, XForcing, XModel_g);\n        }\n        else\n        {\n            FlowCPU(XParam, XLoop, XForcing, XModel);\n        }\n        XLoop.totaltime = XLoop.totaltime + XLoop.dt;\n        //Save2Netcdf(XParam, XLoop, XModel);\n\n        if (XLoop.nextoutputtime - XLoop.totaltime &lt;= XLoop.dt * T(0.00001) &amp;&amp; XParam.outputtimestep &gt; 0.0)\n        {\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n                {\n                    CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[XParam.outvars[ivar]], XModel_g.OutputVarMap[XParam.outvars[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n                }\n            }\n\n            Save2Netcdf(XParam, XLoop, XModel);\n            // Verify the Validity of results\n            finalVol = T(0.0);\n            for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n            {\n                //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n                int ib = XModel.blocks.active[ibl];\n                delta = calcres(T(XParam.delta), XModel.blocks.level[ib]);\n\n\n                for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n                {\n                    for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n                    {\n                        //\n                        int n = memloc(XParam, ix, iy, ib);\n                        finalVol = finalVol + XModel.evolv.h[n] * delta * delta;\n                    }\n                }\n            }\n            T error = (finalVol - initVol) - TheoryInput;\n\n            modelgood = error / TheoryInput &lt; 0.05;\n        }\n\n\n    }\n    log(\"#####\");\n    return modelgood;\n}\ntemplate bool MassConserveSteepSlope&lt;float&gt;(float zsnit, int gpu);\ntemplate bool MassConserveSteepSlope&lt;double&gt;(double zsnit, int gpu);\n\n\ntemplate &lt;class T&gt; bool reductiontest(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n    //srand(seed);\n    T mininput = T(rand()) / T(RAND_MAX);\n    bool test = true;\n\n    Loop&lt;T&gt; XLoop;\n\n    XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    XLoop.totaltime = 0.0;\n\n    //InitSave2Netcdf(XParam, XModel);\n    XLoop.nextoutputtime = mininput * T(2.0);\n    XLoop.dtmax = mininput * T(2.01);\n\n    // Fill in dtmax with random values that are larger than  mininput\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int n = memloc(XParam, ix, iy, ib);\n                XModel.time.dtmax[n] = mininput * T(1.1) + utils::max(T(rand()) / T(RAND_MAX), T(0.0));\n            }\n        }\n    }\n\n    // randomly select a block a i and a j were the maximum value will be relocated\n    int ibbl = ftoi(floor(T(rand()) / T(RAND_MAX) * XParam.nblk));\n    int ibb = XModel.blocks.active[ibbl];\n    int ixx = ftoi(floor(T(rand()) / T(RAND_MAX) * XParam.blkwidth));\n    int iyy = ftoi(floor(T(rand()) / T(RAND_MAX) * XParam.blkwidth));\n\n    int nn = memloc(XParam, ixx, iyy, ibb);\n\n    XModel.time.dtmax[nn] = mininput;\n\n    T reducedt = CalctimestepCPU(XParam, XLoop, XModel.blocks, XModel.time);\n\n    test = abs(reducedt - mininput) &lt; T(100.0) * (XLoop.epsilon);\n    bool testgpu;\n\n    if (!test)\n    {\n        char buffer[256]; sprintf(buffer, \"%e\", abs(reducedt - mininput));\n        std::string str(buffer);\n        log(\"\\t\\t CPU test failed! : Expected=\" + std::to_string(mininput) + \";  Reduced=\" + std::to_string(reducedt) + \";  error=\" + str);\n    }\n\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n\n        reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XLoop.hugeposval, XModel_g.time.dtmax);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        CopytoGPU(XParam.nblkmem, XParam.blksize, XModel.time.dtmax, XModel_g.time.dtmax);\n        T reducedtgpu = CalctimestepGPU(XParam, XLoop, XModel_g.blocks, XModel_g.time);\n        testgpu = abs(reducedtgpu - mininput) &lt; T(100.0) * (XLoop.epsilon);\n\n        if (!testgpu)\n        {\n            char buffer[256]; sprintf(buffer, \"%e\", abs(reducedtgpu - mininput));\n            std::string str(buffer);\n            log(\"\\t\\t GPU test failed! : Expected=\" + std::to_string(mininput) + \";  Reduced=\" + std::to_string(reducedtgpu) + \";  error=\" + str);\n        }\n\n        if (abs(reducedtgpu - reducedt) &gt; T(100.0) * (XLoop.epsilon))\n        {\n            char buffer[256]; sprintf(buffer, \"%e\", abs(reducedtgpu - reducedt));\n            std::string str(buffer);\n            log(\"\\t\\t CPU vs GPU test failed! : Expected=\" + std::to_string(reducedt) + \";  Reduced=\" + std::to_string(reducedtgpu) + \";  error=\" + str);\n        }\n\n        test = test &amp;&amp; testgpu;\n    }\n\n\n    return test;\n}\ntemplate bool reductiontest&lt;float&gt;(Param XParam, Model&lt;float&gt; XModel, Model&lt;float&gt; XModel_g);\ntemplate bool reductiontest&lt;double&gt;(Param XParam, Model&lt;double&gt; XModel, Model&lt;double&gt; XModel_g);\n\ntemplate&lt;class T&gt; bool CPUGPUtest(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    bool test = true;\n\n    T initdepth = T(0.1);\n    T testamp = T(1.0);\n\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    // for flux reconstruction the loop overlap the right(or top for the y direction) halo\n    dim3 blockDimKX(XParam.blkwidth + XParam.halowidth, XParam.blkwidth, 1);\n    dim3 blockDimKY(XParam.blkwidth, XParam.blkwidth + XParam.halowidth, 1);\n\n    InitArrayBUQ(XParam, XModel.blocks, T(0.0), XModel.zb);\n    InitArrayBUQ(XParam, XModel.blocks, T(initdepth), XModel.evolv.zs);\n    InitArrayBUQ(XParam, XModel.blocks, T(initdepth), XModel.evolv.h);\n    InitArrayBUQ(XParam, XModel.blocks, T(0.0), XModel.evolv.u);\n    InitArrayBUQ(XParam, XModel.blocks, T(0.0), XModel.evolv.v);\n\n\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, T(0.0), XModel_g.zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    // Create some usefull vectors\n    std::string evolvst[4] = { \"h\",\"zs\",\"u\",\"v\" };\n\n    std::vector&lt;std::string&gt; evolvVar;\n\n    for (int nv = 0; nv &lt; 4; nv++)\n    {\n        evolvVar.push_back(evolvst[nv]);\n    }\n\n\n    // Check fillhalo function\n\n    // fill with all evolv array with random value\n    /*\n    fillrandom(XParam, XModel.blocks, XModel.evolv.zs);\n    fillrandom(XParam, XModel.blocks, XModel.evolv.h);\n    fillrandom(XParam, XModel.blocks, XModel.evolv.u);\n    fillrandom(XParam, XModel.blocks, XModel.evolv.v);\n    */\n    fillgauss(XParam, XModel.blocks, testamp, XModel.evolv.zs);\n    fillgauss(XParam, XModel.blocks, testamp, XModel.evolv.h);\n    fillgauss(XParam, XModel.blocks, T(0.5 * testamp), XModel.evolv.u);\n    fillgauss(XParam, XModel.blocks, T(0.5 * testamp), XModel.evolv.v);\n\n    //copy to GPU\n    CopytoGPU(XParam.nblkmem, XParam.blksize, XModel.evolv, XModel_g.evolv);\n\n    //============================================\n    //  Fill the halo for gradient reconstruction\n    fillHalo(XParam, XModel.blocks, XModel.evolv, XModel.zb);\n    fillHaloGPU(XParam, XModel_g.blocks, XModel_g.evolv, XModel_g.zb);\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, evolvVar, true);\n\n    //============================================\n    //perform gradient reconstruction\n    //gradientCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.zb);\n    //gradientGPU(XParam, XModel_g.blocks, XModel_g.evolv, XModel_g.grad, XModel.zb);\n\n\n    // CPU gradients\n    std::thread t0(&amp;gradientC&lt;T&gt;, XParam, XModel.blocks, XModel.evolv.h, XModel.grad.dhdx, XModel.grad.dhdy);\n    std::thread t1(&amp;gradientC&lt;T&gt;, XParam, XModel.blocks, XModel.evolv.zs, XModel.grad.dzsdx, XModel.grad.dzsdy);\n    std::thread t2(&amp;gradientC&lt;T&gt;, XParam, XModel.blocks, XModel.evolv.u, XModel.grad.dudx, XModel.grad.dudy);\n    std::thread t3(&amp;gradientC&lt;T&gt;, XParam, XModel.blocks, XModel.evolv.v, XModel.grad.dvdx, XModel.grad.dvdy);\n\n    t0.join();\n    t1.join();\n    t2.join();\n    t3.join();\n\n    //GPU gradients\n\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XModel_g.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel_g.evolv.h, XModel_g.grad.dhdx, XModel_g.grad.dhdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XModel_g.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel_g.evolv.zs, XModel_g.grad.dzsdx, XModel_g.grad.dzsdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XModel_g.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel_g.evolv.u, XModel_g.grad.dudx, XModel_g.grad.dudy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XModel_g.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel_g.evolv.v, XModel_g.grad.dvdx, XModel_g.grad.dvdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    std::string gradst[8] = { \"dhdx\",\"dzsdx\",\"dudx\",\"dvdx\",\"dhdy\",\"dzsdy\",\"dudy\",\"dvdy\" };\n\n    std::vector&lt;std::string&gt; gradVar;\n\n    for (int nv = 0; nv &lt; 8; nv++)\n    {\n        gradVar.push_back(gradst[nv]);\n    }\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, gradVar, false);\n\n    // Gradient in Halo\n\n    // CPU\n    gradientHalo(XParam, XModel.blocks, XModel.evolv.h, XModel.grad.dhdx, XModel.grad.dhdy);\n    gradientHalo(XParam, XModel.blocks, XModel.evolv.zs, XModel.grad.dzsdx, XModel.grad.dzsdy);\n    gradientHalo(XParam, XModel.blocks, XModel.evolv.u, XModel.grad.dudx, XModel.grad.dudy);\n    gradientHalo(XParam, XModel.blocks, XModel.evolv.v, XModel.grad.dvdx, XModel.grad.dvdy);\n\n    // GPU\n    gradientHaloGPU(XParam, XModel_g.blocks, XModel_g.evolv.h, XModel_g.grad.dhdx, XModel_g.grad.dhdy);\n    gradientHaloGPU(XParam, XModel_g.blocks, XModel_g.evolv.zs, XModel_g.grad.dzsdx, XModel_g.grad.dzsdy);\n    gradientHaloGPU(XParam, XModel_g.blocks, XModel_g.evolv.u, XModel_g.grad.dudx, XModel_g.grad.dudy);\n    gradientHaloGPU(XParam, XModel_g.blocks, XModel_g.evolv.v, XModel_g.grad.dvdx, XModel_g.grad.dvdy);\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, gradVar, true);\n\n    //============================================\n    // Kurganov scheme\n\n    std::string fluxst[8] = { \"Fhu\",\"Su\",\"Fqux\",\"Fqvx\",\"Fhv\",\"Sv\",\"Fqvy\",\"Fquy\" };\n\n    std::vector&lt;std::string&gt; fluxVar;\n\n    for (int nv = 0; nv &lt; 8; nv++)\n    {\n        fluxVar.push_back(fluxst[nv]);\n    }\n\n    updateKurgXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n\n    //GPU part\n    updateKurgXGPU &lt;&lt;&lt; gridDim, blockDimKX, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evolv, XModel_g.grad, XModel_g.flux, XModel_g.time.dtmax, XModel_g.zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n\n    // Y- direction\n    updateKurgYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n\n    updateKurgYGPU &lt;&lt;&lt; gridDim, blockDimKY, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evolv, XModel_g.grad, XModel_g.flux, XModel_g.time.dtmax, XModel_g.zb);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, fluxVar, false);\n\n\n    fillHalo(XParam, XModel.blocks, XModel.flux);\n    fillHaloGPU(XParam, XModel_g.blocks, XModel_g.flux);\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, fluxVar, true);\n\n\n    //============================================\n    // Update step\n    std::string advst[3] = { \"dh\",\"dhu\",\"dhv\" };\n\n    std::vector&lt;std::string&gt; advVar;\n\n    for (int nv = 0; nv &lt; 3; nv++)\n    {\n        advVar.push_back(advst[nv]);\n    }\n    updateEVCPU(XParam, XModel.blocks, XModel.evolv, XModel.flux, XModel.adv);\n    updateEVGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, XModel_g.evolv, XModel_g.flux, XModel_g.adv);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, advVar, false);\n\n    //============================================\n    // Advance step\n    std::string evost[4] = { \"zso\",\"ho\",\"uo\",\"vo\" };\n\n    std::vector&lt;std::string&gt; evoVar;\n\n    for (int nv = 0; nv &lt; 4; nv++)\n    {\n        evoVar.push_back(evost[nv]);\n    }\n    AdvkernelCPU(XParam, XModel.blocks, T(0.0005), XModel.zb, XModel.evolv, XModel.adv, XModel.evolv_o);\n    AdvkernelGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, T(0.0005), XModel_g.zb, XModel_g.evolv, XModel_g.adv, XModel_g.evolv_o);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, evoVar, false);\n\n    //============================================\n    // Bottom friction\n\n    bottomfrictionCPU(XParam, XModel.blocks, T(0.5), XModel.cf, XModel.evolv_o);\n\n    bottomfrictionGPU &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel_g.blocks, T(0.5), XModel_g.cf, XModel_g.evolv_o);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, evoVar, false);\n\n\n    //============================================\n    // Repeat the full test\n    Loop&lt;T&gt; XLoop;\n    Loop&lt;T&gt; XLoop_g;\n\n    XParam.endtime = utils::min(0.5 * (XParam.ymax - XParam.yo), 0.5 * (XParam.xmax - XParam.xo)) / (sqrt(XParam.g * (testamp + initdepth)));\n    XParam.outputtimestep = XParam.endtime / 10.0;\n\n\n    XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    XLoop.totaltime = 0.0;\n\n    //InitSave2Netcdf(XParam, XModel);\n    XLoop.nextoutputtime = XParam.outputtimestep;\n    XLoop.dtmax = initdt(XParam, XLoop, XModel);\n\n    XLoop_g.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop_g.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop_g.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    XLoop_g.totaltime = 0.0;\n\n    //InitSave2Netcdf(XParam, XModel);\n    XLoop_g.nextoutputtime = XLoop.nextoutputtime;\n    XLoop_g.dtmax = XLoop.dtmax;\n\n    std::string outvi[18] = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"ho\", \"vo\", \"uo\", \"cf\" };\n\n    std::vector&lt;std::string&gt; outv;\n\n    for (int nv = 0; nv &lt; 18; nv++)\n    {\n        outv.push_back(outvi[nv]);\n    }\n\n\n    InitArrayBUQ(XParam, XModel.blocks, T(0.0), XModel.evolv.u);\n    InitArrayBUQ(XParam, XModel.blocks, T(0.0), XModel.evolv.v);\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, T(0.0), XModel_g.evolv.u);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    reset_var &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, T(0.0), XModel_g.evolv.v);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    Forcing&lt;float&gt; XForcing;\n    while (XLoop.totaltime &lt; XParam.endtime)\n    {\n        FlowGPU(XParam, XLoop_g, XForcing, XModel_g);\n        FlowCPU(XParam, XLoop, XForcing, XModel);\n\n        XLoop.totaltime = XLoop.totaltime + XLoop.dt;\n        XLoop_g.totaltime = XLoop_g.totaltime + XLoop_g.dt;\n        if (XLoop.nextoutputtime - XLoop.totaltime &lt;= XLoop.dt * T(0.00001) &amp;&amp; XParam.outputtimestep &gt; 0.0)\n        {\n            CompareCPUvsGPU(XParam, XModel, XModel_g, outv, false);\n            XLoop.nextoutputtime = min(XLoop.nextoutputtime + XParam.outputtimestep, XParam.endtime);\n            XLoop_g.nextoutputtime = XLoop.nextoutputtime;\n        }\n    }\n\n\n    return test;\n}\n\ntemplate &lt;class T&gt; T ValleyBathy(T x, T y, T slope, T center)\n{\n\n\n    T bathy;\n\n    bathy = (abs(x - center) + y) * slope;\n\n\n    return bathy;\n}\n\n\ntemplate &lt;class T&gt; T ThackerBathy(T x, T y, T L, T D)\n{\n\n\n    T bathy = D * ((x * x + y * y) / (L * L) - 1.0);\n\n\n    return bathy;\n}\n\ntemplate &lt;class T&gt; bool ThackerLakeAtRest(Param XParam, T zsinit)\n{\n    bool test = true;\n    // Make a Parabolic bathy\n\n    auto modeltype = XParam.doubleprecision &lt; 1 ? float() : double();\n    Model&lt;decltype(modeltype)&gt; XModel; // For CPU pointers\n    Model&lt;decltype(modeltype)&gt; XModel_g; // For GPU pointers\n\n    Forcing&lt;float&gt; XForcing;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    XForcing.Bathy.push_back(bathy);\n\n    // initialise forcing bathymetry to 0\n\n    T Lo = T(2500.0);\n    T Do = T(1.0);\n\n    T x, y;\n\n\n\n    XForcing.Bathy[0].xo = -4000.0;\n    XForcing.Bathy[0].yo = -4000.0;\n\n    XForcing.Bathy[0].xmax = 4000.0;\n    XForcing.Bathy[0].ymax = 4000.0;\n    XForcing.Bathy[0].nx = 64;\n    XForcing.Bathy[0].ny = 64;\n\n    XForcing.Bathy[0].dx = 126.0;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            x = T(XForcing.Bathy[0].xo + i * XForcing.Bathy[0].dx);\n            y = T(XForcing.Bathy[0].yo + j * XForcing.Bathy[0].dx);\n            XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = float(ThackerBathy(x, y, Lo, Do));\n        }\n    }\n\n    // Overrule whatever may be set in the param file\n    XParam.xmax = XForcing.Bathy[0].xmax;\n    XParam.ymax = XForcing.Bathy[0].ymax;\n    XParam.xo = XForcing.Bathy[0].xo;\n    XParam.yo = XForcing.Bathy[0].yo;\n\n    XParam.dx = XForcing.Bathy[0].dx;\n\n    XParam.zsinit = zsinit;\n    XParam.endtime = 1390.0;\n\n    XParam.outputtimestep = XParam.endtime;\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    MainLoop(XParam, XForcing, XModel, XModel_g);\n\n\n    // Check Lake at rest state?\n    // all velocities should be very small\n    T smallvel = T(1e-6);\n    int i;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                i = memloc(XParam, ix, iy, ib);\n                if (abs(XModel.evolv.u[i]) &gt; smallvel || abs(XModel.evolv.v[i]) &gt; smallvel)\n                {\n                    log(\"Lake at rest state not acheived!\");\n                    test = false;\n                }\n            }\n        }\n    }\n\n    return test;\n}\ntemplate bool ThackerLakeAtRest&lt;float&gt;(Param XParam, float zsinit);\ntemplate bool ThackerLakeAtRest&lt;double&gt;(Param XParam, double zsinit);\n\n\n\ntemplate &lt;class T&gt; bool RiverVolumeAdapt(Param XParam, T maxslope)\n{\n    //T maxslope = 0.45; // tthe mass conservation is better with smaller slopes \n\n    bool UnitestA, UnitestB, UnitestC, UnitestD;\n    bool ctofA, ctofB, ctofC, ctofD;\n    bool ftocA, ftocB, ftocC, ftocD;\n\n    std::string details;\n\n    XParam.minlevel = 1;\n    XParam.maxlevel = 1;\n    XParam.initlevel = 1;\n\n    XParam.ForceMassConserve = true;\n\n\n    UnitestA=RiverVolumeAdapt(XParam, maxslope, false, false);\n    UnitestB=RiverVolumeAdapt(XParam, maxslope, true, false);\n    UnitestC=RiverVolumeAdapt(XParam, maxslope, false, true);\n    UnitestD=RiverVolumeAdapt(XParam, maxslope, true, true);\n\n\n    if (UnitestA &amp;&amp; UnitestB &amp;&amp; UnitestC &amp;&amp; UnitestD)\n    {\n        log(\"River Volume Conservation Test: Uniform mesh: Success\");\n    }\n    else\n    {\n        log(\"River Volume Conservation Test: Uniform mesh: Failed\");\n        details = UnitestA ? \"successful\" : \"failed\";\n        log(\"\\t Uniform mesh A :\" + details);\n        details = UnitestB ? \"successful\" : \"failed\";\n        log(\"\\t Uniform mesh B :\" + details);\n        details = UnitestC ? \"successful\" : \"failed\";\n        log(\"\\t Uniform mesh C :\" + details);\n        details = UnitestD ? \"successful\" : \"failed\";\n        log(\"\\t Uniform mesh D :\" + details);\n    }\n\n    XParam.minlevel = 0;\n    XParam.maxlevel = 1;\n    XParam.initlevel = 0;\n\n    //Fine to coarse\n    // Change arg 1 and 2 if the slope is changed\n    XParam.AdaptCrit = \"Inrange\";\n    XParam.Adapt_arg1 = \"28.0\";\n    XParam.Adapt_arg2 = \"40.0\";\n    XParam.Adapt_arg3 = \"zb\";\n\n    ftocA = RiverVolumeAdapt(XParam, maxslope, false, false);\n    ftocB = RiverVolumeAdapt(XParam, maxslope, true, false);\n    ftocC = RiverVolumeAdapt(XParam, maxslope, false, true);\n    ftocD = RiverVolumeAdapt(XParam, maxslope, true, true);\n    if (ftocA &amp;&amp; ftocB &amp;&amp; ftocC &amp;&amp; ftocD)\n    {\n        log(\"River Volume Conservation Test: Flow from fine to coarse adapted mesh: Success\");\n    }\n    else\n    {\n        log(\"River Volume Conservation Test: Flow from fine to coarse adapted mesh: Failed\");\n        details = ftocA ? \"successful\" : \"failed\";\n        log(\"\\t Flow from fine to coarse adapted mesh A :\" + details);\n        details = ftocB ? \"successful\" : \"failed\";\n        log(\"\\t Flow from fine to coarse adapted mesh B :\" + details);\n        details = ftocC ? \"successful\" : \"failed\";\n        log(\"\\t Flow from fine to coarse adapted mesh C :\" + details);\n        details = ftocD ? \"successful\" : \"failed\";\n        log(\"\\t Flow from fine to coarse adapted mesh D :\" + details);\n    }\n\n    //coarse to fine\n    // Change arg 1 and 2 if the slope is changed\n    XParam.AdaptCrit = \"Inrange\";\n    XParam.Adapt_arg1 = \"0.0\";\n    XParam.Adapt_arg2 = \"2.0\";\n    XParam.Adapt_arg3 = \"zb\";\n\n    ctofA = RiverVolumeAdapt(XParam, maxslope, false, false);\n    ctofB = RiverVolumeAdapt(XParam, maxslope, true, false);\n    ctofC = RiverVolumeAdapt(XParam, maxslope, false, true);\n    ctofD = RiverVolumeAdapt(XParam, maxslope, true, true);\n    if (ctofA &amp;&amp; ctofB &amp;&amp; ctofC &amp;&amp; ctofD)\n    {\n        log(\"River Volume Conservation Test: Flow from coarse to fine adapted mesh: Success\");\n    }\n    else\n    {\n        log(\"River Volume Conservation Test: Flow from coarse to fine adapted: Failed\");\n        details = ctofA ? \"successful\" : \"failed\";\n        log(\"\\t Flow from coarse to fine adapted mesh A :\" + details);\n        details = ctofB ? \"successful\" : \"failed\";\n        log(\"\\t Flow from coarse to fine adapted mesh B :\" + details);\n        details = ctofC ? \"successful\" : \"failed\";\n        log(\"\\t Flow from coarse to fine adapted mesh C :\" + details);\n        details = ctofD ? \"successful\" : \"failed\";\n        log(\"\\t Flow from coarse to fine adapted mesh D :\" + details);\n\n    }\n\n    return (UnitestA * UnitestB * UnitestC * UnitestD * ctofA * ctofB * ctofC * ctofD * ftocA * ftocB * ftocC * ftocD);\n}\n\n\ntemplate &lt;class T&gt; bool RiverVolumeAdapt(Param XParam, T slope, bool bottop, bool flip)\n{\n    //bool test = true;\n    //\n\n    auto modeltype = XParam.doubleprecision &lt; 1 ? float() : double();\n    Model&lt;decltype(modeltype)&gt; XModel; // For CPU pointers\n    Model&lt;decltype(modeltype)&gt; XModel_g; // For GPU pointers\n\n    Forcing&lt;float&gt; XForcing;\n\n    XForcing = MakValleyBathy(XParam, slope, bottop, flip);\n\n    T x, y;\n    T center = T(10.5);\n\n    float maxtopo = std::numeric_limits&lt;float&gt;::min();\n    float mintopo = std::numeric_limits&lt;float&gt;::max();\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            maxtopo = max(XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx], maxtopo);\n            mintopo = min(XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx], mintopo);\n        }\n    }\n\n\n\n    // Overrule whatever is set in the river forcing\n    T Q = T(1.0);\n\n    double upstream = !flip ? 24.0 : 8;\n    double riverx = !bottop ? upstream : center;\n    double rivery = !bottop ? center : upstream;\n\n    //Create a temporary file with river fluxes\n    std::ofstream river_file(\n        \"testriver.tmp\", std::ios_base::out | std::ios_base::trunc);\n    river_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file &lt;&lt; \"3600.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file.close(); //destructor implicitly does it\n\n    River thisriver;\n    thisriver.Riverflowfile = \"testriver.tmp\";\n    thisriver.xstart = riverx - 1.0;\n    thisriver.xend = riverx + 1.0;\n    thisriver.ystart = rivery - 1.0;\n    thisriver.yend = rivery + 1.0;\n\n    XForcing.rivers.push_back(thisriver);\n\n\n    XForcing.rivers[0].flowinput = readFlowfile(XForcing.rivers[0].Riverflowfile, XParam.reftime);\n\n\n    // Overrule whatever may be set in the param file\n    XParam.xmax = XForcing.Bathy[0].xmax;\n    XParam.ymax = XForcing.Bathy[0].ymax;\n    XParam.xo = XForcing.Bathy[0].xo;\n    XParam.yo = XForcing.Bathy[0].yo;\n\n    XParam.dx = XForcing.Bathy[0].dx;\n\n    XParam.zsinit = mintopo + 0.5;// Had a small amount of water to avoid a huge first step that would surely break the setup\n    XParam.endtime = 20.0;\n\n    XParam.outputtimestep = XParam.endtime;\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n    T initVol = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.delta, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                initVol = initVol + T(XModel.evolv.h[i]) * delta * delta;\n            }\n        }\n    }\n\n\n    MainLoop(XParam, XForcing, XModel, XModel_g);\n\n    T TheoryInput = Q * XParam.endtime;\n\n\n    T SimulatedVolume = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.delta, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                SimulatedVolume = SimulatedVolume + XModel.evolv.h[i] * delta * delta;\n            }\n        }\n    }\n\n    SimulatedVolume = SimulatedVolume - initVol;\n\n    T error = abs(SimulatedVolume - TheoryInput);\n\n    return error / TheoryInput &lt; 0.05;\n\n}\n\n\n\ntemplate &lt;class T&gt; bool testboundaries(Param XParam, T maxslope)\n{\n    //T maxslope = 0.45; // the mass conservation is better with smaller slopes \n\n    bool Wall_B;// , Wall_R, Wall_L, Wall_T;\n    //bool ctofA, ctofB, ctofC, ctofD;\n    //bool ftocA, ftocB, ftocC, ftocD;\n\n\n    std::string details;\n    int Bound_type;\n\n\n    XParam.GPUDEVICE = 0;\n    maxslope = 0.0;\n    //Dir = 3;\n    Bound_type = -1;\n    Wall_B = RiverOnBoundary(XParam, maxslope, 3, Bound_type);\n    //Wall_R = RiverOnBoundary(XParam, maxslope, 0, 0);\n    //Wall_L = RiverOnBoundary(XParam, maxslope, 1, 0);\n    //Wall_T = RiverOnBoundary(XParam, maxslope, 2, 0);\n    /*\n\n    if (UnitestA &amp;&amp; UnitestB &amp;&amp; UnitestC &amp;&amp; UnitestD)\n    {\n        log(\"River Volume Conservation Test: Uniform mesh: Success\");\n    }\n    else\n    {\n        log(\"River Volume Conservation Test: Uniform mesh: Failed\");\n        details = UnitestA ? \"successful\" : \"failed\";\n        log(\"\\t Uniform mesh A :\" + details);\n        details = UnitestB ? \"successful\" : \"failed\";\n        log(\"\\t Uniform mesh B :\" + details);\n        details = UnitestC ? \"successful\" : \"failed\";\n        log(\"\\t Uniform mesh C :\" + details);\n        details = UnitestD ? \"successful\" : \"failed\";\n        log(\"\\t Uniform mesh D :\" + details);\n    }\n\n    XParam.minlevel = 0;\n    XParam.maxlevel = 1;\n    XParam.initlevel = 0;\n\n    //Fine to coarse\n    // Change arg 1 and 2 if the slope is changed\n    XParam.AdaptCrit = \"Inrange\";\n    XParam.Adapt_arg1 = \"28.0\";\n    XParam.Adapt_arg2 = \"40.0\";\n    XParam.Adapt_arg3 = \"zb\";\n\n    ftocA = RiverVolumeAdapt(XParam, maxslope, false, false);\n    ftocB = RiverVolumeAdapt(XParam, maxslope, true, false);\n    ftocC = RiverVolumeAdapt(XParam, maxslope, false, true);\n    ftocD = RiverVolumeAdapt(XParam, maxslope, true, true);\n    if (ftocA &amp;&amp; ftocB &amp;&amp; ftocC &amp;&amp; ftocD)\n    {\n        log(\"River Volume Conservation Test: Flow from fine to coarse adapted mesh: Success\");\n    }\n    else\n    {\n        log(\"River Volume Conservation Test: Flow from fine to coarse adapted mesh: Failed\");\n        details = ftocA ? \"successful\" : \"failed\";\n        log(\"\\t Flow from fine to coarse adapted mesh A :\" + details);\n        details = ftocB ? \"successful\" : \"failed\";\n        log(\"\\t Flow from fine to coarse adapted mesh B :\" + details);\n        details = ftocC ? \"successful\" : \"failed\";\n        log(\"\\t Flow from fine to coarse adapted mesh C :\" + details);\n        details = ftocD ? \"successful\" : \"failed\";\n        log(\"\\t Flow from fine to coarse adapted mesh D :\" + details);\n    }\n\n    //coarse to fine\n    // Change arg 1 and 2 if the slope is changed\n    XParam.AdaptCrit = \"Inrange\";\n    XParam.Adapt_arg1 = \"0.0\";\n    XParam.Adapt_arg2 = \"2.0\";\n    XParam.Adapt_arg3 = \"zb\";\n\n    ctofA = RiverVolumeAdapt(XParam, maxslope, false, false);\n    ctofB = RiverVolumeAdapt(XParam, maxslope, true, false);\n    ctofC = RiverVolumeAdapt(XParam, maxslope, false, true);\n    ctofD = RiverVolumeAdapt(XParam, maxslope, true, true);\n    if (ctofA &amp;&amp; ctofB &amp;&amp; ctofC &amp;&amp; ctofD)\n    {\n        log(\"River Volume Conservation Test: Flow from coarse to fine adapted mesh: Success\");\n    }\n    else\n    {\n        log(\"River Volume Conservation Test: Flow from coarse to fine adapted: Failed\");\n        details = ctofA ? \"successful\" : \"failed\";\n        log(\"\\t Flow from coarse to fine adapted mesh A :\" + details);\n        details = ctofB ? \"successful\" : \"failed\";\n        log(\"\\t Flow from coarse to fine adapted mesh B :\" + details);\n        details = ctofC ? \"successful\" : \"failed\";\n        log(\"\\t Flow from coarse to fine adapted mesh C :\" + details);\n        details = ctofD ? \"successful\" : \"failed\";\n        log(\"\\t Flow from coarse to fine adapted mesh D :\" + details);\n    }*/\n\n    //return (UnitestA * UnitestB * UnitestC * UnitestD * ctofA * ctofB * ctofC * ctofD * ftocA * ftocB * ftocC * ftocD);\n    return(Wall_B);\n}\n\n\ntemplate &lt;class T&gt; bool RiverOnBoundary(Param XParam, T slope, int Dir, int Bound_type)\n{\n    //bool test = true;\n    // Make a Parabolic bathy\n\n    //Param XParam;\n    XParam.GPUDEVICE = -1;\n\n    auto modeltype = XParam.doubleprecision &lt; 1 ? float() : double();\n    Model&lt;decltype(modeltype)&gt; XModel; // For CPU pointers\n    Model&lt;decltype(modeltype)&gt; XModel_g; // For GPU pointers\n\n    Forcing&lt;float&gt; XForcing;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    float* dummybathy;\n\n    //Boundary conditions\n    XForcing.top.type = 0;\n    XForcing.bot.type = 0;\n    XForcing.right.type = 0;\n    XForcing.left.type = 0;\n\n    //Physical wall boundary condition\n    bool PhysWall = 0;\n    if (Bound_type == -1)\n    {\n        PhysWall = 1;\n        Bound_type = 0;\n    }\n\n    if (Dir == 0) //To right\n    {\n        XForcing.right.type = Bound_type;\n        XForcing.top.type = 0;\n    }\n    else if (Dir == 1) //To left\n    {\n        XForcing.left.type = Bound_type;\n        XForcing.bot.type = 0;\n    }\n    else if (Dir == 2) //To top\n    {\n        XForcing.top.type = Bound_type;\n        XForcing.left.type = 0;\n    }\n    else if (Dir == 3) //To bottom\n    {\n        XForcing.bot.type = Bound_type;\n        XForcing.right.type = 0;\n    }\n\n    XForcing.Bathy.push_back(bathy);\n\n    XForcing.Bathy[0].xo = 0.0;\n    XForcing.Bathy[0].yo = 0.0;\n    XForcing.Bathy[0].xmax = 31.0;\n    XForcing.Bathy[0].ymax = 31.0;\n    XForcing.Bathy[0].nx = 32;\n    XForcing.Bathy[0].ny = 32;\n\n    XForcing.Bathy[0].dx = 1.0;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n    T x, y;\n    T center = T(31.0);\n\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, dummybathy);\n\n\n    //float maxtopo = std::numeric_limits&lt;float&gt;::min();\n    float mintopo = 1000000000000.0f;\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            x = T(XForcing.Bathy[0].xo + i * XForcing.Bathy[0].dx);\n            y = T(XForcing.Bathy[0].yo + j * XForcing.Bathy[0].dx);\n\n\n            dummybathy[i + j * XForcing.Bathy[0].nx] = float(ValleyBathy(y, x, slope, center));\n\n            //Add physical walls\n            if (PhysWall == 1)\n            {\n                //if (j &lt; 3)\n                //{\n                //  dummybathy[i + j * XForcing.Bathy[0].nx] = 100.0;\n                //}\n                if (j &gt; XForcing.Bathy[0].ny - 3)\n                {\n                    dummybathy[i + j * XForcing.Bathy[0].nx] = 100.0;\n                }\n                if (i &gt; XForcing.Bathy[0].nx - 3)\n                {\n                    dummybathy[i + j * XForcing.Bathy[0].nx] = 100.0;\n                }\n                if (i &lt; 17)\n                {\n                    dummybathy[i + j * XForcing.Bathy[0].nx] = 1000.0;\n                }\n            }\n\n            mintopo = utils::min(dummybathy[i + j * XForcing.Bathy[0].nx], mintopo);\n            //maxtopo = max(dummybathy[i + j * XForcing.Bathy[0].nx], maxtopo);\n\n        }\n    }\n\n    // Flip or rotate the bathy according to what is requested\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            if (Dir == 1) //left wise\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = dummybathy[i + j * XForcing.Bathy[0].nx];\n            }\n            else if (Dir == 0) //right wise\n            {\n                XForcing.Bathy[0].val[(XForcing.Bathy[0].nx - 1 - i) + j * XForcing.Bathy[0].nx] = dummybathy[i + j * XForcing.Bathy[0].nx];\n            }\n            else if (Dir == 3) //bottom wise\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = dummybathy[j + i * XForcing.Bathy[0].nx];\n            }\n            else if (Dir == 2) //top wise\n            {\n                XForcing.Bathy[0].val[i + (XForcing.Bathy[0].ny - 1 - j) * XForcing.Bathy[0].nx] = dummybathy[j + i * XForcing.Bathy[0].nx];\n            }\n        }\n    }\n\n    free(dummybathy);\n\n    // Overrule whatever is set in the river forcing\n    T Q = T(1.0);\n\n    double riverx = (Dir == 0 | Dir == 2) ? 6.0 : 25.0; //Dir=1 =&gt;leftward\n    double rivery = (Dir == 2 | Dir == 1) ? 6.0 : 25.0; //Dir=2 =&gt;topward\n\n    //Create a temporary file with river fluxes\n    std::ofstream river_file(\n        \"testriver.tmp\", std::ios_base::out | std::ios_base::trunc);\n    river_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file &lt;&lt; \"3600.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file.close(); //destructor implicitly does it\n\n    River thisriver;\n    thisriver.Riverflowfile = \"testriver.tmp\";\n    thisriver.xstart = riverx - 1.0;\n    thisriver.xend = riverx + 1.0;\n    thisriver.ystart = rivery - 1.0;\n    thisriver.yend = rivery + 1.0;\n\n    XForcing.rivers.push_back(thisriver);\n\n\n    XForcing.rivers[0].flowinput = readFlowfile(XForcing.rivers[0].Riverflowfile, XParam.reftime);\n\n\n    // Overrule whatever may be set in the param file\n    XParam.xmax = XForcing.Bathy[0].xmax;\n    XParam.ymax = XForcing.Bathy[0].ymax;\n    XParam.xo = XForcing.Bathy[0].xo;\n    XParam.yo = XForcing.Bathy[0].yo;\n\n    XParam.dx = XForcing.Bathy[0].dx;\n\n    XParam.zsinit = mintopo + 0.5;// Had a small amount of water to avoid a huge first step that would surely break the setup\n    //XParam.zsoffset = 0.2;\n    XParam.endtime = 50.0;\n    XParam.dtinit = 0.1;\n    XParam.mask = 999.0;\n    XParam.outishift = 0;\n    XParam.outjshift = 0;\n    XParam.ForceMassConserve = true;\n\n\n    XParam.outputtimestep = 10.0;// XParam.endtime;\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    InitSave2Netcdf(XParam, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n    T initVol = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.delta, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                initVol = initVol + XModel.evolv.h[i] * delta * delta;\n            }\n        }\n    }\n\n\n    MainLoop(XParam, XForcing, XModel, XModel_g);\n\n    T TheoryInput = Q * (T)XParam.endtime;\n\n\n    T SimulatedVolume = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.delta, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                SimulatedVolume = SimulatedVolume + XModel.evolv.h[i] * delta * delta;\n            }\n        }\n    }\n\n\n    printf(\"End Volume : %f \\n\", SimulatedVolume);\n    printf(\"Init Volume : %f \\n\", initVol);\n\n    SimulatedVolume = SimulatedVolume - initVol;\n\n    printf(\"End Volume - Init volume : %f \\n\", SimulatedVolume);\n\n    T error = abs(SimulatedVolume - TheoryInput);\n\n    printf(\"error : %f \\n\", error);\n    printf(\"Theory input : %f \\n\", TheoryInput);\n    printf(\"return : %f \\n\", (error / TheoryInput));\n\n\n    return error / TheoryInput &lt; 0.01;\n\n}\n\n\n\ntemplate &lt;class T&gt; bool LakeAtRest(Param XParam, Model&lt;T&gt; XModel)\n{\n    T epsi = T(1e-5);\n    int ib;\n\n    bool test = true;\n\n\n    Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n\n    fillHaloC(XParam, XModel.blocks, XModel.zb);\n\n    gradientC(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    gradientHalo(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n\n    refine_linear(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    gradientHalo(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n\n\n\n\n    //============================================\n    // Predictor step in reimann solver\n    //============================================\n\n    //============================================\n    //  Fill the halo for gradient reconstruction\n    fillHalo(XParam, XModel.blocks, XModel.evolv, XModel.zb);\n\n    //============================================\n    // Reset DTmax\n    InitArrayBUQ(XParam, XModel.blocks, XLoop.hugeposval, XModel.time.dtmax);\n\n    //============================================\n    // Calculate gradient for evolving parameters\n    gradientCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.zb);\n\n    //============================================\n    // Flux and Source term reconstruction\n    // X- direction\n    //updateKurgXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n    UpdateButtingerXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n    //AddSlopeSourceXCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n\n    // Y- direction\n    //updateKurgYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n    UpdateButtingerYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.time.dtmax, XModel.zb);\n    //AddSlopeSourceYCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.flux, XModel.zb);\n\n    //============================================\n    // Fill Halo for flux from fine to coarse\n    fillHalo(XParam, XModel.blocks, XModel.flux);\n\n    // Do we need to check also before fill halo part?\n\n    // Check Fhu and Fhv (they should be zero)\n    int i, iright;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XModel.blocks.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                i = memloc(XParam, ix, iy, ib);\n                iright = memloc(XParam, ix + 1, iy, ib);\n                //ileft = memloc(XParam, ix - 1, iy, ib);\n                //itop = memloc(XParam, ix, iy + 1, ib);\n                //ibot = memloc(XParam, ix, iy - 1, ib);\n\n                if (abs(XModel.flux.Fhu[i]) &gt; epsi)\n                {\n                    log(\"Fhu is not zero. Lake at rest not preserved!!!\");\n                    test = false;\n                }\n\n                if (abs(XModel.flux.Fhv[i]) &gt; epsi)\n                {\n                    log(\"Fhv is not zero. Lake at rest not preserved!!!\");\n                    test = false;\n                }\n\n                T dhus = (XModel.flux.Fqux[i] - XModel.flux.Su[iright]);\n                if (abs(dhus) &gt; epsi)\n                {\n                    test = false;\n\n                    log(\"dhu is not zero. Lake at rest not preserved!!!\");\n\n\n                    printf(\"Fhu[i]=%f\\n\", XModel.flux.Fhu[i]);\n\n                    printf(\"Fqux[i]=%f; Su[iright]=%f; Diff=%f \\n\", XModel.flux.Fqux[i], XModel.flux.Su[iright], (XModel.flux.Fqux[i] - XModel.flux.Su[iright]));\n\n                    printf(\" At i: (ib=%d; ix=%d; iy=%d)\\n\", ib, ix, iy);\n                    testButtingerX(XParam, ib, ix, iy, XModel);\n\n                    printf(\" At iright: (ib=%d; ix=%d; iy=%d)\\n\", ib, ix + 1, iy);\n                    testButtingerX(XParam, ib, ix + 1, iy, XModel);\n\n                }\n\n            }\n        }\n    }\n\n\n    if (!test)\n    {\n        copyID2var(XParam, XModel.blocks, XModel.flux.Fhu);\n        copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.LeftBot, XModel.grad.dhdx);\n        copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.LeftTop, XModel.grad.dhdy);\n        copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.TopLeft, XModel.grad.dzsdx);\n        copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.TopRight, XModel.grad.dzsdy);\n        copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.RightTop, XModel.grad.dudx);\n        copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.RightBot, XModel.grad.dudy);\n        copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.BotRight, XModel.grad.dvdx);\n        copyBlockinfo2var(XParam, XModel.blocks, XModel.blocks.BotLeft, XModel.grad.dvdy);\n\n        creatncfileBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, XModel.blocks.outZone[0]);\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"blockID\", 3, XModel.flux.Fhu, XModel.blocks.outZone[0]);\n\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"LeftBot\", 3, XModel.grad.dhdx, XModel.blocks.outZone[0]);\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"LeftTop\", 3, XModel.grad.dhdy, XModel.blocks.outZone[0]);\n\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"TopLeft\", 3, XModel.grad.dzsdx, XModel.blocks.outZone[0]);\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"TopRight\", 3, XModel.grad.dzsdy, XModel.blocks.outZone[0]);\n\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"RightTop\", 3, XModel.grad.dudx, XModel.blocks.outZone[0]);\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"RightBot\", 3, XModel.grad.dudy, XModel.blocks.outZone[0]);\n\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"BotLeft\", 3, XModel.grad.dvdx, XModel.blocks.outZone[0]);\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"BotRight\", 3, XModel.grad.dvdy, XModel.blocks.outZone[0]);\n    }\n\n    return test;\n}\n\n\ntemplate &lt;class T&gt; void testButtingerX(Param XParam, int ib, int ix, int iy, Model&lt;T&gt; XModel)\n{\n    int RB, levRB, LBRB, LB, levLB, RBLB;\n    int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n    int ileft = memloc(XParam.halowidth, XParam.blkmemwidth, ix - 1, iy, ib);\n\n    int lev = XModel.blocks.level[ib];\n    T delta = calcres(T(XParam.delta), lev);\n\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n\n    // neighbours for source term\n\n    RB = XModel.blocks.RightBot[ib];\n    levRB = XModel.blocks.level[RB];\n    LBRB = XModel.blocks.LeftBot[RB];\n\n    LB = XModel.blocks.LeftBot[ib];\n    levLB = XModel.blocks.level[LB];\n    RBLB = XModel.blocks.RightBot[LB];\n\n\n    T cm = T(1.0);\n    T fmu = T(1.0);\n\n    T hi = XModel.evolv.h[i];\n\n    T hn = XModel.evolv.h[ileft];\n\n\n    //if (hi &gt; eps || hn &gt; eps)\n    {\n        T dx, zi, zn, hr, hl, etar, etal, zr, zl, zA, zCN, hCNr, hCNl;\n        T ui, vi, uli, vli, dhdxi, dhdxil, dudxi, dudxil, dvdxi, dvdxil;\n\n        T ga = g * T(0.5);\n        // along X\n        dx = delta * T(0.5);\n        zi = XModel.zb[i];\n        zn = XModel.zb[ileft];\n\n        ui = XModel.evolv.u[i];\n        vi = XModel.evolv.v[i];\n        uli = XModel.evolv.u[ileft];\n        vli = XModel.evolv.v[ileft];\n\n        dhdxi = XModel.grad.dhdx[i];\n        dhdxil = XModel.grad.dhdx[ileft];\n        dudxi = XModel.grad.dudx[i];\n        dudxil = XModel.grad.dudx[ileft];\n        dvdxi = XModel.grad.dvdx[i];\n        dvdxil = XModel.grad.dvdx[ileft];\n\n\n        hr = hi - dx * dhdxi;\n        hl = hn + dx * dhdxil;\n        etar = XModel.evolv.zs[i] - dx * XModel.grad.dzsdx[i];\n        etal = XModel.evolv.zs[ileft] + dx * XModel.grad.dzsdx[ileft];\n\n        //define the topography term at the interfaces\n        zr = zi - dx * XModel.grad.dzbdx[i];\n        zl = zn + dx * XModel.grad.dzbdx[ileft];\n\n        //define the Audusse terms\n        zA = max(zr, zl);\n\n        // Now the CN terms\n        zCN = min(zA, min(etal, etar));\n        hCNr = max(T(0.0), min(etar - zCN, hr));\n        hCNl = max(T(0.0), min(etal - zCN, hl));\n\n        //Velocity reconstruction\n        //To avoid high velocities near dry cells, we reconstruct velocities according to Bouchut.\n        T ul, ur, vl, vr, sl, sr;\n        if (hi &gt; eps) {\n            ur = ui - (T(1.) + dx * dhdxi / hi) * dx * dudxi;\n            vr = vi - (T(1.) + dx * dhdxi / hi) * dx * dvdxi;\n        }\n        else {\n            ur = ui - dx * dudxi;\n            vr = vi - dx * dvdxi;\n        }\n        if (hn &gt; eps) {\n            ul = uli + (T(1.) - dx * dhdxil / hn) * dx * dudxil;\n            vl = vli + (T(1.) - dx * dhdxil / hn) * dx * dvdxil;\n        }\n        else {\n            ul = uli + dx * dudxil;\n            vl = vli + dx * dvdxil;\n        }\n\n\n\n\n        T fh, fu, fv, dt;\n\n\n        //solver below also modifies fh and fu\n        dt = hllc(g, delta, epsi, CFL, cm, fmu, hCNl, hCNr, ul, ur, fh, fu);\n        //hllc(T g, T delta, T epsi, T CFL, T cm, T fm, T hm, T hp, T um, T up, T &amp; fh, T &amp; fq)\n\n\n\n        fv = (fh &gt; 0. ? vl : vr) * fh;\n\n\n        // Topographic source term\n\n        // In the case of adaptive refinement, care must be taken to ensure\n        // well-balancing at coarse/fine faces (see [notes/balanced.tm]()). \n        if ((ix == XParam.blkwidth) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n        {\n            int jj = LBRB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n            int iright = memloc(XParam.halowidth, XParam.blkmemwidth, 0, jj, RB);;\n            hi = XModel.evolv.h[iright];\n            zi = XModel.zb[iright];\n        }\n        if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo if you \n        {\n            int jj = RBLB == ib ? ftoi(floor(iy * (T)0.5)) : ftoi(floor(iy * (T)0.5) + XParam.blkwidth / 2);\n            int ilc = memloc(XParam.halowidth, XParam.blkmemwidth, XParam.blkwidth - 1, jj, LB);\n            //int ilc = memloc(halowidth, blkmemwidth, -1, iy, ib);\n            hn = XModel.evolv.h[ilc];\n            zn = XModel.zb[ilc];\n        }\n\n        sl = ga * (hi + hCNr) * (zi - zCN);\n        sr = ga * (hCNl + hn) * (zn - zCN);\n\n\n        printf(\"dt=%f; etar=%f; etal=%f; zCN=%f; zi=%f; zn=%f; zA=%f, zr=%f, zl=%f\\n\", dt, etar, etal, zCN, zi, zn, zA, zr, zl);\n\n\n        printf(\"hi=%f; hn=%f,fh=%f; fu=%f; sl=%f; sr=%f; hCNl=%f; hCNr=%f; hr=%f; hl=%f; zr=%f; zl=%f;\\n\", hi, hn, fh, fu, sl, sr, hCNl, hCNr, hr, hl, zr, zl);\n\n        printf(\"h[i]=%f; h[ileft]=%f dhdx[i]=%f, dhdx[ileft]=%f, zs[i]=%f, zs[ileft]=%f, dzsdx[i]=%f, dzsdx[ileft]=%f, dzbdx[i]=%f, dzbdx[ileft]=%f\\n\\n\", XModel.evolv.h[i], XModel.evolv.h[ileft], XModel.grad.dhdx[i], XModel.grad.dhdx[ileft], XModel.evolv.zs[i], XModel.evolv.zs[ileft], XModel.grad.dzsdx[i], XModel.grad.dzsdx[ileft], XModel.grad.dzbdx[i], XModel.grad.dzbdx[ileft]);\n    }\n}\n\n\ntemplate &lt;class T&gt; void testkurganovX(Param XParam, int ib, int ix, int iy, Model&lt;T&gt; XModel)\n{\n    int RB, levRB, LBRB, LB, levLB, RBLB;\n    int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n    int ileft = memloc(XParam.halowidth, XParam.blkmemwidth, ix - 1, iy, ib);\n\n    int lev = XModel.blocks.level[ib];\n    T delta = calcres(T(XParam.delta), lev);\n\n    T g = T(XParam.g);\n    T CFL = T(XParam.CFL);\n    T epsi = nextafter(T(1.0), T(2.0)) - T(1.0);\n    T eps = T(XParam.eps) + epsi;\n\n    // neighbours for source term\n\n    RB = XModel.blocks.RightBot[ib];\n    levRB = XModel.blocks.level[RB];\n    LBRB = XModel.blocks.LeftBot[RB];\n\n    LB = XModel.blocks.LeftBot[ib];\n    levLB = XModel.blocks.level[LB];\n    RBLB = XModel.blocks.RightBot[LB];\n\n    T dhdxi = XModel.grad.dhdx[i];\n    T dhdxmin = XModel.grad.dhdx[ileft];\n    T cm = T(1.0);\n    T fmu = T(1.0);\n\n    T hi = XModel.evolv.h[i];\n\n    T hn = XModel.evolv.h[ileft];\n    T dx, zi, zl, zn, zr, zlr, hl, up, hp, hr, um, hm, ga;\n\n    // along X\n    dx = delta * T(0.5);\n    zi = XModel.evolv.zs[i] - hi;\n\n    //printf(\"%f\\n\", zi);\n\n\n    //zl = zi - dx*(dzsdx[i] - dhdx[i]);\n    zl = zi - dx * (XModel.grad.dzsdx[i] - dhdxi);\n    //printf(\"%f\\n\", zl);\n\n    zn = XModel.evolv.zs[ileft] - hn;\n\n    //printf(\"%f\\n\", zn);\n    zr = zn + dx * (XModel.grad.dzsdx[ileft] - dhdxmin);\n\n\n    zlr = max(zl, zr);\n\n    //hl = hi - dx*dhdx[i];\n    hl = hi - dx * dhdxi;\n    up = XModel.evolv.u[i] - dx * XModel.grad.dudx[i];\n    hp = max(T(0.0), hl + zl - zlr);\n\n    hr = hn + dx * dhdxmin;\n    um = XModel.evolv.u[ileft] + dx * XModel.grad.dudx[ileft];\n    hm = max(T(0.0), hr + zr - zlr);\n\n    ga = g * T(0.5);\n    T fh, fu, fv, sl, sr, dt;\n\n    //solver below also modifies fh and fu\n    dt = KurgSolver(g, delta, epsi, CFL, cm, fmu, hp, hm, up, um, fh, fu);\n\n    if ((ix == XParam.blkwidth) &amp;&amp; levRB &lt; lev)//(ix==16) i.e. in the right halo\n    {\n        int jj = LBRB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + XParam.blkwidth / 2;\n        int iright = memloc(XParam.halowidth, XParam.blkmemwidth, 0, jj, RB);;\n        hi = XModel.evolv.h[iright];\n        zi = XModel.zb[iright];\n    }\n    if ((ix == 0) &amp;&amp; levLB &lt; lev)//(ix==16) i.e. in the right halo if you \n    {\n        int jj = RBLB == ib ? floor(iy * (T)0.5) : floor(iy * (T)0.5) + XParam.blkwidth / 2;\n        int ilc = memloc(XParam.halowidth, XParam.blkmemwidth, XParam.blkwidth - 1, jj, LB);\n        hn = XModel.evolv.h[ilc];\n        zn = XModel.zb[ilc];\n    }\n\n\n    sl = ga * (utils::sq(hp) - utils::sq(hl) + (hl + hi) * (zi - zl));\n    sr = ga * (utils::sq(hm) - utils::sq(hr) + (hr + hn) * (zn - zr));\n\n    //Fhu[i] = fmu * fh;\n    //Fqux[i] = fmu * (fu - sl);\n    //Su[i] = fmu * (fu - sr);\n    //Fqvx[i] = fmu * fv;\n\n    printf(\"hi=%f; hn=%f,fh=%f; fu=%f; sl=%f; sr=%f; hp=%f; hm=%f; hr=%f; hl=%f; zr=%f; zl=%f;\\n\", hi, hn, fh, fu, sl, sr, hp, hm, hr, hl, zr, zl);\n\n    printf(\"h[i]=%f; h[ileft]=%f dhdx[i]=%f, dhdx[ileft]=%f, zs[i]=%f, zs[ileft]=%f, dzsdx[i]=%f, dzsdx[ileft]=%f\\n\", XModel.evolv.h[i], XModel.evolv.h[ileft], XModel.grad.dhdx[i], XModel.grad.dhdx[ileft], XModel.evolv.zs[i], XModel.evolv.zs[ileft], XModel.grad.dzsdx[i], XModel.grad.dzsdx[ileft]);\n\n}\n\ntemplate &lt;class T&gt; bool Raintest(T zsnit, int gpu, float alpha,int engine)\n{\n    log(\"#####\");\n    Param XParam;\n    T initVol, TheoryInput;\n    TheoryInput = T(0.0);\n    // initialise domain and required resolution\n    XParam.dx = 1.0 / ((1 &lt;&lt; 6)); //1&lt;&lt;8  = 2^8\n    XParam.xo = -0.5;\n    XParam.yo = -0.5;\n    XParam.xmax = 0.5;\n    XParam.ymax = 0.5;\n\n    XParam.engine = engine;\n\n    //XParam.initlevel = 0;\n    //XParam.minlevel = 0;\n    //XParam.maxlevel = 0;\n\n    XParam.zsinit = zsnit;\n    //XParam.zsoffset = 0.0;\n\n    //Output times for comparisons\n    XParam.endtime = 1.0;\n    XParam.outputtimestep = 0.1;\n\n    XParam.smallnc = 0;\n\n    XParam.cf = 0.01;\n    XParam.frictionmodel = 0;\n\n    //Specification of the test\n    //XParam.test = 7;\n    XParam.rainforcing = true;\n    XParam.ForceMassConserve = true;\n\n    // Enforce GPU/CPU\n    XParam.GPUDEVICE = gpu;\n    XParam.rainbnd = true;\n    //output vars\n    std::vector&lt;std::string&gt; outv = { \"zb\",\"h\",\"zs\",\"u\",\"v\" };\n    XParam.outvars = outv;\n\n    // create Model setup\n    Model&lt;T&gt; XModel;\n    Model&lt;T&gt; XModel_g;\n\n    Forcing&lt;float&gt; XForcing;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    XForcing.Bathy.push_back(bathy);\n\n    // initialise forcing bathymetry to 0\n    XForcing.Bathy[0].xo = -1.0;\n    XForcing.Bathy[0].yo = -1.0;\n    XForcing.Bathy[0].xmax = 1.0;\n    XForcing.Bathy[0].ymax = 1.0;\n    XForcing.Bathy[0].nx = 3;\n    XForcing.Bathy[0].ny = 3;\n\n    XForcing.Bathy[0].dx = 1.0;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = i * alpha / 100;\n        }\n    }\n\n    // Add wall boundary conditions\n    XForcing.right.type = 0;\n    XForcing.left.type = 0;\n    XForcing.top.type = 0;\n    XForcing.bot.type = 0;\n\n\n    //Value definition for surface rain fall\n    T Q = 300; // mm/hr\n    std::cout &lt;&lt; \"# Theoretical volume of water input during the simulation in m3: \" &lt;&lt; TheoryInput &lt;&lt; \", from a rain input of: \" &lt;&lt; Q &lt;&lt; \"mm/hr.\" &lt;&lt; std::endl;\n    //Create a temporary file with rain fluxes\n    std::ofstream rain_file(\n        \"testrain.tmp\", std::ios_base::out | std::ios_base::trunc);\n    rain_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    rain_file &lt;&lt; \"3600.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    rain_file.close(); //destructor implicitly does it\n\n    XForcing.Rain.inputfile = \"testrain.tmp\";\n    XForcing.Rain.uniform = true;\n\n    // Reading rain forcing from file for CPU and unifor rain\n    XForcing.Rain.unidata = readINfileUNI(XForcing.Rain.inputfile, XParam.reftime);\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n    initVol = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.delta, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                initVol = initVol + XModel.evolv.h[i] * delta * delta;\n            }\n        }\n    }\n\n\n    MainLoop(XParam, XForcing, XModel, XModel_g);\n\n    TheoryInput = Q / T(1000.0) / T(3600.0) * XParam.endtime;\n\n\n    T SimulatedVolume = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.delta, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                SimulatedVolume = SimulatedVolume + XModel.evolv.h[i] * delta * delta;\n            }\n        }\n    }\n\n    SimulatedVolume = SimulatedVolume - initVol;\n\n    T error = abs(SimulatedVolume - TheoryInput);\n\n    T modelgood = error / TheoryInput &lt; 0.05;\n\n    //log(\"#####\");\n    return modelgood;\n}\n\n\nbool Raintestinput(int gpu)\n{\n    //Results of the experiment of Aureli, interpolated to output values\n    bool modelgood1, modelgood2;\n    std::string result;\n    //int dim_flux;\n    std::vector&lt;float&gt; Flux1D, Flux3DUni, Flux3D, Flux_obs;\n    float diff, ref, error;\n\n\n    //Comparison between the 1D forcing and the 3D hommgeneous forcing\n    Flux1D = Raintestmap(gpu, 1, -0.03);\n    Flux3DUni = Raintestmap(gpu, 31, -0.03);\n    ref = 0.0;\n    diff = 0.0;\n    for (int i = 0; i &lt; Flux1D.size(); i++)\n    {\n        diff = diff + Flux1D[i] - Flux3DUni[i];\n        ref = ref + Flux1D[i];\n    }\n\n    error = abs(diff / ref);\n    printf(\"Error %f \\n\", error);\n\n    modelgood1 = error &lt; 0.005;\n    result = modelgood1 ? \"successful\" : \"failed\";\n    log(\"\\t\\tRain test input 1D vs 3D homogeneous: \" + result);\n\n    //Comparison between the 3D forcing and the observations from Iwagaki1955.\n\n    //From Observations\n    //Flux_obs = { 1.75136262,  4.31856716, 24.36350225, 32.02235696, 32.41207121,\n    //   31.68632601, 29.8140878 , 47.9632521 , 68.78608061, 57.03656989 };\n\n    //From BG_run of the testcase\n    Flux_obs = { 4.003079, 12.664897, 25.376514, 33.214722, 34.987427, 34.054474,\n        32.696472, 30.718161, 89.497993, 58.156021 };\n\n    Flux3D = Raintestmap(gpu, 3, -0.03);\n    ref = 0.0;\n    diff = 0.0;\n    for (int i = 0; i &lt; Flux3D.size(); i++)\n    {\n        diff = diff + Flux_obs[i] - Flux3D[i];\n        ref = ref + Flux3D[i];\n    }\n\n    error = abs(diff / ref);\n    printf(\"Error %f \\n\", error);\n\n    modelgood2 = error &lt; 0.00005;\n    result = modelgood2 ? \"successful\" : \"failed\";\n    log(\"\\t\\tRain test input 3D map vs Iwagaki1955: \" + result);\n\n    return (modelgood1 * modelgood2);\n}\n\ntemplate &lt;class T&gt; std::vector&lt;float&gt; Raintestmap(int gpu, int dimf, T zinit)\n{\n    log(\"#####\");\n    int k;\n    T rainDuration = 10.0;\n    int NX = 2502;\n    int NY = 22;\n    int NT;\n    double* xRain;\n    double* yRain;\n    double* tRain;\n    double* rainForcing;\n\n\n    Param XParam;\n    T delta;\n\n    // initialise domain and required resolution\n    XParam.xo = 0;\n    XParam.yo = 0;\n    XParam.ymax = 0.196;\n    XParam.dx = (XParam.ymax - XParam.yo) / (1 &lt;&lt; 1);\n    XParam.delta = XParam.dx;\n    double Xmax_exp = 28.0; //minimum Xmax position (adjust to have a \"full blocks\" config)\n    //Calculating xmax to have full blocs with at least a full block behaving as a reservoir\n    XParam.xmax = XParam.xo + (16 * XParam.dx) * std::ceil((Xmax_exp - XParam.xo) / (16 * XParam.dx)) + (16 * XParam.dx);\n    //Surf = T((XParam.xmax - XParam.xo) * (XParam.ymax - XParam.yo));\n    XParam.nblk = ftoi(((XParam.xmax - XParam.xo) / XParam.dx / 16) * ((XParam.ymax - XParam.yo) / XParam.dx / 16));\n    XParam.rainbnd = true;\n    XParam.zsinit = zinit;\n\n    //Output times for comparisons\n    XParam.endtime = 30.0;\n    XParam.outputtimestep = 3.0;\n\n    XParam.smallnc = 0;\n\n    //Specification of the test\n    XParam.test = 8;\n\n    // Enforce GPU/CPU\n    XParam.GPUDEVICE = gpu;\n\n    //Bottom friction\n    XParam.frictionmodel = -1; //Manning model\n    XParam.cf = 0.009; //n in m^(-1/3)s\n\n    std::string outvi[16] = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"Su\", \"Sv\" };\n\n    std::vector&lt;std::string&gt; outv;\n\n    for (int nv = 0; nv &lt; 15; nv++)\n    {\n        outv.push_back(outvi[nv]);\n    }\n\n    XParam.outvars = outv;\n\n    // create Model setup\n    Model&lt;T&gt; XModel;\n    Model&lt;T&gt; XModel_g;\n\n    Forcing&lt;float&gt; XForcing;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    XForcing.Bathy.push_back(bathy);\n\n    // initialise forcing bathymetry to 0\n    XForcing.Bathy[0].xo = -1.0;\n    XForcing.Bathy[0].yo = -1.0;\n    XForcing.Bathy[0].xmax = 28.0;\n    XForcing.Bathy[0].ymax = 1.0;\n    XForcing.Bathy[0].dx = 0.1;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n    XForcing.Bathy[0].nx = ftoi((XForcing.Bathy[0].xmax - XForcing.Bathy[0].xo) / XForcing.Bathy[0].dx + 1);\n    XForcing.Bathy[0].ny = ftoi((XForcing.Bathy[0].ymax - XForcing.Bathy[0].yo) / XForcing.Bathy[0].dx + 1);\n\n\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = -10.0;\n            if (i &lt; (9 / XForcing.Bathy[0].dx + 1))\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = T(0.2 + (9.0 - i * XForcing.Bathy[0].dx) * 2.0 / 100.0);\n            }\n            else if (i &lt; (17 / XForcing.Bathy[0].dx + 1))\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = T(0.08 + (17.0 - i * XForcing.Bathy[0].dx) * 1.5 / 100.0);\n            }\n            else if (i &lt; (25 / XForcing.Bathy[0].dx + 1))\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = T(0.0 + (25.0 - i * XForcing.Bathy[0].dx) * 1.0 / 100.0);\n            }\n        }\n    }\n\n    // Add wall boundary conditions but at the bottom of the slope\n    //XForcing.right.type = 0;\n    XForcing.left.type = 0;\n    //XForcing.top.type = 0;\n    //XForcing.bot.type = 0;\n\n    //Value definition for surface rain fall\n    T r1 = T(3888.0); // mm/hr\n    T r2 = T(2296.8); //mm/hr\n    T r3 = T(2880.0); //mm/hr\n    T Q = (r1 + r2 + r3) / 3;\n    //TheoryInput = Q * XParam.outputtimestep / T(1000.0) / T(3600.0) * Surf; //m3/s\n    //printf(\"# Theoretical volume of water input during the simulation in m3: %f , from a mean rain input of: %f mm/hr.\\n\", TheoryInput, Q);\n    double eps = 0.0001;\n\n    // Create the rain forcing file\n    if (dimf == 1)\n    {\n        //Create a temporary file with rain fluxes for uniform rain\n        std::ofstream rain_file(\n            \"testrain.tmp\", std::ios_base::out | std::ios_base::trunc);\n        rain_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n        rain_file &lt;&lt; std::to_string(rainDuration) + \" \" + std::to_string(Q) &lt;&lt; std::endl;\n        rain_file &lt;&lt; std::to_string(rainDuration + eps) + \" 0.0\" &lt;&lt; std::endl;\n        rain_file &lt;&lt; std::to_string(rainDuration + 360000) + \" 0.0\" &lt;&lt; std::endl;\n        rain_file.close(); //destructor implicitly does it\n\n        XForcing.Rain.inputfile = \"testrain.tmp\";\n        XForcing.Rain.uniform = true;\n\n        // Reading rain forcing from file for CPU and uniform rain\n        XForcing.Rain.unidata = readINfileUNI(XForcing.Rain.inputfile, XParam.reftime);\n        printf(\"1D rain forcing read\\n\");\n    }\n    else //non-uniform forcing\n    {\n        XForcing.Rain.uniform = false;\n\n        //X Y variables\n\n        xRain = (double*)malloc(sizeof(double) * NX);\n        yRain = (double*)malloc(sizeof(double) * NY);\n\n        for (int i = 0; i &lt; NX; i++) { xRain[i] = -0.005 + 0.01 * i; }\n        for (int j = 0; j &lt; NY; j++) { yRain[j] = -0.01 + 0.01 * j; }\n\n        NT = 601;\n        tRain = (double*)malloc(sizeof(double) * NT);\n        for (int tt = 0; tt &lt; NT; tt++) { tRain[tt] = XParam.endtime / (NT - 1) * tt; }\n\n        rainForcing = (double*)malloc(sizeof(double) * NT * NY * NX);\n\n        //Create a non-uniform time-variable rain forcing\n        if (dimf == 3)\n        {\n            //Create the rain forcing:\n            for (k = 0; k &lt; NT; k++)\n            {\n                for (int j = 0; j &lt; NY; j++)\n                {\n                    for (int i = 0; i &lt; NX; i++)\n                    {\n                        if (tRain[k] &lt; rainDuration + eps)\n                        {\n                            if (xRain[i] &lt; 8.0)\n                            {\n                                rainForcing[k * (NX * NY) + j * NX + i] = r1;\n                            }\n                            else if (xRain[i] &lt; 16.0)\n                            {\n                                rainForcing[k * (NX * NY) + j * NX + i] = r2;\n                            }\n                            else\n                            {\n                                rainForcing[k * (NX * NY) + j * NX + i] = r3;\n                            }\n                        }\n                        else\n                        {\n                            rainForcing[k * (NX * NY) + i * NY + j] = 0.0;\n                        }\n                    }\n                }\n            }\n\n            //Write the netcdf file\n            create3dnc(\"rainTemp.nc\", NX, NY, NT, xRain, yRain, tRain, rainForcing, \"myrainforcing\");\n\n            printf(\"non-uniform forcing\\n\");\n\n            //End creation of the nc file for rain forcing\n        }\n        //Create a uniform time-variable rain forcing using a map forcing (nc file)\n        else if (dimf == 31)\n        {\n            //Create the rain forcing:\n            for (k = 0; k &lt; NT; k++)\n            {\n                for (int j = 0; j &lt; NY; j++)\n                {\n                    for (int i = 0; i &lt; NX; i++)\n                    {\n                        if (tRain[k] &lt; rainDuration + eps)\n                        {\n                            rainForcing[k * (NX * NY) + j * NX + i] = Q;\n                        }\n                        else\n                        {\n                            rainForcing[k * (NX * NY) + i * NY + j] = 0.0;\n                        }\n                    }\n                }\n            }\n\n            //Write the netcdf file\n            create3dnc(\"rainTemp.nc\", NX, NY, NT, xRain, yRain, tRain, rainForcing, \"myrainforcing\");\n\n            printf(\"non-uniform forcing 31\\n\");\n            //End creation of the nc file for rain forcing\n        }\n        /*\n        //2D forcing (map without time variation is not working)\n        else if (dimf == 2)//dimf==2 for rain forcing\n        {\n\n            //Create a non-uniform time-constant rain forcing\n            rainForcing = (double*)malloc(sizeof(double) * NY * NX);\n\n            //Create the rain forcing:\n\n            for (int j = 0; j &lt; NY; j++)\n            {\n                for (int i = 0; i &lt; NX; i++)\n                {\n\n                    if (xRain[i] &lt; 8.0)\n                    {\n                        rainForcing[j * NX + i] = r1;\n                    }\n                    else if (xRain[i] &lt; 16.0)\n                    {\n                        rainForcing[j * NX + i] = r2;\n                    }\n                    else\n                    {\n                        rainForcing[j * NX + i] = r3;\n                    }\n\n                }\n            }\n\n            create2dnc(\"rainTempt.nc\", NX, NY, xRain, yRain, rainForcing, \"myrainforcing\");\n\n            //End creation of the nc file for rain forcing\n        }\n        */\n        else { printf(\"Error in rain forcing dimension (should be in [1,3,31])\\n\"); }\n\n        //Reading non-unform forcing\n        bool gpgpu = 0;\n        if (XParam.GPUDEVICE != -1)\n        {\n            gpgpu = 1;\n        }\n\n        XForcing.Rain = readfileinfo(\"rainTemp.nc\", XForcing.Rain);\n        XForcing.Rain.uniform = 0;\n        XForcing.Rain.varname = \"myrainforcing\";\n\n\n        InitDynforcing(gpgpu, XParam, XForcing.Rain);\n\n        //readDynforcing(gpgpu, XParam.totaltime, XForcing.Rain);\n\n\n        free(rainForcing);\n        free(xRain);\n        free(yRain);\n        free(tRain);\n    }\n\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    log(\"Initialising model main loop\");\n\n    Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n\n    //Define some useful variables \n    Initmeanmax(XParam, XLoop, XModel, XModel_g);\n\n\n    log(\"\\t\\tCompleted\");\n    log(\"Model Running...\");\n    std::vector&lt;float&gt; Flux;\n\n    while (XLoop.totaltime &lt; XParam.endtime)\n    {\n\n        // Calculate Forcing at this step\n        updateforcing(XParam, XLoop, XForcing);\n\n        // Core engine\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            FlowGPU(XParam, XLoop, XForcing, XModel_g);\n        }\n        else\n        {\n            FlowCPU(XParam, XLoop, XForcing, XModel);\n        }\n\n        // Time keeping\n        XLoop.totaltime = XLoop.totaltime + XLoop.dt;\n        //printf(\"\\tTime = %f \\n\", XLoop.totaltime);\n\n        //if Toutput, calculate the flux at x=24m;\n\n\n        // Getting the coordinate for the flux calculation\n        int bl, ixx, ibl, ix, ib;\n        T dist = T(1000000000.0);\n        for (ibl = 0; ibl &lt; XParam.nblk; ibl++)\n        {\n            ib = XModel.blocks.active[ibl];\n            delta = calcres(T(XParam.dx), XModel.blocks.level[ib]);\n            for (ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //n = memloc(XParam, ix, 0, ib);\n                if (abs(XModel.blocks.xo[ibl] + ix * delta - 24.0) &lt; dist)\n                {\n                    ixx = ix;\n                    bl = ibl;\n                    dist = T(abs(XModel.blocks.xo[ibl] + ix * delta - 24.0));\n                }\n            }\n        }\n\n        if (XLoop.nextoutputtime - XLoop.totaltime &lt;= XLoop.dt * T(0.00001) &amp;&amp; XParam.outputtimestep &gt; 0.0)\n        {\n            T finalFlux = T(0.0);\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n                {\n                    CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[XParam.outvars[ivar]], XModel_g.OutputVarMap[XParam.outvars[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n                }\n            }\n\n            Save2Netcdf(XParam, XLoop, XModel);\n\n\n            //Calculation of the flux at the bottom of the slope (x=24m)\n            ib = XModel.blocks.active[bl];\n            delta = calcres(T(XParam.delta), XModel.blocks.level[ib]);\n\n            for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n            {\n                int n = memloc(XParam, ixx, iy, ib);\n                finalFlux = finalFlux + XModel.evolv.h[n] * XModel.evolv.u[n] * delta;\n            }\n            finalFlux = finalFlux / float(XParam.ymax - XParam.yo) * 100.0f * 100.0f;\n            Flux.push_back(finalFlux);\n            XLoop.nextoutputtime = XLoop.nextoutputtime + XParam.outputtimestep;\n            printf(\"\\tTime = %f, Flux at bottom end of slope : %f \\n\", XLoop.totaltime, finalFlux);\n        }\n    }\n    /*\n    for (int n = 0; n &lt; Flux.size(); n++)\n    {\n        printf(\"Flux at %i : %f \\n\", n, Flux[n]);\n    }\n    */\n\n    return Flux;\n}\ntemplate std::vector&lt;float&gt; Raintestmap&lt;float&gt;(int gpu, int dimf, float Zsinit);\ntemplate std::vector&lt;float&gt; Raintestmap&lt;double&gt;(int gpu, int dimf, double Zsinit);\n\n\ntemplate &lt;class T&gt; bool ZoneOutputTest(int nzones, T zsinit)\n//template bool ZoneOutputTest&lt;float&gt;(int nzones, float zsinit);\n{\n    log(\"#####\");\n\n    Param XParam;\n    Forcing&lt;float&gt; XForcing;\n\n\n    if (nzones == 3)\n    {\n        // read param file\n        //readforcing(XParam, XForcing);\n        outzoneP zone;\n        zone.outname = \"whole.nc\";\n        zone.xstart = -10;\n        zone.xend = 10;\n        zone.ystart = -10;\n        zone.yend = 10;\n        XParam.outzone.push_back(zone);\n        zone.outname = \"zoomed.nc\";\n        zone.xstart = 1;\n        zone.xend = 2;\n        zone.ystart = -2;\n        zone.yend = 2;\n        XParam.outzone.push_back(zone);\n        zone.outname = \"zoomed2.nc\";\n        zone.xstart = -2;\n        zone.xend = 2;\n        zone.ystart = -4;\n        zone.yend = 2;\n        XParam.outzone.push_back(zone);\n    }\n\n    // initialise domain and required resolution\n    XParam.dx = 1.0 / ((1 &lt;&lt; 6)); //1&lt;&lt;8  = 2^8\n    XParam.xo = -5;\n    XParam.yo = -5;\n    XParam.xmax = 5;\n    XParam.ymax = 5;\n\n    XParam.initlevel = 0;\n    XParam.minlevel = -1;\n    XParam.maxlevel = 1;\n\n    XParam.zsinit = zsinit;\n    //XParam.zsoffset = 0.0;\n\n    //Output times for comparisons\n    XParam.endtime = 1.0;\n    XParam.outputtimestep = 0.5;\n\n    XParam.smallnc = 0;\n\n    XParam.cf = 0.0001;\n    XParam.frictionmodel = 1;\n\n    //Specification of the test\n    //XParam.test = 7;\n    XParam.rainforcing = true;\n\n    // Enforce GPU/CPU\n    //XParam.GPUDEVICE = gpu;\n    //XParam.rainbnd = true;\n\n    // create Model setup\n    Model&lt;T&gt; XModel;\n    Model&lt;T&gt; XModel_g;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    XForcing.Bathy.push_back(bathy);\n\n    // initialise forcing bathymetry to a central hill\n    XForcing.Bathy[0].xo = -10.0;\n    XForcing.Bathy[0].yo = -10.0;\n    XForcing.Bathy[0].xmax = 10.0;\n    XForcing.Bathy[0].ymax = 10.0;\n    XForcing.Bathy[0].nx = 501;\n    XForcing.Bathy[0].ny = 501;\n\n    XForcing.Bathy[0].dx = 0.1;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n\n    float rs, x, y, r, hm;\n    rs = 20; //hill radio \n    hm = 5; //hill top\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            x = float(XForcing.Bathy[0].xo + i * XForcing.Bathy[0].dx);\n            y = float(XForcing.Bathy[0].yo + j * XForcing.Bathy[0].dx);\n            r = sqrt(x * x + y * y);\n            if (r &lt; rs)\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = hm * (1 - r / rs);\n            }\n            if (x &lt; -4.7 | x &gt; 4.7 | y &lt; -4.7 | y &gt; 4.7)\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = 10;\n            }\n        }\n    }\n\n    //Adaptation\n    XParam.AdaptCrit = \"Targetlevel\";\n\n    StaticForcingP&lt;int&gt; Target;\n    XForcing.targetadapt.push_back(Target);\n\n    XForcing.targetadapt[0].xo = -10;\n    XForcing.targetadapt[0].yo = -10;\n    XForcing.targetadapt[0].xmax = 10.0;\n    XForcing.targetadapt[0].ymax = 10.0;\n    XForcing.targetadapt[0].nx = 501;\n    XForcing.targetadapt[0].ny = 501;\n\n    XForcing.targetadapt[0].dx = 0.1;\n\n    AllocateCPU(XForcing.targetadapt[0].nx, XForcing.targetadapt[0].ny, XForcing.targetadapt[0].val);\n\n    for (int j = 0; j &lt; XForcing.targetadapt[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.targetadapt[0].nx; i++)\n        {\n            x = float(XForcing.targetadapt[0].xo + i * XForcing.targetadapt[0].dx);\n            y = float(XForcing.targetadapt[0].yo + j * XForcing.targetadapt[0].dx);\n            if (x &lt; 0.0)\n            {\n                XForcing.targetadapt[0].val[i + j * XForcing.targetadapt[0].nx] = -1;\n            }\n            else\n            {\n                if (y &lt; 0.0)\n                {\n                    XForcing.targetadapt[0].val[i + j * XForcing.targetadapt[0].nx] = 0;\n                }\n                else\n                {\n                    XForcing.targetadapt[0].val[i + j * XForcing.targetadapt[0].nx] = 1;\n                }\n            }\n        }\n    }\n\n    // Add wall boundary conditions\n    XForcing.right.type = 0;\n    XForcing.left.type = 0;\n    XForcing.top.type = 0;\n    XForcing.bot.type = 0;\n\n\n    //Create a temporary file with river fluxes\n    float Q = 1;\n    std::ofstream river_file(\n        \"testriver.tmp\", std::ios_base::out | std::ios_base::trunc);\n    river_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file &lt;&lt; \"3600.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file.close(); //destructor implicitly does it\n\n    River thisriver;\n    thisriver.Riverflowfile = \"testriver.tmp\";\n    thisriver.xstart = -0.2;\n    thisriver.xend = 0.2;\n    thisriver.ystart = -0.2;\n    thisriver.yend = 0.2;\n\n    XForcing.rivers.push_back(thisriver);\n\n\n    XForcing.rivers[0].flowinput = readFlowfile(XForcing.rivers[0].Riverflowfile, XParam.reftime);\n\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    MainLoop(XParam, XForcing, XModel, XModel_g);\n\n    //Test if file exist and can be open:\n    int error = 1;\n    std::vector&lt;int&gt; observedSize{ 473251462,23304761,130802886 };\n    for (int o = 0; o &lt; XModel.blocks.outZone.size(); o++)\n    {\n        std::ifstream fs(XModel.blocks.outZone[o].outname);\n        if (fs.fail())\n        {\n            error++;\n        }\n        else\n        {\n            //Calculate the size of the file in bytes\n            std::ifstream in_file(XModel.blocks.outZone[o].outname, std::ios::binary);\n            in_file.seekg(0, std::ios::end);\n            int file_size = in_file.tellg();\n            printf(\"sizes : %i in bytes\\n\", file_size);\n            error = error * (observedSize[o] / file_size);\n        }\n    }\n\n    bool modelgood = (1 - abs(error)) &lt; 0.05;\n\n    //log(\"#####\");\n    return modelgood;\n}\ntemplate bool ZoneOutputTest&lt;float&gt;(int nzones, float zsinit);\ntemplate bool ZoneOutputTest&lt;double&gt;(int nzones, double zsinit);\n\n\n\ntemplate &lt;class T&gt; bool Rainlossestest(T zsinit, int gpu, float alpha)\n{\n    int NX = 21;\n    int NY = 21;\n    double* xLoss;\n    double* yLoss;\n    double* ilForcing;\n    double* clForcing;\n\n    log(\"#####\");\n    Param XParam;\n    T initVol, TheoryInput;\n    TheoryInput = T(0.0);\n    // initialise domain and required resolution\n    XParam.dx = 1.0 / ((1 &lt;&lt; 6)); //1&lt;&lt;8  = 2^8\n    XParam.xo = -0.5;\n    XParam.yo = -0.5;\n    XParam.xmax = 0.5;\n    XParam.ymax = 0.5;\n\n    XParam.zsinit = zsinit;\n    //XParam.zsoffset = 0.0;\n\n    XParam.infiltration = true;\n\n    //Output times for comparisons\n    XParam.endtime = 1.0;\n    XParam.outputtimestep = 0.1;\n\n    XParam.smallnc = 0;\n\n    XParam.cf = 0.01;\n    XParam.frictionmodel = 0;\n\n    // Enforce GPU/CPU\n    XParam.GPUDEVICE = gpu;\n    XParam.rainbnd = true;\n    //output vars\n    std::string outvi[17] = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"Su\", \"Sv\", \"hgw\" };\n    std::vector&lt;std::string&gt; outv;\n    for (int nv = 0; nv &lt; 17; nv++)\n    {\n        outv.push_back(outvi[nv]);\n    }\n    XParam.outvars = outv;\n\n    // create Model setup\n    Model&lt;T&gt; XModel;\n    Model&lt;T&gt; XModel_g;\n\n    Forcing&lt;float&gt; XForcing;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    XForcing.Bathy.push_back(bathy);\n\n    // initialise forcing bathymetry to 0\n    XForcing.Bathy[0].xo = -1.0;\n    XForcing.Bathy[0].yo = -1.0;\n    XForcing.Bathy[0].xmax = 1.0;\n    XForcing.Bathy[0].ymax = 1.0;\n    XForcing.Bathy[0].nx = 3;\n    XForcing.Bathy[0].ny = 3;\n\n    XForcing.Bathy[0].dx = 1.0;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = T(0.0);\n        }\n    }\n\n\n    // Add wall boundary conditions\n    XForcing.right.type = 0;\n    XForcing.left.type = 0;\n    XForcing.top.type = 0;\n    XForcing.bot.type = 0;\n\n    //Value definition for surface rain fall\n    T Q = 300; // mm/hr\n    std::cout &lt;&lt; \"# Theoretical volume of water input during the simulation in m3: \" &lt;&lt; TheoryInput &lt;&lt; \", from a rain input of: \" &lt;&lt; Q &lt;&lt; \"mm/hr.\" &lt;&lt; std::endl;\n    //Create a temporary file with rain fluxes\n    std::ofstream rain_file(\n        \"testrain.tmp\", std::ios_base::out | std::ios_base::trunc);\n    rain_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    rain_file &lt;&lt; \"3600.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    rain_file.close(); //destructor implicitly does it\n\n    XForcing.Rain.inputfile = \"testrain.tmp\";\n    XForcing.Rain.uniform = true;\n\n    // Reading rain forcing from file for CPU and unifor rain\n    XForcing.Rain.unidata = readINfileUNI(XForcing.Rain.inputfile, XParam.reftime);\n\n    //Value definition for surface IL-CL\n    T IL = 0.02; // mm\n    T CL = 100; // mm/hr\n\n    //Create a uniform map of IL-CL forcing (nc file)\n    xLoss = (double*)malloc(sizeof(double) * NX);\n    yLoss = (double*)malloc(sizeof(double) * NY);\n    for (int i = 0; i &lt; NX; i++) { xLoss[i] = -1.0 + 0.1 * i; }\n    for (int j = 0; j &lt; NY; j++) { yLoss[j] = -1.0 + 0.1 * j; }\n\n    ilForcing = (double*)malloc(sizeof(double) * NY * NX);\n    clForcing = (double*)malloc(sizeof(double) * NY * NX);\n\n    //Create the Losses forcing:\n    for (int j = 0; j &lt; NY; j++)\n    {\n        for (int i = 0; i &lt; NX; i++)\n        {\n            if (xLoss[i] &lt; 0)\n            {\n                ilForcing[j * NX + i] = 0;\n                clForcing[j * NX + i] = 0;\n            }\n            else\n            {\n                ilForcing[j * NX + i] = IL;\n                clForcing[j * NX + i] = CL;\n            }\n        }\n    }\n    create2dnc(\"ilrainlossTempt.nc\", NX, NY, xLoss, yLoss, ilForcing, \"initialloss\");\n    create2dnc(\"clrainlossTempt.nc\", NX, NY, xLoss, yLoss, clForcing, \"continuousloss\");\n\n    //Reading non-unform forcing\n    bool gpgpu = 0;\n    if (XParam.GPUDEVICE != -1)\n    {\n        gpgpu = 1;\n    }\n\n    XForcing.il = readfileinfo(\"ilrainlossTempt.nc\", XForcing.il);\n    XForcing.il.varname = \"initialloss\";\n    XForcing.cl = readfileinfo(\"clrainlossTempt.nc\", XForcing.cl);\n    XForcing.cl.varname = \"continuousloss\";\n    readstaticforcing(XForcing.il);\n    readstaticforcing(XForcing.cl);\n\n    free(ilForcing);\n    free(clForcing);\n    free(xLoss);\n    free(yLoss);\n\n    //XParam.infiltration = false;\n\n    checkparamsanity(XParam, XForcing);\n    //printf(\"h: %f \\n\", XModel.evolv.h[10]);\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n\n    InitialAdaptation(XParam, XForcing, XModel);\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    initVol = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.dx, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                initVol = initVol + XModel.evolv.h[i] * delta * delta;\n            }\n        }\n    }\n\n\n    MainLoop(XParam, XForcing, XModel, XModel_g);\n\n    TheoryInput = Q / T(1000.0) / T(3600.0) * XParam.endtime;\n\n\n    T SimulatedVolume = T(0.0);\n    T Infiltration_model = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.dx, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                SimulatedVolume = SimulatedVolume + XModel.evolv.h[i] * delta * delta;\n                Infiltration_model = Infiltration_model + XModel.hgw[i] * delta * delta;\n            }\n        }\n    }\n\n\n    SimulatedVolume = SimulatedVolume - initVol;\n\n    T error = abs(SimulatedVolume - TheoryInput + Infiltration_model);\n\n    T modelgood = error / abs(TheoryInput) &lt; 0.05;\n\n    //printf(\"Simulatedvolume: %f , Theory input: %f , Calcultated loss: %f\\n\", SimulatedVolume, TheoryInput, Infiltration_model);\n\n    //log(\"#####\");\n    return modelgood;\n}\n\n\ntemplate &lt;class T&gt; int TestGradientSpeed(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    //\n    int fastest = 1;\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    dim3 gridDim(XParam.nblk, 1, 1);\n\n    // for flux reconstruction the loop overlap the right(or top for the y direction) halo\n    dim3 blockDimX2(XParam.blkwidth + XParam.halowidth * 2, XParam.blkwidth + XParam.halowidth * 2, 1);\n\n\n\n    // Allocate CUDA events that we'll use for timing\n    cudaEvent_t startA, startB, startC, startG, startGnew;\n    cudaEvent_t stopA, stopB, stopC, stopG, stopGnew;\n\n    fillHalo(XParam, XModel.blocks, XModel.evolv, XModel.zb);\n\n    std::thread t0(&amp;gradientC&lt;T&gt;, XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    t0.join();\n\n\n    Loop&lt;T&gt; XLoop;\n    // GPU stuff\n\n\n    XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    XLoop.totaltime = 0.0;\n\n    XLoop.nextoutputtime = 3600.0;\n\n\n    cudaEventCreate(&amp;startA);\n\n\n    cudaEventCreate(&amp;stopA);\n\n    // Record the start event\n    cudaEventRecord(startA, NULL);\n    gradient &lt;&lt;&lt; gridDim, blockDim, 0 &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XModel_g.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel_g.zb, XModel_g.grad.dzbdx, XModel_g.grad.dzbdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Record the stop event\n    cudaEventRecord(stopA, NULL);\n\n    // Wait for the stop event to complete\n    cudaEventSynchronize(stopA);\n\n    float msecTotalGrad = 0.0f;\n    cudaEventElapsedTime(&amp;msecTotalGrad, startA, stopA);\n\n    cudaEventDestroy(startA);\n    cudaEventDestroy(stopA);\n\n\n    cudaEventCreate(&amp;startB);\n\n\n    cudaEventCreate(&amp;stopB);\n\n    // Record the start event\n    cudaEventRecord(startB, NULL);\n    gradientSM &lt;&lt;&lt; gridDim, blockDim &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XModel_g.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel_g.zb, XModel_g.grad.dzsdx, XModel_g.grad.dzsdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Record the stop event\n    cudaEventRecord(stopB, NULL);\n\n    // Wait for the stop event to complete\n    cudaEventSynchronize(stopB);\n\n    float msecTotalSM = 0.0f;\n    cudaEventElapsedTime(&amp;msecTotalSM, startB, stopB);\n\n    cudaEventDestroy(startB);\n    cudaEventDestroy(stopB);\n\n\n    cudaEventCreate(&amp;startC);\n\n\n    cudaEventCreate(&amp;stopC);\n\n    // Record the start event\n    cudaEventRecord(startC, NULL);\n    gradientSMC &lt;&lt;&lt; gridDim, blockDim &gt;&gt;&gt; (XParam.halowidth, XModel_g.blocks.active, XModel_g.blocks.level, (T)XParam.theta, (T)XParam.delta, XModel_g.zb, XModel_g.grad.dhdx, XModel_g.grad.dhdy);\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    // Record the stop event\n    cudaEventRecord(stopC, NULL);\n\n    // Wait for the stop event to complete\n    cudaEventSynchronize(stopC);\n\n    float msecTotalSMB = 0.0f;\n    cudaEventElapsedTime(&amp;msecTotalSMB, startC, stopC);\n\n    cudaEventDestroy(startC);\n    cudaEventDestroy(stopC);\n\n\n\n\n    CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dudx, XModel_g.grad.dzbdx);\n    CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dudy, XModel_g.grad.dzbdy);\n\n    CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dzsdx, XModel_g.grad.dzsdx);\n    CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dzsdy, XModel_g.grad.dzsdy);\n\n    CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dhdx, XModel_g.grad.dhdx);\n    CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dhdy, XModel_g.grad.dhdy);\n\n    printf(\"Runtime : normal=%f, shared mem=%f, SharedmemB=%f in msec\\n\", msecTotalGrad, msecTotalSM, msecTotalSMB);\n\n    /*\n    creatncfileBUQ(XParam, XModel.blocks);\n\n    std::vector&lt;std::string&gt; varlist = { \"zb\", \"dzbdx\", \"dzbdy\" };\n\n    for (int ivar = 0; ivar &lt; varlist.size(); ivar++)\n    {\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, varlist[ivar], 3, XModel.OutputVarMap[varlist[ivar]], XModel.blocks.outZone[0]);\n    }\n\n    diffArray(XParam, XLoop, XModel.blocks, \"SMdx\", false, XModel.grad.dzbdx, XModel_g.grad.dzsdx, XModel.time.arrmax, XModel.grad.dzsdx);\n\n\n    diffArray(XParam, XLoop, XModel.blocks, \"SMBdx\", false, XModel.grad.dzbdx, XModel_g.grad.dhdx, XModel.time.arrmax, XModel.grad.dhdx);\n\n    diffArray(XParam, XLoop, XModel.blocks, \"SMBdy\", false, XModel.grad.dzbdy, XModel_g.grad.dhdy, XModel.time.arrmax, XModel.grad.dhdy);\n    diffArray(XParam, XLoop, XModel.blocks, \"SMdy\", false, XModel.grad.dzbdy, XModel_g.grad.dzsdy, XModel.time.arrmax, XModel.grad.dzsdy);\n    */\n    T maxdiffx, maxdiffy;\n    maxdiffx = T(0.0);\n    maxdiffy = T(0.0);\n    T maxdiffsmx, maxdiffsmy;\n    maxdiffsmx = T(0.0);\n    maxdiffsmy = T(0.0);\n    T maxdiffsmbx, maxdiffsmby;\n    maxdiffsmbx = T(0.0);\n    maxdiffsmby = T(0.0);\n    T diffsm, diffsmb;\n\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                diffsm = abs(XModel.grad.dzbdx[i] - XModel.grad.dudx[i]);\n\n                maxdiffx = max(maxdiffx, diffsm);\n\n                diffsm = abs(XModel.grad.dzbdy[i] - XModel.grad.dudy[i]);\n\n                maxdiffx = max(maxdiffx, diffsm);\n\n                diffsm = abs(XModel.grad.dzbdx[i] - XModel.grad.dzsdx[i]);\n\n                maxdiffsmx = max(maxdiffsmx, diffsm);\n\n                diffsm = abs(XModel.grad.dzbdy[i] - XModel.grad.dzsdy[i]);\n\n                maxdiffsmy = max(maxdiffsmy, diffsm);\n\n                diffsm = abs(XModel.grad.dzbdx[i] - XModel.grad.dhdx[i]);\n                maxdiffsmbx = max(maxdiffsmbx, diffsm);\n\n                diffsm = abs(XModel.grad.dzbdy[i] - XModel.grad.dhdy[i]);\n                maxdiffsmby = max(maxdiffsmby, diffsm);\n                //\n            }\n        }\n    }\n\n\n    printf(\"max error : normx=%e, normy=%e, smx=%e, smy=%e,  smbx=%e, smby=%e in m\\n\", maxdiffx, maxdiffy, maxdiffsmx, maxdiffsmy, maxdiffsmbx, maxdiffsmby);\n\n\n    gradientCPU(XParam, XModel.blocks, XModel.evolv, XModel.grad, XModel.zb);\n\n\n    cudaEventCreate(&amp;startG);\n\n\n    cudaEventCreate(&amp;stopG);\n\n    cudaEventRecord(startG, NULL);\n    gradientGPU(XParam, XModel_g.blocks, XModel_g.evolv, XModel_g.grad, XModel_g.zb);\n    cudaEventRecord(stopG, NULL);\n\n    // Wait for the stop event to complete\n    cudaEventSynchronize(stopG);\n\n    float msecTotalG = 0.0f;\n    cudaEventElapsedTime(&amp;msecTotalG, startG, stopG);\n\n    cudaEventDestroy(startG);\n    cudaEventDestroy(stopG);\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, { \"dhdx\",\"dhdy\", \"dzsdx\",\"dzsdy\",\"dudx\",\"dudy\",\"dvdx\",\"dvdy\" }, true);\n\n    //CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dzbdx, XModel_g.grad.dzbdx);\n    //CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dzbdy, XModel_g.grad.dzbdy);\n\n    //CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dzsdx, XModel_g.grad.dzsdx);\n    //CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dzsdy, XModel_g.grad.dzsdy);\n\n    //CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dhdx, XModel_g.grad.dhdx);\n    //CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.grad.dhdy, XModel_g.grad.dhdy);\n\n    cudaEventCreate(&amp;startGnew);\n\n\n    cudaEventCreate(&amp;stopGnew);\n\n    cudaEventRecord(startGnew, NULL);\n    gradientGPUnew(XParam, XModel_g.blocks, XModel_g.evolv, XModel_g.grad, XModel_g.zb);\n    cudaEventRecord(stopGnew, NULL);\n\n    // Wait for the stop event to complete\n    cudaEventSynchronize(stopGnew);\n\n    float msecTotalGnew = 0.0f;\n    cudaEventElapsedTime(&amp;msecTotalGnew, startGnew, stopGnew);\n\n    cudaEventDestroy(startGnew);\n    cudaEventDestroy(stopGnew);\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, { \"dhdx\",\"dhdy\", \"dzsdx\",\"dzsdy\",\"dudx\",\"dudy\",\"dvdx\",\"dvdy\" }, true);\n\n    printf(\"Runtime : old gradient=%f, new Gradient=%f in msec\\n\", msecTotalG, msecTotalGnew);\n\n    return fastest;\n\n}\n\ntemplate &lt;class T&gt; bool TestHaloSpeed(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    Forcing&lt;float&gt; XForcing;\n\n    XForcing = MakValleyBathy(XParam, T(0.4), true, true);\n\n    float maxtopo = std::numeric_limits&lt;float&gt;::min();\n    float mintopo = std::numeric_limits&lt;float&gt;::max();\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            maxtopo = max(XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx], maxtopo);\n            mintopo = min(XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx], mintopo);\n        }\n    }\n\n    // Overrule whatever may be set in the param file\n    XParam.xmax = XForcing.Bathy[0].xmax;\n    XParam.ymax = XForcing.Bathy[0].ymax;\n    XParam.xo = XForcing.Bathy[0].xo;\n    XParam.yo = XForcing.Bathy[0].yo;\n\n    XParam.dx = XForcing.Bathy[0].dx;\n\n    XParam.zsinit = mintopo + 0.5;// Had a small amount of water to avoid a huge first step that would surely break the setup\n    XParam.endtime = 20.0;\n\n    XParam.outputtimestep = XParam.endtime;\n\n    XParam.minlevel = 0;\n    XParam.maxlevel = 1;\n    XParam.initlevel = 0;\n\n    //coarse to fine\n    // Change arg 1 and 2 if the slope is changed\n    XParam.AdaptCrit = \"Inrange\";\n    XParam.Adapt_arg1 = \"0.0\";\n    XParam.Adapt_arg2 = \"2.0\";\n    XParam.Adapt_arg3 = \"zb\";\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n\n\n\n    // Copy zs from CPU to GPU ... again\n    CopytoGPU(XParam.nblkmem, XParam.blksize, XModel.evolv.zs, XModel_g.evolv_o.zs);\n    CopytoGPU(XParam.nblkmem, XParam.blksize, XModel.evolv.zs, XModel_g.evolv.zs);\n\n    cudaStream_t streams[2];\n    CUDA_CHECK(cudaStreamCreate(&amp;streams[0]));\n    CUDA_CHECK(cudaStreamCreate(&amp;streams[1]));\n\n\n    fillHaloC(XParam, XModel.blocks, XModel.evolv.zs);\n    fillHaloGPU(XParam, XModel_g.blocks, streams[0], XModel_g.evolv.zs);\n    fillHaloGPUnew(XParam, XModel_g.blocks, streams[1], XModel_g.evolv_o.zs);\n\n    CUDA_CHECK(cudaDeviceSynchronize());\n\n    cudaStreamDestroy(streams[0]);\n    cudaStreamDestroy(streams[1]);\n\n\n    //CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.evolv.u, XModel_g.evolv.zs);\n    //CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, XModel.evolv.v, XModel_g.evolvo.zs);\n\n    diffArray(XParam, XModel.blocks, \"GPU_old\", true, XModel.evolv.zs, XModel_g.evolv.zs, XModel.evolv.u, XModel.evolv_o.u);\n    diffArray(XParam, XModel.blocks, \"GPU_new\", true, XModel.evolv.zs, XModel_g.evolv_o.zs, XModel.evolv.v, XModel.evolv_o.v);\n\n    return true;\n}\n\ntemplate &lt;class T&gt; int TestInstability(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    Forcing&lt;float&gt; XForcing;\n\n    XForcing = MakValleyBathy(XParam, T(0.4), true, true);\n\n    XParam.conserveElevation = true;\n\n    float maxtopo = std::numeric_limits&lt;float&gt;::min();\n    float mintopo = std::numeric_limits&lt;float&gt;::max();\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            maxtopo = max(XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx], maxtopo);\n            mintopo = min(XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx], mintopo);\n        }\n    }\n\n    // Overrule whatever may be set in the param file\n    XParam.xmax = XForcing.Bathy[0].xmax;\n    XParam.ymax = XForcing.Bathy[0].ymax;\n    XParam.xo = XForcing.Bathy[0].xo;\n    XParam.yo = XForcing.Bathy[0].yo;\n\n    XParam.dx = XForcing.Bathy[0].dx;\n\n    XParam.zsinit = mintopo + 6.9;// Had a water level so that the wet and dry affects the \n    XParam.endtime = 20.0;\n\n    XParam.outputtimestep = XParam.endtime;\n\n    XParam.minlevel = 0;\n    XParam.maxlevel = 2;\n    XParam.initlevel = 0;\n\n    // coarse to fine\n    // Change arg 1 and 2 if the slope is changed\n    XParam.AdaptCrit = \"Targetlevel\";\n    XParam.Adapt_arg1 = \"\";\n    XParam.Adapt_arg2 = \"\";\n    XParam.Adapt_arg3 = \"\";\n\n    StaticForcingP&lt;int&gt; targetlevel;\n    XForcing.targetadapt.push_back(targetlevel);\n\n    XForcing.targetadapt[0].xo = 0.0;\n    XForcing.targetadapt[0].yo = 0.0;\n\n    XForcing.targetadapt[0].xmax = 31.0;\n    XForcing.targetadapt[0].ymax = 31.0;\n    XForcing.targetadapt[0].nx = 32;\n    XForcing.targetadapt[0].ny = 32;\n\n    XForcing.targetadapt[0].dx = 1.0;\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.targetadapt[0].val);\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            XForcing.targetadapt[0].val[i + j * XForcing.Bathy[0].nx] = 1;\n        }\n    }\n\n    XForcing.targetadapt[0].val[12 + 12 * XForcing.Bathy[0].nx] = 2;\n\n\n    // Setup Model(s)\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    // Run first full step (i.e. 2 half steps)\n\n    Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n\n    //FlowCPU(XParam, XLoop, XForcing, XModel);\n    HalfStepCPU(XParam, XLoop, XForcing, XModel);\n\n    T maxu = std::numeric_limits&lt;float&gt;::min();\n    T maxv = std::numeric_limits&lt;float&gt;::min();\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                maxu = max(maxu, abs(XModel.evolv.u[i]));\n                maxv = max(maxv, abs(XModel.evolv.v[i]));\n            }\n        }\n    }\n\n    bool test = false;\n\n    if (maxu &gt; T(std::numeric_limits&lt;T&gt;::epsilon() * T(1000.0)) || maxv &gt; T(std::numeric_limits&lt;T&gt;::epsilon() * T(1000.0)))\n    {\n        //test = true;\n        XParam.outvars = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"Su\", \"Sv\",\"dhdx\", \"dhdy\", \"dzsdx\", \"dzsdy\" };\n        InitSave2Netcdf(XParam, XModel);\n\n    }\n    else\n    {\n        test = true;\n    }\n\n\n    return test;\n\n}\n\n\n\n\n\n//TestMultiBathyRough(int gpu, T ref, int scenario)\ntemplate &lt;class T&gt; bool TestMultiBathyRough(int gpu, T ref, int scenario)\n{\n    T Z0 = ref + 0.0;\n    T Z1 = ref + 2.0;\n    T R0 = 0.000001;\n    T R1 = 0.1;\n    T IL = 8.6;\n    T CL = 7.2;\n    T eps;\n    int NX = 21;\n    int NY = 21;\n    double* xz;\n    double* yz;\n    double* map;\n    Param XParam;\n    Forcing&lt;float&gt; XForcing;\n    Model&lt;float&gt; XModel;\n    Model&lt;float&gt; XModel_g;\n    char* name_file_R1;\n\n\n    //Creation of a Bathy file\n\n    xz = (double*)malloc(sizeof(double) * NX);\n    yz = (double*)malloc(sizeof(double) * NY);\n    for (int i = 0; i &lt; NX; i++) { xz[i] = -1.0 + 0.1 * i; }\n    for (int j = 0; j &lt; NY; j++) { yz[j] = -1.0 + 0.1 * j; }\n\n    map = (double*)malloc(sizeof(double) * NY * NX);\n\n    for (int j = 0; j &lt; NY; j++)\n    {\n        for (int i = 0; i &lt; NX; i++)\n        {\n            map[j * NX + i] = Z0; //+ (yz[j] + 1) * 0.5;\n        }\n    }\n    create2dnc(\"Z0_map.nc\", NX, NY, xz, yz, map, \"z\");\n\n    //Creation of a smaller Bathy file\n\n    //xz = (double*)malloc(sizeof(double) * NX);\n    //yz = (double*)malloc(sizeof(double) * NY);\n    for (int i = 0; i &lt; NX; i++) { xz[i] = 0.0 + 0.05 * i; }\n    for (int j = 0; j &lt; NY; j++) { yz[j] = -1.0 + 0.05 * j; }\n\n    //map = (double*)malloc(sizeof(double) * NY * NX);\n\n    //Create the Losses forcing:\n    for (int j = 0; j &lt; NY; j++)\n    {\n        for (int i = 0; i &lt; NX; i++)\n        {\n            map[j * NX + i] = Z1; // -(yz[j] + 1) * 0.5;\n        }\n    }\n    create2dnc(\"Z1_map.nc\", NX, NY, xz, yz, map, \"z\");\n\n    //Creation of a roughness file\n    //xz = (double*)malloc(sizeof(double) * NX);\n    //yz = (double*)malloc(sizeof(double) * NY);\n    for (int i = 0; i &lt; NX; i++) { xz[i] = -1.0 + 0.1 * i; }\n    for (int j = 0; j &lt; NY; j++) { yz[j] = -1.0 + 0.1 * j; }\n\n    //map = (double*)malloc(sizeof(double) * NY * NX);\n\n    for (int j = 0; j &lt; NY; j++)\n    {\n        for (int i = 0; i &lt; NX; i++)\n        {\n            map[j * NX + i] = R0;\n        }\n    }\n    create2dnc(\"R0_map.nc\", NX, NY, xz, yz, map, \"z0\");\n\n    //Creation of a smaller Roughness file\n    //xz = (double*)malloc(sizeof(double) * NX);\n    //yz = (double*)malloc(sizeof(double) * NY);\n    for (int i = 0; i &lt; NX; i++) { xz[i] = 0.0 + 0.05 * i; }\n    for (int j = 0; j &lt; NY; j++) { yz[j] = 0.0 + 0.05 * j; }\n\n    //map = (double*)malloc(sizeof(double) * NY * NX);\n\n    //Create the Losses forcing:\n    for (int j = 0; j &lt; NY; j++)\n    {\n        for (int i = 0; i &lt; NX; i++)\n        {\n            map[j * NX + i] = R1;\n        }\n    }\n    if (scenario &lt; 0.5)\n    {\n        name_file_R1 = \"R1_map.nc\";\n    }\n    else\n    {\n        name_file_R1 = \"1R_map.nc\";\n    }\n    create2dnc(name_file_R1, NX, NY, xz, yz, map, \"z0\");\n\n    //Creation of a refinement file\n    //xz = (double*)malloc(sizeof(double) * NX);\n    //yz = (double*)malloc(sizeof(double) * NY);\n    for (int i = 0; i &lt; NX; i++) { xz[i] = -1.0 + 0.1 * i; }\n    for (int j = 0; j &lt; NY; j++) { yz[j] = -1.0 + 0.1 * j; }\n\n    //map = (double*)malloc(sizeof(double) * NY * NX);\n\n    for (int j = 0; j &lt; NY; j++)\n    {\n        for (int i = 0; i &lt; NX; i++)\n        {\n            map[j * NX + i] = 0;\n            if ((abs(xz[i]) &lt; 0.5) &amp;&amp; (abs(yz[j]) &lt; 0.5))\n            {\n                map[j * NX + i] = 1;\n            }\n        }\n    }\n    create2dnc(\"refinement.nc\", NX, NY, xz, yz, map, \"z\");\n\n    /*// Creation of a rain fall file\n    std::ofstream rain_file(\n        \"rainTest13.txt\", std::ios_base::out | std::ios_base::trunc);\n    rain_file &lt;&lt; \"0.000000\\t10.00\" &lt;&lt; std::endl;\n    rain_file &lt;&lt; \"1000.000\\t10.00\" &lt;&lt; std::endl;\n    rain_file.close();*/\n\n    // Creation of BG_param_test13.txt file\n    std::ofstream param_file(\n        \"BG_param_test13.txt\", std::ios_base::out | std::ios_base::trunc);\n    //Add Bathymetries to the file\n    param_file &lt;&lt; \"bathy = Z0_map.nc?z ;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"bathy = Z1_map.nc?z ;\" &lt;&lt; std::endl;\n    //Add Roughness to the file\n    if (scenario &gt; 1.5)\n    {\n        R1 = 3.56;\n        param_file &lt;&lt; \"cfmap = \" &lt;&lt; R1 &lt;&lt; std::endl;\n        R0 = 3.56;\n    }\n    else\n    {\n        param_file &lt;&lt; \"cfmap = R0_map.nc?z0 ;\" &lt;&lt; std::endl;\n        param_file &lt;&lt; \"cfmap = \" &lt;&lt; name_file_R1 &lt;&lt; \"?z0 ;\" &lt;&lt; std::endl;\n    }\n    //param_file &lt;&lt; \"cfmap = R1_map.nc?z0 ;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"frictionmodel=1 ;\" &lt;&lt; std::endl;\n    //Add refinement to the file\n    param_file &lt;&lt; \"Adaptation = Targetlevel,refinement.nc?z ;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"initlevel = 0; \" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"maxlevel = 1; \" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"minlevel = 0; \" &lt;&lt; std::endl;\n    //Add River forcing\n    //param_file &lt;&lt; \"rainfile = rainTest13.txt ;\" &lt;&lt; std::endl;\n    //Add endtime and outputvar\n    param_file &lt;&lt; \"endtime = 10.0 ;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"outvars = zs,h,u,v,zb,cf;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"dx = 0.01;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"zsinit = 0.1;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"smallnc = 0;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"doubleprecision = 1;\" &lt;&lt; std::endl;\n    if (scenario &gt; 2.5)\n    {\n        param_file &lt;&lt; \"il = \" &lt;&lt; IL &lt;&lt; std::endl;\n        param_file &lt;&lt; \"cl = \" &lt;&lt; CL &lt;&lt; std::endl;\n    }\n\n    param_file.close();\n\n    //read param file\n    Readparamfile(XParam, XForcing, \"BG_param_test13.txt\"); // \"BG_param_test13.txt\");\n\n    //readforcing\n    readforcing(XParam, XForcing);\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    // Run first full step (i.e. 2 half steps)\n\n    //Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n    MainLoop(XParam, XForcing, XModel, XModel_g);\n\n    //if XModel.cf[0]\n    //  XModel.zb\n\n    T maxz = T(-1.0) * std::numeric_limits&lt;float&gt;::max();\n    T minz = std::numeric_limits&lt;float&gt;::max();\n    T maxr = T(-1.0) * std::numeric_limits&lt;float&gt;::max();\n    T minr = std::numeric_limits&lt;float&gt;::max();\n\n\n    printf(\"min float=%f\\n\", std::numeric_limits&lt;float&gt;::min());\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                maxz = max(maxz, abs(XModel.zb[i]));\n                minz = min(minz, abs(XModel.zb[i]));\n                maxr = max(maxr, abs(XModel.cf[i]));\n                minr = min(minr, abs(XModel.cf[i]));\n            }\n        }\n    }\n\n    bool result = false;\n    eps = 0.0000001;\n\n    if ((abs(maxz - Z1) &lt; eps) &amp;&amp; (abs(maxr - R1) &lt; eps) &amp;&amp; (abs(minz - Z0) &lt; eps) &amp;&amp; (abs(minr - R0) &lt; eps))\n    {\n        result = true;\n    }\n    printf(\"\\t\\n\");\n    printf(\"\\t\\tZ max forced : %f, Z max obs :  %f\\n \", Z1, maxz);\n    printf(\"\\t\\tR max forced :  %f, R max obs:  %f\\n\", R1, maxr);\n    printf(\"\\t\\tZ min forced :  %f, Z min obs:  %f\\n\", Z0, minz);\n    printf(\"\\t\\tR min forced : %f, R min obs : %f\\n \", R0, minr);\n\n    if (scenario &gt; 2.5)\n    {\n        T maxil = T(-1.0) * std::numeric_limits&lt;float&gt;::max();\n        T minil = std::numeric_limits&lt;float&gt;::max();\n        T maxcl = T(-1.0) * std::numeric_limits&lt;float&gt;::max();\n        T mincl = std::numeric_limits&lt;float&gt;::max();\n\n\n        //printf(\"min float=%f\\n\", std::numeric_limits&lt;float&gt;::min());\n\n        for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n        {\n            int ib = XModel.blocks.active[ibl];\n            for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n            {\n                for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n                {\n                    int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                    maxil = max(maxil, abs(XModel.il[i]));\n                    minil = min(minil, abs(XModel.il[i]));\n                    maxcl = max(maxcl, abs(XModel.cl[i]));\n                    mincl = min(mincl, abs(XModel.cl[i]));\n                }\n            }\n        }\n\n        bool result = false;\n        eps = 0.0000001;\n        // IL is expected here to be value when dry and 0 where wet at the begining of the computation\n        if ((abs(maxil - IL) &lt; eps) &amp;&amp; (abs(maxcl - CL) &lt; eps) &amp;&amp; (abs(minil - T(0.0)) &lt; eps) &amp;&amp; (abs(mincl - CL) &lt; eps))\n        {\n            result = true;\n        }\n    }\n\n    return result;\n}\n\n\n\n//TestFlexibleOutputTimes(int gpu, T ref, int scenario)\ntemplate &lt;class T&gt; bool TestFlexibleOutputTimes(int gpu, T ref, int scenario)\n{\n    T Z0 = ref + 0.0;\n    T Z1 = ref + 2.0;\n    T eps;\n    int NX = 21;\n    int NY = 21;\n    double* xz;\n    double* yz;\n    double* map;\n    Param XParam;\n    Forcing&lt;float&gt; XForcing;\n    Model&lt;float&gt; XModel;\n    Model&lt;float&gt; XModel_g;\n    char* name_file_R1;\n\n\n    //Creation of a Bathy file\n\n    xz = (double*)malloc(sizeof(double) * NX);\n    yz = (double*)malloc(sizeof(double) * NY);\n    for (int i = 0; i &lt; NX; i++) { xz[i] = -1.0 + 0.1 * i; }\n    for (int j = 0; j &lt; NY; j++) { yz[j] = -1.0 + 0.1 * j; }\n\n    map = (double*)malloc(sizeof(double) * NY * NX);\n\n    for (int j = 0; j &lt; NY; j++)\n    {\n        for (int i = 0; i &lt; NX; i++)\n        {\n            map[j * NX + i] = Z0; //+ (yz[j] + 1) * 0.5;\n        }\n    }\n    create2dnc(\"Z0_map.nc\", NX, NY, xz, yz, map, \"z\");\n\n\n    // Creation of BG_param_test13.txt file\n    std::ofstream param_file(\n        \"BG_param_test15.txt\", std::ios_base::out | std::ios_base::trunc);\n    //Add Bathymetries to the file\n    param_file &lt;&lt; \"bathy = Z0_map.nc?z ;\" &lt;&lt; std::endl;\n\n    //Add endtime and outputvar\n    param_file &lt;&lt; \"endtime = 11.0 ;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"reftime = 2020-01-01T00:00:00 ;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"outvars = zs,h,u,v,zb;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"dx = 0.05;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"zsinit = 0.1;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"smallnc = 0;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"doubleprecision = 1;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"Toutput = 1|2|5, 2020-01-01T00:00:08,  9.5;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"outzone = Test15_zoom1.nc,0.2,0.6,-0.2,0.2, 2020-01-01T00:00:02|0.008min|2020-01-01T00:00:03, 5.6,6.9;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"outzone = Test15_zoom2.nc,0.2,0.6,-0.2,0.2, 8.1|0.7|, 5.6;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"outzone = Test15_zoom3.nc,0.2,0.6,-0.2,0.2, |0.8|2;\" &lt;&lt; std::endl;\n    param_file &lt;&lt; \"outzone = Test15_zoom4.nc,0.2,0.6,-0.2,0.2, 8.2||9;\" &lt;&lt; std::endl; // Here the step in not given so assumed infinite\n    param_file &lt;&lt; \"outzone = Test15_zoom5.nc,0.2,0.6,-0.2,0.2;\" &lt;&lt; std::endl;\n    param_file.close();\n\n    //read param file\n    Readparamfile(XParam, XForcing, \"BG_param_test15.txt\"); // \"BG_param_test13.txt\");\n\n    //readforcing\n    readforcing(XParam, XForcing);\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    // Run first full step (i.e. 2 half steps)\n\n    //Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n    //MainLoop(XParam, XForcing, XModel, XModel_g);\n\n    //TEST 1: reading and default values check:\n    bool result = false;\n\n    if (XModel.OutputT.size()==20)\n    {\n        result = true;\n    }\n\n    /*\n    if (!XParam.Toutput.end == 11.0)\n        result = false;\n    if (!XParam.Toutput.val[1] == 9.5)\n        result = false;\n\n    if (!XParam.outzone[2].Toutput.init == 0.0)\n        result = false;\n    if (!XParam.outzone[3].Toutput.tstep == 11.0)\n        result = false;\n    if (!XParam.outzone[4].Toutput.tstep == 1.0)\n        result = false;\n        */\n\n\n\n    return result;\n}\n\n\n\n\n\ntemplate &lt;class T&gt; void TestFirsthalfstep(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n\n    // Setup Model(s)\n\n    XParam.outvars = { \"zb\",\"h\",\"zs\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"Su\", \"Sv\",\"dhdx\", \"dhdy\", \"dzsdx\", \"dzsdy\", \"dzbdx\", \"dzbdy\" };\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    // Run first full step (i.e. 2 half steps)\n\n    Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n\n    if (XParam.GPUDEVICE &lt; 0)\n    {\n        //FlowCPU(XParam, XLoop, XForcing, XModel);\n        HalfStepCPU(XParam, XLoop, XForcing, XModel);\n    }\n    else\n    {\n        HalfStepGPU(XParam, XLoop, XForcing, XModel_g);\n\n        for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n        {\n            CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[XParam.outvars[ivar]], XModel_g.OutputVarMap[XParam.outvars[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n        }\n\n    }\n\n    T maxu = std::numeric_limits&lt;float&gt;::min();\n    T maxv = std::numeric_limits&lt;float&gt;::min();\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                maxu = max(maxu, abs(XModel.evolv.u[i]));\n                maxv = max(maxv, abs(XModel.evolv.v[i]));\n            }\n        }\n    }\n\n    bool test = false;\n\n    //test = true;\n\n    InitSave2Netcdf(XParam, XModel);\n\n}\n\ntemplate &lt;class T&gt; void Testzbinit(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n\n    // Setup Model(s)\n\n    XParam.outvars = { \"zb\",\"u\",\"v\",\"Fqux\",\"Fqvx\",\"Fquy\",\"Fqvy\", \"Fhu\", \"Fhv\", \"dh\", \"dhu\", \"dhv\", \"Su\", \"Sv\",\"dhdx\", \"dhdy\", \"dzsdx\", \"dzsdy\", \"dzbdx\", \"dzbdy\" };\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n\n    // Run first full step (i.e. 2 half steps)\n\n    Loop&lt;T&gt; XLoop = InitLoop(XParam, XModel);\n\n\n    //FlowCPU(XParam, XLoop, XForcing, XModel);\n    //HalfStepCPU(XParam, XLoop, XForcing, XModel);\n    if (XParam.conserveElevation)\n    {\n        refine_linear(XParam, XModel.blocks, XModel.zb, XModel.grad.dzbdx, XModel.grad.dzbdy);\n    }\n\n    //HalfStepGPU(XParam, XLoop, XForcing, XModel_g);\n\n    if (XParam.conserveElevation)\n    {\n        refine_linearGPU(XParam, XModel_g.blocks, XModel_g.zb, XModel_g.grad.dzbdx, XModel_g.grad.dzbdy);\n    }\n\n    //for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n    //{\n    //  CUDA_CHECK(cudaMemcpy(XModel.OutputVarMap[XParam.outvars[ivar]], XModel_g.OutputVarMap[XParam.outvars[ivar]], XParam.nblkmem * XParam.blksize * sizeof(T), cudaMemcpyDeviceToHost));\n    //}\n\n    CompareCPUvsGPU(XParam, XModel, XModel_g, XParam.outvars, true);\n\n    //T maxu = std::numeric_limits&lt;float&gt;::min();\n    //T maxv = std::numeric_limits&lt;float&gt;::min();\n    /*\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                maxu = max(maxu, abs(XModel.evolv.u[i]));\n                maxv = max(maxv, abs(XModel.evolv.v[i]));\n            }\n        }\n    }\n    */\n    bool test = false;\n\n    //test = true;\n\n    //InitSave2Netcdf(XParam, XModel);\n\n\n\n}\n\ntemplate &lt;class T&gt; int TestAIObnd(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g, bool bottop, bool flip, bool withaoi)\n{\n    Forcing&lt;float&gt; XForcing;\n\n    XForcing = MakValleyBathy(XParam, T(0.4), bottop, flip);\n\n    XParam.conserveElevation = true;\n\n    float maxtopo = std::numeric_limits&lt;float&gt;::min();\n    float mintopo = std::numeric_limits&lt;float&gt;::max();\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            maxtopo = max(XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx], maxtopo);\n            mintopo = min(XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx], mintopo);\n        }\n    }\n\n    // Overrule whatever may be set in the param file\n    XParam.xmax = XForcing.Bathy[0].xmax;\n    XParam.ymax = XForcing.Bathy[0].ymax;\n    XParam.xo = XForcing.Bathy[0].xo;\n    XParam.yo = XForcing.Bathy[0].yo;\n\n    XParam.dx = XForcing.Bathy[0].dx;\n\n    //XParam.zsinit = mintopo - 6.9;// Had a water level so that the wet and dry affects the \n    XParam.zsinit = mintopo - 9.9;// Had a water level so that the wet and dry affects the \n    XParam.endtime = 20.0;\n\n    XParam.dtmin = 0.00000001;\n    XParam.aoibnd = 0;\n\n    XParam.outputtimestep = XParam.endtime;\n\n    std::ofstream aoi_file(\n        \"testaoi.tmp\", std::ios_base::out | std::ios_base::trunc);\n    aoi_file &lt;&lt; \"5.0 3.0\" &lt;&lt; std::endl;\n    aoi_file &lt;&lt; \"27.0 3.0\" &lt;&lt; std::endl;\n    aoi_file &lt;&lt; \"27.0 27.0\" &lt;&lt; std::endl;\n    aoi_file &lt;&lt; \"5.0 27.0\" &lt;&lt; std::endl;\n    aoi_file &lt;&lt; \"5.0 3.0\" &lt;&lt; std::endl;\n    aoi_file.close(); //destructor implicitly does it\n\n    /*\n    std::ofstream aoi_file(\n        \"testaoi.tmp\", std::ios_base::out | std::ios_base::trunc);\n    aoi_file &lt;&lt; \"-5.0 -3.0\" &lt;&lt; std::endl;\n    aoi_file &lt;&lt; \"27.0 -3.0\" &lt;&lt; std::endl;\n    aoi_file &lt;&lt; \"27.0 270.0\" &lt;&lt; std::endl;\n    aoi_file &lt;&lt; \"-5.0 270.0\" &lt;&lt; std::endl;\n    aoi_file &lt;&lt; \"-5.0 -3.0\" &lt;&lt; std::endl;\n    aoi_file.close(); //destructor implicitly does it\n    */\n    if (withaoi)\n    {\n        XForcing.AOI.file = \"testaoi.tmp\";\n        XForcing.AOI.active = true;\n        XForcing.AOI.poly = readPolygon(XForcing.AOI.file);\n    }\n    /*\n    if (bottop==false &amp;&amp; flip==false)\n    {\n        XForcing.left.type = 0;\n    }\n    if (bottop == false &amp;&amp; flip == true)\n    {\n        XForcing.right.type = 0;\n    }\n    if (bottop == true &amp;&amp; flip == false)\n    {\n        XForcing.bot.type = 0;\n    }\n    if (bottop == true &amp;&amp; flip == true)\n    {\n        XForcing.top.type = 0;\n    }\n    */\n    XParam.minlevel = 3;\n    XParam.maxlevel = 3;\n    XParam.initlevel = 3;\n    /*\n    // coarse to fine\n    // Change arg 1 and 2 if the slope is changed\n    XParam.AdaptCrit = \"Targetlevel\";\n    XParam.Adapt_arg1 = \"\";\n    XParam.Adapt_arg2 = \"\";\n    XParam.Adapt_arg3 = \"\";\n\n    StaticForcingP&lt;int&gt; targetlevel;\n    XForcing.targetadapt.push_back(targetlevel);\n\n    XForcing.targetadapt[0].xo = 0.0;\n    XForcing.targetadapt[0].yo = 0.0;\n\n    XForcing.targetadapt[0].xmax = 31.0;\n    XForcing.targetadapt[0].ymax = 31.0;\n    XForcing.targetadapt[0].nx = 32;\n    XForcing.targetadapt[0].ny = 32;\n\n    XForcing.targetadapt[0].dx = 1.0;\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.targetadapt[0].val);\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            XForcing.targetadapt[0].val[i + j * XForcing.Bathy[0].nx] = 1;\n        }\n    }\n\n    XForcing.targetadapt[0].val[12 + 12 * XForcing.Bathy[0].nx] = 2;\n    */\n    // Add rain forcing\n    //Create a temporary file with river fluxes\n    float Q = 1;\n    std::ofstream river_file(\n        \"testriver.tmp\", std::ios_base::out | std::ios_base::trunc);\n    river_file &lt;&lt; \"0.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file &lt;&lt; \"3600.0 \" + std::to_string(Q) &lt;&lt; std::endl;\n    river_file.close(); //destructor implicitly does it\n\n    River thisriver;\n    thisriver.Riverflowfile = \"testriver.tmp\";\n    thisriver.xstart = 10;\n    thisriver.xend = 12;\n    thisriver.ystart = 10;\n    thisriver.yend = 12;\n\n    XForcing.rivers.push_back(thisriver);\n\n\n    XForcing.rivers[0].flowinput = readFlowfile(XForcing.rivers[0].Riverflowfile, XParam.reftime);\n\n\n    // Setup Model(s)\n\n    checkparamsanity(XParam, XForcing);\n\n    InitMesh(XParam, XForcing, XModel);\n\n    InitialConditions(XParam, XForcing, XModel);\n\n    InitialAdaptation(XParam, XForcing, XModel);\n\n    SetupGPU(XParam, XModel, XForcing, XModel_g);\n    T initVol = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.delta, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                initVol = initVol + XModel.evolv.h[i] * delta * delta;\n            }\n        }\n    }\n\n\n    MainLoop(XParam, XForcing, XModel, XModel_g);\n\n    T TheoryInput = Q * XParam.endtime;\n\n\n    T SimulatedVolume = T(0.0);\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XModel.blocks.active[ibl];\n        T delta = calcres(XParam.delta, XModel.blocks.level[ib]);\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; (XParam.blkwidth); ix++)\n            {\n                int i = memloc(XParam, ix, iy, ib);\n                SimulatedVolume = SimulatedVolume + XModel.evolv.h[i] * delta * delta;\n\n            }\n        }\n    }\n\n    SimulatedVolume = SimulatedVolume - initVol;\n\n    T error = abs(SimulatedVolume - TheoryInput);\n\n    int modelgood = error / TheoryInput &lt; 0.001;\n\n    printf(\"\\nSim Vol = %f, theory=%f, Error = %f, (%f %%) \\n\", SimulatedVolume, TheoryInput, error, (error / TheoryInput) * 100);\n\n    //log(\"#####\");\n    return modelgood;\n}\n\ntemplate &lt;class T&gt; __global__ void vectoroffsetGPU(int nx, T offset, T* z)\n{\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (idx &lt; nx)\n    {\n        z[idx] = z[idx] + offset;\n    }\n}\n\ntemplate &lt;class T&gt; int TestPinMem(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    T* zf, *zf_g, * zf_recov;\n\n\n    int nx = 32;\n    int ny = 1;\n\n    int nelem = nx * ny;\n\n\n    AllocateMappedMemCPU(nx, ny, XParam.GPUDEVICE, zf);\n\n\n    AllocateCPU(nx, ny, zf_recov);\n\n    for (int i = 0; i &lt; nx; i++)\n    {\n        for (int j = 0; j &lt; ny; j++)\n        {\n            zf[i + j * nx] = i + j * nx +T(0.25);\n\n        }\n    }\n\n    T checkrem = T(0.0);\n\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        AllocateMappedMemGPU(nx, ny, XParam.GPUDEVICE, zf_g, zf);\n\n\n\n        dim3 block(16);\n        dim3 grid((unsigned int)ceil(nelem / (float)block.x));\n\n        vectoroffsetGPU &lt;&lt;&lt;grid, block &gt;&gt;&gt; (nelem, T(1.0), zf_g);\n        CUDA_CHECK(cudaDeviceSynchronize());\n\n        CUDA_CHECK(cudaMemcpy(zf_recov, zf_g, nx * ny * sizeof(T), cudaMemcpyDeviceToHost));\n\n\n\n\n        for (int i = 0; i &lt; nx; i++)\n        {\n            for (int j = 0; j &lt; ny; j++)\n            {\n\n                checkrem = checkrem + abs(zf[i + j * nx] - zf_recov[i + j * nx]);\n            }\n        }\n    }\n    int modelgood = checkrem &lt; 1.e-6f;\n\n    if (checkrem &gt; 1.e-6f)\n    {\n        printf(\"\\n Test Failed error = %e \\n\", checkrem);\n        return modelgood;\n    }\n    else\n    {\n        printf(\"\\n Test Success error = %e \\n\", checkrem);\n    }\n\n\n\n    return modelgood;\n}\ntemplate int TestPinMem&lt;float&gt;(Param XParam, Model&lt;float&gt; XModel, Model&lt;float&gt; XModel_g);\ntemplate int TestPinMem&lt;double&gt;(Param XParam, Model&lt;double&gt; XModel, Model&lt;double&gt; XModel_g);\n\n\n\ntemplate &lt;class T&gt; Forcing&lt;float&gt; MakValleyBathy(Param XParam, T slope, bool bottop, bool flip)\n{\n    //\n\n    Forcing&lt;float&gt; XForcing;\n\n    StaticForcingP&lt;float&gt; bathy;\n\n    float* dummybathy;\n\n    XForcing.Bathy.push_back(bathy);\n\n    XForcing.Bathy[0].xo = 0.0;\n    XForcing.Bathy[0].yo = 0.0;\n\n    XForcing.Bathy[0].xmax = 31.0;\n    XForcing.Bathy[0].ymax = 31.0;\n    XForcing.Bathy[0].nx = 32;\n    XForcing.Bathy[0].ny = 32;\n\n    XForcing.Bathy[0].dx = 1.0;\n    XForcing.Bathy[0].dy = XForcing.Bathy[0].dx;\n\n    T x, y;\n    T center = T(10.5);\n\n    AllocateCPU(1, 1, XForcing.left.blks, XForcing.right.blks, XForcing.top.blks, XForcing.bot.blks);\n\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, XForcing.Bathy[0].val);\n    AllocateCPU(XForcing.Bathy[0].nx, XForcing.Bathy[0].ny, dummybathy);\n\n\n    float maxtopo = std::numeric_limits&lt;float&gt;::min();\n    float mintopo = std::numeric_limits&lt;float&gt;::max();\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            x = T(XForcing.Bathy[0].xo + i * XForcing.Bathy[0].dx);\n            y = T(XForcing.Bathy[0].yo + j * XForcing.Bathy[0].dx);\n\n\n            dummybathy[i + j * XForcing.Bathy[0].nx] = float(ValleyBathy(y, x, slope, center));\n\n            maxtopo = max(dummybathy[i + j * XForcing.Bathy[0].nx], maxtopo);\n\n\n        }\n    }\n\n    // Make surrounding wall\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n\n        dummybathy[0 + j * XForcing.Bathy[0].nx] = maxtopo + 5.0f;\n        dummybathy[1 + j * XForcing.Bathy[0].nx] = maxtopo + 5.0f;\n\n        dummybathy[j + 0 * XForcing.Bathy[0].nx] = maxtopo + 5.0f;\n        dummybathy[j + 1 * XForcing.Bathy[0].nx] = maxtopo + 5.0f;\n\n        dummybathy[(XForcing.Bathy[0].nx - 1) + j * XForcing.Bathy[0].nx] = maxtopo + 5.0f;\n        dummybathy[(XForcing.Bathy[0].nx - 2) + j * XForcing.Bathy[0].nx] = maxtopo + 5.0f;\n\n        dummybathy[j + (XForcing.Bathy[0].ny - 1) * XForcing.Bathy[0].nx] = maxtopo + 5.0f;\n        dummybathy[j + (XForcing.Bathy[0].ny - 2) * XForcing.Bathy[0].nx] = maxtopo + 5.0f;\n\n\n    }\n\n    // make a specially elevated spot \n\n    dummybathy[(XForcing.Bathy[0].nx - 1) + 0 * XForcing.Bathy[0].nx] = maxtopo + 10.0f;\n    dummybathy[(XForcing.Bathy[0].nx - 2) + 0 * XForcing.Bathy[0].nx] = maxtopo + 10.0f;\n\n    dummybathy[(XForcing.Bathy[0].nx - 1) + 1 * XForcing.Bathy[0].nx] = maxtopo + 10.0f;\n    dummybathy[(XForcing.Bathy[0].nx - 2) + 1 * XForcing.Bathy[0].nx] = maxtopo + 10.0f;\n\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            mintopo = min(dummybathy[i + j * XForcing.Bathy[0].nx], mintopo);\n        }\n    }\n\n    // Flip or rotate the bathy according to what is requested\n    for (int j = 0; j &lt; XForcing.Bathy[0].ny; j++)\n    {\n        for (int i = 0; i &lt; XForcing.Bathy[0].nx; i++)\n        {\n            if (!flip &amp;&amp; !bottop)\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = dummybathy[i + j * XForcing.Bathy[0].nx];\n            }\n            else if (flip &amp;&amp; !bottop)\n            {\n                XForcing.Bathy[0].val[(XForcing.Bathy[0].nx - 1 - i) + j * XForcing.Bathy[0].nx] = dummybathy[i + j * XForcing.Bathy[0].nx];\n            }\n            else if (!flip &amp;&amp; bottop)\n            {\n                XForcing.Bathy[0].val[i + j * XForcing.Bathy[0].nx] = dummybathy[j + i * XForcing.Bathy[0].nx];\n            }\n            else if (flip &amp;&amp; bottop)\n            {\n                XForcing.Bathy[0].val[i + (XForcing.Bathy[0].ny - 1 - j) * XForcing.Bathy[0].nx] = dummybathy[j + i * XForcing.Bathy[0].nx];\n            }\n        }\n    }\n\n    free(dummybathy);\n\n    return XForcing;\n\n}\n\n\nvoid alloc_init2Darray(float** arr, int NX, int NY)\n{\n    int i, j;\n    //Allocation\n    arr = (float**)malloc(sizeof(float*) * NX);\n    for (i = 0; i &lt; NX; i++) {\n        arr[i] = (float*)malloc(sizeof(float) * NY);\n    }\n\n    //arr = (int **)malloc(sizeof(int *) * NX);\n    //for (i = 0; i &lt; NX; i++) {\n    //  arr[i] = (int *)malloc(sizeof(int) * NY);\n    //}\n    //Initialisation\n    for (i = 0; i &lt; NX; i++) {\n        for (j = 0; j &lt; NY; j++) {\n            arr[i][j] = 0;\n        }\n    }\n}\n\nvoid init3Darray(float*** arr, int rows, int cols, int depths)\n{\n    int i, j, k;\n    for (i = 0; i &lt; rows; i++) {\n        for (j = 0; j &lt; cols; j++) {\n            for (k = 0; k &lt; depths; k++)\n            {\n                arr[i][j][k] = 0;\n            }\n        }\n    }\n}\n\ntemplate &lt;class T&gt; void fillrandom(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int n = memloc(XParam, ix, iy, ib);\n                z[n] = T(rand()) / T(RAND_MAX);\n            }\n        }\n    }\n}\ntemplate void fillrandom&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z);\ntemplate void fillrandom&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z);\n\ntemplate &lt;class T&gt; void fillgauss(Param XParam, BlockP&lt;T&gt; XBlock, T amp, T* z)\n{\n    T delta, x, y;\n    T cc = T(0.05) * (XParam.xmax - XParam.xo);\n    T xorigin = XParam.xo + T(0.5) * (XParam.xmax - XParam.xo);\n    T yorigin = XParam.yo + T(0.5) * (XParam.ymax - XParam.yo);\n\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XBlock.active[ibl];\n        delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                //\n                int n = memloc(XParam, ix, iy, ib);\n                x = T(XParam.xo + XBlock.xo[ib] + ix * delta);\n                y = T(XParam.yo + XBlock.yo[ib] + iy * delta);\n                z[n] = z[n] + amp * exp(T(-1.0) * T(((x - xorigin) * (x - xorigin) + (y - yorigin) * (y - yorigin)) / (2.0 * cc * cc)));\n\n\n            }\n        }\n    }\n}\ntemplate void fillgauss&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float amp, float* z);\ntemplate void fillgauss&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double amp, double* z);\n\ntemplate &lt;class T&gt;\nvoid TestingOutput(Param XParam, Model&lt;T&gt; XModel)\n{\n    std::string outvar;\n\n    Loop&lt;T&gt; XLoop;\n    // GPU stuff\n\n\n    XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    XLoop.totaltime = 0.0;\n\n    XLoop.nextoutputtime = 0.2;\n\n    Forcing&lt;float&gt; XForcing;\n\n    //FlowCPU(XParam, XLoop, XModel);\n\n    //log(std::to_string(XForcing.Bathy.val[50]));\n    creatncfileBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, XModel.blocks.outZone[0]);\n    outvar = \"h\";\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, 3, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n    outvar = \"u\";\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, 3, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n    outvar = \"v\";\n    //copyID2var(XParam, XModel.blocks, XModel.OutputVarMap[outvar]);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, 3, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n    outvar = \"zb\";\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, 3, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n    outvar = \"zs\";\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, 3, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n\n\n    FlowCPU(XParam, XLoop, XForcing, XModel);\n\n\n    //outvar = \"cf\";\n    //defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, 3, XModel.cf);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"dhdx\", 3, XModel.grad.dhdx, XModel.blocks.outZone[0]);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"dhdy\", 3, XModel.grad.dhdy, XModel.blocks.outZone[0]);\n\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"Fhv\", 3, XModel.flux.Fhv, XModel.blocks.outZone[0]);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"Fhu\", 3, XModel.flux.Fhu, XModel.blocks.outZone[0]);\n\n\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"Fqux\", 3, XModel.flux.Fqux, XModel.blocks.outZone[0]);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"Fquy\", 3, XModel.flux.Fquy, XModel.blocks.outZone[0]);\n\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"Fqvx\", 3, XModel.flux.Fqvx, XModel.blocks.outZone[0]);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"Fqvy\", 3, XModel.flux.Fqvy, XModel.blocks.outZone[0]);\n\n\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"Su\", 3, XModel.flux.Su, XModel.blocks.outZone[0]);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"Sv\", 3, XModel.flux.Sv, XModel.blocks.outZone[0]);\n\n\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"dh\", 3, XModel.adv.dh, XModel.blocks.outZone[0]);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"dhu\", 3, XModel.adv.dhu, XModel.blocks.outZone[0]);\n    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, \"dhv\", 3, XModel.adv.dhv, XModel.blocks.outZone[0]);\n\n    writenctimestep(XParam.outfile, XLoop.totaltime + XLoop.dt);\n\n\n    outvar = \"h\";\n    writencvarstepBUQ(XParam, 3, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n\n    outvar = \"zs\";\n    writencvarstepBUQ(XParam, 3, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n    outvar = \"u\";\n    writencvarstepBUQ(XParam, 3, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n    outvar = \"v\";\n    writencvarstepBUQ(XParam, 3, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, outvar, XModel.OutputVarMap[outvar], XModel.blocks.outZone[0]);\n\n}\n\ntemplate void TestingOutput&lt;float&gt;(Param XParam, Model&lt;float&gt; XModel);\ntemplate void TestingOutput&lt;double&gt;(Param XParam, Model&lt;double&gt; XModel);\n\ntemplate &lt;class T&gt; void copyID2var(Param XParam, BlockP&lt;T&gt; XBlock, T* z)\n{\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int n = memloc(XParam, ix, iy, ib);\n                z[n] = T(ib);\n            }\n        }\n    }\n\n}\n\ntemplate void copyID2var&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, float* z);\ntemplate void copyID2var&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, double* z);\n\n\ntemplate &lt;class T&gt; void copyBlockinfo2var(Param XParam, BlockP&lt;T&gt; XBlock, int* blkinfo, T* z)\n{\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        int ib = XBlock.active[ibl];\n        int info = blkinfo[ib];\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int n = memloc(XParam, ix, iy, ib);\n                z[n] = T(info);\n            }\n        }\n    }\n\n}\ntemplate void copyBlockinfo2var&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, int* blkinfo, float* z);\ntemplate void copyBlockinfo2var&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, int* blkinfo, double* z);\n\n\ntemplate &lt;class T&gt; void CompareCPUvsGPU(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g, std::vector&lt;std::string&gt; varlist, bool checkhalo)\n{\n    Loop&lt;T&gt; XLoop;\n    // GPU stuff\n\n\n    XLoop.hugenegval = std::numeric_limits&lt;T&gt;::min();\n\n    XLoop.hugeposval = std::numeric_limits&lt;T&gt;::max();\n    XLoop.epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    XLoop.totaltime = 0.0;\n\n    XLoop.nextoutputtime = 3600.0;\n\n\n    T* gpureceive;\n    T* diff;\n\n    //Forcing&lt;float&gt; XForcing;\n\n    AllocateCPU(XParam.nblkmem, XParam.blksize, gpureceive);\n    AllocateCPU(XParam.nblkmem, XParam.blksize, diff);\n\n\n    //============================================\n    // Compare gradients for evolving parameters\n\n    // calculate difference\n    //diffArray(XParam, XLoop, XModel.blocks, XModel.evolv.h, XModel_g.evolv.h, XModel.evolv_o.u);\n    /*\n    creatncfileBUQ(XParam, XModel.blocks);\n\n    for (int ivar = 0; ivar &lt; varlist.size(); ivar++)\n    {\n        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, varlist[ivar], 3, XModel.OutputVarMap[varlist[ivar]], XModel.blocks.outZone[0]);\n    }\n    */\n    /*\n    std::string varname = \"dt\";\n    if (abs(dtgpu - dtcpu) &lt; (XLoop.epsilon * 2))\n    {\n        log(varname + \" PASS\");\n    }\n    else\n    {\n        log(varname + \" FAIL: \" + \" GPU(\" + std::to_string(dtgpu) + \") - CPU(\"+std::to_string(dtcpu) +\") =  difference: \"+  std::to_string(abs(dtgpu - dtcpu)) + \" Eps: \" + std::to_string(XLoop.epsilon));\n\n    }\n    */\n    //Check variable\n    for (int ivar = 0; ivar &lt; varlist.size(); ivar++)\n    {\n        diffArray(XParam, XModel.blocks, varlist[ivar], checkhalo, XModel.OutputVarMap[varlist[ivar]], XModel_g.OutputVarMap[varlist[ivar]], gpureceive, diff);\n    }\n\n\n\n    free(gpureceive);\n    free(diff);\n\n}\ntemplate void CompareCPUvsGPU&lt;float&gt;(Param XParam, Model&lt;float&gt; XModel, Model&lt;float&gt; XModel_g, std::vector&lt;std::string&gt; varlist, bool checkhalo);\ntemplate void CompareCPUvsGPU&lt;double&gt;(Param XParam, Model&lt;double&gt; XModel, Model&lt;double&gt; XModel_g, std::vector&lt;std::string&gt; varlist, bool checkhalo);\n\n\ntemplate &lt;class T&gt; void diffdh(Param XParam, BlockP&lt;T&gt; XBlock, T* input, T* output, T* shuffle)\n{\n    int iright, itop;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XBlock.active[ibl];\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                iright = memloc(XParam.halowidth, XParam.blkmemwidth, ix + 1, iy, ib);\n                itop = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy + 1, ib);\n\n                output[i] = input[iright] - input[i];\n                shuffle[i] = input[iright];\n            }\n        }\n    }\n}\n\ntemplate &lt;class T&gt; void diffSource(Param XParam, BlockP&lt;T&gt; XBlock, T* Fqux, T* Su, T* output)\n{\n    int iright, itop;\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XBlock.active[ibl];\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n                iright = memloc(XParam.halowidth, XParam.blkmemwidth, ix + 1, iy, ib);\n                itop = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy + 1, ib);\n\n                output[i] = Fqux[i] - Su[iright];\n                //shuffle[i] = input[iright];\n            }\n        }\n    }\n}\n\ntemplate &lt;class T&gt; void diffArray(Param XParam, BlockP&lt;T&gt; XBlock, std::string varname, bool checkhalo, T* cpu, T* gpu, T* dummy, T* out)\n{\n    T diff, maxdiff, rmsdiff;\n    unsigned int nit = 0;\n    int ixmd, iymd, ibmd;\n    //copy GPU back to the CPU (store in dummy)\n    CopyGPUtoCPU(XParam.nblkmem, XParam.blksize, dummy, gpu);\n\n\n    T hugeposval = std::numeric_limits&lt;T&gt;::max();\n    T hugenegval = T(-1.0) * hugeposval;\n    T epsilon = std::numeric_limits&lt;T&gt;::epsilon();\n\n    rmsdiff = T(0.0);\n    maxdiff = hugenegval;\n    ixmd = 0;\n    iymd = 0;\n    ibmd = 0;\n\n    // calculate difference\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        //printf(\"bl=%d\\tblockxo[bl]=%f\\tblockyo[bl]=%f\\n\", bl, blockxo[bl], blockyo[bl]);\n        int ib = XBlock.active[ibl];\n\n        int yst = checkhalo ? -1 : 0;\n        int ynd = checkhalo ? XParam.blkwidth + 1 : XParam.blkwidth;\n\n        int xst = checkhalo ? -1 : 0;\n        int xnd = checkhalo ? XParam.blkwidth + 1 : XParam.blkwidth;\n\n        for (int iy = yst; iy &lt; ynd; iy++)\n        {\n            for (int ix = xst; ix &lt; xnd; ix++)\n            {\n                int n = memloc(XParam, ix, iy, ib);\n                diff = dummy[n] - cpu[n];\n\n                if (abs(diff) &gt;= maxdiff)\n                {\n                    maxdiff = utils::max(abs(diff), maxdiff);\n                    ixmd = ix;\n                    iymd = iy;\n                    ibmd = ib;\n                }\n\n                rmsdiff = rmsdiff + utils::sq(diff);\n                nit++;\n                out[n] = diff;\n            }\n        }\n\n    }\n\n\n    rmsdiff = rmsdiff / nit;\n\n\n\n    if (maxdiff &lt;= T(10000.0) * (epsilon))\n    {\n        log(varname + \" PASS\");\n    }\n    else\n    {\n        creatncfileBUQ(XParam, XBlock);\n        log(varname + \" FAIL: \" + \" Max difference: \" + std::to_string(maxdiff) + \" (at: ix = \" + std::to_string(ixmd) + \" iy = \" + std::to_string(iymd) + \" ib = \" + std::to_string(ibmd) + \") RMS difference: \" + std::to_string(rmsdiff) + \" Eps: \" + std::to_string(epsilon));\n        defncvarBUQ(XParam, XBlock.active, XBlock.level, XBlock.xo, XBlock.yo, varname + \"_CPU\", 3, cpu, XBlock.outZone[0]);\n        defncvarBUQ(XParam, XBlock.active, XBlock.level, XBlock.xo, XBlock.yo, varname + \"_GPU\", 3, dummy, XBlock.outZone[0]);\n        defncvarBUQ(XParam, XBlock.active, XBlock.level, XBlock.xo, XBlock.yo, varname + \"_diff\", 3, out, XBlock.outZone[0]);\n    }\n\n\n\n\n}\n</code></pre>"},{"location":"BGFlood/_testing_8h/","title":"File Testing.h","text":""},{"location":"BGFlood/_testing_8h/#file-testingh","title":"File Testing.h","text":"<p>FileList &gt; src &gt; Testing.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"ReadInput.h\"</code></li> <li><code>#include \"ReadForcing.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"Mesh.h\"</code></li> <li><code>#include \"Setup_GPU.h\"</code></li> <li><code>#include \"Mainloop.h\"</code></li> <li><code>#include \"FlowCPU.h\"</code></li> <li><code>#include \"FlowGPU.h\"</code></li> <li><code>#include \"Adaptation.h\"</code></li> <li><code>#include \"utctime.h\"</code></li> </ul>"},{"location":"BGFlood/_testing_8h/#public-functions","title":"Public Functions","text":"Type Name void CompareCPUvsGPU (Param XParam, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g, std::vector&lt; std::string &gt; varlist, bool checkhalo) Compares the Variables in a CPU model and a GPU models This function is quite useful when checking both are identical enough one needs to provide a list (vector&lt;string&gt;) of variable to check. bool GaussianHumptest (T zsnit, int gpu, bool compare) Gaussian hump propagation test. bool MassConserveSteepSlope (T zsnit, int gpu) River inflow mass conservation test on steep slope. bool Rainlossestest (T zsnit, int gpu, float alpha) Test the Initial and Continuous losses implementation This function tests the Initial Losses and Continuous Losses implementation a plain domain, under constant rain. The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsinit=0.0 is dry) and runs for 1s comparing results every 0.1s (that is approx 20 steps) bool Raintest (T zsnit, int gpu, float alpha, int engine) Test the rain input and mass conservation This function tests the mass conservation of the spacial injection (used to model rain on grid) The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsnit=0.0 is dry) and runs for 0.1s before comparing results with zsnit=0.1 that is approx 20 steps. bool Raintestinput (int gpu) Test the rain input options This function tests the different inputs for rain forcing. This test is based on the paper Aureli2020, the 3 slopes test with regional rain. The experiment has been presented in Iwagaki1955. The first test compares a time varying rain input using a uniform time serie forcing and a time varying 2D field (with same value). The second test check the 3D rain forcing (comparing it to expected values). std::vector&lt; float &gt; Raintestmap (int gpu, int dimf, T zinit) Test the rain input options and return the flux at the bottom of the slope This function return the flux at the bottom of the 3 part slope for different types of rain forcings using the test case based on Iwagaki1955. bool Rivertest (T zsnit, int gpu) River inflow mass conservation test. bool TestFlexibleOutputTimes (int gpu, T ref, int scenario) Test the reading of flexible output times. bool TestMultiBathyRough (int gpu, T ref, int secnario) Test the reading of multiple bathymetry and roughness files. bool Testing (Param XParam, Forcing&lt; float &gt; XForcing, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Wrapping function for all the inbuilt test This function is the entry point to other function below. void TestingOutput (Param XParam, Model&lt; T &gt; XModel) OUTDATED ?Test the output functions of the model OUTDATED? This function tests the output functions of the model by running a simple simulation and writing the output to a netcdf file. bool ZoneOutputTest (int nzones, T zsinit) Test the zoned output This function test the zoned output for a basic configuration. void copyBlockinfo2var (Param XParam, BlockP&lt; T &gt; XBlock, int * blkinfo, T * z) Copies block info to an output variable This function copies block info to an output variable This function is somewhat useful when checking bugs in the mesh refinement or coarsening one needs to provide a pointer(z) allocated on the CPU to store the clockinfo This fonction only works on CPU. void copyID2var (Param XParam, BlockP&lt; T &gt; XBlock, T * z) Copies block ID to an output variable This function copies block info to an output variable This function is somewhat useful when checking bugs in the mesh refinement or coarsening one needs to provide a pointer(z) allocated on the CPU to store the clockinfo This fonction only works on CPU. bool testboundaries (Param XParam, T maxslope)"},{"location":"BGFlood/_testing_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_testing_8h/#function-comparecpuvsgpu","title":"function CompareCPUvsGPU","text":"<p>Compares the Variables in a CPU model and a GPU models This function is quite useful when checking both are identical enough one needs to provide a list (vector&lt;string&gt;) of variable to check. </p><pre><code>template&lt;class T&gt;\nvoid CompareCPUvsGPU (\n    Param XParam,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g,\n    std::vector&lt; std::string &gt; varlist,\n    bool checkhalo\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure (CPU) </li> <li><code>XModel_g</code> Model structure (GPU) </li> <li><code>varlist</code> List of variable names to check (as in OutputVarMap) </li> <li><code>checkhalo</code> true if halo cells should be checked, false otherwise </li> </ul>"},{"location":"BGFlood/_testing_8h/#function-gaussianhumptest","title":"function GaussianHumptest","text":"<p>Gaussian hump propagation test. </p><pre><code>template&lt;class T&gt;\nbool GaussianHumptest (\n    T zsnit,\n    int gpu,\n    bool compare\n) \n</code></pre> <p>!</p> <p>This function tests the full hydrodynamics model and compares the results with pre-conmputed (Hard wired) values The function creates it own model setup and mesh independantly to what the user might want to do The setup consist of a centrally located gaussian hump radiating away The test stops at an arbitrary time to compare with 8 values extracted from a identical run in basilisk This function also compares the result of the GPU and CPU code (until they diverge) </p> <p>Parameters:</p> <ul> <li><code>zsnit</code> Initial water surface elevation at the centre of the domain </li> <li><code>gpu</code> GPU device number to use (-1 for CPU only) </li> <li><code>compare</code> If true, compare GPU and CPU results (GPU required) </li> </ul> <p>Returns:</p> <p>true if the test passed (results within 1e-6 of reference values) </p>"},{"location":"BGFlood/_testing_8h/#function-massconservesteepslope","title":"function MassConserveSteepSlope","text":"<p>River inflow mass conservation test on steep slope. </p><pre><code>template&lt;class T&gt;\nbool MassConserveSteepSlope (\n    T zsnit,\n    int gpu\n) \n</code></pre> <p>!</p> <p>This function tests the mass conservation of the vertical injection (used for rivers) The function creates it own model setup and mesh independantly to what the user might want to do This starts with a initial water level (zsnit=0 is dry) and runs for 0.1s before comparing results with zsnit=0.1 that is approx 20 steps </p> <p>Parameters:</p> <ul> <li><code>zsnit</code> Initial water surface elevation at the centre of the domain </li> <li><code>gpu</code> GPU device number to use (-1 for CPU only) </li> </ul> <p>Returns:</p> <p>true if the test passed (mass conservation within 5%) </p>"},{"location":"BGFlood/_testing_8h/#function-rainlossestest","title":"function Rainlossestest","text":"<p>Test the Initial and Continuous losses implementation This function tests the Initial Losses and Continuous Losses implementation a plain domain, under constant rain. The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsinit=0.0 is dry) and runs for 1s comparing results every 0.1s (that is approx 20 steps) </p><pre><code>template&lt;class T&gt;\nbool Rainlossestest (\n    T zsnit,\n    int gpu,\n    float alpha\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>zsinit</code> Initial water level </li> <li><code>gpu</code> GPU device to use (or -1 for CPU) </li> <li><code>alpha</code> Tolerance for the test (relative error) </li> </ul> <p>Returns:</p> <p>true if test passed </p>"},{"location":"BGFlood/_testing_8h/#function-raintest","title":"function Raintest","text":"<p>Test the rain input and mass conservation This function tests the mass conservation of the spacial injection (used to model rain on grid) The function creates its own model setup and mesh independantly to what the user inputs. This starts with a initial water level (zsnit=0.0 is dry) and runs for 0.1s before comparing results with zsnit=0.1 that is approx 20 steps. </p><pre><code>template&lt;class T&gt;\nbool Raintest (\n    T zsnit,\n    int gpu,\n    float alpha,\n    int engine\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>zsnit</code> Initial water level </li> <li><code>gpu</code> GPU device to use (or -1 for CPU) </li> <li><code>alpha</code> Slope of the bathymetry in % </li> <li><code>engine</code> Engine to use (0=non-hydrostatic, 1=hydrostatic) </li> </ul> <p>Returns:</p> <p>true if test passed </p>"},{"location":"BGFlood/_testing_8h/#function-raintestinput","title":"function Raintestinput","text":"<p>Test the rain input options This function tests the different inputs for rain forcing. This test is based on the paper Aureli2020, the 3 slopes test with regional rain. The experiment has been presented in Iwagaki1955. The first test compares a time varying rain input using a uniform time serie forcing and a time varying 2D field (with same value). The second test check the 3D rain forcing (comparing it to expected values). </p><pre><code>bool Raintestinput (\n    int gpu\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>gpu</code> GPU device to use (or -1 for CPU) </li> </ul> <p>Returns:</p> <p>true if test passed </p>"},{"location":"BGFlood/_testing_8h/#function-raintestmap","title":"function Raintestmap","text":"<p>Test the rain input options and return the flux at the bottom of the slope This function return the flux at the bottom of the 3 part slope for different types of rain forcings using the test case based on Iwagaki1955. </p><pre><code>template&lt;class T&gt;\nstd::vector&lt; float &gt; Raintestmap (\n    int gpu,\n    int dimf,\n    T zinit\n) \n</code></pre> <p>! \\fnstd::vector&lt;float&gt; Raintestmap(int gpu, int dimf, T zinit) </p> <p>Parameters:</p> <ul> <li><code>gpu</code> GPU device to use (or -1 for CPU) </li> <li><code>dimf</code> Dimension of the rain forcing (1=uniform, 3=2 </li> <li><code>zinit</code> Initial water level </li> </ul> <p>Returns:</p> <p>vector of flux at the bottom of the slope </p>"},{"location":"BGFlood/_testing_8h/#function-rivertest","title":"function Rivertest","text":"<p>River inflow mass conservation test. </p><pre><code>template&lt;class T&gt;\nbool Rivertest (\n    T zsnit,\n    int gpu\n) \n</code></pre> <p>!</p> <p>This function tests the mass conservation of the vertical injection (used for rivers) The function creates it own model setup and mesh independantly to what the user might want to do This starts with a initial water level (zsnit=0 is dry) and runs for 0.1s before comparing results with zsnit=0.1 that is approx 20 steps </p> <p>Parameters:</p> <ul> <li><code>zsnit</code> Initial water surface elevation at the centre of the domain </li> <li><code>gpu</code> GPU device number to use (-1 for CPU only) </li> </ul> <p>Returns:</p> <p>true if the test is successful (mass is conserved within 0.1% of the theoretical value) </p>"},{"location":"BGFlood/_testing_8h/#function-testflexibleoutputtimes","title":"function TestFlexibleOutputTimes","text":"<p>Test the reading of flexible output times. </p><pre><code>template&lt;class T&gt;\nbool TestFlexibleOutputTimes (\n    int gpu,\n    T ref,\n    int scenario\n) \n</code></pre> <p>This function creates a case set-up with a param file, read it. It tests the reading and default values used for times outputs. It checks the vectors for time outputs. </p> <p>Parameters:</p> <ul> <li><code>gpu</code> GPU to use (-1 for CPU only) </li> <li><code>ref</code> Reference elevation for the bathymetry files </li> <li><code>scenario</code> Scenario to test (not used here but could be used to test different input cases) </li> </ul> <p>Returns:</p> <p>true if test passed (i.e. the model runs without crashing and gives a reasonable result) </p>"},{"location":"BGFlood/_testing_8h/#function-testmultibathyrough","title":"function TestMultiBathyRough","text":"<p>Test the reading of multiple bathymetry and roughness files. </p><pre><code>template&lt;class T&gt;\nbool TestMultiBathyRough (\n    int gpu,\n    T ref,\n    int secnario\n) \n</code></pre> <p>!</p> <p>This function creates bathy and roughtness files and tests their reading (and interpolation) The objectif is particularly to test multi bathy/roughness inputs and value/file input.</p> <p>Parameters:</p> <ul> <li><code>gpu</code> GPU to use (-1 for CPU only) </li> <li><code>ref</code> Reference elevation for the bathymetry files </li> <li><code>scenario</code> Scenario to test (0: R1 in the middle of the domain, 1: R1 covering the whole domain) </li> </ul> <p>Returns:</p> <p>true if test passed (i.e. the model runs without crashing and gives a reasonable result) </p>"},{"location":"BGFlood/_testing_8h/#function-testing","title":"function Testing","text":"<p>Wrapping function for all the inbuilt test This function is the entry point to other function below. </p><pre><code>template&lt;class T&gt;\nbool Testing (\n    Param XParam,\n    Forcing &lt; float &gt; XForcing,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Test 0 is a gausian hump propagating on a flat uniorm cartesian mesh (both GPU and CPU version tested) Test 1 is vertical discharge on a flat uniorm cartesian mesh (GPU or CPU version) Test 2 Gaussian wave on Cartesian grid (same as test 0): CPU vs GPU (GPU required) Test 3 Test Reduction algorithm Test 4 Boundary condition test Test 5 Lake at rest test for Ardusse/kurganov reconstruction/scheme Test 6 Mass conservation on a slope Test 7 Mass conservation with rain fall on grid Test 8 Rain Map forcing (comparison map and Time Serie and test case with slope and non-uniform rain map) Test 9 Zoned output (test zoned outputs with adaptative grid) Test 10 Initial Loss / Continuous Loss on a slope, under uniform rain Test 11 Wet/dry Instability test with Conserve Elevation Test 12 Calendar time to second conversion Test 13 Multi bathy and roughness map input Test 14 Test AOI bnds aswall to start with Test 15 Flexible times reading</p> <p>Test 99 Run all the test with test number &lt; 99.</p> <p>The following test are not independant, they are tools to check or debug a personnal case Test 998 Compare resuts between the CPU and GPU Flow functions (GPU required) Test 999 Run the main loop and engine in debug mode</p> <p>Parameters:</p> <ul> <li><code>XParam</code> Simulation parameters </li> <li><code>XForcing</code> Forcing data structure </li> <li><code>XModel</code> Host model data structure </li> <li><code>XModel_g</code> Device model data structure </li> </ul> <p>Returns:</p> <p>true if all the tests passed </p>"},{"location":"BGFlood/_testing_8h/#function-testingoutput","title":"function TestingOutput","text":"<p>OUTDATED ?Test the output functions of the model OUTDATED? This function tests the output functions of the model by running a simple simulation and writing the output to a netcdf file. </p><pre><code>template&lt;class T&gt;\nvoid TestingOutput (\n    Param XParam,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XModel</code> Model structure (CPU) </li> </ul>"},{"location":"BGFlood/_testing_8h/#function-zoneoutputtest","title":"function ZoneOutputTest","text":"<p>Test the zoned output This function test the zoned output for a basic configuration. </p><pre><code>template&lt;class T&gt;\nbool ZoneOutputTest (\n    int nzones,\n    T zsinit\n) \n</code></pre> <p>! </p> <p>Parameters:</p> <ul> <li><code>nzones</code> Number of zones to test (1 or 3) </li> <li><code>zsinit</code> Initial water level </li> </ul> <p>Returns:</p> <p>true if test passed </p>"},{"location":"BGFlood/_testing_8h/#function-copyblockinfo2var","title":"function copyBlockinfo2var","text":"<p>Copies block info to an output variable This function copies block info to an output variable This function is somewhat useful when checking bugs in the mesh refinement or coarsening one needs to provide a pointer(z) allocated on the CPU to store the clockinfo This fonction only works on CPU. </p><pre><code>template&lt;class T&gt;\nvoid copyBlockinfo2var (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    int * blkinfo,\n    T * z\n) \n</code></pre> <p>!</p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters (only nblk, blkwidth, xo, yo, xmax, ymax and dx are used) </li> <li><code>XBlock</code> Block parameters (only active is used) </li> <li><code>blkinfo</code> Block information array (CPU) </li> <li><code>z</code> Array to fill </li> </ul>"},{"location":"BGFlood/_testing_8h/#function-copyid2var","title":"function copyID2var","text":"<p>Copies block ID to an output variable This function copies block info to an output variable This function is somewhat useful when checking bugs in the mesh refinement or coarsening one needs to provide a pointer(z) allocated on the CPU to store the clockinfo This fonction only works on CPU. </p><pre><code>template&lt;class T&gt;\nvoid copyID2var (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    T * z\n) \n</code></pre> <p>!</p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters (only nblk, blkwidth, xo, yo, xmax, ymax and dx are used) </li> <li><code>XBlock</code> Block parameters (only active is used) </li> <li><code>z</code> Array to fill </li> </ul>"},{"location":"BGFlood/_testing_8h/#function-testboundaries","title":"function testboundaries","text":"<pre><code>template&lt;class T&gt;\nbool testboundaries (\n    Param XParam,\n    T maxslope\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Testing.h</code></p>"},{"location":"BGFlood/_testing_8h_source/","title":"File Testing.h","text":""},{"location":"BGFlood/_testing_8h_source/#file-testingh","title":"File Testing.h","text":"<p>File List &gt; src &gt; Testing.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef TESTING_H\n#define TESTING_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"ReadInput.h\"\n#include \"ReadForcing.h\"\n\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"Mesh.h\"\n\n#include \"Setup_GPU.h\"\n#include \"Mainloop.h\"\n#include \"FlowCPU.h\"\n#include \"FlowGPU.h\"\n\n#include \"Adaptation.h\"\n\n#include \"utctime.h\"\n\ntemplate &lt;class T&gt; bool Testing(Param XParam, Forcing&lt;float&gt; XForcing, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g);\n\ntemplate &lt;class T&gt; bool GaussianHumptest(T zsnit, int gpu,bool compare);\n\n\ntemplate &lt;class T&gt; void TestingOutput(Param XParam, Model&lt;T&gt; XModel);\ntemplate &lt;class T&gt; void copyID2var(Param XParam, BlockP&lt;T&gt; XBlock, T* z);\ntemplate &lt;class T&gt; void copyBlockinfo2var(Param XParam, BlockP&lt;T&gt; XBlock, int* blkinfo, T* z);\ntemplate &lt;class T&gt; void CompareCPUvsGPU(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g, std::vector&lt;std::string&gt; varlist, bool checkhalo);\n//template &lt;class T&gt; void Gaussianhump(Param XParam, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g);\ntemplate &lt;class T&gt; std::vector&lt;float&gt; Raintestmap(int gpu, int dimf, T zinit);\nbool Raintestinput(int gpu);\ntemplate &lt;class T&gt; bool Rivertest(T zsnit, int gpu);\ntemplate &lt;class T&gt; bool MassConserveSteepSlope(T zsnit, int gpu);\ntemplate &lt;class T&gt; bool Raintest(T zsnit, int gpu, float alpha,int engine);\ntemplate &lt;class T&gt; bool testboundaries(Param XParam, T maxslope);\ntemplate &lt;class T&gt; bool ZoneOutputTest(int nzones, T zsinit);\ntemplate &lt;class T&gt; bool Rainlossestest(T zsnit, int gpu, float alpha);\ntemplate &lt;class T&gt; bool TestMultiBathyRough(int gpu, T ref, int secnario);\ntemplate &lt;class T&gt; bool TestFlexibleOutputTimes(int gpu, T ref, int scenario);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/","title":"File Updateforcing.cu","text":""},{"location":"BGFlood/_updateforcing_8cu/#file-updateforcingcu","title":"File Updateforcing.cu","text":"<p>FileList &gt; src &gt; Updateforcing.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Updateforcing.h\"</code></li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#public-functions","title":"Public Functions","text":"Type Name __host__ void AddDeformCPU (Param XParam, BlockP&lt; T &gt; XBlock, deformmap&lt; float &gt; defmap, EvolvingP&lt; T &gt; XEv, T scale, T * zb) Perform a deformation step on the model on the CPU. Applies deformation maps to the model based on the current simulation time and deformation parameters.  __ __global__ void AddDeformGPU (Param XParam, BlockP&lt; T &gt; XBlock, deformmap&lt; float &gt; defmap, EvolvingP&lt; T &gt; XEv, T scale, T * zb) Perform a deformation step on the model on the GPU. Applies deformation maps to the model based on the current simulation time and deformation parameters. __host__ void AddPatmforcingCPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; PAtm, Model&lt; T &gt; XModel) Add atmospheric pressure forcing to the model on the CPU. Adds atmospheric pressure forcing to the model based on pressure data and current simulation time. template __host__ void AddPatmforcingCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; PAtm, Model&lt; double &gt; XModel)  template __host__ void AddPatmforcingCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; PAtm, Model&lt; float &gt; XModel)  __global__ void AddPatmforcingGPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; PAtm, Model&lt; T &gt; XModel) Add atmospheric pressure forcing to the model on the GPU. Adds atmospheric pressure forcing to the model based on pressure data and current simulation time. template __global__ void AddPatmforcingGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; PAtm, Model&lt; double &gt; XModel)  template __global__ void AddPatmforcingGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; PAtm, Model&lt; float &gt; XModel)  __host__ void AddRiverForcing (Param XParam, Loop&lt; T &gt; XLoop, std::vector&lt; River &gt; XRivers, Model&lt; T &gt; XModel) Add river forcing to the model. Adds river discharge forcing to the model based on river data and current simulation time. template __host__ void AddRiverForcing&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, std::vector&lt; River &gt; XRivers, Model&lt; double &gt; XModel)  template __host__ void AddRiverForcing&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, std::vector&lt; River &gt; XRivers, Model&lt; float &gt; XModel)  __host__ void AddinfiltrationImplicitCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, T * il, T * cl, EvolvingP&lt; T &gt; XEv, T * hgw) Add infiltration forcing to the model implicitly on the CPU. Adds infiltration forcing to the model based on infiltration data and current water depth, updating water depth and surface elevation. template __host__ void AddinfiltrationImplicitCPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, double * il, double * cl, EvolvingP&lt; double &gt; XEv, double * hgw)  template __host__ void AddinfiltrationImplicitCPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, float * il, float * cl, EvolvingP&lt; float &gt; XEv, float * hgw)  __global__ void AddinfiltrationImplicitGPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, T * il, T * cl, EvolvingP&lt; T &gt; XEv, T * hgw) Add infiltration forcing to the model implicitly on the GPU. Adds infiltration forcing to the model based on infiltration data and current water depth, updating water depth and surface elevation. template __global__ void AddinfiltrationImplicitGPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, double * il, double * cl, EvolvingP&lt; double &gt; XEv, double * hgw)  template __global__ void AddinfiltrationImplicitGPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, float * il, float * cl, EvolvingP&lt; float &gt; XEv, float * hgw)  __host__ void AddrainforcingCPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Rain, AdvanceP&lt; T &gt; XAdv) Add rainfall forcing to the model on the CPU. Adds rainfall forcing to the model based on rainfall data and current simulation time. template __host__ void AddrainforcingCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; Rain, AdvanceP&lt; double &gt; XAdv)  template __host__ void AddrainforcingCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; Rain, AdvanceP&lt; float &gt; XAdv)  __global__ void AddrainforcingGPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Rain, AdvanceP&lt; T &gt; XAdv) Add rainfall forcing to the model on the GPU. Adds rainfall forcing to the model based on rainfall data and current simulation time. template __global__ void AddrainforcingGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; Rain, AdvanceP&lt; double &gt; XAdv)  template __global__ void AddrainforcingGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; Rain, AdvanceP&lt; float &gt; XAdv)  __host__ void AddrainforcingImplicitCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Rain, EvolvingP&lt; T &gt; XEv) Add rainfall forcing to the model implicitly on the CPU. Adds rainfall forcing to the model based on rainfall data and current simulation time, updating water depth and surface elevation. template __host__ void AddrainforcingImplicitCPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; Rain, EvolvingP&lt; double &gt; XEv)  template __host__ void AddrainforcingImplicitCPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; Rain, EvolvingP&lt; float &gt; XEv)  __global__ void AddrainforcingImplicitGPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Rain, EvolvingP&lt; T &gt; XEv) Add rainfall forcing to the model implicitly on the GPU. Adds rainfall forcing to the model based on rainfall data and current simulation time, updating water depth and surface elevation. template __global__ void AddrainforcingImplicitGPU&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; Rain, EvolvingP&lt; double &gt; XEv)  template __global__ void AddrainforcingImplicitGPU&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; Rain, EvolvingP&lt; float &gt; XEv)  __host__ void AddwindforcingCPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Uwind, DynForcingP&lt; float &gt; Vwind, AdvanceP&lt; T &gt; XAdv) Add wind forcing to the model on the CPU. Adds wind forcing to the model based on wind data and current simulation time. template __host__ void AddwindforcingCPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; Uwind, DynForcingP&lt; float &gt; Vwind, AdvanceP&lt; double &gt; XAdv)  template __host__ void AddwindforcingCPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; Uwind, DynForcingP&lt; float &gt; Vwind, AdvanceP&lt; float &gt; XAdv)  __global__ void AddwindforcingGPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Uwind, DynForcingP&lt; float &gt; Vwind, AdvanceP&lt; T &gt; XAdv) Add wind forcing to the model on the GPU. Adds wind forcing to the model based on wind data and current simulation time. template __global__ void AddwindforcingGPU&lt; double &gt; (Param XParam, BlockP&lt; double &gt; XBlock, DynForcingP&lt; float &gt; Uwind, DynForcingP&lt; float &gt; Vwind, AdvanceP&lt; double &gt; XAdv)  template __global__ void AddwindforcingGPU&lt; float &gt; (Param XParam, BlockP&lt; float &gt; XBlock, DynForcingP&lt; float &gt; Uwind, DynForcingP&lt; float &gt; Vwind, AdvanceP&lt; float &gt; XAdv)  void Forcingthisstep (Param XParam, double totaltime, DynForcingP&lt; float &gt; &amp; XDynForcing) Update dynamic forcing for the current simulation step. __global__ void InjectManyRiversGPU (Param XParam, int irib, RiverInfo&lt; T &gt; XRin, BlockP&lt; T &gt; XBlock, AdvanceP&lt; T &gt; XAdv) Inject multiple river discharges into the model grid on the GPU. Injects river discharges into the model grid based on river geometry and discharge rates. Optimisation by processing multiple rivers in a single kernel launch. __host__ void InjectRiverCPU (Param XParam, River XRiver, T qnow, int nblkriver, int * Riverblks, BlockP&lt; T &gt; XBlock, AdvanceP&lt; T &gt; XAdv) Inject river discharge into the model grid on the CPU. Injects river discharge into the model grid based on river geometry and discharge rate. template __host__ void InjectRiverCPU&lt; double &gt; (Param XParam, River XRiver, double qnow, int nblkriver, int * Riverblks, BlockP&lt; double &gt; XBlock, AdvanceP&lt; double &gt; XAdv)  template __host__ void InjectRiverCPU&lt; float &gt; (Param XParam, River XRiver, float qnow, int nblkriver, int * Riverblks, BlockP&lt; float &gt; XBlock, AdvanceP&lt; float &gt; XAdv)  __global__ void InjectRiverGPU (Param XParam, River XRiver, T qnow, int * Riverblks, BlockP&lt; T &gt; XBlock, AdvanceP&lt; T &gt; XAdv) Inject river discharge into the model grid on the GPU. Injects river discharge into the model grid based on river geometry and discharge rate. template __global__ void InjectRiverGPU&lt; double &gt; (Param XParam, River XRiver, double qnow, int * Riverblks, BlockP&lt; double &gt; XBlock, AdvanceP&lt; double &gt; XAdv)  template __global__ void InjectRiverGPU&lt; float &gt; (Param XParam, River XRiver, float qnow, int * Riverblks, BlockP&lt; float &gt; XBlock, AdvanceP&lt; float &gt; XAdv)  void deformstep (Param XParam, Loop&lt; T &gt; XLoop, std::vector&lt; deformmap&lt; float &gt;&gt; deform, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Perform a deformation step on the model. Applies deformation maps to the model based on the current simulation time and deformation parameters. Overloaded function to handle both CPU and GPU models. void deformstep (Param XParam, Loop&lt; T &gt; XLoop, std::vector&lt; deformmap&lt; float &gt;&gt; deform, Model&lt; T &gt; XModel) Perform a deformation step on the model. Applies deformation maps to the model based on the current simulation time and deformation parameters. template void deformstep&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, std::vector&lt; deformmap&lt; float &gt;&gt; deform, Model&lt; double &gt; XModel, Model&lt; double &gt; XModel_g)  template void deformstep&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, std::vector&lt; deformmap&lt; float &gt;&gt; deform, Model&lt; float &gt; XModel, Model&lt; float &gt; XModel_g)  __device__ T interp2BUQ (T x, T y, TexSetP Forcing) Interpolate data at given coordinates on the GPU. Interpolates data at specified coordinates using bilinear interpolation. template __device__ double interp2BUQ&lt; double &gt; (double x, double y, TexSetP Forcing)  template __device__ float interp2BUQ&lt; float &gt; (float x, float y, TexSetP Forcing)  __device__ T interpDyn2BUQ (T x, T y, TexSetP Forcing) Interpolate dynamic forcing data at given coordinates on the GPU. Interpolates dynamic forcing data at specified coordinates using bilinear interpolation. template __device__ double interpDyn2BUQ&lt; double &gt; (double x, double y, TexSetP Forcing)  template __device__ float interpDyn2BUQ&lt; float &gt; (float x, float y, TexSetP Forcing)  void updateforcing (Param XParam, Loop&lt; T &gt; XLoop, Forcing&lt; float &gt; &amp; XForcing) Update dynamic forcings for the current simulation step. Updates the dynamic forcing data for the current simulation time step. template void updateforcing&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, Forcing&lt; float &gt; &amp; XForcing)  template void updateforcing&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, Forcing&lt; float &gt; &amp; XForcing)"},{"location":"BGFlood/_updateforcing_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_updateforcing_8cu/#function-adddeformcpu","title":"function AddDeformCPU","text":"<p>Perform a deformation step on the model on the CPU. Applies deformation maps to the model based on the current simulation time and deformation parameters.  __ </p><pre><code>template&lt;class T&gt;\n__host__ void AddDeformCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    deformmap &lt; float &gt; defmap,\n    EvolvingP &lt; T &gt; XEv,\n    T scale,\n    T * zb\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>defmap</code> Deformation map </li> <li><code>XEv</code> Evolving data structure </li> <li><code>scale</code> Scaling factor for deformation </li> <li><code>zb</code> Bed elevation array </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-adddeformgpu","title":"function AddDeformGPU","text":"<p>Perform a deformation step on the model on the GPU. Applies deformation maps to the model based on the current simulation time and deformation parameters. </p><pre><code>template&lt;class T&gt;\n__global__ void AddDeformGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    deformmap &lt; float &gt; defmap,\n    EvolvingP &lt; T &gt; XEv,\n    T scale,\n    T * zb\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop structure containing time information </li> <li><code>deform</code> Vector of deformation maps </li> <li><code>XModel</code> Model data structure for GPU </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-addpatmforcingcpu","title":"function AddPatmforcingCPU","text":"<p>Add atmospheric pressure forcing to the model on the CPU. Adds atmospheric pressure forcing to the model based on pressure data and current simulation time. </p><pre><code>template&lt;class T&gt;\n__host__ void AddPatmforcingCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; PAtm,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>PAtm</code> Atmospheric pressure dynamic forcing structure </li> <li><code>XModel</code> Model data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-addpatmforcingcpu-double","title":"function AddPatmforcingCPU&lt; double &gt;","text":"<pre><code>template __host__ void AddPatmforcingCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; PAtm,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addpatmforcingcpu-float","title":"function AddPatmforcingCPU&lt; float &gt;","text":"<pre><code>template __host__ void AddPatmforcingCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; PAtm,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addpatmforcinggpu","title":"function AddPatmforcingGPU","text":"<p>Add atmospheric pressure forcing to the model on the GPU. Adds atmospheric pressure forcing to the model based on pressure data and current simulation time. </p><pre><code>template&lt;class T&gt;\n__global__ void AddPatmforcingGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; PAtm,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>PAtm</code> Atmospheric pressure dynamic forcing structure </li> <li><code>XModel</code> Model data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-addpatmforcinggpu-double","title":"function AddPatmforcingGPU&lt; double &gt;","text":"<pre><code>template __global__ void AddPatmforcingGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; PAtm,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addpatmforcinggpu-float","title":"function AddPatmforcingGPU&lt; float &gt;","text":"<pre><code>template __global__ void AddPatmforcingGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; PAtm,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addriverforcing","title":"function AddRiverForcing","text":"<p>Add river forcing to the model. Adds river discharge forcing to the model based on river data and current simulation time. </p><pre><code>template&lt;class T&gt;\n__host__ void AddRiverForcing (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    std::vector&lt; River &gt; XRivers,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop structure containing time information </li> <li><code>XRivers</code> Vector of river data structures </li> <li><code>XModel</code> Model data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-addriverforcing-double","title":"function AddRiverForcing&lt; double &gt;","text":"<pre><code>template __host__ void AddRiverForcing&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    std::vector&lt; River &gt; XRivers,\n    Model &lt; double &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addriverforcing-float","title":"function AddRiverForcing&lt; float &gt;","text":"<pre><code>template __host__ void AddRiverForcing&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    std::vector&lt; River &gt; XRivers,\n    Model &lt; float &gt; XModel\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addinfiltrationimplicitcpu","title":"function AddinfiltrationImplicitCPU","text":"<p>Add infiltration forcing to the model implicitly on the CPU. Adds infiltration forcing to the model based on infiltration data and current water depth, updating water depth and surface elevation. </p><pre><code>template&lt;class T&gt;\n__host__ void AddinfiltrationImplicitCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    T * il,\n    T * cl,\n    EvolvingP &lt; T &gt; XEv,\n    T * hgw\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop structure containing time information </li> <li><code>XBlock</code> Block data structure </li> <li><code>il</code> Initial infiltration rates array </li> <li><code>cl</code> Continuous infiltration rates array </li> <li><code>XEv</code> Evolving data structure </li> <li><code>hgw</code> Groundwater height array </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-addinfiltrationimplicitcpu-double","title":"function AddinfiltrationImplicitCPU&lt; double &gt;","text":"<pre><code>template __host__ void AddinfiltrationImplicitCPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    double * il,\n    double * cl,\n    EvolvingP &lt; double &gt; XEv,\n    double * hgw\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addinfiltrationimplicitcpu-float","title":"function AddinfiltrationImplicitCPU&lt; float &gt;","text":"<pre><code>template __host__ void AddinfiltrationImplicitCPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    float * il,\n    float * cl,\n    EvolvingP &lt; float &gt; XEv,\n    float * hgw\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addinfiltrationimplicitgpu","title":"function AddinfiltrationImplicitGPU","text":"<p>Add infiltration forcing to the model implicitly on the GPU. Adds infiltration forcing to the model based on infiltration data and current water depth, updating water depth and surface elevation. </p><pre><code>template&lt;class T&gt;\n__global__ void AddinfiltrationImplicitGPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    T * il,\n    T * cl,\n    EvolvingP &lt; T &gt; XEv,\n    T * hgw\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop structure containing time information </li> <li><code>XBlock</code> Block data structure </li> <li><code>il</code> Initial infiltration rates array </li> <li><code>cl</code> Continuous infiltration rates array </li> <li><code>XEv</code> Evolving data structure </li> <li><code>hgw</code> Groundwater height array </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-addinfiltrationimplicitgpu-double","title":"function AddinfiltrationImplicitGPU&lt; double &gt;","text":"<pre><code>template __global__ void AddinfiltrationImplicitGPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    double * il,\n    double * cl,\n    EvolvingP &lt; double &gt; XEv,\n    double * hgw\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addinfiltrationimplicitgpu-float","title":"function AddinfiltrationImplicitGPU&lt; float &gt;","text":"<pre><code>template __global__ void AddinfiltrationImplicitGPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    float * il,\n    float * cl,\n    EvolvingP &lt; float &gt; XEv,\n    float * hgw\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addrainforcingcpu","title":"function AddrainforcingCPU","text":"<p>Add rainfall forcing to the model on the CPU. Adds rainfall forcing to the model based on rainfall data and current simulation time. </p><pre><code>template&lt;class T&gt;\n__host__ void AddrainforcingCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Rain</code> Rainfall dynamic forcing structure </li> <li><code>XAdv</code> Advance data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-addrainforcingcpu-double","title":"function AddrainforcingCPU&lt; double &gt;","text":"<pre><code>template __host__ void AddrainforcingCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    AdvanceP &lt; double &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addrainforcingcpu-float","title":"function AddrainforcingCPU&lt; float &gt;","text":"<pre><code>template __host__ void AddrainforcingCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    AdvanceP &lt; float &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addrainforcinggpu","title":"function AddrainforcingGPU","text":"<p>Add rainfall forcing to the model on the GPU. Adds rainfall forcing to the model based on rainfall data and current simulation time. </p><pre><code>template&lt;class T&gt;\n__global__ void AddrainforcingGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Rain</code> Rainfall dynamic forcing structure </li> <li><code>XAdv</code> Advance data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-addrainforcinggpu-double","title":"function AddrainforcingGPU&lt; double &gt;","text":"<pre><code>template __global__ void AddrainforcingGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    AdvanceP &lt; double &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addrainforcinggpu-float","title":"function AddrainforcingGPU&lt; float &gt;","text":"<pre><code>template __global__ void AddrainforcingGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    AdvanceP &lt; float &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addrainforcingimplicitcpu","title":"function AddrainforcingImplicitCPU","text":"<p>Add rainfall forcing to the model implicitly on the CPU. Adds rainfall forcing to the model based on rainfall data and current simulation time, updating water depth and surface elevation. </p><pre><code>template&lt;class T&gt;\n__host__ void AddrainforcingImplicitCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    EvolvingP &lt; T &gt; XEv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop structure containing time information </li> <li><code>XBlock</code> Block data structure </li> <li><code>Rain</code> Rainfall dynamic forcing structure </li> <li><code>XEv</code> Evolving data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-addrainforcingimplicitcpu-double","title":"function AddrainforcingImplicitCPU&lt; double &gt;","text":"<pre><code>template __host__ void AddrainforcingImplicitCPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    EvolvingP &lt; double &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addrainforcingimplicitcpu-float","title":"function AddrainforcingImplicitCPU&lt; float &gt;","text":"<pre><code>template __host__ void AddrainforcingImplicitCPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    EvolvingP &lt; float &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addrainforcingimplicitgpu","title":"function AddrainforcingImplicitGPU","text":"<p>Add rainfall forcing to the model implicitly on the GPU. Adds rainfall forcing to the model based on rainfall data and current simulation time, updating water depth and surface elevation. </p><pre><code>template&lt;class T&gt;\n__global__ void AddrainforcingImplicitGPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    EvolvingP &lt; T &gt; XEv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop structure containing time information </li> <li><code>XBlock</code> Block data structure </li> <li><code>Rain</code> Rainfall dynamic forcing structure </li> <li><code>XEv</code> Evolving data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-addrainforcingimplicitgpu-double","title":"function AddrainforcingImplicitGPU&lt; double &gt;","text":"<pre><code>template __global__ void AddrainforcingImplicitGPU&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    EvolvingP &lt; double &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addrainforcingimplicitgpu-float","title":"function AddrainforcingImplicitGPU&lt; float &gt;","text":"<pre><code>template __global__ void AddrainforcingImplicitGPU&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    EvolvingP &lt; float &gt; XEv\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addwindforcingcpu","title":"function AddwindforcingCPU","text":"<p>Add wind forcing to the model on the CPU. Adds wind forcing to the model based on wind data and current simulation time. </p><pre><code>template&lt;class T&gt;\n__host__ void AddwindforcingCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Uwind,\n    DynForcingP &lt; float &gt; Vwind,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Uwind</code> U-component of wind dynamic forcing structure </li> <li><code>Vwind</code> V-component of wind dynamic forcing structure </li> <li><code>XAdv</code> Advance data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-addwindforcingcpu-double","title":"function AddwindforcingCPU&lt; double &gt;","text":"<pre><code>template __host__ void AddwindforcingCPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; Uwind,\n    DynForcingP &lt; float &gt; Vwind,\n    AdvanceP &lt; double &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addwindforcingcpu-float","title":"function AddwindforcingCPU&lt; float &gt;","text":"<pre><code>template __host__ void AddwindforcingCPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; Uwind,\n    DynForcingP &lt; float &gt; Vwind,\n    AdvanceP &lt; float &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addwindforcinggpu","title":"function AddwindforcingGPU","text":"<p>Add wind forcing to the model on the GPU. Adds wind forcing to the model based on wind data and current simulation time. </p><pre><code>template&lt;class T&gt;\n__global__ void AddwindforcingGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Uwind,\n    DynForcingP &lt; float &gt; Vwind,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Uwind</code> U-component of wind dynamic forcing structure </li> <li><code>Vwind</code> V-component of wind dynamic forcing structure </li> <li><code>XAdv</code> Advance data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-addwindforcinggpu-double","title":"function AddwindforcingGPU&lt; double &gt;","text":"<pre><code>template __global__ void AddwindforcingGPU&lt; double &gt; (\n    Param XParam,\n    BlockP &lt; double &gt; XBlock,\n    DynForcingP &lt; float &gt; Uwind,\n    DynForcingP &lt; float &gt; Vwind,\n    AdvanceP &lt; double &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-addwindforcinggpu-float","title":"function AddwindforcingGPU&lt; float &gt;","text":"<pre><code>template __global__ void AddwindforcingGPU&lt; float &gt; (\n    Param XParam,\n    BlockP &lt; float &gt; XBlock,\n    DynForcingP &lt; float &gt; Uwind,\n    DynForcingP &lt; float &gt; Vwind,\n    AdvanceP &lt; float &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-forcingthisstep","title":"function Forcingthisstep","text":"<p>Update dynamic forcing for the current simulation step. </p><pre><code>void Forcingthisstep (\n    Param XParam,\n    double totaltime,\n    DynForcingP &lt; float &gt; &amp; XDynForcing\n) \n</code></pre> <p>Updates the dynamic forcing data for the current simulation time step, handling uniform and non-uniform cases.</p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>totaltime</code> Current simulation time </li> <li><code>XDynForcing</code> Dynamic forcing structure to update </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-injectmanyriversgpu","title":"function InjectManyRiversGPU","text":"<p>Inject multiple river discharges into the model grid on the GPU. Injects river discharges into the model grid based on river geometry and discharge rates. Optimisation by processing multiple rivers in a single kernel launch. </p><pre><code>template&lt;class T&gt;\n__global__ void InjectManyRiversGPU (\n    Param XParam,\n    int irib,\n    RiverInfo &lt; T &gt; XRin,\n    BlockP &lt; T &gt; XBlock,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>irib</code> Index of the river being processed </li> <li><code>XRin</code> River information structure </li> <li><code>XBlock</code> Block data structure </li> <li><code>XAdv</code> Advance data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-injectrivercpu","title":"function InjectRiverCPU","text":"<p>Inject river discharge into the model grid on the CPU. Injects river discharge into the model grid based on river geometry and discharge rate. </p><pre><code>template&lt;class T&gt;\n__host__ void InjectRiverCPU (\n    Param XParam,\n    River XRiver,\n    T qnow,\n    int nblkriver,\n    int * Riverblks,\n    BlockP &lt; T &gt; XBlock,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XRiver</code> River data structure </li> <li><code>qnow</code> Current river discharge rate </li> <li><code>Riverblks</code> Array of blocks affected by the river </li> <li><code>XBlock</code> Block data structure </li> <li><code>XAdv</code> Advance data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-injectrivercpu-double","title":"function InjectRiverCPU&lt; double &gt;","text":"<pre><code>template __host__ void InjectRiverCPU&lt; double &gt; (\n    Param XParam,\n    River XRiver,\n    double qnow,\n    int nblkriver,\n    int * Riverblks,\n    BlockP &lt; double &gt; XBlock,\n    AdvanceP &lt; double &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-injectrivercpu-float","title":"function InjectRiverCPU&lt; float &gt;","text":"<pre><code>template __host__ void InjectRiverCPU&lt; float &gt; (\n    Param XParam,\n    River XRiver,\n    float qnow,\n    int nblkriver,\n    int * Riverblks,\n    BlockP &lt; float &gt; XBlock,\n    AdvanceP &lt; float &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-injectrivergpu","title":"function InjectRiverGPU","text":"<p>Inject river discharge into the model grid on the GPU. Injects river discharge into the model grid based on river geometry and discharge rate. </p><pre><code>template&lt;class T&gt;\n__global__ void InjectRiverGPU (\n    Param XParam,\n    River XRiver,\n    T qnow,\n    int * Riverblks,\n    BlockP &lt; T &gt; XBlock,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XRiver</code> River data structure </li> <li><code>qnow</code> Current river discharge rate </li> <li><code>Riverblks</code> Array of blocks affected by the river </li> <li><code>XBlock</code> Block data structure </li> <li><code>XAdv</code> Advance data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-injectrivergpu-double","title":"function InjectRiverGPU&lt; double &gt;","text":"<pre><code>template __global__ void InjectRiverGPU&lt; double &gt; (\n    Param XParam,\n    River XRiver,\n    double qnow,\n    int * Riverblks,\n    BlockP &lt; double &gt; XBlock,\n    AdvanceP &lt; double &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-injectrivergpu-float","title":"function InjectRiverGPU&lt; float &gt;","text":"<pre><code>template __global__ void InjectRiverGPU&lt; float &gt; (\n    Param XParam,\n    River XRiver,\n    float qnow,\n    int * Riverblks,\n    BlockP &lt; float &gt; XBlock,\n    AdvanceP &lt; float &gt; XAdv\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-deformstep","title":"function deformstep","text":"<p>Perform a deformation step on the model. Applies deformation maps to the model based on the current simulation time and deformation parameters. Overloaded function to handle both CPU and GPU models. </p><pre><code>template&lt;class T&gt;\nvoid deformstep (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    std::vector&lt; deformmap &lt; float &gt;&gt; deform,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop structure containing time information </li> <li><code>deform</code> Vector of deformation maps </li> <li><code>XModel</code> Model data structure </li> <li><code>XModel_g</code> Model data structure for GPU </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-deformstep_1","title":"function deformstep","text":"<p>Perform a deformation step on the model. Applies deformation maps to the model based on the current simulation time and deformation parameters. </p><pre><code>template&lt;class T&gt;\nvoid deformstep (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    std::vector&lt; deformmap &lt; float &gt;&gt; deform,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop structure containing time information </li> <li><code>deform</code> Vector of deformation maps </li> <li><code>XModel</code> Model data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-deformstep-double","title":"function deformstep&lt; double &gt;","text":"<pre><code>template void deformstep&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    std::vector&lt; deformmap &lt; float &gt;&gt; deform,\n    Model &lt; double &gt; XModel,\n    Model &lt; double &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-deformstep-float","title":"function deformstep&lt; float &gt;","text":"<pre><code>template void deformstep&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    std::vector&lt; deformmap &lt; float &gt;&gt; deform,\n    Model &lt; float &gt; XModel,\n    Model &lt; float &gt; XModel_g\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-interp2buq","title":"function interp2BUQ","text":"<p>Interpolate data at given coordinates on the GPU. Interpolates data at specified coordinates using bilinear interpolation. </p><pre><code>template&lt;class T&gt;\n__device__ T interp2BUQ (\n    T x,\n    T y,\n    TexSetP Forcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>x</code> X-coordinate </li> <li><code>y</code> Y-coordinate </li> <li>Forcing Dynamic forcing data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-interp2buq-double","title":"function interp2BUQ&lt; double &gt;","text":"<pre><code>template __device__ double interp2BUQ&lt; double &gt; (\n    double x,\n    double y,\n    TexSetP Forcing\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-interp2buq-float","title":"function interp2BUQ&lt; float &gt;","text":"<pre><code>template __device__ float interp2BUQ&lt; float &gt; (\n    float x,\n    float y,\n    TexSetP Forcing\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-interpdyn2buq","title":"function interpDyn2BUQ","text":"<p>Interpolate dynamic forcing data at given coordinates on the GPU. Interpolates dynamic forcing data at specified coordinates using bilinear interpolation. </p><pre><code>template&lt;class T&gt;\n__device__ T interpDyn2BUQ (\n    T x,\n    T y,\n    TexSetP Forcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>x</code> X-coordinate </li> <li><code>y</code> Y-coordinate </li> <li>Forcing Dynamic forcing data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-interpdyn2buq-double","title":"function interpDyn2BUQ&lt; double &gt;","text":"<pre><code>template __device__ double interpDyn2BUQ&lt; double &gt; (\n    double x,\n    double y,\n    TexSetP Forcing\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-interpdyn2buq-float","title":"function interpDyn2BUQ&lt; float &gt;","text":"<pre><code>template __device__ float interpDyn2BUQ&lt; float &gt; (\n    float x,\n    float y,\n    TexSetP Forcing\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-updateforcing","title":"function updateforcing","text":"<p>Update dynamic forcings for the current simulation step. Updates the dynamic forcing data for the current simulation time step. </p><pre><code>template&lt;class T&gt;\nvoid updateforcing (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop structure containing time information </li> <li><code>XForcing</code> Forcing data structure to update </li> </ul>"},{"location":"BGFlood/_updateforcing_8cu/#function-updateforcing-double","title":"function updateforcing&lt; double &gt;","text":"<pre><code>template void updateforcing&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre>"},{"location":"BGFlood/_updateforcing_8cu/#function-updateforcing-float","title":"function updateforcing&lt; float &gt;","text":"<pre><code>template void updateforcing&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Updateforcing.cu</code></p>"},{"location":"BGFlood/_updateforcing_8cu_source/","title":"File Updateforcing.cu","text":""},{"location":"BGFlood/_updateforcing_8cu_source/#file-updateforcingcu","title":"File Updateforcing.cu","text":"<p>File List &gt; src &gt; Updateforcing.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Updateforcing.h\"\n\ntemplate &lt;class T&gt; void updateforcing(Param XParam, Loop&lt;T&gt; XLoop, Forcing&lt;float&gt; &amp;XForcing)\n{\n    // Update forcing for all possible dynamic forcing. \n    //if a file is declared that implies that the dynamic forcing is applicable\n    if (!XForcing.Rain.inputfile.empty())\n    {\n        Forcingthisstep(XParam, double(XLoop.totaltime), XForcing.Rain);\n    }\n    if (!XForcing.Atmp.inputfile.empty())\n    {\n        Forcingthisstep(XParam, double(XLoop.totaltime), XForcing.Atmp);\n    }\n    if (!XForcing.UWind.inputfile.empty())//&amp;&amp; !XForcing.UWind.inputfile.empty()\n    {\n        Forcingthisstep(XParam, double(XLoop.totaltime), XForcing.UWind);\n        Forcingthisstep(XParam, double(XLoop.totaltime), XForcing.VWind);\n    }\n    for (int iseg = 0; iseg &lt; XForcing.bndseg.size(); iseg++)\n    {\n        if (XForcing.bndseg[iseg].on &amp;&amp; !XForcing.bndseg[iseg].uniform)\n        {\n            Forcingthisstep(XParam, double(XLoop.totaltime), XForcing.bndseg[iseg].WLmap);\n        }\n    }\n\n\n}\ntemplate void updateforcing&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, Forcing&lt;float&gt;&amp; XForcing);\ntemplate void updateforcing&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, Forcing&lt;float&gt;&amp; XForcing);\n\n\n\n\nvoid Forcingthisstep(Param XParam, double totaltime, DynForcingP&lt;float&gt; &amp;XDynForcing)\n{\n    dim3 blockDimDF(16, 16, 1);\n    dim3 gridDimDF((int)ceil((float)XDynForcing.nx / (float)blockDimDF.x), (int)ceil((float)XDynForcing.ny / (float)blockDimDF.y), 1);\n\n\n\n    if (XDynForcing.uniform == 1)\n    {\n        //\n        int Rstepinbnd = 1;\n\n        // Do this for all the corners\n        //Needs limiter in case WLbnd is empty\n        double difft = XDynForcing.unidata[Rstepinbnd].time - totaltime;\n\n        while (difft &lt; 0.0)\n        {\n            Rstepinbnd++;\n            difft = XDynForcing.unidata[Rstepinbnd].time - totaltime;\n        }\n\n        XDynForcing.nowvalue =interptime(XDynForcing.unidata[Rstepinbnd].wspeed, XDynForcing.unidata[Rstepinbnd - 1].wspeed, XDynForcing.unidata[Rstepinbnd].time - XDynForcing.unidata[Rstepinbnd - 1].time, totaltime - XDynForcing.unidata[Rstepinbnd - 1].time);\n\n\n\n    }\n    else\n    {\n        int readfirststep = std::min(std::max((int)floor((totaltime - XDynForcing.to) / XDynForcing.dt), 0), XDynForcing.nt - 2);\n\n        if (readfirststep + 1 &gt; XDynForcing.instep)\n        {\n            // Need to read a new step from the file\n\n            // First copy the forward (aft) step to become the previous step\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                CUDA_CHECK(cudaMemcpy(XDynForcing.before_g, XDynForcing.after_g, XDynForcing.nx * XDynForcing.ny * sizeof(float), cudaMemcpyDeviceToDevice));\n            }\n            else\n            {\n                Copy2CartCPU(XDynForcing.nx, XDynForcing.ny, XDynForcing.before, XDynForcing.after);\n            }\n\n\n            //NextHDstep &lt;&lt;&lt;gridDimRain, blockDimRain, 0 &gt;&gt;&gt; (XParam.Rainongrid.nx, XParam.Rainongrid.ny, Rainbef_g, Rainaft_g);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n\n            // Read the actual file data\n\n            readvardata(XDynForcing.inputfile, XDynForcing.varname, readfirststep + 1, XDynForcing.after, XDynForcing.flipxx, XDynForcing.flipyy);\n            if (XParam.GPUDEVICE &gt;= 0)\n            {\n                CUDA_CHECK(cudaMemcpy(XDynForcing.after_g, XDynForcing.after, XDynForcing.nx * XDynForcing.ny * sizeof(float), cudaMemcpyHostToDevice));\n            }\n\n            XDynForcing.instep = readfirststep + 1;\n        }\n\n        // Interpolate the forcing array to this time \n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            float bftime = float(XDynForcing.to+XDynForcing.dt*(XDynForcing.instep-1));\n            float aftime = float(XDynForcing.to + XDynForcing.dt * (XDynForcing.instep));\n            InterpstepGPU &lt;&lt;&lt;gridDimDF, blockDimDF, 0 &gt;&gt;&gt; (XDynForcing.nx, XDynForcing.ny, float(totaltime), bftime,aftime, XDynForcing.now_g, XDynForcing.before_g, XDynForcing.after_g);\n            CUDA_CHECK(cudaDeviceSynchronize());\n\n            CUDA_CHECK(cudaMemcpyToArray(XDynForcing.GPU.CudArr, 0, 0, XDynForcing.now_g, XDynForcing.nx * XDynForcing.ny * sizeof(float), cudaMemcpyDeviceToDevice));\n        }\n        else\n        {\n            InterpstepCPU(XDynForcing.nx, XDynForcing.ny, XDynForcing.instep - 1, totaltime, XDynForcing.dt, XDynForcing.val, XDynForcing.before, XDynForcing.after);\n        }\n        //InterpstepCPU(XParam.windU.nx, XParam.windU.ny, readfirststep, XParam.totaltime, XParam.windU.dt, Uwind, Uwbef, Uwaft);\n        //InterpstepCPU(XParam.windV.nx, XParam.windV.ny, readfirststep, XParam.totaltime, XParam.windV.dt, Vwind, Vwbef, Vwaft);\n\n\n\n    }\n\n    //return rainuni;\n}\n\ntemplate &lt;class T&gt; __host__ void AddRiverForcing(Param XParam, Loop&lt;T&gt; XLoop, std::vector&lt;River&gt; XRivers, Model&lt;T&gt; XModel)\n{\n    dim3 gridDimRiver(XModel.bndblk.Riverinfo.nburmax, 1, 1);\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n    T qnow;\n    for (int Rin = 0; Rin &lt; XRivers.size(); Rin++)\n    {\n        //\n        int bndstep = 0;\n        double difft = XRivers[Rin].flowinput[bndstep].time - XLoop.totaltime;\n        while (difft &lt;= 0.0) // danger?\n        {\n            bndstep++;\n            difft = XRivers[Rin].flowinput[bndstep].time - XLoop.totaltime;\n        }\n\n        qnow = T(interptime(XRivers[Rin].flowinput[bndstep].q, XRivers[Rin].flowinput[max(bndstep - 1, 0)].q, XRivers[Rin].flowinput[bndstep].time - XRivers[Rin].flowinput[max(bndstep - 1, 0)].time, XLoop.totaltime - XRivers[Rin].flowinput[max(bndstep - 1, 0)].time));\n\n        XModel.bndblk.Riverinfo.qnow[Rin] = qnow / XRivers[Rin].disarea;\n\n    }\n\n    if (XParam.GPUDEVICE &gt;= 0)\n    {\n        for (int irib = 0; irib &lt; XModel.bndblk.Riverinfo.nribmax; irib++)\n        {\n            //InjectRiverGPU &lt;&lt;&lt;gridDimRiver, blockDim, 0 &gt;&gt;&gt; (XParam, XRivers[Rin], qnow, XModel.bndblk.river, XModel.blocks, XModel.adv);\n            //CUDA_CHECK(cudaDeviceSynchronize());\n            InjectManyRiversGPU &lt;&lt;&lt;gridDimRiver, blockDim, 0 &gt;&gt;&gt; (XParam, irib, XModel.bndblk.Riverinfo, XModel.blocks, XModel.adv);\n            CUDA_CHECK(cudaDeviceSynchronize());\n        }\n\n    }\n    else\n    {\n        for (int Rin = 0; Rin &lt; XRivers.size(); Rin++)\n        {\n            InjectRiverCPU(XParam, XRivers[Rin], T(XModel.bndblk.Riverinfo.qnow[Rin]), XModel.bndblk.nblkriver, XModel.bndblk.river, XModel.blocks, XModel.adv);\n        }\n    }\n\n}\ntemplate __host__ void AddRiverForcing&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, std::vector&lt;River&gt; XRivers, Model&lt;float&gt; XModel);\ntemplate __host__ void AddRiverForcing&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, std::vector&lt;River&gt; XRivers, Model&lt;double&gt; XModel);\n\ntemplate &lt;class T&gt; __global__ void InjectRiverGPU(Param XParam,River XRiver, T qnow, int* Riverblks, BlockP&lt;T&gt; XBlock, AdvanceP&lt;T&gt; XAdv)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = Riverblks[ibl];\n\n\n\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n    T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n    T xl, yb, xr, yt, xllo, yllo;\n    xllo = XParam.xo + XBlock.xo[ib];\n    yllo = XParam.yo + XBlock.yo[ib];\n\n    xl = xllo + ix * delta - 0.5 * delta;\n    yb = yllo + iy * delta - 0.5 * delta;\n\n    xr = xllo + ix * delta + 0.5 * delta;\n    yt = yllo + iy * delta + 0.5 * delta;\n    // the conditions are that the discharge area as defined by the user have to include at least a model grid node\n    // This could be really annoying and there should be a better way to deal wiith this like polygon intersection\n    //if (xx &gt;= XForcing.rivers[Rin].xstart &amp;&amp; xx &lt;= XForcing.rivers[Rin].xend &amp;&amp; yy &gt;= XForcing.rivers[Rin].ystart &amp;&amp; yy &lt;= XForcing.rivers[Rin].yend)\n    if (OBBdetect(xl, xr, yb, yt, T(XRiver.xstart), T(XRiver.xend), T(XRiver.ystart), T(XRiver.yend)))\n    {\n\n        XAdv.dh[i] += qnow  / XRiver.disarea;\n\n    }\n\n\n\n}\ntemplate __global__ void InjectRiverGPU&lt;float&gt;(Param XParam, River XRiver, float qnow, int* Riverblks, BlockP&lt;float&gt; XBlock, AdvanceP&lt;float&gt; XAdv);\ntemplate __global__ void InjectRiverGPU&lt;double&gt;(Param XParam, River XRiver, double qnow, int* Riverblks, BlockP&lt;double&gt; XBlock, AdvanceP&lt;double&gt; XAdv);\n\ntemplate &lt;class T&gt; __global__ void InjectManyRiversGPU(Param XParam,int irib, RiverInfo&lt;T&gt; XRin, BlockP&lt;T&gt; XBlock, AdvanceP&lt;T&gt; XAdv)\n{\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = blockDim.x + halowidth * 2;\n\n    int ix = threadIdx.x;\n    int iy = threadIdx.y;\n    int ibl = blockIdx.x;\n\n    int indx = ibl + irib * XRin.nburmax;\n\n    int ib,rid,i;\n\n    T xllo, yllo, xl, yb, xr, yt, levdx;\n    T rxst, ryst, rxnd, rynd;\n\n    ib = XRin.Xbidir[indx];\n    if (ib &gt; -1)\n    {\n\n        i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n        rid = XRin.Xridib[indx];\n\n        levdx = calcres(T(XParam.dx), XBlock.level[ib]);\n\n        xllo = T(XParam.xo + XBlock.xo[ib]);\n        yllo = T(XParam.yo + XBlock.yo[ib]);\n\n\n        xl = xllo + ix * levdx - T(0.5) * levdx;\n        yb = yllo + iy * levdx - T(0.5) * levdx;\n\n        xr = xllo + ix * levdx + T(0.5) * levdx;\n        yt = yllo + iy * levdx + T(0.5) * levdx;\n\n        rxst = XRin.xstart[indx];\n        ryst = XRin.ystart[indx];\n        rxnd = XRin.xend[indx];\n        rynd = XRin.yend[indx];\n\n\n        T qnow = XRin.qnow_g[rid]; // here we use qnow_g because qnow is a CPU pointer\n        if (OBBdetect(xl, xr, yb, yt, rxst, rxnd, ryst, rynd))\n        {\n            XAdv.dh[i] += qnow; //was / T(XRiver.disarea) but this is done upstream now to be consistent with GPU Many river ops \n\n        }\n\n\n    }\n\n}\n\ntemplate &lt;class T&gt; __host__ void InjectRiverCPU(Param XParam, River XRiver, T qnow, int nblkriver, int* Riverblks, BlockP&lt;T&gt; XBlock, AdvanceP&lt;T&gt; XAdv)\n{\n    unsigned int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    T xllo, yllo, xl, yb, xr, yt, levdx;\n\n    for (int ibl = 0; ibl &lt; nblkriver; ibl++)\n    {\n        ib = Riverblks[ibl];\n\n        levdx = calcres(T(XParam.dx), XBlock.level[ib]);\n\n        xllo = T(XParam.xo + XBlock.xo[ib]);\n        yllo = T(XParam.yo + XBlock.yo[ib]);\n\n\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                //T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n                //T x = XParam.xo + XBlock.xo[ib] + ix * delta;\n                //T y = XParam.yo + XBlock.yo[ib] + iy * delta;\n\n                //if (x &gt;= XRiver.xstart &amp;&amp; x &lt;= XRiver.xend &amp;&amp; y &gt;= XRiver.ystart &amp;&amp; y &lt;= XRiver.yend)\n                xl = xllo + ix * levdx - T(0.5) * levdx;\n                yb = yllo + iy * levdx - T(0.5) * levdx;\n\n                xr = xllo + ix * levdx + T(0.5) * levdx;\n                yt = yllo + iy * levdx + T(0.5) * levdx;\n                // the conditions are that the discharge area as defined by the user have to include at least a model grid node\n                // This could be really annoying and there should be a better way to deal wiith this like polygon intersection\n                //if (xx &gt;= XForcing.rivers[Rin].xstart &amp;&amp; xx &lt;= XForcing.rivers[Rin].xend &amp;&amp; yy &gt;= XForcing.rivers[Rin].ystart &amp;&amp; yy &lt;= XForcing.rivers[Rin].yend)\n                if (OBBdetect(xl, xr, yb, yt, T(XRiver.xstart),T(XRiver.xend), T(XRiver.ystart), T(XRiver.yend)))\n                {\n                    XAdv.dh[i] += qnow ; //was / T(XRiver.disarea) but this is done upstream now to be consistent with GPU Many river ops \n\n                }\n            }\n        }\n    }\n\n\n}\ntemplate __host__ void InjectRiverCPU&lt;float&gt;(Param XParam, River XRiver, float qnow, int nblkriver, int* Riverblks, BlockP&lt;float&gt; XBlock, AdvanceP&lt;float&gt; XAdv);\ntemplate __host__ void InjectRiverCPU&lt;double&gt;(Param XParam, River XRiver, double qnow, int nblkriver, int* Riverblks, BlockP&lt;double&gt; XBlock, AdvanceP&lt;double&gt; XAdv);\n\ntemplate &lt;class T&gt; __global__ void AddrainforcingGPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Rain, AdvanceP&lt;T&gt; XAdv)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n    T Rainhh;\n\n    T x = XParam.xo + XBlock.xo[ib] + ix * delta;\n    T y = XParam.yo + XBlock.yo[ib] + iy * delta;\n    if (Rain.uniform)\n    {\n        Rainhh = Rain.nowvalue;\n    }\n    else\n    {\n        Rainhh = T(interpDyn2BUQ(x, y, Rain.GPU));\n    }\n\n\n    Rainhh = Rainhh / T(1000.0) / T(3600.0); // convert from mm/hrs to m/s\n\n    XAdv.dh[i] += Rainhh * XBlock.activeCell[i];\n}\ntemplate __global__ void AddrainforcingGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; Rain, AdvanceP&lt;float&gt; XAdv);\ntemplate __global__ void AddrainforcingGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; Rain, AdvanceP&lt;double&gt; XAdv);\n\ntemplate &lt;class T&gt; __global__ void AddrainforcingImplicitGPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Rain, EvolvingP&lt;T&gt; XEv)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n    T Rainhh;\n\n    T hi = XEv.h[i];\n\n    T x = XParam.xo + XBlock.xo[ib] + ix * delta;\n    T y = XParam.yo + XBlock.yo[ib] + iy * delta;\n    if (Rain.uniform)\n    {\n        Rainhh = Rain.nowvalue;\n    }\n    else\n    {\n        Rainhh = T(interpDyn2BUQ(x, y, Rain.GPU));\n    }\n\n\n    Rainhh = max(Rainhh / T(1000.0) / T(3600.0) * T(XLoop.dt), T(0.0)) * XBlock.activeCell[i]; // convert from mm/hrs to m/s and \n    //printf(\"%f\\n\", Rainhh);\n    T qvol = hi / (hi + Rainhh);\n\n    XEv.h[i] = hi + Rainhh;\n    XEv.zs[i] += Rainhh;\n    if (hi &gt; XParam.eps)\n    {\n        //XEv.u[i] = XEv.u[i] * qvol;\n        //XEv.v[i] = XEv.v[i] * qvol;\n    }\n}\ntemplate __global__ void AddrainforcingImplicitGPU&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; Rain, EvolvingP&lt;float&gt; XEv);\ntemplate __global__ void AddrainforcingImplicitGPU&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; Rain, EvolvingP&lt;double&gt; XEv);\n\ntemplate &lt;class T&gt; __host__ void AddrainforcingCPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Rain, AdvanceP&lt;T&gt; XAdv)\n{\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n                T Rainhh;\n\n                T x = T(XParam.xo) + XBlock.xo[ib] + ix * delta;\n                T y = T(XParam.yo) + XBlock.yo[ib] + iy * delta;\n\n                if (Rain.uniform)\n                {\n                    Rainhh = T(Rain.nowvalue);\n                }\n                else\n                {\n                    Rainhh = interp2BUQ(x, y, Rain);\n                }\n\n\n\n\n                Rainhh = Rainhh / T(1000.0) / T(3600.0); // convert from mm/hrs to m/s\n\n\n\n                XAdv.dh[i] += Rainhh * XBlock.activeCell[i];\n            }\n        }\n    }\n}\ntemplate __host__ void AddrainforcingCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; Rain, AdvanceP&lt;float&gt; XAdv);\ntemplate __host__ void AddrainforcingCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; Rain, AdvanceP&lt;double&gt; XAdv);\n\ntemplate &lt;class T&gt; __host__ void AddrainforcingImplicitCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Rain, EvolvingP&lt;T&gt; XEv)\n{\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n                T hi = XEv.h[i];\n\n                T Rainhh;\n\n                T x = T(XParam.xo) + XBlock.xo[ib] + ix * delta;\n                T y = T(XParam.yo) + XBlock.yo[ib] + iy * delta;\n\n                if (Rain.uniform)\n                {\n                    Rainhh = T(Rain.nowvalue);\n                }\n                else\n                {\n                    Rainhh = interp2BUQ(x, y, Rain);\n                }\n\n\n                Rainhh = max(Rainhh / T(1000.0) / T(3600.0) * T(XLoop.dt), T(0.0)) * XBlock.activeCell[i]; // convert from mm/hrs to m/s and \n\n                T qvol = hi/(hi + Rainhh);\n\n                XEv.h[i] = hi + Rainhh;\n                XEv.zs[i] += Rainhh;\n\n                if (hi &gt; XParam.eps)\n                {\n                    XEv.u[i] = XEv.u[i] * qvol;\n                    XEv.v[i] = XEv.v[i] * qvol;\n                }\n            }\n        }\n    }\n}\ntemplate __host__ void AddrainforcingImplicitCPU&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; Rain, EvolvingP&lt;float&gt; XEv);\ntemplate __host__ void AddrainforcingImplicitCPU&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; Rain, EvolvingP&lt;double&gt; XEv);\n\ntemplate &lt;class T&gt; __host__ void AddinfiltrationImplicitCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, T* il, T* cl, EvolvingP&lt;T&gt; XEv, T* hgw)\n{\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n    int p = 0;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                T waterOut = XEv.h[i];\n                T infiltrationLoc = 0.0;\n                T availinitialinfiltration;\n\n                if (waterOut &gt; 0)\n                {\n                    //Computation of the initial loss\n                    availinitialinfiltration = il[i] / T(1000.0) - hgw[i];\n                    infiltrationLoc = min(waterOut, availinitialinfiltration);\n                    waterOut -= infiltrationLoc;\n\n                    //Computation of the continuous loss\n                    T continuousloss = cl[i] / T(1000.0) / T(3600.0) * T(XLoop.dt); //convert from mm/hs to m/s\n                    infiltrationLoc += min(continuousloss, waterOut);\n\n                    hgw[i] += infiltrationLoc;\n\n                }\n\n                XEv.h[i] -= max(infiltrationLoc * XBlock.activeCell[i],T(0.0));\n                XEv.zs[i] -= max(infiltrationLoc * XBlock.activeCell[i],T(0.0));\n            }\n        }\n    }\n}\ntemplate __host__ void AddinfiltrationImplicitCPU&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, float* il, float* cl, EvolvingP&lt;float&gt; XEv, float* hgw);\ntemplate __host__ void AddinfiltrationImplicitCPU&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, double* il, double* cl, EvolvingP&lt;double&gt; XEv, double* hgw);\n\ntemplate &lt;class T&gt; __global__ void AddinfiltrationImplicitGPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, T* il, T* cl, EvolvingP&lt;T&gt; XEv, T* hgw)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    T waterOut = XEv.h[i];\n    T infiltrationLoc = 0.0;\n    T availinitialinfiltration;\n\n    if (waterOut &gt; 0)\n    {\n        //Computation of the initial loss\n        availinitialinfiltration = max(il[i] / T(1000.0) - hgw[i],T(0.0));\n        infiltrationLoc = min(waterOut, availinitialinfiltration);\n        waterOut -= infiltrationLoc;\n\n        //Computation of the continuous loss\n        T continuousloss = cl[i] / T(1000.0) / T(3600.0) * T(XLoop.dt); //convert from mm/hs to m\n        infiltrationLoc += min(continuousloss, waterOut);\n    }\n\n    hgw[i] += infiltrationLoc;\n\n    XEv.h[i] -= infiltrationLoc * XBlock.activeCell[i];\n    XEv.zs[i] -= infiltrationLoc * XBlock.activeCell[i];\n\n}\ntemplate __global__ void AddinfiltrationImplicitGPU&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, BlockP&lt;float&gt; XBlock, float* il, float* cl, EvolvingP&lt;float&gt; XEv, float* hgw);\ntemplate __global__ void AddinfiltrationImplicitGPU&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, BlockP&lt;double&gt; XBlock, double* il, double* cl, EvolvingP&lt;double&gt; XEv, double* hgw);\n\n\ntemplate &lt;class T&gt; __global__ void AddwindforcingGPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Uwind, DynForcingP&lt;float&gt; Vwind, AdvanceP&lt;T&gt; XAdv)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n    T uwindi, vwindi;\n\n    T x = XParam.xo + XBlock.xo[ib] + ix * delta;\n    T y = XParam.yo + XBlock.yo[ib] + iy * delta;\n\n    T rhoairrhowater = T(0.00121951); // density ratio rho(air)/rho(water) \n\n    if (Uwind.uniform)\n    {\n        uwindi = T(Uwind.nowvalue);\n    }\n    else\n    {\n        uwindi = interpDyn2BUQ(x, y, Uwind.GPU);\n    }\n    if (Vwind.uniform)\n    {\n        vwindi = T(Vwind.nowvalue);\n    }\n    else\n    {\n        vwindi = interpDyn2BUQ(x, y, Vwind.GPU);\n    }\n\n    XAdv.dhu[i] += rhoairrhowater * T(XParam.Cd) * uwindi * abs(uwindi);\n    XAdv.dhv[i] += rhoairrhowater * T(XParam.Cd) * vwindi * abs(vwindi);\n\n    //Rainhh = Rainhh / T(1000.0) / T(3600.0); // convert from mm/hrs to m/s\n\n    //XAdv.dh[i] += Rainhh;\n}\ntemplate __global__ void AddwindforcingGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; Uwind, DynForcingP&lt;float&gt; Vwind, AdvanceP&lt;float&gt; XAdv);\ntemplate __global__ void AddwindforcingGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; Uwind, DynForcingP&lt;float&gt; Vwind, AdvanceP&lt;double&gt; XAdv);\n\ntemplate &lt;class T&gt; __global__ void AddPatmforcingGPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; PAtm, Model&lt;T&gt; XModel)\n{\n    unsigned int halowidth = XParam.halowidth;\n    unsigned int blkmemwidth = blockDim.x + halowidth * 2;\n    //unsigned int blksize = blkmemwidth * blkmemwidth;\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n\n    int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n    T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n    T atmpi;\n\n    T x = XParam.xo + XBlock.xo[ib] + ix * delta;\n    T y = XParam.yo + XBlock.yo[ib] + iy * delta;\n\n\n\n    atmpi = interpDyn2BUQ(x, y, PAtm.GPU);\n\n\n    XModel.Patm[i] = atmpi - XParam.Paref;\n\n}\ntemplate __global__ void AddPatmforcingGPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; PAtm, Model&lt;float&gt; XModel);\ntemplate __global__ void AddPatmforcingGPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; PAtm, Model&lt;double&gt; XModel);\n\ntemplate &lt;class T&gt; __host__ void AddwindforcingCPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Uwind, DynForcingP&lt;float&gt; Vwind, AdvanceP&lt;T&gt; XAdv)\n{\n    //\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n                T uwindi, vwindi;\n\n                T x = T(XParam.xo) + XBlock.xo[ib] + ix * delta;\n                T y = T(XParam.yo) + XBlock.yo[ib] + iy * delta;\n\n                T rhoairrhowater = T(0.00121951); // density ratio rho(air)/rho(water) \n                if (Uwind.uniform)\n                {\n                    uwindi = T(Uwind.nowvalue);\n                }\n                else\n                {\n                    uwindi = interp2BUQ(x, y, Uwind);\n                }\n                if (Vwind.uniform)\n                {\n                    vwindi = T(Vwind.nowvalue);\n                }\n                else\n                {\n                    vwindi = interp2BUQ(x, y, Vwind);\n                }\n\n                XAdv.dhu[i] += rhoairrhowater * T(XParam.Cd) * uwindi * abs(uwindi);\n                XAdv.dhv[i] += rhoairrhowater * T(XParam.Cd) * vwindi * abs(vwindi);\n\n            }\n        }\n    }\n}\ntemplate __host__ void AddwindforcingCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; Uwind, DynForcingP&lt;float&gt; Vwind, AdvanceP&lt;float&gt; XAdv);\ntemplate __host__ void AddwindforcingCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; Uwind, DynForcingP&lt;float&gt; Vwind, AdvanceP&lt;double&gt; XAdv);\n\n\ntemplate &lt;class T&gt; __host__ void AddPatmforcingCPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; PAtm, Model&lt;T&gt; XModel)\n{\n    //\n    int ib;\n    int halowidth = XParam.halowidth;\n    int blkmemwidth = XParam.blkmemwidth;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n\n                int i = memloc(halowidth, blkmemwidth, ix, iy, ib);\n\n                T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n                T atmpi;\n\n                T x = XParam.xo + XBlock.xo[ib] + ix * delta;\n                T y = XParam.yo + XBlock.yo[ib] + iy * delta;\n\n\n                if (PAtm.uniform)\n                {\n                    atmpi = T(PAtm.nowvalue);\n                }\n                else\n                {\n                    atmpi = interp2BUQ(x, y, PAtm);\n                }\n\n\n                XModel.Patm[i] = atmpi;\n\n\n            }\n        }\n    }\n}\ntemplate __host__ void AddPatmforcingCPU&lt;float&gt;(Param XParam, BlockP&lt;float&gt; XBlock, DynForcingP&lt;float&gt; PAtm, Model&lt;float&gt; XModel);\ntemplate __host__ void AddPatmforcingCPU&lt;double&gt;(Param XParam, BlockP&lt;double&gt; XBlock, DynForcingP&lt;float&gt; PAtm, Model&lt;double&gt; XModel);\n\n\n\ntemplate &lt;class T&gt; __device__ T interpDyn2BUQ(T x, T y, TexSetP Forcing)\n{\n    T read;\n    if (Forcing.uniform)\n    {\n        read = T(Forcing.nowvalue);\n    }\n    else\n    {\n        read = interp2BUQ(x, y, Forcing);\n    }\n    return read;\n}\ntemplate __device__ float interpDyn2BUQ&lt;float&gt;(float x, float y, TexSetP Forcing);\ntemplate __device__ double interpDyn2BUQ&lt;double&gt;(double x, double y, TexSetP Forcing);\n\ntemplate &lt;class T&gt; __device__ T interp2BUQ(T x, T y, TexSetP Forcing)\n{\n    T read;\n\n    float ivw = float((x - T(Forcing.xo)) / T(Forcing.dx) + T(0.5));\n    float jvw = float((y - T(Forcing.yo)) / T(Forcing.dy) + T(0.5));\n    read = tex2D&lt;float&gt;(Forcing.tex, ivw, jvw);\n\n    return read;\n}\ntemplate __device__ float interp2BUQ&lt;float&gt;(float x, float y, TexSetP Forcing);\ntemplate __device__ double interp2BUQ&lt;double&gt;(double x, double y, TexSetP Forcing);\n\ntemplate &lt;class T&gt; void deformstep(Param XParam, Loop&lt;T&gt; XLoop, std::vector&lt;deformmap&lt;float&gt;&gt; deform, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g)\n{\n    if (XParam.GPUDEVICE &lt; 0)\n    {\n        deformstep(XParam, XLoop, deform, XModel);\n        InitzbgradientCPU(XParam, XModel); // need to recalculate the zb halo and gradients to avoid blow up in topographic terms\n    }\n    else\n    {\n        deformstep(XParam, XLoop, deform, XModel_g);\n        InitzbgradientGPU(XParam, XModel_g);\n    }\n}\ntemplate void deformstep&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, std::vector&lt;deformmap&lt;float&gt;&gt; deform, Model&lt;float&gt; XModel, Model&lt;float&gt; XModel_g);\ntemplate void deformstep&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, std::vector&lt;deformmap&lt;float&gt;&gt; deform, Model&lt;double&gt; XModel, Model&lt;double&gt; XModel_g);\n\ntemplate &lt;class T&gt; void deformstep(Param XParam, Loop&lt;T&gt; XLoop, std::vector&lt;deformmap&lt;float&gt;&gt; deform, Model&lt;T&gt; XModel)\n{\n    dim3 gridDim(XParam.nblk, 1, 1);\n    dim3 blockDim(XParam.blkwidth, XParam.blkwidth, 1);\n\n    bool updatezbhalo = false;\n\n    for (int nd = 0; nd &lt; deform.size(); nd++)\n    {\n        // if deformation happend in the last computational step\n        if (((deform[nd].startime + deform[nd].duration) &gt;= (XLoop.totaltime - XLoop.dt)) &amp;&amp; (deform[nd].startime &lt; XLoop.totaltime))\n        {\n\n            updatezbhalo = true;\n\n            T dtdef = min(XLoop.dt, XLoop.totaltime - deform[nd].startime);\n            if (XLoop.totaltime &gt; deform[nd].startime + deform[nd].duration)\n            {\n                dtdef = (T)min(XLoop.dt, XLoop.totaltime - (deform[nd].startime + deform[nd].duration));\n            }\n\n\n            T scale = (deform[nd].duration &gt; 0.0) ? T(1.0 / deform[nd].duration * dtdef) : T(1.0);\n\n            //log(\"Applying deform: \" + std::to_string(scale));\n\n            if (XParam.GPUDEVICE &lt; 0)\n            {\n                AddDeformCPU(XParam, XModel.blocks, deform[nd], XModel.evolv, scale, XModel.zb);\n            }\n            else\n            {\n                AddDeformGPU &lt;&lt;&lt;gridDim, blockDim, 0 &gt;&gt;&gt; (XParam, XModel.blocks, deform[nd], XModel.evolv, scale, XModel.zb);\n                CUDA_CHECK(cudaDeviceSynchronize());\n            }\n\n\n        }\n\n    }\n    //Redo the halo if needed\n    if (updatezbhalo)\n    {\n\n        if (XParam.GPUDEVICE &gt;= 0)\n        {\n            CUDA_CHECK(cudaStreamCreate(&amp;XLoop.streams[0]));\n            fillHaloGPU(XParam, XModel.blocks, XLoop.streams[0], XModel.zb);\n\n            cudaStreamDestroy(XLoop.streams[0]);\n        }\n        else\n        {\n            fillHaloC(XParam, XModel.blocks, XModel.zb);\n        }\n    }\n\n\n}\n\ntemplate &lt;class T&gt; __global__ void AddDeformGPU(Param XParam, BlockP&lt;T&gt; XBlock, deformmap&lt;float&gt; defmap, EvolvingP&lt;T&gt; XEv, T scale, T* zb)\n{\n    unsigned int ix = threadIdx.x;\n    unsigned int iy = threadIdx.y;\n    unsigned int ibl = blockIdx.x;\n    unsigned int ib = XBlock.active[ibl];\n    int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n\n    T zss, zbb;\n    T def;\n    T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n    T x = XParam.xo + XBlock.xo[ib] + ix * delta;\n    T y = XParam.yo + XBlock.yo[ib] + iy * delta;\n\n    def= interpDyn2BUQ(x, y, defmap.GPU);\n\n    //if (x &gt; 42000 &amp;&amp; x &lt; 43000 &amp;&amp; y&gt;7719000 &amp;&amp; y &lt; 7721000)\n    //{\n    //  printf(\"x=%f, y=%f, def=%f\\n \", x, y, def);\n    //}\n\n    zss = XEv.zs[i] + def * scale;\n    if (defmap.iscavity == true)\n    {\n        zbb = min(zss, zb[i]);\n    }\n    else\n    {\n        zbb = zb[i] + def * scale;\n    }\n\n    XEv.h[i] = zss - zbb;\n    XEv.zs[i] = zss;\n    zb[i] = zbb;\n\n    //zs[i] = zs[i] + def * scale;\n    //zb[i] = zb[i] + def * scale;\n\n\n\n}\n\ntemplate &lt;class T&gt; __host__ void AddDeformCPU(Param XParam, BlockP&lt;T&gt; XBlock, deformmap&lt;float&gt; defmap, EvolvingP&lt;T&gt; XEv, T scale, T* zb)\n{\n    int ib;\n\n    T zbb,zss;\n\n    T def;\n\n    for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    {\n        ib = XBlock.active[ibl];\n\n        for (int iy = 0; iy &lt; XParam.blkwidth; iy++)\n        {\n            for (int ix = 0; ix &lt; XParam.blkwidth; ix++)\n            {\n                int i = memloc(XParam.halowidth, XParam.blkmemwidth, ix, iy, ib);\n                T delta = calcres(T(XParam.dx), XBlock.level[ib]);\n\n\n                T x = T(XParam.xo) + XBlock.xo[ib] + ix * delta;\n                T y = T(XParam.yo) + XBlock.yo[ib] + iy * delta;\n\n                def = interp2BUQ(x, y, defmap);\n\n                zss = XEv.zs[i] + def * scale;\n                if (defmap.iscavity == true)\n                {\n                    zbb = min(zss, zb[i]);\n                }\n                else\n                {\n                    zbb = zb[i] + def * scale;\n                }\n\n                XEv.zs[i] = zss;\n                XEv.h[i] = zss - zbb;\n                zb[i] = zbb;\n            }\n        }\n    }\n\n}\n</code></pre>"},{"location":"BGFlood/_updateforcing_8h/","title":"File Updateforcing.h","text":""},{"location":"BGFlood/_updateforcing_8h/#file-updateforcingh","title":"File Updateforcing.h","text":"<p>FileList &gt; src &gt; Updateforcing.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> <li><code>#include \"Forcing.h\"</code></li> <li><code>#include \"InitialConditions.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"ReadForcing.h\"</code></li> <li><code>#include \"GridManip.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> </ul>"},{"location":"BGFlood/_updateforcing_8h/#public-functions","title":"Public Functions","text":"Type Name __global__ void AddDeformGPU (Param XParam, BlockP&lt; T &gt; XBlock, deformmap&lt; float &gt; defmap, EvolvingP&lt; T &gt; XEv, T scale, T * zb) Perform a deformation step on the model on the GPU. Applies deformation maps to the model based on the current simulation time and deformation parameters. __host__ void AddPatmforcingCPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; PAtm, Model&lt; T &gt; XModel) Add atmospheric pressure forcing to the model on the CPU. Adds atmospheric pressure forcing to the model based on pressure data and current simulation time. __global__ void AddPatmforcingGPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; PAtm, Model&lt; T &gt; XModel) Add atmospheric pressure forcing to the model on the GPU. Adds atmospheric pressure forcing to the model based on pressure data and current simulation time. __host__ void AddRiverForcing (Param XParam, Loop&lt; T &gt; XLoop, std::vector&lt; River &gt; XRivers, Model&lt; T &gt; XModel) Add river forcing to the model. Adds river discharge forcing to the model based on river data and current simulation time. __host__ void AddinfiltrationImplicitCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, T * il, T * cl, EvolvingP&lt; T &gt; XEv, T * hgw) Add infiltration forcing to the model implicitly on the CPU. Adds infiltration forcing to the model based on infiltration data and current water depth, updating water depth and surface elevation. __global__ void AddinfiltrationImplicitGPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, T * il, T * cl, EvolvingP&lt; T &gt; XEv, T * hgw) Add infiltration forcing to the model implicitly on the GPU. Adds infiltration forcing to the model based on infiltration data and current water depth, updating water depth and surface elevation. __host__ void AddrainforcingCPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Rain, AdvanceP&lt; T &gt; XAdv) Add rainfall forcing to the model on the CPU. Adds rainfall forcing to the model based on rainfall data and current simulation time. __global__ void AddrainforcingGPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Rain, AdvanceP&lt; T &gt; XAdv) Add rainfall forcing to the model on the GPU. Adds rainfall forcing to the model based on rainfall data and current simulation time. __host__ void AddrainforcingImplicitCPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Rain, EvolvingP&lt; T &gt; XEv) Add rainfall forcing to the model implicitly on the CPU. Adds rainfall forcing to the model based on rainfall data and current simulation time, updating water depth and surface elevation. __global__ void AddrainforcingImplicitGPU (Param XParam, Loop&lt; T &gt; XLoop, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Rain, EvolvingP&lt; T &gt; XEv) Add rainfall forcing to the model implicitly on the GPU. Adds rainfall forcing to the model based on rainfall data and current simulation time, updating water depth and surface elevation. __host__ void AddwindforcingCPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Uwind, DynForcingP&lt; float &gt; Vwind, AdvanceP&lt; T &gt; XAdv) Add wind forcing to the model on the CPU. Adds wind forcing to the model based on wind data and current simulation time. __global__ void AddwindforcingGPU (Param XParam, BlockP&lt; T &gt; XBlock, DynForcingP&lt; float &gt; Uwind, DynForcingP&lt; float &gt; Vwind, AdvanceP&lt; T &gt; XAdv) Add wind forcing to the model on the GPU. Adds wind forcing to the model based on wind data and current simulation time. void Forcingthisstep (Param XParam, double totaltime, DynForcingP&lt; float &gt; &amp; XDynForcing) Update dynamic forcing for the current simulation step. __global__ void InjectRiverGPU (Param XParam, River XRiver, T qnow, int * Riverblks, BlockP&lt; T &gt; XBlock, AdvanceP&lt; T &gt; XAdv) Inject river discharge into the model grid on the GPU. Injects river discharge into the model grid based on river geometry and discharge rate. void deformstep (Param XParam, Loop&lt; T &gt; XLoop, std::vector&lt; deformmap&lt; float &gt;&gt; deform, Model&lt; T &gt; XModel, Model&lt; T &gt; XModel_g) Perform a deformation step on the model. Applies deformation maps to the model based on the current simulation time and deformation parameters. Overloaded function to handle both CPU and GPU models. __device__ T interpDyn2BUQ (T x, T y, TexSetP Forcing) Interpolate dynamic forcing data at given coordinates on the GPU. Interpolates dynamic forcing data at specified coordinates using bilinear interpolation. void updateforcing (Param XParam, Loop&lt; T &gt; XLoop, Forcing&lt; float &gt; &amp; XForcing) Update dynamic forcings for the current simulation step. Updates the dynamic forcing data for the current simulation time step."},{"location":"BGFlood/_updateforcing_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_updateforcing_8h/#function-adddeformgpu","title":"function AddDeformGPU","text":"<p>Perform a deformation step on the model on the GPU. Applies deformation maps to the model based on the current simulation time and deformation parameters. </p><pre><code>template&lt;class T&gt;\n__global__ void AddDeformGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    deformmap &lt; float &gt; defmap,\n    EvolvingP &lt; T &gt; XEv,\n    T scale,\n    T * zb\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop structure containing time information </li> <li><code>deform</code> Vector of deformation maps </li> <li><code>XModel</code> Model data structure for GPU </li> </ul>"},{"location":"BGFlood/_updateforcing_8h/#function-addpatmforcingcpu","title":"function AddPatmforcingCPU","text":"<p>Add atmospheric pressure forcing to the model on the CPU. Adds atmospheric pressure forcing to the model based on pressure data and current simulation time. </p><pre><code>template&lt;class T&gt;\n__host__ void AddPatmforcingCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; PAtm,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>PAtm</code> Atmospheric pressure dynamic forcing structure </li> <li><code>XModel</code> Model data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8h/#function-addpatmforcinggpu","title":"function AddPatmforcingGPU","text":"<p>Add atmospheric pressure forcing to the model on the GPU. Adds atmospheric pressure forcing to the model based on pressure data and current simulation time. </p><pre><code>template&lt;class T&gt;\n__global__ void AddPatmforcingGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; PAtm,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>PAtm</code> Atmospheric pressure dynamic forcing structure </li> <li><code>XModel</code> Model data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8h/#function-addriverforcing","title":"function AddRiverForcing","text":"<p>Add river forcing to the model. Adds river discharge forcing to the model based on river data and current simulation time. </p><pre><code>template&lt;class T&gt;\n__host__ void AddRiverForcing (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    std::vector&lt; River &gt; XRivers,\n    Model &lt; T &gt; XModel\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop structure containing time information </li> <li><code>XRivers</code> Vector of river data structures </li> <li><code>XModel</code> Model data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8h/#function-addinfiltrationimplicitcpu","title":"function AddinfiltrationImplicitCPU","text":"<p>Add infiltration forcing to the model implicitly on the CPU. Adds infiltration forcing to the model based on infiltration data and current water depth, updating water depth and surface elevation. </p><pre><code>template&lt;class T&gt;\n__host__ void AddinfiltrationImplicitCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    T * il,\n    T * cl,\n    EvolvingP &lt; T &gt; XEv,\n    T * hgw\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop structure containing time information </li> <li><code>XBlock</code> Block data structure </li> <li><code>il</code> Initial infiltration rates array </li> <li><code>cl</code> Continuous infiltration rates array </li> <li><code>XEv</code> Evolving data structure </li> <li><code>hgw</code> Groundwater height array </li> </ul>"},{"location":"BGFlood/_updateforcing_8h/#function-addinfiltrationimplicitgpu","title":"function AddinfiltrationImplicitGPU","text":"<p>Add infiltration forcing to the model implicitly on the GPU. Adds infiltration forcing to the model based on infiltration data and current water depth, updating water depth and surface elevation. </p><pre><code>template&lt;class T&gt;\n__global__ void AddinfiltrationImplicitGPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    T * il,\n    T * cl,\n    EvolvingP &lt; T &gt; XEv,\n    T * hgw\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop structure containing time information </li> <li><code>XBlock</code> Block data structure </li> <li><code>il</code> Initial infiltration rates array </li> <li><code>cl</code> Continuous infiltration rates array </li> <li><code>XEv</code> Evolving data structure </li> <li><code>hgw</code> Groundwater height array </li> </ul>"},{"location":"BGFlood/_updateforcing_8h/#function-addrainforcingcpu","title":"function AddrainforcingCPU","text":"<p>Add rainfall forcing to the model on the CPU. Adds rainfall forcing to the model based on rainfall data and current simulation time. </p><pre><code>template&lt;class T&gt;\n__host__ void AddrainforcingCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Rain</code> Rainfall dynamic forcing structure </li> <li><code>XAdv</code> Advance data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8h/#function-addrainforcinggpu","title":"function AddrainforcingGPU","text":"<p>Add rainfall forcing to the model on the GPU. Adds rainfall forcing to the model based on rainfall data and current simulation time. </p><pre><code>template&lt;class T&gt;\n__global__ void AddrainforcingGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Rain</code> Rainfall dynamic forcing structure </li> <li><code>XAdv</code> Advance data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8h/#function-addrainforcingimplicitcpu","title":"function AddrainforcingImplicitCPU","text":"<p>Add rainfall forcing to the model implicitly on the CPU. Adds rainfall forcing to the model based on rainfall data and current simulation time, updating water depth and surface elevation. </p><pre><code>template&lt;class T&gt;\n__host__ void AddrainforcingImplicitCPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    EvolvingP &lt; T &gt; XEv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop structure containing time information </li> <li><code>XBlock</code> Block data structure </li> <li><code>Rain</code> Rainfall dynamic forcing structure </li> <li><code>XEv</code> Evolving data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8h/#function-addrainforcingimplicitgpu","title":"function AddrainforcingImplicitGPU","text":"<p>Add rainfall forcing to the model implicitly on the GPU. Adds rainfall forcing to the model based on rainfall data and current simulation time, updating water depth and surface elevation. </p><pre><code>template&lt;class T&gt;\n__global__ void AddrainforcingImplicitGPU (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Rain,\n    EvolvingP &lt; T &gt; XEv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop structure containing time information </li> <li><code>XBlock</code> Block data structure </li> <li><code>Rain</code> Rainfall dynamic forcing structure </li> <li><code>XEv</code> Evolving data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8h/#function-addwindforcingcpu","title":"function AddwindforcingCPU","text":"<p>Add wind forcing to the model on the CPU. Adds wind forcing to the model based on wind data and current simulation time. </p><pre><code>template&lt;class T&gt;\n__host__ void AddwindforcingCPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Uwind,\n    DynForcingP &lt; float &gt; Vwind,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Uwind</code> U-component of wind dynamic forcing structure </li> <li><code>Vwind</code> V-component of wind dynamic forcing structure </li> <li><code>XAdv</code> Advance data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8h/#function-addwindforcinggpu","title":"function AddwindforcingGPU","text":"<p>Add wind forcing to the model on the GPU. Adds wind forcing to the model based on wind data and current simulation time. </p><pre><code>template&lt;class T&gt;\n__global__ void AddwindforcingGPU (\n    Param XParam,\n    BlockP &lt; T &gt; XBlock,\n    DynForcingP &lt; float &gt; Uwind,\n    DynForcingP &lt; float &gt; Vwind,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XBlock</code> Block data structure </li> <li><code>Uwind</code> U-component of wind dynamic forcing structure </li> <li><code>Vwind</code> V-component of wind dynamic forcing structure </li> <li><code>XAdv</code> Advance data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8h/#function-forcingthisstep","title":"function Forcingthisstep","text":"<p>Update dynamic forcing for the current simulation step. </p><pre><code>void Forcingthisstep (\n    Param XParam,\n    double totaltime,\n    DynForcingP &lt; float &gt; &amp; XDynForcing\n) \n</code></pre> <p>Updates the dynamic forcing data for the current simulation time step, handling uniform and non-uniform cases.</p> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>totaltime</code> Current simulation time </li> <li><code>XDynForcing</code> Dynamic forcing structure to update </li> </ul>"},{"location":"BGFlood/_updateforcing_8h/#function-injectrivergpu","title":"function InjectRiverGPU","text":"<p>Inject river discharge into the model grid on the GPU. Injects river discharge into the model grid based on river geometry and discharge rate. </p><pre><code>template&lt;class T&gt;\n__global__ void InjectRiverGPU (\n    Param XParam,\n    River XRiver,\n    T qnow,\n    int * Riverblks,\n    BlockP &lt; T &gt; XBlock,\n    AdvanceP &lt; T &gt; XAdv\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XRiver</code> River data structure </li> <li><code>qnow</code> Current river discharge rate </li> <li><code>Riverblks</code> Array of blocks affected by the river </li> <li><code>XBlock</code> Block data structure </li> <li><code>XAdv</code> Advance data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8h/#function-deformstep","title":"function deformstep","text":"<p>Perform a deformation step on the model. Applies deformation maps to the model based on the current simulation time and deformation parameters. Overloaded function to handle both CPU and GPU models. </p><pre><code>template&lt;class T&gt;\nvoid deformstep (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    std::vector&lt; deformmap &lt; float &gt;&gt; deform,\n    Model &lt; T &gt; XModel,\n    Model &lt; T &gt; XModel_g\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop structure containing time information </li> <li><code>deform</code> Vector of deformation maps </li> <li><code>XModel</code> Model data structure </li> <li><code>XModel_g</code> Model data structure for GPU </li> </ul>"},{"location":"BGFlood/_updateforcing_8h/#function-interpdyn2buq","title":"function interpDyn2BUQ","text":"<p>Interpolate dynamic forcing data at given coordinates on the GPU. Interpolates dynamic forcing data at specified coordinates using bilinear interpolation. </p><pre><code>template&lt;class T&gt;\n__device__ T interpDyn2BUQ (\n    T x,\n    T y,\n    TexSetP Forcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>x</code> X-coordinate </li> <li><code>y</code> Y-coordinate </li> <li>Forcing Dynamic forcing data structure </li> </ul>"},{"location":"BGFlood/_updateforcing_8h/#function-updateforcing","title":"function updateforcing","text":"<p>Update dynamic forcings for the current simulation step. Updates the dynamic forcing data for the current simulation time step. </p><pre><code>template&lt;class T&gt;\nvoid updateforcing (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Forcing &lt; float &gt; &amp; XForcing\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> Model parameters </li> <li><code>XLoop</code> Loop structure containing time information </li> <li><code>XForcing</code> Forcing data structure to update </li> </ul> <p>The documentation for this class was generated from the following file <code>src/Updateforcing.h</code></p>"},{"location":"BGFlood/_updateforcing_8h_source/","title":"File Updateforcing.h","text":""},{"location":"BGFlood/_updateforcing_8h_source/#file-updateforcingh","title":"File Updateforcing.h","text":"<p>File List &gt; src &gt; Updateforcing.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef UPDATEFORCING_H\n#define UPDATEFORCING_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Arrays.h\"\n#include \"Forcing.h\"\n#include \"InitialConditions.h\"\n#include \"MemManagement.h\"\n#include \"ReadForcing.h\"\n#include \"GridManip.h\"\n#include \"Util_CPU.h\"\n\ntemplate &lt;class T&gt; void updateforcing(Param XParam, Loop&lt;T&gt; XLoop, Forcing&lt;float&gt;&amp; XForcing);\n\nvoid Forcingthisstep(Param XParam, double totaltime, DynForcingP&lt;float&gt;&amp; XDynForcing);\n\ntemplate &lt;class T&gt; __device__ T interpDyn2BUQ(T x, T y, TexSetP Forcing);\n\ntemplate &lt;class T&gt; __host__ void AddwindforcingCPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Uwind, DynForcingP&lt;float&gt; Vwind, AdvanceP&lt;T&gt; XAdv);\ntemplate &lt;class T&gt; __global__ void AddwindforcingGPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Uwind, DynForcingP&lt;float&gt; Vwind, AdvanceP&lt;T&gt; XAdv);\n\ntemplate &lt;class T&gt; __host__ void AddrainforcingCPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Rain, AdvanceP&lt;T&gt; XAdv);\ntemplate &lt;class T&gt; __host__ void AddrainforcingImplicitCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Rain, EvolvingP&lt;T&gt; XEv);\ntemplate &lt;class T&gt; __global__ void AddrainforcingGPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Rain, AdvanceP&lt;T&gt; XAdv);\ntemplate &lt;class T&gt; __global__ void AddrainforcingImplicitGPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; Rain, EvolvingP&lt;T&gt; XEv);\n\ntemplate &lt;class T&gt; __host__ void  AddinfiltrationImplicitCPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, T* il, T* cl, EvolvingP&lt;T&gt; XEv, T* hgw);\ntemplate &lt;class T&gt; __global__ void AddinfiltrationImplicitGPU(Param XParam, Loop&lt;T&gt; XLoop, BlockP&lt;T&gt; XBlock, T* il, T* cl, EvolvingP&lt;T&gt; XEv, T* hgw);\n\ntemplate &lt;class T&gt; __global__ void AddPatmforcingGPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; PAtm, Model&lt;T&gt; XModel);\ntemplate &lt;class T&gt; __host__ void AddPatmforcingCPU(Param XParam, BlockP&lt;T&gt; XBlock, DynForcingP&lt;float&gt; PAtm, Model&lt;T&gt; XModel);\n\ntemplate &lt;class T&gt; __host__ void AddRiverForcing(Param XParam, Loop&lt;T&gt; XLoop, std::vector&lt;River&gt; XRivers, Model&lt;T&gt; XModel);\n\ntemplate &lt;class T&gt; void deformstep(Param XParam, Loop&lt;T&gt; XLoop, std::vector&lt;deformmap&lt;float&gt;&gt; deform, Model&lt;T&gt; XModel, Model&lt;T&gt; XModel_g);\n\ntemplate &lt;class T&gt; __global__ void InjectRiverGPU(Param XParam, River XRiver, T qnow, int* Riverblks, BlockP&lt;T&gt; XBlock, AdvanceP&lt;T&gt; XAdv);\ntemplate &lt;class T&gt; __global__ void  AddDeformGPU(Param XParam, BlockP&lt;T&gt; XBlock, deformmap&lt;float&gt; defmap, EvolvingP&lt;T&gt; XEv, T scale, T* zb);\n\n\n#endif\n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/","title":"File Util_CPU.cu","text":""},{"location":"BGFlood/_util___c_p_u_8cu/#file-util_cpucu","title":"File Util_CPU.cu","text":"<p>FileList &gt; src &gt; Util_CPU.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Util_CPU.h\"</code></li> </ul>"},{"location":"BGFlood/_util___c_p_u_8cu/#namespaces","title":"Namespaces","text":"Type Name namespace utils"},{"location":"BGFlood/_util___c_p_u_8cu/#public-functions","title":"Public Functions","text":"Type Name T BarycentricInterpolation (T q1, T x1, T y1, T q2, T x2, T y2, T q3, T x3, T y3, T x, T y) Barycentric interpolation within a triangle. Barycentric interpolation within a triangle defined by the vertices (x1, y1), (x2, y2), and (x3, y3). The values at the vertices are q1, q2, and q3. The function returns the interpolated value at the point (x, y). template float BarycentricInterpolation (float q1, float x1, float y1, float q2, float x2, float y2, float q3, float x3, float y3, float x, float y)  template double BarycentricInterpolation (double q1, double x1, double y1, double q2, double x2, double y2, double q3, double x3, double y3, double x, double y)  __host__ __device__ T BilinearInterpolation (T q11, T q12, T q21, T q22, T x1, T x2, T y1, T y2, T x, T y) Bilinear interpolation within a rectangle. Bilinear interpolation within a rectangle defined by (x1, y1) and (x2, y2). The values at the corners of the rectangle are q11, q12, q21, and q22. The function returns the interpolated value at the point (x, y).  __ template __host__ __device__ double BilinearInterpolation&lt; double &gt; (double q11, double q12, double q21, double q22, double x1, double x2, double y1, double y2, double x, double y)  template __host__ __device__ float BilinearInterpolation&lt; float &gt; (float q11, float q12, float q21, float q22, float x1, float x2, float y1, float y2, float x, float y)  __host__ __device__ bool OBBdetect (T Axmin, T Axmax, T Aymin, T Aymax, T Bxmin, T Bxmax, T Bymin, T Bymax) Overlapping Bounding Box detection. Overlapping Bounding Box detection to determine if two axis-aligned bounding boxes overlap. The function takes the minimum and maximum coordinates of two bounding boxes (A and B). It returns true if the bounding boxes overlap, and false otherwise. template __host__ __device__ bool OBBdetect (float Axmin, float Axmax, float Aymin, float Aymax, float Bxmin, float Bxmax, float Bymin, float Bymax)  template __host__ __device__ bool OBBdetect (double Axmin, double Axmax, double Aymin, double Aymax, double Bxmin, double Bxmax, double Bymin, double Bymax)  __host__ __device__ T calcres (T dx, int level) Calculate the grid resolution at a given refinement level. Calculate the grid resolution at a given refinement level. If level is negative, the resolution is coarsened (doubled for each level). If level is positive, the resolution is refined (halved for each level). __host__ __device__ T calcres (Param XParam, T dx, int level) Calculate the grid resolution at a given refinement level, considering spherical coordinates. Calculate the grid resolution at a given refinement level, considering spherical coordinates. If level is negative, the resolution is coarsened (doubled for each level). If level is positive, the resolution is refined (halved for each level). If the grid is spherical, the resolution is adjusted by the Earth's radius and converted from degrees to meters. template __host__ __device__ double calcres&lt; double &gt; (double dx, int level)  template __host__ __device__ double calcres&lt; double &gt; (Param XParam, double dx, int level)  template __host__ __device__ float calcres&lt; float &gt; (float dx, int level)  template __host__ __device__ float calcres&lt; float &gt; (Param XParam, float dx, int level)  int ftoi (T value) Converts a floating-point number to the nearest integer. Converts a floating-point number to the nearest integer. The function rounds the value to the nearest integer, rounding halfway cases away from zero. template int ftoi&lt; double &gt; (double value)  template int ftoi&lt; float &gt; (float value)  double interptime (double next, double prev, double timenext, double time) Linear interpolation between two values. __host__ __device__ T minmod2 (T theta, T s0, T s1, T s2) Minmod limiter function for slope limiting in numerical schemes. Minmod limiter function for slope limiting in numerical schemes. The function takes a parameter theta and three slope values (s0, s1, s2). Theta is used to tune the limiting (theta=1 gives minmod, the most dissipative limiter, and theta=2 gives superbee, the least dissipative). The function returns the limited slope value based on the input slopes and theta. Usual value : float theta = 1.3f;. template __host__ __device__ float minmod2 (float theta, float s0, float s1, float s2)  template __host__ __device__ double minmod2 (double theta, double s0, double s1, double s2)  unsigned int nextPow2 (unsigned int x) Computes the next power of two greater than or equal to x. Computes the next power of two greater than or equal to x. __host__ __device__ T signof (T a) Returns the sign of a number. Returns the sign of a number. template int signof (int a)  template float signof (float a)  template double signof (double a)"},{"location":"BGFlood/_util___c_p_u_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_util___c_p_u_8cu/#function-barycentricinterpolation","title":"function BarycentricInterpolation","text":"<p>Barycentric interpolation within a triangle. Barycentric interpolation within a triangle defined by the vertices (x1, y1), (x2, y2), and (x3, y3). The values at the vertices are q1, q2, and q3. The function returns the interpolated value at the point (x, y). </p><pre><code>template&lt;class T&gt;\nT BarycentricInterpolation (\n    T q1,\n    T x1,\n    T y1,\n    T q2,\n    T x2,\n    T y2,\n    T q3,\n    T x3,\n    T y3,\n    T x,\n    T y\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>q1</code> Value at (x1, y1) </li> <li><code>x1</code> x-coordinate of the first vertex </li> <li><code>y1</code> y-coordinate of the first vertex </li> <li><code>q2</code> Value at (x2, y2) </li> <li><code>x2</code> x-coordinate of the second vertex </li> <li><code>y2</code> y-coordinate of the second vertex </li> <li><code>q3</code> Value at (x3, y3) </li> <li><code>x3</code> x-coordinate of the third vertex </li> <li><code>y3</code> y-coordinate of the third vertex </li> <li><code>x</code> x-coordinate of the point to interpolate </li> <li><code>y</code> y-coordinate of the point to interpolate </li> </ul> <p>Returns:</p> <p>Interpolated value at (x, y) </p>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-barycentricinterpolation_1","title":"function BarycentricInterpolation","text":"<pre><code>template float BarycentricInterpolation (\n    float q1,\n    float x1,\n    float y1,\n    float q2,\n    float x2,\n    float y2,\n    float q3,\n    float x3,\n    float y3,\n    float x,\n    float y\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-barycentricinterpolation_2","title":"function BarycentricInterpolation","text":"<pre><code>template double BarycentricInterpolation (\n    double q1,\n    double x1,\n    double y1,\n    double q2,\n    double x2,\n    double y2,\n    double q3,\n    double x3,\n    double y3,\n    double x,\n    double y\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-bilinearinterpolation","title":"function BilinearInterpolation","text":"<p>Bilinear interpolation within a rectangle. Bilinear interpolation within a rectangle defined by (x1, y1) and (x2, y2). The values at the corners of the rectangle are q11, q12, q21, and q22. The function returns the interpolated value at the point (x, y).  __ </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T BilinearInterpolation (\n    T q11,\n    T q12,\n    T q21,\n    T q22,\n    T x1,\n    T x2,\n    T y1,\n    T y2,\n    T x,\n    T y\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>q11</code> Value at (x1, y1) </li> <li><code>q12</code> Value at (x1, y2) </li> <li><code>q21</code> Value at (x2, y1) </li> <li><code>q22</code> Value at (x2, y2) </li> <li><code>x1</code> x-coordinate of the bottom-left corner </li> <li><code>x2</code> x-coordinate of the top-right corner </li> <li><code>y1</code> y-coordinate of the bottom-left corner </li> <li><code>y2</code> y-coordinate of the top-right corner </li> <li><code>x</code> x-coordinate of the point to interpolate </li> <li><code>y</code> y-coordinate of the point to interpolate </li> </ul>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-bilinearinterpolation-double","title":"function BilinearInterpolation&lt; double &gt;","text":"<pre><code>template __host__ __device__ double BilinearInterpolation&lt; double &gt; (\n    double q11,\n    double q12,\n    double q21,\n    double q22,\n    double x1,\n    double x2,\n    double y1,\n    double y2,\n    double x,\n    double y\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-bilinearinterpolation-float","title":"function BilinearInterpolation&lt; float &gt;","text":"<pre><code>template __host__ __device__ float BilinearInterpolation&lt; float &gt; (\n    float q11,\n    float q12,\n    float q21,\n    float q22,\n    float x1,\n    float x2,\n    float y1,\n    float y2,\n    float x,\n    float y\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-obbdetect","title":"function OBBdetect","text":"<p>Overlapping Bounding Box detection. Overlapping Bounding Box detection to determine if two axis-aligned bounding boxes overlap. The function takes the minimum and maximum coordinates of two bounding boxes (A and B). It returns true if the bounding boxes overlap, and false otherwise. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ bool OBBdetect (\n    T Axmin,\n    T Axmax,\n    T Aymin,\n    T Aymax,\n    T Bxmin,\n    T Bxmax,\n    T Bymin,\n    T Bymax\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>Axmin</code> Minimum x-coordinate of bounding box A. </li> <li><code>Axmax</code> Maximum x-coordinate of bounding box A. </li> <li><code>Aymin</code> Minimum y-coordinate of bounding box A. </li> <li><code>Aymax</code> Maximum y-coordinate of bounding box A. </li> <li><code>Bxmin</code> Minimum x-coordinate of bounding box B. </li> <li><code>Bxmax</code> Maximum x-coordinate of bounding box B. </li> <li><code>Bymin</code> Minimum y-coordinate of bounding box B. </li> <li><code>Bymax</code> Maximum y-coordinate of bounding box B. </li> </ul> <p>Returns:</p> <p>True if the bounding boxes overlap, false otherwise.</p> <p>Overlaping Bounding Box to detect which cell river falls into. It is the simplest version of the algorythm where the bounding box are paralle;l to the axis </p>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-obbdetect_1","title":"function OBBdetect","text":"<pre><code>template __host__ __device__ bool OBBdetect (\n    float Axmin,\n    float Axmax,\n    float Aymin,\n    float Aymax,\n    float Bxmin,\n    float Bxmax,\n    float Bymin,\n    float Bymax\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-obbdetect_2","title":"function OBBdetect","text":"<pre><code>template __host__ __device__ bool OBBdetect (\n    double Axmin,\n    double Axmax,\n    double Aymin,\n    double Aymax,\n    double Bxmin,\n    double Bxmax,\n    double Bymin,\n    double Bymax\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-calcres","title":"function calcres","text":"<p>Calculate the grid resolution at a given refinement level. Calculate the grid resolution at a given refinement level. If level is negative, the resolution is coarsened (doubled for each level). If level is positive, the resolution is refined (halved for each level). </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T calcres (\n    T dx,\n    int level\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>dx</code> The base grid resolution. </li> <li><code>level</code> The refinement level (negative for coarsening, positive for refining). </li> </ul> <p>Returns:</p> <p>The calculated grid resolution at the specified level. </p>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-calcres_1","title":"function calcres","text":"<p>Calculate the grid resolution at a given refinement level, considering spherical coordinates. Calculate the grid resolution at a given refinement level, considering spherical coordinates. If level is negative, the resolution is coarsened (doubled for each level). If level is positive, the resolution is refined (halved for each level). If the grid is spherical, the resolution is adjusted by the Earth's radius and converted from degrees to meters. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T calcres (\n    Param XParam,\n    T dx,\n    int level\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings. </li> <li><code>dx</code> The base grid resolution. </li> <li><code>level</code> The refinement level (negative for coarsening, positive for refining). </li> </ul> <p>Returns:</p> <p>The calculated grid resolution at the specified level, adjusted for spherical coordinates if applicable. </p>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-calcres-double","title":"function calcres&lt; double &gt;","text":"<pre><code>template __host__ __device__ double calcres&lt; double &gt; (\n    double dx,\n    int level\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-calcres-double_1","title":"function calcres&lt; double &gt;","text":"<pre><code>template __host__ __device__ double calcres&lt; double &gt; (\n    Param XParam,\n    double dx,\n    int level\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-calcres-float","title":"function calcres&lt; float &gt;","text":"<pre><code>template __host__ __device__ float calcres&lt; float &gt; (\n    float dx,\n    int level\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-calcres-float_1","title":"function calcres&lt; float &gt;","text":"<pre><code>template __host__ __device__ float calcres&lt; float &gt; (\n    Param XParam,\n    float dx,\n    int level\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-ftoi","title":"function ftoi","text":"<p>Converts a floating-point number to the nearest integer. Converts a floating-point number to the nearest integer. The function rounds the value to the nearest integer, rounding halfway cases away from zero. </p><pre><code>template&lt;class T&gt;\nint ftoi (\n    T value\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code> The floating-point number to convert. </li> </ul> <p>Returns:</p> <p>The nearest integer. </p>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-ftoi-double","title":"function ftoi&lt; double &gt;","text":"<pre><code>template int ftoi&lt; double &gt; (\n    double value\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-ftoi-float","title":"function ftoi&lt; float &gt;","text":"<pre><code>template int ftoi&lt; float &gt; (\n    float value\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-interptime","title":"function interptime","text":"<p>Linear interpolation between two values. </p><pre><code>double interptime (\n    double next,\n    double prev,\n    double timenext,\n    double time\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-minmod2","title":"function minmod2","text":"<p>Minmod limiter function for slope limiting in numerical schemes. Minmod limiter function for slope limiting in numerical schemes. The function takes a parameter theta and three slope values (s0, s1, s2). Theta is used to tune the limiting (theta=1 gives minmod, the most dissipative limiter, and theta=2 gives superbee, the least dissipative). The function returns the limited slope value based on the input slopes and theta. Usual value : float theta = 1.3f;. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T minmod2 (\n    T theta,\n    T s0,\n    T s1,\n    T s2\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>theta</code> The tuning parameter for the limiter (between 1 and 2). </li> <li><code>s0</code> The slope value at the left cell. </li> <li><code>s1</code> The slope value at the center cell. </li> <li><code>s2</code> The slope value at the right cell. </li> </ul> <p>Returns:</p> <p>The limited slope value. </p>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-minmod2_1","title":"function minmod2","text":"<pre><code>template __host__ __device__ float minmod2 (\n    float theta,\n    float s0,\n    float s1,\n    float s2\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-minmod2_2","title":"function minmod2","text":"<pre><code>template __host__ __device__ double minmod2 (\n    double theta,\n    double s0,\n    double s1,\n    double s2\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-nextpow2","title":"function nextPow2","text":"<p>Computes the next power of two greater than or equal to x. Computes the next power of two greater than or equal to x. </p><pre><code>unsigned int nextPow2 (\n    unsigned int x\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-signof","title":"function signof","text":"<p>Returns the sign of a number. Returns the sign of a number. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T signof (\n    T a\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-signof_1","title":"function signof","text":"<pre><code>template int signof (\n    int a\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-signof_2","title":"function signof","text":"<pre><code>template float signof (\n    float a\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8cu/#function-signof_3","title":"function signof","text":"<pre><code>template double signof (\n    double a\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Util_CPU.cu</code></p>"},{"location":"BGFlood/_util___c_p_u_8cu_source/","title":"File Util_CPU.cu","text":""},{"location":"BGFlood/_util___c_p_u_8cu_source/#file-util_cpucu","title":"File Util_CPU.cu","text":"<p>File List &gt; src &gt; Util_CPU.cu</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n// This code contains an adaptation of the St Venant equation from Basilisk     //\n// See                                                                          //\n// http://basilisk.fr/src/saint-venant.h and                                    //\n// S. Popinet. Quadtree-adaptive tsunami modelling. Ocean Dynamics,             //\n// doi: 61(9) : 1261 - 1285, 2011                                               //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //\n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n\n#include \"Util_CPU.h\"\n\n\nnamespace utils {\n    template &lt;class T&gt; __host__ __device__ T sq(T a) {\n        return (a*a);\n    }\n\n    template &lt;class T&gt; __host__ __device__ const T&amp; max(const T&amp; a, const T&amp; b) {\n        return (a&lt;b) ? b : a;     // or: return comp(a,b)?b:a; for version (2)\n    }\n\n    template &lt;class T&gt; __host__ __device__ const T&amp; min(const T&amp; a, const T&amp; b) {\n        return !(b&lt;a) ? a : b;     // or: return comp(a,b)?b:a; for version (2)\n    }\n\n    template &lt;class T&gt; __host__ __device__ const T&amp; nearest(const T&amp; a, const T&amp; b, const T&amp; c) {\n        return abs(b - c) &gt; abs(a - c) ? a : b;     // Nearest element to c\n    }\n    template &lt;class T&gt; __host__ __device__ const T&amp; nearest(const T&amp; a, const T&amp; b) {\n        return abs(b) &gt; abs(a) ? a : b;     // Nearest element to 0.0\n    }\n/*\n    template &lt;class T&gt; __host__ __device__ const T&amp; floor(const T&amp; a) {\n        return abs(b) &gt; abs(a) ? a : b;\n    }\n*/\n\n    template __host__ __device__ const int&amp; min&lt;int&gt;(const int&amp; a, const int&amp; b);\n    template __host__ __device__ const float&amp; min&lt;float&gt;(const float&amp; a, const float&amp; b);\n    template __host__ __device__ const double&amp; min&lt;double&gt;(const double&amp; a, const double&amp; b);\n\n    template __host__ __device__ const int&amp; max&lt;int&gt;(const int&amp; a, const int&amp; b);\n    template __host__ __device__ const float&amp; max&lt;float&gt;(const float&amp; a, const float&amp; b);\n    template __host__ __device__ const double&amp; max&lt;double&gt;(const double&amp; a, const double&amp; b);\n\n    template int __host__ __device__ sq&lt;int&gt;(int a);\n    template float __host__ __device__ sq&lt;float&gt;(float a);\n    template double __host__ __device__ sq&lt;double&gt;(double a);\n\n    template __host__ __device__ const int&amp; nearest&lt;int&gt;(const int&amp; a, const int&amp; b, const int&amp; c);\n    template __host__ __device__ const float&amp; nearest&lt;float&gt;(const float&amp; a, const float&amp; b, const float&amp; c);\n    template __host__ __device__ const double&amp; nearest&lt;double&gt;(const double&amp; a, const double&amp; b, const double&amp; c);\n\n    template __host__ __device__ const int&amp; nearest&lt;int&gt;(const int&amp; a, const int&amp; b);\n    template __host__ __device__ const float&amp; nearest&lt;float&gt;(const float&amp; a, const float&amp; b);\n    template __host__ __device__ const double&amp; nearest&lt;double&gt;(const double&amp; a, const double&amp; b);\n\n}\n\nunsigned int nextPow2(unsigned int x)\n{\n    --x;\n    x |= x &gt;&gt; 1;\n    x |= x &gt;&gt; 2;\n    x |= x &gt;&gt; 4;\n    x |= x &gt;&gt; 8;\n    x |= x &gt;&gt; 16;\n    return ++x;\n}\n\ndouble interptime(double next, double prev, double timenext, double time)\n{\n    return prev + (time) / (timenext)*(next - prev);\n}\n\n\ntemplate &lt;class T&gt; __host__ __device__ T BilinearInterpolation(T q11, T q12, T q21, T q22, T x1, T x2, T y1, T y2, T x, T y)\n{\n    T x2x1, y2y1, x2x, y2y, yy1, xx1;\n    x2x1 = x2 - x1;\n    y2y1 = y2 - y1;\n    x2x = x2 - x;\n    y2y = y2 - y;\n    yy1 = y - y1;\n    xx1 = x - x1;\n    return (T)1.0 / (x2x1 * y2y1) * (\n        q11 * x2x * y2y +\n        q21 * xx1 * y2y +\n        q12 * x2x * yy1 +\n        q22 * xx1 * yy1\n        );\n}\n\ntemplate __host__ __device__ float BilinearInterpolation&lt;float&gt;(float q11, float q12, float q21, float q22, float x1, float x2, float y1, float y2, float x, float y);\ntemplate __host__ __device__ double BilinearInterpolation&lt;double&gt;(double q11, double q12, double q21, double q22, double x1, double x2, double y1, double y2, double x, double y);\n\ntemplate &lt;class T&gt; T BarycentricInterpolation(T q1, T x1, T y1, T q2, T x2, T y2, T q3, T x3, T y3, T x, T y)\n{\n    T w1, w2, w3, D;\n\n    D = (y2 - y3) * (x1 + x3) + (x3 - x2) * (y1 - y3);\n\n    w1 = ((y2 - y3) * (x - x3) + (x3 - x2) * (y - y3)) / D;\n    w2 = ((y3 - y1) * (x - x3) + (x1 - x3) * (y - y3)) / D;\n    w3 = 1 - w1 - w2;\n\n    return q1 * w1 + q2 * w2 + q3 * w3;\n}\n\ntemplate float BarycentricInterpolation(float q1, float x1, float y1, float q2, float x2, float y2, float q3, float x3, float y3, float x, float y);\ntemplate double BarycentricInterpolation(double q1, double x1, double y1, double q2, double x2, double y2, double q3, double x3, double y3, double x, double y);\n\n\ntemplate &lt;class T&gt;\n__host__ __device__ T calcres(T dx, int level)\n{\n    return  level &lt; 0 ? dx * (1 &lt;&lt; abs(level)) : dx / (1 &lt;&lt; level);\n    //should be 1&lt;&lt; -level\n}\ntemplate __host__ __device__ double calcres&lt;double&gt;(double dx, int level);\ntemplate __host__ __device__ float calcres&lt;float&gt;(float dx, int level);\n\ntemplate &lt;class T&gt;\n__host__ __device__ T calcres(Param XParam, T dx, int level)\n{\n    T ddx = calcres(dx, level); // here use dx as the cue for the compiler to use the float or double version of this function\n\n    if (XParam.spherical)\n    {\n        ddx = ddx * T(XParam.Radius * pi / 180.0);\n    }\n\n    return ddx;\n    //should be 1&lt;&lt; -level\n}\ntemplate __host__ __device__ double calcres&lt;double&gt;(Param XParam, double dx, int level);\ntemplate __host__ __device__ float calcres&lt;float&gt;(Param XParam, float dx, int level);\n\ntemplate &lt;class T&gt; __host__ __device__ T minmod2(T theta, T s0, T s1, T s2)\n{\n    //theta should be used as a global var\n    // can be used to tune the limiting (theta=1\n    //gives minmod, the most dissipative limiter and theta = 2 gives\n    //  superbee, the least dissipative).\n    //float theta = 1.3f;\n    if (s0 &lt; s1 &amp;&amp; s1 &lt; s2) {\n        T d1 = theta * (s1 - s0);\n        T d2 = (s2 - s0) / T(2.0);\n        T d3 = theta * (s2 - s1);\n        if (d2 &lt; d1) d1 = d2;\n        return min(d1, d3);\n    }\n    if (s0 &gt; s1 &amp;&amp; s1 &gt; s2) {\n        T d1 = theta * (s1 - s0), d2 = (s2 - s0) / T(2.0), d3 = theta * (s2 - s1);\n        if (d2 &gt; d1) d1 = d2;\n        return max(d1, d3);\n    }\n    return T(0.0);\n}\n\ntemplate __host__ __device__ float minmod2(float theta, float s0, float s1, float s2);\ntemplate __host__ __device__ double minmod2(double theta, double s0, double s1, double s2);\n\ntemplate &lt;class T&gt; __host__  __device__  bool OBBdetect(T Axmin, T Axmax, T Aymin, T Aymax, T Bxmin, T Bxmax, T Bymin, T Bymax)\n{\n    bool overlap = false;\n\n    bool testX = Bxmin &lt;= Axmax &amp;&amp; Bxmax &gt;= Axmin;\n    bool testY = Bymin &lt;= Aymax &amp;&amp; Bymax &gt;= Aymin;\n\n    overlap = testX &amp;&amp; testY;\n\n    return overlap;\n}\n\ntemplate __host__  __device__  bool OBBdetect(float Axmin, float Axmax, float Aymin, float Aymax, float Bxmin, float Bxmax, float Bymin, float Bymax);\ntemplate __host__  __device__  bool OBBdetect(double Axmin, double Axmax, double Aymin, double Aymax, double Bxmin, double Bxmax, double Bymin, double Bymax);\n\ntemplate &lt;class T&gt; int ftoi(T value) {\n    return (value &gt;= 0 ? static_cast&lt;int&gt;(value + 0.5)\n        : static_cast&lt;int&gt;(value - 0.5));\n}\ntemplate int ftoi&lt;float&gt;(float value);\ntemplate int ftoi&lt;double&gt;(double value);\n\ntemplate &lt;class T&gt; __host__ __device__ T signof(T a)\n{\n\n    return a &gt; T(0.0) ? T(1.0) : T(-1.0);\n}\ntemplate int signof(int a);\ntemplate float signof(float a);\ntemplate double signof(double a);\n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8h/","title":"File Util_CPU.h","text":""},{"location":"BGFlood/_util___c_p_u_8h/#file-util_cpuh","title":"File Util_CPU.h","text":"<p>FileList &gt; src &gt; Util_CPU.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> </ul>"},{"location":"BGFlood/_util___c_p_u_8h/#namespaces","title":"Namespaces","text":"Type Name namespace utils"},{"location":"BGFlood/_util___c_p_u_8h/#public-functions","title":"Public Functions","text":"Type Name __host__ __device__ T BarycentricInterpolation (T q1, T x1, T y1, T q2, T x2, T y2, T q3, T x3, T y3, T x, T y) Barycentric interpolation within a triangle. Barycentric interpolation within a triangle defined by the vertices (x1, y1), (x2, y2), and (x3, y3). The values at the vertices are q1, q2, and q3. The function returns the interpolated value at the point (x, y). __host__ __device__ T BilinearInterpolation (T q11, T q12, T q21, T q22, T x1, T x2, T y1, T y2, T x, T y) Bilinear interpolation within a rectangle. Bilinear interpolation within a rectangle defined by (x1, y1) and (x2, y2). The values at the corners of the rectangle are q11, q12, q21, and q22. The function returns the interpolated value at the point (x, y).  __ __host__ __device__ bool OBBdetect (T Axmin, T Axmax, T Aymin, T Aymax, T Bxmin, T Bxmax, T Bymin, T Bymax) Overlapping Bounding Box detection. Overlapping Bounding Box detection to determine if two axis-aligned bounding boxes overlap. The function takes the minimum and maximum coordinates of two bounding boxes (A and B). It returns true if the bounding boxes overlap, and false otherwise. __host__ __device__ T calcres (T dx, int level) Calculate the grid resolution at a given refinement level. Calculate the grid resolution at a given refinement level. If level is negative, the resolution is coarsened (doubled for each level). If level is positive, the resolution is refined (halved for each level). int ftoi (T value) Converts a floating-point number to the nearest integer. Converts a floating-point number to the nearest integer. The function rounds the value to the nearest integer, rounding halfway cases away from zero. double interptime (double next, double prev, double timenext, double time) Linear interpolation between two values. __host__ __device__ T minmod2 (T theta, T s0, T s1, T s2) Minmod limiter function for slope limiting in numerical schemes. Minmod limiter function for slope limiting in numerical schemes. The function takes a parameter theta and three slope values (s0, s1, s2). Theta is used to tune the limiting (theta=1 gives minmod, the most dissipative limiter, and theta=2 gives superbee, the least dissipative). The function returns the limited slope value based on the input slopes and theta. Usual value : float theta = 1.3f;. unsigned int nextPow2 (unsigned int x) Computes the next power of two greater than or equal to x. Computes the next power of two greater than or equal to x. __host__ __device__ T signof (T a) Returns the sign of a number. Returns the sign of a number."},{"location":"BGFlood/_util___c_p_u_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_util___c_p_u_8h/#function-barycentricinterpolation","title":"function BarycentricInterpolation","text":"<p>Barycentric interpolation within a triangle. Barycentric interpolation within a triangle defined by the vertices (x1, y1), (x2, y2), and (x3, y3). The values at the vertices are q1, q2, and q3. The function returns the interpolated value at the point (x, y). </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T BarycentricInterpolation (\n    T q1,\n    T x1,\n    T y1,\n    T q2,\n    T x2,\n    T y2,\n    T q3,\n    T x3,\n    T y3,\n    T x,\n    T y\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>q1</code> Value at (x1, y1) </li> <li><code>x1</code> x-coordinate of the first vertex </li> <li><code>y1</code> y-coordinate of the first vertex </li> <li><code>q2</code> Value at (x2, y2) </li> <li><code>x2</code> x-coordinate of the second vertex </li> <li><code>y2</code> y-coordinate of the second vertex </li> <li><code>q3</code> Value at (x3, y3) </li> <li><code>x3</code> x-coordinate of the third vertex </li> <li><code>y3</code> y-coordinate of the third vertex </li> <li><code>x</code> x-coordinate of the point to interpolate </li> <li><code>y</code> y-coordinate of the point to interpolate </li> </ul> <p>Returns:</p> <p>Interpolated value at (x, y) </p>"},{"location":"BGFlood/_util___c_p_u_8h/#function-bilinearinterpolation","title":"function BilinearInterpolation","text":"<p>Bilinear interpolation within a rectangle. Bilinear interpolation within a rectangle defined by (x1, y1) and (x2, y2). The values at the corners of the rectangle are q11, q12, q21, and q22. The function returns the interpolated value at the point (x, y).  __ </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T BilinearInterpolation (\n    T q11,\n    T q12,\n    T q21,\n    T q22,\n    T x1,\n    T x2,\n    T y1,\n    T y2,\n    T x,\n    T y\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>q11</code> Value at (x1, y1) </li> <li><code>q12</code> Value at (x1, y2) </li> <li><code>q21</code> Value at (x2, y1) </li> <li><code>q22</code> Value at (x2, y2) </li> <li><code>x1</code> x-coordinate of the bottom-left corner </li> <li><code>x2</code> x-coordinate of the top-right corner </li> <li><code>y1</code> y-coordinate of the bottom-left corner </li> <li><code>y2</code> y-coordinate of the top-right corner </li> <li><code>x</code> x-coordinate of the point to interpolate </li> <li><code>y</code> y-coordinate of the point to interpolate </li> </ul>"},{"location":"BGFlood/_util___c_p_u_8h/#function-obbdetect","title":"function OBBdetect","text":"<p>Overlapping Bounding Box detection. Overlapping Bounding Box detection to determine if two axis-aligned bounding boxes overlap. The function takes the minimum and maximum coordinates of two bounding boxes (A and B). It returns true if the bounding boxes overlap, and false otherwise. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ bool OBBdetect (\n    T Axmin,\n    T Axmax,\n    T Aymin,\n    T Aymax,\n    T Bxmin,\n    T Bxmax,\n    T Bymin,\n    T Bymax\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>Axmin</code> Minimum x-coordinate of bounding box A. </li> <li><code>Axmax</code> Maximum x-coordinate of bounding box A. </li> <li><code>Aymin</code> Minimum y-coordinate of bounding box A. </li> <li><code>Aymax</code> Maximum y-coordinate of bounding box A. </li> <li><code>Bxmin</code> Minimum x-coordinate of bounding box B. </li> <li><code>Bxmax</code> Maximum x-coordinate of bounding box B. </li> <li><code>Bymin</code> Minimum y-coordinate of bounding box B. </li> <li><code>Bymax</code> Maximum y-coordinate of bounding box B. </li> </ul> <p>Returns:</p> <p>True if the bounding boxes overlap, false otherwise.</p> <p>Overlaping Bounding Box to detect which cell river falls into. It is the simplest version of the algorythm where the bounding box are paralle;l to the axis </p>"},{"location":"BGFlood/_util___c_p_u_8h/#function-calcres","title":"function calcres","text":"<p>Calculate the grid resolution at a given refinement level. Calculate the grid resolution at a given refinement level. If level is negative, the resolution is coarsened (doubled for each level). If level is positive, the resolution is refined (halved for each level). </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T calcres (\n    T dx,\n    int level\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>dx</code> The base grid resolution. </li> <li><code>level</code> The refinement level (negative for coarsening, positive for refining). </li> </ul> <p>Returns:</p> <p>The calculated grid resolution at the specified level. </p>"},{"location":"BGFlood/_util___c_p_u_8h/#function-ftoi","title":"function ftoi","text":"<p>Converts a floating-point number to the nearest integer. Converts a floating-point number to the nearest integer. The function rounds the value to the nearest integer, rounding halfway cases away from zero. </p><pre><code>template&lt;class T&gt;\nint ftoi (\n    T value\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code> The floating-point number to convert. </li> </ul> <p>Returns:</p> <p>The nearest integer. </p>"},{"location":"BGFlood/_util___c_p_u_8h/#function-interptime","title":"function interptime","text":"<p>Linear interpolation between two values. </p><pre><code>double interptime (\n    double next,\n    double prev,\n    double timenext,\n    double time\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8h/#function-minmod2","title":"function minmod2","text":"<p>Minmod limiter function for slope limiting in numerical schemes. Minmod limiter function for slope limiting in numerical schemes. The function takes a parameter theta and three slope values (s0, s1, s2). Theta is used to tune the limiting (theta=1 gives minmod, the most dissipative limiter, and theta=2 gives superbee, the least dissipative). The function returns the limited slope value based on the input slopes and theta. Usual value : float theta = 1.3f;. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T minmod2 (\n    T theta,\n    T s0,\n    T s1,\n    T s2\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>theta</code> The tuning parameter for the limiter (between 1 and 2). </li> <li><code>s0</code> The slope value at the left cell. </li> <li><code>s1</code> The slope value at the center cell. </li> <li><code>s2</code> The slope value at the right cell. </li> </ul> <p>Returns:</p> <p>The limited slope value. </p>"},{"location":"BGFlood/_util___c_p_u_8h/#function-nextpow2","title":"function nextPow2","text":"<p>Computes the next power of two greater than or equal to x. Computes the next power of two greater than or equal to x. </p><pre><code>unsigned int nextPow2 (\n    unsigned int x\n) \n</code></pre>"},{"location":"BGFlood/_util___c_p_u_8h/#function-signof","title":"function signof","text":"<p>Returns the sign of a number. Returns the sign of a number. </p><pre><code>template&lt;class T&gt;\n__host__ __device__ T signof (\n    T a\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Util_CPU.h</code></p>"},{"location":"BGFlood/_util___c_p_u_8h_source/","title":"File Util_CPU.h","text":""},{"location":"BGFlood/_util___c_p_u_8h_source/#file-util_cpuh","title":"File Util_CPU.h","text":"<p>File List &gt; src &gt; Util_CPU.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef UTILCPU_H\n#define UTILCPU_H\n\n#include \"General.h\"\n#include \"Param.h\"\n\nnamespace utils {\n    template &lt;class T&gt; __host__ __device__ T sq(T a);\n    template &lt;class T&gt; __host__ __device__ const T&amp; max(const T&amp; a, const T&amp; b);\n    template &lt;class T&gt; __host__ __device__ const T&amp; min(const T&amp; a, const T&amp; b);\n    template &lt;class T&gt; __host__ __device__ const T&amp; nearest(const T&amp; a, const T&amp; b, const T&amp; c);\n    template &lt;class T&gt; __host__ __device__ const T&amp; nearest(const T&amp; a, const T&amp; b);\n\n    //template &lt;&gt;\n\n}\n\n\nunsigned int nextPow2(unsigned int x);\n\ndouble interptime(double next, double prev, double timenext, double time);\n\ntemplate &lt;class T&gt;  __host__ __device__ T BilinearInterpolation(T q11, T q12, T q21, T q22, T x1, T x2, T y1, T y2, T x, T y);\ntemplate &lt;class T&gt;  __host__ __device__ T BarycentricInterpolation(T q1, T x1, T y1, T q2, T x2, T y2, T q3, T x3, T y3, T x, T y);\n\ntemplate &lt;class T&gt; __host__ __device__ T calcres(T dx, int level);\ntemplate &lt;class T&gt; __host__ __device__ T minmod2(T theta, T s0, T s1, T s2);\n\ntemplate &lt;class T&gt; __host__  __device__  bool OBBdetect(T Axmin, T Axmax, T Aymin, T Aymax, T Bxmin, T Bxmax, T Bymin, T Bymax);\n\ntemplate &lt;class T&gt; __host__ __device__ T signof(T a);\n\ntemplate &lt;class T&gt; int ftoi(T value);\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_write__netcdf_8cu/","title":"File Write_netcdf.cu","text":""},{"location":"BGFlood/_write__netcdf_8cu/#file-write_netcdfcu","title":"File Write_netcdf.cu","text":"<p>FileList &gt; src &gt; Write_netcdf.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Write_netcdf.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"General.h\"</code></li> </ul>"},{"location":"BGFlood/_write__netcdf_8cu/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; int &gt; Calcactiveblockzone (Param XParam, int * activeblk, outzoneB Xzone) Calculate active blocks in a zone. Calculates the active blocks within a specified zone by comparing the active blocks with the blocks defined in the zone. void Calcnxny (Param XParam, int level, int &amp; nx, int &amp; ny) Calculate grid dimensions based on level. Calculates the number of grid points in the x and y directions based on the specified level. void Calcnxnyzone (Param XParam, int level, int &amp; nx, int &amp; ny, outzoneB Xzone) Calculate grid dimensions for a specific zone (output zones) based on level. Calculates the number of grid points in the x and y directions for a specified zone based on the given level. void InitSave2Netcdf (Param &amp; XParam, Model&lt; T &gt; &amp; XModel) Initialize NetCDF output files for the model. Initializes NetCDF output files for the model based on the provided parameters and model configuration. If output variables are specified in the parameters, it creates the necessary NetCDF files and defines the variables to be saved. template void InitSave2Netcdf&lt; double &gt; (Param &amp; XParam, Model&lt; double &gt; &amp; XModel)  template void InitSave2Netcdf&lt; float &gt; (Param &amp; XParam, Model&lt; float &gt; &amp; XModel)  void Save2Netcdf (Param XParam, Loop&lt; T &gt; XLoop, Model&lt; T &gt; &amp; XModel) Save model output to NetCDF files at specified output times. Saves model output to NetCDF files at specified output times based on the provided parameters. It checks if the current output time matches the next scheduled output time for each output zone, and if so, writes the relevant variables to the corresponding NetCDF files. template void Save2Netcdf&lt; double &gt; (Param XParam, Loop&lt; double &gt; XLoop, Model&lt; double &gt; &amp; XModel)  template void Save2Netcdf&lt; float &gt; (Param XParam, Loop&lt; float &gt; XLoop, Model&lt; float &gt; &amp; XModel)  void create2dnc (char * filename, int nx, int ny, double * xx, double * yy, double * var, char * varname) Create a NetCDF file containing a 2D variable, for testing for example. Creates a NetCDF file containing a 2D variable with the specified dimensions and data. If the file already exists, it will be overwritten. void create3dnc (char * name, int nx, int ny, int nt, double * xx, double * yy, double * theta, double * var, char * varname) Create a NetCDF file containing a 3D variable, for testing for example. Creates a NetCDF file containing a 3D variable with the specified dimensions and data. If the file already exists, it will be overwritten. void creatncfileBUQ (Param &amp; XParam, int * activeblk, int * level, T * blockxo, T * blockyo, outzoneB &amp; Xzone) Create a NetCDF file for BG-Flood output. Creates a NetCDF file for BG-Flood output based on the provided parameters and zone information. void creatncfileBUQ (Param &amp; XParam, BlockP&lt; T &gt; &amp; XBlock) Create NetCDF files for all output zones in a block. Creates NetCDF files for all output zones defined in the block using the provided parameters and block information. template void creatncfileBUQ&lt; double &gt; (Param &amp; XParam, int * activeblk, int * level, double * blockxo, double * blockyo, outzoneB &amp; Xzone)  template void creatncfileBUQ&lt; double &gt; (Param &amp; XParam, BlockP&lt; double &gt; &amp; XBlock)  template void creatncfileBUQ&lt; float &gt; (Param &amp; XParam, int * activeblk, int * level, float * blockxo, float * blockyo, outzoneB &amp; Xzone)  template void creatncfileBUQ&lt; float &gt; (Param &amp; XParam, BlockP&lt; float &gt; &amp; XBlock)  void defncvarBUQ (Param XParam, int * activeblk, int * level, T * blockxo, T * blockyo, std::string varst, int vdim, T * var, outzoneB Xzone) Define a NetCDF variable for BG-Flood output. Defines a NetCDF variable for BG-Flood output based on the provided parameters, block information and zone information. void defncvarBUQ (Param XParam, int * activeblk, int * level, T * blockxo, T * blockyo, std::string varst, std::string longname, std::string stdname, std::string unit, int vdim, T * var, outzoneB Xzone) Define a NetCDF variable for BG-Flood output with detailed attributes. Defines a NetCDF variable for BG-Flood output based on the provided parameters, block information and zone information, along with detailed attributes such as long name, standard name, and unit. template void defncvarBUQ&lt; double &gt; (Param XParam, int * activeblk, int * level, double * blockxo, double * blockyo, std::string varst, int vdim, double * var, outzoneB Xzone)  template void defncvarBUQ&lt; float &gt; (Param XParam, int * activeblk, int * level, float * blockxo, float * blockyo, std::string varst, int vdim, float * var, outzoneB Xzone)  void defncvarBUQlev (Param XParam, int * activeblk, int * level, T * blockxo, T * blockyo, std::string varst, std::string longname, std::string stdname, std::string unit, int vdim, T * var, outzoneB Xzone) Define a NetCDF variable for BG-Flood output with detailed attributes. Defines a NetCDF variable for BG-Flood output based on the provided parameters, block information and zone information, along with detailed attributes such as long name, standard name, and unit. void handle_ncerror (int status) Handle NetCDF errors. void write2dvarnc (int nx, int ny, double totaltime, double * var) Write a time step of a 2D variable to an existing NetCDF file, for testing for example. Writes a time step of a 2D variable to an existing NetCDF file by appending the provided variable data at the next available time index. void write3dvarnc (int nx, int ny, int nt, double totaltime, double * var) Write a time step of a 3D variable to an existing NetCDF file, for testing for example. Writes a time step of a 3D variable to an existing NetCDF file by appending the provided variable data at the next available time index. void writenctimestep (std::string outfile, double totaltime) Write the current time step to a NetCDF file. Writes the current time step to a NetCDF file by updating the \"time\" variable with the provided total time value. void writencvarstepBUQ (Param XParam, int vdim, int * activeblk, int * level, T * blockxo, T * blockyo, std::string varst, T * var, outzoneB Xzone) Write a time step of a NetCDF variable for BG-Flood output. Writes a time step of a NetCDF variable for BG-Flood output based on the provided parameters, block information, variable data, and zone information. template void writencvarstepBUQ&lt; double &gt; (Param XParam, int vdim, int * activeblk, int * level, double * blockxo, double * blockyo, std::string varst, double * var, outzoneB Xzone)  template void writencvarstepBUQ&lt; float &gt; (Param XParam, int vdim, int * activeblk, int * level, float * blockxo, float * blockyo, std::string varst, float * var, outzoneB Xzone)  void writencvarstepBUQlev (Param XParam, int vdim, int * activeblk, int * level, T * blockxo, T * blockyo, std::string varst, T * var, outzoneB Xzone) Write a time step of a NetCDF variable for BG-Flood output. Writes a time step of a NetCDF variable for BG-Flood output based on the provided parameters, block information, variable data, and zone information. template void writencvarstepBUQlev&lt; double &gt; (Param XParam, int vdim, int * activeblk, int * level, double * blockxo, double * blockyo, std::string varst, double * var, outzoneB Xzone)  template void writencvarstepBUQlev&lt; float &gt; (Param XParam, int vdim, int * activeblk, int * level, float * blockxo, float * blockyo, std::string varst, float * var, outzoneB Xzone)"},{"location":"BGFlood/_write__netcdf_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_write__netcdf_8cu/#function-calcactiveblockzone","title":"function Calcactiveblockzone","text":"<p>Calculate active blocks in a zone. Calculates the active blocks within a specified zone by comparing the active blocks with the blocks defined in the zone. </p><pre><code>std::vector&lt; int &gt; Calcactiveblockzone (\n    Param XParam,\n    int * activeblk,\n    outzoneB Xzone\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings. </li> <li><code>activeblk</code> Pointer to an array of active block indices. </li> <li><code>Xzone</code> The output zone object defining the area for which to calculate active blocks. </li> </ul> <p>Returns:</p> <p>A vector containing the indices of active blocks within the specified zone. Inactive blocks are marked with -1. </p>"},{"location":"BGFlood/_write__netcdf_8cu/#function-calcnxny","title":"function Calcnxny","text":"<p>Calculate grid dimensions based on level. Calculates the number of grid points in the x and y directions based on the specified level. </p><pre><code>void Calcnxny (\n    Param XParam,\n    int level,\n    int &amp; nx,\n    int &amp; ny\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings. </li> <li><code>level</code> The level for which to calculate grid dimensions. </li> <li><code>nx</code> Reference to store the calculated number of grid points in the x direction. </li> <li><code>ny</code> Reference to store the calculated number of grid points in the y direction. </li> </ul>"},{"location":"BGFlood/_write__netcdf_8cu/#function-calcnxnyzone","title":"function Calcnxnyzone","text":"<p>Calculate grid dimensions for a specific zone (output zones) based on level. Calculates the number of grid points in the x and y directions for a specified zone based on the given level. </p><pre><code>void Calcnxnyzone (\n    Param XParam,\n    int level,\n    int &amp; nx,\n    int &amp; ny,\n    outzoneB Xzone\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings. </li> <li><code>level</code> The level for which to calculate grid dimensions. </li> <li><code>nx</code> Reference to store the calculated number of grid points in the x direction. </li> <li><code>ny</code> Reference to store the calculated number of grid points in the y direction. </li> <li><code>Xzone</code> The output zone object defining the area for which to calculate grid dimensions. </li> </ul>"},{"location":"BGFlood/_write__netcdf_8cu/#function-initsave2netcdf","title":"function InitSave2Netcdf","text":"<p>Initialize NetCDF output files for the model. Initializes NetCDF output files for the model based on the provided parameters and model configuration. If output variables are specified in the parameters, it creates the necessary NetCDF files and defines the variables to be saved. </p><pre><code>template&lt;class T&gt;\nvoid InitSave2Netcdf (\n    Param &amp; XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings and model parameters. </li> <li><code>XModel</code> The model object containing block information and output variable mappings. </li> </ul> <p>Note:</p> <p>This is a templated function that can handle different data types for the model (e.g., float, double). </p> <p>See also: creatncfileBUQ for creating the NetCDF file and defining variables. </p>"},{"location":"BGFlood/_write__netcdf_8cu/#function-initsave2netcdf-double","title":"function InitSave2Netcdf&lt; double &gt;","text":"<pre><code>template void InitSave2Netcdf&lt; double &gt; (\n    Param &amp; XParam,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_write__netcdf_8cu/#function-initsave2netcdf-float","title":"function InitSave2Netcdf&lt; float &gt;","text":"<pre><code>template void InitSave2Netcdf&lt; float &gt; (\n    Param &amp; XParam,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_write__netcdf_8cu/#function-save2netcdf","title":"function Save2Netcdf","text":"<p>Save model output to NetCDF files at specified output times. Saves model output to NetCDF files at specified output times based on the provided parameters. It checks if the current output time matches the next scheduled output time for each output zone, and if so, writes the relevant variables to the corresponding NetCDF files. </p><pre><code>template&lt;class T&gt;\nvoid Save2Netcdf (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings and model parameters. </li> <li><code>XLoop</code> The loop object containing time-stepping information. </li> <li><code>XModel</code> The model object containing block information and output variable mappings. </li> </ul> <p>Note:</p> <p>This is a templated function that can handle different data types for the model (e.g., float, double). </p> <p>See also: writenctimestep for writing the time step to the NetCDF file. </p>"},{"location":"BGFlood/_write__netcdf_8cu/#function-save2netcdf-double","title":"function Save2Netcdf&lt; double &gt;","text":"<pre><code>template void Save2Netcdf&lt; double &gt; (\n    Param XParam,\n    Loop &lt; double &gt; XLoop,\n    Model &lt; double &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_write__netcdf_8cu/#function-save2netcdf-float","title":"function Save2Netcdf&lt; float &gt;","text":"<pre><code>template void Save2Netcdf&lt; float &gt; (\n    Param XParam,\n    Loop &lt; float &gt; XLoop,\n    Model &lt; float &gt; &amp; XModel\n) \n</code></pre>"},{"location":"BGFlood/_write__netcdf_8cu/#function-create2dnc","title":"function create2dnc","text":"<p>Create a NetCDF file containing a 2D variable, for testing for example. Creates a NetCDF file containing a 2D variable with the specified dimensions and data. If the file already exists, it will be overwritten. </p><pre><code>void create2dnc (\n    char * filename,\n    int nx,\n    int ny,\n    double * xx,\n    double * yy,\n    double * var,\n    char * varname\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> The name of the NetCDF file to be created.</li> <li><code>nx</code> The number of grid points in the x-direction. </li> <li><code>ny</code> The number of grid points in the y-direction. </li> <li><code>xx</code> Pointer to an array containing the x-coordinates of the grid points. </li> <li><code>yy</code> Pointer to an array containing the y-coordinates of the grid points. </li> <li><code>var</code> Pointer to an array containing the 2D variable data to be stored in the NetCDF file. </li> <li><code>varname</code> The name of the variable to be stored in the NetCDF file. </li> </ul> <p>Note:</p> <p>This function uses the NetCDF C library to create and write to the NetCDF file. </p>"},{"location":"BGFlood/_write__netcdf_8cu/#function-create3dnc","title":"function create3dnc","text":"<p>Create a NetCDF file containing a 3D variable, for testing for example. Creates a NetCDF file containing a 3D variable with the specified dimensions and data. If the file already exists, it will be overwritten. </p><pre><code>void create3dnc (\n    char * name,\n    int nx,\n    int ny,\n    int nt,\n    double * xx,\n    double * yy,\n    double * theta,\n    double * var,\n    char * varname\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> The name of the NetCDF file to be created. </li> <li><code>nx</code> The number of grid points in the x-direction. </li> <li><code>ny</code> The number of grid points in the y-direction. </li> <li><code>nt</code> The number of time steps. </li> <li><code>xx</code> Pointer to an array containing the x-coordinates of the grid points. </li> <li><code>yy</code> Pointer to an array containing the y-coordinates of the grid points. </li> <li><code>theta</code> Pointer to an array containing the time values. </li> <li><code>var</code> Pointer to an array containing the 3D variable data to be stored in the NetCDF file. </li> <li><code>varname</code> The name of the variable to be stored in the NetCDF file. </li> </ul> <p>Note:</p> <p>This function uses the NetCDF C library to create and write to the NetCDF file. </p>"},{"location":"BGFlood/_write__netcdf_8cu/#function-creatncfilebuq","title":"function creatncfileBUQ","text":"<p>Create a NetCDF file for BG-Flood output. Creates a NetCDF file for BG-Flood output based on the provided parameters and zone information. </p><pre><code>template&lt;class T&gt;\nvoid creatncfileBUQ (\n    Param &amp; XParam,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    outzoneB &amp; Xzone\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings and model parameters. </li> <li><code>activeblk</code> Pointer to an array of active block indices. </li> <li><code>level</code> Pointer to an array of block levels. </li> <li><code>blockxo</code> Pointer to an array of block x-coordinates. </li> <li><code>blockyo</code> Pointer to an array of block y-coordinates. </li> <li><code>Xzone</code> The output zone object defining the area and settings for the NetCDF file. </li> </ul>"},{"location":"BGFlood/_write__netcdf_8cu/#function-creatncfilebuq_1","title":"function creatncfileBUQ","text":"<p>Create NetCDF files for all output zones in a block. Creates NetCDF files for all output zones defined in the block using the provided parameters and block information. </p><pre><code>template&lt;class T&gt;\nvoid creatncfileBUQ (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings and model parameters. </li> <li><code>XBlock</code> The block object containing block information and output zones. </li> </ul>"},{"location":"BGFlood/_write__netcdf_8cu/#function-creatncfilebuq-double","title":"function creatncfileBUQ&lt; double &gt;","text":"<pre><code>template void creatncfileBUQ&lt; double &gt; (\n    Param &amp; XParam,\n    int * activeblk,\n    int * level,\n    double * blockxo,\n    double * blockyo,\n    outzoneB &amp; Xzone\n) \n</code></pre>"},{"location":"BGFlood/_write__netcdf_8cu/#function-creatncfilebuq-double_1","title":"function creatncfileBUQ&lt; double &gt;","text":"<pre><code>template void creatncfileBUQ&lt; double &gt; (\n    Param &amp; XParam,\n    BlockP &lt; double &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/_write__netcdf_8cu/#function-creatncfilebuq-float","title":"function creatncfileBUQ&lt; float &gt;","text":"<pre><code>template void creatncfileBUQ&lt; float &gt; (\n    Param &amp; XParam,\n    int * activeblk,\n    int * level,\n    float * blockxo,\n    float * blockyo,\n    outzoneB &amp; Xzone\n) \n</code></pre>"},{"location":"BGFlood/_write__netcdf_8cu/#function-creatncfilebuq-float_1","title":"function creatncfileBUQ&lt; float &gt;","text":"<pre><code>template void creatncfileBUQ&lt; float &gt; (\n    Param &amp; XParam,\n    BlockP &lt; float &gt; &amp; XBlock\n) \n</code></pre>"},{"location":"BGFlood/_write__netcdf_8cu/#function-defncvarbuq","title":"function defncvarBUQ","text":"<p>Define a NetCDF variable for BG-Flood output. Defines a NetCDF variable for BG-Flood output based on the provided parameters, block information and zone information. </p><pre><code>template&lt;class T&gt;\nvoid defncvarBUQ (\n    Param XParam,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    std::string varst,\n    int vdim,\n    T * var,\n    outzoneB Xzone\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings and model parameters. </li> <li><code>activeblk</code> Pointer to an array of active block indices. </li> <li><code>level</code> Pointer to an array of block levels. </li> <li><code>blockxo</code> Pointer to an array of block x-coordinates. </li> <li><code>blockyo</code> Pointer to an array of block y-coordinates. </li> <li><code>varst</code> The base name of the variable to be defined. </li> <li><code>vdim</code> The number of dimensions of the variable (2 or 3). </li> <li><code>var</code> Pointer to the array containing the variable data. </li> <li><code>Xzone</code> The output zone object defining the area and settings for the NetCDF variable. </li> </ul> <p>Note:</p> <p>This is an overloaded function that provides a simpler interface when longname, stdname, and unit are not needed. </p>"},{"location":"BGFlood/_write__netcdf_8cu/#function-defncvarbuq_1","title":"function defncvarBUQ","text":"<p>Define a NetCDF variable for BG-Flood output with detailed attributes. Defines a NetCDF variable for BG-Flood output based on the provided parameters, block information and zone information, along with detailed attributes such as long name, standard name, and unit. </p><pre><code>template&lt;class T&gt;\nvoid defncvarBUQ (\n    Param XParam,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    std::string varst,\n    std::string longname,\n    std::string stdname,\n    std::string unit,\n    int vdim,\n    T * var,\n    outzoneB Xzone\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings and model parameters. </li> <li><code>activeblk</code> Pointer to an array of active block indices. </li> <li><code>level</code> Pointer to an array of block levels. </li> <li><code>blockxo</code> Pointer to an array of block x-coordinates. </li> <li><code>blockyo</code> Pointer to an array of block y-coordinates. </li> <li><code>varst</code> The base name of the variable to be defined. </li> <li><code>longname</code> The long name attribute for the variable. </li> <li><code>stdname</code> The standard name attribute for the variable. </li> <li><code>unit</code> The unit attribute for the variable. </li> <li><code>vdim</code> The number of dimensions of the variable (2 or 3). </li> <li><code>var</code> Pointer to the array containing the variable data. </li> <li><code>Xzone</code> The output zone object defining the area and settings for the NetCDF variable. </li> </ul> <p>Note:</p> <p>This is a templated function that can handle different data types for the variable (e.g., float, double). </p>"},{"location":"BGFlood/_write__netcdf_8cu/#function-defncvarbuq-double","title":"function defncvarBUQ&lt; double &gt;","text":"<pre><code>template void defncvarBUQ&lt; double &gt; (\n    Param XParam,\n    int * activeblk,\n    int * level,\n    double * blockxo,\n    double * blockyo,\n    std::string varst,\n    int vdim,\n    double * var,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/_write__netcdf_8cu/#function-defncvarbuq-float","title":"function defncvarBUQ&lt; float &gt;","text":"<pre><code>template void defncvarBUQ&lt; float &gt; (\n    Param XParam,\n    int * activeblk,\n    int * level,\n    float * blockxo,\n    float * blockyo,\n    std::string varst,\n    int vdim,\n    float * var,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/_write__netcdf_8cu/#function-defncvarbuqlev","title":"function defncvarBUQlev","text":"<p>Define a NetCDF variable for BG-Flood output with detailed attributes. Defines a NetCDF variable for BG-Flood output based on the provided parameters, block information and zone information, along with detailed attributes such as long name, standard name, and unit. </p><pre><code>template&lt;class T&gt;\nvoid defncvarBUQlev (\n    Param XParam,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    std::string varst,\n    std::string longname,\n    std::string stdname,\n    std::string unit,\n    int vdim,\n    T * var,\n    outzoneB Xzone\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings and model parameters. </li> <li><code>activeblk</code> Pointer to an array of active block indices. </li> <li><code>level</code> Pointer to an array of block levels. </li> <li><code>blockxo</code> Pointer to an array of block x-coordinates. </li> <li><code>blockyo</code> Pointer to an array of block y-coordinates. </li> <li><code>varst</code> The base name of the variable to be defined. </li> <li><code>longname</code> The long name attribute for the variable. </li> <li><code>stdname</code> The standard name attribute for the variable. </li> <li><code>unit</code> The unit attribute for the variable. </li> <li><code>vdim</code> The number of dimensions of the variable (2 or 3). </li> <li><code>var</code> Pointer to the array containing the variable data. </li> <li><code>Xzone</code> The output zone object defining the area and settings for the NetCDF variable. </li> </ul> <p>Note:</p> <p>This is a templated function that can handle different data types for the variable (e.g., float, double). </p>"},{"location":"BGFlood/_write__netcdf_8cu/#function-handle_ncerror","title":"function handle_ncerror","text":"<p>Handle NetCDF errors. </p><pre><code>void handle_ncerror (\n    int status\n) \n</code></pre>"},{"location":"BGFlood/_write__netcdf_8cu/#function-write2dvarnc","title":"function write2dvarnc","text":"<p>Write a time step of a 2D variable to an existing NetCDF file, for testing for example. Writes a time step of a 2D variable to an existing NetCDF file by appending the provided variable data at the next available time index. </p><pre><code>void write2dvarnc (\n    int nx,\n    int ny,\n    double totaltime,\n    double * var\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>nx</code> The number of grid points in the x-direction. </li> <li><code>ny</code> The number of grid points in the y-direction. </li> <li><code>totaltime</code> The total time value to be written to the \"time\" variable. </li> <li><code>var</code> Pointer to an array containing the 2D variable data to be appended to the NetCDF file. </li> </ul> <p>Note:</p> <p>This function assumes that the NetCDF file \"3Dvar.nc\" already exists and is open for writing. </p>"},{"location":"BGFlood/_write__netcdf_8cu/#function-write3dvarnc","title":"function write3dvarnc","text":"<p>Write a time step of a 3D variable to an existing NetCDF file, for testing for example. Writes a time step of a 3D variable to an existing NetCDF file by appending the provided variable data at the next available time index. </p><pre><code>void write3dvarnc (\n    int nx,\n    int ny,\n    int nt,\n    double totaltime,\n    double * var\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>nx</code> The number of grid points in the x-direction. </li> <li><code>ny</code> The number of grid points in the y-direction. </li> <li><code>nt</code> The number of time steps. </li> <li><code>totaltime</code> The total time value to be written to the \"time\" variable. </li> <li><code>var</code> Pointer to an array containing the 3D variable data to be appended to the NetCDF file. </li> </ul> <p>Note:</p> <p>This function assumes that the NetCDF file \"3Dvar.nc\" already exists and is open for writing. </p>"},{"location":"BGFlood/_write__netcdf_8cu/#function-writenctimestep","title":"function writenctimestep","text":"<p>Write the current time step to a NetCDF file. Writes the current time step to a NetCDF file by updating the \"time\" variable with the provided total time value. </p><pre><code>void writenctimestep (\n    std::string outfile,\n    double totaltime\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>outfile</code> The name of the NetCDF output file. </li> <li><code>totaltime</code> The total time value to be written to the \"time\" variable. </li> </ul>"},{"location":"BGFlood/_write__netcdf_8cu/#function-writencvarstepbuq","title":"function writencvarstepBUQ","text":"<p>Write a time step of a NetCDF variable for BG-Flood output. Writes a time step of a NetCDF variable for BG-Flood output based on the provided parameters, block information, variable data, and zone information. </p><pre><code>template&lt;class T&gt;\nvoid writencvarstepBUQ (\n    Param XParam,\n    int vdim,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    std::string varst,\n    T * var,\n    outzoneB Xzone\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings and model parameters. </li> <li><code>vdim</code> The number of dimensions of the variable (2 or 3). </li> <li><code>activeblk</code> Pointer to an array of active block indices. </li> <li><code>level</code> Pointer to an array of block levels. </li> <li><code>blockxo</code> Pointer to an array of block x-coordinates. </li> <li><code>blockyo</code> Pointer to an array of block y-coordinates. </li> <li><code>varst</code> The base name of the variable to be written. </li> <li><code>var</code> Pointer to the array containing the variable data. </li> <li><code>Xzone</code> The output zone object defining the area and settings for the NetCDF variable. </li> </ul> <p>Note:</p> <p>This is a templated function that can handle different data types for the variable (e.g., float, double). </p>"},{"location":"BGFlood/_write__netcdf_8cu/#function-writencvarstepbuq-double","title":"function writencvarstepBUQ&lt; double &gt;","text":"<pre><code>template void writencvarstepBUQ&lt; double &gt; (\n    Param XParam,\n    int vdim,\n    int * activeblk,\n    int * level,\n    double * blockxo,\n    double * blockyo,\n    std::string varst,\n    double * var,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/_write__netcdf_8cu/#function-writencvarstepbuq-float","title":"function writencvarstepBUQ&lt; float &gt;","text":"<pre><code>template void writencvarstepBUQ&lt; float &gt; (\n    Param XParam,\n    int vdim,\n    int * activeblk,\n    int * level,\n    float * blockxo,\n    float * blockyo,\n    std::string varst,\n    float * var,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/_write__netcdf_8cu/#function-writencvarstepbuqlev","title":"function writencvarstepBUQlev","text":"<p>Write a time step of a NetCDF variable for BG-Flood output. Writes a time step of a NetCDF variable for BG-Flood output based on the provided parameters, block information, variable data, and zone information. </p><pre><code>template&lt;class T&gt;\nvoid writencvarstepBUQlev (\n    Param XParam,\n    int vdim,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    std::string varst,\n    T * var,\n    outzoneB Xzone\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings and model parameters. </li> <li><code>vdim</code> The number of dimensions of the variable (2 or 3). </li> <li><code>activeblk</code> Pointer to an array of active block indices. </li> <li><code>level</code> Pointer to an array of block levels. </li> <li><code>blockxo</code> Pointer to an array of block x-coordinates. </li> <li><code>blockyo</code> Pointer to an array of block y-coordinates. </li> <li><code>varst</code> The base name of the variable to be written. </li> <li><code>var</code> Pointer to the array containing the variable data. </li> <li><code>Xzone</code> The output zone object defining the area and settings for the NetCDF variable. </li> </ul> <p>Note:</p> <p>This is a templated function that can handle different data types for the variable (e.g., float, double). This version handles variables defined for each level separately. </p> <p>See also: writencvarstepBUQ for the version that does not separate by levels. </p>"},{"location":"BGFlood/_write__netcdf_8cu/#function-writencvarstepbuqlev-double","title":"function writencvarstepBUQlev&lt; double &gt;","text":"<pre><code>template void writencvarstepBUQlev&lt; double &gt; (\n    Param XParam,\n    int vdim,\n    int * activeblk,\n    int * level,\n    double * blockxo,\n    double * blockyo,\n    std::string varst,\n    double * var,\n    outzoneB Xzone\n) \n</code></pre>"},{"location":"BGFlood/_write__netcdf_8cu/#function-writencvarstepbuqlev-float","title":"function writencvarstepBUQlev&lt; float &gt;","text":"<pre><code>template void writencvarstepBUQlev&lt; float &gt; (\n    Param XParam,\n    int vdim,\n    int * activeblk,\n    int * level,\n    float * blockxo,\n    float * blockyo,\n    std::string varst,\n    float * var,\n    outzoneB Xzone\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Write_netcdf.cu</code></p>"},{"location":"BGFlood/_write__netcdf_8cu_source/","title":"File Write_netcdf.cu","text":""},{"location":"BGFlood/_write__netcdf_8cu_source/#file-write_netcdfcu","title":"File Write_netcdf.cu","text":"<p>File List &gt; src &gt; Write_netcdf.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Write_netcdf.h\"\n#include \"Util_CPU.h\"\n#include \"General.h\"\n\nvoid handle_ncerror(int status) {\n\n\n    if (status != NC_NOERR) {\n        fprintf(stderr, \"Netcdf %s\\n\", nc_strerror(status));\n        std::ostringstream stringStream;\n        stringStream &lt;&lt; nc_strerror(status);\n        std::string copyOfStr = stringStream.str();\n        log(\"Netcdf error:\" + copyOfStr);\n        //fprintf(logfile, \"Netcdf: %s\\n\", nc_strerror(status));\n        exit(2);\n    }\n}\n\nvoid Calcnxny(Param XParam, int level, int&amp; nx, int&amp; ny)\n{\n    double ddx = calcres(XParam.dx, level);\n    double dxp = calcres(XParam.dx, level + 1);\n    double xxmax, xxmin, yymax, yymin;\n\n    xxmax = XParam.xmax - dxp;\n    yymax = XParam.ymax - dxp;\n\n    xxmin = XParam.xo + dxp;\n    yymin = XParam.yo + dxp;\n\n    nx = ftoi(round((xxmax - xxmin) / ddx + 1.0));\n    ny = ftoi(round((yymax - yymin) / ddx + 1.0));\n}\n\nvoid Calcnxnyzone(Param XParam, int level, int&amp; nx, int&amp; ny, outzoneB Xzone)\n{\n    double ddx = calcres(XParam.dx, level);\n    double xxmax, xxmin, yymax, yymin;\n\n    xxmax = Xzone.xmax;\n    yymax = Xzone.ymax;\n\n    xxmin = Xzone.xo;\n    yymin = Xzone.yo;\n\n    nx = ftoi((xxmax - xxmin) / ddx);\n    ny = ftoi((yymax - yymin) / ddx);\n}\n\nstd::vector&lt;int&gt; Calcactiveblockzone(Param XParam, int* activeblk, outzoneB Xzone)\n{\n    std::vector&lt;int&gt; actblkzone(Xzone.nblk, -1);\n    int* inactive, * inblock;\n\n    for (int ib = 0; ib &lt; Xzone.nblk; ib++)\n    {\n        //printf(\"loop=%i \\n\", Xzone.blk[ib]);\n        inactive = std::find(activeblk, activeblk + XParam.nblk, Xzone.blk[ib]);\n        inblock = std::find(Xzone.blk, Xzone.blk + Xzone.nblk, Xzone.blk[ib]);\n        //if ((inactive != activeblk + XParam.nblk) &amp;&amp; (inblock != Xzone.blk + Xzone.nblk))\n        if (inactive != activeblk + XParam.nblk)\n        {\n            //printf(\"active=%i \\n\", Xzone.blk[ib]);\n            if (inblock != Xzone.blk + Xzone.nblk)\n            {\n                actblkzone[ib] = Xzone.blk[ib];\n                //printf(\"block=%i \\n\", Xzone.blk[ib]);\n            }\n            else { actblkzone[ib] = -1; }\n        }\n        else\n        {\n            actblkzone[ib] = -1;\n        }\n    }\n    return(actblkzone);\n}\n\ntemplate&lt;class T&gt;\nvoid creatncfileBUQ(Param&amp; XParam, int* activeblk, int* level, T* blockxo, T* blockyo, outzoneB&amp; Xzone)\n{\n\n    int status;\n    int nx, ny;\n    //double dx = XParam.dx;\n    size_t nxx, nyy;\n    int ncid, xx_dim, yy_dim, time_dim, blockid_dim, nblk;\n    double* xval, * yval;\n\n    int BGFloodoutversion = 0;// integer to quickly identify the output as BG_flood or not\n\n    //const int minlevzone = XParam.minlevel;\n    //const int maxlevzone = XParam.maxlevel;\n\n    std::vector&lt;int&gt; activeblkzone = Calcactiveblockzone(XParam, activeblk, Xzone);\n    //Calclevelzone(XParam, minlevzone, maxlevzone, Xzone, level);\n    nblk = Xzone.nblk;\n\n\n    // create the netcdf dataset Xzone.outname.c_str()\n    status = nc_create(Xzone.outname.c_str(), NC_NOCLOBBER | NC_NETCDF4, &amp;ncid);\n    if (status != NC_NOERR)\n    {\n        if (status == NC_EEXIST) // File already exist so automatically rename the output file \n        {\n            //printf(\"Warning! Output file name already exist  \");\n            log(\"Warning! Output file name already exist   \");\n            int fileinc = 1;\n            std::vector&lt;std::string&gt; extvec = split(Xzone.outname, '.');\n            std::string bathyext = extvec.back();\n            std::string newname;\n\n            while (status == NC_EEXIST)\n            {\n                newname = extvec[0];\n                for (int nstin = 1; nstin &lt; extvec.size() - 1; nstin++)\n                {\n                    // This is in case there are \".\" in the file name that do not relate to the file extension\"\n                    newname = newname + \".\" + extvec[nstin];\n                }\n                newname = newname + \"_\" + std::to_string(fileinc) + \".\" + bathyext;\n                Xzone.outname = newname;\n                status = nc_create(Xzone.outname.c_str(), NC_NOCLOBBER | NC_NETCDF4, &amp;ncid);\n                fileinc++;\n            }\n            //printf(\"New file name: %s  \", Xzone.outname.c_str());\n            log(\"New file name: \" + Xzone.outname);\n\n        }\n        else\n        {\n            // Other error\n            handle_ncerror(status);\n        }\n    }\n\n    // status could be a new error after renaming the file\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    double initdx = calcres(XParam.dx, XParam.initlevel);\n    double xmin, xmax, ymin, ymax;\n\n    xmin = Xzone.xo;\n    xmax = Xzone.xmax;\n    ymin = Xzone.yo;\n    ymax = Xzone.ymax;\n\n\n\n    // Define global attributes\n    status = nc_put_att_int(ncid, NC_GLOBAL, \"maxlevel\", NC_INT, 1, &amp;Xzone.maxlevel);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_put_att_int(ncid, NC_GLOBAL, \"minlevel\", NC_INT, 1, &amp;Xzone.minlevel);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_put_att_double(ncid, NC_GLOBAL, \"xmin\", NC_DOUBLE, 1, &amp;xmin);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_put_att_double(ncid, NC_GLOBAL, \"xmax\", NC_DOUBLE, 1, &amp;xmax);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_put_att_double(ncid, NC_GLOBAL, \"ymin\", NC_DOUBLE, 1, &amp;ymin);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_put_att_double(ncid, NC_GLOBAL, \"ymax\", NC_DOUBLE, 1, &amp;ymax);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n    status = nc_put_att_text(ncid, NC_GLOBAL, \"Conventions\", 14,\"CF-1.11-draft\");\n\n    // Define global attribute for identifying BG_Flood\n    status = nc_put_att_int(ncid, NC_GLOBAL, \"BG_Flood\", NC_INT, 1, &amp;BGFloodoutversion);\n\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n    // Define time variable \n    status = nc_def_dim(ncid, \"time\", NC_UNLIMITED, &amp;time_dim);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    int time_id, xx_id, yy_id;\n    int tdim[] = { time_dim };\n\n    //########################\n    //static size_t tst[] = { 0 };\n    size_t blkstart[] = { 0 }; // Xzone.blk[0]};\n    size_t blkcount[] = { (size_t)Xzone.nblk };\n    size_t xcount[] = { 0 };\n    size_t ycount[] = { 0 };\n    static size_t xstart[] = { 0 }; // start at first value\n    static size_t ystart[] = { 0 };\n    status = nc_def_var(ncid, \"time\", NC_FLOAT, 1, tdim, &amp;time_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    static char txtname[] = \"time\";\n    status = nc_put_att_text(ncid, time_id, \"standard_name\", strlen(txtname), txtname);\n    //status = nc_put_att_string(ncid, time_id, \"standard_name\", 1, \"time\");\n    //units = \"days since 1990-1-1 0:0:0\";\n\n    std::string timestr = \"seconds since \" + XParam.reftime;\n    const char* timeunit = timestr.c_str();\n\n    status = nc_put_att_text(ncid, time_id, \"units\", strlen(timeunit), timeunit);\n\n    std::string timeaxis = \"T\";\n\n    status = nc_put_att_text(ncid, time_id, \"axis\", timeaxis.size(), timeaxis.c_str());\n\n    //static char calendarname[] = \"standard\";\n    //status = nc_put_att_text(ncid, time_id, \"calendar\", strlen(calendarname), calendarname);\n\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n    int crsid;\n    std::string crsname;\n    status = nc_def_var(ncid, \"crs\", NC_INT, 0, tdim, &amp;crsid);\n    if (XParam.spherical == 1)\n    {\n        crsname = \"latitude_longitude\";\n\n        float primemeridian = 0.0f;\n        float sma = 6378137.0f;\n        float iflat = 298.257223563f;\n        status = nc_put_att_text(ncid, crsid, \"grid_mapping_name\", crsname.size(), crsname.c_str());\n        status = nc_put_att_float(ncid, crsid, \"longitude_of_prime_meridian\", NC_FLOAT, 1, &amp;primemeridian);\n        status = nc_put_att_float(ncid, crsid, \"semi_major_axis\", NC_FLOAT, 1, &amp;sma);\n        status = nc_put_att_float(ncid, crsid, \"inverse_flattening\", NC_FLOAT, 1, &amp;iflat);\n    }\n    else\n    {\n        crsname = \"projected\";\n        std::string proj = XParam.crs_ref;\n        //\"+proj=tmerc +lat_0=0 +lon_0=173 +k=0.9996 +x_0=1600000 +y_0=10000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\";\n        status = nc_put_att_text(ncid, crsid, \"grid_mapping_name\", crsname.size(), crsname.c_str());\n        status = nc_put_att_text(ncid, crsid, \"crs_wkt\", proj.size(), proj.c_str());\n        status = nc_put_att_text(ncid, crsid, \"spatial_ref\", proj.size(), proj.c_str());\n        //status = nc_put_att_float(ncid, crsid, \"semi_major_axis\", NC_FLOAT, 1, 6378137.0);\n        //status = nc_put_att_float(ncid, crsid, \"inverse_flattening\", NC_FLOAT, 1, 298.257223563);\n    }\n\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    int bgfid;\n\n    // Model variable to store parameters\n    status = nc_def_var(ncid, \"BGFlood\", NC_INT, 0, tdim, &amp;bgfid);\n    saveparam2netCDF(ncid, bgfid, XParam);\n\n\n    // Define dimensions and variables to store block id, status, level xo, yo\n\n    status = nc_def_dim(ncid, \"blockid\", nblk, &amp;blockid_dim);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    int biddim[] = { blockid_dim };\n    int blkid_id, blkxo_id, blkyo_id, blklevel_id, blkwidth_id, blkstatus_id;\n\n    status = nc_def_var(ncid, \"blockid\", NC_INT, 1, biddim, &amp;blkid_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_def_var(ncid, \"blockxo\", NC_FLOAT, 1, biddim, &amp;blkxo_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_def_var(ncid, \"blockyo\", NC_FLOAT, 1, biddim, &amp;blkyo_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_def_var(ncid, \"blockwidth\", NC_FLOAT, 1, biddim, &amp;blkwidth_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_def_var(ncid, \"blocklevel\", NC_INT, 1, biddim, &amp;blklevel_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_def_var(ncid, \"blockstatus\", NC_INT, 1, biddim, &amp;blkstatus_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //int* levZone;\n    std::string xaxis = \"X\";\n    std::string yaxis = \"Y\";\n    // For each level Define xx yy \n    for (int lev = Xzone.minlevel; lev &lt;= Xzone.maxlevel; lev++)\n    {\n\n        Calcnxnyzone(XParam, lev, nx, ny, Xzone);\n\n        //printf(\"lev=%d;  xxmin=%f; xxmax=%f; nx=%d\\n\", lev, xmin, xmax, nx);\n        //printf(\"lev=%d;  yymin=%f; yymax=%f; ny=%d\\n\", lev,  ymin, ymax, ny);\n\n        //to change type from int to size_t\n        nxx = nx;\n        nyy = ny;\n\n        //Define dimensions: Name and length\n        std::string xxname, yyname, sign;\n\n        lev &lt; 0 ? sign = \"N\" : sign = \"P\";\n\n\n        xxname = \"xx_\" + sign + std::to_string(abs(lev));\n        yyname = \"yy_\" + sign + std::to_string(abs(lev));\n\n        //printf(\"lev=%d; xxname=%s; yyname=%s;\\n\", lev, xxname.c_str(), yyname.c_str());\n        //printf(\"ddx=%f; nxx=%d;\\n\", ddx, nxx);\n        status = nc_def_dim(ncid, xxname.c_str(), nxx, &amp;xx_dim);\n        if (status != NC_NOERR) handle_ncerror(status);\n        status = nc_def_dim(ncid, yyname.c_str(), nyy, &amp;yy_dim);\n        if (status != NC_NOERR) handle_ncerror(status);\n        //status = nc_def_dim(ncid, \"npart\",nnpart,&amp;p_dim);\n\n        int xdim[] = { xx_dim };\n        int ydim[] = { yy_dim };\n\n\n\n        status = nc_def_var(ncid, xxname.c_str(), NC_DOUBLE, 1, xdim, &amp;xx_id);\n        if (status != NC_NOERR) handle_ncerror(status);\n        status = nc_def_var(ncid, yyname.c_str(), NC_DOUBLE, 1, ydim, &amp;yy_id);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n\n\n\n        status = nc_put_att_text(ncid, xx_id, \"axis\", xaxis.size(), xaxis.c_str());\n        status = nc_put_att_text(ncid, yy_id, \"axis\", yaxis.size(), yaxis.c_str());\n        //End definitions: leave define mode\n    }\n    status = nc_enddef(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //status = nc_close(ncid);\n    //if (status != NC_NOERR) handle_ncerror(status);\n\n    float* blkwidth;\n    int* blkid;\n    int ibl;\n\n\n    AllocateCPU(1, nblk, blkwidth);\n    AllocateCPU(1, nblk, blkid);\n\n    //printf(\"blockId:\\n\");\n    for (int ib = 0; ib &lt; nblk; ib++)\n    {\n        //int ibl = activeblk[Xzone.blk[ib]];\n        ibl = activeblkzone[ib];\n        blkwidth[ib] = (float)calcres(XParam.dx, level[ibl]);\n        blkid[ib] = ibl;\n    }\n\n\n    status = nc_put_vara_int(ncid, blkid_id, blkstart, blkcount, blkid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //status = nc_put_vara_int(ncid, blkstatus_id, blkstart, blkcount, activeblk);\n    status = nc_put_vara_float(ncid, blkwidth_id, blkstart, blkcount, blkwidth);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n    // Reusing blkwidth/blkid for other array (for blkxo/blklevel and blkyo) to save memory space\n\n    // This is needed because the blockxo array may be shuffled to memory block beyond nblk\n    for (int ib = 0; ib &lt; nblk; ib++)\n    {\n        //int ibl = activeblk[Xzone.blk[ib]];\n        ibl = activeblkzone[ib];\n        blkwidth[ib] = float(T(XParam.xo) + blockxo[ibl]);\n        blkid[ib] = level[ibl];\n\n    }\n\n    status = nc_put_vara_float(ncid, blkxo_id, blkstart, blkcount, blkwidth);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    status = nc_put_vara_int(ncid, blklevel_id, blkstart, blkcount, blkid);\n\n    for (int ib = 0; ib &lt; nblk; ib++)\n    {\n        //int ibl = activeblk[Xzone.blk[ib]];\n        ibl = activeblkzone[ib];\n        blkwidth[ib] = float(T(XParam.yo) + blockyo[ibl]);\n    }\n\n    status = nc_put_vara_float(ncid, blkyo_id, blkstart, blkcount, blkwidth);\n\n\n    free(blkid);\n    free(blkwidth);\n\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    std::string xxname, yyname, sign;\n\n    for (int lev = Xzone.minlevel; lev &lt;= Xzone.maxlevel; lev++)\n    {\n        Calcnxnyzone(XParam, lev, nx, ny, Xzone);\n\n        // start at first value\n        //static size_t thstart[] = { 0 };\n        xcount[0] = nx;\n        ycount[0] = ny;\n        //Recreat the x, y\n        xval = (double*)malloc(nx * sizeof(double));\n        yval = (double*)malloc(ny * sizeof(double));\n\n        double ddx = calcres(XParam.dx, lev);\n        double dxp = calcres(XParam.dx, lev + 1);\n        double  xxmin, yymin;\n        //doublle xxmax, yymax\n        //xxmax = Xzone.xmax - dxp;\n        //yymax = Xzone.ymax - dxp;\n\n        xxmin = Xzone.xo + dxp;\n        yymin = Xzone.yo + dxp;\n\n        for (int i = 0; i &lt; nx; i++)\n        {\n            xval[i] = xxmin + double(i) * ddx;\n        }\n\n        for (int i = 0; i &lt; ny; i++)\n        {\n            yval[i] = yymin + double(i) * ddx;\n        }\n\n\n        lev &lt; 0 ? sign = \"N\" : sign = \"P\";\n\n\n        xxname = \"xx_\" + sign + std::to_string(abs(lev));\n        yyname = \"yy_\" + sign + std::to_string(abs(lev));\n\n        //printf(\"lev=%d; xxname=%s; yyname=%s;\\n\", lev, xxname.c_str(), yyname.c_str());\n\n        status = nc_inq_varid(ncid, xxname.c_str(), &amp;xx_id);\n        if (status != NC_NOERR) handle_ncerror(status);\n        status = nc_inq_varid(ncid, yyname.c_str(), &amp;yy_id);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        //Provide values for variables\n\n        status = nc_put_vara_double(ncid, xx_id, xstart, xcount, xval);\n        if (status != NC_NOERR) handle_ncerror(status);\n        status = nc_put_vara_double(ncid, yy_id, ystart, ycount, yval);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n\n\n        free(xval);\n        free(yval);\n    }\n\n    //close and save new file\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n\n\n\n    //return XParam;void\n}\n\ntemplate void creatncfileBUQ&lt;float&gt;(Param&amp; XParam, int* activeblk, int* level, float* blockxo, float* blockyo, outzoneB&amp; Xzone);\ntemplate void creatncfileBUQ&lt;double&gt;(Param&amp; XParam, int* activeblk, int* level, double* blockxo, double* blockyo, outzoneB&amp; Xzone);\n\ntemplate&lt;class T&gt;\nvoid creatncfileBUQ(Param&amp; XParam, BlockP&lt;T&gt;&amp; XBlock)\n{\n    for (int o = 0; o &lt; XBlock.outZone.size(); o++)\n    {\n        creatncfileBUQ(XParam, XBlock.active, XBlock.level, XBlock.xo, XBlock.yo, XBlock.outZone[o]);\n    }\n}\ntemplate void creatncfileBUQ&lt;float&gt;(Param&amp; XParam, BlockP&lt;float&gt;&amp; XBlock);\ntemplate void creatncfileBUQ&lt;double&gt;(Param&amp; XParam, BlockP&lt;double&gt;&amp; XBlock);\n\ntemplate &lt;class T&gt; void defncvarBUQ(Param XParam, int* activeblk, int* level, T* blockxo, T* blockyo, std::string varst, int vdim, T* var, outzoneB Xzone)\n{\n    defncvarBUQ(XParam, activeblk, level, blockxo, blockyo, varst, \"\", \"\", \"\", vdim, var, Xzone);\n}\n\ntemplate &lt;class T&gt; void defncvarBUQ(Param XParam, int* activeblk, int* level, T* blockxo, T* blockyo, std::string varst, std::string longname, std::string stdname, std::string unit, int vdim, T* var, outzoneB Xzone)\n{\n\n    int smallnc = XParam.smallnc;\n    float scalefactor = XParam.scalefactor;\n    float addoffset = XParam.addoffset;\n    //int nx = ceil(XParam.nx / 16.0) * 16.0;\n    //int ny = ceil(XParam.ny / 16.0) * 16.0;\n    int status;\n    int ncid, var_id;\n    int  var_dimid2D[2];\n    int  var_dimid3D[3];\n    //int  var_dimid4D[4];\n\n    short* varblk_s;\n    float* varblk;\n    int recid, xid, yid;\n    int bl, ibl, lev;\n    //size_t ntheta;// nx and ny are stored in XParam not yet for ntheta\n\n    float fillval = 9.9692e+36f;\n    short fillval_s = (short)round((9.9692e+36f - addoffset) / scalefactor);\n    //short Sfillval = 32767;\n    //short fillval = 32767\n    static size_t start2D[] = { 0, 0 }; // start at first value \n    //static size_t count2D[] = { ny, nx };\n    static size_t count2D[] = { (size_t)XParam.blkwidth, (size_t)XParam.blkwidth };\n\n    static size_t start3D[] = { 0, 0, 0 }; // start at first value \n    //static size_t count3D[] = { 1, ny, nx };\n    static size_t count3D[] = { 1, (size_t)XParam.blkwidth, (size_t)XParam.blkwidth };\n    //size_t count3D[3];\n    //count3D[0] = 1;\n    //count3D[1] = XParam.blkwidth;\n    //count3D[2] = XParam.blkwidth;\n\n    //int minlevzone, maxlevzone;\n\n    std::string outfile = Xzone.outname;\n    std::vector&lt;int&gt; activeblkzone = Calcactiveblockzone(XParam, activeblk, Xzone);\n    //Calclevelzone(XParam, minlevzone, maxlevzone, Xzone, level);\n\n\n    nc_type VarTYPE;\n\n    if (smallnc &gt; 0)\n    {\n        VarTYPE = NC_SHORT;\n    }\n    else\n    {\n        VarTYPE = NC_FLOAT;\n    }\n\n    //printf(\"\\n ib=%d count3D=[%d,%d,%d]\\n\", count3D[0], count3D[1], count3D[2]);\n\n\n    status = nc_open(outfile.c_str(), NC_WRITE, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    status = nc_redef(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    //Inquire dimensions ids\n    status = nc_inq_unlimdim(ncid, &amp;recid);//time\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    varblk = (float*)malloc(XParam.blkwidth * XParam.blkwidth * sizeof(float));\n    if (smallnc &gt; 0)\n    {\n\n        varblk_s = (short*)malloc(XParam.blkwidth * XParam.blkwidth * sizeof(short));\n    }\n\n\n    std::string xxname, yyname, varname, sign;\n\n    //generate a different variable name for each level and add attribute as necessary\n    for (lev = Xzone.minlevel; lev &lt;= Xzone.maxlevel; lev++)\n    {\n\n        //std::string xxname, yyname, sign;\n\n        lev &lt; 0 ? sign = \"N\" : sign = \"P\";\n\n\n        xxname = \"xx_\" + sign + std::to_string(abs(lev));\n        yyname = \"yy_\" + sign + std::to_string(abs(lev));\n\n        varname = varst + \"_\" + sign + std::to_string(abs(lev));\n\n\n        //printf(\"lev=%d; xxname=%s; yyname=%s;\\n\", lev, xxname.c_str(), yyname.c_str());\n        status = nc_inq_dimid(ncid, xxname.c_str(), &amp;xid);\n        if (status != NC_NOERR) handle_ncerror(status);\n        status = nc_inq_dimid(ncid, yyname.c_str(), &amp;yid);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n\n        var_dimid2D[0] = yid;\n        var_dimid2D[1] = xid;\n\n        var_dimid3D[0] = recid;\n        var_dimid3D[1] = yid;\n        var_dimid3D[2] = xid;\n\n        if (vdim == 2)\n        {\n            status = nc_def_var(ncid, varname.c_str(), VarTYPE, vdim, var_dimid2D, &amp;var_id);\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n        else if (vdim == 3)\n        {\n            status = nc_def_var(ncid, varname.c_str(), VarTYPE, vdim, var_dimid3D, &amp;var_id);\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n\n        if (smallnc &gt; 0)\n        {\n\n            status = nc_put_att_short(ncid, var_id, \"_FillValue\", NC_SHORT, 1, &amp;fillval_s);\n            if (status != NC_NOERR) handle_ncerror(status);\n            status = nc_put_att_short(ncid, var_id, \"missingvalue\", NC_SHORT, 1, &amp;fillval_s);\n\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n        else\n        {\n            status = nc_put_att_float(ncid, var_id, \"_FillValue\", NC_FLOAT, 1, &amp;fillval);\n            if (status != NC_NOERR) handle_ncerror(status);\n            status = nc_put_att_float(ncid, var_id, \"missingvalue\", NC_FLOAT, 1, &amp;fillval);\n\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n\n\n        if (smallnc &gt; 0)\n        {\n\n            status = nc_put_att_float(ncid, var_id, \"scale_factor\", NC_FLOAT, 1, &amp;scalefactor);\n            if (status != NC_NOERR) handle_ncerror(status);\n            status = nc_put_att_float(ncid, var_id, \"add_offset\", NC_FLOAT, 1, &amp;addoffset);\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n\n\n        status = nc_put_att_text(ncid, var_id, \"standard_name\", stdname.size(), stdname.c_str());\n        status = nc_put_att_text(ncid, var_id, \"long_name\", longname.size(), longname.c_str());\n        status = nc_put_att_text(ncid, var_id, \"units\", unit.size(), unit.c_str());\n\n        std::string crsstrname = \"crs\";\n        status = nc_put_att_text(ncid, var_id, \"grid_mapping\", crsstrname.size(), crsstrname.c_str());\n\n\n        int shuffle = 1;\n        int deflate = 1;        // This switches compression on (1) or off (0).\n        int deflate_level = 5;  // This is the compression level in range 1 (less) - 9 (more).\n        nc_def_var_deflate(ncid, var_id, shuffle, deflate, deflate_level);\n\n    }\n    // End definition\n    status = nc_enddef(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //printf(\"\\n ib=%d count3D=[%d,%d,%d]\\n\", count3D[0], count3D[1], count3D[2]);\n\n    // Now write the initial value of the Variable out\n\n    //std::vector&lt;int&gt; activeblkzone = Calcactiveblockzone(XParam, activeblk, Xzone);\n\n    //####################\n    for (ibl = 0; ibl &lt; Xzone.nblk; ibl++)\n    {\n\n        //bl = activeblk[Xzone.blk[ibl]];\n        bl = activeblkzone[ibl];\n        lev = level[bl];\n\n\n        //double xxmax, yymax;\n        double xxmin, yymin;\n        double initdx = calcres(XParam.dx, XParam.initlevel);\n\n\n\n        //xxmax = Xzone.xmax - calcres(XParam.dx, lev) / 2.0;\n        //yymax = Xzone.ymax - calcres(XParam.dx, lev )/2.0;\n\n\n        xxmin = Xzone.xo + calcres(XParam.dx, lev) / 2.0;\n        yymin = Xzone.yo + calcres(XParam.dx, lev) / 2.0;\n        //printf(\"xxmin=%f, yymin=%f, lev=$d \\n\", xxmin, yymin, lev);\n\n        //std::string xxname, yyname, sign;\n\n        lev &lt; 0 ? sign = \"N\" : sign = \"P\";\n\n\n        xxname = \"xx_\" + sign + std::to_string(abs(lev));\n        yyname = \"yy_\" + sign + std::to_string(abs(lev));\n\n        varname = varst + \"_\" + sign + std::to_string(abs(lev));\n        status = nc_inq_dimid(ncid, xxname.c_str(), &amp;xid);\n        if (status != NC_NOERR) handle_ncerror(status);\n        status = nc_inq_dimid(ncid, yyname.c_str(), &amp;yid);\n        if (status != NC_NOERR) handle_ncerror(status);\n        status = nc_inq_varid(ncid, varname.c_str(), &amp;var_id);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = (i + XParam.halowidth + XParam.outishift) + (j + XParam.halowidth + XParam.outjshift) * XParam.blkmemwidth + bl * XParam.blksize;\n                int r = i + j * XParam.blkwidth;\n                if (smallnc &gt; 0)\n                {\n                    // packed_data_value = nint((unpacked_data_value - add_offset) / scale_factor)\n                    varblk_s[r] = (short)round((var[n] - addoffset) / scalefactor);\n                }\n                else\n                {\n                    varblk[r] = (float)var[n];\n                }\n            }\n        }\n        if (vdim == 2)\n        {\n            start2D[0] = (size_t)round((XParam.yo + blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n            start2D[1] = (size_t)round((XParam.xo + blockxo[bl] - xxmin) / calcres(XParam.dx, lev));\n\n            if (smallnc &gt; 0)\n            {\n                status = nc_put_vara_short(ncid, var_id, start2D, count2D, varblk_s);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n            else\n            {\n                status = nc_put_vara_float(ncid, var_id, start2D, count2D, varblk);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n        }\n        else if (vdim == 3)\n        {\n            //\n            start3D[1] = (size_t)round((XParam.yo + blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n            start3D[2] = (size_t)round((XParam.xo + blockxo[bl] - xxmin) / calcres(XParam.dx, lev));\n\n            if (smallnc &gt; 0)\n            {\n                status = nc_put_vara_short(ncid, var_id, start3D, count3D, varblk_s);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n            else\n            {\n                status = nc_put_vara_float(ncid, var_id, start3D, count3D, varblk);\n\n                if (status != NC_NOERR)\n                {\n                    printf(\"\\n ib=%d start=[%d,%d,%d]; initlevel=%d; initdx=%f; level=%d; xo=%f; yo=%f; blockxo[ib]=%f xxmin=%f blockyo[ib]=%f yymin=%f startfl=%f\\n\", bl, (int)start3D[0], (int)start3D[1], (int)start3D[2], XParam.initlevel, initdx, lev, Xzone.xo, Xzone.yo, blockxo[bl], xxmin, blockyo[bl], yymin, (blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n                    //printf(\"\\n varblk[0]=%f varblk[255]=%f\\n\", varblk[0], varblk[255]);\n                    handle_ncerror(status);\n                }\n            }\n\n        }\n\n    }\n\n\n    if (smallnc &gt; 0)\n    {\n\n        free(varblk_s);\n    }\n    free(varblk);\n    //close and save new file\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n}\n\ntemplate void defncvarBUQ&lt;float&gt;(Param XParam, int* activeblk, int* level, float* blockxo, float* blockyo, std::string varst, int vdim, float* var, outzoneB Xzone);\ntemplate void defncvarBUQ&lt;double&gt;(Param XParam, int* activeblk, int* level, double* blockxo, double* blockyo, std::string varst, int vdim, double* var, outzoneB Xzone);\n\ntemplate &lt;class T&gt; void defncvarBUQlev(Param XParam, int* activeblk, int* level, T* blockxo, T* blockyo, std::string varst, std::string longname, std::string stdname, std::string unit, int vdim, T* var, outzoneB Xzone)\n{\n\n    int smallnc = XParam.smallnc;\n    float scalefactor = XParam.scalefactor;\n    float addoffset = XParam.addoffset;\n    //int nx = ceil(XParam.nx / 16.0) * 16.0;\n    //int ny = ceil(XParam.ny / 16.0) * 16.0;\n    int status;\n    int ncid, var_id;\n    int  var_dimid2D[2];\n    int  var_dimid3D[3];\n    //int  var_dimid4D[4];\n\n    short* varblk_s;\n    float* varblk;\n    int recid, xid, yid;\n    int bl, ibl;\n    //size_t ntheta;// nx and ny are stored in XParam not yet for ntheta\n\n    float fillval = 9.9692e+36f;\n    short fillval_s = (short)round((9.9692e+36f - addoffset) / scalefactor);\n    //short Sfillval = 32767;\n    //short fillval = 32767\n    static size_t start2D[] = { 0, 0 }; // start at first value \n    //static size_t count2D[] = { ny, nx };\n    static size_t count2D[] = { (size_t)XParam.blkwidth, (size_t)XParam.blkwidth };\n\n    static size_t start3D[] = { 0, 0, 0 }; // start at first value \n    //static size_t count3D[] = { 1, ny, nx };\n    static size_t count3D[] = { 1, (size_t)XParam.blkwidth, (size_t)XParam.blkwidth };\n    //size_t count3D[3];\n    //count3D[0] = 1;\n    //count3D[1] = XParam.blkwidth;\n    //count3D[2] = XParam.blkwidth;\n\n    //int minlevzone, maxlevzone;\n\n    std::string outfile = Xzone.outname;\n    std::vector&lt;int&gt; activeblkzone = Calcactiveblockzone(XParam, activeblk, Xzone);\n    //Calclevelzone(XParam, minlevzone, maxlevzone, Xzone, level);\n\n\n    nc_type VarTYPE;\n\n    if (smallnc &gt; 0)\n    {\n        VarTYPE = NC_SHORT;\n    }\n    else\n    {\n        VarTYPE = NC_FLOAT;\n    }\n\n    //printf(\"\\n ib=%d count3D=[%d,%d,%d]\\n\", count3D[0], count3D[1], count3D[2]);\n\n\n    status = nc_open(outfile.c_str(), NC_WRITE, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    status = nc_redef(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    //Inquire dimensions ids\n    status = nc_inq_unlimdim(ncid, &amp;recid);//time\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    varblk = (float*)malloc(XParam.blkwidth * XParam.blkwidth * sizeof(float));\n    if (smallnc &gt; 0)\n    {\n\n        varblk_s = (short*)malloc(XParam.blkwidth * XParam.blkwidth * sizeof(short));\n    }\n\n\n    std::string xxname, yyname, varname, sign;\n\n    //generate a different variable name for each level and add attribute as necessary\n    for (int lev = Xzone.minlevel; lev &lt;= Xzone.maxlevel; lev++)\n    {\n\n        //std::string xxname, yyname, sign;\n\n        lev &lt; 0 ? sign = \"N\" : sign = \"P\";\n\n\n        xxname = \"xx_\" + sign + std::to_string(abs(lev));\n        yyname = \"yy_\" + sign + std::to_string(abs(lev));\n\n        varname = varst + \"_\" + sign + std::to_string(abs(lev));\n\n\n        //printf(\"lev=%d; xxname=%s; yyname=%s;\\n\", lev, xxname.c_str(), yyname.c_str());\n        status = nc_inq_dimid(ncid, xxname.c_str(), &amp;xid);\n        if (status != NC_NOERR) handle_ncerror(status);\n        status = nc_inq_dimid(ncid, yyname.c_str(), &amp;yid);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n\n        var_dimid2D[0] = yid;\n        var_dimid2D[1] = xid;\n\n        var_dimid3D[0] = recid;\n        var_dimid3D[1] = yid;\n        var_dimid3D[2] = xid;\n\n        if (vdim == 2)\n        {\n            status = nc_def_var(ncid, varname.c_str(), VarTYPE, vdim, var_dimid2D, &amp;var_id);\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n        else if (vdim == 3)\n        {\n            status = nc_def_var(ncid, varname.c_str(), VarTYPE, vdim, var_dimid3D, &amp;var_id);\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n\n        if (smallnc &gt; 0)\n        {\n\n            status = nc_put_att_short(ncid, var_id, \"_FillValue\", NC_SHORT, 1, &amp;fillval_s);\n            if (status != NC_NOERR) handle_ncerror(status);\n            status = nc_put_att_short(ncid, var_id, \"missingvalue\", NC_SHORT, 1, &amp;fillval_s);\n\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n        else\n        {\n            status = nc_put_att_float(ncid, var_id, \"_FillValue\", NC_FLOAT, 1, &amp;fillval);\n            if (status != NC_NOERR) handle_ncerror(status);\n            status = nc_put_att_float(ncid, var_id, \"missingvalue\", NC_FLOAT, 1, &amp;fillval);\n\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n\n\n        if (smallnc &gt; 0)\n        {\n\n            status = nc_put_att_float(ncid, var_id, \"scale_factor\", NC_FLOAT, 1, &amp;scalefactor);\n            if (status != NC_NOERR) handle_ncerror(status);\n            status = nc_put_att_float(ncid, var_id, \"add_offset\", NC_FLOAT, 1, &amp;addoffset);\n            if (status != NC_NOERR) handle_ncerror(status);\n        }\n\n\n        status = nc_put_att_text(ncid, var_id, \"standard_name\", stdname.size(), stdname.c_str());\n        status = nc_put_att_text(ncid, var_id, \"long_name\", longname.size(), longname.c_str());\n        status = nc_put_att_text(ncid, var_id, \"units\", unit.size(), unit.c_str());\n\n        std::string crsstrname = \"crs\";\n        status = nc_put_att_text(ncid, var_id, \"grid_mapping\", crsstrname.size(), crsstrname.c_str());\n\n\n        int shuffle = 1;\n        int deflate = 1;        // This switches compression on (1) or off (0).\n        int deflate_level = 5;  // This is the compression level in range 1 (less) - 9 (more).\n        nc_def_var_deflate(ncid, var_id, shuffle, deflate, deflate_level);\n\n    }\n    // End definition\n    status = nc_enddef(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    //printf(\"\\n ib=%d count3D=[%d,%d,%d]\\n\", count3D[0], count3D[1], count3D[2]);\n\n    // Now write the initial value of the Variable out\n\n    //std::vector&lt;int&gt; activeblkzone = Calcactiveblockzone(XParam, activeblk, Xzone);\n\n    //####################\n    // Create empty array for each levels\n    std::vector&lt;outP&gt; varlayers;\n    int nx, ny;\n    for (int levi = Xzone.minlevel; levi &lt;= Xzone.maxlevel; levi++)\n    {\n        varlayers.push_back(outP());\n        int levindex = (levi - Xzone.minlevel);\n\n        Calcnxnyzone(XParam, levi, nx, ny, Xzone);\n        varlayers[levindex].z = (float*)malloc(nx * ny * sizeof(float));\n        if (smallnc &gt; 0)\n        {\n\n            varlayers[levindex].z_s = (short*)malloc(nx * ny * sizeof(short));\n        }\n        varlayers[levindex].level = levi;\n\n        for (int j = 0; j &lt; ny; j++)\n        {\n            for (int i = 0; i &lt; nx; i++)\n            {\n                int n = i + j * nx;\n\n                varlayers[levindex].z[n] = fillval;\n                if (smallnc &gt; 0)\n                {\n                    varlayers[levindex].z_s[n] = fillval_s;\n                }\n            }\n        }\n    }\n\n    //std::string xxname, yyname, varname, sign;\n    //std::vector&lt;int&gt; activeblkzone = Calcactiveblockzone(XParam, activeblk, Xzone);\n\n\n    //int lev, bl;\n    for (int ibl = 0; ibl &lt; Xzone.nblk; ibl++)\n    {\n        //bl = activeblk[Xzone.blk[ibl]];\n    //for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    //{\n        bl = activeblkzone[ibl];\n        int lev = level[bl];\n\n        double  xxmin, yymin;\n        int nxlev, nylev;\n        //double xxmax, yymax;\n        double initdx = calcres(XParam.dx, XParam.initlevel);\n\n        int io, jo;\n        //xxmax = Xzone.xmax - calcres(XParam.dx, lev) / 2.0;\n        //yymax = Xzone.ymax - calcres(XParam.dx, lev) / 2.0;\n\n        int levindex = (lev - Xzone.minlevel);\n\n        Calcnxnyzone(XParam, lev, nxlev, nylev, Xzone);\n        xxmin = Xzone.xo + calcres(XParam.dx, lev) / 2.0;\n        yymin = Xzone.yo + calcres(XParam.dx, lev) / 2.0;\n\n\n\n        jo = round((XParam.yo + blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n        io = round((XParam.xo + blockxo[bl] - xxmin) / calcres(XParam.dx, lev));\n\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = (i + XParam.halowidth + XParam.outishift) + (j + XParam.halowidth + XParam.outjshift) * XParam.blkmemwidth + bl * XParam.blksize;\n                int r = (io + i) + (jo + j) * nxlev;\n                if (smallnc &gt; 0)\n                {\n                    // packed_data_value = nint((unpacked_data_value - add_offset) / scale_factor)\n                    varlayers[levindex].z_s[r] = (short)round((var[n] - addoffset) / scalefactor);\n                }\n                else\n                {\n                    varlayers[levindex].z[r] = (float)var[n];\n                }\n            }\n        }\n\n    }\n\n\n    for (int levi = Xzone.minlevel; levi &lt;= Xzone.maxlevel; levi++)\n    {\n        int nxlev, nylev;\n        Calcnxnyzone(XParam, levi, nxlev, nylev, Xzone);\n        //double  xxmin, yymin;\n        levi &lt; 0 ? sign = \"N\" : sign = \"P\";\n        varname = varst + \"_\" + sign + std::to_string(abs(levi));\n\n        status = nc_inq_varid(ncid, varname.c_str(), &amp;var_id);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        //xxmin = Xzone.xo + calcres(XParam.dx, levi) / 2.0;\n        //yymin = Xzone.yo + calcres(XParam.dx, levi) / 2.0;\n\n        int levindex = (levi - Xzone.minlevel);\n\n        if (vdim == 2)\n        {\n\n\n            start2D[0] = 0; // (size_t)round((XParam.yo - yymin) / calcres(XParam.dx, levi));\n            start2D[1] = 0; // (size_t)round((XParam.xo - xxmin) / calcres(XParam.dx, levi));\n\n            count2D[0] = (size_t)nylev;\n            count2D[1] = (size_t)nxlev;\n\n            if (smallnc &gt; 0)\n            {\n\n                status = nc_put_vara_short(ncid, var_id, start2D, count2D, varlayers[levindex].z_s);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n            else\n            {\n                status = nc_put_vara_float(ncid, var_id, start2D, count2D, varlayers[levindex].z);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n        }\n        else if (vdim == 3)\n        {\n            start3D[1] = 0;// (size_t)round((XParam.yo - yymin) / calcres(XParam.dx, levi));\n            start3D[2] = 0;// (size_t)round((XParam.xo - xxmin) / calcres(XParam.dx, levi));\n\n            count3D[1] = (size_t)nylev;\n            count3D[2] = (size_t)nxlev;\n\n            if (smallnc &gt; 0)\n            {\n                status = nc_put_vara_short(ncid, var_id, start3D, count3D, varlayers[levindex].z_s);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n            else\n            {\n                status = nc_put_vara_float(ncid, var_id, start3D, count3D, varlayers[levindex].z);\n                if (status != NC_NOERR) handle_ncerror(status);\n                //printf(\"\\n ib=%d start=[%d,%d,%d]; initlevel=%d; initdx=%f; level=%d; xo=%f; yo=%f; blockxo[ib]=%f xxmin=%f blockyo[ib]=%f yymin=%f startfl=%f\\n\", bl, start3D[0], start3D[1], start3D[2], XParam.initlevel, initdx, lev, Xzone.xo, Xzone.yo, blockxo[bl], xxmin, blockyo[bl], yymin, (blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n                //printf(\"\\n varblk[0]=%f varblk[255]=%f\\n\", varblk[0], varblk[255]);\n                //printf(\"\\n ib=%d count3D=[%d,%d,%d]\\n\", count3D[0], count3D[1], count3D[2]);\n                //printf(\"\\n ib=%d; level=%d; blockxo[ib]=%f blockyo[ib]=%f \\n\", bl, lev, blockxo[bl], blockyo[bl]);\n            }\n\n        }\n\n    }\n\n    for (int levi = Xzone.minlevel; levi &lt;= Xzone.maxlevel; levi++)\n    {\n        int levindex = (levi - Xzone.minlevel);\n        if (smallnc &gt; 0)\n        {\n\n            free(varlayers[levindex].z_s);\n        }\n        free(varlayers[levindex].z);\n    }\n    //close and save new file\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n}\n\n\n\ntemplate &lt;class T&gt; void writencvarstepBUQ(Param XParam, int vdim, int* activeblk, int* level, T* blockxo, T* blockyo, std::string varst, T* var, outzoneB Xzone)\n{\n    int status, ncid, recid, var_id;\n    static size_t nrec;\n    short* varblk_s;\n    float* varblk;\n    //int nx, ny;\n    //int dimids[NC_MAX_VAR_DIMS];\n    //size_t  *ddim, *start, *count;\n    //XParam.outfile.c_str()\n\n    static size_t start2D[] = { 0, 0 }; // start at first value \n    //static size_t count2D[] = { ny, nx };\n    static size_t count2D[] = { (size_t)XParam.blkwidth, (size_t)XParam.blkwidth };\n\n    static size_t start3D[] = { 0, 0, 0 }; // start at first value // This is updated to nrec-1 further down\n    //static size_t count3D[] = { 1, ny, nx };\n    static size_t count3D[] = { 1, (size_t)XParam.blkwidth, (size_t)XParam.blkwidth };\n\n    int smallnc = XParam.smallnc;\n    float scalefactor = XParam.scalefactor;\n    float addoffset = XParam.addoffset;\n\n    status = nc_open(Xzone.outname.c_str(), NC_WRITE, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    //read id from time dimension\n    status = nc_inq_unlimdim(ncid, &amp;recid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    status = nc_inq_dimlen(ncid, recid, &amp;nrec);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    start3D[0] = nrec - 1;\n\n    varblk = (float*)malloc(XParam.blkwidth * XParam.blkwidth * sizeof(float));\n    if (smallnc &gt; 0)\n    {\n\n        varblk_s = (short*)malloc(XParam.blkwidth * XParam.blkwidth * sizeof(short));\n    }\n\n\n    std::string xxname, yyname, varname, sign;\n    std::vector&lt;int&gt; activeblkzone = Calcactiveblockzone(XParam, activeblk, Xzone);\n\n\n    int lev, bl;\n    for (int ibl = 0; ibl &lt; Xzone.nblk; ibl++)\n    {\n        //bl = activeblk[Xzone.blk[ibl]];\n    //for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    //{\n        bl = activeblkzone[ibl];\n        lev = level[bl];\n        lev &lt; 0 ? sign = \"N\" : sign = \"P\";\n        double  xxmin, yymin;\n        //double xxmax, yymax;\n        double initdx = calcres(XParam.dx, XParam.initlevel);\n\n\n        //xxmax = Xzone.xmax - calcres(XParam.dx, lev) / 2.0;\n        //yymax = Xzone.ymax - calcres(XParam.dx, lev) / 2.0;\n\n\n        xxmin = Xzone.xo + calcres(XParam.dx, lev) / 2.0;\n        yymin = Xzone.yo + calcres(XParam.dx, lev) / 2.0;\n\n        varname = varst + \"_\" + sign + std::to_string(abs(lev));\n\n\n        status = nc_inq_varid(ncid, varname.c_str(), &amp;var_id);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = (i + XParam.halowidth + XParam.outishift) + (j + XParam.halowidth + XParam.outjshift) * XParam.blkmemwidth + bl * XParam.blksize;\n                int r = i + j * XParam.blkwidth;\n                if (smallnc &gt; 0)\n                {\n                    // packed_data_value = nint((unpacked_data_value - add_offset) / scale_factor)\n                    varblk_s[r] = (short)round((var[n] - addoffset) / scalefactor);\n                }\n                else\n                {\n                    varblk[r] = (float)var[n];\n                }\n            }\n        }\n        if (vdim == 2)\n        {\n            start2D[0] = (size_t)round((XParam.yo + blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n            start2D[1] = (size_t)round((XParam.xo + blockxo[bl] - xxmin) / calcres(XParam.dx, lev));\n\n            if (smallnc &gt; 0)\n            {\n\n\n                status = nc_put_vara_short(ncid, var_id, start2D, count2D, varblk_s);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n            else\n            {\n                status = nc_put_vara_float(ncid, var_id, start2D, count2D, varblk);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n        }\n        else if (vdim == 3)\n        {\n            start3D[1] = (size_t)round((XParam.yo + blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n            start3D[2] = (size_t)round((XParam.xo + blockxo[bl] - xxmin) / calcres(XParam.dx, lev));\n            if (smallnc &gt; 0)\n            {\n                status = nc_put_vara_short(ncid, var_id, start3D, count3D, varblk_s);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n            else\n            {\n                status = nc_put_vara_float(ncid, var_id, start3D, count3D, varblk);\n                if (status != NC_NOERR) handle_ncerror(status);\n                //printf(\"\\n ib=%d start=[%d,%d,%d]; initlevel=%d; initdx=%f; level=%d; xo=%f; yo=%f; blockxo[ib]=%f xxmin=%f blockyo[ib]=%f yymin=%f startfl=%f\\n\", bl, start3D[0], start3D[1], start3D[2], XParam.initlevel, initdx, lev, Xzone.xo, Xzone.yo, blockxo[bl], xxmin, blockyo[bl], yymin, (blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n                //printf(\"\\n varblk[0]=%f varblk[255]=%f\\n\", varblk[0], varblk[255]);\n                //printf(\"\\n ib=%d count3D=[%d,%d,%d]\\n\", count3D[0], count3D[1], count3D[2]);\n                //printf(\"\\n ib=%d; level=%d; blockxo[ib]=%f blockyo[ib]=%f \\n\", bl, lev, blockxo[bl], blockyo[bl]);\n            }\n\n        }\n\n    }\n\n\n    if (smallnc &gt; 0)\n    {\n\n        free(varblk_s);\n    }\n    free(varblk);\n    //close and save new file\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n}\n\n// Scope for compiler to know what function to compile\n\ntemplate void writencvarstepBUQ&lt;float&gt;(Param XParam, int vdim, int* activeblk, int* level, float* blockxo, float* blockyo, std::string varst, float* var, outzoneB Xzone);\ntemplate void writencvarstepBUQ&lt;double&gt;(Param XParam, int vdim, int* activeblk, int* level, double* blockxo, double* blockyo, std::string varst, double* var, outzoneB Xzone);\n\nextern \"C\" void writenctimestep(std::string outfile, double totaltime)\n{\n    int status, ncid, recid, time_id;\n    status = nc_open(outfile.c_str(), NC_WRITE, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    static size_t nrec;\n    static size_t tst[] = { 0 };\n    //read id from time dimension\n    status = nc_inq_unlimdim(ncid, &amp;recid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    status = nc_inq_dimlen(ncid, recid, &amp;nrec);\n    if (status != NC_NOERR) handle_ncerror(status);\n    status = nc_inq_varid(ncid, \"time\", &amp;time_id);\n    if (status != NC_NOERR) handle_ncerror(status);\n    tst[0] = nrec;\n    status = nc_put_var1_double(ncid, time_id, tst, &amp;totaltime);\n    if (status != NC_NOERR) handle_ncerror(status);\n    //close and save\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n}\n\ntemplate &lt;class T&gt; void writencvarstepBUQlev(Param XParam, int vdim, int* activeblk, int* level, T* blockxo, T* blockyo, std::string varst, T* var, outzoneB Xzone)\n{\n    int status, ncid, recid, var_id;\n    static size_t nrec;\n    short* varblk_s;\n    float* varblk;\n    //int nx, ny;\n    //int dimids[NC_MAX_VAR_DIMS];\n    //size_t  *ddim, *start, *count;\n    //XParam.outfile.c_str()\n\n\n    float fillval = 9.9692e+36f;\n    short fillval_s = (short)round((9.9692e+36f - XParam.addoffset) / XParam.scalefactor);\n\n    static size_t start2D[] = { 0, 0 }; // start at first value \n    //static size_t count2D[] = { ny, nx };\n    static size_t count2D[] = { (size_t)XParam.blkwidth, (size_t)XParam.blkwidth };\n\n    static size_t start3D[] = { 0, 0, 0 }; // start at first value // This is updated to nrec-1 further down\n    //static size_t count3D[] = { 1, ny, nx };\n    static size_t count3D[] = { 1, (size_t)XParam.blkwidth, (size_t)XParam.blkwidth };\n\n    int smallnc = XParam.smallnc;\n    float scalefactor = XParam.scalefactor;\n    float addoffset = XParam.addoffset;\n\n    status = nc_open(Xzone.outname.c_str(), NC_WRITE, &amp;ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    //read id from time dimension\n    status = nc_inq_unlimdim(ncid, &amp;recid);\n    if (status != NC_NOERR) handle_ncerror(status);\n    status = nc_inq_dimlen(ncid, recid, &amp;nrec);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n    start3D[0] = nrec - 1;\n\n\n    // Create empty array for each levels\n    std::vector&lt;outP&gt; varlayers;\n    int nx, ny;\n    for (int levi = Xzone.minlevel; levi &lt;= Xzone.maxlevel; levi++)\n    {\n        varlayers.push_back(outP());\n        int levindex = (levi - Xzone.minlevel);\n\n        Calcnxnyzone(XParam, levi, nx, ny, Xzone);\n        varlayers[levindex].z = (float*)malloc(nx * ny * sizeof(float));\n        if (smallnc &gt; 0)\n        {\n\n            varlayers[levindex].z_s = (short*)malloc(nx * ny * sizeof(short));\n        }\n        varlayers[levindex].level = levi;\n\n        for (int j = 0; j &lt; ny; j++)\n        {\n            for (int i = 0; i &lt; nx; i++)\n            {\n                int n = i + j * nx;\n\n                varlayers[levindex].z[n] = fillval;\n                if (smallnc &gt; 0)\n                {\n                    varlayers[levindex].z_s[n] = fillval_s;\n                }\n            }\n        }\n    }\n\n    std::string xxname, yyname, varname, sign;\n    std::vector&lt;int&gt; activeblkzone = Calcactiveblockzone(XParam, activeblk, Xzone);\n\n\n    int lev, bl;\n    for (int ibl = 0; ibl &lt; Xzone.nblk; ibl++)\n    {\n        //bl = activeblk[Xzone.blk[ibl]];\n    //for (int ibl = 0; ibl &lt; XParam.nblk; ibl++)\n    //{\n        bl = activeblkzone[ibl];\n        lev = level[bl];\n\n        double  xxmin, yymin;\n        int nxlev, nylev;\n        //double xxmax, yymax;\n        double initdx = calcres(XParam.dx, XParam.initlevel);\n\n        int io, jo;\n        //xxmax = Xzone.xmax - calcres(XParam.dx, lev) / 2.0;\n        //yymax = Xzone.ymax - calcres(XParam.dx, lev) / 2.0;\n\n        int levindex = (lev - Xzone.minlevel);\n\n        Calcnxnyzone(XParam, lev, nxlev, nylev, Xzone);\n        xxmin = Xzone.xo + calcres(XParam.dx, lev) / 2.0;\n        yymin = Xzone.yo + calcres(XParam.dx, lev) / 2.0;\n\n\n\n        jo = round((XParam.yo + blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n        io = round((XParam.xo + blockxo[bl] - xxmin) / calcres(XParam.dx, lev));\n\n\n        for (int j = 0; j &lt; XParam.blkwidth; j++)\n        {\n            for (int i = 0; i &lt; XParam.blkwidth; i++)\n            {\n                int n = (i + XParam.halowidth + XParam.outishift) + (j + XParam.halowidth + XParam.outjshift) * XParam.blkmemwidth + bl * XParam.blksize;\n                int r = (io + i) + (jo + j) * nxlev;\n                if (smallnc &gt; 0)\n                {\n                    // packed_data_value = nint((unpacked_data_value - add_offset) / scale_factor)\n                    varlayers[levindex].z_s[r] = (short)round((var[n] - addoffset) / scalefactor);\n                }\n                else\n                {\n                    varlayers[levindex].z[r] = (float)var[n];\n                }\n            }\n        }\n\n    }\n\n\n    for (int levi = Xzone.minlevel; levi &lt;= Xzone.maxlevel; levi++)\n    {\n        int nxlev, nylev;\n        Calcnxnyzone(XParam, levi, nxlev, nylev, Xzone);\n        //double  xxmin, yymin;\n        levi &lt; 0 ? sign = \"N\" : sign = \"P\";\n        varname = varst + \"_\" + sign + std::to_string(abs(levi));\n\n        status = nc_inq_varid(ncid, varname.c_str(), &amp;var_id);\n        if (status != NC_NOERR) handle_ncerror(status);\n\n        //xxmin = Xzone.xo + calcres(XParam.dx, levi) / 2.0;\n        //yymin = Xzone.yo + calcres(XParam.dx, levi) / 2.0;\n\n        int levindex = (levi - Xzone.minlevel);\n\n        if (vdim == 2)\n        {\n\n\n            start2D[0] = 0; // (size_t)round((XParam.yo - yymin) / calcres(XParam.dx, levi));\n            start2D[1] = 0; // (size_t)round((XParam.xo - xxmin) / calcres(XParam.dx, levi));\n\n            count2D[0] = (size_t)nylev;\n            count2D[1] = (size_t)nxlev;\n\n            if (smallnc &gt; 0)\n            {\n\n                status = nc_put_vara_short(ncid, var_id, start2D, count2D, varlayers[levindex].z_s);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n            else\n            {\n                status = nc_put_vara_float(ncid, var_id, start2D, count2D, varlayers[levindex].z);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n        }\n        else if (vdim == 3)\n        {\n            start3D[1] = 0;// (size_t)round((XParam.yo - yymin) / calcres(XParam.dx, levi));\n            start3D[2] = 0;// (size_t)round((XParam.xo - xxmin) / calcres(XParam.dx, levi));\n\n            count3D[1] = (size_t)nylev;\n            count3D[2] = (size_t)nxlev;\n\n            if (smallnc &gt; 0)\n            {\n                status = nc_put_vara_short(ncid, var_id, start3D, count3D, varlayers[levindex].z_s);\n                if (status != NC_NOERR) handle_ncerror(status);\n            }\n            else\n            {\n                status = nc_put_vara_float(ncid, var_id, start3D, count3D, varlayers[levindex].z);\n                if (status != NC_NOERR) handle_ncerror(status);\n                //printf(\"\\n ib=%d start=[%d,%d,%d]; initlevel=%d; initdx=%f; level=%d; xo=%f; yo=%f; blockxo[ib]=%f xxmin=%f blockyo[ib]=%f yymin=%f startfl=%f\\n\", bl, start3D[0], start3D[1], start3D[2], XParam.initlevel, initdx, lev, Xzone.xo, Xzone.yo, blockxo[bl], xxmin, blockyo[bl], yymin, (blockyo[bl] - yymin) / calcres(XParam.dx, lev));\n                //printf(\"\\n varblk[0]=%f varblk[255]=%f\\n\", varblk[0], varblk[255]);\n                //printf(\"\\n ib=%d count3D=[%d,%d,%d]\\n\", count3D[0], count3D[1], count3D[2]);\n                //printf(\"\\n ib=%d; level=%d; blockxo[ib]=%f blockyo[ib]=%f \\n\", bl, lev, blockxo[bl], blockyo[bl]);\n            }\n\n        }\n\n    }\n\n    for (int levi = Xzone.minlevel; levi &lt;= Xzone.maxlevel; levi++)\n    {\n        int levindex = (levi - Xzone.minlevel);\n        if (smallnc &gt; 0)\n        {\n\n            free(varlayers[levindex].z_s);\n        }\n        free(varlayers[levindex].z);\n    }\n    //close and save new file\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n}\n\n// Scope for compiler to know what function to compile\n\ntemplate void writencvarstepBUQlev&lt;float&gt;(Param XParam, int vdim, int* activeblk, int* level, float* blockxo, float* blockyo, std::string varst, float* var, outzoneB Xzone);\ntemplate void writencvarstepBUQlev&lt;double&gt;(Param XParam, int vdim, int* activeblk, int* level, double* blockxo, double* blockyo, std::string varst, double* var, outzoneB Xzone);\n\n\n\n//Initialise netcdf files\ntemplate &lt;class T&gt; void InitSave2Netcdf(Param&amp; XParam, Model&lt;T&gt;&amp; XModel)\n{\n    if (!XParam.outvars.empty())\n    {\n        log(\"Create netCDF output file...\");\n        creatncfileBUQ(XParam, XModel.blocks);\n        //creatncfileBUQ(XParam);\n        /*for (int o = 0; o &lt; XModel.blocks.outZone.size(); o++)\n        {\n            writenctimestep(XModel.blocks.outZone[o].outname, XParam.totaltime);\n            for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n            {\n                std::string varstr = XParam.outvars[ivar];\n                if (XParam.savebyblk)\n                {\n                    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, varstr, XModel.Outvarlongname[varstr], XModel.Outvarstdname[varstr], XModel.Outvarunits[varstr], 3, XModel.OutputVarMap[varstr], XModel.blocks.outZone[o]);\n\n                }\n                else\n                {\n                    defncvarBUQlev(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, varstr, XModel.Outvarlongname[varstr], XModel.Outvarstdname[varstr], XModel.Outvarunits[varstr], 3, XModel.OutputVarMap[varstr], XModel.blocks.outZone[o]);\n\n                }\n            }\n        }*/\n    }\n}\ntemplate void InitSave2Netcdf&lt;float&gt;(Param&amp; XParam, Model&lt;float&gt;&amp; XModel);\ntemplate void InitSave2Netcdf&lt;double&gt;(Param&amp; XParam, Model&lt;double&gt;&amp; XModel);\n\n//Save initialisation in maps outpout if require\n/*template &lt;class T&gt; void SaveInitialisation2Netcdf(Param&amp; XParam, Model&lt;T&gt;&amp; XModel)\n{\n    double NextZoneOutTime;\n\n    if (!XParam.outvars.empty())\n    {\n        for (int o = 0; o &lt; XModel.blocks.outZone.size(); o++)\n        {\n            NextZoneOutTime = XModel.blocks.outZone[o].OutputT[XModel.blocks.outZone[o].index_next_OutputT];\n            if (XParam.totaltime == NextZoneOutTime)\n            {\n                log(\"Output to map: \" + XModel.blocks.outZone[o].outname + \", Totaltime = \" + std::to_string(XParam.totaltime) + \" s; Initialisation\");\n\n                writenctimestep(XModel.blocks.outZone[o].outname, XParam.totaltime);\n                for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n                {\n                    std::string varstr = XParam.outvars[ivar];\n                    defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, varstr, XModel.Outvarlongname[varstr], XModel.Outvarstdname[varstr], XModel.Outvarunits[varstr], 3, XModel.OutputVarMap[varstr], XModel.blocks.outZone[o]);\n                }\n                XModel.blocks.outZone[o].index_next_OutputT++;\n            }\n\n\n        }\n    }\n}\ntemplate void SaveInitialisation2Netcdf&lt;float&gt;(Param&amp; XParam, Model&lt;float&gt;&amp; XModel);\ntemplate void SaveInitialisation2Netcdf&lt;double&gt;(Param&amp; XParam, Model&lt;double&gt;&amp; XModel);\n*/\n\ntemplate &lt;class T&gt; void Save2Netcdf(Param XParam, Loop&lt;T&gt; XLoop, Model&lt;T&gt;&amp; XModel)\n{\n    double NextZoneOutTime;\n    double tiny = 0.0000001;\n\n    char buffer[256];\n    double meanTspeps = (XModel.OutputT[XLoop.indNextoutputtime] - XModel.OutputT[XLoop.indNextoutputtime - T(1)]) / XLoop.nstepout;\n    sprintf(buffer, \"%e\", meanTspeps);\n    std::string str(buffer);\n    //std::string maps;\n\n    if (!XParam.outvars.empty())\n    {\n        for (int o = 0; o &lt; XModel.blocks.outZone.size(); o++)\n        {\n            int indLoc = min(XModel.blocks.outZone[o].index_next_OutputT, (int(XModel.blocks.outZone[o].OutputT.size() - 1)));\n            NextZoneOutTime = XModel.blocks.outZone[o].OutputT[indLoc];\n            if (abs(XLoop.nextoutputtime - NextZoneOutTime) &lt; tiny)\n            {\n                log(\"Output to map: \" + XModel.blocks.outZone[o].outname + \", Totaltime = \" + std::to_string(XLoop.totaltime) + \" s; Mean dt = \" + str + \" s\");\n\n                writenctimestep(XModel.blocks.outZone[o].outname, XLoop.totaltime);\n                for (int ivar = 0; ivar &lt; XParam.outvars.size(); ivar++)\n                {\n                    if (XModel.blocks.outZone[o].index_next_OutputT == 0)//first time output\n                    {\n                        std::string varstr = XParam.outvars[ivar];\n                        defncvarBUQ(XParam, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, varstr, XModel.Outvarlongname[varstr], XModel.Outvarstdname[varstr], XModel.Outvarunits[varstr], 3, XModel.OutputVarMap[varstr], XModel.blocks.outZone[o]);\n                    }\n                    else\n                    {\n                        if (XParam.savebyblk)\n                        {\n                            writencvarstepBUQ(XParam, 3, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, XParam.outvars[ivar], XModel.OutputVarMap[XParam.outvars[ivar]], XModel.blocks.outZone[o]);\n                        }\n                        else\n                        {\n                            writencvarstepBUQlev(XParam, 3, XModel.blocks.active, XModel.blocks.level, XModel.blocks.xo, XModel.blocks.yo, XParam.outvars[ivar], XModel.OutputVarMap[XParam.outvars[ivar]], XModel.blocks.outZone[o]);\n                        }\n                    }\n                }\n                XModel.blocks.outZone[o].index_next_OutputT++;\n            }\n        }\n    }\n    //maps.erase(maps.size() - 2);\n}\ntemplate void Save2Netcdf&lt;float&gt;(Param XParam, Loop&lt;float&gt; XLoop, Model&lt;float&gt;&amp; XModel);\ntemplate void Save2Netcdf&lt;double&gt;(Param XParam, Loop&lt;double&gt; XLoop, Model&lt;double&gt;&amp; XModel);\n\n\n//The following functions are tools to create 2D or 3D netcdf files (for testing for example)\n\nextern \"C\" void create2dnc(char* filename, int nx, int ny, double* xx, double* yy, double* var, char* varname)\n{\n    int status;\n    int ncid, xx_dim, yy_dim, tvar_id;\n\n    size_t nxx, nyy;\n    static size_t start[] = { 0, 0 }; // start at first value\n    static size_t count[] = { (size_t)ny, (size_t)nx };\n    int xx_id, yy_id; //\n    nxx = nx;\n    nyy = ny;\n\n    //create the netcdf dataset\n    status = nc_create(filename, NC_CLOBBER, &amp;ncid);\n\n    //Define dimensions: Name and length\n\n    status = nc_def_dim(ncid, \"xx\", nxx, &amp;xx_dim);\n    status = nc_def_dim(ncid, \"yy\", nyy, &amp;yy_dim);\n    int xdim[] = { xx_dim };\n    int ydim[] = { yy_dim };\n\n    //define variables: Name, Type,...\n    int var_dimids[3];\n    var_dimids[0] = yy_dim;\n    var_dimids[1] = xx_dim;\n\n    status = nc_def_var(ncid, \"xx\", NC_DOUBLE, 1, xdim, &amp;xx_id);\n    status = nc_def_var(ncid, \"yy\", NC_DOUBLE, 1, ydim, &amp;yy_id);\n\n\n    status = nc_def_var(ncid, varname, NC_DOUBLE, 2, var_dimids, &amp;tvar_id);\n\n    status = nc_enddef(ncid);\n\n    static size_t xstart[] = { 0 }; // start at first value\n    static size_t xcount[] = { (size_t)nx };\n\n    static size_t ystart[] = { 0 }; // start at first value\n    static size_t ycount[] = { (size_t)ny };\n\n\n\n    //Provide values for variables\n    status = nc_put_vara_double(ncid, xx_id, xstart, xcount, xx);\n    status = nc_put_vara_double(ncid, yy_id, ystart, ycount, yy);\n\n    status = nc_put_vara_double(ncid, tvar_id, start, count, var);\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n}\n\n//Create a ncdf file containing a 3D variable (the file is overwritten if it was existing before)\nextern \"C\" void create3dnc(char* name, int nx, int ny, int nt, double* xx, double* yy, double* theta, double* var, char* varname)\n{\n    int status;\n    int ncid, xx_dim, yy_dim, tt_dim, tvar_id;\n    size_t nxx, nyy, ntt;\n    static size_t start[] = { 0, 0, 0 }; // start at first value\n    static size_t count[] = { (size_t)nt, (size_t)ny, (size_t)nx };\n    int xx_id, yy_id, tt_id; //\n    nxx = nx;\n    nyy = ny;\n    ntt = nt;\n\n    //create the netcdf dataset\n    status = nc_create(name, NC_CLOBBER, &amp;ncid);\n    //Define dimensions: Name and length\n    status = nc_def_dim(ncid, \"xx\", nxx, &amp;xx_dim);\n    status = nc_def_dim(ncid, \"yy\", nyy, &amp;yy_dim);\n    status = nc_def_dim(ncid, \"time\", ntt, &amp;tt_dim);\n    int xdim[] = { xx_dim };\n    int ydim[] = { yy_dim };\n    int tdim[] = { tt_dim };\n\n    //define variables: Name, Type,...\n    int var_dimids[3];\n    var_dimids[0] = tt_dim;\n    var_dimids[1] = yy_dim;\n    var_dimids[2] = xx_dim;\n\n    status = nc_def_var(ncid, \"time\", NC_DOUBLE, 1, tdim, &amp;tt_id);\n    status = nc_def_var(ncid, \"xx\", NC_DOUBLE, 1, xdim, &amp;xx_id);\n    status = nc_def_var(ncid, \"yy\", NC_DOUBLE, 1, ydim, &amp;yy_id);\n\n    status = nc_def_var(ncid, varname, NC_DOUBLE, 3, var_dimids, &amp;tvar_id);\n\n    status = nc_enddef(ncid);\n\n    //static size_t tst[] = { 0 };\n    static size_t xstart[] = { 0 }; // start at first value\n    static size_t xcount[] = { (size_t)nx };\n    static size_t ystart[] = { 0 }; // start at first value\n    static size_t ycount[] = { (size_t)ny };\n\n    static size_t tstart[] = { 0 }; // start at first value\n    static size_t tcount[] = { (size_t)nt };\n\n    //Provide values for variables\n    status = nc_put_vara_double(ncid, xx_id, xstart, xcount, xx);\n    status = nc_put_vara_double(ncid, yy_id, ystart, ycount, yy);\n    status = nc_put_vara_double(ncid, tt_id, tstart, tcount, theta);\n\n    status = nc_put_vara_double(ncid, tvar_id, start, count, var);\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n}\n\nextern \"C\" void write3dvarnc(int nx, int ny, int nt, double totaltime, double* var)\n{\n    int status;\n    int ncid, recid;\n    //size_t nxx, nyy;\n    static size_t start[] = { 0, 0, 0, 0 }; // start at first value\n    static size_t count[] = { 1, (size_t)nt, (size_t)ny, (size_t)nx };\n    static size_t tst[] = { 0 };\n    int time_id, var_id;\n\n    //nxx = nx;\n    //nyy = ny;\n\n    static size_t nrec;\n    status = nc_open(\"3Dvar.nc\", NC_WRITE, &amp;ncid);\n    //read id from time dimension\n    status = nc_inq_unlimdim(ncid, &amp;recid);\n    status = nc_inq_dimlen(ncid, recid, &amp;nrec);\n    //printf(\"nrec=%d\\n\",nrec);\n\n     //read file for variable ids\n    status = nc_inq_varid(ncid, \"time\", &amp;time_id);\n    status = nc_inq_varid(ncid, \"3Dvar\", &amp;var_id);\n    start[0] = nrec;//\n    tst[0] = nrec;\n\n    //Provide values for variables\n    status = nc_put_var1_double(ncid, time_id, tst, &amp;totaltime);\n    status = nc_put_vara_double(ncid, var_id, start, count, var);\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n}\n\nextern \"C\" void write2dvarnc(int nx, int ny, double totaltime, double* var)\n{\n    int status;\n    int ncid, recid;\n    //size_t nxx, nyy;\n    static size_t start[] = { 0, 0, 0 }; // start at first value\n    static size_t count[] = { 1, (size_t)ny, (size_t)nx };\n    static size_t tst[] = { 0 };\n    int time_id, var_id;\n\n    //nxx = nx;\n    //nyy = ny;\n\n    static size_t nrec;\n    status = nc_open(\"3Dvar.nc\", NC_WRITE, &amp;ncid);\n\n    //read id from time dimension\n    status = nc_inq_unlimdim(ncid, &amp;recid);\n    status = nc_inq_dimlen(ncid, recid, &amp;nrec);\n    //printf(\"nrec=%d\\n\",nrec);\n\n     //read file for variable ids\n    status = nc_inq_varid(ncid, \"time\", &amp;time_id);\n    status = nc_inq_varid(ncid, \"3Dvar\", &amp;var_id);\n\n    start[0] = nrec;//\n    tst[0] = nrec;\n\n    //Provide values for variables\n    status = nc_put_var1_double(ncid, time_id, tst, &amp;totaltime);\n    status = nc_put_vara_double(ncid, var_id, start, count, var);\n    status = nc_close(ncid);\n    if (status != NC_NOERR) handle_ncerror(status);\n\n}\n</code></pre>"},{"location":"BGFlood/_write__netcdf_8h/","title":"File Write_netcdf.h","text":""},{"location":"BGFlood/_write__netcdf_8h/#file-write_netcdfh","title":"File Write_netcdf.h","text":"<p>FileList &gt; src &gt; Write_netcdf.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> <li><code>#include \"Write_txtlog.h\"</code></li> <li><code>#include \"ReadInput.h\"</code></li> <li><code>#include \"MemManagement.h\"</code></li> <li><code>#include \"Util_CPU.h\"</code></li> <li><code>#include \"Arrays.h\"</code></li> </ul>"},{"location":"BGFlood/_write__netcdf_8h/#public-functions","title":"Public Functions","text":"Type Name void InitSave2Netcdf (Param &amp; XParam, Model&lt; T &gt; &amp; XModel) Initialize NetCDF output files for the model. Initializes NetCDF output files for the model based on the provided parameters and model configuration. If output variables are specified in the parameters, it creates the necessary NetCDF files and defines the variables to be saved. void Save2Netcdf (Param XParam, Loop&lt; T &gt; XLoop, Model&lt; T &gt; &amp; XModel) Save model output to NetCDF files at specified output times. Saves model output to NetCDF files at specified output times based on the provided parameters. It checks if the current output time matches the next scheduled output time for each output zone, and if so, writes the relevant variables to the corresponding NetCDF files. void create2dnc (char * filename, int nx, int ny, double * xx, double * yy, double * var, char * varname) Create a NetCDF file containing a 2D variable, for testing for example. Creates a NetCDF file containing a 2D variable with the specified dimensions and data. If the file already exists, it will be overwritten. void create3dnc (char * name, int nx, int ny, int nt, double * xx, double * yy, double * theta, double * var, char * varname) Create a NetCDF file containing a 3D variable, for testing for example. Creates a NetCDF file containing a 3D variable with the specified dimensions and data. If the file already exists, it will be overwritten. void creatncfileBUQ (Param &amp; XParam, int * activeblk, int * level, T * blockxo, T * blockyo, outzoneB &amp; Xzone) Create a NetCDF file for BG-Flood output. Creates a NetCDF file for BG-Flood output based on the provided parameters and zone information. void creatncfileBUQ (Param &amp; XParam, BlockP&lt; T &gt; &amp; XBlock) Create NetCDF files for all output zones in a block. Creates NetCDF files for all output zones defined in the block using the provided parameters and block information. void defncvarBUQ (Param XParam, int * activeblk, int * level, T * blockxo, T * blockyo, std::string varst, int vdim, T * var, outzoneB Xzone) Define a NetCDF variable for BG-Flood output. Defines a NetCDF variable for BG-Flood output based on the provided parameters, block information and zone information. void handle_ncerror (int status) Handle NetCDF errors. void write2dvarnc (int nx, int ny, double totaltime, double * var) Write a time step of a 2D variable to an existing NetCDF file, for testing for example. Writes a time step of a 2D variable to an existing NetCDF file by appending the provided variable data at the next available time index. void write3dvarnc (int nx, int ny, int nt, double totaltime, double * var) Write a time step of a 3D variable to an existing NetCDF file, for testing for example. Writes a time step of a 3D variable to an existing NetCDF file by appending the provided variable data at the next available time index. void writenctimestep (std::string outfile, double totaltime) Write the current time step to a NetCDF file. Writes the current time step to a NetCDF file by updating the \"time\" variable with the provided total time value. void writencvarstepBUQ (Param XParam, int vdim, int * activeblk, int * level, T * blockxo, T * blockyo, std::string varst, T * var, outzoneB Xzone) Write a time step of a NetCDF variable for BG-Flood output. Writes a time step of a NetCDF variable for BG-Flood output based on the provided parameters, block information, variable data, and zone information."},{"location":"BGFlood/_write__netcdf_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_write__netcdf_8h/#function-initsave2netcdf","title":"function InitSave2Netcdf","text":"<p>Initialize NetCDF output files for the model. Initializes NetCDF output files for the model based on the provided parameters and model configuration. If output variables are specified in the parameters, it creates the necessary NetCDF files and defines the variables to be saved. </p><pre><code>template&lt;class T&gt;\nvoid InitSave2Netcdf (\n    Param &amp; XParam,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings and model parameters. </li> <li><code>XModel</code> The model object containing block information and output variable mappings. </li> </ul> <p>Note:</p> <p>This is a templated function that can handle different data types for the model (e.g., float, double). </p> <p>See also: creatncfileBUQ for creating the NetCDF file and defining variables. </p>"},{"location":"BGFlood/_write__netcdf_8h/#function-save2netcdf","title":"function Save2Netcdf","text":"<p>Save model output to NetCDF files at specified output times. Saves model output to NetCDF files at specified output times based on the provided parameters. It checks if the current output time matches the next scheduled output time for each output zone, and if so, writes the relevant variables to the corresponding NetCDF files. </p><pre><code>template&lt;class T&gt;\nvoid Save2Netcdf (\n    Param XParam,\n    Loop &lt; T &gt; XLoop,\n    Model &lt; T &gt; &amp; XModel\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings and model parameters. </li> <li><code>XLoop</code> The loop object containing time-stepping information. </li> <li><code>XModel</code> The model object containing block information and output variable mappings. </li> </ul> <p>Note:</p> <p>This is a templated function that can handle different data types for the model (e.g., float, double). </p> <p>See also: writenctimestep for writing the time step to the NetCDF file. </p>"},{"location":"BGFlood/_write__netcdf_8h/#function-create2dnc","title":"function create2dnc","text":"<p>Create a NetCDF file containing a 2D variable, for testing for example. Creates a NetCDF file containing a 2D variable with the specified dimensions and data. If the file already exists, it will be overwritten. </p><pre><code>void create2dnc (\n    char * filename,\n    int nx,\n    int ny,\n    double * xx,\n    double * yy,\n    double * var,\n    char * varname\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> The name of the NetCDF file to be created.</li> <li><code>nx</code> The number of grid points in the x-direction. </li> <li><code>ny</code> The number of grid points in the y-direction. </li> <li><code>xx</code> Pointer to an array containing the x-coordinates of the grid points. </li> <li><code>yy</code> Pointer to an array containing the y-coordinates of the grid points. </li> <li><code>var</code> Pointer to an array containing the 2D variable data to be stored in the NetCDF file. </li> <li><code>varname</code> The name of the variable to be stored in the NetCDF file. </li> </ul> <p>Note:</p> <p>This function uses the NetCDF C library to create and write to the NetCDF file. </p>"},{"location":"BGFlood/_write__netcdf_8h/#function-create3dnc","title":"function create3dnc","text":"<p>Create a NetCDF file containing a 3D variable, for testing for example. Creates a NetCDF file containing a 3D variable with the specified dimensions and data. If the file already exists, it will be overwritten. </p><pre><code>void create3dnc (\n    char * name,\n    int nx,\n    int ny,\n    int nt,\n    double * xx,\n    double * yy,\n    double * theta,\n    double * var,\n    char * varname\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> The name of the NetCDF file to be created. </li> <li><code>nx</code> The number of grid points in the x-direction. </li> <li><code>ny</code> The number of grid points in the y-direction. </li> <li><code>nt</code> The number of time steps. </li> <li><code>xx</code> Pointer to an array containing the x-coordinates of the grid points. </li> <li><code>yy</code> Pointer to an array containing the y-coordinates of the grid points. </li> <li><code>theta</code> Pointer to an array containing the time values. </li> <li><code>var</code> Pointer to an array containing the 3D variable data to be stored in the NetCDF file. </li> <li><code>varname</code> The name of the variable to be stored in the NetCDF file. </li> </ul> <p>Note:</p> <p>This function uses the NetCDF C library to create and write to the NetCDF file. </p>"},{"location":"BGFlood/_write__netcdf_8h/#function-creatncfilebuq","title":"function creatncfileBUQ","text":"<p>Create a NetCDF file for BG-Flood output. Creates a NetCDF file for BG-Flood output based on the provided parameters and zone information. </p><pre><code>template&lt;class T&gt;\nvoid creatncfileBUQ (\n    Param &amp; XParam,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    outzoneB &amp; Xzone\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings and model parameters. </li> <li><code>activeblk</code> Pointer to an array of active block indices. </li> <li><code>level</code> Pointer to an array of block levels. </li> <li><code>blockxo</code> Pointer to an array of block x-coordinates. </li> <li><code>blockyo</code> Pointer to an array of block y-coordinates. </li> <li><code>Xzone</code> The output zone object defining the area and settings for the NetCDF file. </li> </ul>"},{"location":"BGFlood/_write__netcdf_8h/#function-creatncfilebuq_1","title":"function creatncfileBUQ","text":"<p>Create NetCDF files for all output zones in a block. Creates NetCDF files for all output zones defined in the block using the provided parameters and block information. </p><pre><code>template&lt;class T&gt;\nvoid creatncfileBUQ (\n    Param &amp; XParam,\n    BlockP &lt; T &gt; &amp; XBlock\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings and model parameters. </li> <li><code>XBlock</code> The block object containing block information and output zones. </li> </ul>"},{"location":"BGFlood/_write__netcdf_8h/#function-defncvarbuq","title":"function defncvarBUQ","text":"<p>Define a NetCDF variable for BG-Flood output. Defines a NetCDF variable for BG-Flood output based on the provided parameters, block information and zone information. </p><pre><code>template&lt;class T&gt;\nvoid defncvarBUQ (\n    Param XParam,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    std::string varst,\n    int vdim,\n    T * var,\n    outzoneB Xzone\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings and model parameters. </li> <li><code>activeblk</code> Pointer to an array of active block indices. </li> <li><code>level</code> Pointer to an array of block levels. </li> <li><code>blockxo</code> Pointer to an array of block x-coordinates. </li> <li><code>blockyo</code> Pointer to an array of block y-coordinates. </li> <li><code>varst</code> The base name of the variable to be defined. </li> <li><code>vdim</code> The number of dimensions of the variable (2 or 3). </li> <li><code>var</code> Pointer to the array containing the variable data. </li> <li><code>Xzone</code> The output zone object defining the area and settings for the NetCDF variable. </li> </ul> <p>Note:</p> <p>This is an overloaded function that provides a simpler interface when longname, stdname, and unit are not needed. </p>"},{"location":"BGFlood/_write__netcdf_8h/#function-handle_ncerror","title":"function handle_ncerror","text":"<p>Handle NetCDF errors. </p><pre><code>void handle_ncerror (\n    int status\n) \n</code></pre>"},{"location":"BGFlood/_write__netcdf_8h/#function-write2dvarnc","title":"function write2dvarnc","text":"<p>Write a time step of a 2D variable to an existing NetCDF file, for testing for example. Writes a time step of a 2D variable to an existing NetCDF file by appending the provided variable data at the next available time index. </p><pre><code>void write2dvarnc (\n    int nx,\n    int ny,\n    double totaltime,\n    double * var\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>nx</code> The number of grid points in the x-direction. </li> <li><code>ny</code> The number of grid points in the y-direction. </li> <li><code>totaltime</code> The total time value to be written to the \"time\" variable. </li> <li><code>var</code> Pointer to an array containing the 2D variable data to be appended to the NetCDF file. </li> </ul> <p>Note:</p> <p>This function assumes that the NetCDF file \"3Dvar.nc\" already exists and is open for writing. </p>"},{"location":"BGFlood/_write__netcdf_8h/#function-write3dvarnc","title":"function write3dvarnc","text":"<p>Write a time step of a 3D variable to an existing NetCDF file, for testing for example. Writes a time step of a 3D variable to an existing NetCDF file by appending the provided variable data at the next available time index. </p><pre><code>void write3dvarnc (\n    int nx,\n    int ny,\n    int nt,\n    double totaltime,\n    double * var\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>nx</code> The number of grid points in the x-direction. </li> <li><code>ny</code> The number of grid points in the y-direction. </li> <li><code>nt</code> The number of time steps. </li> <li><code>totaltime</code> The total time value to be written to the \"time\" variable. </li> <li><code>var</code> Pointer to an array containing the 3D variable data to be appended to the NetCDF file. </li> </ul> <p>Note:</p> <p>This function assumes that the NetCDF file \"3Dvar.nc\" already exists and is open for writing. </p>"},{"location":"BGFlood/_write__netcdf_8h/#function-writenctimestep","title":"function writenctimestep","text":"<p>Write the current time step to a NetCDF file. Writes the current time step to a NetCDF file by updating the \"time\" variable with the provided total time value. </p><pre><code>void writenctimestep (\n    std::string outfile,\n    double totaltime\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>outfile</code> The name of the NetCDF output file. </li> <li><code>totaltime</code> The total time value to be written to the \"time\" variable. </li> </ul>"},{"location":"BGFlood/_write__netcdf_8h/#function-writencvarstepbuq","title":"function writencvarstepBUQ","text":"<p>Write a time step of a NetCDF variable for BG-Flood output. Writes a time step of a NetCDF variable for BG-Flood output based on the provided parameters, block information, variable data, and zone information. </p><pre><code>template&lt;class T&gt;\nvoid writencvarstepBUQ (\n    Param XParam,\n    int vdim,\n    int * activeblk,\n    int * level,\n    T * blockxo,\n    T * blockyo,\n    std::string varst,\n    T * var,\n    outzoneB Xzone\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The parameter object containing grid settings and model parameters. </li> <li><code>vdim</code> The number of dimensions of the variable (2 or 3). </li> <li><code>activeblk</code> Pointer to an array of active block indices. </li> <li><code>level</code> Pointer to an array of block levels. </li> <li><code>blockxo</code> Pointer to an array of block x-coordinates. </li> <li><code>blockyo</code> Pointer to an array of block y-coordinates. </li> <li><code>varst</code> The base name of the variable to be written. </li> <li><code>var</code> Pointer to the array containing the variable data. </li> <li><code>Xzone</code> The output zone object defining the area and settings for the NetCDF variable. </li> </ul> <p>Note:</p> <p>This is a templated function that can handle different data types for the variable (e.g., float, double). </p> <p>The documentation for this class was generated from the following file <code>src/Write_netcdf.h</code></p>"},{"location":"BGFlood/_write__netcdf_8h_source/","title":"File Write_netcdf.h","text":""},{"location":"BGFlood/_write__netcdf_8h_source/#file-write_netcdfh","title":"File Write_netcdf.h","text":"<p>File List &gt; src &gt; Write_netcdf.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef WRITENETCDF_H\n#define WRITENETCDF_H\n\n#include \"General.h\"\n#include \"Param.h\"\n#include \"Write_txtlog.h\"\n#include \"ReadInput.h\"\n#include \"MemManagement.h\"\n#include \"Util_CPU.h\"\n#include \"Arrays.h\"\n\nvoid handle_ncerror(int status);\ntemplate&lt;class T&gt; void creatncfileBUQ(Param &amp;XParam, int* activeblk, int* level, T* blockxo, T* blockyo, outzoneB &amp;Xzone);\ntemplate&lt;class T&gt; void creatncfileBUQ(Param &amp;XParam, BlockP&lt;T&gt; &amp;XBlock);\ntemplate &lt;class T&gt; void defncvarBUQ(Param XParam, int * activeblk, int * level, T * blockxo, T *blockyo, std::string varst, int vdim, T * var, outzoneB Xzone);\ntemplate &lt;class T&gt; void writencvarstepBUQ(Param XParam, int vdim, int * activeblk, int* level, T * blockxo, T *blockyo, std::string varst, T * var, outzoneB Xzone);\ntemplate &lt;class T&gt; void InitSave2Netcdf(Param &amp;XParam, Model&lt;T&gt; &amp;XModel);\n//template &lt;class T&gt; void SaveInitialisation2Netcdf(Param&amp; XParam, Model&lt;T&gt;&amp; XModel);\nextern \"C\" void writenctimestep(std::string outfile, double totaltime);\ntemplate &lt;class T&gt; void Save2Netcdf(Param XParam, Loop&lt;T&gt; XLoop, Model&lt;T&gt; &amp;XModel);\n\nextern \"C\" void create2dnc(char* filename, int nx, int ny, double* xx, double* yy, double* var, char* varname);\nextern \"C\" void create3dnc(char* name, int nx, int ny, int nt, double* xx, double* yy, double* theta, double* var, char* varname);\nextern \"C\" void write3dvarnc(int nx, int ny, int nt, double totaltime, double* var);\nextern \"C\" void write2dvarnc(int nx, int ny, double totaltime, double* var);\n\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/_write__txtlog_8cpp/","title":"File Write_txtlog.cpp","text":""},{"location":"BGFlood/_write__txtlog_8cpp/#file-write_txtlogcpp","title":"File Write_txtlog.cpp","text":"<p>FileList &gt; src &gt; Write_txtlog.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Write_txtlog.h\"</code></li> </ul>"},{"location":"BGFlood/_write__txtlog_8cpp/#public-functions","title":"Public Functions","text":"Type Name void SaveParamtolog (Param XParam) Save model parameters to the log file. Saves the model parameters from the given Param object to the log file \"BG_log.txt\". void create_logfile () Create a log file for BG-Flood. Creates a log file named \"BG_log.txt\" for BG-Flood. The log file is reset if it already exists. The function also writes a header with the current date and time. void log (std::string text)  void saveparam2netCDF (int ncid, int bgfid, Param XParam) Save model parameters to a NetCDF file. Saves the model parameters from the given Param object to a NetCDF file. void write_text_to_log_file (std::string text) Write text to the log file. Writes the given text to the log file \"BG_log.txt\"."},{"location":"BGFlood/_write__txtlog_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_write__txtlog_8cpp/#function-saveparamtolog","title":"function SaveParamtolog","text":"<p>Save model parameters to the log file. Saves the model parameters from the given Param object to the log file \"BG_log.txt\". </p><pre><code>void SaveParamtolog (\n    Param XParam\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The Param object containing the model parameters </li> </ul>"},{"location":"BGFlood/_write__txtlog_8cpp/#function-create_logfile","title":"function create_logfile","text":"<p>Create a log file for BG-Flood. Creates a log file named \"BG_log.txt\" for BG-Flood. The log file is reset if it already exists. The function also writes a header with the current date and time. </p><pre><code>void create_logfile () \n</code></pre>"},{"location":"BGFlood/_write__txtlog_8cpp/#function-log","title":"function log","text":"<pre><code>void log (\n    std::string text\n) \n</code></pre>"},{"location":"BGFlood/_write__txtlog_8cpp/#function-saveparam2netcdf","title":"function saveparam2netCDF","text":"<p>Save model parameters to a NetCDF file. Saves the model parameters from the given Param object to a NetCDF file. </p><pre><code>void saveparam2netCDF (\n    int ncid,\n    int bgfid,\n    Param XParam\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>ncid</code> The NetCDF file ID </li> <li><code>bgfid</code> The NetCDF group ID for the parameters </li> <li><code>XParam</code> The Param object containing the model parameters </li> </ul>"},{"location":"BGFlood/_write__txtlog_8cpp/#function-write_text_to_log_file","title":"function write_text_to_log_file","text":"<p>Write text to the log file. Writes the given text to the log file \"BG_log.txt\". </p><pre><code>void write_text_to_log_file (\n    std::string text\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>text</code> The text to write to the log file </li> </ul> <p>The documentation for this class was generated from the following file <code>src/Write_txtlog.cpp</code></p>"},{"location":"BGFlood/_write__txtlog_8cpp_source/","title":"File Write_txtlog.cpp","text":""},{"location":"BGFlood/_write__txtlog_8cpp_source/#file-write_txtlogcpp","title":"File Write_txtlog.cpp","text":"<p>File List &gt; src &gt; Write_txtlog.cpp</p> <p>Go to the documentation of this file</p> <pre><code>//                                                                              //\n//Copyright (C) 2018 Bosserelle                                                 //\n//                                                                              //\n//This program is free software: you can redistribute it and/or modify          //\n//it under the terms of the GNU General Public License as published by          //\n//the Free Software Foundation.                                                 //\n//                                                                              //\n//This program is distributed in the hope that it will be useful,               //\n//but WITHOUT ANY WARRANTY; without even the implied warranty of                //\n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 //\n//GNU General Public License for more details.                                  //\n//                                                                              //\n//You should have received a copy of the GNU General Public License             //\n//along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.         //\n\n#include \"Write_txtlog.h\"\n\n\n\nvoid log(std::string text)\n{\n\n    std::cout &lt;&lt; text &lt;&lt; std::endl;\n    write_text_to_log_file(text);\n\n}\n\nvoid create_logfile()\n{\n    // Reset the log file\n    std::ofstream log_file(\n        \"BG_log.txt\", std::ios_base::out | std::ios_base::trunc);\n\n    log_file.close();\n\n    //Logfile header\n    //auto n = std::chrono::system_clock::now();\n    //auto in_time_t = std::chrono::system_clock::to_time_t(n);\n    //std::tm buf;\n    //localtime_s(&amp;buf, &amp;in_time_t);\n    //std::cout &lt;&lt; std::put_time(&amp;buf, \"%Y-%m-%d %X\") &lt;&lt; std::endl;\n/*\n    auto now = std::chrono::system_clock::now();\n    auto in_time_t = std::chrono::system_clock::to_time_t(now);\n\n     std::stringstream ss;\n     ss &lt;&lt; std::put_time(std::localtime(&amp;in_time_t), \"%Y-%m-%d %X\");\n     */\n/*\n    std::time_t now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());\n\n    std::string s(30, '\\0');\n    std::tm buf;\n    struct tm * timeinfo;\n    std::localtime_s(&amp;buf, &amp;now);\n    //std::time_t rawtime;\n    //timeinfo = localtime(&amp;rawtime);\n    std::strftime(&amp;s[0], s.size(), \"%Y-%m-%d %H:%M:%S\", &amp;timeinfo);\n*/\n    //strftime(buffer, 80, \"%d-%m-%Y %H:%M:%S\", timeinfo);\n    //std::string strtimenow(buffer);\n\n    time_t rawtime;\n    struct tm* timeinfo;\n    char buffer[80];\n\n    time(&amp;rawtime);\n    timeinfo = localtime(&amp;rawtime);\n\n    strftime(buffer, 80, \"%d-%m-%Y %H:%M:%S\", timeinfo);\n    std::string strtimenow(buffer);\n\n\n    log(\"#################################\");\n\n    log(\"BG_Flood v0.95\");\n\n    log(\"#################################\");\n    //log(\"model started at \" + ss.str());\n    log(\"#################################\");\n    log(\"#\");\n\n    write_text_to_log_file(\"model started at \" + strtimenow);\n}\n\nvoid write_text_to_log_file(std::string text)\n{\n    std::ofstream log_file(\n        \"BG_log.txt\", std::ios_base::out | std::ios_base::app);\n    log_file &lt;&lt; text &lt;&lt; std::endl;\n    log_file.close(); //destructor implicitly does it\n}\n\nvoid SaveParamtolog(Param XParam)// need to bring in Xforcing info too!\n{\n    write_text_to_log_file(\"\\n\");\n    write_text_to_log_file(\"###################################\");\n    write_text_to_log_file(\"### Summary of model parameters ###\");\n    write_text_to_log_file(\"###################################\");\n    write_text_to_log_file(\"# Bathymetry file\");\n    //write_text_to_log_file(\"bathy = \" + XParam.Bathymetry.inputfile + \";\");\n    write_text_to_log_file(\"posdown = \" + std::to_string(XParam.posdown) + \";\");\n    //write_text_to_log_file(\"nx = \" + std::to_string(XParam.nx) + \";\");\n    //write_text_to_log_file(\"ny = \" + std::to_string(XParam.ny) + \";\");\n    write_text_to_log_file(\"dx = \" + std::to_string(XParam.dx) + \";\");\n    write_text_to_log_file(\"delta = \" + std::to_string(XParam.delta) + \";\");\n    write_text_to_log_file(\"grdalpha = \" + std::to_string(XParam.grdalpha*180.0 / pi) + \";\");\n    write_text_to_log_file(\"xo = \" + std::to_string(XParam.xo) + \";\");\n    write_text_to_log_file(\"yo = \" + std::to_string(XParam.yo) + \";\");\n    write_text_to_log_file(\"xmax = \" + std::to_string(XParam.xo) + \";\");\n    write_text_to_log_file(\"ymax = \" + std::to_string(XParam.yo) + \";\");\n    write_text_to_log_file(\"\\n\");\n\n\n    write_text_to_log_file(\"gpudevice = \" + std::to_string(XParam.GPUDEVICE) + \";\");\n    write_text_to_log_file(\"\\n\");\n    write_text_to_log_file(\"# Flow parameters\");\n    write_text_to_log_file(\"eps = \" + std::to_string(XParam.eps) + \";\");\n    write_text_to_log_file(\"cf = \" + std::to_string(XParam.cf) + \";\");\n\n    write_text_to_log_file(\"theta = \" + std::to_string(XParam.theta) + \";\");\n\n\n    write_text_to_log_file(\"Cd = \" + std::to_string(XParam.Cd) + \";\");\n\n    write_text_to_log_file(\"\\n\");\n    write_text_to_log_file(\"# Timekeeping parameters\");\n    write_text_to_log_file(\"CFL = \" + std::to_string(XParam.CFL) + \";\");\n    write_text_to_log_file(\"totaltime = \" + std::to_string(XParam.totaltime) + \"; # Start time\");\n    write_text_to_log_file(\"endtime = \" + std::to_string(XParam.endtime) + \";\");\n    write_text_to_log_file(\"outputtimestep = \" + std::to_string(XParam.outputtimestep) + \";\");\n\n\n    std::string alloutvars = \"\";\n    for (int nvar = 0; nvar &lt; XParam.outvars.size(); nvar++)\n    {\n        if (nvar &gt; 0)\n        {\n            alloutvars = alloutvars + \", \";\n        }\n        alloutvars = alloutvars + XParam.outvars[nvar];\n    }\n    write_text_to_log_file(\"outvars = \" + alloutvars + \";\");\n\n\n\n    write_text_to_log_file(\"\\n\");\n    write_text_to_log_file(\"# Files\");\n    if (!XParam.outzone.empty())\n    {\n        for (int o = 0; o &lt; XParam.outzone.size(); o++)\n        {\n            write_text_to_log_file(\"outzonefile = \" + XParam.outzone[o].outname + \",\" + std::to_string(XParam.outzone[o].xstart) + \",\" + std::to_string(XParam.outzone[o].xend) + \",\" + std::to_string(XParam.outzone[o].ystart) + \",\" + std::to_string(XParam.outzone[o].yend) + \";\");\n        }\n    }\n    else\n    {\n        write_text_to_log_file(\"outfile = \" + XParam.outfile + \";\");\n    }\n\n    write_text_to_log_file(\"smallnc = \" + std::to_string(XParam.smallnc) + \"; #if smallnc==1 all Output are scaled and saved as a short int\");\n    if (XParam.smallnc == 1)\n    {\n        write_text_to_log_file(\"scalefactor = \" + std::to_string(XParam.scalefactor) + \";\");\n        write_text_to_log_file(\"addoffset = \" + std::to_string(XParam.addoffset) + \";\");\n    }\n\n    if (!XParam.TSnodesout.empty())\n    {\n        for (int o = 0; o &lt; XParam.TSnodesout.size(); o++)\n        {\n            write_text_to_log_file(\"TSOfile = \" + XParam.TSnodesout[o].outname + \",\" + std::to_string(XParam.TSnodesout[o].x) + \",\" + std::to_string(XParam.TSnodesout[o].y)+\";\");\n            //write_text_to_log_file(\"TSnode = \" + std::to_string(XParam.TSnodesout[o].i) + \",\" + std::to_string(XParam.TSnodesout[o].j) + \";\");\n        }\n    }\n    write_text_to_log_file(\"\\n\");\n    write_text_to_log_file(\"# Boundaries\");\n    write_text_to_log_file(\"# 0:wall; 1: Neumann (Default); 2:Dirichlet (zs); 3: abs1d \");\n    /*\n    //write_text_to_log_file(\"right = \" + std::to_string(XParam.rightbnd.type) + \";\");\n    //write_text_to_log_file(\"left = \" + std::to_string(XParam.leftbnd.type) + \";\");\n    //write_text_to_log_file(\"top = \" + std::to_string(XParam.topbnd.type) + \";\");\n    //write_text_to_log_file(\"bot = \" + std::to_string(XParam.botbnd.type) + \";\");\n\n    if (!XParam.rightbnd.inputfile.empty())\n        write_text_to_log_file(\"rightbndfile = \" + XParam.rightbnd.inputfile + \";\");\n    if (!XParam.leftbnd.inputfile.empty())\n        write_text_to_log_file(\"leftbndfile = \" + XParam.leftbnd.inputfile + \";\");\n    if (!XParam.topbnd.inputfile.empty())\n        write_text_to_log_file(\"topbndfile = \" + XParam.topbnd.inputfile + \";\");\n    if (!XParam.botbnd.inputfile.empty())\n        write_text_to_log_file(\"botbndfile = \" + XParam.botbnd.inputfile + \";\");\n*/\n    /*\n    std::string rightbndfile;\n    std::string leftbndfile;\n    std::string topbndfile;\n    std::string botbndfile;\n    */\n    //hot start\n    if (!XParam.hotstartfile.empty())\n    {\n        write_text_to_log_file(\"hotstartfile = \" + XParam.hotstartfile + \";\");\n        write_text_to_log_file(\"hotstep = \" + std::to_string(XParam.hotstep) + \";\");\n    }\n\n\n    write_text_to_log_file(\"\\n\");\n    write_text_to_log_file(\"# Others\");\n    write_text_to_log_file(\"g = \" + std::to_string(XParam.g) + \";\");\n    write_text_to_log_file(\"rho = \" + std::to_string(XParam.rho) + \";\");\n    write_text_to_log_file(\"\\n\");\n}\n\n\nvoid saveparam2netCDF(int ncid, int bgfid, Param XParam)\n{\n    int status, boolanswer;\n    //status = nc_put_att_text(ncid, bgfid, \"grid_mapping_name\", crsname.size(), crsname.c_str());\n    //status = nc_put_att_float(ncid, bgfid, \"longitude_of_prime_meridian\", NC_FLOAT, 1, &amp;primemeridian);\n\n    status = nc_put_att_int(ncid, bgfid, \"test\", NC_INT, 1, &amp;XParam.test);\n    status = nc_put_att_double(ncid, bgfid, \"g\", NC_DOUBLE, 1, &amp;XParam.g);\n    status = nc_put_att_double(ncid, bgfid, \"rho\", NC_DOUBLE, 1, &amp;XParam.rho);\n    status = nc_put_att_double(ncid, bgfid, \"eps\", NC_DOUBLE, 1, &amp;XParam.eps);\n    status = nc_put_att_double(ncid, bgfid, \"CFL\", NC_DOUBLE, 1, &amp;XParam.CFL);\n    status = nc_put_att_double(ncid, bgfid, \"theta\", NC_DOUBLE, 1, &amp;XParam.theta);\n    status = nc_put_att_double(ncid, bgfid, \"VelThreshold\", NC_DOUBLE, 1, &amp;XParam.VelThreshold);\n\n    status = nc_put_att_int(ncid, bgfid, \"frictionmodel\", NC_INT, 1, &amp;XParam.frictionmodel);\n\n    status = nc_put_att_double(ncid, bgfid, \"Cd\", NC_DOUBLE, 1, &amp;XParam.Cd);\n    status = nc_put_att_double(ncid, bgfid, \"Pa2m\", NC_DOUBLE, 1, &amp;XParam.Pa2m);\n    status = nc_put_att_double(ncid, bgfid, \"Paref\", NC_DOUBLE, 1, &amp;XParam.Paref);\n    status = nc_put_att_double(ncid, bgfid, \"lat\", NC_DOUBLE, 1, &amp;XParam.lat);\n\n    boolanswer = XParam.windforcing;\n    status = nc_put_att_int(ncid, bgfid, \"windforcing\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.atmpforcing;\n    status = nc_put_att_int(ncid, bgfid, \"atmpforcing\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.rainforcing;\n    status = nc_put_att_int(ncid, bgfid, \"rainforcing\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.infiltration;\n    status = nc_put_att_int(ncid, bgfid, \"infiltration\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.conserveElevation;\n    status = nc_put_att_int(ncid, bgfid, \"conserveElevation\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.wetdryfix;\n    status = nc_put_att_int(ncid, bgfid, \"wetdryfix\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.leftbnd;\n    status = nc_put_att_int(ncid, bgfid, \"leftbnd\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.rightbnd;\n    status = nc_put_att_int(ncid, bgfid, \"rightbnd\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.topbnd;\n    status = nc_put_att_int(ncid, bgfid, \"topbnd\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.botbnd;\n    status = nc_put_att_int(ncid, bgfid, \"botbnd\", NC_INT, 1, &amp;boolanswer);\n\n\n\n\n\n    double cf = 0.0001; // Bottom friction coefficient for flow model (if constant)\n\n\n    status = nc_put_att_int(ncid, bgfid, \"GPUDEVICE\", NC_INT, 1, &amp;XParam.GPUDEVICE);\n\n    status = nc_put_att_int(ncid, bgfid, \"doubleprecision\", NC_INT, 1, &amp;XParam.doubleprecision);\n\n    status = nc_put_att_int(ncid, bgfid, \"engine\", NC_INT, 1, &amp;XParam.engine);\n\n    status = nc_put_att_double(ncid, bgfid, \"dx\", NC_DOUBLE, 1, &amp;XParam.dx);\n    status = nc_put_att_double(ncid, bgfid, \"delta\", NC_DOUBLE, 1, &amp;XParam.delta);\n\n    status = nc_put_att_double(ncid, bgfid, \"xo\", NC_DOUBLE, 1, &amp;XParam.xo);\n    status = nc_put_att_double(ncid, bgfid, \"yo\", NC_DOUBLE, 1, &amp;XParam.yo);\n    status = nc_put_att_double(ncid, bgfid, \"xmax\", NC_DOUBLE, 1, &amp;XParam.xmax);\n    status = nc_put_att_double(ncid, bgfid, \"ymax\", NC_DOUBLE, 1, &amp;XParam.ymax);\n\n    status = nc_put_att_double(ncid, bgfid, \"grdalpha\", NC_DOUBLE, 1, &amp;XParam.grdalpha);\n\n    status = nc_put_att_int(ncid, bgfid, \"nx\", NC_INT, 1, &amp;XParam.nx);\n    status = nc_put_att_int(ncid, bgfid, \"ny\", NC_INT, 1, &amp;XParam.ny);\n    status = nc_put_att_int(ncid, bgfid, \"nblk\", NC_INT, 1, &amp;XParam.nblk);\n\n    status = nc_put_att_int(ncid, bgfid, \"blkwidth\", NC_INT, 1, &amp;XParam.blkwidth);\n    status = nc_put_att_int(ncid, bgfid, \"blkmemwidth\", NC_INT, 1, &amp;XParam.blkmemwidth);\n    status = nc_put_att_int(ncid, bgfid, \"blksize\", NC_INT, 1, &amp;XParam.blksize);\n    status = nc_put_att_int(ncid, bgfid, \"halowidth\", NC_INT, 1, &amp;XParam.halowidth);\n    status = nc_put_att_int(ncid, bgfid, \"posdown\", NC_INT, 1, &amp;XParam.posdown);\n\n    boolanswer = XParam.spherical;\n    status = nc_put_att_int(ncid, bgfid, \"spherical\", NC_INT, 1, &amp;boolanswer);\n    status = nc_put_att_double(ncid, bgfid, \"Radius\", NC_DOUBLE, 1, &amp;XParam.Radius);\n    status = nc_put_att_double(ncid, bgfid, \"mask\", NC_DOUBLE, 1, &amp;XParam.mask);\n\n    status = nc_put_att_int(ncid, bgfid, \"initlevel\", NC_INT, 1, &amp;XParam.initlevel);\n    status = nc_put_att_int(ncid, bgfid, \"maxlevel\", NC_INT, 1, &amp;XParam.maxlevel);\n    status = nc_put_att_int(ncid, bgfid, \"minlevel\", NC_INT, 1, &amp;XParam.minlevel);\n    status = nc_put_att_int(ncid, bgfid, \"nblkmem\", NC_INT, 1, &amp;XParam.nblkmem);\n    status = nc_put_att_int(ncid, bgfid, \"navailblk\", NC_INT, 1, &amp;XParam.navailblk);\n    status = nc_put_att_double(ncid, bgfid, \"membuffer\", NC_DOUBLE, 1, &amp;XParam.membuffer);\n\n    status = nc_put_att_double(ncid, bgfid, \"outputtimestep\", NC_DOUBLE, 1, &amp;XParam.outputtimestep);\n    status = nc_put_att_double(ncid, bgfid, \"endtime\", NC_DOUBLE, 1, &amp;XParam.endtime);\n    status = nc_put_att_double(ncid, bgfid, \"totaltime\", NC_DOUBLE, 1, &amp;XParam.totaltime);\n    status = nc_put_att_double(ncid, bgfid, \"dtinit\", NC_DOUBLE, 1, &amp;XParam.dtinit);\n    status = nc_put_att_double(ncid, bgfid, \"dtmin\", NC_DOUBLE, 1, &amp;XParam.dtmin);\n\n    status = nc_put_att_double(ncid, bgfid, \"zsinit\", NC_DOUBLE, 1, &amp;XParam.zsinit);\n    status = nc_put_att_double(ncid, bgfid, \"zsoffset\", NC_DOUBLE, 1, &amp;XParam.zsoffset);\n\n    status = nc_put_att_text(ncid, bgfid, \"hotstartfile\", XParam.hotstartfile.size(), XParam.hotstartfile.c_str());\n    status = nc_put_att_int(ncid, bgfid, \"hotstep\", NC_INT, 1, &amp;XParam.hotstep);\n\n    status = nc_put_att_double(ncid, bgfid, \"wet_threshold \", NC_DOUBLE, 1, &amp;XParam.wet_threshold);\n\n    status = nc_put_att_int(ncid, bgfid, \"maxTSstorage\", NC_INT, 1, &amp;XParam.maxTSstorage);\n\n    boolanswer = XParam.resetmax;\n    status = nc_put_att_int(ncid, bgfid, \"resetmax\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.outmax;\n    status = nc_put_att_int(ncid, bgfid, \"outmax\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.outmean;\n    status = nc_put_att_int(ncid, bgfid, \"outmean\", NC_INT, 1, &amp;boolanswer);\n\n    boolanswer = XParam.outtwet;\n    status = nc_put_att_int(ncid, bgfid, \"outtwet\", NC_INT, 1, &amp;boolanswer);\n\n    status = nc_put_att_int(ncid, bgfid, \"outishift\", NC_INT, 1, &amp;XParam.outishift);\n\n    status = nc_put_att_int(ncid, bgfid, \"outjshift\", NC_INT, 1, &amp;XParam.outjshift);\n\n    status = nc_put_att_int(ncid, bgfid, \"nrivers\", NC_INT, 1, &amp;XParam.nrivers);\n\n    status = nc_put_att_int(ncid, bgfid, \"nblkriver\", NC_INT, 1, &amp;XParam.nblkriver);\n\n    status = nc_put_att_int(ncid, bgfid, \"nbndblkleft\", NC_INT, 1, &amp;XParam.nbndblkleft);\n    status = nc_put_att_int(ncid, bgfid, \"nbndblkright\", NC_INT, 1, &amp;XParam.nbndblkright);\n    status = nc_put_att_int(ncid, bgfid, \"nbndblktop\", NC_INT, 1, &amp;XParam.nbndblktop);\n    status = nc_put_att_int(ncid, bgfid, \"nbndblkbot\", NC_INT, 1, &amp;XParam.nbndblkbot);\n\n    status = nc_put_att_int(ncid, bgfid, \"nmaskblk\", NC_INT, 1, &amp;XParam.nmaskblk);\n\n    status = nc_put_att_int(ncid, bgfid, \"smallnc\", NC_INT, 1, &amp;XParam.smallnc);\n\n    status = nc_put_att_float(ncid, bgfid, \"scalefactor\", NC_FLOAT, 1, &amp;XParam.scalefactor);\n\n    status = nc_put_att_float(ncid, bgfid, \"addoffset\", NC_FLOAT, 1, &amp;XParam.addoffset);\n\n    status = nc_put_att_double(ncid, bgfid, \"deformmaxtime\", NC_DOUBLE, 1, &amp;XParam.deformmaxtime);\n\n    boolanswer = XParam.rainbnd;\n    status = nc_put_att_int(ncid, bgfid, \"rainbnd\", NC_INT, 1, &amp;boolanswer);\n\n    status = nc_put_att_text(ncid, bgfid, \"AdaptCrit\", XParam.AdaptCrit.size(), XParam.AdaptCrit.c_str());\n\n    status = nc_put_att_text(ncid, bgfid, \"Adapt_arg1\", XParam.Adapt_arg1.size(), XParam.Adapt_arg1.c_str());\n    status = nc_put_att_text(ncid, bgfid, \"Adapt_arg2\", XParam.Adapt_arg2.size(), XParam.Adapt_arg2.c_str());\n    status = nc_put_att_text(ncid, bgfid, \"Adapt_arg3\", XParam.Adapt_arg3.size(), XParam.Adapt_arg3.c_str());\n    status = nc_put_att_text(ncid, bgfid, \"Adapt_arg4\", XParam.Adapt_arg4.size(), XParam.Adapt_arg4.c_str());\n    status = nc_put_att_text(ncid, bgfid, \"Adapt_arg5\", XParam.Adapt_arg5.size(), XParam.Adapt_arg5.c_str());\n\n    status = nc_put_att_int(ncid, bgfid, \"adaptmaxiteration\", NC_INT, 1, &amp;XParam.adaptmaxiteration);\n\n    status = nc_put_att_text(ncid, bgfid, \"reftime\", XParam.reftime.size(), XParam.reftime.c_str());\n\n\n    std::string allouvars;\n    for (int i = 0; i &lt; XParam.outvars.size(); i++)\n    {\n        allouvars = allouvars + XParam.outvars[i];\n        if (i &lt; (XParam.outvars.size() - 1))\n        {\n            allouvars = allouvars + \", \";\n        }\n    }\n\n    status = nc_put_att_text(ncid, bgfid, \"outvars\", allouvars.size(), allouvars.c_str());\n\n    status = nc_put_att_text(ncid, bgfid, \"outfile\", XParam.outfile.size(), XParam.outfile.c_str());\n\n\n\n\n\n    /*\n\n    std::vector&lt;TSoutnode&gt; TSnodesout;\n\n\n\n\n\n    std::vector&lt;outzoneP&gt; outzone;\n\n    // deformation forcing for tsunami generation\n    //std::vector&lt;deformmap&gt; deform;\n\n\n    std::string AdaptCrit;\n    int* AdaptCrit_funct_pointer;\n\n\n    */\n}\n</code></pre>"},{"location":"BGFlood/_write__txtlog_8h/","title":"File Write_txtlog.h","text":""},{"location":"BGFlood/_write__txtlog_8h/#file-write_txtlogh","title":"File Write_txtlog.h","text":"<p>FileList &gt; src &gt; Write_txtlog.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"Param.h\"</code></li> </ul>"},{"location":"BGFlood/_write__txtlog_8h/#public-functions","title":"Public Functions","text":"Type Name void SaveParamtolog (Param XParam) Save model parameters to the log file. Saves the model parameters from the given Param object to the log file \"BG_log.txt\". void create_logfile () Create a log file for BG-Flood. Creates a log file named \"BG_log.txt\" for BG-Flood. The log file is reset if it already exists. The function also writes a header with the current date and time. void log (std::string text)  void saveparam2netCDF (int ncid, int bgfid, Param XParam) Save model parameters to a NetCDF file. Saves the model parameters from the given Param object to a NetCDF file. void write_text_to_log_file (std::string text) Write text to the log file. Writes the given text to the log file \"BG_log.txt\"."},{"location":"BGFlood/_write__txtlog_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/_write__txtlog_8h/#function-saveparamtolog","title":"function SaveParamtolog","text":"<p>Save model parameters to the log file. Saves the model parameters from the given Param object to the log file \"BG_log.txt\". </p><pre><code>void SaveParamtolog (\n    Param XParam\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>XParam</code> The Param object containing the model parameters </li> </ul>"},{"location":"BGFlood/_write__txtlog_8h/#function-create_logfile","title":"function create_logfile","text":"<p>Create a log file for BG-Flood. Creates a log file named \"BG_log.txt\" for BG-Flood. The log file is reset if it already exists. The function also writes a header with the current date and time. </p><pre><code>void create_logfile () \n</code></pre>"},{"location":"BGFlood/_write__txtlog_8h/#function-log","title":"function log","text":"<pre><code>void log (\n    std::string text\n) \n</code></pre>"},{"location":"BGFlood/_write__txtlog_8h/#function-saveparam2netcdf","title":"function saveparam2netCDF","text":"<p>Save model parameters to a NetCDF file. Saves the model parameters from the given Param object to a NetCDF file. </p><pre><code>void saveparam2netCDF (\n    int ncid,\n    int bgfid,\n    Param XParam\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>ncid</code> The NetCDF file ID </li> <li><code>bgfid</code> The NetCDF group ID for the parameters </li> <li><code>XParam</code> The Param object containing the model parameters </li> </ul>"},{"location":"BGFlood/_write__txtlog_8h/#function-write_text_to_log_file","title":"function write_text_to_log_file","text":"<p>Write text to the log file. Writes the given text to the log file \"BG_log.txt\". </p><pre><code>void write_text_to_log_file (\n    std::string text\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>text</code> The text to write to the log file </li> </ul> <p>The documentation for this class was generated from the following file <code>src/Write_txtlog.h</code></p>"},{"location":"BGFlood/_write__txtlog_8h_source/","title":"File Write_txtlog.h","text":""},{"location":"BGFlood/_write__txtlog_8h_source/#file-write_txtlogh","title":"File Write_txtlog.h","text":"<p>File List &gt; src &gt; Write_txtlog.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef WRITETXTLOG_H\n#define WRITETXTLOG_H\n\n#include \"General.h\"\n#include \"Param.h\"\n\nvoid log(std::string text);\nvoid create_logfile();\nvoid write_text_to_log_file(std::string text);\nvoid SaveParamtolog(Param XParam);\nvoid saveparam2netCDF(int ncid, int bgfid, Param XParam);\n// End of global definition\n#endif\n</code></pre>"},{"location":"BGFlood/utctime_8cu/","title":"File utctime.cu","text":""},{"location":"BGFlood/utctime_8cu/#file-utctimecu","title":"File utctime.cu","text":"<p>FileList &gt; src &gt; utctime.cu</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"utctime.h\"</code></li> </ul>"},{"location":"BGFlood/utctime_8cu/#public-functions","title":"Public Functions","text":"Type Name double date_string_to_s (std::string datetime, std::string refdate) Convert a date string to seconds from a reference date. Converts a date string in the format \"YYYY-MM-DDTHH:MM:SS\" or \"YYYY/MM/DD HH:MM:SS\" to seconds from the reference date. long long date_string_to_time (std::string date) Convert a date string to a Unix timestamp. Converts a date string in the format \"YYYY-MM-DDTHH:MM:SS\" or \"YYYY/MM/DD HH:MM:SS\" to a Unix timestamp (number of seconds since the beginning of 1970 CE). int days_from_epoch (int y, int m, int d) Calculate the number of days from the epoch (1970-01-01) to a given date. Algorithm: http://howardhinnant.github.io/date_algorithms.html . struct tm * gmtime_r (const time_t * timep, struct tm * tm) Convert a Unix timestamp to a Gregorian civil date-time tuple. double readinputtimetxt (std::string input, std::string &amp; refdate) Read a time string and convert it to seconds. Reads a time string and converts it to seconds. If the string is a valid datetime string it returns the seconds from the reference date, otherwise it returns a float of seconds. bool testime1 (int hour) Test time calculation functions. Test time calculation functions. bool testime2 (int hour) Test time calculation functions for greater than comparison. Test time calculation functions for greater than comparison. long long timegm (struct tm const * t) Convert a Gregorian civil date-time tuple to a Unix timestamp. Converts a Gregorian civil date-time tuple in GMT (UTC) time zone to a Unix timestamp."},{"location":"BGFlood/utctime_8cu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/utctime_8cu/#function-date_string_to_s","title":"function date_string_to_s","text":"<p>Convert a date string to seconds from a reference date. Converts a date string in the format \"YYYY-MM-DDTHH:MM:SS\" or \"YYYY/MM/DD HH:MM:SS\" to seconds from the reference date. </p><pre><code>double date_string_to_s (\n    std::string datetime,\n    std::string refdate\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>datetime</code> The date string to convert </li> <li><code>refdate</code> The reference date string </li> </ul> <p>Returns:</p> <p>The number of seconds from the reference date as double </p>"},{"location":"BGFlood/utctime_8cu/#function-date_string_to_time","title":"function date_string_to_time","text":"<p>Convert a date string to a Unix timestamp. Converts a date string in the format \"YYYY-MM-DDTHH:MM:SS\" or \"YYYY/MM/DD HH:MM:SS\" to a Unix timestamp (number of seconds since the beginning of 1970 CE). </p><pre><code>long long date_string_to_time (\n    std::string date\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>date</code> The date string to convert </li> </ul> <p>Returns:</p> <p>The corresponding Unix timestamp as long long </p>"},{"location":"BGFlood/utctime_8cu/#function-days_from_epoch","title":"function days_from_epoch","text":"<p>Calculate the number of days from the epoch (1970-01-01) to a given date. Algorithm: http://howardhinnant.github.io/date_algorithms.html . </p><pre><code>int days_from_epoch (\n    int y,\n    int m,\n    int d\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>y</code> Year </li> <li><code>m</code> Month </li> <li><code>d</code> Day </li> </ul>"},{"location":"BGFlood/utctime_8cu/#function-gmtime_r","title":"function gmtime_r","text":"<p>Convert a Unix timestamp to a Gregorian civil date-time tuple. </p><pre><code>struct tm * gmtime_r (\n    const time_t * timep,\n    struct tm * tm\n) \n</code></pre> <p>Converts a Unix timestamp (number of seconds since the beginning of 1970 CE) to a Gregorian civil date-time tuple in GMT (UTC) time zone.</p> <p>This conforms to C89 (and C99...) and POSIX.</p> <p>This implementation works, and doesn't overflow for any sizeof(time_t). It doesn't check for overflow/underflow in tm-&gt;tm_year output. Other than that, it never overflows or underflows. It assumes that that time_t is signed.</p> <p>This implements the inverse of the POSIX formula (http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15) for all time_t values, no matter the size, as long as tm-&gt;tm_year doesn't overflow or underflow. The formula is: tm_sec + tm_min*60 + tm_hour*3600 * tm_yday*86400 + (tm_year-70)*31536000 + ((tm_year-69)/4)*86400 - ((tm_year-1)/100)*86400 + ((tm_year+299)/400)*86400.</p> <p>Parameters:</p> <ul> <li><code>timep</code> Pointer to the Unix timestamp </li> <li><code>tm</code> Pointer to the struct tm to be filled </li> </ul> <p>Returns:</p> <p>Pointer to the filled struct tm </p>"},{"location":"BGFlood/utctime_8cu/#function-readinputtimetxt","title":"function readinputtimetxt","text":"<p>Read a time string and convert it to seconds. Reads a time string and converts it to seconds. If the string is a valid datetime string it returns the seconds from the reference date, otherwise it returns a float of seconds. </p><pre><code>double readinputtimetxt (\n    std::string input,\n    std::string &amp; refdate\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>input</code> The input time string </li> <li><code>refdate</code> The reference date string </li> </ul> <p>Returns:</p> <p>The time in seconds as double </p>"},{"location":"BGFlood/utctime_8cu/#function-testime1","title":"function testime1","text":"<p>Test time calculation functions. Test time calculation functions. </p><pre><code>bool testime1 (\n    int hour\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>hour</code> The hour to test </li> </ul>"},{"location":"BGFlood/utctime_8cu/#function-testime2","title":"function testime2","text":"<p>Test time calculation functions for greater than comparison. Test time calculation functions for greater than comparison. </p><pre><code>bool testime2 (\n    int hour\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>hour</code> The hour to test </li> </ul>"},{"location":"BGFlood/utctime_8cu/#function-timegm","title":"function timegm","text":"<p>Convert a Gregorian civil date-time tuple to a Unix timestamp. Converts a Gregorian civil date-time tuple in GMT (UTC) time zone to a Unix timestamp. </p><pre><code>long long timegm (\n    struct tm const * t\n) \n</code></pre> <p>Note:</p> <p>It does not modify broken-down time </p> <p>Parameters:</p> <ul> <li><code>t</code> Pointer to the struct tm to be converted </li> </ul> <p>Returns:</p> <p>The corresponding Unix timestamp </p> <p>The documentation for this class was generated from the following file <code>src/utctime.cu</code></p>"},{"location":"BGFlood/utctime_8cu_source/","title":"File utctime.cu","text":""},{"location":"BGFlood/utctime_8cu_source/#file-utctimecu","title":"File utctime.cu","text":"<p>File List &gt; src &gt; utctime.cu</p> <p>Go to the documentation of this file</p> <pre><code>#include \"utctime.h\"\n\nnamespace chrono = std::chrono;\nusing chrono::duration_cast;\nusing chrono::time_point_cast; \n/*\nnamespace {\n\nstd::time_t to_time_t(const UTCClock::time_point &amp;tp) noexcept\n{\n  return std::time_t(\n      duration_cast&lt;chrono::seconds&gt;(tp.time_since_epoch()).count());\n}\n\nUTCClock::time_point from_time_t(std::time_t tt) noexcept\n{\n  return time_point_cast&lt;UTCClock::duration&gt;(\n     chrono::time_point&lt;UTCClock,chrono::seconds&gt;(chrono::seconds(tt)));\n}\n\n} // namespace\n*/\n// Algorithm: http://howardhinnant.github.io/date_algorithms.html\nint days_from_epoch(int y, int m, int d)\n{\n    y -= m &lt;= 2;\n    int era = y / 400;\n    int yoe = y - era * 400;                                   // [0, 399]\n    int doy = (153 * (m + (m &gt; 2 ? -3 : 9)) + 2) / 5 + d - 1;  // [0, 365]\n    int doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;           // [0, 146096]\n    return era * 146097 + doe - 719468;\n}\n\nstruct tm* gmtime_r(const time_t* timep, struct tm* tm) {\n    const time_t ts = *timep;\n    time_t t = ts / 86400;\n    unsigned hms = ts % 86400;  /* -86399 &lt;= hms &lt;= 86399. This needs sizeof(int) &gt;= 4. */\n    time_t c, f;\n    unsigned yday;  /* 0 &lt;= yday &lt;= 426. Also fits to an `unsigned short', but `int' is faster. */\n    unsigned a;  /* 0 &lt;= a &lt;= 2133. Also fits to an `unsigned short', but `int' is faster. */\n    if ((int)hms &lt; 0) { --t; hms += 86400; }  /* Fix quotient and negative remainder if ts was negative (i.e. before year 1970 CE). */\n    /* Now: -24856 &lt;= t &lt;= 24855. */\n    tm-&gt;tm_sec = hms % 60;\n    hms /= 60;\n    tm-&gt;tm_min = hms % 60;\n    tm-&gt;tm_hour = hms / 60;\n    if (sizeof(time_t) &gt; 4) {  /* Optimization. For int32_t, this would keep t intact, so we won't have to do it. This produces unreachable code. */\n        f = (t + 4) % 7;\n        if (f &lt; 0) f += 7;  /* Fix negative remainder if (t + 4) was negative. */\n        /* Now 0 &lt;= f &lt;= 6. */\n        tm-&gt;tm_wday = f;\n        c = (t &lt;&lt; 2) + 102032;\n        f = c / 146097;\n        if (c % 146097 &lt; 0) --f;  /* Fix negative remainder if c was negative. */\n        --f;\n        t += f;\n        f &gt;&gt;= 2;\n        t -= f;\n        f = (t &lt;&lt; 2) + 102035;\n        c = f / 1461;\n        if (f % 1461 &lt; 0) --c;  /* Fix negative remainder if f was negative. */\n    }\n    else {\n        tm-&gt;tm_wday = (t + 24861) % 7;  /* t + 24861 &gt;= 0. */\n        /* Now: -24856 &lt;= t &lt;= 24855. */\n        c = ((t &lt;&lt; 2) + 102035) / 1461;\n    }\n    yday = t - 365 * c - (c &gt;&gt; 2) + 25568;\n    /* Now: 0 &lt;= yday &lt;= 425. */\n    a = yday * 5 + 8;\n    /* Now: 8 &lt;= a &lt;= 2133. */\n    tm-&gt;tm_mon = a / 153;\n    a %= 153;  /* No need to fix if a &lt; 0, because a cannot be negative here. */\n    /* Now: 2 &lt;= tm-&gt;tm_mon &lt;= 13. */\n    /* Now: 0 &lt;= a &lt;= 152. */\n    tm-&gt;tm_mday = 1 + a / 5;  /* No need to fix if a &lt; 0, because a cannot be negative here. */\n    /* Now: 1 &lt;= tm-&gt;tm_mday &lt;= 31. */\n    if (tm-&gt;tm_mon &gt;= 12) {\n        tm-&gt;tm_mon -= 12;\n        /* Now: 0 &lt;= tm-&gt;tm_mon &lt;= 1. */\n        ++c;\n        yday -= 366;\n    }\n    else {  /* Check for leap year (in c). */\n   /* Now: 2 &lt;= tm-&gt;tm_mon &lt;= 11. */\n   /* 1903: not leap; 1904: leap, 1900: not leap; 2000: leap */\n   /* With sizeof(time_t) == 4, we have 1901 &lt;= year &lt;= 2038; of these\n    * years only 2000 is divisble by 100, and that's a leap year, no we\n    * optimize the check to `(c &amp; 3) == 0' only.\n    */\n        if (!((c &amp; 3) == 0 &amp;&amp; (sizeof(time_t) &lt;= 4 || c % 100 != 0 || (c + 300) % 400 == 0))) --yday;  /* These `== 0' comparisons work even if c &lt; 0. */\n    }\n    tm-&gt;tm_year = c;  /* This assignment may overflow or underflow, we don't check it. Example: time_t is a huge int64_t, tm-&gt;tm_year is int32_t. */\n    /* Now: 0 &lt;= tm-&gt;tm_mon &lt;= 11. */\n    /* Now: 0 &lt;= yday &lt;= 365. */\n    tm-&gt;tm_yday = yday;\n    tm-&gt;tm_isdst = 0;\n    return tm;\n}\n\n\n// It  does not modify broken-down time\nlong long timegm(struct tm const* t)\n{\n    int year = t-&gt;tm_year + 1900;\n    int month = t-&gt;tm_mon;          // 0-11\n    if (month &gt; 11)\n    {\n        year += month / 12;\n        month %= 12;\n    }\n    else if (month &lt; 0)\n    {\n        int years_diff = (11 - month) / 12;\n        year -= years_diff;\n        month += 12 * years_diff;\n    }\n    int days_since_epoch = days_from_epoch(year, month + 1, t-&gt;tm_mday);\n\n    return 60LL * (60LL * (24LL * days_since_epoch + (long long)t-&gt;tm_hour) + (long long)t-&gt;tm_min) + (long long)t-&gt;tm_sec;\n}\n/*\nUTCClock::time_point UTCClock::fromDate(\n    int year, int month, int day, int hour, int min, int sec, int usec)\n{\n  std::tm tm     = {0};\n  tm.tm_year     = year - 1900;\n  tm.tm_mon      = month - 1;\n  tm.tm_mday     = day;\n  tm.tm_hour     = hour;\n  tm.tm_min      = min;\n  tm.tm_sec      = sec;\n  tm.tm_isdst    = -1;\n  std::time_t tt = timegm(&amp;tm);\n  return from_time_t(tt) + chrono::microseconds(usec);\n}\n\n\nvoid UTCClock::toDate(const UTCClock::time_point &amp;tp,\n                      int &amp;year,\n                      int &amp;month,\n                      int &amp;day,\n                      int &amp;hour,\n                      int &amp;min,\n                      int &amp;sec,\n                      int &amp;usec)\n{\n  std::time_t tt = to_time_t(tp);\n  std::tm tm;\n  gmtime_r(&amp;tt, &amp;tm);\n  year  = tm.tm_year + 1900;\n  month = tm.tm_mon + 1;\n  day   = tm.tm_mday;\n  hour  = tm.tm_hour;\n  min   = tm.tm_min;\n  chrono::microseconds leftover =\n      tp - from_time_t(tt) + chrono::seconds(tm.tm_sec);\n  sec = duration_cast&lt;chrono::seconds&gt;(leftover).count();\n  usec = (leftover-chrono::seconds(sec)).count();\n}\n*/\n\nlong long date_string_to_time(std::string date)\n{\n    struct tm tm = { 0 }; // Important, initialize all members\n    //int n = 0;\n    //int year, mon, day, hour, min, sec;\n    std::vector&lt;std::string&gt;  datetime, ddd, ttt;\n    datetime = split(date, 'T');\n    if (datetime.size() &lt; 2)\n    {\n        datetime.clear();\n        datetime = split(date, ' ');\n    }\n\n    ddd = split(datetime[0], '-');\n    if (ddd.size() &lt; 3)\n    {\n        ddd = split(datetime[0], '/');\n    }\n    // index for the year and mday\n    //by default we assume date is written as yyyy-mm-ddTHH:MM:SS\n    int indexyear = 0;\n    int indexmday = 2;\n\n    if (ddd[0].length() &lt; 4 &amp;&amp; ddd[2].length() == 4)//i.e. date is written as dd-mm-yyyy\n    {\n        int indexyear = 2;\n        int indexmday = 0;\n    }\n    // If you write date like an American (mm-dd-yyyy). it wont work and I can't help\n\n    tm.tm_year = std::stoi(ddd[indexyear]);\n\n    tm.tm_mon = std::stoi(ddd[1]);\n\n    tm.tm_mday = std::stoi(ddd[indexmday]);\n\n    if (datetime.size() &gt; 1)\n    {\n\n        ttt = split(datetime[1], ':');\n\n        tm.tm_hour = std::stoi(ttt[0]);\n        tm.tm_min = std::stoi(ttt[1]);\n        if (ttt.size() == 3)\n        {\n            tm.tm_sec = std::stoi(ttt[2]);\n        }\n        else\n        {\n            tm.tm_sec = 0;\n        }\n    }\n    else\n    {\n        tm.tm_hour = 0;\n        tm.tm_min = 0;\n        tm.tm_sec = 0;\n    }\n\n\n\n\n    //sscanf(date, \"%d-%d-%dT%d:%d:%d %n\", &amp;tm.tm_year, &amp;tm.tm_mon, &amp;tm.tm_mday,\n    //  &amp;tm.tm_hour, &amp;tm.tm_min, &amp;tm.tm_sec, &amp;n);\n    // If scan did not completely succeed or extra junk\n    //if (n == 0 || date[n]) {\n    //  return (time_t)-1;\n    //}\n    //tm.tm_isdst = 0; // Eforce output to be standard time. \n    tm.tm_mon--;      // Months since January\n    // Assume 2 digit year if in the range 2000-2099, else assume year as given\n    if (tm.tm_year &gt;= 0 &amp;&amp; tm.tm_year &lt; 100) {\n        tm.tm_year += 2000;\n    }\n    tm.tm_year -= 1900; // Years since 1900\n    //UTCTime t1 = UTCClock::fromDate(year, mon, day, hour, min, sec, 0);\n    long long t1 = timegm(&amp;tm);\n    return t1;\n}\n\ndouble date_string_to_s(std::string datetime, std::string refdate)\n{\n    //testime1(1);\n    //testime2(2);\n\n    //UTCTime ttime = date_string_to_time(datetime);\n    //UTCTime reftime = date_string_to_time(refdate);\n\n    double diff;\n\n    std::string::size_type n = datetime.find('T');\n    if (std::string::npos == n)\n    {\n        diff = std::stod(datetime);\n    }\n    else\n    {\n\n        long long ttime = date_string_to_time(datetime);\n        long long reftime = date_string_to_time(refdate);\n\n        //double diff = difftime(ttime, reftime);\n\n        //std::chrono::microseconds timeDiff = ttime - reftime;\n\n        //double diff = ((double) duration_cast&lt;std::chrono::milliseconds&gt;(ttime - reftime).count())/1000.0;\n\n        diff = (double)(ttime - reftime);\n    }\n\n    return diff;\n}\n\n// Read time string. If it is a valid datetime string return s from reftime otherwise return a foat of seconds \ndouble readinputtimetxt(std::string input, std::string &amp; refdate)\n{\n    std::string date = trim(input, \" \");\n    double timeinsec;\n    //check if string contains a T a marker of \n    std::vector&lt;std::string&gt;  datetime = split(date, 'T');\n\n    if (datetime.size() &gt; 1)\n    {\n        //likely a datetime\n        if (refdate.empty())\n        {\n            refdate = date;\n        }\n        timeinsec = date_string_to_s(date, refdate);\n\n\n    }\n    else\n    {\n        //Likely a float\n        timeinsec = std::stod(datetime[0]);\n    }\n\n    return timeinsec;\n}\n\nbool testime1(int hour)\n{\n    bool test = false;\n    double eps = 1e-7;\n\n    for (int iy = 1400; iy &lt;= 2800; iy++)\n    {\n        tm tm1, tm2;\n\n        tm1.tm_year = iy;\n        tm2.tm_year = iy;\n\n        tm1.tm_mday = 1;\n        tm2.tm_mday = 1;\n\n        tm1.tm_mon = 0;\n        tm2.tm_mon = 0;\n\n        tm1.tm_hour = 0;\n        tm2.tm_hour = hour;\n\n        tm1.tm_min = 0;\n        tm2.tm_min = 0;\n\n        tm1.tm_sec = 0;\n        tm2.tm_sec = 0;\n\n        //UTCTime t1 = UTCClock::fromDate(iy, 1, 1, 0, 0, 0, 0);\n        //UTCTime t2 = UTCClock::fromDate(iy, 1, 1, hour, 0, 0, 0);\n\n        long long t1 = timegm(&amp;tm1);\n        long long t2 = timegm(&amp;tm2);\n\n\n\n\n        //double dt12 = ((double)duration_cast&lt;std::chrono::milliseconds&gt;(t2 - t1).count()) / 1000.0;\n        double dt12 = (double)(t2 - t1);\n        test = abs(dt12 - (hour * 3600.0)) &lt; eps;\n        if (!test)\n        {\n            printf(\"Failed datetime calculation: year=%d\\n\", iy);\n            break;\n        }\n    }\n\n\n    return test;\n}\n\nbool testime2(int hour)\n{\n    bool test = false;\n\n\n    for (int iy = 1970; iy &lt;= 2400; iy++)\n    {\n        //UTCTime t1 = UTCClock::fromDate(1970, 1, 1, 0, 0, 0, 0);\n        //UTCTime t2 = UTCClock::fromDate(iy, 1, 1, hour, 0, 0, 0);\n        tm tm1, tm2;\n\n        tm1.tm_year = 1970;\n        tm2.tm_year = iy;\n\n        tm1.tm_mday = 1;\n        tm2.tm_mday = 1;\n\n        tm1.tm_mon = 0;\n        tm2.tm_mon = 0;\n\n        tm1.tm_hour = 0;\n        tm2.tm_hour = hour;\n\n        tm1.tm_min = 0;\n        tm2.tm_min = 0;\n\n        tm1.tm_sec = 0;\n        tm2.tm_sec = 0;\n\n        //UTCTime t1 = UTCClock::fromDate(iy, 1, 1, 0, 0, 0, 0);\n        //UTCTime t2 = UTCClock::fromDate(iy, 1, 1, hour, 0, 0, 0);\n\n        long long t1 = timegm(&amp;tm1);\n        long long t2 = timegm(&amp;tm2);\n\n\n\n        //double dt12 = ((double)duration_cast&lt;std::chrono::milliseconds&gt;(t2 - t1).count()) / 1000.0;\n\n        test = t2&gt;t1;\n        if (!test)\n        {\n\n            int dse = days_from_epoch(tm2.tm_year, tm2.tm_mon + 1, tm2.tm_mday);\n            printf(\"Failed datetime calculation greater than: year=%d\\n\", iy);\n            printf(\"dse=%d\\nt1 = %lld;\\n t2=%lld\\n\",dse, t1, t2);\n            break;\n        }\n    }\n\n\n    return test;\n}\n</code></pre>"},{"location":"BGFlood/utctime_8h/","title":"File utctime.h","text":""},{"location":"BGFlood/utctime_8h/#file-utctimeh","title":"File utctime.h","text":"<p>FileList &gt; src &gt; utctime.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"General.h\"</code></li> <li><code>#include \"ReadInput.h\"</code></li> </ul>"},{"location":"BGFlood/utctime_8h/#public-functions","title":"Public Functions","text":"Type Name double date_string_to_s (std::string datetime, std::string refdate) Convert a date string to seconds from a reference date. Converts a date string in the format \"YYYY-MM-DDTHH:MM:SS\" or \"YYYY/MM/DD HH:MM:SS\" to seconds from the reference date. long long date_string_to_time (std::string date) Convert a date string to a Unix timestamp. Converts a date string in the format \"YYYY-MM-DDTHH:MM:SS\" or \"YYYY/MM/DD HH:MM:SS\" to a Unix timestamp (number of seconds since the beginning of 1970 CE). double readinputtimetxt (std::string input, std::string &amp; refdate) Read a time string and convert it to seconds. Reads a time string and converts it to seconds. If the string is a valid datetime string it returns the seconds from the reference date, otherwise it returns a float of seconds. bool testime1 (int hour) Test time calculation functions. Test time calculation functions. bool testime2 (int hour) Test time calculation functions for greater than comparison. Test time calculation functions for greater than comparison."},{"location":"BGFlood/utctime_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"BGFlood/utctime_8h/#function-date_string_to_s","title":"function date_string_to_s","text":"<p>Convert a date string to seconds from a reference date. Converts a date string in the format \"YYYY-MM-DDTHH:MM:SS\" or \"YYYY/MM/DD HH:MM:SS\" to seconds from the reference date. </p><pre><code>double date_string_to_s (\n    std::string datetime,\n    std::string refdate\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>datetime</code> The date string to convert </li> <li><code>refdate</code> The reference date string </li> </ul> <p>Returns:</p> <p>The number of seconds from the reference date as double </p>"},{"location":"BGFlood/utctime_8h/#function-date_string_to_time","title":"function date_string_to_time","text":"<p>Convert a date string to a Unix timestamp. Converts a date string in the format \"YYYY-MM-DDTHH:MM:SS\" or \"YYYY/MM/DD HH:MM:SS\" to a Unix timestamp (number of seconds since the beginning of 1970 CE). </p><pre><code>long long date_string_to_time (\n    std::string date\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>date</code> The date string to convert </li> </ul> <p>Returns:</p> <p>The corresponding Unix timestamp as long long </p>"},{"location":"BGFlood/utctime_8h/#function-readinputtimetxt","title":"function readinputtimetxt","text":"<p>Read a time string and convert it to seconds. Reads a time string and converts it to seconds. If the string is a valid datetime string it returns the seconds from the reference date, otherwise it returns a float of seconds. </p><pre><code>double readinputtimetxt (\n    std::string input,\n    std::string &amp; refdate\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>input</code> The input time string </li> <li><code>refdate</code> The reference date string </li> </ul> <p>Returns:</p> <p>The time in seconds as double </p>"},{"location":"BGFlood/utctime_8h/#function-testime1","title":"function testime1","text":"<p>Test time calculation functions. Test time calculation functions. </p><pre><code>bool testime1 (\n    int hour\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>hour</code> The hour to test </li> </ul>"},{"location":"BGFlood/utctime_8h/#function-testime2","title":"function testime2","text":"<p>Test time calculation functions for greater than comparison. Test time calculation functions for greater than comparison. </p><pre><code>bool testime2 (\n    int hour\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>hour</code> The hour to test </li> </ul> <p>The documentation for this class was generated from the following file <code>src/utctime.h</code></p>"},{"location":"BGFlood/utctime_8h_source/","title":"File utctime.h","text":""},{"location":"BGFlood/utctime_8h_source/#file-utctimeh","title":"File utctime.h","text":"<p>File List &gt; src &gt; utctime.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef UTCTIME_H\n#define UTCTIME_H\n\n#include \"General.h\"\n#include \"ReadInput.h\"\n/*\nstruct UTCClock\n{\n    typedef std::chrono::microseconds duration;\n    typedef duration::rep rep;\n    typedef duration::period period;\n    typedef std::chrono::time_point&lt;UTCClock, duration&gt; time_point;\n    static const bool is_steady = true;\n\n    //      \n    // every time_point will be generated from here\n    //\n    static time_point fromDate(int year = 0, int month = 0, int day = 0,\n        int hour = 0, int min = 0, int sec = 0,\n        int usec = 0);\n    //\n    // convert time_point to a date/time representation\n    //\n    static void toDate(const time_point&amp; tp,\n        int&amp; year, int&amp; month, int&amp; day,\n        int&amp; hour, int&amp; min, int&amp; sec,\n        int&amp; usec);\n\n    // NOT Supported, we don't need current time. We only\n    // want to represent UTC DateTime\n    // static time_point now(); \n};\n*/\n//using UTCTime = std::chrono::time_point&lt;UTCClock, std::chrono::microseconds&gt;;\n\nlong long date_string_to_time(std::string date);\ndouble date_string_to_s(std::string datetime, std::string refdate);\ndouble readinputtimetxt(std::string input, std::string &amp; refdate);\nbool testime1(int hour);\nbool testime2(int hour);\n\n#endif\n</code></pre>"},{"location":"BGFlood/namespaces/","title":"List","text":""},{"location":"BGFlood/namespaces/#namespace-list","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace utils </li> </ul>"},{"location":"BGFlood/classes/","title":"Index","text":""},{"location":"BGFlood/classes/#class-index","title":"Class Index","text":""},{"location":"BGFlood/classes/#a","title":"a","text":"<ul> <li>AdaptP</li> <li>AdvanceP</li> <li>AOIinfo</li> </ul>"},{"location":"BGFlood/classes/#b","title":"b","text":"<ul> <li>BlockP</li> <li>BndblockP</li> <li>bndparam</li> <li>bndsegment</li> <li>bndsegmentside</li> <li>bndTexP</li> </ul>"},{"location":"BGFlood/classes/#d","title":"d","text":"<ul> <li>deformmap</li> <li>DynForcingP</li> </ul>"},{"location":"BGFlood/classes/#e","title":"e","text":"<ul> <li>EvolvingMLP</li> <li>EvolvingP</li> <li>EvolvingP_M</li> </ul>"},{"location":"BGFlood/classes/#f","title":"f","text":"<ul> <li>Flowin</li> <li>FluxMLP</li> <li>FluxP</li> <li>Forcing</li> <li>forcingmap</li> </ul>"},{"location":"BGFlood/classes/#g","title":"g","text":"<ul> <li>GradientsMLP</li> <li>GradientsP</li> </ul>"},{"location":"BGFlood/classes/#i","title":"i","text":"<ul> <li>inputmap</li> </ul>"},{"location":"BGFlood/classes/#l","title":"l","text":"<ul> <li>Loop</li> </ul>"},{"location":"BGFlood/classes/#m","title":"m","text":"<ul> <li>Mapparam</li> <li>maskinfo</li> <li>Model</li> </ul>"},{"location":"BGFlood/classes/#o","title":"o","text":"<ul> <li>outP</li> <li>outzoneB</li> <li>outzoneP</li> </ul>"},{"location":"BGFlood/classes/#p","title":"p","text":"<ul> <li>Param</li> <li>Pointout</li> <li>Polygon</li> </ul>"},{"location":"BGFlood/classes/#r","title":"r","text":"<ul> <li>River</li> <li>RiverBlk</li> <li>RiverInfo</li> </ul>"},{"location":"BGFlood/classes/#s","title":"s","text":"<ul> <li>SharedMemory</li> <li>SharedMemory&lt; double &gt;</li> <li>SLTS</li> <li>StaticForcingP</li> </ul>"},{"location":"BGFlood/classes/#t","title":"t","text":"<ul> <li>T_output</li> <li>TexSetP</li> <li>TimeP</li> <li>TSoutnode</li> </ul>"},{"location":"BGFlood/classes/#v","title":"v","text":"<ul> <li>Vertex</li> </ul>"},{"location":"BGFlood/classes/#w","title":"w","text":"<ul> <li>Windin</li> </ul>"},{"location":"BGFlood/hierarchy/","title":"Hierarchy","text":""},{"location":"BGFlood/hierarchy/#class-hierarchy","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class AOIinfo </li> <li>class Flowin </li> <li>class Mapparam </li> <li>class Param </li> <li>class Pointout </li> <li>class Polygon </li> <li>class River </li> <li>class SLTS </li> <li>class TSoutnode </li> <li>class T_output </li> <li>class Vertex </li> <li>class Windin </li> <li>class bndparam </li> <li>class bndsegment </li> <li>class bndsegmentside </li> <li>class inputmap <ul> <li>struct StaticForcingP </li> <li>class deformmap </li> <li>class forcingmap <ul> <li>struct DynForcingP </li> <li>struct DynForcingP </li> </ul> </li> </ul> </li> <li>class outzoneP </li> <li>struct AdaptP </li> <li>struct AdvanceP Structure holding advance variables for time stepping. </li> <li>struct BlockP </li> <li>struct BndblockP </li> <li>struct EvolvingMLP Structure holding evolving variables (no z relative variables). </li> <li>struct EvolvingP Structure holding evolving physical variables. <ul> <li>struct EvolvingP_M Structure for mean/max evolving variables, inherits from EvolvingP .</li> </ul> </li> <li>struct FluxMLP Structure holding flux variables (no z relative variables). </li> <li>struct FluxP Structure holding flux variables for advection. </li> <li>struct Forcing </li> <li>struct GradientsMLP Structure holding gradient arrays (no z relative variables). </li> <li>struct GradientsP Structure holding gradient arrays for physical variables. </li> <li>struct Loop </li> <li>struct Model </li> <li>struct RiverBlk </li> <li>struct RiverInfo </li> <li>struct SharedMemory </li> <li>struct SharedMemory&lt; double &gt; </li> <li>struct TexSetP </li> <li>struct TimeP </li> <li>struct bndTexP </li> <li>struct maskinfo </li> <li>struct outP </li> <li>struct outzoneB </li> </ul>"},{"location":"BGFlood/modules/","title":"Modules","text":""},{"location":"BGFlood/modules/#modules","title":"Modules","text":"<p>No modules found.</p>"},{"location":"BGFlood/pages/","title":"Related Pages","text":""},{"location":"BGFlood/pages/#related-pages","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"BGFlood/class_members/","title":"Members","text":""},{"location":"BGFlood/class_members/#class-members","title":"Class Members","text":""},{"location":"BGFlood/class_members/#a","title":"a","text":"<ul> <li>active (AOIinfo, BlockP)</li> <li>availblk (AdaptP)</li> <li>activeCell (BlockP)</li> <li>after (DynForcingP)</li> <li>after_g (DynForcingP)</li> <li>AOI (Forcing)</li> <li>Atmp (Forcing)</li> <li>atmpstep (Loop)</li> <li>atmpuni (Loop)</li> <li>atmpuniform (Loop)</li> <li>adapt (Model)</li> <li>adv (Model)</li> <li>AdaptCrit (Param)</li> <li>AdaptCrit_funct_pointer (Param)</li> <li>Adapt_arg1 (Param)</li> <li>Adapt_arg2 (Param)</li> <li>Adapt_arg3 (Param)</li> <li>Adapt_arg4 (Param)</li> <li>Adapt_arg5 (Param)</li> <li>adaptmaxiteration (Param)</li> <li>addoffset (Param)</li> <li>aoibnd (Param)</li> <li>atmpforcing (Param)</li> <li>arrmax (TimeP)</li> <li>arrmin (TimeP)</li> </ul>"},{"location":"BGFlood/class_members/#b","title":"b","text":"<ul> <li>BotLeft (BlockP)</li> <li>BotRight (BlockP)</li> <li>bot (BndblockP, Forcing, bndsegment)</li> <li>before (DynForcingP)</li> <li>before_g (DynForcingP)</li> <li>Bathy (Forcing)</li> <li>bndseg (Forcing)</li> <li>blockDim (Loop)</li> <li>blocks (Model)</li> <li>bndblk (Model)</li> <li>blkmemwidth (Param)</li> <li>blksize (Param)</li> <li>blkwidth (Param)</li> <li>bndfiltertime (Param)</li> <li>bndrelaxtime (Param)</li> <li>bndtaper (Param)</li> <li>botbnd (Param)</li> <li>block (River, RiverBlk, TSoutnode)</li> <li>blks (bndparam, maskinfo)</li> <li>blks_g (bndparam)</li> <li>blk (bndsegmentside, outzoneB)</li> <li>blk_g (bndsegmentside)</li> </ul>"},{"location":"BGFlood/class_members/#c","title":"c","text":"<ul> <li>coarsen (AdaptP)</li> <li>csumblk (AdaptP)</li> <li>clampedge (DynForcingP, deformmap)</li> <li>cf (Forcing, Model, Param)</li> <li>cl (Forcing, Model, Param)</li> <li>CFL (Param)</li> <li>Cd (Param)</li> <li>conserveElevation (Param)</li> <li>crs_ref (Param)</li> <li>CudArr (TexSetP)</li> <li>channelDesc (TexSetP)</li> </ul>"},{"location":"BGFlood/class_members/#d","title":"d","text":"<ul> <li>dh (AdvanceP)</li> <li>dhu (AdvanceP)</li> <li>dhv (AdvanceP)</li> <li>deform (Forcing)</li> <li>dhdx (GradientsMLP, GradientsP)</li> <li>dhdy (GradientsMLP, GradientsP)</li> <li>dudx (GradientsMLP, GradientsP)</li> <li>dudy (GradientsMLP, GradientsP)</li> <li>dvdx (GradientsMLP, GradientsP)</li> <li>dvdy (GradientsMLP, GradientsP)</li> <li>dzbdx (GradientsP)</li> <li>dzbdy (GradientsP)</li> <li>dzsdx (GradientsP)</li> <li>dzsdy (GradientsP)</li> <li>dt (Loop, Param, TimeP, forcingmap)</li> <li>dtmax (Loop, TimeP)</li> <li>datmpdx (Model)</li> <li>datmpdy (Model)</li> <li>deformmaxtime (Param)</li> <li>delta (Param)</li> <li>doubleprecision (Param)</li> <li>dtinit (Param)</li> <li>dtmin (Param)</li> <li>dx (Param, TexSetP, inputmap)</li> <li>disarea (River)</li> <li>dy (TexSetP, inputmap)</li> <li>data (bndparam, bndsegment)</li> <li>duration (deformmap)</li> <li>denanval (inputmap)</li> </ul>"},{"location":"BGFlood/class_members/#e","title":"e","text":"<ul> <li>epsilon (Loop)</li> <li>evmax (Model)</li> <li>evmean (Model)</li> <li>evolv (Model)</li> <li>evolv_o (Model)</li> <li>endcputime (Param)</li> <li>endtime (Param)</li> <li>engine (Param)</li> <li>eps (Param)</li> <li>end (T_output)</li> <li>extension (inputmap)</li> </ul>"},{"location":"BGFlood/class_members/#f","title":"f","text":"<ul> <li>file (AOIinfo)</li> <li>Fux (FluxMLP)</li> <li>Fuy (FluxMLP)</li> <li>Fvx (FluxMLP)</li> <li>Fvy (FluxMLP)</li> <li>Fhu (FluxP)</li> <li>Fhv (FluxP)</li> <li>Fqux (FluxP)</li> <li>Fquy (FluxP)</li> <li>Fqvx (FluxP)</li> <li>Fqvy (FluxP)</li> <li>flux (Model)</li> <li>fluxml (Model)</li> <li>ForceMassConserve (Param)</li> <li>frictionmodel (Param)</li> <li>flowinput (River)</li> <li>flipxx (inputmap)</li> <li>flipyy (inputmap)</li> </ul>"},{"location":"BGFlood/class_members/#g","title":"g","text":"<ul> <li>gridDim (Loop)</li> <li>grad (Model)</li> <li>GPUDEVICE (Param)</li> <li>GPU_initmem_byte (Param)</li> <li>GPU_totalmem_byte (Param)</li> <li>g (Param)</li> <li>grdalpha (Param, inputmap)</li> <li>GPU (bndparam, deformmap, forcingmap)</li> </ul>"},{"location":"BGFlood/class_members/#h","title":"h","text":"<ul> <li>h (EvolvingMLP, EvolvingP, Pointout)</li> <li>hU (EvolvingP_M)</li> <li>hau (FluxMLP)</li> <li>hav (FluxMLP)</li> <li>hfu (FluxMLP)</li> <li>hfv (FluxMLP)</li> <li>hu (FluxMLP)</li> <li>hv (FluxMLP)</li> <li>hugenegval (Loop)</li> <li>hugeposval (Loop)</li> <li>hgw (Model)</li> <li>halowidth (Param)</li> <li>hotstartfile (Param)</li> <li>hotstep (Param)</li> </ul>"},{"location":"BGFlood/class_members/#i","title":"i","text":"<ul> <li>invactive (AdaptP)</li> <li>il (Forcing, Model, Param)</li> <li>indNextoutputtime (Loop)</li> <li>infiltration (Param)</li> <li>initlevel (Param)</li> <li>inittime (Param)</li> <li>i (River, TSoutnode)</li> <li>init (T_output)</li> <li>inputstr (T_output)</li> <li>inputfile (bndparam, bndsegment, forcingmap, inputmap)</li> <li>isright (bndparam, bndsegmentside)</li> <li>istop (bndparam, bndsegmentside)</li> <li>iscavity (deformmap)</li> <li>instep (forcingmap)</li> <li>index_next_OutputT (outzoneB)</li> </ul>"},{"location":"BGFlood/class_members/#j","title":"j","text":"<ul> <li>j (River, TSoutnode)</li> </ul>"},{"location":"BGFlood/class_members/#l","title":"l","text":"<ul> <li>LeftBot (BlockP)</li> <li>LeftTop (BlockP)</li> <li>level (BlockP, outP)</li> <li>left (BndblockP, Forcing, bndsegment)</li> <li>lat (Param)</li> <li>leftbnd (Param)</li> </ul>"},{"location":"BGFlood/class_members/#m","title":"m","text":"<ul> <li>mask (BlockP, Param)</li> <li>maxTSstorage (Param)</li> <li>maxlevel (Param, outzoneB)</li> <li>membuffer (Param)</li> <li>minlevel (Param, outzoneB)</li> </ul>"},{"location":"BGFlood/class_members/#n","title":"n","text":"<ul> <li>newlevel (AdaptP)</li> <li>nblkTs (BndblockP)</li> <li>nblkriver (BndblockP, Param)</li> <li>nbndblkbot (BndblockP, Param)</li> <li>nbndblkleft (BndblockP, Param)</li> <li>nbndblkright (BndblockP, Param)</li> <li>nbndblktop (BndblockP, Param)</li> <li>now (DynForcingP)</li> <li>now_g (DynForcingP)</li> <li>nTSsteps (Loop)</li> <li>nextoutputtime (Loop)</li> <li>nstep (Loop)</li> <li>nstepout (Loop)</li> <li>num_streams (Loop)</li> <li>navailblk (Param)</li> <li>nblk (Param, bndparam, bndsegment, bndsegmentside, maskinfo, outzoneB)</li> <li>nblkmem (Param)</li> <li>nmaskblk (Param)</li> <li>nrivers (Param)</li> <li>nx (Param, inputmap)</li> <li>ny (Param, inputmap)</li> <li>nbir (RiverInfo)</li> <li>nburmax (RiverInfo)</li> <li>nribmax (RiverInfo)</li> <li>nowvalue (TexSetP, forcingmap)</li> <li>nbnd (bndparam, bndsegment)</li> <li>nt (forcingmap)</li> </ul>"},{"location":"BGFlood/class_members/#o","title":"o","text":"<ul> <li>outZone (BlockP)</li> <li>OutputT (Model, outzoneB)</li> <li>OutputVarMap (Model)</li> <li>Outvarlongname (Model)</li> <li>Outvarstdname (Model)</li> <li>Outvarunits (Model)</li> <li>outfile (Param)</li> <li>outishift (Param)</li> <li>outjshift (Param)</li> <li>outmax (Param)</li> <li>outmean (Param)</li> <li>outputtimestep (Param)</li> <li>outtwet (Param)</li> <li>outvars (Param)</li> <li>outzone (Param)</li> <li>operator T* (SharedMemory)</li> <li>operator const T * (SharedMemory)</li> <li>operator const double * (SharedMemory&lt; double &gt;)</li> <li>operator double * (SharedMemory&lt; double &gt;)</li> <li>outname (TSoutnode, outzoneB, outzoneP)</li> <li>on (bndparam, bndsegment)</li> </ul>"},{"location":"BGFlood/class_members/#p","title":"p","text":"<ul> <li>poly (AOIinfo, bndsegment)</li> <li>Patm (Model)</li> <li>Pa2m (Param)</li> <li>Paref (Param)</li> <li>posdown (Param)</li> <li>polyfile (bndsegment)</li> </ul>"},{"location":"BGFlood/class_members/#q","title":"q","text":"<ul> <li>q (Flowin)</li> <li>qnow (RiverInfo)</li> <li>qnow_g (RiverInfo)</li> <li>qmean (bndparam, bndsegmentside)</li> <li>qmean_g (bndparam, bndsegmentside)</li> </ul>"},{"location":"BGFlood/class_members/#r","title":"r","text":"<ul> <li>refine (AdaptP)</li> <li>RightBot (BlockP)</li> <li>RightTop (BlockP)</li> <li>Riverinfo (BndblockP)</li> <li>right (BndblockP, Forcing, bndsegment)</li> <li>river (BndblockP)</li> <li>Rain (Forcing)</li> <li>rivers (Forcing)</li> <li>rainstep (Loop)</li> <li>rainuni (Loop)</li> <li>rainuniform (Loop)</li> <li>Radius (Param)</li> <li>rainbnd (Param)</li> <li>rainforcing (Param)</li> <li>reftime (Param)</li> <li>resetmax (Param)</li> <li>rho (Param)</li> <li>rightbnd (Param)</li> <li>Riverflowfile (River)</li> <li>resDesc (TexSetP)</li> </ul>"},{"location":"BGFlood/class_members/#s","title":"s","text":"<ul> <li>Su (FluxP)</li> <li>Sv (FluxP)</li> <li>streams (Loop)</li> <li>savebyblk (Param)</li> <li>scalefactor (Param)</li> <li>setupcputime (Param)</li> <li>smallnc (Param)</li> <li>spherical (Param)</li> <li>startcputime (Param)</li> <li>side (bndparam, maskinfo)</li> <li>startime (deformmap)</li> </ul>"},{"location":"BGFlood/class_members/#t","title":"t","text":"<ul> <li>TopLeft (BlockP)</li> <li>TopRight (BlockP)</li> <li>Tsout (BndblockP)</li> <li>top (BndblockP, Forcing, bndsegment)</li> <li>time (Flowin, Model, Pointout, SLTS, Windin)</li> <li>targetadapt (Forcing)</li> <li>TSAllout (Loop)</li> <li>totaltime (Loop, Param, TimeP)</li> <li>TSstore (Model)</li> <li>TSnodesout (Param)</li> <li>Toutput (Param, outzoneP)</li> <li>test (Param)</li> <li>theta (Param)</li> <li>topbnd (Param)</li> <li>tmax (River, forcingmap)</li> <li>to (River, forcingmap)</li> <li>tstep (T_output)</li> <li>tex (TexSetP)</li> <li>texDesc (TexSetP)</li> <li>type (bndparam, bndsegment, maskinfo)</li> </ul>"},{"location":"BGFlood/class_members/#u","title":"u","text":"<ul> <li>u (EvolvingMLP, EvolvingP, Pointout)</li> <li>U (EvolvingP_M)</li> <li>UWind (Forcing)</li> <li>uwinduni (Loop)</li> <li>uuvel (SLTS)</li> <li>uniform (TexSetP, bndsegment, forcingmap)</li> <li>uwind (Windin)</li> <li>Uvel (bndTexP)</li> <li>unidata (forcingmap)</li> </ul>"},{"location":"BGFlood/class_members/#v","title":"v","text":"<ul> <li>val (DynForcingP, StaticForcingP, T_output, deformmap)</li> <li>v (EvolvingMLP, EvolvingP, Pointout)</li> <li>VWind (Forcing)</li> <li>vwinduni (Loop)</li> <li>VelThreshold (Param)</li> <li>vertices (Polygon)</li> <li>vvvel (SLTS)</li> <li>vwind (Windin)</li> <li>Vvel (bndTexP)</li> <li>varname (inputmap)</li> </ul>"},{"location":"BGFlood/class_members/#w","title":"w","text":"<ul> <li>windstep (Loop)</li> <li>winduniform (Loop)</li> <li>wettime (Model)</li> <li>wet_threshold (Param)</li> <li>wetdryfix (Param)</li> <li>windforcing (Param)</li> <li>wlevs (SLTS)</li> <li>wdirection (Windin)</li> <li>wspeed (Windin)</li> <li>WLS (bndTexP)</li> <li>WLmap (bndsegment)</li> </ul>"},{"location":"BGFlood/class_members/#x","title":"x","text":"<ul> <li>xo (BlockP, Param, TexSetP, inputmap, outzoneB)</li> <li>xmax (Param, Polygon, inputmap, outP, outzoneB)</li> <li>xmin (Polygon, outP)</li> <li>xend (River, RiverInfo, outzoneP)</li> <li>xstart (River, RiverInfo, outzoneP)</li> <li>Xbidir (RiverInfo)</li> <li>Xridib (RiverInfo)</li> <li>x (TSoutnode, Vertex)</li> </ul>"},{"location":"BGFlood/class_members/#y","title":"y","text":"<ul> <li>yo (BlockP, Param, TexSetP, inputmap, outzoneB)</li> <li>ymax (Param, Polygon, inputmap, outP, outzoneB)</li> <li>ymin (Polygon, outP)</li> <li>yend (River, RiverInfo, outzoneP)</li> <li>ystart (River, RiverInfo, outzoneP)</li> <li>y (TSoutnode, Vertex)</li> </ul>"},{"location":"BGFlood/class_members/#z","title":"z","text":"<ul> <li>zs (EvolvingP, Pointout)</li> <li>zb (Model)</li> <li>zsinit (Param)</li> <li>zsoffset (Param)</li> <li>z (outP)</li> <li>z_s (outP)</li> </ul>"},{"location":"BGFlood/class_member_functions/","title":"Member Functions","text":""},{"location":"BGFlood/class_member_functions/#class-member-functions","title":"Class Member Functions","text":""},{"location":"BGFlood/class_member_functions/#o","title":"o","text":"<ul> <li>operator T* (SharedMemory)</li> <li>operator const T * (SharedMemory)</li> <li>operator const double * (SharedMemory&lt; double &gt;)</li> <li>operator double * (SharedMemory&lt; double &gt;)</li> </ul>"},{"location":"BGFlood/class_member_variables/","title":"Member Variables","text":""},{"location":"BGFlood/class_member_variables/#class-member-variables","title":"Class Member Variables","text":""},{"location":"BGFlood/class_member_variables/#a","title":"a","text":"<ul> <li>active (AOIinfo, BlockP)</li> <li>availblk (AdaptP)</li> <li>activeCell (BlockP)</li> <li>after (DynForcingP)</li> <li>after_g (DynForcingP)</li> <li>AOI (Forcing)</li> <li>Atmp (Forcing)</li> <li>atmpstep (Loop)</li> <li>atmpuni (Loop)</li> <li>atmpuniform (Loop)</li> <li>adapt (Model)</li> <li>adv (Model)</li> <li>AdaptCrit (Param)</li> <li>AdaptCrit_funct_pointer (Param)</li> <li>Adapt_arg1 (Param)</li> <li>Adapt_arg2 (Param)</li> <li>Adapt_arg3 (Param)</li> <li>Adapt_arg4 (Param)</li> <li>Adapt_arg5 (Param)</li> <li>adaptmaxiteration (Param)</li> <li>addoffset (Param)</li> <li>aoibnd (Param)</li> <li>atmpforcing (Param)</li> <li>arrmax (TimeP)</li> <li>arrmin (TimeP)</li> </ul>"},{"location":"BGFlood/class_member_variables/#b","title":"b","text":"<ul> <li>BotLeft (BlockP)</li> <li>BotRight (BlockP)</li> <li>bot (BndblockP, Forcing, bndsegment)</li> <li>before (DynForcingP)</li> <li>before_g (DynForcingP)</li> <li>Bathy (Forcing)</li> <li>bndseg (Forcing)</li> <li>blockDim (Loop)</li> <li>blocks (Model)</li> <li>bndblk (Model)</li> <li>blkmemwidth (Param)</li> <li>blksize (Param)</li> <li>blkwidth (Param)</li> <li>bndfiltertime (Param)</li> <li>bndrelaxtime (Param)</li> <li>bndtaper (Param)</li> <li>botbnd (Param)</li> <li>block (River, RiverBlk, TSoutnode)</li> <li>blks (bndparam, maskinfo)</li> <li>blks_g (bndparam)</li> <li>blk (bndsegmentside, outzoneB)</li> <li>blk_g (bndsegmentside)</li> </ul>"},{"location":"BGFlood/class_member_variables/#c","title":"c","text":"<ul> <li>coarsen (AdaptP)</li> <li>csumblk (AdaptP)</li> <li>clampedge (DynForcingP, deformmap)</li> <li>cf (Forcing, Model, Param)</li> <li>cl (Forcing, Model, Param)</li> <li>CFL (Param)</li> <li>Cd (Param)</li> <li>conserveElevation (Param)</li> <li>crs_ref (Param)</li> <li>CudArr (TexSetP)</li> <li>channelDesc (TexSetP)</li> </ul>"},{"location":"BGFlood/class_member_variables/#d","title":"d","text":"<ul> <li>dh (AdvanceP)</li> <li>dhu (AdvanceP)</li> <li>dhv (AdvanceP)</li> <li>deform (Forcing)</li> <li>dhdx (GradientsMLP, GradientsP)</li> <li>dhdy (GradientsMLP, GradientsP)</li> <li>dudx (GradientsMLP, GradientsP)</li> <li>dudy (GradientsMLP, GradientsP)</li> <li>dvdx (GradientsMLP, GradientsP)</li> <li>dvdy (GradientsMLP, GradientsP)</li> <li>dzbdx (GradientsP)</li> <li>dzbdy (GradientsP)</li> <li>dzsdx (GradientsP)</li> <li>dzsdy (GradientsP)</li> <li>dt (Loop, Param, TimeP, forcingmap)</li> <li>dtmax (Loop, TimeP)</li> <li>datmpdx (Model)</li> <li>datmpdy (Model)</li> <li>deformmaxtime (Param)</li> <li>delta (Param)</li> <li>doubleprecision (Param)</li> <li>dtinit (Param)</li> <li>dtmin (Param)</li> <li>dx (Param, TexSetP, inputmap)</li> <li>disarea (River)</li> <li>dy (TexSetP, inputmap)</li> <li>data (bndparam, bndsegment)</li> <li>duration (deformmap)</li> <li>denanval (inputmap)</li> </ul>"},{"location":"BGFlood/class_member_variables/#e","title":"e","text":"<ul> <li>epsilon (Loop)</li> <li>evmax (Model)</li> <li>evmean (Model)</li> <li>evolv (Model)</li> <li>evolv_o (Model)</li> <li>endcputime (Param)</li> <li>endtime (Param)</li> <li>engine (Param)</li> <li>eps (Param)</li> <li>end (T_output)</li> <li>extension (inputmap)</li> </ul>"},{"location":"BGFlood/class_member_variables/#f","title":"f","text":"<ul> <li>file (AOIinfo)</li> <li>Fux (FluxMLP)</li> <li>Fuy (FluxMLP)</li> <li>Fvx (FluxMLP)</li> <li>Fvy (FluxMLP)</li> <li>Fhu (FluxP)</li> <li>Fhv (FluxP)</li> <li>Fqux (FluxP)</li> <li>Fquy (FluxP)</li> <li>Fqvx (FluxP)</li> <li>Fqvy (FluxP)</li> <li>flux (Model)</li> <li>fluxml (Model)</li> <li>ForceMassConserve (Param)</li> <li>frictionmodel (Param)</li> <li>flowinput (River)</li> <li>flipxx (inputmap)</li> <li>flipyy (inputmap)</li> </ul>"},{"location":"BGFlood/class_member_variables/#g","title":"g","text":"<ul> <li>gridDim (Loop)</li> <li>grad (Model)</li> <li>GPUDEVICE (Param)</li> <li>GPU_initmem_byte (Param)</li> <li>GPU_totalmem_byte (Param)</li> <li>g (Param)</li> <li>grdalpha (Param, inputmap)</li> <li>GPU (bndparam, deformmap, forcingmap)</li> </ul>"},{"location":"BGFlood/class_member_variables/#h","title":"h","text":"<ul> <li>h (EvolvingMLP, EvolvingP, Pointout)</li> <li>hU (EvolvingP_M)</li> <li>hau (FluxMLP)</li> <li>hav (FluxMLP)</li> <li>hfu (FluxMLP)</li> <li>hfv (FluxMLP)</li> <li>hu (FluxMLP)</li> <li>hv (FluxMLP)</li> <li>hugenegval (Loop)</li> <li>hugeposval (Loop)</li> <li>hgw (Model)</li> <li>halowidth (Param)</li> <li>hotstartfile (Param)</li> <li>hotstep (Param)</li> </ul>"},{"location":"BGFlood/class_member_variables/#i","title":"i","text":"<ul> <li>invactive (AdaptP)</li> <li>il (Forcing, Model, Param)</li> <li>indNextoutputtime (Loop)</li> <li>infiltration (Param)</li> <li>initlevel (Param)</li> <li>inittime (Param)</li> <li>i (River, TSoutnode)</li> <li>init (T_output)</li> <li>inputstr (T_output)</li> <li>inputfile (bndparam, bndsegment, forcingmap, inputmap)</li> <li>isright (bndparam, bndsegmentside)</li> <li>istop (bndparam, bndsegmentside)</li> <li>iscavity (deformmap)</li> <li>instep (forcingmap)</li> <li>index_next_OutputT (outzoneB)</li> </ul>"},{"location":"BGFlood/class_member_variables/#j","title":"j","text":"<ul> <li>j (River, TSoutnode)</li> </ul>"},{"location":"BGFlood/class_member_variables/#l","title":"l","text":"<ul> <li>LeftBot (BlockP)</li> <li>LeftTop (BlockP)</li> <li>level (BlockP, outP)</li> <li>left (BndblockP, Forcing, bndsegment)</li> <li>lat (Param)</li> <li>leftbnd (Param)</li> </ul>"},{"location":"BGFlood/class_member_variables/#m","title":"m","text":"<ul> <li>mask (BlockP, Param)</li> <li>maxTSstorage (Param)</li> <li>maxlevel (Param, outzoneB)</li> <li>membuffer (Param)</li> <li>minlevel (Param, outzoneB)</li> </ul>"},{"location":"BGFlood/class_member_variables/#n","title":"n","text":"<ul> <li>newlevel (AdaptP)</li> <li>nblkTs (BndblockP)</li> <li>nblkriver (BndblockP, Param)</li> <li>nbndblkbot (BndblockP, Param)</li> <li>nbndblkleft (BndblockP, Param)</li> <li>nbndblkright (BndblockP, Param)</li> <li>nbndblktop (BndblockP, Param)</li> <li>now (DynForcingP)</li> <li>now_g (DynForcingP)</li> <li>nTSsteps (Loop)</li> <li>nextoutputtime (Loop)</li> <li>nstep (Loop)</li> <li>nstepout (Loop)</li> <li>num_streams (Loop)</li> <li>navailblk (Param)</li> <li>nblk (Param, bndparam, bndsegment, bndsegmentside, maskinfo, outzoneB)</li> <li>nblkmem (Param)</li> <li>nmaskblk (Param)</li> <li>nrivers (Param)</li> <li>nx (Param, inputmap)</li> <li>ny (Param, inputmap)</li> <li>nbir (RiverInfo)</li> <li>nburmax (RiverInfo)</li> <li>nribmax (RiverInfo)</li> <li>nowvalue (TexSetP, forcingmap)</li> <li>nbnd (bndparam, bndsegment)</li> <li>nt (forcingmap)</li> </ul>"},{"location":"BGFlood/class_member_variables/#o","title":"o","text":"<ul> <li>outZone (BlockP)</li> <li>OutputT (Model, outzoneB)</li> <li>OutputVarMap (Model)</li> <li>Outvarlongname (Model)</li> <li>Outvarstdname (Model)</li> <li>Outvarunits (Model)</li> <li>outfile (Param)</li> <li>outishift (Param)</li> <li>outjshift (Param)</li> <li>outmax (Param)</li> <li>outmean (Param)</li> <li>outputtimestep (Param)</li> <li>outtwet (Param)</li> <li>outvars (Param)</li> <li>outzone (Param)</li> <li>outname (TSoutnode, outzoneB, outzoneP)</li> <li>on (bndparam, bndsegment)</li> </ul>"},{"location":"BGFlood/class_member_variables/#p","title":"p","text":"<ul> <li>poly (AOIinfo, bndsegment)</li> <li>Patm (Model)</li> <li>Pa2m (Param)</li> <li>Paref (Param)</li> <li>posdown (Param)</li> <li>polyfile (bndsegment)</li> </ul>"},{"location":"BGFlood/class_member_variables/#q","title":"q","text":"<ul> <li>q (Flowin)</li> <li>qnow (RiverInfo)</li> <li>qnow_g (RiverInfo)</li> <li>qmean (bndparam, bndsegmentside)</li> <li>qmean_g (bndparam, bndsegmentside)</li> </ul>"},{"location":"BGFlood/class_member_variables/#r","title":"r","text":"<ul> <li>refine (AdaptP)</li> <li>RightBot (BlockP)</li> <li>RightTop (BlockP)</li> <li>Riverinfo (BndblockP)</li> <li>right (BndblockP, Forcing, bndsegment)</li> <li>river (BndblockP)</li> <li>Rain (Forcing)</li> <li>rivers (Forcing)</li> <li>rainstep (Loop)</li> <li>rainuni (Loop)</li> <li>rainuniform (Loop)</li> <li>Radius (Param)</li> <li>rainbnd (Param)</li> <li>rainforcing (Param)</li> <li>reftime (Param)</li> <li>resetmax (Param)</li> <li>rho (Param)</li> <li>rightbnd (Param)</li> <li>Riverflowfile (River)</li> <li>resDesc (TexSetP)</li> </ul>"},{"location":"BGFlood/class_member_variables/#s","title":"s","text":"<ul> <li>Su (FluxP)</li> <li>Sv (FluxP)</li> <li>streams (Loop)</li> <li>savebyblk (Param)</li> <li>scalefactor (Param)</li> <li>setupcputime (Param)</li> <li>smallnc (Param)</li> <li>spherical (Param)</li> <li>startcputime (Param)</li> <li>side (bndparam, maskinfo)</li> <li>startime (deformmap)</li> </ul>"},{"location":"BGFlood/class_member_variables/#t","title":"t","text":"<ul> <li>TopLeft (BlockP)</li> <li>TopRight (BlockP)</li> <li>Tsout (BndblockP)</li> <li>top (BndblockP, Forcing, bndsegment)</li> <li>time (Flowin, Model, Pointout, SLTS, Windin)</li> <li>targetadapt (Forcing)</li> <li>TSAllout (Loop)</li> <li>totaltime (Loop, Param, TimeP)</li> <li>TSstore (Model)</li> <li>TSnodesout (Param)</li> <li>Toutput (Param, outzoneP)</li> <li>test (Param)</li> <li>theta (Param)</li> <li>topbnd (Param)</li> <li>tmax (River, forcingmap)</li> <li>to (River, forcingmap)</li> <li>tstep (T_output)</li> <li>tex (TexSetP)</li> <li>texDesc (TexSetP)</li> <li>type (bndparam, bndsegment, maskinfo)</li> </ul>"},{"location":"BGFlood/class_member_variables/#u","title":"u","text":"<ul> <li>u (EvolvingMLP, EvolvingP, Pointout)</li> <li>U (EvolvingP_M)</li> <li>UWind (Forcing)</li> <li>uwinduni (Loop)</li> <li>uuvel (SLTS)</li> <li>uniform (TexSetP, bndsegment, forcingmap)</li> <li>uwind (Windin)</li> <li>Uvel (bndTexP)</li> <li>unidata (forcingmap)</li> </ul>"},{"location":"BGFlood/class_member_variables/#v","title":"v","text":"<ul> <li>val (DynForcingP, StaticForcingP, T_output, deformmap)</li> <li>v (EvolvingMLP, EvolvingP, Pointout)</li> <li>VWind (Forcing)</li> <li>vwinduni (Loop)</li> <li>VelThreshold (Param)</li> <li>vertices (Polygon)</li> <li>vvvel (SLTS)</li> <li>vwind (Windin)</li> <li>Vvel (bndTexP)</li> <li>varname (inputmap)</li> </ul>"},{"location":"BGFlood/class_member_variables/#w","title":"w","text":"<ul> <li>windstep (Loop)</li> <li>winduniform (Loop)</li> <li>wettime (Model)</li> <li>wet_threshold (Param)</li> <li>wetdryfix (Param)</li> <li>windforcing (Param)</li> <li>wlevs (SLTS)</li> <li>wdirection (Windin)</li> <li>wspeed (Windin)</li> <li>WLS (bndTexP)</li> <li>WLmap (bndsegment)</li> </ul>"},{"location":"BGFlood/class_member_variables/#x","title":"x","text":"<ul> <li>xo (BlockP, Param, TexSetP, inputmap, outzoneB)</li> <li>xmax (Param, Polygon, inputmap, outP, outzoneB)</li> <li>xmin (Polygon, outP)</li> <li>xend (River, RiverInfo, outzoneP)</li> <li>xstart (River, RiverInfo, outzoneP)</li> <li>Xbidir (RiverInfo)</li> <li>Xridib (RiverInfo)</li> <li>x (TSoutnode, Vertex)</li> </ul>"},{"location":"BGFlood/class_member_variables/#y","title":"y","text":"<ul> <li>yo (BlockP, Param, TexSetP, inputmap, outzoneB)</li> <li>ymax (Param, Polygon, inputmap, outP, outzoneB)</li> <li>ymin (Polygon, outP)</li> <li>yend (River, RiverInfo, outzoneP)</li> <li>ystart (River, RiverInfo, outzoneP)</li> <li>y (TSoutnode, Vertex)</li> </ul>"},{"location":"BGFlood/class_member_variables/#z","title":"z","text":"<ul> <li>zs (EvolvingP, Pointout)</li> <li>zb (Model)</li> <li>zsinit (Param)</li> <li>zsoffset (Param)</li> <li>z (outP)</li> <li>z_s (outP)</li> </ul>"},{"location":"BGFlood/class_member_typedefs/","title":"Member Typedefs","text":""},{"location":"BGFlood/class_member_typedefs/#class-member-typedefs","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"BGFlood/class_member_enums/","title":"Member Enumerations","text":""},{"location":"BGFlood/class_member_enums/#class-member-enums","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"BGFlood/namespace_members/","title":"Members","text":""},{"location":"BGFlood/namespace_members/#namespace-members","title":"Namespace Members","text":""},{"location":"BGFlood/namespace_members/#m","title":"m","text":"<ul> <li>max (utils)</li> <li>max&lt; double &gt; (utils)</li> <li>max&lt; float &gt; (utils)</li> <li>max&lt; int &gt; (utils)</li> <li>min (utils)</li> <li>min&lt; double &gt; (utils)</li> <li>min&lt; float &gt; (utils)</li> <li>min&lt; int &gt; (utils)</li> </ul>"},{"location":"BGFlood/namespace_members/#n","title":"n","text":"<ul> <li>nearest (utils)</li> <li>nearest&lt; double &gt; (utils)</li> <li>nearest&lt; float &gt; (utils)</li> <li>nearest&lt; int &gt; (utils)</li> </ul>"},{"location":"BGFlood/namespace_members/#s","title":"s","text":"<ul> <li>sq (utils)</li> <li>sq&lt; double &gt; (utils)</li> <li>sq&lt; float &gt; (utils)</li> <li>sq&lt; int &gt; (utils)</li> </ul>"},{"location":"BGFlood/namespace_member_functions/","title":"Member Functions","text":""},{"location":"BGFlood/namespace_member_functions/#namespace-member-functions","title":"Namespace Member Functions","text":""},{"location":"BGFlood/namespace_member_functions/#m","title":"m","text":"<ul> <li>max (utils)</li> <li>max&lt; double &gt; (utils)</li> <li>max&lt; float &gt; (utils)</li> <li>max&lt; int &gt; (utils)</li> <li>min (utils)</li> <li>min&lt; double &gt; (utils)</li> <li>min&lt; float &gt; (utils)</li> <li>min&lt; int &gt; (utils)</li> </ul>"},{"location":"BGFlood/namespace_member_functions/#n","title":"n","text":"<ul> <li>nearest (utils)</li> <li>nearest&lt; double &gt; (utils)</li> <li>nearest&lt; float &gt; (utils)</li> <li>nearest&lt; int &gt; (utils)</li> </ul>"},{"location":"BGFlood/namespace_member_functions/#s","title":"s","text":"<ul> <li>sq (utils)</li> <li>sq&lt; double &gt; (utils)</li> <li>sq&lt; float &gt; (utils)</li> <li>sq&lt; int &gt; (utils)</li> </ul>"},{"location":"BGFlood/namespace_member_variables/","title":"Member Variables","text":""},{"location":"BGFlood/namespace_member_variables/#namespace-member-variables","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"BGFlood/namespace_member_typedefs/","title":"Member Typedefs","text":""},{"location":"BGFlood/namespace_member_typedefs/#namespace-member-typedefs","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"BGFlood/namespace_member_enums/","title":"Member Enumerations","text":""},{"location":"BGFlood/namespace_member_enums/#namespace-member-enums","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"BGFlood/functions/","title":"Functions","text":""},{"location":"BGFlood/functions/#functions","title":"Functions","text":""},{"location":"BGFlood/functions/#a","title":"a","text":"<ul> <li>AdaptCriteria (AdaptCriteria.cu, AdaptCriteria.h)</li> <li>AdaptCriteria&lt; double &gt; (AdaptCriteria.cu)</li> <li>AdaptCriteria&lt; float &gt; (AdaptCriteria.cu)</li> <li>Adapt (Adaptation.cu, Adaptation.h)</li> <li>Adaptation (Adaptation.cu, Adaptation.h)</li> <li>Adaptation&lt; double &gt; (Adaptation.cu)</li> <li>Adaptation&lt; float &gt; (Adaptation.cu)</li> <li>Adaptationcleanup (Adaptation.cu, Adaptation.h)</li> <li>Adaptationcleanup&lt; double &gt; (Adaptation.cu)</li> <li>Adaptationcleanup&lt; float &gt; (Adaptation.cu)</li> <li>AddBlocks (Adaptation.cu, Adaptation.h)</li> <li>AddBlocks&lt; double &gt; (Adaptation.cu)</li> <li>AddBlocks&lt; float &gt; (Adaptation.cu)</li> <li>AdvkernelCPU (Advection.cu, Advection.h)</li> <li>AdvkernelCPU&lt; double &gt; (Advection.cu)</li> <li>AdvkernelCPU&lt; float &gt; (Advection.cu)</li> <li>AdvkernelGPU (Advection.cu, Advection.h)</li> <li>AdvkernelGPU&lt; double &gt; (Advection.cu)</li> <li>AdvkernelGPU&lt; float &gt; (Advection.cu)</li> <li>ABS1D (Boundary.cu, Boundary.h)</li> <li>ABS1DQ (Boundary.cu, Boundary.h)</li> <li>AddZSoffset (InitEvolv.cu, InitEvolv.h)</li> <li>AddSlopeSourceXCPU (Kurganov.cu, Kurganov.h)</li> <li>AddSlopeSourceXCPU&lt; double &gt; (Kurganov.cu)</li> <li>AddSlopeSourceXCPU&lt; float &gt; (Kurganov.cu)</li> <li>AddSlopeSourceXGPU (Kurganov.cu, Kurganov.h)</li> <li>AddSlopeSourceXGPU&lt; double &gt; (Kurganov.cu)</li> <li>AddSlopeSourceXGPU&lt; float &gt; (Kurganov.cu)</li> <li>AddSlopeSourceYCPU (Kurganov.cu, Kurganov.h)</li> <li>AddSlopeSourceYCPU&lt; double &gt; (Kurganov.cu)</li> <li>AddSlopeSourceYCPU&lt; float &gt; (Kurganov.cu)</li> <li>AddSlopeSourceYGPU (Kurganov.cu, Kurganov.h)</li> <li>AddSlopeSourceYGPU&lt; double &gt; (Kurganov.cu)</li> <li>AddSlopeSourceYGPU&lt; float &gt; (Kurganov.cu)</li> <li>addUandhU_CPU (Meanmax.cu)</li> <li>addUandhU_GPU (Meanmax.cu, Meanmax.h)</li> <li>addavg_varCPU (Meanmax.cu)</li> <li>addavg_varGPU (Meanmax.cu, Meanmax.h)</li> <li>addwettime_CPU (Meanmax.cu)</li> <li>addwettime_GPU (Meanmax.cu, Meanmax.h)</li> <li>AllocateCPU (MemManagement.cu, MemManagement.h)</li> <li>AllocateCPU&lt; double &gt; (MemManagement.cu)</li> <li>AllocateCPU&lt; float &gt; (MemManagement.cu)</li> <li>AllocateCPU&lt; int &gt; (MemManagement.cu)</li> <li>AllocateGPU (MemManagement.cu, MemManagement.h)</li> <li>AllocateGPU&lt; double &gt; (MemManagement.cu)</li> <li>AllocateGPU&lt; float &gt; (MemManagement.cu)</li> <li>AllocateGPU&lt; int &gt; (MemManagement.cu)</li> <li>AllocateMappedMemCPU (MemManagement.cu, MemManagement.h)</li> <li>AllocateMappedMemCPU&lt; double &gt; (MemManagement.cu)</li> <li>AllocateMappedMemCPU&lt; float &gt; (MemManagement.cu)</li> <li>AllocateMappedMemCPU&lt; int &gt; (MemManagement.cu)</li> <li>AllocateMappedMemGPU (MemManagement.cu, MemManagement.h)</li> <li>AllocateMappedMemGPU&lt; double &gt; (MemManagement.cu)</li> <li>AllocateMappedMemGPU&lt; float &gt; (MemManagement.cu)</li> <li>AllocateMappedMemGPU&lt; int &gt; (MemManagement.cu)</li> <li>AdvecEv (Multilayer.cu, Multilayer.h)</li> <li>AdvecEv&lt; double &gt; (Multilayer.cu)</li> <li>AdvecEv&lt; float &gt; (Multilayer.cu)</li> <li>AdvecFluxML (Multilayer.cu, Multilayer.h)</li> <li>AdvecFluxML&lt; double &gt; (Multilayer.cu)</li> <li>AdvecFluxML&lt; float &gt; (Multilayer.cu)</li> <li>AllocateBndTEX (Setup_GPU.cu, Setup_GPU.h)</li> <li>AllocateTEX (Setup_GPU.cu, Setup_GPU.h)</li> <li>alloc_init2Darray (Testing.cu)</li> <li>AddDeformCPU (Updateforcing.cu)</li> <li>AddDeformGPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddPatmforcingCPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddPatmforcingCPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddPatmforcingCPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddPatmforcingGPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddPatmforcingGPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddPatmforcingGPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddRiverForcing (Updateforcing.cu, Updateforcing.h)</li> <li>AddRiverForcing&lt; double &gt; (Updateforcing.cu)</li> <li>AddRiverForcing&lt; float &gt; (Updateforcing.cu)</li> <li>AddinfiltrationImplicitCPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddinfiltrationImplicitCPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddinfiltrationImplicitCPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddinfiltrationImplicitGPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddinfiltrationImplicitGPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddinfiltrationImplicitGPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddrainforcingCPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddrainforcingCPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddrainforcingCPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddrainforcingGPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddrainforcingGPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddrainforcingGPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddrainforcingImplicitCPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddrainforcingImplicitCPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddrainforcingImplicitCPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddrainforcingImplicitGPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddrainforcingImplicitGPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddrainforcingImplicitGPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddwindforcingCPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddwindforcingCPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddwindforcingCPU&lt; float &gt; (Updateforcing.cu)</li> <li>AddwindforcingGPU (Updateforcing.cu, Updateforcing.h)</li> <li>AddwindforcingGPU&lt; double &gt; (Updateforcing.cu)</li> <li>AddwindforcingGPU&lt; float &gt; (Updateforcing.cu)</li> </ul>"},{"location":"BGFlood/functions/#b","title":"b","text":"<ul> <li>bndCPU (Boundary.cu, Boundary.h)</li> <li>bndCPU&lt; double &gt; (Boundary.cu)</li> <li>bndCPU&lt; float &gt; (Boundary.cu)</li> <li>bndFluxGPUSide (Boundary.cu, Boundary.h)</li> <li>bndFluxGPUSideCPU (Boundary.cu)</li> <li>bndGPU (Boundary.cu, Boundary.h)</li> <li>bndGPU&lt; double &gt; (Boundary.cu)</li> <li>bndGPU&lt; float &gt; (Boundary.cu)</li> <li>bottomfrictionCPU (Friction.cu, Friction.h)</li> <li>bottomfrictionCPU&lt; double &gt; (Friction.cu)</li> <li>bottomfrictionCPU&lt; float &gt; (Friction.cu)</li> <li>bottomfrictionGPU (Friction.cu, Friction.h)</li> <li>bottomfrictionGPU&lt; double &gt; (Friction.cu)</li> <li>bottomfrictionGPU&lt; float &gt; (Friction.cu)</li> <li>blockmean (GridManip.cu)</li> <li>bndmaskGPU (Halo.cu, Halo.h)</li> <li>bndmaskGPU&lt; double &gt; (Halo.cu)</li> <li>bndmaskGPU&lt; float &gt; (Halo.cu)</li> <li>blockinpoly (Poly.cu, Poly.h)</li> <li>blockinpoly&lt; double &gt; (Poly.cu)</li> <li>blockinpoly&lt; float &gt; (Poly.cu)</li> <li>BarycentricInterpolation (Util_CPU.cu, Util_CPU.h)</li> <li>BilinearInterpolation (Util_CPU.cu, Util_CPU.h)</li> <li>BilinearInterpolation&lt; double &gt; (Util_CPU.cu)</li> <li>BilinearInterpolation&lt; float &gt; (Util_CPU.cu)</li> </ul>"},{"location":"BGFlood/functions/#c","title":"c","text":"<ul> <li>CalcAvailblk (Adaptation.cu, Adaptation.h)</li> <li>CalcAvailblk&lt; double &gt; (Adaptation.cu)</li> <li>CalcAvailblk&lt; float &gt; (Adaptation.cu)</li> <li>checkBUQsanity (Adaptation.cu, Adaptation.h)</li> <li>checkBUQsanity&lt; double &gt; (Adaptation.cu)</li> <li>checkBUQsanity&lt; float &gt; (Adaptation.cu)</li> <li>checklevel (Adaptation.cu, Adaptation.h)</li> <li>checkneighbourdistance (Adaptation.cu, Adaptation.h)</li> <li>checkneighbourrefine (Adaptation.cu, Adaptation.h)</li> <li>coarsen (Adaptation.cu, Adaptation.h)</li> <li>coarsen&lt; double &gt; (Adaptation.cu)</li> <li>coarsen&lt; float &gt; (Adaptation.cu)</li> <li>CalctimestepCPU (Advection.cu, Advection.h)</li> <li>CalctimestepCPU&lt; double &gt; (Advection.cu)</li> <li>CalctimestepCPU&lt; float &gt; (Advection.cu)</li> <li>CalctimestepGPU (Advection.cu, Advection.h)</li> <li>CalctimestepGPU&lt; double &gt; (Advection.cu)</li> <li>CalctimestepGPU&lt; float &gt; (Advection.cu)</li> <li>cleanupCPU (Advection.cu, Advection.h)</li> <li>cleanupCPU&lt; double &gt; (Advection.cu)</li> <li>cleanupCPU&lt; float &gt; (Advection.cu)</li> <li>cleanupGPU (Advection.cu, Advection.h)</li> <li>cleanupGPU&lt; double &gt; (Advection.cu)</li> <li>cleanupGPU&lt; float &gt; (Advection.cu)</li> <li>conserveElevation (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevation&lt; double &gt; (ConserveElevation.cu)</li> <li>conserveElevation&lt; float &gt; (ConserveElevation.cu)</li> <li>conserveElevationBot (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationGHBot (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationGHLeft (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationGHRight (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationGHTop (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationGPU (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationGPU&lt; double &gt; (ConserveElevation.cu)</li> <li>conserveElevationGPU&lt; float &gt; (ConserveElevation.cu)</li> <li>conserveElevationGradHalo (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationGradHalo&lt; double &gt; (ConserveElevation.cu)</li> <li>conserveElevationGradHalo&lt; float &gt; (ConserveElevation.cu)</li> <li>conserveElevationGradHaloA (ConserveElevation.cu)</li> <li>conserveElevationGradHaloB (ConserveElevation.cu)</li> <li>conserveElevationGradHaloGPU (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationGradHaloGPU&lt; double &gt; (ConserveElevation.cu)</li> <li>conserveElevationGradHaloGPU&lt; float &gt; (ConserveElevation.cu)</li> <li>conserveElevationLeft (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationRight (ConserveElevation.cu, ConserveElevation.h)</li> <li>conserveElevationTop (ConserveElevation.cu, ConserveElevation.h)</li> <li>Copy2CartCPU (GridManip.cu, GridManip.h)</li> <li>Copy2CartCPU&lt; bool &gt; (GridManip.cu)</li> <li>Copy2CartCPU&lt; double &gt; (GridManip.cu)</li> <li>Copy2CartCPU&lt; float &gt; (GridManip.cu)</li> <li>Copy2CartCPU&lt; int &gt; (GridManip.cu)</li> <li>CopyArrayBUQ (GridManip.cu, GridManip.h)</li> <li>CopyArrayBUQ&lt; bool, double &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; bool, float &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; double &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; double, double &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; double, float &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; float &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; float, double &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; float, float &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; int, double &gt; (GridManip.cu)</li> <li>CopyArrayBUQ&lt; int, float &gt; (GridManip.cu)</li> <li>coldstart (InitEvolv.cu, InitEvolv.h)</li> <li>Calcbndblks (InitialConditions.cu, InitialConditions.h)</li> <li>calcactiveCellCPU (InitialConditions.cu, InitialConditions.h)</li> <li>calcactiveCellGPU (InitialConditions.cu)</li> <li>CalcInitdtCPU (Mainloop.cu)</li> <li>CalcInitdtGPU (Mainloop.cu)</li> <li>CrashDetection (Mainloop.cu)</li> <li>Calcmeanmax (Meanmax.cu, Meanmax.h)</li> <li>Calcmeanmax&lt; double &gt; (Meanmax.cu)</li> <li>Calcmeanmax&lt; float &gt; (Meanmax.cu)</li> <li>CalcInitnblk (Mesh.cu, Mesh.h)</li> <li>CalcMaskblk (Mesh.cu, Mesh.h)</li> <li>CalcMaskblk&lt; double &gt; (Mesh.cu)</li> <li>CalcMaskblk&lt; float &gt; (Mesh.cu)</li> <li>CalcfaceValX (Multilayer.cu, Multilayer.h)</li> <li>CalcfaceValX&lt; double &gt; (Multilayer.cu)</li> <li>CalcfaceValX&lt; float &gt; (Multilayer.cu)</li> <li>CalcfaceValY (Multilayer.cu, Multilayer.h)</li> <li>CalcfaceValY&lt; double &gt; (Multilayer.cu)</li> <li>CalcfaceValY&lt; float &gt; (Multilayer.cu)</li> <li>CheckadvecMLX (Multilayer.cu, Multilayer.h)</li> <li>CheckadvecMLX&lt; double &gt; (Multilayer.cu)</li> <li>CheckadvecMLX&lt; float &gt; (Multilayer.cu)</li> <li>CheckadvecMLY (Multilayer.cu, Multilayer.h)</li> <li>CheckadvecMLY&lt; double &gt; (Multilayer.cu)</li> <li>CheckadvecMLY&lt; float &gt; (Multilayer.cu)</li> <li>CleanupML (Multilayer.cu, Multilayer.h)</li> <li>CleanupML&lt; double &gt; (Multilayer.cu)</li> <li>CleanupML&lt; float &gt; (Multilayer.cu)</li> <li>CounterCWPoly (Poly.cu, Poly.h)</li> <li>cn_PnPoly (Poly.cu)</li> <li>clampedges (ReadForcing.cu, ReadForcing.h)</li> <li>case_insensitive_compare (ReadInput.cu, ReadInput.h)</li> <li>checkparamsanity (ReadInput.cu, ReadInput.h)</li> <li>checkncvarname (Read_netcdf.cu, Read_netcdf.h)</li> <li>CUDA_CHECK (Setup_GPU.cu, Setup_GPU.h)</li> <li>CopyGPUtoCPU (Setup_GPU.cu, Setup_GPU.h)</li> <li>CopyGPUtoCPU&lt; bool &gt; (Setup_GPU.cu)</li> <li>CopyGPUtoCPU&lt; double &gt; (Setup_GPU.cu)</li> <li>CopyGPUtoCPU&lt; float &gt; (Setup_GPU.cu)</li> <li>CopyGPUtoCPU&lt; int &gt; (Setup_GPU.cu)</li> <li>CopytoGPU (Setup_GPU.cu, Setup_GPU.h)</li> <li>CopytoGPU&lt; bool &gt; (Setup_GPU.cu)</li> <li>CopytoGPU&lt; double &gt; (Setup_GPU.cu)</li> <li>CopytoGPU&lt; float &gt; (Setup_GPU.cu)</li> <li>CopytoGPU&lt; int &gt; (Setup_GPU.cu)</li> <li>calcCM (Spherical.cu, Spherical.h)</li> <li>calcFM (Spherical.cu, Spherical.h)</li> <li>CPUGPUtest (Testing.cu)</li> <li>CompareCPUvsGPU (Testing.cu, Testing.h)</li> <li>CompareCPUvsGPU&lt; double &gt; (Testing.cu)</li> <li>CompareCPUvsGPU&lt; float &gt; (Testing.cu)</li> <li>copyBlockinfo2var (Testing.cu, Testing.h)</li> <li>copyBlockinfo2var&lt; double &gt; (Testing.cu)</li> <li>copyBlockinfo2var&lt; float &gt; (Testing.cu)</li> <li>copyID2var (Testing.cu, Testing.h)</li> <li>copyID2var&lt; double &gt; (Testing.cu)</li> <li>copyID2var&lt; float &gt; (Testing.cu)</li> <li>calcres (Util_CPU.cu, Util_CPU.h)</li> <li>calcres&lt; double &gt; (Util_CPU.cu)</li> <li>calcres&lt; float &gt; (Util_CPU.cu)</li> <li>Calcactiveblockzone (Write_netcdf.cu)</li> <li>Calcnxny (Write_netcdf.cu)</li> <li>Calcnxnyzone (Write_netcdf.cu)</li> <li>create2dnc (Write_netcdf.cu, Write_netcdf.h)</li> <li>create3dnc (Write_netcdf.cu, Write_netcdf.h)</li> <li>creatncfileBUQ (Write_netcdf.cu, Write_netcdf.h)</li> <li>creatncfileBUQ&lt; double &gt; (Write_netcdf.cu)</li> <li>creatncfileBUQ&lt; float &gt; (Write_netcdf.cu)</li> <li>create_logfile (Write_txtlog.cpp, Write_txtlog.h)</li> </ul>"},{"location":"BGFlood/functions/#d","title":"d","text":"<ul> <li>densify (Advection.cu, Advection.h)</li> <li>Dirichlet1D (Boundary.cu, Boundary.h)</li> <li>Dirichlet1Q (Boundary.cu, Boundary.h)</li> <li>DebugLoop (Mainloop.cu, Mainloop.h)</li> <li>DebugLoop&lt; double &gt; (Mainloop.cu)</li> <li>DebugLoop&lt; float &gt; (Mainloop.cu)</li> <li>divavg_varCPU (Meanmax.cu)</li> <li>divavg_varGPU (Meanmax.cu, Meanmax.h)</li> <li>dotprod (Poly.cu)</li> <li>DelimLine (ReadForcing.cu, ReadForcing.h)</li> <li>denan (ReadForcing.cu, ReadForcing.h)</li> <li>denan&lt; double &gt; (ReadForcing.cu)</li> <li>denan&lt; float &gt; (ReadForcing.cu)</li> <li>diffArray (Testing.cu)</li> <li>diffSource (Testing.cu)</li> <li>diffdh (Testing.cu)</li> <li>deformstep (Updateforcing.cu, Updateforcing.h)</li> <li>deformstep&lt; double &gt; (Updateforcing.cu)</li> <li>deformstep&lt; float &gt; (Updateforcing.cu)</li> <li>defncvarBUQ (Write_netcdf.cu, Write_netcdf.h)</li> <li>defncvarBUQ&lt; double &gt; (Write_netcdf.cu)</li> <li>defncvarBUQ&lt; float &gt; (Write_netcdf.cu)</li> <li>defncvarBUQlev (Write_netcdf.cu)</li> <li>date_string_to_s (utctime.cu, utctime.h)</li> <li>date_string_to_time (utctime.cu, utctime.h)</li> <li>days_from_epoch (utctime.cu)</li> </ul>"},{"location":"BGFlood/functions/#f","title":"f","text":"<ul> <li>Flowbnd (Boundary.cu, Boundary.h)</li> <li>Flowbnd&lt; double &gt; (Boundary.cu)</li> <li>Flowbnd&lt; float &gt; (Boundary.cu)</li> <li>FlowbndFlux (Boundary.cu, Boundary.h)</li> <li>FlowbndFlux&lt; double &gt; (Boundary.cu)</li> <li>FlowbndFlux&lt; float &gt; (Boundary.cu)</li> <li>FlowbndFluxML (Boundary.cu, Boundary.h)</li> <li>FlowbndFluxML&lt; double &gt; (Boundary.cu)</li> <li>FlowbndFluxML&lt; float &gt; (Boundary.cu)</li> <li>FlowbndFluxold (Boundary.cu)</li> <li>FlowbndFluxold&lt; double &gt; (Boundary.cu)</li> <li>FlowbndFluxold&lt; float &gt; (Boundary.cu)</li> <li>findmaskside (Boundary.cu, Boundary.h)</li> <li>FlowCPU (FlowCPU.cu, FlowCPU.h)</li> <li>FlowCPU&lt; double &gt; (FlowCPU.cu)</li> <li>FlowCPU&lt; float &gt; (FlowCPU.cu)</li> <li>FlowGPU (FlowGPU.cu, FlowGPU.h)</li> <li>FlowGPU&lt; double &gt; (FlowGPU.cu)</li> <li>FlowGPU&lt; float &gt; (FlowGPU.cu)</li> <li>FlowMLGPU (FlowMLGPU.cu, FlowMLGPU.h)</li> <li>FlowMLGPU&lt; double &gt; (FlowMLGPU.cu)</li> <li>FlowMLGPU&lt; float &gt; (FlowMLGPU.cu)</li> <li>fillBot (Halo.cu, Halo.h)</li> <li>fillBot&lt; double &gt; (Halo.cu)</li> <li>fillBot&lt; float &gt; (Halo.cu)</li> <li>fillBotFlux (Halo.cu)</li> <li>fillBotnew (Halo.cu, Halo.h)</li> <li>fillBotnew&lt; double &gt; (Halo.cu)</li> <li>fillBotnew&lt; float &gt; (Halo.cu)</li> <li>fillCorners (Halo.cu, Halo.h)</li> <li>fillCorners&lt; double &gt; (Halo.cu)</li> <li>fillCorners&lt; float &gt; (Halo.cu)</li> <li>fillCornersGPU (Halo.cu, Halo.h)</li> <li>fillCornersGPU&lt; double &gt; (Halo.cu)</li> <li>fillCornersGPU&lt; float &gt; (Halo.cu)</li> <li>fillHalo (Halo.cu, Halo.h)</li> <li>fillHalo&lt; double &gt; (Halo.cu)</li> <li>fillHalo&lt; float &gt; (Halo.cu)</li> <li>fillHaloBTFluxC (Halo.cu)</li> <li>fillHaloBTFluxC&lt; double &gt; (Halo.cu)</li> <li>fillHaloBTFluxC&lt; float &gt; (Halo.cu)</li> <li>fillHaloBotTopGPU (Halo.cu)</li> <li>fillHaloBotTopGPU&lt; double &gt; (Halo.cu)</li> <li>fillHaloBotTopGPU&lt; float &gt; (Halo.cu)</li> <li>fillHaloBotTopGPUnew (Halo.cu)</li> <li>fillHaloBotTopGPUnew&lt; double &gt; (Halo.cu)</li> <li>fillHaloBotTopGPUnew&lt; float &gt; (Halo.cu)</li> <li>fillHaloC (Halo.cu, Halo.h)</li> <li>fillHaloC&lt; double &gt; (Halo.cu)</li> <li>fillHaloC&lt; float &gt; (Halo.cu)</li> <li>fillHaloD (Halo.cu)</li> <li>fillHaloD&lt; double &gt; (Halo.cu)</li> <li>fillHaloD&lt; float &gt; (Halo.cu)</li> <li>fillHaloF (Halo.cu, Halo.h)</li> <li>fillHaloF&lt; double &gt; (Halo.cu)</li> <li>fillHaloF&lt; float &gt; (Halo.cu)</li> <li>fillHaloGPU (Halo.cu, Halo.h)</li> <li>fillHaloGPU&lt; double &gt; (Halo.cu)</li> <li>fillHaloGPU&lt; float &gt; (Halo.cu)</li> <li>fillHaloGPUnew (Halo.cu, Halo.h)</li> <li>fillHaloGPUnew&lt; double &gt; (Halo.cu)</li> <li>fillHaloGPUnew&lt; float &gt; (Halo.cu)</li> <li>fillHaloLRFluxC (Halo.cu)</li> <li>fillHaloLRFluxC&lt; double &gt; (Halo.cu)</li> <li>fillHaloLRFluxC&lt; float &gt; (Halo.cu)</li> <li>fillHaloLeftRightGPU (Halo.cu)</li> <li>fillHaloLeftRightGPU&lt; double &gt; (Halo.cu)</li> <li>fillHaloLeftRightGPU&lt; float &gt; (Halo.cu)</li> <li>fillHaloLeftRightGPUnew (Halo.cu)</li> <li>fillHaloLeftRightGPUnew&lt; double &gt; (Halo.cu)</li> <li>fillHaloLeftRightGPUnew&lt; float &gt; (Halo.cu)</li> <li>fillHaloTopRightC (Halo.cu, Halo.h)</li> <li>fillHaloTopRightC&lt; double &gt; (Halo.cu)</li> <li>fillHaloTopRightC&lt; float &gt; (Halo.cu)</li> <li>fillHaloTopRightGPU (Halo.cu, Halo.h)</li> <li>fillHaloTopRightGPU&lt; double &gt; (Halo.cu)</li> <li>fillHaloTopRightGPU&lt; float &gt; (Halo.cu)</li> <li>fillLeft (Halo.cu, Halo.h)</li> <li>fillLeft&lt; double &gt; (Halo.cu)</li> <li>fillLeft&lt; float &gt; (Halo.cu)</li> <li>fillLeftFlux (Halo.cu)</li> <li>fillLeftnew (Halo.cu, Halo.h)</li> <li>fillLeftnew&lt; double &gt; (Halo.cu)</li> <li>fillLeftnew&lt; float &gt; (Halo.cu)</li> <li>fillRight (Halo.cu, Halo.h)</li> <li>fillRight&lt; double &gt; (Halo.cu)</li> <li>fillRight&lt; float &gt; (Halo.cu)</li> <li>fillRightFlux (Halo.cu, Halo.h)</li> <li>fillRightFlux&lt; double &gt; (Halo.cu)</li> <li>fillRightFlux&lt; float &gt; (Halo.cu)</li> <li>fillRightnew (Halo.cu, Halo.h)</li> <li>fillRightnew&lt; double &gt; (Halo.cu)</li> <li>fillRightnew&lt; float &gt; (Halo.cu)</li> <li>fillTop (Halo.cu, Halo.h)</li> <li>fillTop&lt; double &gt; (Halo.cu)</li> <li>fillTop&lt; float &gt; (Halo.cu)</li> <li>fillTopFlux (Halo.cu, Halo.h)</li> <li>fillTopFlux&lt; double &gt; (Halo.cu)</li> <li>fillTopFlux&lt; float &gt; (Halo.cu)</li> <li>fillTopnew (Halo.cu, Halo.h)</li> <li>fillTopnew&lt; double &gt; (Halo.cu)</li> <li>fillTopnew&lt; float &gt; (Halo.cu)</li> <li>FindTSoutNodes (InitialConditions.cu, InitialConditions.h)</li> <li>FindTSoutNodes&lt; double &gt; (InitialConditions.cu)</li> <li>FindTSoutNodes&lt; float &gt; (InitialConditions.cu)</li> <li>Findbndblks (InitialConditions.cu, InitialConditions.h)</li> <li>Findoutzoneblks (InitialConditions.cu)</li> <li>Findoutzoneblks&lt; double &gt; (InitialConditions.cu)</li> <li>Findoutzoneblks&lt; float &gt; (InitialConditions.cu)</li> <li>FillCPU (MemManagement.cu, MemManagement.h)</li> <li>FillCPU&lt; double &gt; (MemManagement.cu)</li> <li>FillCPU&lt; float &gt; (MemManagement.cu)</li> <li>FillCPU&lt; int &gt; (MemManagement.cu)</li> <li>FindMaskblk (Mesh.cu, Mesh.h)</li> <li>FindMaskblk&lt; double &gt; (Mesh.cu)</li> <li>FindMaskblk&lt; float &gt; (Mesh.cu)</li> <li>findparameter (ReadInput.cu, ReadInput.h)</li> <li>fillgauss (Testing.cu)</li> <li>fillgauss&lt; double &gt; (Testing.cu)</li> <li>fillgauss&lt; float &gt; (Testing.cu)</li> <li>fillrandom (Testing.cu)</li> <li>fillrandom&lt; double &gt; (Testing.cu)</li> <li>fillrandom&lt; float &gt; (Testing.cu)</li> <li>Forcingthisstep (Updateforcing.cu, Updateforcing.h)</li> <li>ftoi (Util_CPU.cu, Util_CPU.h)</li> <li>ftoi&lt; double &gt; (Util_CPU.cu)</li> <li>ftoi&lt; float &gt; (Util_CPU.cu)</li> </ul>"},{"location":"BGFlood/functions/#g","title":"g","text":"<ul> <li>gradient (Gradients.cu, Gradients.h)</li> <li>gradient&lt; double &gt; (Gradients.cu)</li> <li>gradient&lt; float &gt; (Gradients.cu)</li> <li>gradientC (Gradients.cu, Gradients.h)</li> <li>gradientC&lt; double &gt; (Gradients.cu)</li> <li>gradientC&lt; float &gt; (Gradients.cu)</li> <li>gradientCPU (Gradients.cu, Gradients.h)</li> <li>gradientCPU&lt; double &gt; (Gradients.cu)</li> <li>gradientCPU&lt; float &gt; (Gradients.cu)</li> <li>gradientGPU (Gradients.cu, Gradients.h)</li> <li>gradientGPU&lt; double &gt; (Gradients.cu)</li> <li>gradientGPU&lt; float &gt; (Gradients.cu)</li> <li>gradientGPUnew (Gradients.cu, Gradients.h)</li> <li>gradientGPUnew&lt; double &gt; (Gradients.cu)</li> <li>gradientGPUnew&lt; float &gt; (Gradients.cu)</li> <li>gradientHalo (Gradients.cu, Gradients.h)</li> <li>gradientHaloBot (Gradients.cu)</li> <li>gradientHaloBotGPU (Gradients.cu, Gradients.h)</li> <li>gradientHaloBotGPUnew (Gradients.cu, Gradients.h)</li> <li>gradientHaloGPU (Gradients.cu, Gradients.h)</li> <li>gradientHaloGPUnew (Gradients.cu)</li> <li>gradientHaloLeft (Gradients.cu)</li> <li>gradientHaloLeftGPU (Gradients.cu, Gradients.h)</li> <li>gradientHaloLeftGPUnew (Gradients.cu, Gradients.h)</li> <li>gradientHaloRight (Gradients.cu)</li> <li>gradientHaloRightGPU (Gradients.cu, Gradients.h)</li> <li>gradientHaloRightGPUnew (Gradients.cu, Gradients.h)</li> <li>gradientHaloTop (Gradients.cu)</li> <li>gradientHaloTopGPU (Gradients.cu, Gradients.h)</li> <li>gradientHaloTopGPUnew (Gradients.cu, Gradients.h)</li> <li>gradientSM (Gradients.cu, Gradients.h)</li> <li>gradientSM&lt; double &gt; (Gradients.cu)</li> <li>gradientSM&lt; float &gt; (Gradients.cu)</li> <li>gradientSMB (Gradients.cu, Gradients.h)</li> <li>gradientSMB&lt; double &gt; (Gradients.cu)</li> <li>gradientSMB&lt; float &gt; (Gradients.cu)</li> <li>gradientSMC (Gradients.cu, Gradients.h)</li> <li>gradientSMC&lt; double &gt; (Gradients.cu)</li> <li>gradientSMC&lt; float &gt; (Gradients.cu)</li> <li>gradientedgeX (Gradients.cu, Gradients.h)</li> <li>gradientedgeX&lt; double &gt; (Gradients.cu)</li> <li>gradientedgeX&lt; float &gt; (Gradients.cu)</li> <li>gradientedgeY (Gradients.cu, Gradients.h)</li> <li>gradientedgeY&lt; double &gt; (Gradients.cu)</li> <li>gradientedgeY&lt; float &gt; (Gradients.cu)</li> <li>GetTimeOutput (InitialConditions.cu)</li> <li>GaussianHumptest (Testing.cu, Testing.h)</li> <li>GaussianHumptest&lt; double &gt; (Testing.cu)</li> <li>GaussianHumptest&lt; float &gt; (Testing.cu)</li> <li>gmtime_r (utctime.cu)</li> </ul>"},{"location":"BGFlood/functions/#h","title":"h","text":"<ul> <li>halowall (Boundary.cu, Boundary.h)</li> <li>HalfStepCPU (FlowCPU.cu, FlowCPU.h)</li> <li>HalfStepCPU&lt; double &gt; (FlowCPU.cu)</li> <li>HalfStepCPU&lt; float &gt; (FlowCPU.cu)</li> <li>HalfStepGPU (FlowGPU.cu, FlowGPU.h)</li> <li>HalfStepGPU&lt; double &gt; (FlowGPU.cu)</li> <li>HalfStepGPU&lt; float &gt; (FlowGPU.cu)</li> <li>HaloFluxCPUBT (Halo.cu)</li> <li>HaloFluxCPULR (Halo.cu)</li> <li>HaloFluxGPUBT (Halo.cu, Halo.h)</li> <li>HaloFluxGPUBTnew (Halo.cu, Halo.h)</li> <li>HaloFluxGPULR (Halo.cu, Halo.h)</li> <li>HaloFluxGPULRnew (Halo.cu, Halo.h)</li> <li>hllc (Reimann.cu, Reimann.h)</li> <li>haversin (Spherical.cu)</li> <li>handle_ncerror (Write_netcdf.cu, Write_netcdf.h)</li> </ul>"},{"location":"BGFlood/functions/#i","title":"i","text":"<ul> <li>inrangecriteria (AdaptCriteria.cu, AdaptCriteria.h)</li> <li>inrangecriteria&lt; double &gt; (AdaptCriteria.cu)</li> <li>inrangecriteria&lt; float &gt; (AdaptCriteria.cu)</li> <li>InitialAdaptation (Adaptation.cu, Adaptation.h)</li> <li>InitialAdaptation&lt; double &gt; (Adaptation.cu)</li> <li>InitialAdaptation&lt; float &gt; (Adaptation.cu)</li> <li>Inside (Boundary.cu, Boundary.h)</li> <li>isbnd (Boundary.cu, Boundary.h)</li> <li>InitArrayBUQ (GridManip.cu, GridManip.h)</li> <li>InitArrayBUQ&lt; bool, double &gt; (GridManip.cu)</li> <li>InitArrayBUQ&lt; bool, float &gt; (GridManip.cu)</li> <li>InitArrayBUQ&lt; double, double &gt; (GridManip.cu)</li> <li>InitArrayBUQ&lt; double, float &gt; (GridManip.cu)</li> <li>InitArrayBUQ&lt; float, double &gt; (GridManip.cu)</li> <li>InitArrayBUQ&lt; float, float &gt; (GridManip.cu)</li> <li>InitArrayBUQ&lt; int, double &gt; (GridManip.cu)</li> <li>InitArrayBUQ&lt; int, float &gt; (GridManip.cu)</li> <li>InitBlkBUQ (GridManip.cu, GridManip.h)</li> <li>InitBlkBUQ&lt; bool, double &gt; (GridManip.cu)</li> <li>InitBlkBUQ&lt; bool, float &gt; (GridManip.cu)</li> <li>InitBlkBUQ&lt; double, double &gt; (GridManip.cu)</li> <li>InitBlkBUQ&lt; double, float &gt; (GridManip.cu)</li> <li>InitBlkBUQ&lt; float, double &gt; (GridManip.cu)</li> <li>InitBlkBUQ&lt; float, float &gt; (GridManip.cu)</li> <li>InitBlkBUQ&lt; int, double &gt; (GridManip.cu)</li> <li>InitBlkBUQ&lt; int, float &gt; (GridManip.cu)</li> <li>InterpstepCPU (GridManip.cu, GridManip.h, ReadForcing.h)</li> <li>InterpstepCPU&lt; double, double &gt; (GridManip.cu)</li> <li>InterpstepCPU&lt; double, float &gt; (GridManip.cu)</li> <li>InterpstepCPU&lt; float, double &gt; (GridManip.cu)</li> <li>InterpstepCPU&lt; float, float &gt; (GridManip.cu)</li> <li>InterpstepCPU&lt; int, double &gt; (GridManip.cu)</li> <li>InterpstepCPU&lt; int, float &gt; (GridManip.cu)</li> <li>InterpstepGPU (GridManip.cu, GridManip.h)</li> <li>InterpstepGPU&lt; double &gt; (GridManip.cu)</li> <li>InterpstepGPU&lt; float &gt; (GridManip.cu)</li> <li>interp2BUQ (GridManip.cu, GridManip.h, Updateforcing.cu)</li> <li>interp2BUQ&lt; double &gt; (GridManip.cu, Updateforcing.cu)</li> <li>interp2BUQ&lt; double, DynForcingP&lt; float &gt; &gt; (GridManip.cu)</li> <li>interp2BUQ&lt; double, StaticForcingP&lt; float &gt; &gt; (GridManip.cu)</li> <li>interp2BUQ&lt; double, StaticForcingP&lt; int &gt; &gt; (GridManip.cu)</li> <li>interp2BUQ&lt; double, deformmap&lt; float &gt; &gt; (GridManip.cu)</li> <li>interp2BUQ&lt; float &gt; (GridManip.cu, Updateforcing.cu)</li> <li>interp2BUQ&lt; float, DynForcingP&lt; float &gt; &gt; (GridManip.cu)</li> <li>interp2BUQ&lt; float, StaticForcingP&lt; float &gt; &gt; (GridManip.cu)</li> <li>interp2BUQ&lt; float, StaticForcingP&lt; int &gt; &gt; (GridManip.cu)</li> <li>interp2BUQ&lt; float, deformmap&lt; float &gt; &gt; (GridManip.cu)</li> <li>initevolv (InitEvolv.cu, InitEvolv.h)</li> <li>initevolv&lt; double &gt; (InitEvolv.cu)</li> <li>initevolv&lt; float &gt; (InitEvolv.cu)</li> <li>InitRivers (InitialConditions.cu, InitialConditions.h)</li> <li>InitRivers&lt; double &gt; (InitialConditions.cu)</li> <li>InitRivers&lt; float &gt; (InitialConditions.cu)</li> <li>InitTSOutput (InitialConditions.cu, InitialConditions.h)</li> <li>Initbndblks (InitialConditions.cu)</li> <li>InitialConditions (InitialConditions.cu, InitialConditions.h)</li> <li>InitialConditions&lt; double &gt; (InitialConditions.cu)</li> <li>InitialConditions&lt; float &gt; (InitialConditions.cu)</li> <li>Initmaparray (InitialConditions.cu, InitialConditions.h)</li> <li>Initmaparray&lt; double &gt; (InitialConditions.cu)</li> <li>Initmaparray&lt; float &gt; (InitialConditions.cu)</li> <li>Initoutzone (InitialConditions.cu, InitialConditions.h)</li> <li>Initoutzone&lt; double &gt; (InitialConditions.cu)</li> <li>Initoutzone&lt; float &gt; (InitialConditions.cu)</li> <li>InitzbgradientCPU (InitialConditions.cu, InitialConditions.h)</li> <li>InitzbgradientCPU&lt; double &gt; (InitialConditions.cu)</li> <li>InitzbgradientCPU&lt; float &gt; (InitialConditions.cu)</li> <li>InitzbgradientGPU (InitialConditions.cu, InitialConditions.h)</li> <li>InitzbgradientGPU&lt; double &gt; (InitialConditions.cu)</li> <li>InitzbgradientGPU&lt; float &gt; (InitialConditions.cu)</li> <li>initOutputTimes (InitialConditions.cu, InitialConditions.h)</li> <li>initinfiltration (InitialConditions.cu)</li> <li>initoutput (InitialConditions.cu, InitialConditions.h)</li> <li>InitLoop (Mainloop.cu, Mainloop.h)</li> <li>initdt (Mainloop.cu, Mainloop.h)</li> <li>initdt&lt; double &gt; (Mainloop.cu)</li> <li>initdt&lt; float &gt; (Mainloop.cu)</li> <li>Initmeanmax (Meanmax.cu, Meanmax.h)</li> <li>Initmeanmax&lt; double &gt; (Meanmax.cu)</li> <li>Initmeanmax&lt; float &gt; (Meanmax.cu)</li> <li>InitBlockInfo (Mesh.cu, Mesh.h)</li> <li>InitBlockadapt (Mesh.cu, Mesh.h)</li> <li>InitBlockadapt&lt; double &gt; (Mesh.cu)</li> <li>InitBlockadapt&lt; float &gt; (Mesh.cu)</li> <li>InitBlockneighbours (Mesh.cu, Mesh.h)</li> <li>InitBlockneighbours&lt; double &gt; (Mesh.cu)</li> <li>InitBlockneighbours&lt; float &gt; (Mesh.cu)</li> <li>InitBlockxoyo (Mesh.cu, Mesh.h)</li> <li>InitBlockxoyo&lt; double &gt; (Mesh.cu)</li> <li>InitBlockxoyo&lt; float &gt; (Mesh.cu)</li> <li>InitMesh (Mesh.cu, Mesh.h)</li> <li>InitMesh&lt; double &gt; (Mesh.cu)</li> <li>InitMesh&lt; float &gt; (Mesh.cu)</li> <li>isLeft (Poly.cu)</li> <li>InitDynforcing (ReadForcing.cu, ReadForcing.h)</li> <li>InitialiseToutput (ReadInput.cu, ReadInput.h)</li> <li>init3Darray (Testing.cu)</li> <li>InjectManyRiversGPU (Updateforcing.cu)</li> <li>InjectRiverCPU (Updateforcing.cu)</li> <li>InjectRiverCPU&lt; double &gt; (Updateforcing.cu)</li> <li>InjectRiverCPU&lt; float &gt; (Updateforcing.cu)</li> <li>InjectRiverGPU (Updateforcing.cu, Updateforcing.h)</li> <li>InjectRiverGPU&lt; double &gt; (Updateforcing.cu)</li> <li>InjectRiverGPU&lt; float &gt; (Updateforcing.cu)</li> <li>interpDyn2BUQ (Updateforcing.cu, Updateforcing.h)</li> <li>interpDyn2BUQ&lt; double &gt; (Updateforcing.cu)</li> <li>interpDyn2BUQ&lt; float &gt; (Updateforcing.cu)</li> <li>interptime (Util_CPU.cu, Util_CPU.h)</li> <li>InitSave2Netcdf (Write_netcdf.cu, Write_netcdf.h)</li> <li>InitSave2Netcdf&lt; double &gt; (Write_netcdf.cu)</li> <li>InitSave2Netcdf&lt; float &gt; (Write_netcdf.cu)</li> </ul>"},{"location":"BGFlood/functions/#k","title":"k","text":"<ul> <li>KurgSolver (Kurganov.cu, Kurganov.h)</li> </ul>"},{"location":"BGFlood/functions/#l","title":"l","text":"<ul> <li>LakeAtRest (Testing.cu)</li> <li>log (Write_txtlog.cpp, Write_txtlog.h)</li> </ul>"},{"location":"BGFlood/functions/#m","title":"m","text":"<ul> <li>main (BG_Flood.cu)</li> <li>mainwork (BG_Flood.cu, BG_Flood.h)</li> <li>maskbnd (Boundary.cu, Boundary.h)</li> <li>maskbnd&lt; double &gt; (Boundary.cu)</li> <li>maskbnd&lt; float &gt; (Boundary.cu)</li> <li>maskbndGPUFluxbot (Boundary.cu, Boundary.h)</li> <li>maskbndGPUFluxbot&lt; double &gt; (Boundary.cu)</li> <li>maskbndGPUFluxbot&lt; float &gt; (Boundary.cu)</li> <li>maskbndGPUFluxleft (Boundary.cu, Boundary.h)</li> <li>maskbndGPUFluxleft&lt; double &gt; (Boundary.cu)</li> <li>maskbndGPUFluxleft&lt; float &gt; (Boundary.cu)</li> <li>maskbndGPUFluxright (Boundary.cu, Boundary.h)</li> <li>maskbndGPUFluxright&lt; double &gt; (Boundary.cu)</li> <li>maskbndGPUFluxright&lt; float &gt; (Boundary.cu)</li> <li>maskbndGPUFluxtop (Boundary.cu, Boundary.h)</li> <li>maskbndGPUFluxtop&lt; double &gt; (Boundary.cu)</li> <li>maskbndGPUFluxtop&lt; float &gt; (Boundary.cu)</li> <li>maskbndGPUbot (Boundary.cu, Boundary.h)</li> <li>maskbndGPUbot&lt; double &gt; (Boundary.cu)</li> <li>maskbndGPUbot&lt; float &gt; (Boundary.cu)</li> <li>maskbndGPUleft (Boundary.cu, Boundary.h)</li> <li>maskbndGPUleft&lt; double &gt; (Boundary.cu)</li> <li>maskbndGPUleft&lt; float &gt; (Boundary.cu)</li> <li>maskbndGPUright (Boundary.cu, Boundary.h)</li> <li>maskbndGPUright&lt; double &gt; (Boundary.cu)</li> <li>maskbndGPUright&lt; float &gt; (Boundary.cu)</li> <li>maskbndGPUtop (Boundary.cu, Boundary.h)</li> <li>maskbndGPUtop&lt; double &gt; (Boundary.cu)</li> <li>maskbndGPUtop&lt; float &gt; (Boundary.cu)</li> <li>manningfriction (Friction.cu, Friction.h)</li> <li>MainLoop (Mainloop.cu, Mainloop.h)</li> <li>MainLoop&lt; double &gt; (Mainloop.cu)</li> <li>MainLoop&lt; float &gt; (Mainloop.cu)</li> <li>mapoutput (Mainloop.cu)</li> <li>max_Norm_CPU (Meanmax.cu)</li> <li>max_Norm_GPU (Meanmax.cu, Meanmax.h)</li> <li>max_hU_CPU (Meanmax.cu)</li> <li>max_hU_GPU (Meanmax.cu, Meanmax.h)</li> <li>max_varCPU (Meanmax.cu)</li> <li>max_varGPU (Meanmax.cu, Meanmax.h)</li> <li>memloc (MemManagement.cu, MemManagement.h)</li> <li>MakValleyBathy (Testing.cu)</li> <li>MassConserveSteepSlope (Testing.cu, Testing.h)</li> <li>MassConserveSteepSlope&lt; double &gt; (Testing.cu)</li> <li>MassConserveSteepSlope&lt; float &gt; (Testing.cu)</li> <li>minmod2 (Util_CPU.cu, Util_CPU.h)</li> </ul>"},{"location":"BGFlood/functions/#n","title":"n","text":"<ul> <li>noslipbnd (Boundary.cu, Boundary.h)</li> <li>noslipbndQ (Boundary.cu, Boundary.h)</li> <li>nc_get_var1_T (Read_netcdf.cu, Read_netcdf.h)</li> <li>nc_get_var_T (Read_netcdf.cu, Read_netcdf.h)</li> <li>nc_get_vara_T (Read_netcdf.cu, Read_netcdf.h)</li> <li>nextPow2 (Util_CPU.cu, Util_CPU.h)</li> </ul>"},{"location":"BGFlood/functions/#o","title":"o","text":"<ul> <li>OBBdetect (Util_CPU.cu, Util_CPU.h)</li> </ul>"},{"location":"BGFlood/functions/#p","title":"p","text":"<ul> <li>ProlongationElevation (ConserveElevation.cu, ConserveElevation.h)</li> <li>ProlongationElevationGH (ConserveElevation.cu)</li> <li>pointoutputstep (Mainloop.cu)</li> <li>printstatus (Mainloop.cu, Mainloop.h)</li> <li>pressureML (Multilayer.cu, Multilayer.h)</li> <li>pressureML&lt; double &gt; (Multilayer.cu)</li> <li>pressureML&lt; float &gt; (Multilayer.cu)</li> <li>PolygonIntersect (Poly.cu)</li> </ul>"},{"location":"BGFlood/functions/#r","title":"r","text":"<ul> <li>refine (Adaptation.cu, Adaptation.h)</li> <li>refine&lt; double &gt; (Adaptation.cu)</li> <li>refine&lt; float &gt; (Adaptation.cu)</li> <li>refinesanitycheck (Adaptation.cu, Adaptation.h)</li> <li>reducemin3 (Advection.cu, Advection.h)</li> <li>RevertProlongationElevation (ConserveElevation.cu)</li> <li>reset_var (FlowGPU.cu, FlowGPU.h)</li> <li>reset_var&lt; double &gt; (FlowGPU.cu)</li> <li>reset_var&lt; float &gt; (FlowGPU.cu)</li> <li>RecalculateZs (Halo.cu, Halo.h)</li> <li>RecalculateZs&lt; double &gt; (Halo.cu)</li> <li>RecalculateZs&lt; float &gt; (Halo.cu)</li> <li>RecalculateZsGPU (Halo.cu, Halo.h)</li> <li>RecalculateZsGPU&lt; double &gt; (Halo.cu)</li> <li>RecalculateZsGPU&lt; float &gt; (Halo.cu)</li> <li>Recalculatehh (Halo.cu, Halo.h)</li> <li>Recalculatehh&lt; double &gt; (Halo.cu)</li> <li>Recalculatehh&lt; float &gt; (Halo.cu)</li> <li>refine_linear (Halo.cu, Halo.h)</li> <li>refine_linear&lt; double &gt; (Halo.cu)</li> <li>refine_linear&lt; float &gt; (Halo.cu)</li> <li>refine_linearGPU (Halo.cu, Halo.h)</li> <li>refine_linearGPU&lt; double &gt; (Halo.cu)</li> <li>refine_linearGPU&lt; float &gt; (Halo.cu)</li> <li>refine_linear_Bot (Halo.cu, Halo.h)</li> <li>refine_linear_Bot&lt; double &gt; (Halo.cu)</li> <li>refine_linear_Bot&lt; float &gt; (Halo.cu)</li> <li>refine_linear_BotGPU (Halo.cu)</li> <li>refine_linear_BotGPU&lt; double &gt; (Halo.cu)</li> <li>refine_linear_BotGPU&lt; float &gt; (Halo.cu)</li> <li>refine_linear_Left (Halo.cu, Halo.h)</li> <li>refine_linear_Left&lt; double &gt; (Halo.cu)</li> <li>refine_linear_Left&lt; float &gt; (Halo.cu)</li> <li>refine_linear_LeftGPU (Halo.cu)</li> <li>refine_linear_LeftGPU&lt; double &gt; (Halo.cu)</li> <li>refine_linear_LeftGPU&lt; float &gt; (Halo.cu)</li> <li>refine_linear_Right (Halo.cu, Halo.h)</li> <li>refine_linear_Right&lt; double &gt; (Halo.cu)</li> <li>refine_linear_Right&lt; float &gt; (Halo.cu)</li> <li>refine_linear_RightGPU (Halo.cu)</li> <li>refine_linear_RightGPU&lt; double &gt; (Halo.cu)</li> <li>refine_linear_RightGPU&lt; float &gt; (Halo.cu)</li> <li>refine_linear_Top (Halo.cu, Halo.h)</li> <li>refine_linear_Top&lt; double &gt; (Halo.cu)</li> <li>refine_linear_Top&lt; float &gt; (Halo.cu)</li> <li>refine_linear_TopGPU (Halo.cu)</li> <li>refine_linear_TopGPU&lt; double &gt; (Halo.cu)</li> <li>refine_linear_TopGPU&lt; float &gt; (Halo.cu)</li> <li>readhotstartfile (InitEvolv.cu, InitEvolv.h)</li> <li>readhotstartfile&lt; double &gt; (InitEvolv.cu)</li> <li>readhotstartfile&lt; float &gt; (InitEvolv.cu)</li> <li>readhotstartfileBG (InitEvolv.cu)</li> <li>RectCornerBlk (InitialConditions.cu)</li> <li>resetmaxCPU (Meanmax.cu)</li> <li>resetmaxGPU (Meanmax.cu)</li> <li>resetmeanCPU (Meanmax.cu)</li> <li>resetmeanCPU&lt; double &gt; (Meanmax.cu)</li> <li>resetmeanCPU&lt; float &gt; (Meanmax.cu)</li> <li>resetmeanGPU (Meanmax.cu)</li> <li>resetmeanGPU&lt; double &gt; (Meanmax.cu)</li> <li>resetmeanGPU&lt; float &gt; (Meanmax.cu)</li> <li>resetmeanmax (Meanmax.cu, Meanmax.h)</li> <li>resetmeanmax&lt; double &gt; (Meanmax.cu)</li> <li>resetmeanmax&lt; float &gt; (Meanmax.cu)</li> <li>resetvalCPU (Meanmax.cu)</li> <li>resetvalCPU&lt; double &gt; (Meanmax.cu)</li> <li>resetvalCPU&lt; float &gt; (Meanmax.cu)</li> <li>resetvalGPU (Meanmax.cu, Meanmax.h)</li> <li>resetvalGPU&lt; double &gt; (Meanmax.cu)</li> <li>resetvalGPU&lt; float &gt; (Meanmax.cu)</li> <li>ReallocArray (MemManagement.cu, MemManagement.h)</li> <li>ReallocArray&lt; double &gt; (MemManagement.cu)</li> <li>ReallocArray&lt; float &gt; (MemManagement.cu)</li> <li>ReallocArray&lt; int &gt; (MemManagement.cu)</li> <li>readCRSfrombathy (ReadForcing.cu)</li> <li>readDynforcing (ReadForcing.cu, ReadForcing.h)</li> <li>readFlowfile (ReadForcing.cu, ReadForcing.h)</li> <li>readINfileUNI (ReadForcing.cu, ReadForcing.h)</li> <li>readNestfile (ReadForcing.cu, ReadForcing.h)</li> <li>readPolygon (ReadForcing.cu, ReadForcing.h)</li> <li>readWLfile (ReadForcing.cu, ReadForcing.h)</li> <li>readWNDfileUNI (ReadForcing.cu, ReadForcing.h)</li> <li>readXBbathy (ReadForcing.cu, ReadForcing.h)</li> <li>readXBbathy&lt; float &gt; (ReadForcing.cu)</li> <li>readXBbathy&lt; int &gt; (ReadForcing.cu)</li> <li>readbathyASCHead (ReadForcing.cu, ReadForcing.h)</li> <li>readbathyASCzb (ReadForcing.cu, ReadForcing.h)</li> <li>readbathyASCzb&lt; float &gt; (ReadForcing.cu)</li> <li>readbathyASCzb&lt; int &gt; (ReadForcing.cu)</li> <li>readbathyHeadMD (ReadForcing.cu, ReadForcing.h)</li> <li>readbathyMD (ReadForcing.cu, ReadForcing.h)</li> <li>readbathyMD&lt; float &gt; (ReadForcing.cu)</li> <li>readbathyMD&lt; int &gt; (ReadForcing.cu)</li> <li>readbathydata (ReadForcing.cu)</li> <li>readbndfile (ReadForcing.cu, ReadForcing.h)</li> <li>readbndpolysegment (ReadForcing.cu, ReadForcing.h)</li> <li>readforcing (ReadForcing.cu, ReadForcing.h)</li> <li>readforcing&lt; float &gt; (ReadForcing.cu)</li> <li>readforcingdata (ReadForcing.cu, ReadForcing.h)</li> <li>readforcingdata&lt; StaticForcingP&lt; float &gt; &gt; (ReadForcing.cu)</li> <li>readforcingdata&lt; StaticForcingP&lt; int &gt; &gt; (ReadForcing.cu)</li> <li>readforcingdata&lt; deformmap&lt; float &gt; &gt; (ReadForcing.cu)</li> <li>readforcinghead (ReadForcing.cu, ReadForcing.h)</li> <li>readforcinghead&lt; StaticForcingP&lt; float &gt; &gt; (ReadForcing.cu)</li> <li>readforcinghead&lt; forcingmap &gt; (ReadForcing.cu)</li> <li>readforcinghead&lt; inputmap &gt; (ReadForcing.cu)</li> <li>readstaticforcing (ReadForcing.cu, ReadForcing.h)</li> <li>readstaticforcing&lt; StaticForcingP&lt; float &gt; &gt; (ReadForcing.cu)</li> <li>readstaticforcing&lt; StaticForcingP&lt; int &gt; &gt; (ReadForcing.cu)</li> <li>readstaticforcing&lt; deformmap&lt; float &gt; &gt; (ReadForcing.cu)</li> <li>ReadTRangestr (ReadInput.cu, ReadInput.h)</li> <li>ReadToutSTR (ReadInput.cu, ReadInput.h)</li> <li>ReadToutput (ReadInput.cu, ReadInput.h)</li> <li>ReadTvalstr (ReadInput.cu, ReadInput.h)</li> <li>Readparamfile (ReadInput.cu, ReadInput.h)</li> <li>readApproxtimestr (ReadInput.cu, ReadInput.h)</li> <li>readbndline (ReadInput.cu, ReadInput.h)</li> <li>readbndlineside (ReadInput.cu, ReadInput.h)</li> <li>readfileinfo (ReadInput.cu, ReadInput.h)</li> <li>readfileinfo&lt; DynForcingP&lt; float &gt; &gt; (ReadInput.cu)</li> <li>readfileinfo&lt; StaticForcingP&lt; float &gt; &gt; (ReadInput.cu)</li> <li>readfileinfo&lt; deformmap&lt; float &gt; &gt; (ReadInput.cu)</li> <li>readfileinfo&lt; forcingmap &gt; (ReadInput.cu)</li> <li>readfileinfo&lt; inputmap &gt; (ReadInput.cu)</li> <li>readparambool (ReadInput.cu, ReadInput.h)</li> <li>readparamstr (ReadInput.cu, ReadInput.h)</li> <li>read2Dnc (Read_netcdf.cu, Read_netcdf.h)</li> <li>read3Dnc (Read_netcdf.cu, Read_netcdf.h)</li> <li>readATMstep (Read_netcdf.cu, Read_netcdf.h)</li> <li>readWNDstep (Read_netcdf.cu, Read_netcdf.h)</li> <li>readgridncsize (Read_netcdf.cu, Read_netcdf.h)</li> <li>readgridncsize&lt; DynForcingP&lt; float &gt; &gt; (Read_netcdf.cu)</li> <li>readgridncsize&lt; StaticForcingP&lt; float &gt; &gt; (Read_netcdf.cu)</li> <li>readgridncsize&lt; StaticForcingP&lt; int &gt; &gt; (Read_netcdf.cu)</li> <li>readgridncsize&lt; deformmap&lt; float &gt; &gt; (Read_netcdf.cu)</li> <li>readgridncsize&lt; forcingmap &gt; (Read_netcdf.cu)</li> <li>readgridncsize&lt; inputmap &gt; (Read_netcdf.cu)</li> <li>readncslev1 (Read_netcdf.cu, Read_netcdf.h)</li> <li>readncslev1&lt; double &gt; (Read_netcdf.cu)</li> <li>readncslev1&lt; float &gt; (Read_netcdf.cu)</li> <li>readnctime (Read_netcdf.cu, Read_netcdf.h)</li> <li>readnctime2 (Read_netcdf.cu, Read_netcdf.h)</li> <li>readnczb (Read_netcdf.cu, Read_netcdf.h)</li> <li>readvardata (Read_netcdf.cu, Read_netcdf.h)</li> <li>readvardata&lt; double &gt; (Read_netcdf.cu)</li> <li>readvardata&lt; float &gt; (Read_netcdf.cu)</li> <li>readvardata&lt; int &gt; (Read_netcdf.cu)</li> <li>readvarinfo (Read_netcdf.cu, Read_netcdf.h)</li> <li>Rainlossestest (Testing.cu, Testing.h)</li> <li>Raintest (Testing.cu, Testing.h)</li> <li>Raintestinput (Testing.cu, Testing.h)</li> <li>Raintestmap (Testing.cu, Testing.h)</li> <li>Raintestmap&lt; double &gt; (Testing.cu)</li> <li>Raintestmap&lt; float &gt; (Testing.cu)</li> <li>RiverOnBoundary (Testing.cu)</li> <li>RiverVolumeAdapt (Testing.cu)</li> <li>Rivertest (Testing.cu, Testing.h)</li> <li>Rivertest&lt; double &gt; (Testing.cu)</li> <li>Rivertest&lt; float &gt; (Testing.cu)</li> <li>reductiontest (Testing.cu)</li> <li>reductiontest&lt; double &gt; (Testing.cu)</li> <li>reductiontest&lt; float &gt; (Testing.cu)</li> <li>readinputtimetxt (utctime.cu, utctime.h)</li> </ul>"},{"location":"BGFlood/functions/#s","title":"s","text":"<ul> <li>smartfriction (Friction.cu, Friction.h)</li> <li>setedges (GridManip.cu, GridManip.h)</li> <li>setedges&lt; double &gt; (GridManip.cu)</li> <li>setedges&lt; float &gt; (GridManip.cu)</li> <li>setedgessideBT (GridManip.cu)</li> <li>setedgessideLR (GridManip.cu)</li> <li>storeTSout (Mainloop.cu, Mainloop.h)</li> <li>SegmentIntersect (Poly.cu)</li> <li>setendtime (ReadInput.cu, ReadInput.h)</li> <li>split (ReadInput.cu, ReadInput.h)</li> <li>split_full (ReadInput.cu, ReadInput.h)</li> <li>SetupGPU (Setup_GPU.cu, Setup_GPU.h)</li> <li>SetupGPU&lt; double &gt; (Setup_GPU.cu)</li> <li>SetupGPU&lt; float &gt; (Setup_GPU.cu)</li> <li>spharea (Spherical.cu, Spherical.h)</li> <li>signof (Util_CPU.cu, Util_CPU.h)</li> <li>Save2Netcdf (Write_netcdf.cu, Write_netcdf.h)</li> <li>Save2Netcdf&lt; double &gt; (Write_netcdf.cu)</li> <li>Save2Netcdf&lt; float &gt; (Write_netcdf.cu)</li> <li>SaveParamtolog (Write_txtlog.cpp, Write_txtlog.h)</li> <li>saveparam2netCDF (Write_txtlog.cpp, Write_txtlog.h)</li> </ul>"},{"location":"BGFlood/functions/#t","title":"t","text":"<ul> <li>Thresholdcriteria (AdaptCriteria.cu, AdaptCriteria.h)</li> <li>Thresholdcriteria&lt; double &gt; (AdaptCriteria.cu)</li> <li>Thresholdcriteria&lt; float &gt; (AdaptCriteria.cu)</li> <li>targetlevelcriteria (AdaptCriteria.cu)</li> <li>targetlevelcriteria&lt; double &gt; (AdaptCriteria.cu)</li> <li>targetlevelcriteria&lt; float &gt; (AdaptCriteria.cu)</li> <li>timestepreductionCPU (Advection.cu, Advection.h)</li> <li>TheresholdVelCPU (Friction.cu, Friction.h)</li> <li>TheresholdVelCPU&lt; double &gt; (Friction.cu)</li> <li>TheresholdVelCPU&lt; float &gt; (Friction.cu)</li> <li>TheresholdVelGPU (Friction.cu, Friction.h)</li> <li>TheresholdVelGPU&lt; double &gt; (Friction.cu)</li> <li>TheresholdVelGPU&lt; float &gt; (Friction.cu)</li> <li>ThresholdVelocity (Friction.cu, Friction.h)</li> <li>test_SegmentIntersect (Poly.cu)</li> <li>test_intersectpoly (Poly.cu)</li> <li>test_wninpoly (Poly.cu)</li> <li>trim (ReadInput.cu, ReadInput.h)</li> <li>TestAIObnd (Testing.cu)</li> <li>TestFirsthalfstep (Testing.cu)</li> <li>TestFlexibleOutputTimes (Testing.cu, Testing.h)</li> <li>TestGradientSpeed (Testing.cu)</li> <li>TestHaloSpeed (Testing.cu)</li> <li>TestInstability (Testing.cu)</li> <li>TestMultiBathyRough (Testing.cu, Testing.h)</li> <li>TestPinMem (Testing.cu)</li> <li>TestPinMem&lt; double &gt; (Testing.cu)</li> <li>TestPinMem&lt; float &gt; (Testing.cu)</li> <li>Testing (Testing.cu, Testing.h)</li> <li>Testing&lt; double &gt; (Testing.cu)</li> <li>Testing&lt; float &gt; (Testing.cu)</li> <li>TestingOutput (Testing.cu, Testing.h)</li> <li>TestingOutput&lt; double &gt; (Testing.cu)</li> <li>TestingOutput&lt; float &gt; (Testing.cu)</li> <li>Testzbinit (Testing.cu)</li> <li>ThackerBathy (Testing.cu)</li> <li>ThackerLakeAtRest (Testing.cu)</li> <li>ThackerLakeAtRest&lt; double &gt; (Testing.cu)</li> <li>ThackerLakeAtRest&lt; float &gt; (Testing.cu)</li> <li>testButtingerX (Testing.cu)</li> <li>testboundaries (Testing.cu, Testing.h)</li> <li>testkurganovX (Testing.cu)</li> <li>testime1 (utctime.cu, utctime.h)</li> <li>testime2 (utctime.cu, utctime.h)</li> <li>timegm (utctime.cu)</li> </ul>"},{"location":"BGFlood/functions/#u","title":"u","text":"<ul> <li>updateEVCPU (Advection.cu, Advection.h)</li> <li>updateEVCPU&lt; double &gt; (Advection.cu)</li> <li>updateEVCPU&lt; float &gt; (Advection.cu)</li> <li>updateEVGPU (Advection.cu, Advection.h)</li> <li>updateEVGPU&lt; double &gt; (Advection.cu)</li> <li>updateEVGPU&lt; float &gt; (Advection.cu)</li> <li>updateKurgXATMCPU (Kurganov.cu, Kurganov.h)</li> <li>updateKurgXATMCPU&lt; double &gt; (Kurganov.cu)</li> <li>updateKurgXATMCPU&lt; float &gt; (Kurganov.cu)</li> <li>updateKurgXATMGPU (Kurganov.cu, Kurganov.h)</li> <li>updateKurgXATMGPU&lt; double &gt; (Kurganov.cu)</li> <li>updateKurgXATMGPU&lt; float &gt; (Kurganov.cu)</li> <li>updateKurgXCPU (Kurganov.cu, Kurganov.h)</li> <li>updateKurgXCPU&lt; double &gt; (Kurganov.cu)</li> <li>updateKurgXCPU&lt; float &gt; (Kurganov.cu)</li> <li>updateKurgXGPU (Kurganov.cu, Kurganov.h)</li> <li>updateKurgXGPU&lt; double &gt; (Kurganov.cu)</li> <li>updateKurgXGPU&lt; float &gt; (Kurganov.cu)</li> <li>updateKurgYATMCPU (Kurganov.cu, Kurganov.h)</li> <li>updateKurgYATMCPU&lt; double &gt; (Kurganov.cu)</li> <li>updateKurgYATMCPU&lt; float &gt; (Kurganov.cu)</li> <li>updateKurgYATMGPU (Kurganov.cu, Kurganov.h)</li> <li>updateKurgYATMGPU&lt; double &gt; (Kurganov.cu)</li> <li>updateKurgYATMGPU&lt; float &gt; (Kurganov.cu)</li> <li>updateKurgYCPU (Kurganov.cu, Kurganov.h)</li> <li>updateKurgYCPU&lt; double &gt; (Kurganov.cu)</li> <li>updateKurgYCPU&lt; float &gt; (Kurganov.cu)</li> <li>updateKurgYGPU (Kurganov.cu, Kurganov.h)</li> <li>updateKurgYGPU&lt; double &gt; (Kurganov.cu)</li> <li>updateKurgYGPU&lt; float &gt; (Kurganov.cu)</li> <li>updateBnd (Mainloop.cu)</li> <li>UpdateButtingerXCPU (Reimann.cu, Reimann.h)</li> <li>UpdateButtingerXGPU (Reimann.cu, Reimann.h)</li> <li>UpdateButtingerYCPU (Reimann.cu, Reimann.h)</li> <li>UpdateButtingerYGPU (Reimann.cu, Reimann.h)</li> <li>updateforcing (Updateforcing.cu, Updateforcing.h)</li> <li>updateforcing&lt; double &gt; (Updateforcing.cu)</li> <li>updateforcing&lt; float &gt; (Updateforcing.cu)</li> </ul>"},{"location":"BGFlood/functions/#v","title":"v","text":"<ul> <li>VertAdd (Poly.cu)</li> <li>VertSub (Poly.cu)</li> <li>ValleyBathy (Testing.cu)</li> <li>vectoroffsetGPU (Testing.cu)</li> </ul>"},{"location":"BGFlood/functions/#w","title":"w","text":"<ul> <li>WetDryProlongation (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryProlongation&lt; double &gt; (ConserveElevation.cu)</li> <li>WetDryProlongation&lt; float &gt; (ConserveElevation.cu)</li> <li>WetDryProlongationGPU (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryProlongationGPU&lt; double &gt; (ConserveElevation.cu)</li> <li>WetDryProlongationGPU&lt; float &gt; (ConserveElevation.cu)</li> <li>WetDryProlongationGPUBot (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryProlongationGPULeft (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryProlongationGPURight (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryProlongationGPUTop (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryRestriction (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryRestriction&lt; double &gt; (ConserveElevation.cu)</li> <li>WetDryRestriction&lt; float &gt; (ConserveElevation.cu)</li> <li>WetDryRestrictionGPU (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryRestrictionGPU&lt; double &gt; (ConserveElevation.cu)</li> <li>WetDryRestrictionGPU&lt; float &gt; (ConserveElevation.cu)</li> <li>WetDryRestrictionGPUBot (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryRestrictionGPULeft (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryRestrictionGPURight (ConserveElevation.cu, ConserveElevation.h)</li> <li>WetDryRestrictionGPUTop (ConserveElevation.cu, ConserveElevation.h)</li> <li>wetdryrestriction (ConserveElevation.cu, ConserveElevation.h)</li> <li>wetdryrestriction&lt; double &gt; (ConserveElevation.cu)</li> <li>wetdryrestriction&lt; float &gt; (ConserveElevation.cu)</li> <li>WetsloperesetCPU (Gradients.cu)</li> <li>WetsloperesetHaloBotCPU (Gradients.cu)</li> <li>WetsloperesetHaloBotGPU (Gradients.cu, Gradients.h)</li> <li>WetsloperesetHaloLeftCPU (Gradients.cu)</li> <li>WetsloperesetHaloLeftGPU (Gradients.cu, Gradients.h)</li> <li>WetsloperesetHaloRightCPU (Gradients.cu)</li> <li>WetsloperesetHaloRightGPU (Gradients.cu, Gradients.h)</li> <li>WetsloperesetHaloTopCPU (Gradients.cu)</li> <li>WetsloperesetHaloTopGPU (Gradients.cu, Gradients.h)</li> <li>WetsloperesetXGPU (Gradients.cu, Gradients.h)</li> <li>WetsloperesetYGPU (Gradients.cu, Gradients.h)</li> <li>warmstart (InitEvolv.cu, InitEvolv.h)</li> <li>warmstartold (InitEvolv.cu)</li> <li>wn_PnPoly (Poly.cu, Poly.h)</li> <li>wn_PnPoly&lt; double &gt; (Poly.cu)</li> <li>wn_PnPoly&lt; float &gt; (Poly.cu)</li> <li>write2dvarnc (Write_netcdf.cu, Write_netcdf.h)</li> <li>write3dvarnc (Write_netcdf.cu, Write_netcdf.h)</li> <li>writenctimestep (Write_netcdf.cu, Write_netcdf.h)</li> <li>writencvarstepBUQ (Write_netcdf.cu, Write_netcdf.h)</li> <li>writencvarstepBUQ&lt; double &gt; (Write_netcdf.cu)</li> <li>writencvarstepBUQ&lt; float &gt; (Write_netcdf.cu)</li> <li>writencvarstepBUQlev (Write_netcdf.cu)</li> <li>writencvarstepBUQlev&lt; double &gt; (Write_netcdf.cu)</li> <li>writencvarstepBUQlev&lt; float &gt; (Write_netcdf.cu)</li> <li>write_text_to_log_file (Write_txtlog.cpp, Write_txtlog.h)</li> </ul>"},{"location":"BGFlood/functions/#x","title":"x","text":"<ul> <li>XiafrictionCPU (Friction.cu, Friction.h)</li> <li>XiafrictionCPU&lt; double &gt; (Friction.cu)</li> <li>XiafrictionCPU&lt; float &gt; (Friction.cu)</li> <li>XiafrictionGPU (Friction.cu, Friction.h)</li> <li>XiafrictionGPU&lt; double &gt; (Friction.cu)</li> <li>XiafrictionGPU&lt; float &gt; (Friction.cu)</li> <li>xprod (Poly.cu)</li> </ul>"},{"location":"BGFlood/functions/#z","title":"z","text":"<ul> <li>ZoneOutputTest (Testing.cu, Testing.h)</li> <li>ZoneOutputTest&lt; double &gt; (Testing.cu)</li> <li>ZoneOutputTest&lt; float &gt; (Testing.cu)</li> </ul>"},{"location":"BGFlood/macros/","title":"Macros","text":""},{"location":"BGFlood/macros/#macros","title":"Macros","text":""},{"location":"BGFlood/macros/#a","title":"a","text":"<ul> <li>ALIGN_UP (MemManagement.cu)</li> </ul>"},{"location":"BGFlood/macros/#m","title":"m","text":"<ul> <li>MEMORY_ALIGNMENT (MemManagement.cu)</li> </ul>"},{"location":"BGFlood/macros/#p","title":"p","text":"<ul> <li>pi (General.h)</li> </ul>"},{"location":"BGFlood/variables/","title":"Variables","text":""},{"location":"BGFlood/variables/#variables","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"BGFlood/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}